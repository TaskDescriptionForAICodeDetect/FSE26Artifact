[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> g[150005];\nlong double d[150005];\n\nvoid dfs1(int cur, int par) {\n    int cnt = (int)g[cur].size() - (par != -1);\n    if (cnt == 0) return;\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs1(nex, cur);\n        d[cur] += (d[nex] + 1) / cnt;\n    }\n}\n\nlong double ans[150005];\n\nvoid dfs2(int cur, long double d_par, int par) {\n    int cnt = g[cur].size();\n    for (int nex : g[cur]) {\n        if (nex == par) ans[cur] += d_par + 1;\n        else ans[cur] += d[nex] + 1;\n    }\n\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs2(nex, (ans[cur] - d[nex] - 1) / (cnt - (par != -1)), cur);\n    }\n    ans[cur] /= cnt;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << setprecision(20) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[150000];\n\n\ndouble dfs(int cur, int prev, double p, int depth){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return depth*p;\n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        ret+=dfs(e,cur,p/c,depth+1);\n    }\n    return ret;\n}\n\n//木の直径 verified AOJ GRL_5_A\n#define MAX_V 150000\n\npii dfs(int prev, int v, const vector<int> graph[MAX_V]){   //searching farthest node\n    pii r(0,v);\n    \n    rep(i,graph[v].size()){\n        int e = graph[v][i];\n        if(e == prev) continue;\n        pii tmp = dfs(v,e,graph);\n        tmp.first += 1;\n        if(r.first < tmp.first) r = tmp;\n    }\n    return r;\n}\n\npii diameter( const vector<int> graph[MAX_V] ) {\n    pii r = dfs(-1, 0, graph);\n    pii t = dfs(-1, r.second, graph);\n    return pii(r.second,t.second);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    \n    if(n<=1000){\n        rep(i,n){\n            printf(\"%.20lf\\n\",dfs(i,-1,1,0));\n        }\n    }else{\n        pii res = diameter(G);\n        rep(i,n){\n            if(i!=res.first && i!=res.second){\n                printf(\"%.20lf\\n\",(n-1)/2.0);\n            }else{\n                printf(\"%.20lf\\n\",(n-1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N;\nvector<int> V[150010];\ndouble ans[150010];\ndouble s[150010];\n\nvoid dfs(int p , int q){\n\tfor(int u : V[q]){\n\t\tif(p == u) continue;\n\t\tdfs(q,u);\n\t\tif((int)V[u].size() > 1) s[q] += s[u] / (V[u].size()-1) + 1.0;\n\t\telse s[q] += 1.0;\n\t}\n\t//printf(\"  %d %f\\n\" , q , s[q]);\n}\n\nvoid dfs2(int p , int q){\n\tans[q] = s[q] / V[q].size();\n\t//printf(\"    %d %f\\n\" , q , s[q]);\n\tfor(int u : V[q]){\n\t\tif(p == u) continue;\n\t\tif((int)V[q].size() > 1) s[u] += (s[q] - ((int)V[u].size() > 1 ? s[u] / (V[u].size()-1) : 0.0) - 1.0) / (V[q].size()-1) + 1.0;\n\t\telse s[u] += 1.0;\n\t\tdfs2(q,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\tif(N == 1){\n\t\tprintf(\"0.0\\n\");\n\t\treturn 0;\n\t}\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tscanf(\"%d%d\" , &a , &b);\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tdfs(-1,1);\n\tdfs2(-1,1);\n\trepp(i,1,N+1){\n\t\tprintf(\"%.9f\\n\" , ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\nconst ll INF = 1e16;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n//--------------------------------------------------------------------------------//\nconst ll MAX_SIZE = 150005;\nll N;\nvvc<ll> G(MAX_SIZE);\nld dp[MAX_SIZE], ans[MAX_SIZE];\nll T[MAX_SIZE];\n\nvoid dfs1(ll now, ll parent){\n    ll nowsize = 1;\n    ld tmpv = 0;\n    ld deg = (parent == -1 ? G[now].size() : G[now].size() - 1);\n    for(auto& to: G[now]){\n        if (parent == to) continue;\n        \n        dfs1(to, now);\n        nowsize += T[to];\n\n        //遷移させる値の処理\n        tmpv += (dp[to] + 1);\n    }\n\n    if(deg!=0) tmpv /= deg;\n    dp[now] = tmpv;\n    T[now] = nowsize;\n    return;\n}\n \nvoid dfs2(ll now, ll parent, ld pv){ //pv:親から受け取る値\n    ll nowsize = T[now];\n    ld tmpv = pv, degsize = G[now].size();\n\n    if (parent != -1) tmpv = (tmpv + (degsize - 1) * dp[now]) / (ld)degsize;\n\n    ans[now] = tmpv;\n    \n    for(auto& to: G[now]){\n        if(to!=parent){\n            dfs2(to, now, (degsize * ans[now] - dp[to] - 1)/max(1.0L,(degsize-1))+1);\n        }\n    }\n \n    return;\n}\n\nint main() {\n    init();\n    ll N;\n    cin >> N;\n    rep(i,N-1){\n        ll a, b;\n        cin >> a >> b;\n        a--, b--;\n        G[a].eb(b), G[b].eb(a);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, -1, dp[0]);\n\n    rep(i, N) cout << ans[i] << \"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ndouble E[150000],ANS[1500000];\nvector<int> g[150000];\n\ndouble dfs1(int idx,int par)\n{\n\tdouble cnt = 0;\n\tfor(auto &i:g[idx])\n\t{\n\t\tif(par==i)continue;\n\t\tE[idx] += dfs1(i,idx);\n\t\tcnt++;\n\t}\n\tif(cnt!=0)E[idx] /= cnt;\n\treturn E[idx]+1.0;\n}\n\nvoid dfs2(int idx,double d_par,int par)\n{\n\tdouble sum = 0;\n\tint cnt = 0;\n\tif(idx!=0)cnt++;\n\tfor(auto &i:g[idx])\n\t{\n\t\tif(i==par)continue;\n\t\tsum += E[i];\n\t\tcnt ++;\n\t}\n\tif(idx!=0)sum += d_par ;\n\t//cout<<idx<<' '<<d_par<<' '<<sum<<' '<<cnt<<endl;\n\tANS[idx] = (sum+(double)cnt)/(double)(cnt);\n\t// ANS[idx] = sum;\n\tfor(auto &i:g[idx])\n\t{\n\t\tif(i==par)continue;\n\t\tif(cnt!=1)dfs2(i,(sum-E[i]+cnt-1)/(cnt-1),idx);\n\t\telse dfs2(i,(sum-E[i])/cnt,idx);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0;i<n-1;i++)\n\t{\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx--;y--;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tdfs1(0,-1);\n\tdfs2(0,0,-1);\n\tfor(int i = 0;i<n;i++)printf(\"%.10lf\\n\",ANS[i]);//cout<<endl;\n\t//for(int i = 0;i<n;i++)cout<<E[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\ndouble *dp[150005];\nbool *used[150005];\nvector<int> V[150005];\n\ndouble f(int x, int p) {\n\tif (used[x][p]) return dp[x][p];\n\tdouble ans = 0;\n\tfor (int i = 0; i < V[x].size(); i++) {\n\t\tif (i == p) continue;\n\t\tans += f(V[x][i], lower_bound(V[V[x][i]].begin(), V[V[x][i]].end(), x) - V[V[x][i]].begin()) / (V[x].size() - 1);\n\t}\n\tused[x][p] = 1;\n\treturn dp[x][p] = ans + 1;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) sort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < N; i++) {\n\t\tdp[i] = new double[V[i].size()];\n\t\tused[i] = new bool[V[i].size()];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j < V[i].size(); j++) ans += f(V[i][j], lower_bound(V[V[i][j]].begin(), V[V[i][j]].end(), i) - V[V[i][j]].begin()) / V[i].size();\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint *dp[150005];\nvector<int> V[150005];\n\ndouble f(int x, int p) {\n\tif (dp[x][p] != -1) return dp[x][p];\n\tdouble ans = 0;\n\tfor (int i = 0; i < V[x].size(); i++) {\n\t\tif (i == p) continue;\n\t\tans += f(V[x][i], lower_bound(V[V[x][i]].begin(), V[V[x][i]].end(), x) - V[V[x][i]].begin()) / (V[x].size() - 1);\n\t}\n\treturn dp[x][p] = ans + 1;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) sort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < N; i++) {\n\t\tdp[i] = new int[V[i].size()];\n\t\tmemset(dp[i], -1, sizeof(dp[i]));\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j < V[i].size(); j++) ans += f(V[i][j], lower_bound(V[V[i][j]].begin(), V[V[i][j]].end(), i) - V[V[i][j]].begin()) / V[i].size();\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=15e4;\nvector<int> G[MAX_N];\nint N;\nunordered_map<int,double> dp[MAX_N];\n\ndouble dfs(int v,int p){\n\tif(dp[v].find(p)!=dp[v].end()){\n\t\treturn dp[v][p];\n\t}\n\tint cnt=0;\n\tfor(auto e:G[v]){\n\t\tif(e!=p){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdouble ret;\n\tif(cnt==0){\n\t\tret=0;\n\t}else{\n\t\tret=1;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e!=p){\n\t\t\t\tret+=dfs(e,v)/cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[v][p]=ret;\n}\ntypedef pair<int,int> P;\ndouble ans[MAX_N];\nint main(){\n\tcin>>N;\n\tREP(i,N-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tvector<int> per;\n\t{\n\t\tqueue<P> que;\n\t\tque.push(P(0,-1));\n\t\tper.push_back(0);\n\t\twhile(!que.empty()){\n\t\t\tP p=que.front();\n\t\t\tque.pop();\n\t\t\tint v=p.first,q=p.second;\n\t\t\tfor(auto e:G[v]){\n\t\t\t\tif(e!=q){\n\t\t\t\t\tque.push(P(e,v));\n\t\t\t\t\tper.push_back(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,N){\n\t\tans[per[i]]=dfs(per[i],-1);\n\t\tdouble sm=0;\n\t\tfor(auto e:G[per[i]]){\n\t\t\tsm+=dp[e][per[i]];\n\t\t}\n\t\tif((int)G[per[i]].size()==1){\n\t\t\tdp[per[i]][G[per[i]][0]]=0;\n\t\t}else{\n\t\t\tfor(auto e:G[per[i]]){\n\t\t\t\tdp[per[i]][e]=(sm-dp[e][per[i]])/((int)G[per[i]].size()-1)+1;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,N){\n\t\tprintf(\"%.16f\\n\",ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <queue>\n#include <set>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nint make_rooted_tree(std::vector<std::vector<long long int> > &G, long long int N, long long int root_index, std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par);\n// subroutine of make_rooted_tree must not be called in other places\nint sub_make_rooted_tree(std::vector<std::vector<long long int> > &G, long long int N, long long int root_index, std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par);\n\ndouble fill_table1(std::vector<std::vector<long long int> > &G_rooted, long long int index, std::vector<double> &table1);\n\ndouble fill_table2(std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par, long long int index, std::vector<double> &table1, std::vector<double> &table2);\n\nint main(){\n\n  // read problem\n  long long int N, tmp1, tmp2;\n  scanf(\"%lld\", &N);\n  std::vector<std::vector<long long int> > G(N);\n  for(long long int i = 0; i < N-1; i++){\n    scanf(\"%lld%lld\", &tmp1, &tmp2);\n    G[tmp1-1].push_back(tmp2-1);\n    G[tmp2-1].push_back(tmp1-1);\n  }\n\n  \n  // make rooted tree\n  std::vector<std::vector<long long int> > G_rooted(N);\n  std::vector<long long int> par(N);\n\n  std::cerr << \"start make rooted tree\" << std::endl;\n  make_rooted_tree(G, N, 0, G_rooted, par);\n  std::cerr << \"end make rooted tree\" << std::endl;\n\n  /*std::cerr << \"G_rooted\" << std::endl;\n  for(long long int i = 0; i < N; i++){\n    std::cerr << i << \": \";\n    for(long long int j = 0; j < G_rooted[i].size(); j++){\n      std::cerr << G_rooted[i][j] << \" \";\n    }std::cerr << std::endl;\n  }std::cerr << std::endl;*/\n\n  // solve problem for root\n  std::vector<double> table1(N);\n  for(long long int i = 0; i < N; i++){\n    table1[i] = -1.0;\n  }\n  std::cerr << \"start fill table1\" << std::endl;\n  fill_table1(G_rooted, 0, table1);\n  std::cerr << \"end fill table1\" << std::endl;\n  \n  /*std::cerr << \"table1:\" << std::endl;\n  for(long long int i = 0; i < N; i++){\n    std::cerr << table1[i] << \" \";\n  }std::cerr << std::endl;*/\n\n  \n  // solve problem\n  std::vector<double> table2(N);\n  table2[0] = table1[0];\n  for(long long int i = 0; i < G[0].size(); i++){\n    fill_table2(G_rooted, par, G[0][i], table1, table2);\n  }\n\n  std::cerr << \"Answer: \" << std::endl;\n  for(long long int i = 0; i < N; i++){\n    std::cout << std::setprecision(10) << table2[i] << std::endl;\n  }\n\n  return 0;\n}\n\n\nint make_rooted_tree(std::vector<std::vector<long long int> > &G, long long int N, long long int root_index, std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par){\n  // initialize par and call sub_make_rooted_tree\n  par[root_index] = root_index;\n  sub_make_rooted_tree(G, N, root_index, G_rooted, par);\n\n  return 0;\n}\n\nint sub_make_rooted_tree(std::vector<std::vector<long long int> > &G, long long int N, long long int root_index, std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par){\n\n  for(long long int i = 0; i < G[root_index].size(); i++){\n    // for all connected nodes but parent node\n    if(G[root_index][i] != par[root_index]){\n      par[G[root_index][i]] = root_index;\n      G_rooted[root_index].push_back(G[root_index][i]);\n      sub_make_rooted_tree(G, N, G[root_index][i], G_rooted, par);\n    }\n  }\n\n  return 0;\n}\n\ndouble fill_table1(std::vector<std::vector<long long int> > &G_rooted, long long int index, std::vector<double> &table1){\n  if(table1[index] > -0.5){\n    return table1[index];\n  }\n  if(G_rooted[index].size()==0){\n    table1[index] = 0.0;\n    return 0.0;\n  }\n  else{\n    double n_child = G_rooted[index].size();\n    double ans = 0.0;\n    for(int i = 0; i < G_rooted[index].size(); i++){\n      ans += fill_table1(G_rooted, G_rooted[index][i], table1)/n_child;\n    }\n    ans += 1.0;\n    table1[index] = ans;\n    return ans;\n  }\n}\n\ndouble fill_table2(std::vector<std::vector<long long int> > &G_rooted, std::vector<long long int> &par, long long int index, std::vector<double> &table1, std::vector<double> &table2){\n\n  long long int n1, n2;\n  n1 = G_rooted[index].size();\n  double ans = table1[index] * (n1*1.0)/(n1+1.0);\n  double tmp;\n\n  if(par[par[index]] == par[index]){ // par[index] is root\n    n2 = G_rooted[par[index]].size();\n  }\n  else{\n    n2 = G_rooted[par[index]].size()+1; // par[index] is not root\n  }\n\n  if(n2 == 1){ // par[index] is a leaf vertex\n    ans += 1.0/(n1+1.0);\n    table2[index] = ans;\n  }\n  else{\n    tmp = (table2[par[index]] - (table1[index]+1.0)*1.0/n2) * n2/(n2-1.0);\n    ans += (tmp + 1.0)/(n1+1.0);\n  }\n\n  table2[index] = ans;\n  \n\n  for(long long int i = 0; i < G_rooted[index].size(); i++){\n    fill_table2(G_rooted, par, G_rooted[index][i], table1, table2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nint n, u, v;\nvector <int> edge[150005];\ndouble dp[150005];\n\nvoid dfs(int cur, int par) {\n    int sz = edge[cur].size();\n    if (par >= 0) sz--;\n    for (auto child : edge[cur]) {\n        if (child == par) continue;\n        dfs(child, cur);\n        dp[cur] += (dp[child] + 1.0) / (double)sz;\n    }\n}\n\nvoid dfs2(int cur, int par, double par_e) {\n    dp[cur] = 0.0;\n    double sz = (double)(edge[cur].size());\n    for (auto child : edge[cur]) {\n        if (child == par) dp[cur] += (par_e + 1.0) / sz;\n        else dp[cur] += (dp[child] + 1.0) / sz;\n    }\n\n    for (auto child : edge[cur]) {\n        if (child == par) continue;\n        int next_par_e;\n        if (par == -1 && sz == 1.0) next_par_e = 0;\n        else next_par_e = (dp[cur] * sz - (dp[child] + 1.0)) / (sz - 1.0);\n        dfs2(child, cur, next_par_e);\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        cin >> u >> v;\n        u--; v--;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    for (int i = 0; i < n; i++) {\n        cout << fixed << setprecision(12) << dp[i] << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: d.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-20 10:05:23\n***********************************************/\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> a;\n\ndouble dfs(int cur, int par) {\n    double ans = 0;\n    int choice = a[cur].size();\n    if (par != -1) -- choice;\n    for (auto v : a[cur]) {\n        if (v != par) {\n            ans += 1.0 / choice * (1.0 + dfs(v, cur));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    int u, v;\n    a = vector<vector<int>> (n);\n    for (int i = 0; i < n-1; ++ i) {\n        cin >> u >> v;\n        -- u; -- v;\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 0; i < n; ++ i) {\n        cout << dfs(i, -1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n\ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return 0.0;\n\tif(dp[P(prev,now)] >= EPS) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Majk\n */\n\n#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n\tint N;\n\tvector<vector<int>> E;\n\tmap<pii, double> C;\n\n\tdouble count(int u, int v) {\n\t\tif (C.find({u,v}) != C.end()) return C[{u,v}];\n\t\tdouble ans = 0.0;\n\t\tint cnt = 0;\n\n\t\tfor (int w: E[u]) if (v!=w) {\n\t\t\t\t++cnt;\n\t\t\t\tans += 1+count(w,u);\n\t\t\t}\n\n\t\tif (cnt > 0) ans /= cnt;\n\t\treturn C[{u,v}] = ans;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tcin >> N; E.clear(); E.resize(N);\n\t\tC.clear();\n\t\tfor (int i = 0; i < N-1; ++i) {\n\t\t\tint u,v; cin >> u >> v; --u; --v;\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\n\t\tcout << fixed << setprecision(10);\n\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << count(j, -1) << '\\n';\n\t\t}\n\n\t}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[150000];\n\n\ndouble dfs(int cur, int prev, double p, int depth){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return depth*p;\n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        ret+=dfs(e,cur,p/c,depth+1);\n    }\n    return ret;\n}\n\n//木の直径 verified AOJ GRL_5_A\n#define MAX_V 150000\n\npii dfs(int prev, int v, const vector<int> graph[MAX_V]){   //searching farthest node\n    pii r(0,v);\n    \n    rep(i,graph[v].size()){\n        int e = graph[v][i];\n        if(e == prev) continue;\n        pii tmp = dfs(v,e,graph);\n        tmp.first += 1;\n        if(r.first < tmp.first) r = tmp;\n    }\n    return r;\n}\n\npii diameter( const vector<int> graph[MAX_V] ) {\n    pii r = dfs(-1, 0, graph);\n    pii t = dfs(-1, r.second, graph);\n    return pii(r.second,t.second);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    \n    if(n<=1000){\n        rep(i,n){\n            printf(\"%.20lf\\n\",dfs(i,-1,1,0));\n        }\n    }else{\n        pii res = diameter(G);\n        rep(i,n){\n            if(i!=res.first && i!=res.second){\n                \n                printf(\"%.20lf\\n\",(n-1)/2.0);\n            }else{\n                printf(\"%.20lf\\n\",(double)(n-1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nvector<vector<pair<int,double>>>go;\nvector<double>ans;\ndouble dfs(int ter,int per){\n\tdouble ret=0;int cou=0;\n\tfor(auto &it:go[ter]){\n\t\tif(it.fir==per){continue;}\n\t\tcou++;\n\t\tit.sec=dfs(it.fir,ter);\n\t\tret+=it.sec;\n\t}\n\tif(cou==0){return 1;}\n\tcerr<<ret/cou<<endl;\n\treturn ret/cou+1;\n}\nvoid efs(int ter,int per,double wa){\n\tint cou=0;\n\tif(per!=-1){cou=1;}\n\tfor(auto &it:go[ter]){if(it.fir==per){continue;}wa+=it.sec;cou++;}\n\tans[ter]=wa/cou;\n\tcerr<<cou<<\" \"<<ter<<\" \"<<wa<<endl;\n\tfor(auto &it:go[ter]){\n\t\tif(it.fir==per){continue;}\n\t\tdouble aaa;\n\t\tif(cou==1){aaa=1;}\n\t\telse{aaa=1+(wa-it.sec)/(cou-1);}\n\t\tefs(it.fir,ter,aaa);\n\t}\n\t\n}\nint main(void) {\n\tcout<<fixed<<setprecision(20);\n\tint n;cin>>n;\n\tif(n==1){cout<<0<<endl;return 0;}\n\tgo.res(n);\n\tans.res(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;u--;v--;\n\t\tgo[u].pub(mp(v,-5.0));\n\t\tgo[v].pub(mp(u,-5.0));\n\t}\n\tdfs(0,-1);\n\tefs(0,-1,0.0);\n\tfor(int i=0;i<n;i++){cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[150000];\ndouble ee[150000], ans[1500000];\n\nvoid dfs1(int idx, int par)\n{\n  double ret = 0;\n  int child = 0;\n\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    ret += ee[to] + 1.0;\n    ++child;\n  }\n  ee[idx] = 0;\n  if(child >= 1) ee[idx] += ret / child;\n}\n\nvoid dfs2(int idx, double d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  double ret = 0;\n  for(int &to : g[idx]) {\n    if(to == par) ret += d_par + 1.0;\n    else ret += ee[to] + 1.0;\n  }\n  ans[idx] = ret / g[idx].size();\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, (ret - ee[to]) / max(1, (int) g[idx].size() - 1), idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\n// @@ !! LIM(debug tree)\n// --> f:<< debug f:updMaxMin tree\n// ---- inserted function << from util.cc\ntemplate <typename T1, typename T2>\nostream& operator<< (ostream& os, const pair<T1,T2>& p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\n\ntemplate <typename T1, typename T2, typename T3>\nostream& operator<< (ostream& os, const tuple<T1,T2,T3>& t) {\n  os << \"(\" << get<0>(t) << \", \" << get<1>(t)\n     << \", \" << get<2>(t) << \")\";\n  return os;\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nostream& operator<< (ostream& os, const tuple<T1,T2,T3,T4>& t) {\n  os << \"(\" << get<0>(t) << \", \" << get<1>(t)\n     << \", \" << get<2>(t) << \", \" << get<3>(t) << \")\";\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const vector<T>& v) {\n  os << '[';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << ']';\n\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const set<T>& v) {\n  os << '{';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << '}';\n\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const multiset<T>& v) {\n  os << '{';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << '}';\n\n  return os;\n}\n\ntemplate <typename T1, typename T2>\nostream& operator<< (ostream& os, const map<T1, T2>& mp) {\n  os << '[';\n  for (auto it = mp.begin(); it != mp.end(); it++) {\n    if (it != mp.begin()) os << \", \";\n    os << it->first << \": \" << it->second;\n  }\n  os << ']';\n\n  return os;\n}\n\ntemplate <typename T, typename T2, typename T3>\nostream& operator<< (ostream& os, const priority_queue<T, T2, T3>& orig) {\n  priority_queue<T, T2, T3> pq(orig);\n  bool first = true;\n  os << '[';\n  while (!pq.empty()) {\n    T x = pq.top(); pq.pop();\n    if (!first) os << \", \";\n    os << x;\n    first = false;\n  }\n  return os << ']';\n}\n// ---- end <<\n// ---- inserted library file debug.cc\ntemplate <class... Args>\nstring dbgFormat(const char* fmt, Args... args) {\n  size_t len = snprintf(nullptr, 0, fmt, args...);\n  char buf[len + 1];\n  snprintf(buf, len + 1, fmt, args...);\n  return string(buf);\n}\n\ntemplate <class Head>\nvoid dbgLog(Head&& head) {\n  cerr << head << endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid dbgLog(Head&& head, Tail&&... tail)\n{\n  cerr << head << \" \";\n  dbgLog(forward<Tail>(tail)...);\n}\n\n#if DEBUG\n  #define DLOG(...)        dbgLog(__VA_ARGS__)\n  #define DFMT(...)        cerr << dbgFormat(__VA_ARGS__) << endl\n  #define DCALL(func, ...) func(__VA_ARGS__)\n#else\n  #define DLOG(...)\n  #define DFMT(...)\n  #define DCALL(func, ...)\n#endif\n\n// ---- end debug.cc\n// ---- inserted function updMaxMin from util.cc\ntemplate<typename T>\nbool updMax(T& tmax, const T& x) {\n  if (x > tmax) { tmax = x; return true;  }\n  else          {           return false; }\n}\ntemplate<typename T>\nbool updMin(T& tmin, const T& x) {\n  if (x < tmin) { tmin = x; return true;  }\n  else          {           return false; }\n}\n// ---- end updMaxMin\n// ---- inserted library file tree.cc\n\nclass Edge : public pair<int, int> {\npublic:\n  Edge() : pair<int, int>() {}\n  Edge(const int& x, const int& y) : pair<int, int>(x, y) {}\n  Edge(istream& stream, int shift) {\n    stream >> this->first >> this->second;\n    this->first -= shift;\n    this->second -= shift;\n  }\n};\n\nclass Tree {\n\n  void init() {\n    numNodes = edge.size() + 1;\n    parent.resize(numNodes);\n    child.resize(numNodes);\n    depth.resize(numNodes);\n    for (int i = 0; i < numNodes - 1; i++) {\n      Edge e = edge.at(i);\n      child.at(e.first).push_back(e.second);\n      child.at(e.second).push_back(e.first);\n    }\n    auto dfs = [&](const auto& recF, int n, int p, int l) -> void {\n      parent.at(n) = p;\n      depth.at(n) = l;\n      int ip = -1;\n      auto& vecC = child.at(n);\n      int numC = vecC.size();\n      for (int i = 0; i < numC; i++) {\n\tint c = vecC.at(i);\n\tif (c == p) ip = i;\n\telse        recF(recF, c, n, l+1);\n      }\n      if (n != root) {\n\tif (ip < numC - 1) swap(vecC.at(ip), vecC.at(numC - 1));\n\tvecC.resize(numC - 1);\n      }\n    };\n    dfs(dfs, root, -1, 0);\n    parent.at(root) = root;\n  }\n\n  vector<vector<int>> pPnt;   \n          // pPnt.at(0) == parent\n          // pPnt.at(t).at(n) == parent^{2^t}.at(n)\n  void preparePPnt() {\n    pPnt.push_back(parent);\n    for (int t = 0; true; t++) {\n      bool done = true;\n      vector<int> vec(numNodes);\n      for (int n = 0; n < numNodes; n++) {\n\tint m = pPnt.at(t).at(n);\n\tvec.at(n) = pPnt.at(t).at(m);\n\tif (vec.at(n) != m) done = false;\n      }\n      pPnt.push_back(move(vec));\n      if (done) break;\n    }\n  }\n\n  map<int, map<int, int>> __node2edgeID;\n\npublic:\n  int numNodes;\n  int root;\n  vector<int> parent;   // parent.at(root) == root\n  vector<vector<int>> child;\n  vector<int> depth;\n  vector<Edge> edge;\n\n  Tree(vector<Edge>&& edge_, int root_ = 0) : root(root_), edge(move(edge_)) {\n    init();\n  }\n\n  Tree(const auto& edge_, int root_ = 0) : root(root_), edge() {\n    for (Edge e : edge_) edge.push_back(e);\n    init();\n  }\n\n  // Lowest Common Ancestor\n  int lca(int x, int y) {\n    if (depth.at(x) > depth.at(y)) swap(x, y);\n    int dep = depth.at(x);\n    int yy = ancestorDep(y, dep);\n    if (x == yy) return x;\n    int t = 0;\n    for (int q = 1; q < dep; q *= 2) t++;\n    for ( ; t >= 0; t--) {\n      if (pPnt.at(t).at(x) != pPnt.at(t).at(yy)) {\n\tx = pPnt.at(t).at(x);\n\tyy = pPnt.at(t).at(yy);\n      }\n    }\n    return parent.at(x);\n  }\n\n  // the path between two nodes\n  vector<int> nnpath(int x, int y) {\n    vector<int> ret, sub;\n    int c = lca(x, y);\n    for ( ; x != c; x = parent.at(x)) ret.push_back(x);\n    for ( ; y != c; y = parent.at(y)) sub.push_back(y);\n    ret.push_back(c);\n    for (int i = sub.size() - 1; i >= 0; i--) ret.push_back(sub.at(i));\n    return ret;\n  }\n\n  // the ancestor of n whose depth is dep\n  int ancestorDep(int n, int dep) {\n    if (pPnt.size() == 0) preparePPnt();\n    int diff = depth.at(n) - dep;\n    assert(diff >= 0);\n    for (int t = 0; diff > 0; t++) {\n      if (diff & (1 << t)) {\n\tn = pPnt.at(t).at(n);\n\tdiff ^= (1 << t);\n      }\n    }\n    return n;\n  }\n\n  int node2edgeID(int n1, int n2) {\n    if (__node2edgeID.empty()) {\n      for (ll i = 0; i < numNodes - 1; i++) {\n\tEdge e = edge.at(i);\n\t__node2edgeID[e.first][e.second] = i;\n\t__node2edgeID[e.second][e.first] = i;\n      }\n    }\n    auto it1 = __node2edgeID.find(n1);\n    if (it1 == __node2edgeID.end()) return -1;\n    auto it2 = it1->second.find(n2);\n    if (it2 == it1->second.end()) return -1;\n    return it2->second;\n  }\n  Edge node2edge(int n1, int n2) { return edge.at(node2edgeID(n1, n2)); }\n  \n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"    \n  // diameter\n  //   not efficient at all.  fixed-rooted tree is not suitable....\n  int diameter() {\n  // tuple<int, int, int> diameter() {\n    int maxDepth = 0;\n    int mdArg1 = -1;\n    for (int i = 0; i < numNodes; i++) {\n      if (updMax(maxDepth, depth.at(i))) mdArg1 = i;\n    }\n    Tree tr2(edge, mdArg1);\n    maxDepth = 0;\n    int mdArg2;\n    for (int i = 0; i < numNodes; i++) {\n      if (updMax(maxDepth, tr2.depth.at(i))) mdArg2 = i;\n    }\n    // Return mdArg1 and mdArg2 if you need endpoints as well.\n    // return make_tuple(maxDepth, mdArg1, mdArg2);\n    return maxDepth;\n  }\n};\n#pragma GCC diagnostic pop\n\ntemplate <typename T, typename ADD_T, typename MOD_T>\nclass RerootTree {\npublic:\n  const Tree& tree;\n  const T& unitT;\n  const ADD_T& add;   // T -> T -> T\n  const MOD_T& mod;   // T -> int -> int -> T\n  \n  vector<vector<T>> left;\n  vector<vector<T>> right;\n  vector<T> res;\n\n  T dfs1(int n) {\n    vector<T> vec;\n    for (ll c : tree.child.at(n)) vec.push_back(mod(dfs1(c), c, n));\n    int k = tree.child.at(n).size();\n    vector<T>& leftN = left.at(n);\n    vector<T>& rightN = right.at(n);\n    leftN.resize(k+1);\n    leftN.at(0) = unitT;\n    for (int i = 0; i < k; i++) {\n      leftN.at(i+1) = add(leftN.at(i), vec.at(i));\n    }\n    rightN.resize(k+1);\n    rightN.at(k) = unitT;\n    for (int i = k-1; i >= 0; i--) {\n      rightN.at(i) = add(vec.at(i), rightN.at(i+1));\n    }\n    return rightN.at(0);\n  }\n\n  void dfs2(int n, const T& parRes) {\n    T thisRes = add(right.at(n).at(0), parRes);\n    res.at(n) = thisRes;\n    for (int i = 0; i < (int)tree.child.at(n).size(); i++) {\n      int c = tree.child.at(n).at(i);\n      T x = add(parRes, add(left.at(n).at(i), right.at(n).at(i+1)));\n      dfs2(c, mod(move(x), n, c));\n    }\n  }\n\n  RerootTree(const Tree& tree_, auto add_, auto mod_, T unitT_\n\t     ) : tree(tree_), unitT(unitT_), add(add_), mod(mod_),\n\t\t left(tree.numNodes), right(tree.numNodes),\n\t\t res(tree.numNodes) {\n    dfs1(tree.root);\n    DLOG(\"right\", right);\n    dfs2(tree.root, unitT);\n    DLOG(\"right\", right);\n  }\n};\n\n\n// ---- end tree.cc\n// @@ !! LIM  -- end mark --\n\nint main(int argc, char *argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  ll N; cin >> N;\n  vector<Edge> ve;\n  for (ll i = 0; i < N-1; i++) ve.emplace_back(Edge(cin, 1));\n  Tree tree(move(ve));\n  using T = pair<double, ll>;\n  T unitT({0.0, 0});\n  auto add = [&](const T& t1, const T& t2) -> T {\n    double e1; ll w1; tie(e1, w1) = t1;\n    double e2; ll w2; tie(e2, w2) = t2;\n    ll w0 = w1 + w2;\n    if (w0 == 0) return make_pair(0, 0);\n    return make_pair((e1 * w1 + e2 * w2) / w0, w0);\n  };\n  auto mod = [&](const T& t, ll c, ll n) -> T {\n    return make_pair(t.first + 1.0, 1);\n  };\n  RerootTree<T, decltype(add), decltype(mod)> rt(tree, add, mod, unitT);\n  for (ll i = 0; i < N; i++) cout << rt.res.at(i).first << \"\\n\";\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <map>\n\n#define fir first\n#define sec second\n#define sz(s) (s).size()\n#define pb push_back\n#define get(n) scanf(\"%d\",&n);\n#define gets(s) string s;cin >> (s);\n#define prfi(n) printf(\"%d\", &n);\n#define prfd(n) printf(\"%lf\", &n);\n#define All(s) (s).begin(), (s).end()\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n#define For(i,j,k) for(int (i)=(j);(i)<(k);(i)++)\n#define drep(i,j) for(int (i)=(j);(i)>=0;(i)--)\n#define Ford(i,j,k) for(int (i)=(j);i>=(k);i--)\n#define fore(c,v) for(auto (c): (v))\n#define lp for(int i=0;i<n;i++)\n#define mem(a,b) memset(a,b,sizeof(a));\n#define dump(x)  std::cout << #x << \" = \" << (x) << std::endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing ull = unsigned long long int;\nusing ll = long long;\nusing ld = long double;\nusing pii = std::pair<int,int>;\nusing pll = std::pair<ll, ll>;\nusing vi = std::vector<int> ;\nusing vvi = std::vector<vi> ;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vd = std::vector<double> ;\nusing vvd = std::vector<vd> ;\nusing qi = std::queue<int> ;\nusing vpii = std::vector<std::pair<int, int> >;\nusing vpll = std::vector<pll>;\nusing namespace std;\n\nconst int Mod = (1e9) + 7;\nconst int INF = 1e9 + 19;\nconst ll INFL = 1e18 + 19;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nconst int dx2[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nconst int dy2[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\n//_____________________________________Templates_________________________________________//\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\ntemplate<class T> inline void pri(T a){cout << a << endl;}\ntemplate<class Z> using vec = vector<Z>;\ntemplate<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n//mainly use for dynamic prog\ntemplate<class T1, class T2>\nvoid update(T1 &a, T2 b){\n  a += b;\n  if(a > Mod) a %= Mod;\n}\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\nbool pairsort(pll pl, pll pr){\n  if(pl.first == pr.first)return pl.second > pr.second;\n  return pl.first < pr.first;\n}\n\nint cntbit(ll a,int n,int j){int res = 0;For(i,j,n){if(a>>i & 1){res++;}}return res;}\nbool stdbit(int a, int b){return a&(1 << b); }\nint GCD(int a, int b){if(b > a)return GCD(b,a);if(a%b == 0)return b;else return GCD(b, a%b);}\nint LCM(int a, int b){return a*b/GCD(a,b);}\nint roundup(int a, int b){if(a % b == 0)return a/b;else return (a+b)/b;}\nint rounddown(int a, int b){if(a%b == 0)return a/b;else {return (a-b)/b;}}\nll pow(ll a, ll n){ll res = 1;while(n > 0){if(n&1)res *= a; a *= a; n = n >> 1;}return res;}\nll GetDiviserCount(ll N)//約数の個数\n{\n  ll res = 1;\n  For(i,2,sqrt(N)+1)\n  {\n    ll cnt = 0;\n    while(N%i == 0)\n    {\n      cnt++;\n      N /= i;\n    }\n    res *= (cnt + 1);\n    if(N == 1)break;\n  }\n  if(N != 1)res *= 2;\n  return res;\n}\nvll GetDivisor(ll N)//約数列挙\n{\n  vll res;\n  for(ll i = 1;i*i <= N;i++)\n  {\n    if(N%i == 0)\n    {\n      res.pb(i);\n      if(i*i != N)res.pb(N/i);\n    }\n  }\n  sort(All(res));\n  return res;\n}\n\ntemplate<class Z>\nstruct Matrix\n{\n  using mat = Matrix<Z>;\n  vector<vector<Z>> m_dat;\n  int m_h;\n  int m_w;\n  Matrix(int h, int w, Z x = 0) : m_h(h), m_w(w) ,m_dat(h,vector<Z>(w,x)) {}\n  Matrix(vector<vector<Z>> &v) \n  {\n    m_dat = v;\n    m_h = v.size();\n    m_w = v[0].size();\n  }\n\n  vector<Z> &operator[] (int idx)\n  {\n    return m_dat[idx];\n  }\n  mat Multiple(mat &a)\n  {\n    mat C(m_h, a.m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      for(int j=0;j<a.m_w;j++)\n      {\n        for(int k=0;k<m_w;k++)\n        {\n         C[i][j] += m_dat[i][k] * a[k][j];\n        }\n      }\n    }\n    return C;\n  }\n  mat Pow(ll x)\n  {\n    mat B(m_h,m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      B[i][i] = 1;\n    }\n    mat A = *this;\n    while(x > 0)\n    {\n      if(x&1)B = B.Multiple(A);\n      A = A.Multiple(A);\n      x = x >> 1;\n    }\n    return B;\n  }\n  friend ostream& operator<<(ostream &os, const mat &A);\n};\n\ntemplate<class Z>\nostream& operator<<(ostream &os, Matrix<Z>& A)\n{\n  for(int i=0;i<A.m_h;i++)\n  {\n    for(int j=0;j<A.m_w;j++)\n    {\n      os << A.m_dat[i][j] << \" \";\n    }\n    os << endl;\n  }\n  return os;\n}\ntemplate<class Z>\nusing mat = Matrix<Z>;\n\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%Mod+Mod)%Mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += Mod-a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= Mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n \n  // for prime mod\n  mint inv() const {\n    return pow(Mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n  friend ostream& operator<<(ostream& os, const mint& a);\n};\nostream& operator<<(ostream& os, const mint& a)\n{\n  os << a.x;\n  return os;\n}\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < Mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n//_____________________　following sorce code_________________________//\nconst int max_n = 3 * (1e5) + 1;\nconst int max_m = 83 * (1e5) + 1;\n\nint n,m,k;\nll N;\nint h,w;\nvvi tree;\nstring S;\nint a,b,c;\nvi v;\nvec<double> dp;\nvec<double> ans;\n\nvoid dfs(int v, int u=-1)\n{\n  double res = 1;\n  vi pos;\n  fore(p, tree[v])\n  {\n    if(u == p)continue;\n    dfs(p,v);\n    pos.pb(p);\n  }\n  double cnt = pos.size();\n  if(cnt == 0)\n  {\n    dp[v] = 0;\n    return ;\n  }\n  double possi = 1/cnt;\n  fore(p,pos)\n  {\n    res += dp[p] * possi;\n  }\n  dp[v] = res;\n  return ;\n}\n\nvoid dfs2(int v,int u=-1)\n{\n  if(v == 0)\n  {\n    fore(p,tree[v])dfs2(p,v);\n    return ;\n  }\n  \n  double tmp = 0;\n  double cnt = tree[v].size();\n  fore(p,tree[v])\n  {\n    if(tree[p].size() == 1)continue;\n    if(p != u)tmp += dp[p];\n    else \n    {\n      double poss = (double)tree[u].size() *(dp[u]-1) - dp[v];;\n      poss /= (double)(tree[u].size()-1);\n      tmp += 1 + poss;\n    }\n  }\n  dp[v] = 1;\n  dp[v] += tmp/(double)cnt;\n  fore(p,tree[v])\n  {\n    if(p == u)continue;\n    dfs2(p,v);\n  }\n}\n\nsigned main () {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  IN(n);\n  tree = vvi(n);\n  dp = vector<double>(n);\n  rep(i,n-1)\n  {\n    IN(a,b);a--;b--;\n    //dump(a);\n    tree[a].emplace_back(b);\n    tree[b].emplace_back(a);\n  }\n  dfs(0);\n  dfs2(0);\n  fore(ans, dp)\n  {\n    cout << fixed << setprecision(15) << ans << endl;\n  }\n  //cout << ans << endl;\n  //for(auto c : ans){cout << c << endl;}\n  //cout << fixed << setprecision(15) << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define fi first\n#define se second\n#define mp make_pair\n#define itrfor(itr,A) for(auto itr = A.begin(); itr !=A.end();itr++)\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntypedef long long llong;\nchar moji[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\nchar moji2[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};\nchar moji3[10]={'0','1','2','3','4','5','6','7','8','9'};\n#define Sort(a) sort(a.begin(),a.end());\n#define Reverse(a) reverse(a.begin(),a.end());\n#define print(a) cout << a << endl;\n#define MOD llong(1e9+7)\n#define MAX int(2 * 1e5 +5)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define pi acos(-1.0)\n#define int llong\n#define INF llong(1e17)\ntemplate<class T> bool chmax(T &a,  T b) {if(a<b){a=b; return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,  T b) {if(a>b){a=b; return 1;} return 0;}\nvoid myprint(int* A,int A_num){\n   REP(i,A_num) cout << A[i] << \" \";\n   cout << endl;\n}\n\n\nconst int n_max = 150005;\nint n;\nvector<int> Graph[n_max];\n\ndouble dp1[n_max];\ndouble ans[n_max];\n\n\ndouble dfs1(int v, int par){\n    dp1[v] = 0.0;\n    int cnt = 0;\n    itrfor(itr,Graph[v]){\n        if( *itr == par) continue;\n        dp1[v] += 1.0 +  dfs1(*itr,v);\n        cnt ++;\n    }\n    if(cnt != 0) dp1[v] /= cnt;\n    return dp1[v] ;\n\n}\n\ndouble dfs2(int v, int par, double par_value){\n    ans[v] = 0.0;\n    itrfor(itr,Graph[v]){\n        if( *itr == par) ans[v] += 1.0 + par_value;\n        else ans[v] += 1.0 + dp1[*itr];\n    }\n    itrfor(itr,Graph[v]){\n        if( *itr == par) continue;\n        else{\n            if( Graph[v].size() == 1)dfs2(*itr, v, 0.0);\n            else dfs2(*itr, v, (ans[v] - 1.0 - dp1[*itr]) / ( double(Graph[v].size()) - 1) );\n        }\n    }\n\n    ans[v] /= double(Graph[v].size());\n}\n\n\nsigned main(){\n    cin >> n;\n    REP(i,n - 1){\n        int x,y;\n        cin >> x >> y;\n        x --;\n        y --;\n        Graph[x].push_back(y);\n        Graph[y].push_back(x);\n    }\n\n    dfs1(0,-1);\n\n    dfs2(0,-1,0.0);\n    REP(i,n){\n        cout << fixed << setprecision(10) << ans[i] << endl;\n    }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=double;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nconst int limit=150010;\nusing edge=struct{int to,rev;};\nvector<edge> graph[limit];\nvector<R> dp[limit];\n\nvector<R> sum;\nvector<int> cnt;\n\nvoid add_edge(int from,int to){ \n\tgraph[from].push_back({to,int(graph[to].size())});\n\tgraph[to].push_back({from,int(graph[from].size())-1});\n\tdp[from].push_back(-1.0);\n\tdp[to].push_back(-1.0);\n}\n\nR dfs(int v,int i){\n\tif(i==-1){\n\t\tconst int m=graph[v].size();\n\t\t\n\t\tR ret=0.0;\n\t\tif(cnt[v]>=2) return sum[v]/m;\n\t\t\n\t\trep(j,m){\n\t\t\tconst int nv=graph[v][j].to;\n\t\t\tconst int ni=graph[v][j].rev;\n\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t}\n\t\tsum[v]=ret,cnt[v]=2;\n\t\tret/=m;\n\t\treturn ret;\n\t}else{\n\t\tR &ret=dp[v][i];\n\t\tif(ret>=0.0) return ret;\n\t\tret=0.0; \n\n\t\tconst int m=int(graph[v].size());\n\t\t\t\n\t\tif(cnt[v]<=1){\n\t\t\trep(j,m){\n\t\t\t\tif(j==i) continue;\n\t\t\t\tconst int nv=graph[v][j].to;\n\t\t\t\tconst int ni=graph[v][j].rev;\n\t\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t\t}\n\n\t\t\tsum[v]=ret;\n\t\t\tif(m!=1) ret/=(m-1);\n\t\t\t\n\t\t\tcnt[v]++;\n\t\t\tif(cnt[v]==2){\n\t\t\t\tconst int nv=graph[v][i].to;\n\t\t\t\tconst int ni=graph[v][i].rev;\n\t\t\t\tsum[v]+=dfs(nv,ni)+1.0;\n\t\t\t}\n\t\t}else{\n\t\t\tret=sum[v];\n\t\t\t{\n\t\t\t\tconst int nv=graph[v][i].to;\n\t\t\t\tconst int ni=graph[v][i].rev;\n\t\t\t\tret-=dfs(nv,ni)+1.0;\n\t\t\t}\n\t\t\tif(m!=1) ret/=(m-1);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\tcnt=vector<int>(n,0);\n\tsum=vector<R>(n,0.0);\n\n\trep(i,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\n\trep(i,n) printf(\"%.20lf\\n\",dfs(i,-1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nstruct Graph {\n    struct Edge { int i; double t; };\n    Graph(int n) : e(n) {}\n    void add_edge(int i, int j) {\n        e[i].push_back({ j, 0.0 });\n    }\n    double foo(int i, int p) {\n        double s = 0;\n        int k = 0;\n        for (Edge& o : e[i]) {\n            if (o.i == p) continue;\n            double t = o.t;\n            if (t == 0.0) o.t = t = foo(o.i, i) + 1;\n            s += t;\n            k++;\n        }\n        if (k != 0) s /= k;\n        return s;\n    }\n    vector<vector<Edge>> e;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << fixed << setprecision(12) << g.foo(i, -1) << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (ll i = (ll)(a); i < (ll)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\n\nvector<lld> dp1(151010, 0);\nvector<lld> dp2(151010, 0);\n\nvector<int> childnum(151010, 0);\nvector<int> parvec(151010, 0);\nmap<int, vector<int>> g;\n\nvoid dfs1(int cur, int par)\n{\n    parvec[cur] = par;\n    lld ret = 0;\n    for (auto x : g[cur])\n    {\n        if (x != par)\n        {\n            dfs1(x, cur);\n            ret += 1 + dp1[x];\n            childnum[cur]++;\n        }\n    }\n    if (childnum[cur] != 0)\n    {\n        dp1[cur] = ret / (lld)childnum[cur];\n    }\n    else\n    {\n        dp1[cur] = 0;\n    }\n}\n\nvoid dfs2(int cur, int par)\n{\n    if (par == -1)\n    {\n        dp2[cur] = dp1[cur];\n    }\n    else\n    {\n\n        int pnum = g[par].size();\n        lld parexp;\n        if (pnum == 1)\n        {\n            parexp = (dp1[par] * (childnum[par]) - dp1[cur]) / ((childnum[par]));\n        }\n        else\n        {\n            parexp = 1 + (dp1[par] * (g[par].size()) - dp1[cur] - 1) / (pnum - 1);\n        }\n        //cerr << cur << \" \" << par << \" \" << parexp << \" \" << pnum << endl;\n        dp1[cur] = (dp1[cur] * childnum[cur] + (parexp)) / (lld)(childnum[cur] + 1);\n        //cerr << dp1[cur] << endl;\n    }\n    for (auto x : g[cur])\n    {\n        if (x != par)\n            dfs2(x, cur);\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i, n - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs1(0, -1);\n\n    /* rep(i, n)\n    {\n        cerr << fixed << setprecision(18) << dp1[i] << endl;\n    }\n    cerr << endl;\n    */\n    dfs2(0, -1);\n\n    rep(i, n)\n    {\n        cout << fixed << setprecision(18) << dp1[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)\n\ntypedef long long llong;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst double EPS = 1e-9;\n\n#define MAXN 150004\nint N;\nVI adj[MAXN];\n\nint par[MAXN];\nint nchildren[MAXN];\ndouble E_down[MAXN];\ndouble sum_children_E[MAXN];\nvoid dfs1(int u) {\n   nchildren[u] = 0;\n   sum_children_E[u] = 0.0;\n   for (int v : adj[u]) {\n      if (v != par[u]) {\n         par[v] = u;\n         nchildren[u]++;\n         dfs1(v);\n         sum_children_E[u] += E_down[v];\n      }\n   }\n   if (nchildren[u] == 0)\n      E_down[u] = 0.0;\n   else\n      E_down[u] = 1 + sum_children_E[u] / nchildren[u];\n}\n\ndouble E_up[MAXN];\ndouble E[MAXN];\nvoid dfs2(int u) {\n   int p = par[u];\n   if (p == -1) {\n      E_up[u] = 0.0;\n      E[u] = E_down[u];\n   }\n   else {\n      if (E_up[p] > EPS)\n         E_up[u] = 1 + (E_up[p] + (sum_children_E[p] - E_down[u]) + nchildren[p] - 1) / nchildren[p];\n      else if (nchildren[p] > 1)\n         E_up[u] = 1 + ((sum_children_E[p] - E_down[u]) + nchildren[p] - 1) / (nchildren[p]-1);\n      else\n         E_up[u] = 1;\n      E[u] = E_up[u] / (nchildren[u]+1) + E_down[u] * nchildren[u] * 1.0 / (nchildren[u]+1);\n   }\n   for (int v : adj[u]) {\n      if (v != p)\n         dfs2(v);\n   }\n}\n\nint main(int argc, char* argv[]) {\n   scanf(\"%d\", &N);\n   REP(j, N-1) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      --u, --v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n   }\n\n   par[0] = -1;\n   dfs1(0);\n\n   dfs2(0);\n\n   REP(u, N) {\n   // fprintf(stderr, \"%d: Edown=%.05f  Eup=%.05f  E=%.05f\\n\", u+1, E_down[u], E_up[u], E[u]);\n      printf(\"%.010f\\n\", E[u]);\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nvector<int> G[150000];\nbool used1[150000];\nbool used2[150000];\ndouble dp[150000];\n\nvoid dfs1(int v){\n    used1[v] = true;\n    int n = G[v].size();\n    if(v != 0) n--;\n    for(int i = 0; i < G[v].size(); i++){\n        if(!used1[G[v][i]]){\n            dfs1(G[v][i]);\n            dp[v] += (dp[G[v][i]]+1)/(double)n;\n        }\n    }\n}\n\nvoid dfs2(int v){\n    used2[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        if(!used2[G[v][i]]){\n            int n = G[v].size();\n            int m = G[G[v][i]].size();\n            if(G[v].size() != 1){\n                double e = (dp[v]-(dp[G[v][i]]+1)/n)*((double)n/(double)(n-1));\n                dp[G[v][i]] *= ((double)(m-1)/(double)(m));\n                dp[G[v][i]] += (e+1)/(double)m;\n            }else{\n                dp[G[v][i]] *= ((double)(m-1)/(double)(m));\n                dp[G[v][i]] += 1/(double)m;\n            }\n            dfs2(G[v][i]);\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i = 0; i < N-1; i++){\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    cout << fixed << setprecision(10);\n    dfs1(0);\n    \n    dfs2(0);\n    for(int i = 0; i < N; i++){\n        cout << dp[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...)\n#endif\n\n/**\n * @title Graph template\n * @docs graph_template.md\n */\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n};\n\ntemplate <typename T> using Graph = std::vector<std::vector<Edge<T>>>;\ntemplate <typename T> using Tree = std::vector<std::vector<Edge<T>>>;\n\ntemplate <typename T, typename C> void add_edge(C &g, int from, int to, T w = 1){\n  g[from].emplace_back(from, to, w);\n}\n\ntemplate <typename T, typename C> void add_undirected(C &g, int a, int b, T w = 1){\n  add_edge<T, C>(g, a, b, w);\n  add_edge<T, C>(g, b, a, w);\n}\n\n\n\n/**\n * @title Rerooting DP\n * @docs rerooting.md\n */\nnamespace rerooting_impl {\n  template <typename T, typename U, typename Merge, typename EdgeF, typename VertexF>\n  T rec1(\n    Tree<U> &tree,\n    T id,\n    const Merge &merge,\n    const EdgeF &f,\n    const VertexF &g,\n    std::vector<std::vector<T>> &dp,\n    int cur,\n    int par = -1\n  ){\n    T acc = id;\n\n    for(int i = 0; i < (int)tree[cur].size(); ++i){\n      auto &e = tree[cur][i];\n      if(e.to == par) continue;\n      dp[cur][i] = rec1(tree, id, merge, f, g, dp, e.to, cur);\n      acc = merge(acc, f(dp[cur][i], e));\n    }\n\n    return g(acc, cur);\n  }\n\n  template <typename T, typename U, typename Merge, typename EdgeF, typename VertexF>\n  void rec2(\n    const Tree<U> &tree,\n    T id,\n    const Merge &merge,\n    const EdgeF &f,\n    const VertexF &g,\n    std::vector<std::vector<T>> &dp,\n    int cur,\n    int par,\n    T value\n  ){\n    const int l = tree[cur].size();\n\n    for(int i = 0; i < l; ++i){\n      if(tree[cur][i].to == par){\n        dp[cur][i] = value;\n      }\n    }\n\n    std::vector<T> left(l + 1, id), right(l + 1, id);\n\n    for(int i = 0; i < l - 1; ++i){\n      const auto &e = tree[cur][i];\n      left[i + 1] = merge(left[i], f(dp[cur][i], e));\n    }\n\n    for(int i = l - 1; i >= 1; --i){\n      const auto &e = tree[cur][i];\n      right[i - 1] = merge(right[i], f(dp[cur][i], e));\n    }\n\n    for(int i = 0; i < l; ++i){\n      const auto &e = tree[cur][i];\n      if(e.to == par) continue;\n\n      rec2(tree, id, merge, f, g, dp, e.to, cur, g(merge(left[i], right[i]), cur));\n    }\n  }\n}\n\ntemplate <typename T, typename U, typename Merge, typename EdgeF, typename VertexF>\nauto rerooting(Tree<U> tree, T id, Merge merge, EdgeF f, VertexF g){\n  const int N = tree.size();\n  std::vector<std::vector<T>> dp(N);\n  std::vector<T> ret(N, id);\n\n  for(int i = 0; i < N; ++i) dp[i].assign(tree[i].size(), id);\n  rerooting_impl::rec1(tree, id, merge, f, g, dp, 0);\n  rerooting_impl::rec2(tree, id, merge, f, g, dp, 0, -1, id);\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < (int)tree[i].size(); ++j){\n      ret[i] = merge(ret[i], f(dp[i][j], tree[i][j]));\n    }\n\n    ret[i] = g(ret[i], i);\n  }\n\n  return ret;\n}\n\n\n\n\n\n\nnamespace solver{\n  void solve(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    \n    int N; std::cin >> N;\n\n    Tree<int> tree(N);\n    for(int i = 0; i < N - 1; ++i){\n      int u, v; std::cin >> u >> v;\n      add_undirected(tree, u - 1, v - 1, 1);\n    }\n\n    auto merge =\n      [](const auto &a, const auto &b){\n        return std::make_pair(a.first + b.first, a.second + b.second);\n      };\n    auto f =\n      [](const auto &a, const auto &){\n        return a;\n      };\n    auto g =\n      [](const auto &a, int){\n        if(a.second == 0){\n          return std::make_pair(0.0, 1);\n        }else{\n          return std::make_pair(a.first / a.second + 1, 1);\n        }\n      };\n\n    auto res = rerooting<std::pair<double, int>>(tree, {0, 0}, merge, f, g);\n\n    for(auto x : res){\n      std::cout << std::fixed << std::setprecision(12) << x.first << \"\\n\";\n    }\n  }\n}\n\nint main(){\n  solver::solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n    rep(i, N)if (sz(G[i]) > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        rep(i, N)printf(\"%0.8f\\n\", ans);\n        exit(0);\n    }\n\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.8f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size()-1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint d[151515],p[151515],c[151515];\ndouble dp[151515],memo[151515];\nbool done[151515];\nvector<int> g[151515];\n\ndouble treedp(int v, int pr){\n\tint i;\n\tif(d[v]>=0){\n\t\treturn dp[v];\n\t}\n\td[v] = d[pr]+1;\n\tp[v] = pr;\n\tc[v] = 0;\n\tdp[v] = 0.0;\n\tfor(i=(g[v].l_ength()-1); i>=0; --i){\n\t\tif(g[v][i] == pr){\n\t\t\tcontinue;\n\t\t}\n\t\tdp[v] += treedp(g[v][i],v);\n\t\t++c[v];\n\t}\n\tif(!c[v]){\n\t\treturn dp[v];\n\t}\n\tdp[v] /= ((double)(c[v]));\n\tdp[v] += 1.0;\n\treturn dp[v];\n}\n\ndouble solve(int v){\n\tif(done[v]){\n\t\treturn memo[v];\n\t}\n\tdone[v] = true;\n\tif(p[v]==0){\n\t\tif(c[0]>1){\n\t\t\tmemo[v] = ((treedp(0,p[0])-1.0)*((double)(c[0]))-treedp(v,0))/((double)(c[0]-1))+1.0;\n\t\t}else{\n\t\t\tmemo[v] = 0.0;\n\t\t}\n\t\treturn memo[v];\n\t}\n\tmemo[v] = ((treedp(p[v],p[p[v]])-1.0)*((double)(c[p[v]]))-treedp(v,p[v])+solve(p[v]))/((double)(c[p[v]]))+1.0;\n\treturn memo[v];\n}\n\nint main(void){\n\tint n,i,v,u;\n\tfill(d,d+151515,-1);\n\tfill(done,done+151515,false);\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tprintf(\"%.15lf\\n\",treedp(0,n));\n\tfor(i=1; i<n; ++i){\n\t\tprintf(\"%.15lf\\n\",(treedp(i,p[i])*((double)(g[i].l_ength()-1))+solve(i)+1.0)/((double)(g[i].l_ength())));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing ld = long double;\n\nint N;\nvector<vector<int>> edges;\nvector<map<int, ld>> vmp;\n\nld dfs(int from, int now) {\n\tif (from != -1 && vmp[from].find(now) != vmp[from].end()) {\n\t\treturn vmp[from][now];\n\t}\n\tif (edges[now].size() == 1 && edges[now].front() == from) {\n\t\treturn vmp[from][now] = 1;\n\t}\n\tld res = 0;\n\tfor (int next : edges[now])if (next != from) {\n\t\tres += dfs(now, next);\n\t}\n\tres /= (edges[now].size() - 1);\n\tif (from == -1)return res;\n\telse return vmp[from][now] = res + 1;\n}\nvoid dfs2(int from, int now) {\n\tif (from != -1) {\n\t\tvmp[now][from] = 1 + (\n\t\t\tedges[from].size() == 1\n\t\t\t? 0\n\t\t\t: ((vmp[from][from] - vmp[from][now]) / (edges[from].size() - 1))\n\t\t\t);\n\t}\n\tld res = 0;\n\tfor (auto itr : vmp[now])res += itr.second;\n\tvmp[now][now] = res;\n\tfor (int next : edges[now])if (next != from)dfs2(now, next);\n}\n\nint main()\n{\n\tcin >> N;\n\tedges.resize(N);\n\tvmp.resize(N);\n\trep(i, N - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tdfs(-1, 0);\n\tdfs2(-1, 0);\n\trep(i, N) {\n\t\tcout << fixed << setprecision(15) << vmp[i][i] / edges[i].size() << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tfor (int v : E[i])dfs(i, v);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=150001;\nint i,j,t,n,d[N],fa[N],en[N+N],nxt[N+N];\ndouble f[N],g[N];\nvoid dfs1(int u,int p)\n{\n\tfor(int i=fa[u];i;i=nxt[i])if(en[i]^p)\n\t\t++d[u],dfs1(en[i],u),f[u]+=f[en[i]];\n\tif(d[u])f[u]=f[u]/d[u]+1;\n}\nvoid dfs2(int u,int p)\n{\n\tfor(int i=fa[u],v;i;i=nxt[i])if((v=en[i])^p)\n\t{\n\t\tif(p)g[v]=(f[u]*d[u]-f[v]-1+g[u])/d[u]+1;else\n\t\tif(d[u]>1)g[v]=(f[u]*d[u]-f[v]-1)/(d[u]-1)+1;\n\t\tdfs2(v,u);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(;++t<n+n-1;)\n\t{\n\t\tscanf(\"%d%d\",&i,&j);\n\t\ten[t]=j,nxt[t]=fa[i],fa[i]=t;\n\t\ten[++t]=i,nxt[t]=fa[j],fa[j]=t;\n\t}\n\tdfs1(1,0),dfs2(1,0);\n\tfor(printf(\"%.6lf\\n\",f[i=1]);++i<=n;)\n\t\tprintf(\"%.6lf\\n\",(f[i]*d[i]+g[i])/(d[i]+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\nint N;\nvector<int> E[151010];\n//-----------------------------------------------------------------------------------\ndouble dp[151010];\ndouble dfs(int cu, int pa = -1) {\n    double ret = 0;\n    int cnt = 0;\n    for (int to : E[cu]) if (to != pa) ret += dfs(to, cu) + 1, cnt++;\n    if (0 < cnt) ret /= cnt;\n    return dp[cu] = ret;\n}\n//-----------------------------------------------------------------------------------\ndouble ans[151010];\nvoid dfs2(int cu, int pa = -1) {\n    // for ans\n    double sm = 0; int cnt = 0;\n    for (int to : E[cu]) sm += dp[to] + 1, cnt++;\n    if (0 < cnt) ans[cu] = sm / cnt;\n    else ans[cu] = sm;\n\n    for (int to : E[cu]) if (pa != to) {\n        dp[cu] = sm - dp[to] - 1;\n        if (1 < cnt) dp[cu] /= (cnt - 1);\n        dfs2(to, cu);\n    }\n}\n//-----------------------------------------------------------------------------------\nint main() {\n    cin >> N;\n    if (1010 < N) return 0;\n    rep(i, 0, N - 1) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    dfs(1);\n    dfs2(1);\n\n    rep(i, 1, N + 1) printf(\"%.10f\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-8)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n//*\n// シンプルな構文解析用\ntypedef string::const_iterator State;\nclass ParseError {};\n//*/\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint N;\nGraph G;\n\nvd dp;\n\n\nvoid dfs1(int pos, int par) {\n\tif (pos != 0 && G[pos].size() == 1) return;\n\tfor (auto edge : G[pos]) {\n\t\tif (edge.to == par)continue;\n\t\tdfs1(edge.to, pos);\n\t\tdp[pos] += dp[edge.to];\n\t}\n\tif (pos == 0) {\n\t\tdp[pos] /= G[pos].size();\n\t}\n\telse {\n\t\tdp[pos] /= (G[pos].size() - 1);\n\t}\n\tdp[pos] += 1;\n}\n\nvoid dfs2(int pos, int par, double add) {\n\tif (pos != 0) {\n\t\tdp[pos] = (dp[pos] * (G[pos].size() - 1) + add) / G[pos].size();\n\t}\n\tfor (auto edge : G[pos]) {\n\t\tif (edge.to == par)continue;\n\t\tif (G[pos].size() == 1) {\n\t\t\tdfs2(edge.to, pos, 1.0);\n\t\t}\n\t\telse {\n\t\t\tdfs2(edge.to, pos, 1+(G[pos].size()*dp[pos]-(1+dp[edge.to]))/(G[pos].size()-1));\n\t\t}\n\t}\n}\n\nint main(void) {\n\tcin >> N;\n\tG = Graph(N);\n\tdp = vd(N, 0);\n\trep(i, N - 1) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tG[s].push_back(Edge{ s,t,1 });\n\t\tG[t].push_back(Edge{ t,s,1 });\n\t}\n\tdfs1(0, -1);\n\tdfs2(0, -1, 0);\n\n\tcout << fixed << setprecision(14);\n\trep(i, N) {\n\t\tcout << dp[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble memo[150010];\ndouble ans[150010];\nvector<int> G[150010];\n\nvoid dfs(int idx, int par) {\n    int sz = G[idx].size();\n    for(auto &to : G[idx]) {\n        if(to == par) {\n            sz--; continue;\n        }\n        dfs(to, idx);\n        memo[idx] += memo[to] + 1.0;\n    }\n    if(sz) memo[idx] /= sz;\n}\n\nvoid dfs2(int idx, double d_par, int par) {\n    double sum = 0.0;\n    int sz = G[idx].size();\n    for(auto &to : G[idx]) {\n        if(to == par) sum += d_par + 1.0;\n        else sum += memo[to] + 1.0;\n    }\n    // printf(\"idx = %lld, d_par = %.12lf, par = %lld, sum = %.12lf\\n\", idx, d_par, par, sum);\n    ans[idx] = (sz > 0 ? sum / sz : 0.0);\n    for(auto &to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, sz > 1 ? (sum - memo[to] - 1.0) / (sz - 1) : 0.0, idx);\n    }\n}\n\nsigned main() {\n    int n; cin >> n;\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, 0.0, -1);\n    rep(i,0,n) printf(\"%.12f\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define FOR(i,n,m) for(int i=(n);i<(m);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REPR(i,n) for(int i=(n);i>=0;i--)\n#define all(vec) vec.begin(),vec.end()\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing P=pair<ll,ll>;\nusing PP=pair<ll,P>;\nusing vp=vector<P>;\nusing vpp=vector<PP>;\nusing vs=vector<string>;\n#define fi first\n#define se second\n#define pb push_back\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(a>b){a=b;return true;}return false;}\ntemplate<typename A,typename B>istream&operator>>(istream&is,pair<A,B> &p){is>>p.fi>>p.se;return is;}\ntemplate<typename A,typename B>ostream&operator<<(ostream&os,const pair<A,B> &p){os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return os;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T> &t){REP(i,t.size())is>>t[i];return is;}\ntemplate<typename T>ostream&operator<<(ostream&os,const vector<T>&t){os<<\"{\";REP(i,t.size()){if(i)os<<\",\";os<<t[i];}cout<<\"}\";return os;}\nconst ll MOD=1000000007LL;\nconst int INF=1<<30;\nconst ll LINF=1LL<<60;\nint n;\nvector<vector<int>> G;\nmap<P,double> mem;\ndouble dfs(int x,int par){\n    double res=0;\n    if(mem.count({x,par})){\n        return mem[{x,par}];\n    }\n    int cnt=0;\n    for(int i=0;i<G[x].size();i++){\n        if(G[x][i]!=par){\n            res+=dfs(G[x][i],x)+1;\n            cnt++;\n        }\n    }\n    if(!cnt){\n        return 0;\n    }\n    return mem[{x,par}]=res/cnt;\n}\nint main(){\n    cin>>n;\n    G.resize(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    for(int i=0;i<n;i++){\n        printf(\"%.10f\\n\",dfs(i,-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#define N 200010\nusing namespace std;\nint head[N], k, sz[N];\ndouble E[N], ans[N];\nstruct Edge\n{\n    int v, next;\n}edge[2 * N];\nvoid add_edge(int u, int v)\n{\n    edge[++k].v = v;\n    edge[k].next = head[u];\n    head[u] = k;\n}\nvoid dfs1(int u, int pre)\n{\n    for(int kk = head[u]; ~kk; kk = edge[kk].next)\n    {\n        int v = edge[kk].v;\n        if(v == pre) continue;\n        dfs1(v, u);\n        E[u] += 1.0 / sz[u] * (E[v] + 1);\n    }\n}\nvoid dfs2(int u, int pre)\n{\n    double t = 1.0 / sz[pre] * (E[u] + 1);\n    t = ans[pre] - t;\n    if(sz[pre] != 1)\n        t = t * sz[pre] / (sz[pre] - 1);\n    ans[u] = E[u] * (sz[u] - 1) / sz[u] + 1.0 / sz[u] * (t + 1);\n    for(int kk = head[u]; ~kk; kk = edge[kk].next)\n    {\n        int v = edge[kk].v;\n        if(v == pre) continue;\n        dfs2(v, u);\n    }\n}\nint main()\n{\n    int n, u, v, i;\n    scanf(\"%d\", &n);\n    memset(sz, -1, sizeof(sz));\n    k = -1;\n    memset(head, -1, sizeof(head));\n    for(i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n        sz[u]++;\n        sz[v]++;\n    }\n    sz[1]++;\n    dfs1(1, -1);\n    for(i = 2; i <= n; ++i) sz[i]++;\n    ans[1] = E[1];\n    for(i = head[1]; ~i; i = edge[i].next)\n    {\n        int v = edge[i].v;\n        dfs2(v, 1);\n    }\n    for(i = 1; i <= n; ++i)\n    {\n        printf(\"%.10lf\\n\", ans[i]);\n    }\n    return 0;\n}\n/*\n3\n1 2\n1 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#define ran 222222\nint n;\nvector<int> e[ran];\n\ndouble res[ran];int ch[ran];\ndouble out[ran];\n\nvoid dfs2(int x,int f,double to){\n\tif(x!=1){\n\t\tout[x] = res[x] * ch[x] + to + 1;\n\t\tch[x] ++;\n\t}else{\n\t\tout[x] = res[x] * ch[x];\n\t}\n\tfor(vector<int>::iterator it = e[x].begin(); it!=e[x].end(); it++){\n\t\tint y = *it;\n\t\tif(y == f)continue;\n\t\tdfs2(y,x, ch[x] == 1 ? 0 : (out[x] - (res[y]+1))/(ch[x]-1));\n\t}\n}\nvoid dfs(int x,int f){\n\tch[x] = 0;\n\tres[x] = 0;\n\tfor(vector<int>::iterator it = e[x].begin(); it!=e[x].end(); it++){\n\t\tint y = *it;\n\t\tif(y == f)continue;\n\t\tdfs(y,x);\n\t\tres[x] += res[y]+1;\n\t\tch[x] ++;\n\t}\n\tif(ch[x]){\n\t\tres[x] /= ch[x];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,1);\n\tdfs2(1,1,0);\n\tfor(int i=1; i<=n; i++)\n\t\tprintf(\"%.12lf\\n\",ch[i] == 0 ? 0 : out[i]/ch[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nmap<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,d[SZ]; Edg\nld f[SZ],ca=0;\nvoid dp1(int x,int fa=0)\n{\n\tf[x]=0;\n\tfor esb(x,e,b) if(b!=fa)\n\t\tdp1(b,x), f[x]+=(f[b]+1)/ld(d[x]-bool(fa));\n}\nld anss[SZ];\nvoid dp2(int x,int fa=0)\n{\n\tld cc=ca; anss[x]=cc;\n\tfor esb(x,e,b) if(b!=fa)\n\t{\n\t\tld ts=(f[b]+1)/ld(d[x]);\n\t\tld ot=0;\n\t\tif(fabs(cc-ts)>1e-6)\n\t\t\tot=(cc-ts)/(1-1.0/ld(d[x]));\n\t\tot++;\n\t\tca=f[b]*(1-1.0/ld(d[b]))+ot*1.0/ld(d[b]);\n\t\tdp2(b,x);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b);++d[a];++d[b];\n\t}\n\tdp1(1); ca=f[1]; dp2(1);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%.10lf\\n\",anss[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size()-1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tfor (int v : E[i]) {\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nstruct Graph {\n    struct Edge { int i, n; double t; };\n    struct Vertex { int n; int k; double t; };\n    Graph(int n, int m) : v(n, { -1, 0, 0 }), e(m), m(0) {}\n    void add_edge(int i, int j) {\n        e[m] = { j, v[i].n, 0.0 };\n        v[i].n = m;\n        m++;\n    }\n    double foo(int i, int p) {\n        double t = 0.0;\n        int k = 0;\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == p) continue;\n            o.t = foo(o.i, i) + 1;\n            t += o.t;\n            k++;\n        }\n        if (k == 0) return 0.0;\n        v[i].t = t;\n        v[i].k = k;\n        return t / k;\n    }\n    void bar(int i, int p, double t) {\n        if (p >= 0) {\n            v[i].t += t + 1;\n            v[i].k++;\n        }\n        int k = v[i].k - 1;\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == p) continue;\n            bar(o.i, i, k == 0 ? 0.0 : (v[i].t - o.t) / k);\n        }\n    }\n    vector<Edge> e;\n    vector<Vertex> v;\n    int m;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph g(n, (n - 1) * 2);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n\n    g.foo(0, -1);\n    g.bar(0, -1, 0.0);\n    for (int i = 0; i < n; i++) {\n        cout << fixed << setprecision(9) << g.v[i].t / g.v[i].k << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- ReRooting {{{ ///\n\n#include <functional>\n#include <vector>\ntemplate < class Monoid >\nstruct ReRooting {\n  using size_type = std::size_t;\n  using edge_type = std::tuple< size_type, size_type, size_type >;\n  using graph_type = std::vector< std::vector< edge_type > >;\n  using T = typename Monoid::T;\n  using dig_f_type = std::function< T(T, size_type edge_id, size_type from, size_type to) >;\n  using after_f_type = std::function< T(T, size_type vertex_id, size_type degree_of_this) >;\n  using vector_bool_type = std::vector< int >;\n  graph_type graph;\n\n  size_type n;\n\n  std::vector< std::vector< T > > dp;\n  std::vector< vector_bool_type > did;\n  std::vector< std::vector< T > > L;\n  std::vector< std::vector< T > > R;\n\n  dig_f_type dig;\n  after_f_type after;\n  static T default_dig(const T&a, ...) {\n    return a;\n  }\n  static T default_after(const T&a, ...) {\n    return a;\n  }\n\n  bool built;\n\n  ReRooting() {}\n  ReRooting(size_type n, dig_f_type dig = default_dig, after_f_type after = default_after) : dig(dig), after(after) {\n    clear(n);\n  }\n  ReRooting(std::vector<std::vector<int>> graph, dig_f_type dig = default_dig, after_f_type after = default_after) : ReRooting(graph.size(), dig, after) {\n    for(size_type from = 0; from < n; from++) {\n      for(auto to : graph[from]) if(to < from) {\n        add_edge(from, to);\n      }\n    }\n  }\n\n  void clear() { clear(n); }\n\n  void clear(size_type n) {\n    this->n = n;\n    graph.resize(n);\n    graph.assign(n, std::vector< edge_type >());\n    dp.resize(n);\n    dp.assign(n, std::vector< T >());\n    did.resize(n);\n    did.assign(n, vector_bool_type());\n    L.resize(n);\n    L.assign(n, std::vector< T >());\n    R.resize(n);\n    R.assign(n, std::vector< T >());\n    built = 0;\n  }\n\n  size_type added = 0;\n  void add_edge(size_type a, size_type b, size_type id = static_cast<size_type>(-1)) {\n    assert(a < n && b < n && a != b);\n    if(id == static_cast<size_type>(-1)) id = added;\n    graph[a].emplace_back(b, graph[b].size(), id);\n    graph[b].emplace_back(a, graph[a].size() - 1, id);\n    added++;\n  }\n\n  void set_dig(dig_f_type dig = default_dig) { this->dig = dig; }\n\n  void set_after(after_f_type after = default_after) { this->after = after; }\n\n  void build() {\n    assert(!built);\n    assert(added == n - 1);\n    built = 1;\n    if(n == 0) return;\n    for(size_type i = 0; i < n; i++) {\n      dp[i].resize(graph[i].size() + 1);\n      did[i].resize(graph[i].size() + 1);\n      L[i].reserve(graph[i].size() + 1);\n      R[i].reserve(graph[i].size() + 1);\n    }\n    dfs(0, graph[0].size(), 1);\n  }\n\npublic:\n  T dfs(size_type i) {\n    assert(built);\n    return dfs(i, graph[i].size(), 0);\n  }\n\n  T dfs(size_type i, size_type k) {\n    assert(built);\n    assert(k <= graph[i].size());\n    return dfs(i, k, 0);\n  }\n\n  T dfs_from(size_type i, size_type j) {\n    assert(built);\n    assert(j < n);\n    // TODO : どうする?\n    // return dfs(i, , 0);\n  }\n\nprivate:\n  T dfs(size_type i, size_type p, bool f) {\n    int deg = graph[i].size() - static_cast< size_type >(p != graph[i].size());\n    if(did[i][p]) return dp[i][p];\n    did[i][p] = 1;\n    T res = Monoid::identity();\n    if(f || p == graph[i].size()) {\n      // O(deg)\n      // go only child\n\n      if(p == graph[i].size()) {\n        for(auto to : graph[i]) {\n          size_type j, rev, edge_id;\n          std::tie(j, rev, edge_id) = to;\n          L[i].push_back(dig(dfs(j, rev, f), edge_id, i, j));\n        }\n        R[i] = L[i];\n        for(int x = 1; x < deg; x++) L[i][x] = Monoid::op(L[i][x - 1], L[i][x]);\n        for(int x = deg - 2; x >= 0; x--) R[i][x] = Monoid::op(R[i][x], R[i][x + 1]);\n        res = L[i].back();\n      } else {\n        for(size_type x = 0; x < graph[i].size(); x++)\n          if(x != p) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            res = Monoid::op(res, dig(dfs(j, rev, f), edge_id, i, j));\n          }\n      }\n    } else {\n      // O(1)\n      dfs(i, graph[i].size(), f);\n      res = Monoid::op(p >= 1 ? L[i][p - 1] : Monoid::identity(),\n                       p + 1 < R[i].size() ? R[i][p + 1] : Monoid::identity());\n    }\n    return dp[i][p] = after(res, i, deg);\n  }\n};\n\n/// }}}--- ////\n\n// my monoid, m-act {{{\nstruct MyMonoid {\n  using T = double;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n// }}}\n\nusing rerooting = ReRooting<MyMonoid>;\nusing T = rerooting::T;\n\nT dig(T a, int id, int from, int to) {\n  return a + 1;\n}\n\nT after(T a, int i, int deg) {\n  if(deg == 0) return a;\n  return a / deg;\n}\n\nconst int N = 1e5;\nstd::vector<std::vector<int>> g;\nint n;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; std::cin >> a >> b;\n    a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  rerooting rr(g, dig, after);\n  rr.build();\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) cout << rr.dfs(i) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, int> , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, p)] != 0)\n        return mp[make_pair(v, p)] * t;\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, 1.0 / k) + 1.0 / k;\n    }\n    mp[make_pair(v, p)] = ans;\n    return ans * t;\n}\nint main()\n{\n    int n, i, x, y;\n\n    scanf(\"%d\", &n)\n\n    for(i = 1; i < n; ++i)\n    {\n        scanf(\"%d %d\", &x, &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\nvector<int> G[1000];\n\ndouble dfs(int cur, int prev, double p, int depth){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return depth*p;\n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        ret+=dfs(e,cur,p/c,depth+1);\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    assert(n<=1000);\n    \n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    \n    \n    rep(i,n){\n        printf(\"%.20lf\\n\",dfs(i,-1,1,0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n\nint a;\nvector<int>rinsetu[100000];\nunordered_map<int, unordered_map<int, double>>U;//頂点IからJに進むときの進む距離の平均\ndouble saiki(int i, int j) {\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tdouble K = 1;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while(getline(ss,x,c)) v.emplace_back(x); return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\ndouble re[151234];\ndouble dp[151234];\n\ndouble dfs(const vv<int> &g,int v,int p){\n  double re=0;\n  int cnt=0;\n  for(int w:g[v])if(w!=p) re+=dfs(g,w,v)+1, ++cnt;\n  return dp[v]=cnt?re/cnt:0;\n}\nvoid dfs(const vv<int> &g,int v,int p,double P){\n  double sum=P;\n  for(int w:g[v])if(w!=p) sum+=dp[w]+1;\n  //out(v,sum,P,1);\n  re[v]=sum/g[v].size();\n  //for(int w:g[v])if(w!=p) out(v,w,1);\n  for(int w:g[v])if(w!=p) dfs(g,w,v,g[v].size()>1?(sum-dp[w]-1)/(g[v].size()-1)+1:1);\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int n;\n  cin>>n;\n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n  vv<int> g(n);\n  rep(i,n-1){\n    int x,y;\n    cin>>x>>y; --x; --y;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  dfs(g,0,-1);\n  //rep(i,n) cout<<dp[i]<<endl;\n  dfs(g,0,-1,0);\n  rep(i,n) cout<<re[i]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint F[150000];\nvector<int> G[150000], B[150000];\nvector<double> dp[150000];\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  if (F[x] == -1) {\n    for (int i=0; i<G[x].size(); i++) {\n      if (i == p) continue;\n      r += dfs(G[x][i], B[x][i]);\n    }\n    dp[x][p] = (r/c)+1;\n    F[x] = r;\n    if (p < G[x].size()) F[x] += dfs(G[x][p], B[x][p]);\n    return dp[x][p];\n  }\n  else {\n    r = F[x];\n    if (p < G[x].size()) r -= dfs(G[x][p], B[x][p]);\n  }\n  return dp[x][p] = (r/c)+1;\n}\n\n\nsigned main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(x, N) {\n    F[x] = -1;\n    sort(all(G[x]));\n    B[x].resize(G[x].size());\n    dp[x].resize(G[x].size()+1, -1);\n  }\n\n  rep(x, N) {\n    for (int i=0; i<G[x].size(); i++) {\n      int t = G[x][i];\n      B[x][i] = lower_bound(all(G[t]), x) - G[t].begin();\n    }\n  }\n  rep(i, N) {\n    printf(\"%.15f\\n\", dfs(i, G[i].size()));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 150005\nusing namespace std;\n\nint n,tot,fst[N],pnt[N<<1],nxt[N<<1],fa[N],dgr[N],son[N]; double f[N],g[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid dfs1(int x){\n\tint i,y; son[x]=0;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x; dfs1(y);\n\t\t\tf[x]+=f[y]+1; son[x]++;\n\t\t}\n\t}\n\tif (son[x]) f[x]/=son[x];\n}\nvoid dfs2(int x){\n\tint i,y; double sum=g[x];\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]) sum+=f[y]+1;\n\t}\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tif (x==1 && dgr[x]==1) g[y]=1;\n\t\t\t\telse g[y]=(sum-f[y]-1)/(dgr[x]-1)+1;\n\t\t\tdfs2(y);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x); dgr[x]++; dgr[y]++;\n\t}\n\tdfs1(1); dfs2(1);\n\tfor (i=1; i<=n; i++) printf(\"%.12f\\n\",f[i]*son[i]/dgr[i]+g[i]*(dgr[i]-son[i])/dgr[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nvector<int> v[200000];\ndouble dp1[200000];\ndouble dp2[200000];\n\ndouble dfs1(int u,int prev){\n    double ret = 0.0;\n    int cnt;\n    if(u==prev) cnt = v[u].size();\n    else cnt = v[u].size()-1;\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev) continue;\n        ret += (dfs1(v[u][i],u)+1.0)/cnt;\n    }\n    return dp1[u] = ret;\n}\n\nvoid dfs2(int u,int prev){\n    double ret = 0.0;\n    int cnt = v[u].size();\n    int bf = v[prev].size();\n    int w = (bf==1?bf:bf-1);\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev){\n            ret += ((dp2[prev]*bf-(dp1[u]+1.0))/w+1.0)/cnt;\n        }\n        else ret += (dp1[v[u][i]]+1.0)/cnt;\n    }\n    dp2[u] = ret;\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev) continue;\n        dfs2(v[u][i],u);\n    }\n}\n\n\nint main(){\n    int N;cin >> N;\n    for (int i = 0; i < N-1; i++) {\n        int x,y;cin >> x >> y;\n        x--,y--;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    dfs1(0,0);\n    dfs2(0,0);\n    for (int i = 0; i < N; i++) {\n        cout << setprecision(10) << fixed << dp2[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<pair<int, int>> g[N];\nvector<double> expect[N];\n\ndouble dfs(int i, int p, int t) {\n  expect[i][t] = 0;\n  for(auto edge : g[i]) if(edge.first != p) {\n    expect[i][t] += (expect[edge.first][edge.second] < 0)\n      ? dfs(edge.first, i, edge.second)\n      : expect[edge.first][edge.second];\n  }\n  if(g[i].size() - (p != -1)) (expect[i][t] += (g[i].size() - (p != -1)) ) /= (g[i].size() - (p != -1));\n  return expect[i][t];\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    expect[a].emplace_back(-1);\n    expect[b].emplace_back(-1);\n    g[a].emplace_back(b, expect[b].size() - 1);\n    g[b].emplace_back(a, expect[a].size() - 1);\n  }\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) {\n    expect[i].emplace_back(-1);\n    cout << dfs(i, -1, expect[i].size() - 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> g[150005];\ndouble d[150005];\n\nvoid dfs1(int cur, int par) {\n    int cnt = (int)g[cur].size() - (par != -1);\n    if (cnt == 0) return;\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs1(nex, cur);\n        d[cur] += (d[nex] + 1) / cnt;\n    }\n}\n\ndouble ans[150005];\n\nvoid dfs2(int cur, double d_par, int par) {\n    int cnt = g[cur].size();\n    for (int nex : g[cur]) {\n        if (nex == par) ans[cur] += d_par + 1;\n        else ans[cur] += d[nex] + 1;\n    }\n\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs2(nex, (cnt > 1 ? (ans[cur] - d[nex] - 1) / (cnt - 1) : 0), cur);\n    }\n    ans[cur] /= cnt;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << setprecision(20) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n    why I'm too lazy?\n**/\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n#define pb push_back\n#define pp pop_back\n#define ll long long\n#define ld long double\n#define OK puts(\"OK\");\n#define sz(s) (int)s.size()\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\n\ninline int min(int a, int b)\n{\n    return (a > b) ? b : a;\n}\ninline int max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nconst int N = 2e5 + 10;\nconst int inf = 1e9 + 7;\nconst ll linf = 1e17 + 7;\n\nint n, x, y;\ndouble ans[N], d[N];\nvector <int> g[N];\n\nvoid dfs(int v, int p)\n{\n    double ans = 0;\n    for(auto to : g[v])\n    {\n        if(to == p) continue;\n        dfs(to, v);\n        if(v == p)\n            d[v] += (d[to] + 1.0) / sz(g[v]);\n        else\n            d[v] += (d[to] + 1.0) / (sz(g[v]) - 1);\n    }\n}\n\nvoid Dfs(int v, int p)\n{\n    int t = sz(g[v]);\n    int pt = sz(g[p]);\n    int pp = sz(g[p]) - 1;\n\n    if(v > 1) {\n        ans[v] = d[v] * (t - 1) / t;\n        ans[v] += ( (ans[p] - (d[v] + 1.0) / pt) * pt / (pp ? pp : 1) + 1.0 ) / t;\n    }\n\n    for(int to : g[v])\n        if(to != p)\n            Dfs(to, v);\n}\n\nmain()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++)\n        scanf(\"%d%d\", &x, &y), g[x].pb(y), g[y].pb(x);\n    dfs(1, 1);\n    ans[1] = d[1];\n    Dfs(1, 1);\n\n    for(int i = 1 ; i <= n; i++)\n        cout << fixed << setprecision(7) << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nvector<int> lis[150010];\n\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (lis[nod].size() == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (lis[nod].size() - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        cin >> edge[i][0] >> edge[i][1];\n        --edge[i][0];\n        --edge[i][1];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        double ans = 0;\n        for (int item : lis[i])\n        {\n            ans += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        printf(\"%.9f\\n\", ans / lis[i].size());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    Int N;\n\n    vector<vector<Int>> tree;\n    vector<vector<double>> dp;\n    vector<Int> pi;\n\n\n    double dfs1(Int v, Int p = -1) {\n        dp[v].resize(tree[v].size());\n        if (tree[v].size() == 1 && p != -1) {\n            return 0.0;\n        }\n\n        Int cnt = 0;\n        double sum = 0.0;\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) {\n                pi[u] = i;\n                continue;\n            }\n\n            cnt++;\n            double tmp = dfs1(u, v);\n            dp[v][i] = tmp;\n            sum += tmp + 1.0;\n        }\n\n        return sum / cnt;\n    }\n\n    void dfs2(Int v, double res_p = 0.0, Int p = -1) {\n        if (p != -1) {\n            dp[v][pi[v]] = res_p;\n        }\n        if (tree[v].size() == 1 && p != -1) {\n            return;\n        }\n\n        Int cnt = tree[v].size() - 1;\n        double sum = 0.0;\n        for (int i = 0; i < tree[v].size(); ++i) {\n            sum += dp[v][i] + 1.0;\n        }\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) continue;\n            double n_res = cnt > 0 ? (sum - dp[v][i] - 1.0) / cnt : 0;\n            dfs2(u, n_res, v);\n        }\n    }\n\n\n    void solve() {\n        cin >> N;\n        if (N == 1) {\n            cout << 0 << endl;\n            return;\n        }\n        tree.resize(N);\n        dp.resize(N);\n        pi.resize(N);\n        for (int i = 1; i < N; ++i) {\n            Int a, b;\n            cin >> a >> b;\n            a--, b--;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n\n        dfs1(0);\n        dfs2(0);\n\n        vector<double> ans(N);\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < dp[i].size(); ++j) {\n                ans[i] += dp[i][j];\n            }\n            ans[i] /= dp[i].size();\n            ans[i] += 1;\n\n            cout << ans[i] << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef pair<double,int> pdi;\n\n\nvector<int> G[15000];\ndouble val[150000];\ndouble ans[150000];\nint deg[150000];\n\npdi dfs(int cur, int prev){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return pdi(val[cur] = 0,0);\n    \n    int height=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        double res;\n        int h;\n        tie(res,h) = dfs(e,cur);\n        ret+=1+res;\n        height = max(1+h,height);\n    }\n    ret/=c;\n    return pdi(val[cur] = ret,height);\n}\n\n\ndouble dfs2(int cur, int prev, double d_par){\n    vector<pdi> v;\n    for(auto e:G[cur]){\n        if(e==prev)v.pb(pdi(d_par+1,e));\n        else v.pb(pdi(val[e]+1,e));\n    }\n    \n    double ave = 0;\n    rep(i,v.size())ave+=v[i].first;\n    ave/=deg[cur];\n    \n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        if(deg[cur]==1)dfs2(e,cur,0);\n        else dfs2(e,cur,(ave*deg[cur]-(val[e]+1))/(deg[cur]-1));\n    }\n    \n    return ans[cur] = ave;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    \n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        deg[u]++;\n        deg[v]++;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    \n    dfs(0,-1);\n    \n    dfs2(0,-1,0);\n    \n    rep(i,n){\n        printf(\"%.20lf\\n\",ans[i]);\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nint deg[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    int p = deg[u];\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) * 1.0 / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    int p = deg[u];\n    for (int v : G[u]) if (v != fa) {\n        if (fa == -1) {\n            if (p == 1)\n                dp2[v] = 1;\n            else\n                dp2[v] = ((dp[u] + 1) * p - (dp[v] + 2)) / (p - 1);\n        }\n        else\n            dp2[v] = ((dp2[u] + 1) + (dp[u] + 1) * (p - 1) - (dp[v] + 2)) / (p - 1);\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n\n    for (int i = 1; i < N; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n        deg[u] ++, deg[v] ++;\n    }\n\n    dp2[1] = 0;\n    dfs(1, -1);\n    dfs2(1, -1);\n\n//    for (int i = 1; i <= N; i ++)\n//        cout<<i<<\" \"<<dp[i]<<\" \"<<dp2[i]<<\" \"<<deg[i]<<endl;\n\n    printf(\"%.8f\\n\", dp[1]);\n    for (int i = 2; i <= N; i ++) {\n        printf(\"%.8f\\n\", (dp[i] * (deg[i] - 1) + dp2[i]) * 1.0 / deg[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)\n\ntypedef long long llong;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst double EPS = 1e-9;\n\n#define MAXN 150004\nint N;\nVI adj[MAXN];\n\nint par[MAXN];\nint nchildren[MAXN];\ndouble E_down[MAXN];\ndouble sum_children_E[MAXN];\nvoid dfs1(int u) {\n   nchildren[u] = 0;\n   sum_children_E[u] = 0.0;\n   for (int v : adj[u]) {\n      if (v != par[u]) {\n         par[v] = u;\n         nchildren[u]++;\n         dfs1(v);\n         sum_children_E[u] += E_down[v];\n      }\n   }\n   if (nchildren[u] == 0)\n      E_down[u] = 0.0;\n   else\n      E_down[u] = 1 + sum_children_E[u] / nchildren[u];\n}\n\ndouble E_up[MAXN];\ndouble E[MAXN];\nvoid dfs2(int u) {\n   int p = par[u];\n   if (p == -1) {\n      E_up[u] = 0.0;\n      E[u] = E_down[u];\n   }\n   else {\n      if (E_up[p] > EPS)\n         E_up[u] = 1 + (E_up[p] + (sum_children_E[p] - E_down[u]) + nchildren[p] - 1) / nchildren[p];\n      else\n         E_up[u] = 1 + ((sum_children_E[p] - E_down[u]) + nchildren[p] - 1) / (nchildren[p]-1);\n      E[u] = E_up[u] / (nchildren[u]+1) + E_down[u] * nchildren[u] * 1.0 / (nchildren[u]+1);\n   }\n   for (int v : adj[u]) {\n      if (v != p)\n         dfs2(v);\n   }\n}\n\nint main(int argc, char* argv[]) {\n   scanf(\"%d\", &N);\n   REP(j, N-1) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      --u, --v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n   }\n\n   par[0] = -1;\n   dfs1(0);\n\n   dfs2(0);\n\n   REP(u, N) {\n   // fprintf(stderr, \"%d: Edown=%.05f  Eup=%.05f  E=%.05f\\n\", u+1, E_down[u], E_up[u], E[u]);\n      printf(\"%.010f\\n\", E[u]);\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n#define double long double\n#define EPS 1e-9\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tint M;\n\tif (N > 0)\n\t\tM = A[0].size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1LL << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\ndouble dfs(vector< vector< int > > &G, vector< map< int, double > > &dp, int x, int p, int f) {\n\tif (dp[x].count(p))\n\t\treturn dp[x][p];\n\tdouble ret = 0.0;\n\tif (f || p == -1) {\n\t\tfor (auto j : G[x]) {\n\t\t\tif (j == p)\n\t\t\t\tcontinue;\n\t\t\tret += dfs(G, dp, j, x, f);\n\t\t}\n\t} else {\n\t\tdouble a = dfs(G, dp, x, -1, f);\n\t\tdouble b = dfs(G, dp, p, x, f);\n\t\tint d = G[x].size();\n\t\tret = (a - 1.0) * d - b;\n\t}\n\tint d = G[x].size() - (p != -1);\n\tif (d) {\n\t\tret /= d;\n\t\tret += 1.0;\n\t}\n\treturn dp[x][p] = ret;\n}\nsigned main() {\n\tcin >> N;\n\tvector< vector< int > > G(N);\n\trep(i, N - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u;\n\t\t--v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< map< int, double > > dp(N);\n\tdfs(G, dp, 0, -1, 1);\n\trep(i, N) cout << dfs(G, dp, i, -1, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Data, typename T >\nstruct ReRooting {\n\n  struct Node {\n    int to, rev;\n    Data data;\n  };\n\n  using F1 = function< T(T, T) >;\n  using F2 = function< T(T, int, int, Data) >; // ret, src, to, data\n\n\n  vector< vector< Node > > g;\n  vector< vector< T > > ldp, rdp;\n  vector< int > lptr, rptr;\n  const F1 f1;\n  const F2 f2;\n  const T ident;\n\n  ReRooting(int n, const F1 &f1, const F2 &f2, const T &ident) :\n      g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}\n\n  void add_edge(int u, int v, const Data &d) {\n    g[u].emplace_back((Node) {v, (int) g[v].size(), d});\n    g[v].emplace_back((Node) {u, (int) g[u].size() - 1, d});\n  }\n\n  T dfs(int idx, int par) {\n\n    while(lptr[idx] != par && lptr[idx] < g[idx].size()) {\n      auto &e = g[idx][lptr[idx]];\n      ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      ++lptr[idx];\n    }\n    while(rptr[idx] != par && rptr[idx] >= 0) {\n      auto &e = g[idx][rptr[idx]];\n      rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      --rptr[idx];\n    }\n    if(par < 0) return rdp[idx][0];\n    return f1(ldp[idx][par], rdp[idx][par + 1]);\n  }\n\n  vector< T > solve() {\n    for(int i = 0; i < g.size(); i++) {\n      ldp[i].assign(g[i].size() + 1, ident);\n      rdp[i].assign(g[i].size() + 1, ident);\n      lptr[i] = 0;\n      rptr[i] = (int) g[i].size() - 1;\n    }\n    vector< T > ret;\n    for(int i = 0; i < g.size(); i++) {\n      ret.push_back(dfs(i, -1));\n    }\n    return ret;\n  }\n};\n\nconst int INF = 1 << 30;\nusing pi = pair< double, int >;\n\nint main() {\n  int N, D;\n  cin >> N;\n\n  auto f1 = [](pi a, pi b) {\n    return pi(a.first + b.first, a.second + b.second);\n  };\n\n  auto f2 = [](pi a, int src, int to, int data) {\n    return pi((a.second == 0 ? 0.0 : a.first / a.second) + 1.0, 1);\n  };\n\n  ReRooting< int, pi > g(N, f1, f2, {0.0, 0});\n  for(int i = 1; i < N; i++) {\n    int s, t;\n    cin >> s >> t;\n    --s, --t;\n    g.add_edge(s, t, 0);\n  }\n\n  for(auto &p : g.solve()) {\n    cout << fixed << setprecision(10) << (p.second == 0 ? 0.0 : p.first / p.second) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    if(dp2[a]>0)return ;\n    if(a==0)return ;\n    dfs2(par[a]);\n    int b=par[a];\n    ld p=v[b].size();\n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    for(auto x:u){\n        for(int i=0;i<n;i++)ch[i]=0;\n        ch[x]=1;\n        dfs2(x);\n    }\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 15e4;\nvector<vector<int>> g(N);\nmap<int, ld> dp[N];\nint n;\nld dfs(int i, int p, int f = 0) {\n  if(dp[i].count(p)) return dp[i][p];\n  int cnt = 0;\n  ld res = 0;\n  if(f || p == -1) {\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      res += dfs(j, i, f);\n    }\n  } else {\n    cnt = g[i].size() - 1;\n    res = (dfs(i, -1, f) - 1.0) * g[i].size() - dfs(p, i, f);\n  }\n  if(cnt) res /= cnt, res += 1.0;\n  return dp[i][p] = res;\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  dfs(0, -1, 1);\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << dfs(i, -1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define ST string\n#define BS bitset\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define FOR(i,a,n) for(i=a;i<n;i++)\n#define rep(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define INF 1145141919810364364\n#define PI 3.14159265358979\n//#define MOD 1000000007\n#define MOD 998244353\n#define ERR 0.00000000000001\n#define NUM 200010\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nLL mod(LL a,LL m){if(a<0)return a%m+m;else return a%m;}\nLL DIV(LL a,LL d){LL m=MOD,x=1,y=0,k;while(m){k=d/m;d-=k*m;swap(m,d);x-=k*y;swap(x,y);}return mod(a*mod(x,MOD),MOD);}\nLL FAC(LL a){LL i,ans=1;FOR(i,1,a+1){ans*=i;if(MOD>0&&ans>MOD)ans%=MOD;}return ans;}\nLL POW(LL a,LL n){LL ans=1;while(n>0){if(n&1)ans=ans*a%MOD;a=a*a%MOD;n>>=1;}return ans;}\nLL fact[NUM],finv[NUM],inv[NUM];\nvoid comi(){LL i;fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,NUM){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\n\nVVL g(150010);\nmap<LL,DB> dp[150010];\nDB dfs(LL i,LL p,LL f=0){\n  if(dp[i].count(p))return dp[i][p];\n  LL n=g[i].size();\n  if(p!=-1)n--;\n  DB ret=0;\n  if(f||p==-1){\n    for(LL j:g[i])if(j!=p){\n      ret+=dfs(j,i,f);\n    }\n  }else{\n    ret=(dfs(i,-1,f)-1)*(n+1)-dfs(p,i,f);\n  }\n  if(n)ret=ret/n+1;\n  return dp[i][p]=ret;\n}\n\nint main(){\n  FAST;\n  LL i,ans=0,N,u,v;\n  cin>>N;\n  rep(i,N-1){\n    cin>>u>>v;\n    g[u].EB(v);\n    g[v].EB(u);\n  }\n  dfs(1,-1,1);\n  FOR(i,1,N+1)printf(\"%.8f\\n\",dfs(i,-1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n  }\n}init;\n\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n\n  Edge rev() const {return Edge(to,from,cost);}\n  \n  friend ostream& operator<<(ostream &os, const Edge &e){\n    os << \"(FROM: \" << e.from << \",\" << \"TO: \" << e.to << \",\" << \"COST: \" << e.cost << \")\";\n    return os;\n  }\n};\n\ntemplate <typename T> using Graph = vector<vector<Edge<T>>>;\ntemplate <typename T> using Tree = vector<vector<Edge<T>>>;\n\ntemplate <typename C, typename T> void add_edge(C &g, int from, int to, T w){\n  g[from].push_back(Edge<T>(from, to, w));  \n}\n\ntemplate <typename C, typename T> void add_undirected(C &g, int a, int b, T w){\n  g[a].push_back(Edge<T>(a, b, w));\n  g[b].push_back(Edge<T>(b, a, w));\n}\n\n\n\ntemplate <typename T, typename U>\nstruct ZenhouiTreeDP{\n  int N;\n  Tree<T> tree;\n  vector<int> parent, ch_num, edge_num;\n  vector<U> sub_dp, bottom_up_dp, result;\n  U id;\n  \n  ZenhouiTreeDP(const Tree<T> &tree, U id):\n    N(tree.size()), tree(tree), parent(N), ch_num(N), edge_num(N), sub_dp(N), bottom_up_dp(N, id), result(N), id(id)\n  {\n    rooting(0);\n  }\n\n  void rooting(int cur, int par = -1){\n    edge_num[cur] = tree[cur].size();\n    parent[cur] = par;\n    \n    auto it = tree[cur].begin();\n    while(it != tree[cur].end()){\n      if(it->to == par) break;\n      ++it;\n    }\n    if(it != tree[cur].end()) tree[cur].erase(it);\n\n    ch_num[cur] = tree[cur].size();\n\n    for(auto &e : tree[cur]){\n      rooting(e.to, e.from);\n    }\n  }\n\n  virtual void subtree_func(int cur, int to){}\n  \n  void sub_dfs(int cur){\n    sub_dp[cur] = id;\n    \n    for(auto &e : tree[cur]){\n      sub_dfs(e.to);\n      subtree_func(cur, e.to);\n    }\n  }\n\n  virtual void bottom_up_func(int cur, int par, U left, U right){}\n  virtual U sum_func(U prev, int cur){return 0;}\n\n  void accum_dfs(int cur){\n    int size = tree[cur].size();\n\n    vector<U> left_sum(size+1, id);\n    U right_sum = id;\n\n    for(int i = 0; i < size; ++i){\n      left_sum[i+1] = sum_func(left_sum[i], tree[cur][i].to);\n    }\n\n    for(int i = size-1; i >= 0; --i){\n      int nxt = tree[cur][i].to;\n\n      bottom_up_func(nxt, cur, left_sum[i], right_sum);\n      \n      right_sum = sum_func(right_sum, nxt);\n      accum_dfs(nxt);\n    }\n  }\n\n  virtual void result_func(int cur){}\n\n  void dfs(int cur){\n    result_func(cur);\n    for(auto &e : tree[cur]){\n      dfs(e.to);\n    }\n  }\n\n  void run(){\n    sub_dfs(0);\n    accum_dfs(0);\n    dfs(0);\n  }\n};\n\n\n\n\nstruct DP : public ZenhouiTreeDP<int, double>{\n  DP(const Tree<int> &tree): ZenhouiTreeDP<int,double>(tree, 0){}\n\n  void subtree_func(int cur, int to){\n    sub_dp[cur] += (sub_dp[to] + 1) / ch_num[cur];\n  }\n\n  void bottom_up_func(int cur, int par, double left, double right){\n    int size = (parent[par] != -1 ? 1 : 0) + ch_num[par] - 1;\n    \n    if(parent[par] != -1) bottom_up_dp[cur] += bottom_up_dp[par] + 1;\n    bottom_up_dp[cur] += left + right;\n\n    if(size == 0) bottom_up_dp[cur] = 0;\n    else bottom_up_dp[cur] /= size;\n  }\n  \n  double sum_func(double prev, int cur){\n    return prev + (sub_dp[cur] + 1);\n  }\n\n  void result_func(int cur){\n    result[cur] = 0;\n    if(parent[cur] != -1) result[cur] += bottom_up_dp[cur] + 1;\n    for(auto &e : tree[cur]){\n      result[cur] += sub_dp[e.to] + 1;\n    }\n    result[cur] /= edge_num[cur];\n  }\n\n\n  void run(){\n    ZenhouiTreeDP<int,double>::run();\n  }\n};\n\n\n\n\n\n\n\n\n\nint main(){\n  int N;\n  while(cin >> N){\n    Tree<int> tree(N);\n    REP(i,N-1){\n      int u, v; cin >> u >> v;\n      --u, --v;\n      add_undirected(tree, u, v, 1);\n    }\n\n    DP zdp(tree);\n    zdp.run();\n\n    REP(i,N){\n      cout << zdp.result[i] << endl;\n    }\n    cerr << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v, connect[150001];\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t\tconnect[u]++;\n\t\tconnect[v]++;\n\t}\n\n\tfor (int i = 1; i <= n; i++){\n\t\tif (connect[i] == 1){\n\t\t\tcout << n - 1 << endl;\n\t\t}\n\t\telse{\n\t\t\tfloat num = n - 1;\n\t\t\tcout << num / 2 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\ndouble dp[150000],ans[150000];\nvector<int>E[150000];\ndouble dfs(int v,int p){\n\tdouble ans=0;\n\tfor(int u:E[v]){\n\t\tif(u!=p)ans+=(dfs(u,v)+1)/double(E[v].size()-(p!=-1));\n\t}\n\treturn dp[v]=ans;\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)ans[v]=dp[v];\n\telse{\n\t\tif(E[p].size()==1)ans[v]=dp[v];\n\t\telse ans[v]=(ans[p]*E[p].size()-dp[v]+1)/(E[p].size()-1)/E[v].size()+dp[v]*(E[v].size()-1)/E[v].size();\n\t}\n\tfor(int u:E[v]){\n\t\tif(u!=p)dfs2(u,v);\n\t}\n}\nint main(){\n\tint n;scanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);u--;v--;\n\t\tE[u].push_back(v);E[v].push_back(u);\n\t}\n\tdfs(0,-1);dfs2(0,-1);\n\trep(i,n)printf(\"%.12lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\ndouble ans[150000];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tdouble ans;\n\t\tif (E[i].size() == 1)ans = n - 1;\n\t\telse ans = (n - 1)*0.5;\n\t\tprintf(\"%.12lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define MP(a,b) make_pair(a,b)\ntypedef long long LL;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\nconst LL MOD = 1000000007LL;\nvector<int> G[150000];\ndouble dp[150000];\ndouble dp2[150000];\nvoid dfs1(int v, int par) {\n\tint cnt = 0;\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) continue;\n\t\tdfs1(to, v);\n\t\tdp[v] += (dp[to] + 1);\n\t\tcnt++;\n\t}\n\tif (cnt > 0) dp[v] /= cnt;\n}\nvoid dfs2(int v, int d_par, int par) {\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) dp2[v] += (d_par + 1);\n\t\telse dp2[v] += (dp[to] + 1);\n\t}\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) continue;\n\t\tdouble D = dp2[v] - (dp[to] + 1);\n\t\tif (G[v].size() > 1) D /= (G[v].size() - 1);\n\t\tdfs2(to, D, v);\n\t}\n\tdp2[v] /= G[v].size();\n}\nint main() {\n\tint N;\n\tcin >> N;\n\trep(i, N - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs1(0, -1);\n\tdfs2(0, 0, -1);\n\trep(i, N) {\n\t\tprintf(\"%.15lf\\n\", dp2[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// https://s8pc-4.contest.atcoder.jp/tasks/s8pc_4_d\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\nvector<tuple<int, double>> G[150000];\ndouble expects[150000];\n\ndouble dfs(int cur, int last)\n{\n  double sum = 0;\n  int branches = 0;\n  for (auto& ce : G[cur]) {\n    int c;\n    double e;\n    c = get<0>(ce);\n    if (c == last) {\n      continue;\n    }\n    branches++;\n    e = dfs(c, cur);\n    e++;\n    get<1>(ce) = e;\n    sum += e;\n  }\n  if (branches == 0) {\n    return 0;\n  }\n  return sum / branches;\n}\n\nvoid dfs2(int cur, int last, double cle)\n{\n  double sum = 0;\n  for (auto& ce : G[cur]) {\n    int c;\n    double e;\n    tie(c, e) = ce;\n    if (c == last) {\n      sum += cle;\n      continue;\n    }\n    sum += e;\n  }\n  for (auto& ce : G[cur]) {\n    int c;\n    double e;\n    tie(c, e) = ce;\n    if (c == last) {\n      continue;\n    }\n    double ep = (sum - e); // / (G[cur].size()-1);\n    // printf(\"cur = %d, last = %d, ep = %f\\n\", cur, last, ep);\n    if (ep != 0) {\n      ep /= (G[cur].size()-1);\n    }\n    dfs2(c, cur, ep+1);\n  }\n  expects[cur] = sum / G[cur].size();\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n-1; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--;\n    v--;\n    G[u].push_back(make_tuple(v, 0));\n    G[v].push_back(make_tuple(u, 0));\n  }\n  dfs(0, -1);\n  dfs2(0, -1, 0);\n  for (int i = 0; i < n; i++) {\n    printf(\"%.12f\\n\", expects[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n#include <deque>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\nusing namespace std;\n\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define TEN(n) ((ll)(1e##n))\n#define fst first\n#define snd second\n\nstring DBG_DLM(int &i){return(i++==0?\"\":\", \");}\n#define DBG_B(exp){int i=0;os<<\"{\";{exp;}os<<\"}\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,set<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q);\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q);\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p);\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>mp);\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>mp);\ntemplate<int I,class TPL>void DBG(ostream&os,TPL t){}\ntemplate<int I,class TPL,class H,class...Ts>void DBG(ostream&os,TPL t){os<<(I==0?\"\":\", \")<<get<I>(t);DBG<I+1,TPL,Ts...>(os,t);}\ntemplate<class T,class K>void DBG(ostream&os,pair<T,K>p,string delim){os<<\"(\"<<p.first<<delim<<p.second<<\")\";}\ntemplate<class...Ts>ostream&operator<<(ostream&os,tuple<Ts...>t){os<<\"(\";DBG<0,tuple<Ts...>,Ts...>(os,t);os<<\")\";return os;}\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p){DBG(os,p,\", \");return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v){DBG_B(forr(t,v){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,set<T>s){DBG_B(forr(t,s){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.front();});}\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.top();});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\n#define DBG_OVERLOAD(_1,_2,_3,_4,_5,_6,macro_name,...)macro_name\n#define DBG_LINE(){char s[99];sprintf(s,\"line:%3d | \",__LINE__);cerr<<s;}\n#define DBG_OUTPUT(v){cerr<<(#v)<<\"=\"<<(v);}\n#define DBG1(v,...){DBG_OUTPUT(v);}\n#define DBG2(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG1(__VA_ARGS__);}\n#define DBG3(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG2(__VA_ARGS__);}\n#define DBG4(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG3(__VA_ARGS__);}\n#define DBG5(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG4(__VA_ARGS__);}\n#define DBG6(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG5(__VA_ARGS__);}\n#define DEBUG0(){DBG_LINE();cerr<<endl;}\n#ifdef LOCAL\n#define out(...){DBG_LINE();DBG_OVERLOAD(__VA_ARGS__,DBG6,DBG5,DBG4,DBG3,DBG2,DBG1)(__VA_ARGS__);cerr<<endl;}\n#else\n#define out(...)\n#endif\n\nusing ll=long long;\nusing pii=pair<int,int>;using pll=pair<ll,ll>;using pil=pair<int,ll>;using pli=pair<ll,int>;\nusing vs=vector<string>;using vvs=vector<vs>;using vvvs=vector<vvs>;\nusing vb=vector<bool>;using vvb=vector<vb>;using vvvb=vector<vvb>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate<class A,class B>bool amax(A&a,const B&b){return b>a?a=b,1:0;}\ntemplate<class A,class B>bool amin(A&a,const B&b){return b<a?a=b,1:0;}\nll ri(){ll l;cin>>l;return l;} string rs(){string s;cin>>s;return s;}\n\nusing Weight = int64_t;\nstruct Edge {\n\tint dst;\n\tWeight weight;\n\tEdge() : dst(0), weight(0) {}\n\tEdge(int d, Weight w = 1) : dst(d), weight(w) {}\n};\nostream &operator<<(ostream &os, const Edge &e) { return os << e.dst; }\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid Main() {\n\tint n = ri();\n\tGraph G(n);\n\trep(i, n-1) {\n\t\tint u = ri() - 1;\n\t\tint v = ri() - 1;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\n\tif (n == 1) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tif (n == 2) {\n\t\tcout << 1 << endl << 1 << endl;\n\t\treturn;\n\t}\n\n\tvd E(n);\n\tint root = -1;\n\trep(i, n) {\n\t\tif (sz(G[i]) >= 2) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t{\n\t\tfunction<void(int, int)> dfs = [&](int cur, int pre) {\n\t\t\tint nc = 0;\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst != pre) {\n\t\t\t\t\tdfs(edge.dst, cur);\n\t\t\t\t\tE[cur] += E[edge.dst] + 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nc) E[cur] /= nc;\n\t\t};\n\t\tdfs(root, -1);\n\t}\n\n\tout(E);\n\n\tvd sum(n);\n\n\t{\n\t\tfunction<void(int, int, double)> dfs = [&](int cur, int pre, double e_par) {\n\n\t\t\tint nc = 0;\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst == pre) {\n\t\t\t\t\tsum[cur] += e_par + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnc++;\n\t\t\t\t\tsum[cur] += E[edge.dst] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout(cur, pre, e_par, sum[cur]);\n\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst == pre) continue;\n\t\t\t\tdouble e_par_c = (sum[cur] - (E[edge.dst] + 1)) / (sz(G[cur])-1);\n\t\t\t\tdfs(edge.dst, cur, e_par_c);\n\t\t\t}\n\t\t};\n\t\tdfs(root, -1, 0);\n\t}\n\tout(sum);\n\tcout << fixed << setprecision(10);\n\trep(i, n) {\n\t\tcout << sum[i] / sz(G[i]) << endl;\n\t}\n}\n\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tMain();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** Template Begin ***/\n\n#define USING_BOOST\n#define USING_NAMESPACE\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nauto init_ = [] {\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10);\n    return 0;\n}();\n\ntemplate <typename T>\ninline T in() {\n    T x;\n    std::cin >> x;\n    return x;\n}\n\ntemplate <typename T>\ninline void in(T &x) {\n    std::cin >> x;\n}\n\ntemplate <typename T, typename... Ts>\ninline void in(T &t, Ts &... ts) {\n    std::cin >> t;\n    in(ts...);\n}\n\ntemplate <typename T, typename U = std::vector<T>>\ninline U vin(int n) {\n    U v(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> v[i];\n    }\n    return v;\n}\n\ntemplate <typename T, typename U = std::vector<T>, typename V = std::vector<U>>\ninline V vin(int h, int w) {\n    V vv(h, U(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            std::cin >> vv[i][j];\n        }\n    }\n    return vv;\n}\n\ntemplate <typename T>\ninline void out(const T &x) {\n    std::cout << x << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T, typename... Ts>\ninline void out(const T &t, const Ts &... ts) {\n    std::cout << t << delimiter;\n    out(ts...);\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int n) {\n    for (int i = 0; i < n; ++i) {\n        if (i) std::cout << delimiter;\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int h, int w) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (j) std::cout << delimiter;\n            std::cout << v[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\ntemplate <typename T, size_t D>\nstruct multi_vector_type {\n    using type = std::vector<typename multi_vector_type<T, D - 1>::type>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 1> {\n    using type = std::vector<T>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 0> {\n    using type = T;\n};\n\ntemplate <typename T, size_t D>\nusing multi_vector = typename multi_vector_type<T, D>::type;\n\ntemplate <typename T, size_t D, class = typename std::enable_if<D == 0>::type>\nT make_vector(const T &val = T()) {\n    return val;\n}\n\ntemplate <typename T, size_t D = 1, typename... Ts,\n          class = typename std::enable_if<D != 0>::type>\nmulti_vector<T, D> make_vector(size_t n, Ts &&... args) {\n    return multi_vector<T, D>(n, make_vector<T, D - 1>(args...));\n}\n\nnamespace detail {\n\ntemplate <typename F>\nstruct Debug {\n    const char *delim_ = \"\\n\";\n    F fun;\n\n    Debug(F f) : fun(f) {}\n\n    ~Debug() { fun(delim_); }\n\n    Debug &delim(const char *d) {\n        delim_ = d;\n        return *this;\n    }\n};\n\nstd::deque<std::string> split(const std::string &s, char c) {\n    std::deque<std::string> v;\n    std::stringstream ss(s);\n    std::string x;\n    while (std::getline(ss, x, c)) v.emplace_back(x);\n    return v;\n}\n\ntemplate <typename T>\nvoid deb(const char *delim, std::deque<std::string> v, T a) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << '\\n';\n    std::cerr << std::flush;\n}\n\ntemplate <typename T, typename... Args>\nvoid deb(const char *delim, std::deque<std::string> v, T a, Args... args) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << delim;\n    v.pop_front();\n    deb(delim, std::move(v), args...);\n}\n\ntemplate <typename... Args>\nauto wrap(std::deque<std::string> v, Args... args) {\n    auto f = [=](const char *delim = \"\\n\") { deb(delim, v, args...); };\n\n    return Debug<decltype(f)>(f);\n}\n}\n\n#define debug(args...) ::detail::wrap(::detail::split(#args, ','), args)\n\n#ifdef USING_BOOST\n\n#include <boost/math/common_factor.hpp>\n#include <boost/range.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/algorithm_ext.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/numeric.hpp>\n\ninline auto rep(int begin, int end) {\n    if (begin > end) {\n        return boost::irange(0, 0);\n    } else {\n        return boost::irange(begin, end);\n    }\n}\n\ninline auto rep(int begin, int end, int step) {\n    if ((step > 0 && begin > end) || (step < 0 && begin < end)) {\n        return boost::irange(0, 0, step);\n    } else {\n        return boost::irange(begin, end, step);\n    }\n}\n\n#endif\n\n#ifdef USING_NAMESPACE\nusing namespace std;\n\n#ifdef USING_BOOST\nusing namespace boost;\nusing namespace boost::adaptors;\n#endif\n#endif\n\n/*** Template End ***/\n\nint n;\nvector<vector<int>> graph;\nvector<bool> used;\n\ndouble dfs(int i) {\n    used[i] = true;\n\n    int cnt = 0;\n    double res = 0.0;\n\n    for (int to : graph[i]) {\n        if (used[to]) {\n            continue;\n        }\n\n        cnt++;\n\n        res += dfs(to) + 1.0;\n    }\n\n    if (cnt == 0) {\n        return 0.0;\n    } else {\n        return res / cnt;\n    }\n}\n\nint main() {\n    in(n);\n\n    graph.resize(n);\n    used.resize(n);\n\n    for (int i : rep(0, n - 1)) {\n        int u, v;\n        in(u, v);\n        u--;\n        v--;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    if (all_of(graph.begin(), graph.end(),\n               [](auto &node) { return node.size() <= 2; })) {\n        for (int i : rep(0, n)) {\n            if (graph[i].size() == 1) {\n                out(n - 1);\n            } else {\n                out((n - 1) / 2.0);\n            }\n        }\n    } else if (n <= 1000) {\n        for (int i : rep(0, n)) {\n            fill(used, false);\n            out(dfs(i));\n        }\n    } else {\n        assert(false);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ALL(v) (v).begin(),(v).end()\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst long long MOD = 1e9 + 7;\n\n#define MAX_N 150000\n\nvector<int> G[MAX_N];\n\ndouble dfs(int v, int pre){\n    vector<double> t;\n    for (auto to : G[v]) {\n        if (to == pre) continue;\n        t.emplace_back(dfs(to, v));\n    }\n    if (t.size() == 0) return 0;\n    double res = 0;\n    rep(i,t.size()){\n        res += t[i];\n    }\n    return res / (double)t.size() + 1.0;\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n    int u, v;\n    rep(i, n - 1) {\n        cin >> u >> v;\n        u--;\n        v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    if (n > 1000) return 0;\n    rep(v, n) {\n        printf(\"%.10lf\\n\", dfs(v, -1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nvector<int> e[150010];\nvector<int> ri[150010];\nvector<double> dp[150010];\nint done[150010];\ndouble s[150010];\nint n;\ndouble dfs(int v, int pi) {\n\tif (done[v] == n) {\n\t\treturn s[v] - dp[v][pi];\n\t}\n\tif (done[v] != -1) {\n\t\tif (pi == done[v]) {\n\t\t\treturn s[v];\n\t\t}\n\t\tif (e[v].size() == 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tint i = done[v];\n\t\ts[v] += dp[v][i] = (1.0 + dfs(e[v][i], ri[v][i])) / (e[v].size() - 1.0);\n\t\tdone[v] = n;\n\t\treturn s[v] - dp[v][pi];\n\t}\n\tdone[v] = pi;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tif (i == pi) {\n\t\t\tcontinue;\n\t\t}\n\t\ts[v] += dp[v][i] = (1.0 + dfs(e[v][i], ri[v][i])) / (e[v].size() - 1.0);\n\t}\n\treturn s[v];\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tdone[i] = -1;\n\t\ts[i] = 0.0;\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\t--u; --v;\n\t\tri[u].push_back((int)e[v].size());\n\t\tri[v].push_back((int)e[u].size());\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i] = vector<double>(e[i].size(), 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < e[i].size(); j++) {\n\t\t\tdfs(i, j);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble k = 0;\n\t\tfor (int j = 0; j < e[i].size(); j++) {\n\t\t\tk += (1.0 + dfs(e[i][j], ri[i][j])) / e[i].size();\n\t\t}\n\t\tprintf(\"%.12f\\n\", k);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nconst int limit=150010;\nusing edge=struct{int to,rev;};\nvector<edge> graph[limit];\nvector<R> dp[limit];\n\nvoid add_edge(int from,int to){ \n\tgraph[from].push_back({to,int(graph[to].size())});\n\tgraph[to].push_back({from,int(graph[from].size())-1});\n\tdp[from].push_back(-1.0);\n\tdp[to].push_back(-1.0);\n}\n\n\n\nR dfs(int v,int i){\n\tif(i==-1){\n\t\tR ret=0.0;\n\t\tconst int m=graph[v].size();\n\t\trep(j,m){\n\t\t\tconst int nv=graph[v][j].to;\n\t\t\tconst int ni=graph[v][j].rev;\n\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t}\n\t\tret/=m;\n\t\treturn ret;\n\t}else{\n\t\tR &ret=dp[v][i];\n\t\tif(ret>=0.0) return ret;\n\t\tret=0.0; \n\t\tconst int m=int(graph[v].size());\n\t\trep(j,m){\n\t\t\tif(j==i) continue;\n\t\t\tconst int nv=graph[v][j].to;\n\t\t\tconst int ni=graph[v][j].rev;\n\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t}\n\t\tif(m!=1) ret/=(m-1);\n\t\treturn ret;\n\t}\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i,n-1){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\n\tcout.precision(20);\n\trep(i,n) cout << fixed << dfs(i,-1) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b,ok,ch[15000],L;\nvector<int> v[15000];\nld ans[15000];\nmap<int,int>mp;\nvoid dfs(int A){\n    if(mp[A]==1)ans[A]=n-1;\n    else ans[A]=ld(n-1)/2.0;\n    for(auto x:v[A]){\n        if(ch[x]!=0)continue;\n        ch[x]=ch[A]+1;\n        dfs(x);\n    }\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        mp[a]++;\n        mp[b]++;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(auto x:mp){\n        if(x.second==1)L=x.first;\n        if(x.second>2)ok=1;\n    }\n    if(ok==0){\n        ch[L]=1;\n        dfs(L);\n    }\n    for(int i=0;i<n;i++){\n        cout<<ans[i]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define mod 1000000007\n#define INF 1145141919810364364\n#define int long long\n#define all(vec) vec.begin(),vec.end()\n#define P pair<int,int>\n#define S second\n#define F first\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nbool prime(int x) {\n\tfor (int i = 2; i <= sqrt(x); i++) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nint kai(int x, int y) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= mod;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y) {\n\tif (y > x)return 0;\n\treturn kai(x, y) * mod_pow(kai(y, y), mod - 2, mod) % mod;\n}\n\nint n;\nvector<int> vec[150010];\nint cnt[150010];\nlong double ansdown[150010];\nlong double ans[150010];\nbool bl[150010];\n\nvoid dfs(int x) {\n\tbl[x] = true;\n\tfor (int i = 0; i < (int)vec[x].size(); i++) {\n\t\tif (!bl[vec[x][i]]) {\n\t\t\tdfs(vec[x][i]);\n\t\t\tcnt[x]++;\n\t\t\tansdown[x] += ansdown[vec[x][i]] + 1;\n\t\t}\n\t}\n\tif (cnt[x])ansdown[x] /= cnt[x];\n}\n\nvoid dfs2(int x) {\n\tbl[x] = true;\n\tfor (int i = 0; i < (int)vec[x].size(); i++) {\n\t\tif (!bl[vec[x][i]]) {\n\t\t\tif (cnt[x] == 1)ans[vec[x][i]] = (ansdown[vec[x][i]] * cnt[vec[x][i]] + 1) / (cnt[vec[x][i]] + 1);\n\t\t\telse ans[vec[x][i]] = ((ans[x] * cnt[x] - ansdown[vec[x][i]] - 1) / (cnt[x] - 1) + 1 + ansdown[vec[x][i]] * cnt[vec[x][i]]) / (cnt[vec[x][i]] + 1);\n\t\t\tcnt[vec[x][i]]++;\n\t\t\tdfs2(vec[x][i]);\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tvec[a].push_back(b);\n\t\tvec[b].push_back(a);\n\t}\n\tdfs(1);\n\tans[1] = ansdown[1];\n\tfill(bl, bl + n + 5, false);\n\tdfs2(1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%.15Lf\", ans[i]);\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], deg[150000];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        deg[u]++;\n        deg[v]++;\n        E[i][0] = u;\n        E[i][1] = v;\n    }\n\n    rep(i, N)if (deg[i] > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        //rep(i, N)printf(\"%.10f\\n\", ans);\n        //exit(0);\n    }\n    rep(i, N - 1)rep(j, 2)G[E[i][j]].push_back(i);\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\ntypedef long double ld;\n\nint n;\nvector<int> t[150000];\nbool used[150000];\nvector<int> g[150000];\nld e[150000];\nld ans[150000];\n\nvoid make_graph(int i){\n    used[i] = true;\n    for(int v: t[i]){\n        if(!used[v]){\n            g[i].push_back(v);\n            make_graph(v);\n        }\n    }\n}\n\nld dfs(int i){\n    ld c = 0;\n    for(int v: g[i]){\n        c += dfs(v) + 1;\n    }\n    return e[i] = c / max((int)g[i].size(), 1);\n}\n\nvoid solve(int i, ld u){\n    if(i == 0){\n        ans[i] = e[i];\n        ld s = 0;\n        for(int v: g[i]){\n            s += e[v];\n        }\n        for(int v: g[i]){\n            solve(v, g[i].size() == 1 ? 0 : (s - e[v]) / (g[i].size() - 1) + 1);\n        }\n        return;\n    }\n    ans[i] = (u + 1 + g[i].size() * e[i]) / (g[i].size() + 1);\n    ld s = 0;\n    for(int v: g[i]){\n        s += e[v];\n    }\n    for(int v: g[i]){\n        solve(v, (s - e[v] + u) / g[i].size() + 1);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        t[u - 1].push_back(v - 1);\n        t[v - 1].push_back(u - 1);\n    }\n\n    make_graph(0);\n\n    dfs(0);\n\n    solve(0, -1);\n\n    rep(i, n){\n        cout << ans[i] << setprecision(10) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n#include <deque>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\nusing namespace std;\n\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define TEN(n) ((ll)(1e##n))\n#define fst first\n#define snd second\n\nstring DBG_DLM(int &i){return(i++==0?\"\":\", \");}\n#define DBG_B(exp){int i=0;os<<\"{\";{exp;}os<<\"}\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,set<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q);\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q);\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p);\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>mp);\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>mp);\ntemplate<int I,class TPL>void DBG(ostream&os,TPL t){}\ntemplate<int I,class TPL,class H,class...Ts>void DBG(ostream&os,TPL t){os<<(I==0?\"\":\", \")<<get<I>(t);DBG<I+1,TPL,Ts...>(os,t);}\ntemplate<class T,class K>void DBG(ostream&os,pair<T,K>p,string delim){os<<\"(\"<<p.first<<delim<<p.second<<\")\";}\ntemplate<class...Ts>ostream&operator<<(ostream&os,tuple<Ts...>t){os<<\"(\";DBG<0,tuple<Ts...>,Ts...>(os,t);os<<\")\";return os;}\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p){DBG(os,p,\", \");return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v){DBG_B(forr(t,v){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,set<T>s){DBG_B(forr(t,s){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.front();});}\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.top();});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\n#define DBG_OVERLOAD(_1,_2,_3,_4,_5,_6,macro_name,...)macro_name\n#define DBG_LINE(){char s[99];sprintf(s,\"line:%3d | \",__LINE__);cerr<<s;}\n#define DBG_OUTPUT(v){cerr<<(#v)<<\"=\"<<(v);}\n#define DBG1(v,...){DBG_OUTPUT(v);}\n#define DBG2(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG1(__VA_ARGS__);}\n#define DBG3(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG2(__VA_ARGS__);}\n#define DBG4(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG3(__VA_ARGS__);}\n#define DBG5(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG4(__VA_ARGS__);}\n#define DBG6(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG5(__VA_ARGS__);}\n#define DEBUG0(){DBG_LINE();cerr<<endl;}\n#ifdef LOCAL\n#define out(...){DBG_LINE();DBG_OVERLOAD(__VA_ARGS__,DBG6,DBG5,DBG4,DBG3,DBG2,DBG1)(__VA_ARGS__);cerr<<endl;}\n#else\n#define out(...)\n#endif\n\nusing ll=long long;\nusing pii=pair<int,int>;using pll=pair<ll,ll>;using pil=pair<int,ll>;using pli=pair<ll,int>;\nusing vs=vector<string>;using vvs=vector<vs>;using vvvs=vector<vvs>;\nusing vb=vector<bool>;using vvb=vector<vb>;using vvvb=vector<vvb>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate<class A,class B>bool amax(A&a,const B&b){return b>a?a=b,1:0;}\ntemplate<class A,class B>bool amin(A&a,const B&b){return b<a?a=b,1:0;}\nll ri(){ll l;cin>>l;return l;} string rs(){string s;cin>>s;return s;}\n\nusing Weight = int64_t;\nstruct Edge {\n\tint dst;\n\tWeight weight;\n\tEdge() : dst(0), weight(0) {}\n\tEdge(int d, Weight w = 1) : dst(d), weight(w) {}\n};\nostream &operator<<(ostream &os, const Edge &e) { return os << e.dst; }\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid Main() {\n\tint n = ri();\n\tGraph G(n);\n\tvi deg(n);\n\trep(i, n-1) {\n\t\tint u = ri() - 1;\n\t\tint v = ri() - 1;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t\tdeg[u]++;\n\t\tdeg[v]++;\n\t}\n\n\tvd E(n);\n\tint root = 0;\n\t\n\t{\n\t\tfunction<void(int, int)> dfs = [&](int cur, int pre) {\n\t\t\tint nc = 0;\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst != pre) {\n\t\t\t\t\tdfs(edge.dst, cur);\n\t\t\t\t\tE[cur] += E[edge.dst] + 1;\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nc) E[cur] /= nc;\n\t\t};\n\t\tdfs(root, -1);\n\t}\n\n\tout(deg);\n\tout(E);\n\n\tvd sum(n);\n\n\t{\n\t\tfunction<void(int, int, double)> dfs = [&](int cur, int pre, double e_par) {\n\n\t\t\tint nc = 0;\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst == pre) {\n\t\t\t\t\tsum[cur] += e_par + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnc++;\n\t\t\t\t\tsum[cur] += E[edge.dst] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout(cur, pre, e_par, sum[cur]);\n\n\t\t\tforr(edge, G[cur]) {\n\t\t\t\tif (edge.dst == pre) continue;\n\t\t\t\tdouble e_par_c = sum[cur] - (E[edge.dst] + 1);\n\t\t\t\tif (e_par_c > 0) e_par_c /= deg[cur]-1;\n\t\t\t\tdfs(edge.dst, cur, e_par_c);\n\t\t\t}\n\t\t};\n\t\tdfs(root, -1, 0);\n\t}\n\tout(sum);\n\tcout << fixed << setprecision(10);\n\trep(i, n) {\n\t\tcout << sum[i] / deg[i] << endl;\n\t}\n}\n\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tMain();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string.h>\n#include<iostream>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<string.h>\n#include<algorithm>\n#include <stdlib.h>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\nbool board[100005][7];\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int> >v(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    int root=-1,end=-1;\n    for(int i=0;i<n;i++){\n        if(v[i].size()==1){\n            if(root==-1)root=i;\n            else end=i;\n        }\n    }\n    vector<int>no(n);\n    no[root]=0;\n    no[end]=n-1;\n    int cur=root;\n    int ii=1;\n    while(cur!=end){\n        if(cur!=v[cur][0])cur=v[cur][0];\n        else cur=v[cur][1];\n        no[cur]=ii++;\n        cout<<cur<<\" \"<<no[cur]<<endl;\n    }\n    vector<double>p(n);\n    for(int i=0;i<n;i++){\n        p[i]=(1.0*no[i]+n-1-no[i])/2.0;\n    }\n    for(int i=0;i<n;i++){\n        cout<<p[i]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <time.h>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w = 1) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed = 0) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tcon(a - oindexed, b - oindexed);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//無向\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nsigned main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBiDGraph g(n);\n\tg.scan(n-1,1);\n\n\tvector<double> per(n);\n\n\tfunction<double(int, int)> dfs = [&](int cur, int p) {\n\t\tdouble ret = 0;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\n\t\t\tret += (1+dfs(itr.first, cur))/(double)(g.g[cur].size()-(bool)(p+1));\n\n\t\t}\n\t\treturn per[cur] = ret;\n\t};\n\n\tdfs(0,-1);\n\tvector<double> ans(n);\n\tfunction<void(int, int, double)> dfs2 = [&](int cur, int p, double par) {\n\t\tdouble np = par;\n\t\tdouble sum = np;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t\tans[cur] = sum / g.g[cur].size();\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum -= per[itr.first]+1;\n\t\t\tdfs2(itr.first, cur, 1+ (g.g[cur].size() - 1 ? sum/(g.g[cur].size() - 1) : 0));\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t};\n\tdfs2(0, -1, 0);\n\tans[0] = per[0];\n\tREP(i, n)\n\t\tprintf(\"%.10lf\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<int> g[N];\ndouble dp[N];\ndouble dp1[N];\ndouble dp2[N];\ndouble ans[N];\n\n// †全方位木DP†はO(N)頂点からやると落とされちゃうめう\n\nvoid dfs(int i, int p = -1) {\n  int sz = (g[i].size() - (p != -1));\n  for(int j : g[i]) if(j != p) {\n    dfs(j, i);\n    dp[i] += (1 + dp1[j]);\n    dp1[i] += (1 + dp1[j]) / sz;\n  }\n}\n\nvoid dfs2(int i, int p = -1) {\n  int sz = (g[i].size() - (p != -1));\n  ans[i] = dp[i] + (p != -1 ? dp2[i] : 0);\n  for(int j : g[i]) if(j != p) {\n    dp2[j] = 1 + (ans[i] - (1 + dp1[j])) / (g[i].size() - 1);\n    dfs2(j, i); ////\n  }\n  ans[i] /= g[i].size();\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  dfs(0);\n  dfs2(0);\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst double pi = 3.141592653589793;\n\nint n;\nvector<vector<int>> g(150000+5);\nvector<vector<pair<double,double>>> vp(150000+5);\ndouble ans[150000+5];\n\nvoid dfs1(int now,int par){\n    int size=g[now].size();\n    if (par!=-1) size-=1;\n    for(auto nx: g[now]){\n        if (nx==par) continue;\n        dfs1(nx,now);\n    }\n    double v=0.0;\n    double p=0.0;\n    for (auto nx: g[now]){\n        if (nx==par) continue;\n        v+=(vp[nx][0].fi+vp[nx][0].se)/size;\n        p+=vp[nx][0].se/size;\n    }\n    if (p==0.0) vp[now].pb(make_pair(0.0,1.0));\n    else vp[now].pb(make_pair(v,p));\n    return ;\n}\n\nvoid dfs2(int now,int par,double v,double p){\n    double sumv=0.0;\n    double sump=0.0;\n    int size=g[now].size();\n    for(auto nx: g[now]){\n        if (nx==par){\n            ans[now]+=v/size+p/size;\n            sumv+=v+p;\n            sump+=p;\n        }\n        else{\n            ans[now]+=vp[nx][0].fi/size+vp[nx][0].se/size;\n            sumv+=vp[nx][0].fi+vp[nx][0].se;\n            sump+=vp[nx][0].se;\n        }\n    }\n    for(auto nx: g[now]){\n        if (nx==par) continue;\n        if (size==1) dfs2(nx,now,0,1.0);\n        else dfs2(nx,now,(sumv-(vp[nx][0].fi+vp[nx][0].se))/(size-1),(sump-vp[nx][0].se)/(size-1));\n    }\n    return ;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs1(0,-1);\n    //cout << vp[0][0].fi << vp[0][0].se << endl;\n    //rep(i,12) cout << vp[i][0].fi << vp[i][0].se << endl;\n    dfs2(0,-1,0.0,0.0);\n    rep(i,n) cout << fixed << setprecision(10) << ans[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<int> g[N];\ndouble dp[N];\ndouble dp1[N];\ndouble dp2[N];\ndouble ans[N];\n\n// †全方位木DP†はO(N)頂点からやると落とされちゃうめう\n\nvoid dfs(int i, int p = -1) {\n  int sz = (g[i].size() - (p != -1));\n  for(int j : g[i]) if(j != p) {\n    dfs(j, i);\n    dp[i] += (1 + dp1[j]);\n    dp1[i] += (1 + dp1[j]) / sz;\n  }\n}\n\nvoid dfs2(int i, int p = -1) {\n  ans[i] = dp[i] + (p != -1 ? dp2[i] : 0);\n  for(int j : g[i]) if(j != p) {\n    dp2[j] = 1 + (ans[i] - (1 + dp1[j])) / (g[i].size() - 1); /// コーナーに気をつけよう\n    dfs2(j, i); ////\n  }\n  ans[i] /= g[i].size();\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  if(n == 1) { //\n    cout << 0.0 << endl;\n    return 0;\n  }\n  if(n == 2) { //\n    cout << 1.0 << endl;\n    cout << 1.0 << endl;\n    return 0;\n  }\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  int t = 0;\n  for(int i = 0; i < n; i++) if(g[i].size() >= 2) t = i; /// はい\n  dfs(t);\n  dfs2(t);\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\ndouble dp1[150010];\nvector<vll> G;\nvoid dfs1(ll v,ll p){\n  ll cnt=0;\n  for(ll u:G[v])if(u!=p){\n    dfs1(u,v);\n    dp1[v] += dp1[u];\n    cnt++;\n  }\n  if(cnt>0){\n    dp1[v] /= cnt;\n    dp1[v] += 1;\n  }\n}\ndouble dp2[150010];\nvoid dfs2(ll v,ll p,double pval){\n  double tmp=0;\n  for(ll u:G[v]){\n    if(u==p)tmp += pval;\n    else tmp += dp1[u];\n  }\n  ll size=G[v].size();\n  dp2[v] = tmp/size+1;\n  for(ll u:G[v])if(u!=p){\n    dfs2(u,v,size<=1?0:(tmp-dp1[u])/(size-1)+1);\n  }\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N;cin>>N;\n  G.resize(N);\n  for(ll i=0;i<N-1;i++){\n    ll u,v;cin>>u>>v;u--;v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(0,-1);\n  //debug(dp1[0]);\n  dfs2(0,-1,0);\n  for(ll i=0;i<N;i++){\n    printf(\"%.7lf\\n\",dp2[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define INF_LL (ll)1e18\n#define INF (int)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\nusing ll = long long;\nusing PII = pair<int, int>;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nclass LazySegTree{\nprivate:\n\tint n;\n\tvector<ll> node, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tLazySegTree(vector<ll> v){\n\t\tint sz = v.size();\n\t\tn = 1; while(n < sz) n *= 2;\n\t\tnode.resize(2*n-1, 0);\n\t\tlazy.resize(2*n-1, 0);\n\t\tlazyFlag.resize(2*n-1, false);\n\t\tREP(i, sz) node[i+n-1] = v[i];\n\t\tfor(int i = n-2;i >= 0;i--) node[i] = node[2*i+1]+node[2*i+2];\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazyFlag[k]){\n\t\t\tnode[k] += lazy[k] * (r-l);\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] += lazy[k];\n\t\t\t\tlazy[2*k+2] += lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\n\tvoid add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return;\n\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tadd(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\tadd(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\tnode[k] = node[k*2+1] + node[k*2+2];\n\t\t}\n\t}\n\n\tll query(int a, int b, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\n\t\tif(b <= l || r <= a) return 0;\n\t\tif(a <= l && r <= b) return node[k];\n\n\t\treturn query(a, b, k*2+1, l, (l+r)/2) + query(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nclass Bucket{\nprivate:\n\tint n, bs, bn; // 要素数、バケットサイズ、バケットの数\n\tvector<ll> data;\n\tvector<ll> bucket, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tBucket(vector<ll> v, int sz){\n\t\tdata = v;\n\t\tn = v.size();\n\t\tbs = sz;\n\t\tbn = (n + bs - 1) / bs;\n\t\tdata.resize(bn*bs, INF_LL);\n\t\tbucket.assign(bn, INF_LL);\n\t\tlazy.assign(bn, 0);\n\t\tlazyFlag.assign(bn, 0);\n\t\tREP(i, bn){\n\t\t\tll minx = INF_LL;\n\t\t\tREP(j, bs){\n\t\t\t\tchmin(minx, data[i*bs+j]);\n\t\t\t}\n\t\t\tbucket[i] = minx;\n\t\t}\n\t}\n\n\tvoid eval(int k){\n\t\tif(lazyFlag[k]){\n\t\t\tlazyFlag[k] = false;\n\t\t\tFOR(i, bs*k, bs*(k+1)){\n\t\t\t\tdata[i] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tlazyFlag[k] = true;\n\t\t\t\tbucket[k] = x;\n\t\t\t\tlazy[k] = x;\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t\tbucket[k] = INF_LL;\n\t\t\t\tFOR(i, l, r){\n\t\t\t\t\tchmin(bucket[k], data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll query(int s, int t){\n\t\tll res = INF_LL;\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tchmin(res, bucket[k]);\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tchmin(res, data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n};\n\nvector<int> G[150150];\n\ndouble dfs(int v, int p){\n\tdouble res = 0;\n\tint f = 0;\n\tif(p != -1) f = 1;\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tres += dfs(G[v][i], v)/(G[v].size()-f);\n\t}\n\treturn res+1;\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tREP(i, N-1){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tREP(i, N){\n\t\tcout << fixed << setprecision(10) << dfs(i, -1)-1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Clang Magicできるか？？？\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint n;\nvector<int> et[150000];\nunordered_map<int, double> dp;\n\ndouble dfs(int p, int v)\n{\n\tint childNum = et[v].size() - (p != -1);\n\tif (childNum == 0) return 0;\n\tif (dp.find(p * n + v) != dp.end()) return dp[p * n + v];\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tret += dfs(v, et[v][i]);\n\t}\n\tret /= childNum;\n\treturn dp[p * n + v] = ret + 1;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%.14f\\n\", dfs(-1, i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    if(dp2[a]>0)return ;\n    if(a==0)return ;\n    if(dp2[(int)par[a]]==0)dfs2(par[a]);\n    int b=par[a];\n    ld p=v[b].size();\n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    //cout<<\"W\"<<endl;\n  \t//for(int i=0;i<n;i++)dp2[i]=0;\n    for(auto x:u){\n        dfs2(x);\n    }\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MAX = 150000;\nvector<int> edges[MAX];\nint parent[MAX];\ndouble ans[MAX];\n\ndouble dfs(int i, int prev){\n    double ret = 0.0;\n    parent[i] = prev;\n    for(auto j : edges[i]){\n        if(j == prev) continue;\n        ret += dfs(j, i) + 1.0;\n    }\n    if(edges[i].size()>1){\n        ret /= edges[i].size() - (i == 0 ? 0 : 1);\n    }\n    ans[i] = ret;\n    return ret;\n}\n\nvoid dfs2(int i){\n    if(parent[i] >= 0){\n        int p = parent[i];\n        int sz = edges[p].size();\n        double add;\n        if(sz>1){\n            add = (ans[p] * sz - ans[i] - 1.0) / (sz-1) + 1.0;\n        }else{\n            add = 1.0;\n        }\n        sz = edges[i].size();\n        ans[i] = (ans[i] * (sz-1) + add) / sz;\n    }\n    for(auto j : edges[i]){\n        if(j != parent[i]) dfs2(j);\n    }\n}\n\nint main(){\n    int i, j, k;\n    cin >> N;\n    for(i=0; i<N-1; i++){\n        int u, v;\n        cin >> u >> v;\n        edges[u-1].push_back(v-1);\n        edges[v-1].push_back(u-1);\n    }\n\n    dfs(0, -1);\n    dfs2(0);\n    cout << fixed << setprecision(10);\n    for(i=0; i<N; i++) cout << ans[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tfor (int v : E[i])dfs(i, v);\n\t}\n\trep(i, n) {\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, pair <int, double > > , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, make_pair(p, t))] != 0)\n        return mp[make_pair(v, make_pair(p, t))];\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, t / k) + t / k;\n    }\n    mp[make_pair(v, make_pair(p, t))] = ans;\n    return ans;\n}\nint main()\n{\n    int n, i, x, y;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: d.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-20 10:05:23\n***********************************************/\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> a;\nvector<double> dp;\nvector<double> dp2;\n\ndouble dfs(int cur, int par) {\n    double ans = 0;\n    int cnt = 0;\n    for (auto v : a[cur]) {\n        if (v != par) {\n            ans += 1.0 + dfs(v, cur);\n            ++ cnt;\n        }\n    }\n    if (cnt) ans /= cnt;\n    dp[cur] = ans;\n    return ans;\n}\n\nvoid dfs2(int cur, int par, double back) {\n//    cout << \"cur: \" << cur << \" par: \" << par << \" back= \" << back << endl;\n    double ans = 0.0;\n    for (auto v : a[cur]) {\n        if (v == par) ans += back + 1.0;\n        else ans += dp[v] + 1.0;\n    }\n    dp2[cur] = ans / a[cur].size();\n\n    for (auto v : a[cur]) {\n        if (v != par) {\n            dfs2(v, cur, (ans - dp[v]-1) / max(1, (int)a[cur].size() - 1) );\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    int u, v;\n    a = vector<vector<int>> (n);\n    dp = vector<double>(n);\n    dp2 = vector<double>(n);\n    for (int i = 0; i < n-1; ++ i) {\n        cin >> u >> v;\n        -- u; -- v;\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    \n    for (int i = 0; i < n; ++ i)\n        cout << fixed << setprecision(12) << dp2[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\n\tstd::vector<double> dp(n);\n\tstd::vector<std::vector<std::pair<double, int>>> d(n);\n\tauto dfs = [&](auto&& dfs, int v, int par) -> void {\n\t\tint deg = g[v].size() - (par != -1);\n\t\tfor(auto e: g[v]) {\n\t\t\tif(e == par) continue;\n\t\t\tdfs(dfs, e, v);\n\t\t\tdp[v] += (dp[e] + 1) / deg;\n\t\t\td[v].push_back({(dp[e] + 1) / deg, e});\n\t\t}\n\t};\n\tdfs(dfs, 0, -1);\n\t\n\tstd::vector<double> t(n), ans(n);\n\tauto solve = [&](auto&& solve, int v, int par) -> void {\n\t\tdouble sum = 0;\n\t\tfor(auto e: d[v]) sum += e.first;\n\t\tfor(auto e: d[v]) t[e.second] = e.first;\n\t\tfor(auto e: g[v]) {\n\t\t\tif(e == par) continue;\n\t\t\tint deg = g[e].size() - (g[e].size() != 1);\n\t\t\tdouble tmp = sum - t[e];\n\t\t\tans[e] += (tmp + 1) / g[e].size();\n\t\t\tans[v] += (dp[e] + 1) / g[v].size();\n\t\t\td[e].push_back({(tmp + 1) / deg, v});\n\t\t\tsolve(solve, e, v);\n\t\t}\n\t};\n\tsolve(solve, 0, -1);\n\n\tfor(auto v: ans) printf(\"%.12lf\\n\", v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\n\n#define EPS 1e-9\ntypedef pair<int, int> ii;\n\nvector<vector<int> > g; vector<unordered_map<int, double> > m;\nvector<unordered_map<int, double> > v;\nint N;\n\ndouble solve(int n, int p){\n\tdouble tot = 0, np = 0;\n\tif(p!=-1&&v[n][p]==1)\n\t\treturn m[n][p];\n\tfor(int x=0; x<g[n].size(); x++){\n\t\tif(g[n][x]!=p){\n//\t\t\tcout << n << \" \" << g[n][x] << endl;\n//\t\t\tcout << x << g[n].size() << endl;\n\t\t\tdouble res = solve(g[n][x], n);\n\t\t\ttot += res+1;\n\t\t\tnp++;\n\t\t}\n\t}\n\tif(np==0){\n\t\t//endnode\n\t\tnp++;\n\t}\n\tv[n][p] = 1;\n//\tcout << n << \" \" << p << \" \" << np << endl;\n\tif(p==-1)\n\t\treturn (tot/((double)np));\n\telse\n\t\treturn m[n][p] = (tot/((double)np));\n}\n\nint main(){\n\tiostream::sync_with_stdio(false); cin.tie(0);\n\tcin>>N;\n\tg.assign(N+1, vector<int>());\n\tm.assign(N+1, unordered_map<int, double>());\n\tv.assign(N+1, unordered_map<int, double>());\n\tint A, B;\n\tfor(int n=1; n<N; n++){\n\t\tcin>>A>>B;\n\t\tg[A].push_back(B);\n\t\tg[B].push_back(A);\n\t//\tcout << A << \" \" << B << endl;\n\t}\n\t//for(int x=0; x<g[5].size(); x++)\n\t//\tcout << g[5][x] << endl;\n\tfor(int n=1; n<=N; n++){\n\t\tdouble r = solve(n, -1);\n\t//\tcout << g[5][2] << endl;\n\t\tprintf(\"%.8f\\n\", r);\n\t//\tcout << n << endl;\n\t}\n\t//cout << \"f\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define EPS 1e-9\ntypedef pair<int, int> ii;\n\nvector<vector<int> > g; vector<map<int, double> > m;\nvector<map<int, double> > v;\nint N;\n\ndouble solve(int n, int p){\n\tdouble tot = 0, np = 0;\n\tif(p!=-1&&v[n][p]==1)\n\t\treturn m[n][p];\n\tfor(int x=0; x<g[n].size(); x++){\n\t\tif(g[n][x]!=p){\n//\t\t\tcout << n << \" \" << g[n][x] << endl;\n//\t\t\tcout << x << g[n].size() << endl;\n\t\t\tdouble res = solve(g[n][x], n);\n\t\t\ttot += res+1;\n\t\t\tnp++;\n\t\t}\n\t}\n\tif(np==0){\n\t\t//endnode\n\t\tnp++;\n\t}\n\tv[n][p] = 1;\n//\tcout << n << \" \" << p << \" \" << np << endl;\n\tif(p==-1)\n\t\treturn (tot/((double)np));\n\telse\n\t\treturn m[n][p] = (tot/((double)np));\n}\n\nint main(){\n\tcin>>N;\n\tg.assign(N+1, vector<int>());\n\tm.assign(N+1, map<int, double>());\n\tv.assign(N+1, map<int, double>());\n\tint A, B;\n\tfor(int n=1; n<N; n++){\n\t\tcin>>A>>B;\n\t\tg[A].push_back(B);\n\t\tg[B].push_back(A);\n\t//\tcout << A << \" \" << B << endl;\n\t}\n\t//for(int x=0; x<g[5].size(); x++)\n\t//\tcout << g[5][x] << endl;\n\tfor(int n=1; n<=N; n++){\n\t\tdouble r = solve(n, -1);\n\t//\tcout << g[5][2] << endl;\n\t\tprintf(\"%.8f\\n\", r);\n\t//\tcout << n << endl;\n\t}\n\t//cout << \"f\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\nusing ll = long long;\nll mp(int x, int y) {\n    return (ll)x << 32 | y;\n}\nunordered_map<ll, double> dp;\n\ndouble rec(int u, int p) {\n    if (dp.count(mp(u, p))) {\n        return dp[mp(u, p)];\n    }\n    double &res = dp[mp(u, p)];\n    res = 0;\n    int cnt = 0;\n    for (auto &v : g[u]) {\n        if (v != p) ++cnt;\n    }\n    if (cnt == 0) {\n        res = 0;\n    } else {\n        for (auto &v : g[u]) {\n            if (v != p) {\n                res += 1 + rec(v, u);\n            }\n        }\n        res /= cnt;\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n) {\n        dp.clear();\n        g.assign(n, {});\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%.10f\\n\", rec(i, -1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = true;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = false;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nconst int inf=1145141919;\nconst int mod=1000000007;\nconst int dd[]={0,-1,0,1,0};\nusing namespace std;\nint a,b,c,d;\nstruct Node{\n\tdouble u=0;\n\tvector<int> e;\n\tunordered_map<int,double> ma;\n};\nNode p[150000];\ndouble saiki(int u,int v){\n\tauto it=p[u].ma.find(v);\n\tif(it!=end(p[u].ma))\n\t\treturn it->second;\n\tdouble ans=0;\n\tint i=0;\n\tfor(auto x:p[u].e){\n\t\tif(x==v)\n\t\t\tcontinue;\n\t\tans+=saiki(x,u)+1;\n\t\ti++;\n\t}\n\tif(i!=0)\n\t\tans/=i;\n\tp[u].ma.insert({v,ans});\n\treturn ans;\n}\nsigned main(){\n\tint i,j;\n\tcin>>a;\n\tfor(i=0;i<a-1;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tp[u].e.push_back(v);\n\t\tp[v].e.push_back(u);\n\t}\n\tif(a==1){\n\t\tcout<<\"0\"<<endl;\n\t\treturn 0;\n\t}\n\tfor(i=0;i<a;i++)\n\t\tcout<<setprecision(15)<<saiki(i,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//http://s8pc-4.contest.atcoder.jp/tasks/s8pc_4_d\n// F[u] expert value depart from u and go down\n// G[u] expert value depart from v and go up\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 150000;\n\nint n,deg[maxn];\ndouble F[maxn],G[maxn];\nvector<int> adj[maxn];\n\nvoid visit(int u,int pa) {\n    int son = deg[u] - ((pa!=-1)?1:0);\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            visit(v,u);\n            F[u] = F[u] + 1.0*(F[v]+1)/son;\n        }\n    }\n}\n\nvoid visit2(int u,int pa) {\n    int p = deg[u];\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            if (pa==-1) {\n                if (p==1) G[v]=1;\n                else G[v] = ((F[u]+1)*p - (F[v]+2))/(p-1);\n            }\n            else G[v] = (G[u]+1)/(p-1) + (F[u]+1) - (F[v]+2)/(p-1);\n            visit2(v,u);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n //   freopen(\"in.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int u,v;\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        deg[u]++; deg[v]++;\n    }\n    visit(1,-1);\n    visit2(1,-1);\n    cout.precision(8);\n    cout<<F[1]<<endl;\n    for (int i=2;i<=n;i++) cout<<(F[i]*(deg[i]-1) + G[i])*1.0 / deg[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], deg[150000];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        deg[u]++;\n        deg[v]++;\n        E[i][0] = u;\n        E[i][1] = v;\n    }\n\n    rep(i, N)if (deg[i] > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        rep(i, N) {\n            if(deg[i]==2)printf(\"%.10f\\n\", ans);\n            else printf(\"%d\\n\", N - 1);\n        }\n        exit(0);\n    }\n    assert(0);\n    rep(i, N - 1)rep(j, 2)G[E[i][j]].push_back(i);\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nint deg[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    int p = deg[u];\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) * 1.0 / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    int p = deg[u];\n    for (int v : G[u]) if (v != fa) {\n        if (fa == -1) {\n            if (p == 1)\n                dp2[v] = 1;\n            else\n                dp2[v] = ((dp[u] + 1) * (p-1) - (dp[v] + 2)) / (p - 1);\n        }\n        else\n            dp2[v] = ((dp2[u] + 1) + (dp[u] + 1) * (p - 1) - (dp[v] + 2)) / (p - 1);\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n\n    for (int i = 1; i < N; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n        deg[u] ++, deg[v] ++;\n    }\n\n    dp2[1] = 0;\n    dfs(1, -1);\n    dfs2(1, -1);\n\n//    for (int i = 1; i <= N; i ++)\n//        cout<<i<<\" \"<<dp[i]<<\" \"<<dp2[i]<<\" \"<<deg[i]<<endl;\n\n    printf(\"%.8f\\n\", dp[1]);\n    for (int i = 2; i <= N; i ++) {\n        printf(\"%.8f\\n\", (dp[i] * (deg[i] - 1) + dp2[i]) * 1.0 / deg[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n    why I'm too lazy?\n**/\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n#define pb push_back\n#define pp pop_back\n#define ll long long\n#define ld long double\n#define OK puts(\"OK\");\n#define sz(s) (int)s.size()\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\n\ninline int min(int a, int b)\n{\n    return (a > b) ? b : a;\n}\ninline int max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nconst int N = 2e5 + 10;\nconst int inf = 1e9 + 7;\nconst ll linf = 1e17 + 7;\n\nint n, x, y;\nvector <int> g[N];\n\ndouble dfs(int v, int p, double d)\n{\n    double ans = 0;\n    for(auto to : g[v])\n    {\n        if(to == p) continue;\n        if(v == p)\n            ans += dfs(to, v, d / (sz(g[v]) ? sz(g[v]) : 1.0) );\n        else\n            ans += dfs(to, v, d / (sz(g[v]) - 1 ? sz(g[v]) - 1 : 1.0));\n    }\n    return ans + d;\n}\n\nmain()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++)\n        scanf(\"%d%d\", &x, &y), g[x].pb(y), g[y].pb(x);\n    for(int i = 1 ; i <= n; i++)\n        cout << fixed << setprecision(10) << dfs(i, i, 1.0) - 1.0 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\nint N, u[151234], v[151234];\nstd::vector<int>G[151234];\n\nint main()\n{\n\tin >> N;\n\trep(i, N - 1)\n\t{\n\t\tin >> u[i] >> v[i];\n\t\tG[u[i]].push_back(v[i]);\n\t\tG[v[i]].push_back(u[i]);\n\t}\n\trep(i, N)\n\t{\n\t\tif (G[i + 1].size() > 2) { return 0; }\n\t}\n\n\tout << std::fixed << std::setprecision(10);\n\trep(i, N)\n\t{\n\t\tif (G[i + 1].size() == 1)\n\t\t{\n\t\t\tout << N - 1 << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong double ans;\n\t\t\tans = (double)i / 2;\n\t\t\tans += (double)(N - i - 1) / 2;\n\t\t\tout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nvector<int> vec[150000];\nint dist[150000];\n\nint main() {\n\tcin >> n;\n\tint x[150000];\n\tinc(i, (n - 1) * 2) {\n\t\tint q;\n\t\tcin >> q;\n\t\tx[q - 1]++;\n\t}\n\t\n\tinc(i, n) {\n\t\tcout << (x[i] == 1 ? n - 1 : (n - 1) / 2.0) << endl;\n\t}\n\t\n\t/*\n\tinc(i, n - 1) {\n\t\tint u, v;\n\t\tu--; v--;\n\t\tvec[u].PB(v);\n\t\tvec[v].PB(u);\n\t}\n\t\n\tint s;\n\tinc(i, n) {\n\t\tif(vec[i].size() == 1) { s = i; break; }\n\t}\n\t\n\tint p = -1;\n\tinc(i, n) {\n\t\tinc(j, vec[s].size()) {\n\t\t\tif(vec[s][j] != p) {\n\t\t\t\tdist[s] = i;\n\t\t\t\tp = s;\n\t\t\t\ts = vec[s][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinc(i, n) {\n\t\tdouble ans;\n\t\t     if(dist[i] == 0) { ans = n - 1; }\n\t\telse if(dist[i] == n - 1) { ans = 0; }\n\t\telse {\n\t\t\tans = (i + ())\n\t\t}\n\t\t\n\t\tcout << (i + ) << endl;\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\ndouble ans[150010], ex[150010];\n\nvoid dfs(Graph &G, int cur, int par=-1) {\n    int sz = G[cur].size();\n    if(par != -1) sz--;\n\n    double sum = 0.0;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        dfs(G, to, cur);\n        sum += ex[to] + 1;\n    }\n\n    if(sz) ex[cur] = sum / sz;\n}\n\nvoid solve(Graph &G, int cur, int par=-1, double d_par=0.0) {\n    double sum = 0.0;\n    int sz = (int)G[cur].size();\n    for(auto to : G[cur]) {\n        if(to == par) sum += d_par + 1;\n        else sum += ex[to] + 1;\n    }\n\n    ans[cur] = sum / sz;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        double n_sum = sum - ex[to] - 1;\n        if(sz > 1) n_sum /= (sz - 1);\n        solve(G, to, cur, n_sum);\n    }\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n\n    Graph G(N);\n    for(int i=0; i<N-1; i++) {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(G, 0);\n    solve(G, 0);\n    for(int i=0; i<N; i++) {\n        printf(\"%.12f\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing Graph = vector<vector<int>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nGraph g;\n// d[i] := 頂点 i に移動するとき, それ以降に移動する回数の期待値\nvector<double> d;\nvoid dfs(int u, int p) {\n    double sum = 0;\n    int cnt = 0;\n    for (int v: g[u]) if (v != p) {\n        dfs(v, u);\n        sum += d[v] + 1;\n        cnt++;\n    }\n    d[u] = (cnt ? sum / cnt : 0);\n}\nvector<double> res;\nvoid dfs2(int u, int p, double d_par = 0) {\n    double total = 0;\n    for (int v: g[u]) total += (v == p ? d_par : d[v]) + 1;\n    res[u] = total / g[u].size();\n    for (int v: g[u]) if (v != p) {\n        double nd_par = (total - (d[v] + 1)) / (g[u].size() - 1);\n        dfs2(v, u, nd_par);\n    }\n}\n\n#include <iomanip>\nint main() {\n    cout << fixed << setprecision(12);\n    int n; cin >> n;\n    g.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    if (n == 1) return !(cout << 0 << endl);\n    if (n == 2) return !(cout << \"1\\n1\" << endl);\n    int r = -1;\n    for (int i = 0; i < n; i++) if (g[i].size() >= 2) r = i;\n    d.resize(n);\n    dfs(r, -1);\n    res.resize(n);\n    dfs2(r, -1);\n    for (auto e: res) cout << e << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//はじめての全方位DP\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#define int long long\nusing namespace std;\n\nint n;\nvector<int> et[150000];\ndouble dp[150000];\t\t//頂点0を根としたときの部分木iについて, 頂点iからの移動回数の期待値をdp[i]とおく。\nint chNum[150000];\t\t//頂点0を根としたとき, 頂点iの子の数をchNum[i]とおく。\ndouble ans[150000];\t\t//頂点iを根としたとき, 頂点iからの移動回数の期待値をans[i]とおく。\n\ndouble dfs(int p, int v)\n{\n\tchNum[v] = et[v].size() - (p != -1);\n\tif (chNum[v] == 0) return dp[v] = 0;\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tret += dfs(v, et[v][i]);\n\t}\n\tret /= chNum[v];\n\treturn dp[v] = ret + 1;\n}\n\nvoid Dfs(int p, int v) {\n\tif (p != -1) {\n\t\t//ans[v]を求める\n\t\tdouble ret_p;\t\t\t\t\t\t\t//vを根としたときの部分木pについて, pからの移動回数の期待値をret_pとおく。\n\t\tint childNum = (int)et[p].size() - 1;\t//vを根としたときの, pの子の数\n\t\t\n\t\tif (childNum == 0) {\n\t\t\tret_p = 0;\n\t\t}\n\t\telse {\n\t\t\tret_p = (et[p].size() * ans[p] - dp[v] - 1.0) / childNum;\n\t\t}\n\t\tans[v] = dp[v] * (chNum[v] / (chNum[v] + 1.0)) + (1.0 + ret_p) / (chNum[v] + 1);\n\t}\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tDfs(v, et[v][i]);\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\tdfs(-1, 0); ans[0] = dp[0];\n\tDfs(-1, 0);\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%.14f\\n\", ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <random>\n#include <unordered_set>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <limits>\nusing namespace std;\ntypedef long long ll;\n//#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e16)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\n\ntemplate <typename T>\nclass Seg_Tree{\npublic: // 0-index\n\tvector<T> dat;\n\tT initial,M;\n\tint n;\n\tT unite(T a,T b){//\n\t\treturn a+b;\n\t}\n\tSeg_Tree(int n0_=1,T initial_=1,T M_=1){\n\t\tinitsize(n0_,initial_,M_);\n\t}\n\tvoid initsize(int n0,T initial_,T M_){\n\t\tM = M_;\n\t\tinitial = initial_;\n\t\tint k=1;\n\t\twhile(1){\n\t\t\tif(n0<=k){\n\t\t\t\tn=k;\n\t\t\t\tdat.resize(2*n-1);\n\t\t\t\tfor(int i=0;i<2*n-1;i++)dat[i]=initial;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk*=2;\n\t\t}\n\t}\n\n\t//i banme wo x nisuru\n\tvoid update(int i,T x){\n\t\ti += n-1;\n\t\tdat[i] = x;\n\t\twhile(i>0){\n\t\t\ti = (i-1) / 2;\n\t\t\tdat[i] = unite(dat[i*2+1],dat[i*2+2]);\n\t\t}\n\t}\n\n\t//[a,b)\n\tT query0(int a,int b,int k,int l,int r){\n\t\tif(r<=a || b<=l)return initial;\n\t\tif(a<=l && r<=b)return dat[k];\n\t\telse{\n\t\t\tT vl = query0(a,b,k*2+1,l,(l+r)/2);\n\t\t\tT vr = query0(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn unite(vl,vr);\n\t\t}\n\t}\n\n\t//return [a,b)\n\tT query(int a,int b){\n\t\treturn query0(a,b,0,0,n);\n\t}\n\n\tT get_except(int ind){\n\t\tT vl = query(0,ind);\n\t\tT vr = query(ind+1,n);\n\t\treturn unite(vl,vr);\n\t}\n\n\tT get_all(){\n\t\treturn query(0,n);\n\t}\n};\n\nvector<int> leaf(const vector<int> &u,const vector<int> &v){\n\tint N = u.size() + 1;\n\tvector<int> G(N,0),res;\n\tfor(int i=0;i<N-1;i++){\n\t\tG[u[i]]++;\n\t\tG[v[i]]++;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(G[i] == 1){\n\t\t\tres.push_back(i);\n\t\t}\n\t}\n\treturn res;\n}\n\nvector< pair<int,int> > leaf_to_root(const vector<int> &u,const vector<int> &v,const int root){\n\t// return <parent,child>\n\tint yet = 1000000000;\n\tvector<int> d(u.size()+1,yet);\n\tvector< pair<int,int> > res;\n\tqueue<int> Q;\n\tQ.push(root);\n\td[root] = 0;\n\tvector< vector<int> > G(u.size()+1);\n\tfor(int i=0;i<u.size();i++){\n\t\tG[u[i]].push_back(v[i]);\n\t\tG[v[i]].push_back(u[i]);\n\t}\n\twhile( Q.size() ){\n\t\tint now = Q.front();\n\t\tQ.pop();\n\t\tfor(auto nex:G[now]){\n\t\t\tif(d[nex]!=yet)continue;\n\t\t\td[nex] = d[now] + 1;\n\t\t\tQ.push(nex);\n\t\t\tres.push_back( make_pair(now,nex) );\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\n\nint main(){\n\n\n\tint N;\n\tcin >> N;\n\tvector<int> x(N-1),y(N-1);\n\tFOR(i,0,N-1) cin >> x[i] >> y[i];\n\tFOR(i,0,N-1) x[i]--,y[i]--;\n\n\n\tvector< vector<int> > G(N);\n\tfor(int i=0;i<N-1;i++){\n\t\tG[x[i]].push_back(y[i]);\n\t\tG[y[i]].push_back(x[i]);\n\t}\n\tvector< map<int,int> > ma(N);\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tma[ i ][ G[i][j] ] = j;\n\t\t}\n\t}\n\n\tvector< Seg_Tree<double> > dp(N);\n\tfor(int i=0;i<N;i++){\n\t\tdp[i].initsize(G[i].size(),0,MOD);\n\t}\n\n\tauto route = leaf_to_root(x,y,0);\n\tfor(auto a:route){\n\t\tint p = a.first;\n\t\tint c = a.second;\n\t\tdouble x = 0;\n\t\tif(G[c].size() != 1){\n\t\t\tdouble y = G[c].size();\n\t\t\tx = dp[c].get_except(ma[c][p]) / (y - 1.0); \n\t\t}\n\t\tdp[p].update(ma[p][c], x+1.0 );\n\t}\n\n\treverse(route.begin(),route.end());\n\tfor(auto a:route){\n\t\tint c = a.second;\n\t\tint p = a.first;\n\t\tdouble x = 0;\n\t\tif(G[p].size() != 1){\n\t\t\tdouble y = (double) G[p].size();\n\t\t\tx = dp[p].get_except(ma[p][c]) / (y - 1.0); \n\t\t}\n\t\tdp[c].update( ma[c][p] , x+1.0 );\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tout(10) << dp[i].get_all()/G[i].size() << endl;\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing ld = long double;\n\nint N;\nvector<vector<int>> edges;\nvector<map<int, ld>> vmp;\n\nld dfs(int from, int now) {\n\tif (from != -1 && vmp[from].find(now) != vmp[from].end()) {\n\t\treturn vmp[from][now];\n\t}\n\tif (edges[now].size() == 1 && edges[now].front() == from) {\n\t\treturn vmp[from][now] = 1;\n\t}\n\tld res = 0;\n\tfor (int next : edges[now])if (next != from) {\n\t\tres += dfs(now, next);\n\t}\n\tres /= (edges[now].size() - 1);\n\tif (from == -1)return res;\n\telse return vmp[from][now] = res + 1;\n}\n\nint main()\n{\n\tcin >> N;\n\tedges.resize(N);\n\tvmp.resize(N);\n\trep(i, N - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\trep(i, N)dfs(-1, i);\n\trep(i, N) {\n\t\tld res = 0;\n\t\tfor (auto itr : vmp[i])res += itr.second;\n\t\tres /= edges[i].size();\n\t\tcout << fixed << setprecision(15) << res << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 5;\n\nvector<int> G[maxn];\nint deg[maxn];\n\ndouble ans = 0;\n\nvoid dfs(int u, int fa, double p) {\n    for (int v : G[u]) if (v != fa) {\n        ans += p;\n        if (deg[v] == 1) return;\n        double x = deg[v] - 1;\n        dfs(v, u, p / x);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        deg[u] ++, deg[v] ++;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; i ++) {\n        ans = 0;\n        dfs(i, -1, 1.0 / deg[i]);\n        printf(\"%.6f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n\nvoid solve_r(vvi& v, int d, int cur, int prev, double r, double& result)\n{\n\tint n;\n\n\tn=v[cur].size();\n\tif(prev>=0) n--;\n\tif(n==0)\n\t{\n\t\tresult+=d*r;\n\t}\n\n\tr/=n;\n\tfor(int e: v[cur])\n\t{\n\t\tif(e==prev) continue;\n\t\tsolve_r(v, d+1, e, cur, r, result);\n\t}\n}\n\n\nvoid solve(vector<double>& r, vvi& v)\n{\n\tdouble result;\n\n\tfor(int i=1;i<v.size();i++)\n\t{\n\t\tresult=0.0;\n\t\tsolve_r(v, 0, i, -1, 1.0, result);\n\t\tr[i]=result;\n\t}\n}\n\n\nint main(void)\n{\n\tvector<double> r;\n\tvvi v;\n\tint n, a, b;\n\n\twhile(scanf(\"%d\", &n)==1)\n\t{\n\t\tv.clear();\n\t\tv.resize(n+1);\n\t\tr.resize(n+1);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tv[a].push_back(b);\n\t\t\tv[b].push_back(a);\n\t\t}\n\t\tsolve(r, v);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tprintf(\"%f\\n\", r[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\nusing Graph=vector<vector<int>>;\n\nGraph g;\ndouble dp1[151000];\ndouble dp2[151000];\n\ndouble dfs1(int idx,int pre){\n    int n=(int)g[idx].size()-1;\n    if(pre==-1) n++;\n    for(int next:g[idx]){\n        if(next==pre) continue;\n        dp1[idx]+=(1+dfs1(next,idx))/n;\n    }\n    return dp1[idx];\n}\n\nvoid dfs2(int idx,int pre){\n    if(pre!=-1){\n        int n=(int)g[pre].size();\n        if(pre==0) dp2[idx]=( (dp1[pre])*(n)-(dp1[idx]+1) )/(max(n-1,1) )+1;\n        else dp2[idx]=( (dp2[pre]+1)+(dp1[pre]+1)*(n-1)-(dp1[idx]+2) )/(n-1);\n    }\n    for(int next:g[idx]){\n        if(next==pre) continue;\n        dfs2(next,idx);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n    int n;\n    cin>>n;\n    g.resize(n);\n    for(int i=0;i<n-1;i++){\n        int s,t;\n        cin>>s>>t;\n        s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    dfs1(0,-1);\n    dfs2(0,-1);\n    for(int i=0;i<n;i++){\n        int n=(int)g[i].size();\n        //cout<<dp1[i]<<\" \"<<dp2[i]<<endl;\n        if(i!=0) cout<< (dp1[i]*(n-1)+dp2[i])/n<<endl;\n        else cout<<dp1[i]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\n\tusing value = double;\n\tstd::vector<std::map<int, value>> dp(n);\n\tauto solve = [&](auto&& solve, int v, int par, bool flag) -> double {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\n\t\tint deg = 0;\n\t\tvalue val = 0.;\n\t\tif(flag or par == -1) {\n\t\t\tdeg = g[v].size() - (par != -1);\n\t\t\tfor(auto e: g[v]) {\n\t\t\t\tif(e == par) continue;\n\t\t\t\tval += solve(solve, e, v, flag);\n\t\t\t}\n\t\t} else {\n\t\t\tdeg = g[v].size() - !!g[v].size();\n\t\t\tvalue parent_val = solve(solve, par, v, 0);\n\t\t\tvalue around_val = (solve(solve, v, -1, 0) - 1.) * g[v].size();\n\t\t\tval = around_val - parent_val;\n\t\t}\n\t\tif(deg) val = val / deg + 1;\n\n\t\treturn dp[v][par] = val;\n\t};\n\tsolve(solve, 0, -1, 1);\n\n\tfor(int v = 0; v < n; v++) printf(\"%.12lf\\n\", solve(solve, v, -1, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, int> , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, p)] != 0)\n        return mp[make_pair(v, p)] * t;\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, 1.0 / k) + 1.0 / k;\n    }\n    mp[make_pair(v, p)] = ans;\n    return ans * t;\n}\nint main()\n{\n    int n, i, x, y;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nint n;\nint a , b;\nvector < int > v[N];\ndouble sub[N];\ndouble ans[N];\nvoid dfs1(int node , int parent){\n\tsub[node] = 0;\n\tint child = 0;\n\tfor(int next : v[node]){\n\t\tif(next != parent){\n\t\t\tdfs1(next , node);\n\t\t\t++child;\n\t\t\tsub[node] += sub[next] + 1;\n\t\t}\n\t}\n\tif(child){\n\t\tsub[node] /= child;\n\t}\n}\nvoid dfs2(int node , int parent , double val){\n\tif(parent){\n\t\tans[node] = (sub[node] * (v[node].size() - 1) + (val + 1)) / v[node].size(); \n\t}\n\telse{\n\t\tans[node] = sub[node];\n\t}\n\tfor(int next : v[node]){\n\t\tif(next != parent){\n\t\t\tif(v[node].size() == 1){\n\t\t\t\tdfs2(next , node , 0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs2(next , node , (ans[node] * v[node].size() - sub[next] - 1) / (v[node].size() - 1));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i < n ; ++i){\n\t\tscanf(\"%d %d\" , &a , &b);\n\t\tv[a].emplace_back(b);\n\t\tv[b].emplace_back(a);\n\t}\n\tdfs1(1 , 0);\n\tdfs2(1 , 0 , 0);\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tprintf(\"%.9lf\\n\" , ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=15e4;\nvector<int> G[MAX_N];\nint N;\nunordered_map<int,double> dp[MAX_N];\n\ndouble dfs(int v,int p){\n\tif(dp[v].find(p)!=dp[v].end()){\n\t\treturn dp[v][p];\n\t}\n\tint cnt=0;\n\tfor(auto e:G[v]){\n\t\tif(e!=p){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdouble ret;\n\tif(cnt==0){\n\t\tret=0;\n\t}else{\n\t\tret=1;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e!=p){\n\t\t\t\tret+=dfs(e,v)/cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[v][p]=ret;\n}\nint main(){\n\tcin>>N;\n\tREP(i,N-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tREP(i,N){\n\t\tprintf(\"%.16f\\n\",dfs(i,-1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n \nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n \ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return dp[P(prev,now)] = 0.0;\n\tif(dp.find(P(prev,now)) != dp.end()) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n \nsigned main(){\n\tcin >> n;\n\tif(n > 1000) return 0;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef pair<double,int> pdi;\n\n\nvector<int> G[150000];\ndouble val[150000];\ndouble ans[150000];\nint deg[150000];\n\ndouble dfs(int cur, int prev){\n    double ret = 0;\n    int c=0;\n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n        ret+=1+dfs(e,cur);\n    }\n    if(c!=0)ret/=c;\n    return val[cur] = ret;\n}\n\n\ndouble dfs2(int cur, int prev, double d_par){\n    vector<pdi> v;\n    for(auto e:G[cur]){\n        if(e==prev)v.pb(pdi(d_par+1,e));\n        else v.pb(pdi(val[e]+1,e));\n    }\n    \n    double ave = 0;\n    rep(i,v.size())ave+=v[i].first;\n    ave/=deg[cur];\n    \n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        if(deg[cur]==1)dfs2(e,cur,0);\n        else dfs2(e,cur,(ave*deg[cur]-(val[e]+1))/(deg[cur]-1));\n    }\n    \n    return ans[cur] = ave;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    \n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        deg[u]++;\n        deg[v]++;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    \n    dfs(0,-1);\n    \n    dfs2(0,-1,0);\n    \n    rep(i,n){\n        printf(\"%.20lf\\n\",ans[i]);\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[150000];\ndouble ee[150000], ans[1500000];\n\nvoid dfs1(int idx, int par)\n{\n  double ret = 0;\n  int child = 0;\n\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    ret += ee[to] + 1.0;\n    ++child;\n  }\n  ee[idx] = 0;\n  if(child >= 1) ee[idx] += ret / child;\n}\n\nvoid dfs2(int idx, double d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  double ret = 0;\n  for(int &to : g[idx]) {\n    if(to == par) ret += 1.0 + d_par;\n    else ret += 1.0 + ee[to];\n  }\n  ans[idx] = ret / g[idx].size();\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, (ret - ee[to] - 1.0) / max(1, (int) g[idx].size() - 1), idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2];\nvi G[150000];\nfloat dp[150001][2];\n\nfloat f(int e, int s) {\n    float &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    float p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        float ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.8f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\ndouble dp[150000], ans[150000];\nvector<int>E[150000];\ndouble dfs(int v, int p) {\n\tdouble ans = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / double(E[v].size() - (p != -1));\n\t}\n\treturn dp[v] = ans;\n}\nvoid dfs2(int v, int p) {\n\tif (p == -1)ans[v] = dp[v];\n\telse {\n\t\tif (E[p].size() == 1)ans[v] = 1. / E[v].size() + dp[v] * (E[v].size() - 1) / E[v].size();\n\t\telse if (E[v].size() == 1) {\n\t\t\tans[v] = (ans[p] * E[p].size() - dp[v] - 1) / (E[p].size() - 1) + 1;\n\t\t}\n\t\telse {\n\t\t\tans[v] = ((ans[p] * E[p].size() - dp[v] - 1) / (E[p].size() - 1) + 1) / E[v].size() + dp[v] * (E[v].size() - 1) / E[v].size();\n\t\t}\n\t}\n\tfor (int u : E[v]) {\n\t\tif (u != p)dfs2(u, v);\n\t}\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\tdfs(0, -1); dfs2(0, -1);\n\trep(i, n)printf(\"%.12lf\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, pair <int, double > > , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, make_pair(p, t))] != 0)\n        return mp[make_pair(v, make_pair(p, t))];\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, t / k) + t / k;\n    }\n    mp[make_pair(v, make_pair(p, t))] = ans;\n    return ans;\n}\nint main()\n{\n    int n, i, x, y;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-9;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n\ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return 0.0;\n\tif(dp[P(prev,now)] >= EPS) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tcin >> u >> v; u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include <map>\n#include <queue>\n#include <stack>\n#include<set>\n\n#define DIV 1000000007\nusing namespace std;\nusing ll = long long;\nusing ldb = long double;\n\ntypedef struct {\n    vector<int> edge;\n    int par = 0;\n    ldb dp1 = 0, e = 0;\n    bool vi1 = 0, vi2 = 0;\n}node_t;\nvector<node_t> node;\n\nldb dfs(int x) {\n    ldb sum = 0.0;\n    ldb n = node[x].edge.size();\n    ldb cnt = 0;\n    for (int i = 0; i < n; i++) {\n        int to = node[x].edge[i];\n        if (node[to].vi1) continue;\n        node[to].par = x;\n        node[to].vi1 = true;\n        sum += dfs(to) + 1;\n        cnt++;\n    }\n    if (cnt == 0) node[x].dp1 = 0;\n    else  node[x].dp1 = (double)sum / cnt;\n    return node[x].dp1;\n\n}\n\nvoid dfs2(int y) {\n    int par = node[y].par;\n    ldb sp = node[par].edge.size();\n    ldb sn = node[y].edge.size();\n    if (y == 1) node[y].e = node[y].dp1;\n    else {\n        ldb temp = node[par].e * sp - node[y].dp1 - 1.0;\n        if (temp == 0) node[y].e = (1.0 + (sn - 1.0) * node[y].dp1) / sn;\n        else node[y].e = (temp / (sp - 1.0) + 1.0 + (sn - 1.0) * node[y].dp1) / sn;\n    }\n    for (int i = 0; i < sn; i++) {\n        int to = node[y].edge[i];\n        if (node[to].vi2) continue;\n        node[to].vi2 = true;\n        dfs2(node[y].edge[i]);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    node = vector<node_t>(N + 1);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        node[u].edge.push_back(v);\n        node[v].edge.push_back(u);\n    }\n\n    node[1].vi1 = true;\n    dfs(1);\n    if (N > 1000) {\n        node[1].vi2 = true;\n        dfs2(1);\n        for (int i = 1; i <= N; i++) {\n            printf(\"%.15Lf\\n\", node[i].e);\n        }\n    }\n    else {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                node[j].vi1 = false;\n            }\n            node[i].vi1 = true;\n            printf(\"%.15Lf\\n\", dfs(i));\n            \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#include <Mylib/Debug/debug.cpp>\n#else\n#define dump(...)\n#endif\n\n/**\n * @title Graph template\n * @docs graph_template.md\n */\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n};\n\ntemplate <typename T> using Graph = std::vector<std::vector<Edge<T>>>;\ntemplate <typename T> using Tree = std::vector<std::vector<Edge<T>>>;\n\ntemplate <typename T, typename C> void add_edge(C &g, int from, int to, T w = 1){\n  g[from].emplace_back(from, to, w);\n}\n\ntemplate <typename T, typename C> void add_undirected(C &g, int a, int b, T w = 1){\n  add_edge<T, C>(g, a, b, w);\n  add_edge<T, C>(g, b, a, w);\n}\n\n\n\n/**\n * @title Rerooting DP\n * @docs rerooting.md\n */\n\ntemplate <typename T, typename U, typename Merge, typename EdgeF, typename VertexF>\nstruct Rerooting{\n  int N;\n  T tree;\n  U id;\n  Merge merge;\n  EdgeF f;\n  VertexF g;\n  \n  std::vector<std::vector<U>> dp;\n  std::vector<U> result;\n  \n  Rerooting(T tree, U id, Merge merge, EdgeF f, VertexF g):\n    N(tree.size()), tree(tree), id(id), merge(merge), f(f), g(g), dp(N), result(N, id)\n  {\n    for(int i = 0; i < N; ++i) dp[i].assign((int)tree[i].size(), id);\n    rec1(0);\n    rec2(0, -1, id);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < (int)tree[i].size(); ++j){\n        result[i] = merge(result[i], f(dp[i][j], tree[i][j]));\n      }\n      \n      result[i] = g(result[i], i);\n    }\n  }\n\n  U rec1(int cur, int par = -1){\n    U acc = id;\n    \n    for(int i = 0; i < (int)tree[cur].size(); ++i){\n      auto &e = tree[cur][i];\n      if(e.to == par) continue;\n      dp[cur][i] = rec1(e.to, cur);\n      acc = merge(acc, f(dp[cur][i], e));\n    }\n\n    return g(acc, cur);\n  }\n\n  void rec2(int cur, int par, U value){\n    const int l = tree[cur].size();\n\n    for(int i = 0; i < l; ++i){\n      if(tree[cur][i].to == par){\n        dp[cur][i] = value;\n      }\n    }\n\n    std::vector<U> left(l+1, id), right(l+1, id);\n\n    for(int i = 0; i < l-1; ++i){\n      const auto &e = tree[cur][i];\n      left[i+1] = merge(left[i], f(dp[cur][i], e));\n    }\n\n    for(int i = l-1; i >= 1; --i){\n      const auto &e = tree[cur][i];\n      right[i-1] = merge(right[i], f(dp[cur][i], e));\n    }\n\n    for(int i = 0; i < l; ++i){\n      const auto &e = tree[cur][i];\n      if(e.to == par) continue;\n\n      rec2(e.to, cur, g(merge(left[i], right[i]), cur));\n    }\n  }\n};\n\ntemplate <typename T, typename G, typename Merge, typename EdgeF, typename VertexF>\nauto make_rerooting(const G &tree, T id, Merge merge, EdgeF f, VertexF g){\n  return Rerooting<G,T,Merge,EdgeF,VertexF>(tree, id, merge, f, g);\n}\n\n\n\n\n\n\nnamespace solver{\n  void solve(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    \n    int N; std::cin >> N;\n\n    Tree<int> tree(N);\n    for(int i = 0; i < N - 1; ++i){\n      int u, v; std::cin >> u >> v;\n      add_undirected(tree, u - 1, v - 1, 1);\n    }\n\n    auto merge =\n      [](const auto &a, const auto &b){\n        return std::make_pair(a.first + b.first, a.second + b.second);\n      };\n    auto f =\n      [](const auto &a, const auto &){\n        return a;\n      };\n    auto g =\n      [](const auto &a, int){\n        if(a.second == 0){\n          return std::make_pair(0.0, 1);\n        }else{\n          return std::make_pair(a.first / a.second + 1, 1);\n        }\n      };\n    \n    auto res = make_rerooting<std::pair<double, int>>(tree, {0, 0}, merge, f, g).result;\n\n    for(auto x : res){\n      std::cout << std::fixed << std::setprecision(12) << x.first << \"\\n\";\n    }\n  }\n}\n\nint main(){\n  solver::solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long int;\nusing P = std::pair<int, int>;\n\n#define rep(i, n) for (int i = 1; i <= (n); ++i)\n#define rag(con) std::begin(con), std::end(con)\n\nconstexpr int MAX = 1e5 + 1e4 * 5 + 10;\n\nstd::vector<int> g[MAX];\n\ndouble pre[MAX];\ndouble parv;\n\nbool used[MAX];\n\ndouble ans[MAX];\n\nvoid dfs0(int v)\n{\n\n    used[v] = 1;\n\n    int cnt = 0;\n    for (auto c : g[v])\n    {\n        if (!used[c])\n        {\n            dfs0(c);\n            pre[v] += pre[c];\n            ++cnt;\n        }\n    }\n\n    if (v == 1)\n    {\n        pre[v] /= (double)g[v].size();\n        pre[v] += 1.0;\n    }\n    else if (cnt != 0)\n    {\n        pre[v] /= (double)(g[v].size() - 1);\n        pre[v] += 1.0;\n    }\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n\n    if (pre[v] == 0.0)\n        ans[v] = parv + 1.0;\n    else if (v == 1)\n        ans[v] = pre[v];\n    else\n        ans[v] = ((pre[v] - 1.0) * (double)(g[v].size() - 1) + parv) / (double)g[v].size() + 1.0;\n\n    //std::cerr << v << ' ' << parv << ' ' << ans[v] << std::endl;\n\n    double pparv = parv;\n\n    for (auto c : g[v])\n    {\n        if (!used[c])\n        {\n            if (v == 1)\n            {\n                if (g[v].size() != 1)\n                    parv = ((pre[v] - 1.0) * (double)g[v].size() - pre[c]) / (double)(g[v].size() - 1) + 1.0;\n            }\n            else\n                parv = pre[v] + (parv - pre[c]) / (double)(g[v].size() - 1);\n\n            dfs(c);\n\n            parv = pparv;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n\n    std::cin >> n;\n\n    rep(i, n - 1)\n    {\n        int u, v;\n        std::cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs0(1);\n\n    /*rep(i, n)\n            std::cerr\n        << pre[i] << ' ';\n    std::cerr << std::endl;*/\n\n    std::memset(used, 0, sizeof(used));\n\n    dfs(1);\n\n    rep(i, n)\n            std::cout\n        << std::fixed << ans[i] << std::setprecision(8) << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = std::int_fast64_t;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nusing value = long double;\nconst value id = 0.;\nvalue marge(value a, value b) { return a + b; }\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<int> a(n - 1), b(n - 1);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\n\t\tg[a[i]].push_back(i);\n\t\tg[b[i]].push_back(i);\n\t}\n\n\tstd::vector<std::map<int, value>> dp(n);\n\tauto solve = [&](auto&& solve, int v, int par, bool flag) -> value {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\t\t\n\t\tvalue res = id;\n\t\tconst int deg = g[v].size() - (par != -1);\n\t\tif(par == -1 or flag) {\n\t\t\tstd::vector<value> ret;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tint id = g[v][i];\n\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\tif(to == par) continue;\n\t\t\t\t\n\t\t\t\tret.push_back(solve(solve, to, v, flag) + 1.);\n\t\t\t}\n\t\t\t\n\t\t\tstd::vector<value> R(ret.size() + 1, id);\n\t\t\tfor(int i = (int)R.size() - 1; i > 0; i--) R[i - 1] = marge(R[i], ret[i - 1]);\n\t\t\tif(par == -1) {\n\t\t\t\tvalue L = id;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tint id = g[v][i];\n\t\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\t\t\n\t\t\t\t\tlong double tmp = marge(L, R[i + 1]);\n\t\t\t\t\tif(deg - 1) tmp = tmp / (deg - 1);\n\t\t\t\t\tdp[v][to] = tmp;\n\t\t\t\t\tL = marge(L, ret[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(deg) res = R[0] / deg;\n\t\t} else {\n\t\t\tsolve(solve, v, -1, flag);\n\n\t\t\tres = solve(solve, v, par, flag);\n\t\t}\n\n\t\treturn dp[v][par] = res;\n\t};\n\tsolve(solve, 0, -1, true);\n\n\tfor(int i = 0; i < n; i++) printf(\"%.12Lf\\n\", solve(solve, i, -1, false));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = (LL)1e9+7;\nconst int SIZE = 2e5+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\ndouble dp[150009];\ndouble ans[150009];\nvector<int> radj[150009],adj[150009];\nint par[150009];\n\nvoid dfs1(int x,int p=-1){\n\tint cc=SZ(radj[x])-(p!=-1);\n\tfor(int i:radj[x]){\n\t\tif(i==p)continue;\n\t\tadj[x].PB(i);\n\t\tdfs1(i,x);\n\t\tdp[x]+=(dp[i]+1)/cc;\n\t}\n}\n\nvoid dfs2(int x,int p=-1){\n\tif(x==0)ans[x]=dp[x];\n\telse{\n\t\tint cc=SZ(radj[x]);\n\t\tint pcc=SZ(radj[p]);\n\t\tans[x]=(dp[x]*(cc-1))/cc;\n\t\tif(pcc>1)ans[x]+=((ans[p]-(dp[x]+1)/pcc)/(pcc-1)*pcc+1)/cc;\n\t\telse ans[x]+=(double)1/cc;\n\t}\n\tfor(int i:adj[x]){\n\t\tdfs2(i,x);\n\t}\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tradj[a].PB(b);radj[b].PB(a);\n\t}\n\tdfs1(0);dfs2(0);\n\tREP(i,n){\n\t\tprintf(\"%.10lf\\n\",ans[i]);\n\t\t//printf(\"%lf\",[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\ntemplate <typename sum_t, typename key_t>\nstruct ReRooting {\n    struct Edge {\n        int to;\n        key_t data;\n        sum_t dp, ndp;\n    };\n\n    using F = function<sum_t(sum_t, sum_t)>;\n    using G = function<sum_t(sum_t, key_t)>;\n\n    vector<vector<Edge>> g;\n    vector<sum_t> subdp, dp;\n    const sum_t ident;\n    const F f;\n    const G gg;\n\n    ReRooting(int V, const F f, const G g, const sum_t& ident)\n        : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const key_t& d) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const key_t& d, const key_t& e) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for (auto& e : g[idx]) {\n            if (e.to == par)\n                continue;\n            dfs_sub(e.to, idx);\n            subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const sum_t& top) {\n        sum_t buff{ident};\n        for (int i = 0; i < (int)g[idx].size(); i++) {\n            auto& e = g[idx][i];\n            e.ndp = buff;\n            e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for (int i = (int)g[idx].size() - 1; i >= 0; i--) {\n            auto& e = g[idx][i];\n            if (e.to != par)\n                dfs_all(e.to, idx, f(e.ndp, buff));\n            e.ndp = f(e.ndp, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector<sum_t> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n//https://ei1333.hateblo.jp/entry/2018/12/21/004022\n//#define V vector<int> を消す\n\nint N;\n\nstruct node {\n    double exp;\n    int num;\n};\n\nvoid solve() {\n    auto f1 = [](node a, node b) {\n        if (a.num + b.num == 0) {\n            return node{0, 0};\n        } else {\n            return node{(a.exp * a.num + b.exp * b.num) / (a.num + b.num), a.num + b.num};\n        };\n    };\n    auto f2 = [](node a, int x) {\n        return node{a.exp + 1.0, 1};\n    };\n    ReRooting<node, int> tree(N, f1, f2, node{0, 0});\n    FOR(N - 1) {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        tree.add_edge(x, y, 1);\n    }\n    for (auto& a : tree.build()) {\n        cout << a.exp << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n    cin >> N;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p != -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v) + 1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nbool CASE_HACK_MODE = false;\nint32_t center1 = -1;\nint32_t center2 = -1;\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t\tif (center1 == -1) { center1 = a; center2 = b; }\n\t\telse {\n\t\t\tif (a == center1 || a == center2) {\n\t\t\t\tcenter1 = a;\n\t\t\t}\n\t\t\telse if (b == center1 || b == center2) {\n\t\t\t\tcenter1 = b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tCASE_HACK_MODE = true;\n\t\t\t}\n\n\t\t\tcenter2 = -1;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tif (!CASE_HACK_MODE)\n\t{\n\t\tfor (int32_t i = 0; i < N; ++i)\n\t\t{\n\t\t\tout << get(i, -1) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << ((i == center1) ? 1.0 : 2.0) << endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b,ok,ch[150000],L;\nvector<int> v[150000];\nld ans[150000];\nmap<int,int>mp;\n/*\nvoid dfs(int A){\n    if(mp[A]==1)ans[A]=n-1;\n    else ans[A]=ld(n-1)/2.0;\n    for(auto x:v[A]){\n        if(ch[x]!=0)continue;\n        ch[x]=ch[A]+1;\n        dfs(x);\n    }\n    return ;\n}*/\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        mp[a]++;\n        mp[b]++;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(auto x:mp){\n        if(x.second>2)ok=1;\n    }\n    if(ok==0){\n        for(int i=0;i<n;i++){\n            if(mp[i]==1)ans[i]=n-1;\n            else ans[i]=(ld)(n-1)/2.0;\n        }\n    }\n    for(int i=0;i<n;i++){\n        cout<<ans[i]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], deg[150000];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        deg[u]++;\n        deg[v]++;\n        E[i][0] = u;\n        E[i][1] = v;\n    }\n\n    assert(0);\n    rep(i, N)if (deg[i] > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        rep(i, N) {\n            if(deg[i]==2)printf(\"%.10f\\n\", ans);\n            else printf(\"%d\\n\", N - 1);\n        }\n        exit(0);\n    }\n    rep(i, N - 1)rep(j, 2)G[E[i][j]].push_back(i);\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing Pos = complex<double>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nstruct ci : public iterator<forward_iterator_tag, ll> { ll n; ci(const ll n) : n(n) { } bool operator==(const ci& x) { return n == x.n; } bool operator!=(const ci& x) { return !(*this == x); } ci &operator++() { n++; return *this; } ll operator*() const { return n; } };\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n#define ldout fixed << setprecision(40) \n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vector<double> d(n);\n    function<double(ll, ll)> dfs1 = [&](ll u, ll p) {\n        ll num = g[u].size() - (p != -1);\n        if (p != -1 && g[u].size() <= 1) \n            return d[u] = 0;\n\n        double ret = 0;\n        for (auto v : g[u]) if (v != p) \n            ret += dfs1(v, u);\n\n        return d[u] = ret / num + 1;\n    };\n    dfs1(0, -1);\n\n    vector<double> ret(n);\n    function<void(ll, ll, double)> dfs2 = [&](ll u, ll p, double dpar) {\n        double sum = g[u].size();\n        for (auto v : g[u]) if (v != p) sum += d[v];\n        if (p != -1) sum += dpar;\n\n        ret[u] = (p == -1 ? d[u] : sum / g[u].size());\n\n        for (auto v : g[u]) if (v != p) \n            dfs2(v, u, g[u].size() > 1 ? (sum - d[v] - 1) / (g[u].size() - 1) : 0);\n    };\n    dfs2(0, -1, 0);\n\n    rep(i, n) \n        cout << ldout << ret[i] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n\nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, unordered_map<int, double>>U;//頂点IからJに進むときの進む距離の平均\ndouble saiki(int i, int j) {\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tdouble K = 1;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) if (g[u][i].first != prev) {\n\t\tcnt++;\n\t\tres += dfs(g[u][i].first, g[u][i].second, u);\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = (res + cnt) / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i);\n\t\t\n\t\tif (g[i].size() == 0) ans = 0;\n\t\telse ans = (ans + g[i].size()) / g[i].size();\n\t\t\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nvector< int > g[150000];\ndouble ee[150000], ans[1500000];\n\nvoid dfs1(int idx, int par)\n{\n  double ret = 0;\n  int child = 0;\n\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    ret += ee[to];\n    ++child;\n  }\n  ee[idx] = 1;\n  if(child >= 1) ee[idx] += ret / child;\n}\n\nvoid dfs2(int idx, double d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  double ret = 0;\n  for(int &to : g[idx]) {\n    if(to == par) ret += d_par;\n    else ret += ee[to];\n  }\n  ans[idx] = ret / g[idx].size();\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, 1.0 + (ret - ee[to]) / max(1, (int) g[idx].size() - 1), idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n// add :: T -> T -> T\n//     {v1,v2,...,vm}+vm+1\n// bundle :: T -> T\n//     u->{v1,v2,v3,...,vm} \ntemplate<class T, class F1, class F2>\nvector<T> freeTreeDP(const vector<vector<int>> &g, F1 add, F2 bundle) {\n\tconst int n = g.size();\n\tvector<T> dp(n);\n\tfunction<void(int, int)> dfs = [&](int u, int p) {\n\t\tfor (int v : g[u]) {\n\t\t\tif (v != p) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tdp[u] = add(dp[u], dp[v]);\n\t\t\t}\n\t\t}\n\t\tdp[u] = bundle(dp[u]);\n\t};\n\tdfs(0, -1);\n\tfunction<void(int, int)> dfs2 = [&](int u, int p) {\n\t\tconst int m = g[u].size();\n\t\tT l;\n\t\tvector<T> r(m);\n\t\tfor (int i = m - 2; i >= 0; i--) {\n\t\t\tr[i] = add(dp[g[u][i + 1]], r[i + 1]);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tconst int v = g[u][i];\n\t\t\tdp[u] = bundle(add(l, r[i]));\n\t\t\tl = add(l, dp[v]);\n\t\t\tif (v != p) {\n\t\t\t\tdfs2(v, u);\n\t\t\t}\n\t\t}\n\t\tdp[u] = bundle(l);\n\t};\n\tdfs2(0, -1);\n\treturn dp;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> g(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--;\n\t\tv--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tstruct foo {\n\t\tdouble sum;\n\t\tint cnt;\n\t\tfoo(double sum = 0, int cnt = 0) : sum(sum), cnt(cnt) {}\n\t};\n\tauto add = [&](const foo &a, const foo &b) {\n\t\tfoo c;\n\t\tc.sum = a.sum + b.sum;\n\t\tc.cnt = a.cnt + b.cnt;\n\t\treturn c;\n\t};\n\tauto bundle = [&](const foo &a) {\n\t\tfoo c;\n\t\tif (a.cnt == 0) {\n\t\t\tc.sum = 0;\n\t\t} else {\n\t\t\tc.sum = 1.0 / a.cnt * a.sum + 1;\n\t\t}\n\t\tc.cnt = 1;\n\t\treturn c;\n\t};\n\tauto dp = freeTreeDP<foo>(g, add, bundle);\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%.20f\\n\", dp[i].sum);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nconst int MAX_V = 150000;\nvector<int> es[MAX_V];\nld dp1[MAX_V], dp2[MAX_V];\n\nld dfs1(int now, int pre){\n    dp1[now] = 0.0;\n    ld cnt = 0.0;\n    for(auto &e: es[now]){\n        if(e == pre) continue;\n        cnt += 1.0;\n        dp1[now] += dfs1(e, now)+1.0;\n    }\n    if(cnt > EPS) dp1[now] /= cnt;\n    return dp1[now];\n}\n\nvoid dfs2(int now, int pre){\n    if(pre == -1) dp2[now] = 0.0;\n    elif(pre == 0){\n        ld n = sz(es[pre]);\n        if(abs(n-1.0) < EPS) dp2[now] = 1.0;\n        else dp2[now] = 2.0 + (dp1[pre]-dp1[now]/n-1.0)*n/(n-1);\n    }\n    else{\n        ld n = sz(es[pre])-1;\n        dp2[now] = 2.0 + (dp1[pre]-dp1[now]/n-1.0) + (dp2[pre]-1.0)/n;\n    }\n    for(auto &e: es[now]){\n        if(e != pre) dfs2(e, now);\n    }\n}\n\nint main(){\n    int N;\n    cin >> N;\n    rep(i, N-1){\n        int u, v; cin >> u >> v; u--, v--;\n        es[u].pb(v), es[v].pb(u);\n    }\n    dfs1(0, -1), dfs2(0, -1);\n    rep(i, N){\n        ld ans;\n        if(i == 0) ans = dp1[i];\n        else{\n            ld n = sz(es[i]);\n            ans = ((n-1)*dp1[i]+dp2[i])/n;\n        }\n        cout << sp(10) << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[150001];\nvector<ld> dpadj[150001];\nld dp[150001];\nvector<ld> dp2adj[150001];\nld dp2[150001];\n\nvoid dfs1(int u, int p)\n{\n\tld ans = 0;\n\tll child = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs1(v,u);\n\t\tchild++;\n\t\tans+=dp[v];\n\t}\n\tif(child==0) \n\t{\n\t\tdp[u]=0;\n\t\treturn ;\n\t}\n\tans/=ld(child);\n\tans+=1;\n\tdp[u] = ans;\n}\n\nvoid dfs2(int u, int p)\n{\n\tld ans = 0;\n\tll child = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs2(v,u);\n\t\tchild++;\n\t\tans+=dp[v];\n\t}\n\tif(child==0) \n\t{\n\t\treturn ;\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tif(child==1)\n\t\t{\n\t\t\tdpadj[u][i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdpadj[u][i] = 1 + (ld(1)/ld(child-1))*(ans-dp[v]);\n\t}\n}\n\nvoid dfs3(int u, int idx, int p)\n{\n\tll child=0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tchild++;\n\t}\n\tif(p==-1)\n\t{\n\t\tdp2[u] = dp[u];\n\t}\n\telse\n\t{\n\t\tdp2[u] = (ld(child)/ld(child+1))*dp[u] + (ld(1)/ld(child+1))*(dp2adj[p][idx]+1);\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tif(p==-1)\n\t\t{\n\t\t\tdp2adj[u][i] = dpadj[u][i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp2adj[u][i] = ld(child-1)/ld(child)*dpadj[u][i] + ld(1)/ld(child)*(dp2adj[p][idx]+1);\n\t\t}\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs3(v,i,u);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tdpadj[i].resize(int(adj[i].size()));\n\t\tdp2adj[i].resize(int(adj[i].size()));\n\t}\n\tdfs1(0,-1);\n\tdfs2(0,-1);\n\tdfs3(0,0,-1);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout<<fixed<<setprecision(10)<<dp2[i]<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <limits>\n#include <type_traits>\n#include <tuple>\n\ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\ntemplate <typename WeightType>\nclass weighted_edge {\npublic:\n  using size_type = size_t;\n  using weight_type = WeightType;\n\nprotected:\n  size_type M_src, M_dst;\n  weight_type M_weight;\n\npublic:\n  weighted_edge() = default;\n  weighted_edge(weighted_edge const&) = default;\n  weighted_edge(weighted_edge&&) = default;\n\n  weighted_edge(size_type s, size_type d, weight_type w):\n    M_src(s), M_dst(d), M_weight(w)\n  {}\n\n  weighted_edge& operator =(weighted_edge const&) = default;\n  weighted_edge& operator =(weighted_edge&&) = default;\n\n  bool operator <(weighted_edge const& other) const {\n    if (M_weight < other.M_weight) return true;\n    if (other.M_weight < M_weight) return false;\n    if (M_src != other.M_src) return M_src < other.M_src;\n    return M_dst < other.M_dst;\n  }\n\n  size_type source() const { return M_src; }\n  size_type target() const { return M_dst; }\n  weight_type weight() const { return M_weight; }\n};\n\nstruct directed_tag {};\nstruct undirected_tag {};\n\ntemplate <typename Edge, typename Directedness>\nclass adjacency_list {\npublic:\n  using size_type = size_t;\n  using edge_type = Edge;\n  using weight_type = typename Edge::weight_type;\n  static constexpr weight_type inf = std::numeric_limits<weight_type>::max();\n\nprivate:\n  std::vector<std::vector<edge_type>> M_g;\n\npublic:\n  adjacency_list() = default;\n  adjacency_list(adjacency_list const&) = default;\n  adjacency_list(adjacency_list&&) = default;\n  adjacency_list(size_type n): M_g(n) {}\n\n  template <typename... Args>\n  void emplace(size_type src, size_type dst, Args... args) {\n    M_g[src].emplace_back(src, dst, args...);\n    if (std::is_same<Directedness, undirected_tag>::value)\n      M_g[dst].emplace_back(dst, src, args...);\n  }\n\n  void sort_by_index() {\n    auto cmp = [](auto const& e1, auto const& e2) {\n      return e1.target() < e2.target();\n    };\n    for (auto v: M_g) std::sort(v.begin(), v.end(), cmp);\n  }\n\n  size_type size() const { return M_g.size(); }\n  std::vector<edge_type> const& operator [](size_type i) const { return M_g[i]; }\n};\n\ntemplate <typename Edge, typename Directedness>\nconstexpr typename Edge::weight_type inf = adjacency_list<Edge, Directedness>::inf;\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\ntemplate <typename Monoid, typename UndirectedTree>\nauto dp_on_tree(UndirectedTree const& g) {\n  Monoid e{};\n  size_t n = g.size();\n  std::vector<size_t> parent(n, -1_zu);\n\n  std::vector<std::vector<Monoid>> dp0(n), dp1(n);\n  std::vector<Monoid> dp(n);\n  for (size_t i = 0; i < n; ++i) {\n    dp0[i].resize(g[i].size()+1, e);\n    dp1[i].resize(g[i].size()+1, e);\n  }\n\n  make_fix_point([&](auto dfs0, size_t v, size_t p) -> Monoid {\n      Monoid res = e;\n      typename UndirectedTree::weight_type weight{};\n      for (size_t i = 0; i < g[v].size(); ++i) {\n        size_t u = g[v][i].target();\n        if (u == p) {\n          parent[v] = i;\n          weight = g[v][i].weight();\n          continue;\n        }\n        Monoid tmp = dfs0(u, v);\n        res.append(tmp);\n        dp0[v][i+1] = dp1[v][i] = tmp;\n      }\n      return res.f(weight);\n  })(0, -1_zu);\n\n  make_fix_point([&](auto dfs1, size_t v, size_t p, size_t pi) -> void {\n      if (v != 0) {\n        Monoid tmp = (dp0[p][pi] + dp1[p][pi+1]).f(g[p][pi].weight());\n        dp0[v][parent[v]+1] = tmp;\n        dp1[v][parent[v]] = tmp;\n      }\n      {\n        for (size_t i = 1; i < dp0[v].size(); ++i)\n          dp0[v][i].prepend(dp0[v][i-1]);\n        for (size_t i = dp1[v].size()-1; i--;)\n          dp1[v][i].append(dp1[v][i+1]);\n        dp[v] = dp1[v][0];\n      }\n      for (size_t i = 0; i < g[v].size(); ++i) {\n        size_t u = g[v][i].target();\n        if (u != p) dfs1(u, v, i);\n      }\n  })(0, -1_zu, -1_zu);\n\n  return dp;\n}\n\nclass neko {\npublic:\n  using value_type = double;\n  using size_type = size_t;\n\nprivate:\n  value_type M_value = 0.0;\n  size_type M_degree = 0;\n\npublic:\n  neko() = default;\n  neko(neko const&) = default;\n  neko(neko&&) = default;\n  neko(value_type v, size_type d): M_value(v), M_degree(d) {}\n\n  neko& operator =(neko const&) = default;\n  neko& operator =(neko&&) = default;\n\n  neko& append(neko const& other) {\n    M_value = (M_value * M_degree + other.M_value * other.M_degree);\n    M_degree += other.M_degree;\n    if (M_degree > 0) M_value /= M_degree;\n    return *this;\n  }\n  neko& prepend(neko const& other) {\n    return append(other);\n  }\n  neko operator +(neko const& other) const {\n    return neko(*this).append(other);\n  }\n  template <typename Tp>\n  neko f(Tp const&) const {\n    return neko(M_value+1, 1);\n  }\n  value_type get() const { return M_value; }\n};\n\nint main() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  adjacency_list<weighted_edge<int>, undirected_tag> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t u, v;\n    scanf(\"%zu %zu\", &u, &v);\n    --u, --v;\n    g.emplace(u, v, 1);\n  }\n  g.sort_by_index();\n\n  for (auto r: dp_on_tree<neko>(g))\n    printf(\"%.12f\\n\", r.get());\n}\n"
  },
  {
    "language": "C++",
    "code": "d"
  },
  {
    "language": "C++",
    "code": "/*** Template Begin ***/\n\n#define USING_BOOST\n#define USING_NAMESPACE\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nauto init_ = [] {\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10);\n    return 0;\n}();\n\ntemplate <typename T>\ninline T in() {\n    T x;\n    std::cin >> x;\n    return x;\n}\n\ntemplate <typename T>\ninline void in(T &x) {\n    std::cin >> x;\n}\n\ntemplate <typename T, typename... Ts>\ninline void in(T &t, Ts &... ts) {\n    std::cin >> t;\n    in(ts...);\n}\n\ntemplate <typename T, typename U = std::vector<T>>\ninline U vin(int n) {\n    U v(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> v[i];\n    }\n    return v;\n}\n\ntemplate <typename T, typename U = std::vector<T>, typename V = std::vector<U>>\ninline V vin(int h, int w) {\n    V vv(h, U(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            std::cin >> vv[i][j];\n        }\n    }\n    return vv;\n}\n\ntemplate <typename T>\ninline void out(const T &x) {\n    std::cout << x << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T, typename... Ts>\ninline void out(const T &t, const Ts &... ts) {\n    std::cout << t << delimiter;\n    out(ts...);\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int n) {\n    for (int i = 0; i < n; ++i) {\n        if (i) std::cout << delimiter;\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int h, int w) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (j) std::cout << delimiter;\n            std::cout << v[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\ntemplate <typename T, size_t D>\nstruct multi_vector_type {\n    using type = std::vector<typename multi_vector_type<T, D - 1>::type>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 1> {\n    using type = std::vector<T>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 0> {\n    using type = T;\n};\n\ntemplate <typename T, size_t D>\nusing multi_vector = typename multi_vector_type<T, D>::type;\n\ntemplate <typename T, size_t D, class = typename std::enable_if<D == 0>::type>\nT make_vector(const T &val = T()) {\n    return val;\n}\n\ntemplate <typename T, size_t D = 1, typename... Ts,\n          class = typename std::enable_if<D != 0>::type>\nmulti_vector<T, D> make_vector(size_t n, Ts &&... args) {\n    return multi_vector<T, D>(n, make_vector<T, D - 1>(args...));\n}\n\nnamespace detail {\n\ntemplate <typename F>\nstruct Debug {\n    const char *delim_ = \"\\n\";\n    F fun;\n\n    Debug(F f) : fun(f) {}\n\n    ~Debug() { fun(delim_); }\n\n    Debug &delim(const char *d) {\n        delim_ = d;\n        return *this;\n    }\n};\n\nstd::deque<std::string> split(const std::string &s, char c) {\n    std::deque<std::string> v;\n    std::stringstream ss(s);\n    std::string x;\n    while (std::getline(ss, x, c)) v.emplace_back(x);\n    return v;\n}\n\ntemplate <typename T>\nvoid deb(const char *delim, std::deque<std::string> v, T a) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << '\\n';\n    std::cerr << std::flush;\n}\n\ntemplate <typename T, typename... Args>\nvoid deb(const char *delim, std::deque<std::string> v, T a, Args... args) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << delim;\n    v.pop_front();\n    deb(delim, std::move(v), args...);\n}\n\ntemplate <typename... Args>\nauto wrap(std::deque<std::string> v, Args... args) {\n    auto f = [=](const char *delim = \"\\n\") { deb(delim, v, args...); };\n\n    return Debug<decltype(f)>(f);\n}\n}\n\n#define debug(args...) ::detail::wrap(::detail::split(#args, ','), args)\n\n#ifdef USING_BOOST\n\n#include <boost/math/common_factor.hpp>\n#include <boost/range.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/algorithm_ext.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/numeric.hpp>\n\ninline auto rep(int begin, int end) {\n    if (begin > end) {\n        return boost::irange(0, 0);\n    } else {\n        return boost::irange(begin, end);\n    }\n}\n\ninline auto rep(int begin, int end, int step) {\n    if ((step > 0 && begin > end) || (step < 0 && begin < end)) {\n        return boost::irange(0, 0, step);\n    } else {\n        return boost::irange(begin, end, step);\n    }\n}\n\n#endif\n\n#ifdef USING_NAMESPACE\nusing namespace std;\n\n#ifdef USING_BOOST\nusing namespace boost;\nusing namespace boost::adaptors;\n#endif\n#endif\n\n/*** Template End ***/\n\nint n;\nvector<vector<int>> graph;\nvector<bool> used;\n\ndouble dfs(int i) {\n    used[i] = true;\n\n    int cnt = 0;\n    double res = 0.0;\n\n    for (int to : graph[i]) {\n        if (used[to]) {\n            continue;\n        }\n\n        cnt++;\n\n        res += dfs(to) + 1.0;\n    }\n\n    if (cnt == 0) {\n        return 0.0;\n    } else {\n        return res / cnt;\n    }\n}\n\nint main() {\n    in(n);\n\n    graph.resize(n);\n    used.resize(n);\n\n    for (int i : rep(0, n - 1)) {\n        int u, v;\n        in(u, v);\n        u--;\n        v--;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    if (all_of(graph.begin(), graph.end(),\n               [](auto &node) { return node.size() <= 2; })) {\n        for (int i : rep(0, n)) {\n            if (i == 0 || i == n - 1) {\n                out(n - 1);\n            } else {\n                out((n - 1) / 2.0);\n            }\n        }\n    } else if (n <= 1000) {\n        for (int i : rep(0, n)) {\n            fill(used, false);\n            out(dfs(i));\n        }\n    } else {\n        assert(false);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n//#define scanf scanf_s\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nconst llint mod=1000000007;\n\nint N,K,gen,root;\nvector<double> uans;\nvector<double> dans;\nvector<set<int>> ko;\nvector<int> oya;\nvoid make_tree(int per,int ter){\n\tko[ter].erase(per);\n\tfor(auto it=ko[ter].begin();it!=ko[ter].end();it++){\n\t\tmake_tree(ter,*it);\n\t}\n}\ndouble find_dans(int ter){\n\tdouble ans=0;\n\tif(ko[ter].size()==0){return 0;}\n\tfor(auto it=ko[ter].begin();it!=ko[ter].end();it++){\n\t\tans+=find_dans(*it);\n\t}\n\tans/=ko[ter].size();\n\tans+=1;\n\tdans[ter]=ans;\n\treturn ans;\n}\nvoid find_uans(int per,int ter){\n\t\n\tif(ter==root){uans[ter]=dans[ter];}\n\telse if(per==root){uans[ter]=((dans[per]*ko[per].size())-dans[ter]-1)/(ko[per].size()-1)+1;}\n\telse{ uans[ter]=((dans[per]*ko[per].size()-dans[ter]-1)+uans[per])/ko[per].size()+1; }\n\tfor(auto it=ko[ter].begin();it!=ko[ter].end();it++){find_uans(ter,*it);}\n}\nint main(void){\n\tint i,j,a,b;\n\tdouble ans;\n\tscanf(\"%d\",&N);\n\tif(N==1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tif(N==2){\n\t\tprintf(\"1.0\\n1.0\\n\");return 0;\n\t}\n\tuans.resize(N);\n\tdans.resize(N);\n\tko.resize(N);\n\toya.resize(N);\n\tfor(i=1;i<N;i++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\tko[a].insert(b);\n\t\tko[b].insert(a);\n\t}\n\troot=0;a=0;\n\tif(ko[a].size()==1){root=*ko[a].begin();}\n\tmake_tree(-1,root);\n\tfind_dans(root);\n\tfind_uans(-1,root);\n\tfor(i=0;i<N;i++){\n\t\tif(i==root){ans=dans[i];}\n\t\telse{ans=(dans[i]*ko[i].size()+uans[i])/(ko[i].size()+1);}\n\t\tprintf(\"%lf\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nbool used[150000];\n\ndouble dfs(int v) {\n\tused[v] = 1;\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (!used[u])cnt++;\n\t}\n\tfor (int u : E[v]) {\n\t\tif (!used[u])ans += (dfs(u) + 1) / (double)cnt;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\tif (n <= 1000) {\n\t\trep(i, n) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tprintf(\"%.12lf\\n\", dfs(i));\n\t\t}\n\t\treturn 0;\n\t}\n\trep(i, n) {\n\t\tdouble ans;\n\t\tif (E[i].size() == 1)ans = n - 1;\n\t\telse ans = (n - 1)*0.5;\n\t\tprintf(\"%.12lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> g[150005];\ndouble d[150005];\n\nvoid dfs1(int cur, int par) {\n    int cnt = (int)g[cur].size() - (par != -1);\n    if (cnt == 0) return;\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs1(nex, cur);\n        d[cur] += (d[nex] + 1) / cnt;\n    }\n}\n\ndouble ans[150005];\n\nvoid dfs2(int cur, double d_par, int par) {\n    int cnt = g[cur].size();\n    for (int nex : g[cur]) {\n        if (nex == par) ans[cur] += d_par + 1;\n        else ans[cur] += d[nex] + 1;\n    }\n\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs2(nex, (ans[cur] - d[nex] - 1) / (cnt - (par != -1)), cur);\n    }\n    ans[cur] /= cnt;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << setprecision(20) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\nvector<pair<int,double> >G[1<<18];\nint n;\ndouble dfs(int u,int p)\n{\n\tdouble ans=0,count=0;\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(G[u][i].first==p)continue;\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tif(G[u][i].second>=0)ans+=G[u][i].second;\n\t\t\telse ans+=(G[u][i].second=dfs(G[u][i].first,u));\n\t\t}\n\t}\n\treturn(count?ans/count:0)+1;\n}\nmain()\n{\n\tcin>>n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tG[u].push_back(make_pair(v,-1));\n\t\tG[v].push_back(make_pair(u,-1));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<fixed<<setprecision(9)<<dfs(i,-1)-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "3.666666666666667\n2.250000000000000\n3.666666666666667\n2.833333333333333\n2.555555555555555\n2.666666666666667\n4.333333333333333\n2.666666666666667\n5.333333333333333\n2.500000000000000\n2.500000000000000\n5.000000000000000\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[150000], B[150000];\nvector<double> dp[150000];\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  for (int i=0; i<G[x].size(); i++) {\n    if (i == p) continue;\n    r += dfs(G[x][i], B[x][i]);\n  }\n  return dp[x][p] = (r/c)+1;\n}\n\n\nsigned main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(x, N) {\n    sort(all(G[x]));\n    B[x].resize(G[x].size());\n    dp[x].resize(G[x].size()+1, -1);\n  }\n\n  rep(x, N) {\n    for (int i=0; i<G[x].size(); i++) {\n      int t = G[x][i];\n      B[x][i] = lower_bound(all(G[t]), x) - G[t].begin();\n    }\n  }\n  rep(i, N) {\n    printf(\"%.15f\\n\", dfs(i, G[i].size()));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\ntemplate <class S, class T> using P = pair<S, T>;\ntemplate <class... T> using TP = tuple<T...>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing dbl = double;\nusing str = string;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing tl = TP<ll, ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vtl = V<tl>;\nusing vvtl = V<vtl>;\nusing vs = V<str>;\nusing vvs = V<vs>;\nusing vd = V<dbl>;\nusing vvd = V<vd>;\nusing vvvd = V<vvd>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing stll = stack<ll>;\nusing stpl = stack<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n//#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define fr front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define ROR(v,i) for(auto &(i):(v))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).bgn,(a).en)\n#define NEXTP(a) next_permutation((a).bgn,(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define fs(a) cout <<((a)?\"second\":\"first\")<<\"\\n\";\n#define Fs(a) cout <<((a)?\"Second\":\"First\")<<\"\\n\";\n#define FS(a) cout <<((a)?\"SECOND\":\"FIRST\")<<\"\\n\";\n//#define say(a) cout <<(a);\n//#define sal(a) cout <<(a)<<\"\\n\";\n#define sak cout <<\"\\n\";\n#define sas cout <<\" \";\n#define sat cout <<\"\\t\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define dbgs(...) dal(#__VA_ARGS__);dal(__VA_ARGS__);\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define LSB(a) ((a)&(-(a)))\n/*#define llin(a) ll (a);cin >>(a);\n#define llin2(a,b) ll (a),(b);cin >>(a)>>(b);\n#define llin3(a,b,c) ll (a),(b),(c);cin >>(a)>>(b)>>(c);\n#define stin(a) string (a);cin >>(a);*/\n#define vin(v) ROR((v),(i)){cin >>(i);};\n#define vllin(N,v) vll (v)((N));vin(v);\n#define vllin2(N,a,b) vll (a)(N),(b)(N);REP(i,N){cin>>(a)[i]>>(b)[i];};\n#define vsin(N,v) vs (v)((N));vin(v);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n#define tg(t,i) get<i>(t)\n\n#define Id(x) get<0>(x)\n#define Act(x) get<1>(x)\n#define InvAct(x) get<2>(x)\n#define mg(id,act) mt(id,act,lam(l))\n//#define MonoidSet(T) TP<T, function<T(T, T)>>\n#define GroupSet(T) TP<T, function<T(T, T)>, function<T(T, T)>>\n#define CompareSet(T) TP<T, function<bool(T, T)>>\n#define lam(lr) ([](auto l, auto r){return (lr);})\n#define elam(lr) ([=](auto l, auto r){return (lr);})\n#define clam(lr) ([&](auto l, auto r){return (lr);})\n#define lamr(lr) ([](auto l, auto r){lr})\n#define elamr(lr) ([=](auto l, auto r){lr})\n#define clamr(lr) ([&](auto l, auto r){lr})\n#define min(...) Operation(MIN,__VA_ARGS__)\n#define max(...) Operation(MAX,__VA_ARGS__)\n#define gcd(...) Operation(GCD,__VA_ARGS__)\n#define lcm(...) Operation(LCM,__VA_ARGS__)\n#define vmin(...) VOperation(MIN,__VA_ARGS__)\n#define vmax(...) VOperation(MAX,__VA_ARGS__)\n#define vgcd(...) VOperation(GCD,__VA_ARGS__)\n#define vlcm(...) VOperation(LCM,__VA_ARGS__)\n#define vsum(...) VOperation(ADD,__VA_ARGS__)\n#define vpro(...) VOperation(MUL,__VA_ARGS__)\n#define emin(a, ...) ((a)=min((a),__VA_ARGS__))\n#define emax(a, ...) ((a)=max((a),__VA_ARGS__))\n#define egcd(a, ...) ((a)=gcd((a),__VA_ARGS__))\n#define elcm(a, ...) ((a)=lcm((a),__VA_ARGS__))\n#define ope Operation\n#define vope VOperation\n\n#define svll SumV<ll>\n#define svvll SumV2<ll>\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) str __VA_ARGS__;Input(__VA_ARGS__);\n//#define vli(size, ...) vll __VA_ARGS__;vInitInput(size,__VA_ARGS__);\n#define vlr(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vlc(size, ...) vll __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsr(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsc(size, ...) vs __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vli2(rowSize,columnSize, ...) vvll __VA_ARGS__;vInitInput2(rowSize,columnSize,__VA_ARGS__);\n#define vplr(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vplc(size, ...) vpl __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vpli(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst vll DX = { 0,-1,0,1,0,-1,1,1,-1 };\nconst vll DY = { 0,0,-1,0,1,-1,-1,1,1 };\nconst str alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst str ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <class T> auto GetVectorValueType(T v) { return v; }\ntemplate <class T> auto GetVectorValueType(V<T> v) { return GetVectorValueType(T()); }\n\ntemplate <class S, class T> istream &operator>>(istream &in, P<S, T> &p) { return in >> p.fi >> p.se; }\ntemplate <class T> istream &operator>>(istream &in, V<T> &v) { REP(i, v.sz) in >> v[i]; return in; }\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n\tcin >> var;\n\tInput(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n\tv.res(size);\n\tvInit(size, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class T, class... Args> void vInput(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInput(size, args...);\n}\nvoid vInputR(ll size) {}\ntemplate <class T, class... Args> void vInputR(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInputR(size, args...);\n}\nvoid vInputNumC(ll num) {}\ntemplate <class T, class... Args> void vInputNumC(ll num, V<T>& v, Args&... args) {\n\tcin >> v[num];\n\tvInputNumC(num, args...);\n}\nvoid vInputC(ll size) {}\ntemplate <class... Args> void vInputC(ll size, Args&... args) {\n\tREP(i, size) vInputNumC(i, args...);\n}\nvoid vInitInputR(ll size) {}\ntemplate <class... Args> void vInitInputR(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputR(size, args...);\n}\nvoid vInitInputC(ll size) {}\ntemplate <class... Args> void vInitInputC(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputC(size, args...);\n}\nvoid vInit2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInit2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tv.asn(rowSize, V<T>(columnSize));\n\tvInit2(rowSize, columnSize, args...);\n}\nvoid vInput2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInput2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tREP(r, rowSize) {\n\t\tREP(c, columnSize) {\n\t\t\tcin >> v[r][c];\n\t\t}\n\t}\n\tvInput2(rowSize, columnSize, args...);\n}\nvoid vInitInput2(ll rowSize, ll columnSize) {}\ntemplate <class... Args> void vInitInput2(ll rowSize, ll columnSize, Args&... args) {\n\tvInit2(rowSize, columnSize, args...);\n\tvInput2(rowSize, columnSize, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n\treturn out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n\tif (v.emp) return out << \"{}\";\n\telse {\n\t\tauto itr = v.bgn;\n\t\tout << \"{\" << *itr;\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \"}\";\n\t\treturn out;\n\t}\n}\ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n\tif (m.emp) return out << \"<[]>\";\n\telse {\n\t\tauto itr = m.bgn;\n\t\tout << \"< [\" << (itr->fi) << \": \" << (itr->se);\n\t\titr++;\n\t\twhile (itr != m.en) {\n\t\t\tout << \"], [\" << (itr->fi) << \": \" << (itr->se);\n\t\t\titr++;\n\t\t}\n\t\tout << \"] >\";\n\t\treturn out;\n\t}\n}\ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n\tif (s.emp) return out << \"<>\";\n\telse {\n\t\tauto itr = s.bgn;\n\t\tout << \"<\" << *itr;\n\t\titr++;\n\t\twhile (itr != s.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \">\";\n\t\treturn out;\n\t}\n}\n\nvoid say() {}\ntemplate <class T> void say(T t) { cout << t; }\ntemplate <class Head, class... Body> void say(Head head, Body... body) {\n\tcout << head << \" \";\n\tsay(body...);\n}\nvoid sal() { cout << \"\\n\"; }\ntemplate <class... Args> void sal(Args... args) {\n\tsay(args...);\n\tcout << \"\\n\";\n}\n\nvoid day() {}\ntemplate <class T> void day(T t) { cerr << t; }\ntemplate <class Head, class... Body> void day(Head head, Body... body) {\n\tcerr << head << \" \";\n\tday(body...);\n}\nvoid dal() { cerr << \"\\n\"; }\ntemplate <class... Args> void dal(Args... args) {\n\tday(args...);\n\tcerr << \"\\n\";\n}\n\nvoid salv() {}\ntemplate <class T> void salv(V<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tauto itr = v.bgn;\n\t\tsay(*itr);\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tsas;\n\t\t\tsay(*itr);\n\t\t\titr++;\n\t\t}\n\t\tsak;\n\t}\n}\ntemplate <class T> void salv(VV<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tROR(v, i) salv(i);\n\t}\n}\ntemplate <class T, class... Args> void salv(T v, Args... args) {\n\tsalv(v);\n\tsalv(args...);\n}\n\n\ntemplate <class L, class R> auto Gcd(L l, R r) -> decltype(l + r) {\n\tif (l < r) swap(l, r);\n\treturn r ? Gcd(r, l%r) : l;\n}\ntemplate <class L, class R> auto Lcm(L l, R r) {\n\tif (!l || !r) return 0;\n\treturn l / Gcd(l, r) * r;\n}\n\n/*\nauto LES = mp(INF, lam(return l < r;));\nauto GRT = mp(-INF, lam(return l > r;));\nauto EQ = mp(0, lam(return l == r;));\n\nauto ADD = mp(0, lam(return l + r;));\nauto SUB = mp(0, lam(return l - r;));\nauto MUL = mp(1, lam(return l * r;));\nauto DIV = mp(1, lam(return l / r;));\nauto MDL = mp(1, lam(return l % r;));\nauto XOR = mp(0, lam(return l ^ r;));\nauto OR = mp(0, lam(return l | r;));\nauto AND = mp(((ll)(1) << 63) - 1, lam(return l & r;));\nauto MIN = mp(INF, lam(return (l < r) ? l : r;));\nauto MAX = mp(-INF, lam(return (l > r) ? l : r;));\nauto GCD = mp(0, lam(return Gcd(l, r);));\nauto LCM = mp(1, lam(return Lcm(l, r);));\n*/\n\nauto LES = mp(INF, lam(l < r));\nauto GRT = mp(-INF, lam(l > r));\nauto EQ = mp(0, lam(l == r));\n\nauto ADD = mt(0, lam(l + r), lam(l - r));\nauto MUL = mt(1, lam(l * r), lam(l / r));\nauto XOR = mt(0, lam(l ^ r), lam(l ^ r));\nauto OR = mg(0, lam(l | r));\nauto AND = mg(((ll)(1) << 63) - 1, lam(l & r));\nauto MIN = mg(0, lam((l < r) ? l : r));\nauto MAX = mg(0, lam((l > r) ? l : r));\nauto GCD = mg(0, lam(Gcd(l, r)));\nauto LCM = mg(0, lam(Lcm(l, r)));\n\ntemplate <class OperationType> auto Operation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto Operation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T, class... Args> auto Operation(OperationType A, T x, Args... args) {\n\tauto tmp = Operation(A, args...);\n\treturn Act(A)(x, tmp);\n}\n\ntemplate <class OperationType> auto VOperation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, V<T> v) {\n\tif (v.emp) {\n\t\tdecltype(GetVectorValueType(T())) tmp = Id(A);\n\t\treturn tmp;\n\t}\n\tauto tmp = VOperation(A, v[0]);\n\tFOR(i, 1, v.sz - 1) tmp = Act(A)(tmp, VOperation(A, v[i]));\n\treturn tmp;\n}\ntemplate <class OperationType, class T, class... Args> auto VOperation(OperationType A, T x, Args... args) {\n\tauto xResult = VOperation(A, x);\n\tauto tmp = VOperation(A, args...);\n\treturn Act(A)(xResult, tmp);\n}\n\n\nll Bset(ll a, ll b, ll c) {\n\tif (c) a |= b;\n\telse a &= ~b;\n\treturn a;\n}\n\n\nstruct UFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tUFT(ll tsizeget, ll modeget = 0){\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct pUFT {\n\npublic:\n\n\tll tsize;\n\tll now;\n\tvll par;\n\tvll rank;\n\tvll mtime;\n\tvvll sizepi;\n\tVV<T> sizepv;\n\tV<T> elm;\n\tGroupSet(T) Add;\n\n\tpUFT(ll tsize, GroupSet(T) Add = ADD) : tsize(tsize), Add(Add) { init(); }\n\tvoid init() {\n\t\tnow = 0;\n\t\tpar.asn(tsize, -1);\n\t\trank.asn(tsize, 0);\n\t\tmtime.asn(tsize, INF);\n\t\tsizepi.asn(tsize, { 0 });\n\t\tsizepv.asn(tsize, {});\n\t}\n\tvoid set(ll x, T s) {\n\t\telm[x] = s;\n\t\tsizepv[x] = { s };\n\t}\n\tll root(ll x, ll t) {\n\t\treturn (mtime[x] > t) ? x : root(par[x], t);\n\t}\n\tbool same(ll x, ll y, ll t) {\n\t\treturn root(x, t) == root(y, t);\n\t}\n\tll merge(ll x, ll y) {\n\t\tnow++;\n\t\tx = root(x, now);\n\t\ty = root(y, now);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[y].pb(now);\n\t\t\t\tsizepv[y].pb(elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t\tmtime[x] = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[x].pb(now);\n\t\t\t\tsizepv[x].pb(elm[x]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tmtime[y] = now;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tT size(ll x, ll t) {\n\t\tx = root(x, t);\n\t\treturn sizepv[x][UPB(sizepi[x], t) - 1];\n\t}\n\n};\n\nstruct wUFT {\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tvll dweight;\n\twUFT(ll tsizeget, ll modeget = 0) {\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\tdweight.asn(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\tif (par[x] < 0) return x;\n\t\telse {\n\t\t\tll r = root(par[x]);\n\t\t\tdweight[x] += dweight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\tll weight(ll x) {\n\t\troot(x);\n\t\treturn dweight[x];\n\t}\n\tll diff(ll x, ll y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y, ll w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t\tdweight[x] = -w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t\tdweight[y] = w;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct sUFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tGroupSet(T) Add;\n\tV<T> elm;\n\tsUFT(ll tsize, GroupSet(T) Add = ADD, ll mode = 0) : tsize(tsize), Add(Add), mode(mode) { init(); }\n\tvoid init() {\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\telm.asn(tsize, Id(Add));\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tT size(ll x) {\n\t\treturn elm[root(x)];\n\t}\n\tT& operator[](ll x) { return elm[x]; }\n};\n\ntemplate <typename valtype> class SegT {\n\npublic:\n\n\tll size;\n\tvector<valtype> v;\n\n\tvaltype initv;\n\tfunction<valtype(valtype x, valtype y)> calc;\n\n\tSegT() {}\n\tSegT(const SegT &segt) {}\n\n\tSegT(ll sizeget, ll modeget = 0) {\n\t\tsizeset(sizeget);\n\t\tmodeset(modeget);\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, ll modeget = 0) {\n\t\tsizeset(cpyvec.sz);\n\t\tmodeset(modeget);\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tSegT(ll sizeget, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(sizeget);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(cpyvec.sz);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tvoid sizeset(ll rsize) {\n\t\tsize = DigN2(rsize);\n\t\tif (rsize == Pow2(size - 1)) size--;\n\t\treturn;\n\t}\n\tvoid modeset(ll mode) {\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tinitv = 0;\n\t\t\tcalc = [](valtype x, valtype y) {return x + y; };\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinitv = INF;\n\t\t\tcalc = [](valtype x, valtype y) {return min(x, y); };\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinitv = -INF;\n\t\t\tcalc = [](valtype x, valtype y) {return max(x, y); };\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tvoid init() {\n\t\tv.asn(Pow2(size + 1) - 1, initv);\n\t}\n\tvoid copy(vector<valtype> cpyvec) {\n\t\tREP(i, min(cpyvec.sz, Pow2(size))) set(i, cpyvec[i]);\n\t}\n\tll i2v(ll i) const{\n\t\tif (i < 0 || i >= Pow2(size)) return -1;\n\t\treturn Pow2(size) + i - 1;\n\t}\n\tll top(ll i) const{\n\t\tif (i == 0) return -1;\n\t\treturn (i - 1) / 2;\n\t}\n\tpl bot(ll i) const{\n\t\tif (i + 1 >= Pow2(size)) return mp(-1, -1);\n\t\treturn mp(2 * i + 1, 2 * i + 2);\n\t}\n\tvoid set(ll i, valtype x) {\n\t\ti = i2v(i);\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = top(i);\n\t\t\tv[i] = calc(v[bot(i).fi], v[bot(i).se]);\n\t\t}\n\t\treturn;\n\t}\n\tvoid add(ll i, valtype x) {\n\t\tset(i, v[i2v(i)] + x);\n\t\treturn;\n\t}\n\tvaltype operator[](const ll &i) const {\n\t\treturn v[i2v(i)];\n\t}\n//\tvaltype que(ll a = 0, ll b = Pow2(size) - 1) {\n\tvaltype que(ll a, ll b) {\n\t\tif (a == b) return v[i2v(a)];\n\t\tif (a > b) return initv;//swap(a, b);\n\t\tvaltype ans = initv;\n\t\tll ai = i2v(a);\n\t\tll bi = i2v(b);\n\t\tFOR(i, 1, size + 1) {\n\t\t\tif (a > b) break;\n\t\t\tif (a%Pow2(i)) {\n\t\t\t\tans = calc(ans, v[ai]);\n\t\t\t\ta += Pow2(i - 1);\n\t\t\t\tai = top(ai) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tai = top(ai);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t\tif ((b + 1) % Pow2(i)) {\n\t\t\t\tans = calc(ans, v[bi]);\n\t\t\t\tb -= Pow2(i - 1);\n\t\t\t\tbi = top(bi) - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbi = top(bi);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t}\n\t\treturn ans;\n\t}\n\tvaltype que(ll b) {\n\t\treturn que(0, b);\n\t}\n\tvaltype que() {\n\t\treturn que(0, Pow2(size) - 1);\n\t}\n\n\n};\n\n\n/*template <class Type> class DP {\n\npublic:\n\n\tvector<Type> v;\n\tType initv;\n\tvll size, block;\n\n\tDP() {}\n\tDP(const DP &dp) {}\n\n\ttemplate<class... Args> DP(Args... args) {\n\t\tblock.asn(1, 1);\n\t\tInitialize(args...);\n\t}\n\n\tvoid Initialize(Type initv_) {\n\t\tinitv = initv_;\n\t\tv.asn(block.bk, initv);\n\t}\n\ttemplate<class... Args> void Initialize(ll val, Args... args) {\n\t\tsize.pb(val);\n\t\tblock.pb(block.bk*val);\n\t\tInitialize(args...);\n\t}\n\n\n\n};*/\n\n\npl Bezout(ll a, ll b) {\n\tif (b != 0) {\n\t\tpl xy;\n\t\txy = Bezout(b, a%b);\n\t\treturn mp(xy.se, xy.fi - ((a / b)*xy.se));\n\t}\n\telse {\n\t\treturn mp(1, 0);\n\t}\n}\npl Bez(ll a, ll b, ll c) {\n\tpl xy;\n\tll x, y, z, gc;\n\txy = Bezout(a, b);\n\tgc = gcd(a, b);\n\tif (c%gc != 0) return mp(-1, -1);\n\tx = xy.fi*(c / gc); y = xy.se*(c / gc);\n\tif (x < 0) z = rup(-x, (b / gc));\n\tif (x >= 0) z = -x / (b / gc);\n\tx += z * (b / gc);\n\ty -= z * (a / gc);\n\treturn mp(x, y);\n}\n\nll DigS10(ll n) {\n\tll ans = 0;\n\twhile(1) {\n\t\tans += n % 10;\n\t\tn /= 10;\n\t\tif (!n) break;\n\t}\n\treturn ans;\n}\n\nll isP(ll n) {\n\tif (n <= 1) return 0;\n\tFOR(i, 2, (ll)sqrt(n) + 1) {\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nll Tot(ll n) {\n\tif (n <= 0) return 0;\n\tll ans = n, x = 2;\n\twhile (x*x <= n) {\n\t\tif (n%x == 0) {\n\t\t\tans -= ans / x;\n\t\t\twhile (n%x == 0) n /= x;\n\t\t}\n\t\tx++;\n\t}\n\tif (n > 1) ans -= ans / n;\n\treturn ans;\n}\n\ntemplate <class T> struct Graph {\npublic:\n\tll vSize;\n\tll eMode;\n\tll mapMode;\n\tGroupSet(T) Add;\n\tCompareSet(T) Less;\n\tCompareSet(T) Equal;\n\tVV<P<T, ll>> adj;\n\tmap<pl, T> len;\n\tGraph(ll vSize, ll eMode = 0, ll mapMode = 0, GroupSet(T) Add = ADD, CompareSet(T) Less = LES, CompareSet(T) Equal = EQ) : vSize(vSize), eMode(eMode), mapMode(mapMode), Add(Add), Less(Less), Equal(Equal) {}\n\tvoid Init() {\n\t\tadj.asn(vSize, V<P<T, ll>>());\n\t}\n\tvoid AddE(ll x, ll y, T cost) {\n\t\tiAddE(x, y, cost);\n\t\tif (!eMode) iAddE(y, x, cost);\n\t}\n\tvoid iAddE(ll x, ll y, T cost) {\n\t\tadj[x].pb(mp(cost, y));\n\t\tif (mapMode) len[mp(x, y)] = cost;\n\t}\n\tP<bool, T> getE(ll x, ll y) {\n\t\tif (!len.count(mp(x, y))) return mp(false, Id(Less));\n\t\treturn mp(true, len[mp(x, y)]);\n\t}\n\tV<T> Dijk(ll x) {\n\t\tV<T> ans(vSize, Id(Less));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se] = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se], i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tV<P<T, vll>> rDijk(ll x) {\n\t\tV<P<T, vll>> ans(vSize, mp(Id(Less), vll()));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se].fi = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tans[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tT Prim(ll x = 0) {\n\t\tT ans = Id(Add);\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans = Act(Add)(ans, segt[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tP<T, V<P<T, vll>>> rPrim(ll x = 0) {\n\t\tP<T, V<P<T, vll>>> ans = mp(Id(Add), V<P<T, vll>>(vSize, mp(Id(Less), vll())));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans.se[now.se].fi = segt[now.se].fi;\n\t\t\tans.fi = Act(Add)(ans.fi, ans.se[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tans.se[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\ntemplate <class T> struct Sum {\npublic:\n\tV<T> v, s;\n\tll size;\n\tGroupSet(T) Add;\n\tSum(V<T> v, GroupSet(T) Add = ADD) : v(v), size(v.sz), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(size + 1, Id(Add));\n\t}\n\tvoid Calc() {\n\t\tREP(i, size) s[i + 1] = Act(Add)(s[i], v[i]);\n\t}\n\tT operator()(ll x) {\n\t\tif (x < -1) x = -1;\n\t\tif (x > size - 1) x = size - 1;\n\t\treturn s[x + 1];\n\t}\n\tT operator()(ll l, ll r) {\n\t\tif (l < 0) l = 0;\n\t\tif (r >= size) r = size - 1;\n\t\tif (l > r) return Id(Add);\n\t\treturn InvAct(Add)(s[r + 1], s[l]);\n\t}\n};\nusing sumll = Sum<ll>;\n\ntemplate <class T> struct Sum2 {\npublic:\n\tVV<T> v, s;\n\tll RowSize, ColumnSize;\n\tGroupSet(T) Add;\n\tSum2(VV<T> v, GroupSet(T) Add = ADD) : v(v), RowSize(v.sz), ColumnSize(v.sz ? v[0].sz : 0), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(RowSize + 1, V<T>(ColumnSize + 1, Id(Add)));\n\t}\n\tvoid Calc() {\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n//\t\t\t\ts[r][c] = InvAct(Add)(Act(Add)(Act(Add)(v[r - 1][c - 1], operator()(r - 1, c - 2)), operator()(r - 2, c - 1)), operator()(r - 2, c - 2));\n\t\t\t\ts[r][c] = Act(Add)(s[r][c - 1], v[r - 1][c - 1]);\n\t\t\t}\n\t\t}\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n\t\t\t\ts[r][c] = Act(Add)(s[r - 1][c], s[r][c]);\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(ll r, ll c) {\n\t\tif (r < -1) r = -1;\n\t\tif (c < -1) c = -1;\n\t\tif (r > RowSize - 1) r = RowSize - 1;\n\t\tif (c > ColumnSize - 1) c = ColumnSize - 1;\n\t\treturn s[r + 1][c + 1];\n\t}\n\tT operator()(ll r1, ll c1, ll r2, ll c2) {\n\t\tif (r1 < 0) r1 = 0;\n\t\tif (c1 < 0) c1 = 0;\n\t\tif (r2 >= RowSize) r2 = RowSize - 1;\n\t\tif (c2 >= ColumnSize) c2 = ColumnSize - 1;\n\t\tif (r1 > r2) return Id(Add);\n\t\tif (c1 > c2) return Id(Add);\n\t\treturn InvAct(Add)(Act(Add)(s[r2 + 1][c2 + 1], s[r1][c1]), Act(Add)(s[r2 + 1][c1], s[r1][c2 + 1]));\n\t}\n};\nusing sumll2 = Sum2<ll>;\n\ntemplate <class T> struct Point2 {\npublic:\n\tVV<T> v;\n\tll h, w;\n\tPoint2() : h(0), w(0) {}\n\tPoint2(ll h, ll w) : h(h), w(w) { asn(h, w); }\n\tPoint2(ll h, ll w, T val) : h(h), w(w) { asn(h, w, val); }\n\tPoint2(VV<T> cv) : h(cv.sz), w(cv.sz ? cv[0].sz : 0) { asn(h, w); copy(cv); }\n\tvoid assign(ll h, ll w) { v.asn(h, V<T>(w)); }\n\tvoid assign(ll h, ll w, ll val) { v.asn(h, V<T>(w, val)); }\n\tvoid copy(VV<T> cv) { REP(_h, h) REP(_w, w) v[_h][_w] = cv[_h][_w]; }\n\tT& operator()(ll h, ll w) { return v[h][w]; }\n\tT& operator()(pl p) { return v[p.fi][p.se]; }\n\tT& operator[](pl p) { return v[p.fi][p.se]; }\n};\ntemplate <class T> using P2 = Point2<T>;\n\ntemplate <ll Mod> struct Modll {\npublic:\n\tll v;\n\tModll() : v(0) {}\n\tModll(ll _v) { set(_v % Mod + Mod); }\n\tModll& set(ll _v) {\n\t\tv = (_v < Mod) ? _v : (_v - Mod);\n\t\treturn *this;\n\t}\n\tModll pow(ll n) const {\n\t\tModll x = *this, ans = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) ans *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tModll inverse() const { return (*this).pow(Mod - 2); }\n\tModll operator+(const Modll& m) const { return Modll().set(v + m.v); }\n\tModll operator-(const Modll& m) const { return Modll().set(Mod + v - m.v); }\n\tModll operator*(const Modll& m) const { return Modll().set((ull(v) * m.v) % Mod); }\n\tModll operator/(const Modll& m) const { return *this * m.inv; }\n\tModll& operator+=(const Modll& m) { return *this = *this + m; }\n\tModll& operator-=(const Modll& m) { return *this = *this - m; }\n\tModll& operator*=(const Modll& m) { return *this = *this * m; }\n\tModll& operator/=(const Modll& m) { return *this = *this / m; }\n\tModll operator-() const { return Modll(0) - *this; }\n\texplicit operator bool() const { return v != 0; }\n\tfriend istream& operator>>(istream& in, Modll& m) { return in >> m.v; }\n\tfriend ostream& operator<<(ostream& out, const Modll& m) { return out << m.v; }\n};\nusing mll = Modll<MOD>;\nusing vmll = V<mll>;\nusing vvmll = V<vmll>;\nusing vvvmll = V<vvmll>;\n\nvmll MFactMemo(2, 1);\nvmll MIFactMemo(2, 1);\n\nmll mFact(ll n) {\n\tif (MFactMemo.sz <= n) {\n\t\tll oldsize = MFactMemo.sz;\n\t\tMFactMemo.res(n + 1, 1);\n\t\tFOR(i, oldsize, n) MFactMemo[i] = MFactMemo[i - 1] * i;\n\t}\n\treturn MFactMemo[n];\n}\nmll miFact(ll n) {\n\tif (MIFactMemo.sz <= n) {\n\t\tll oldsize = MIFactMemo.sz;\n\t\tMIFactMemo.res(n + 1, 1);\n\t\tMIFactMemo.bk = mFact(n).inv;\n\t\trFOR(i, oldsize + 1, n) MIFactMemo[i - 1] = MIFactMemo[i] * i;\n\t}\n\treturn MIFactMemo[n];\n}\nmll mComb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn mFact(n) * miFact(k) * miFact(n - k);\n}\n\nll LIS(vll v, ll m = 0) {\n\n\tif (v.sz > 0) {\n\t\tll ans = 0;\n\t\tvll dp(v.sz, INF);\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tdp[m ? UPB(dp, v[i]) : LOWB(dp, v[i])] = v[i];\n\t\t}\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tif (dp[i] == INF) break;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n}\n\nll Bsrch(function<bool(ll x)> f, ll mi, ll ma) {\n\tll ng = mi - 1, ok = ma, mid;\n\twhile (ok - ng > 1) {\n\t\tmid = (ng + ok) / 2;\n\t\t(f(mid) ? ok : ng) = mid;\n\t}\n\treturn ok;\n}\n\ntemplate <class T, class M = decltype(MUL), class S = decltype(ADD)> VV<T> MultiMatrix(VV<T> A, VV<T> B, M Mul = MUL, S Add = ADD) {\n\tVV<T> ans;\n\tll ii = A.sz;\n\tif (!ii) return ans;\n\tll jj = A[0].sz;\n\tif (!jj) return ans;\n\tll jj2 = B.sz;\n\tif (!jj2) return ans;\n\tif (jj != jj2) return ans;\n\tll kk = B[0].sz;\n\tif (!kk) return ans;\n\tans.asn(ii, V<T>(kk, 0));\n\tREP(i, ii) {\n\t\tREP(k, kk) {\n\t\t\tREP(j, jj) {\n\t\t\t\tans[i][k] = Act(Add)(ans[i][k], Act(Mul)(A[i][j], B[j][k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n\tif ((n < 0) || (k < 0)) return 0;\n\tif (CombMemo[n][k] == -1) {\n\t\tif (n < k) CombMemo[n][k] = 0;\n\t\telse {\n\t\t\tif (n == 0) CombMemo[n][k] = 1;\n\t\t\telse if (k == 0) CombMemo[n][k] = 1;\n\t\t\telse if (n == k) CombMemo[n][k] = 1;\n\t\t\telse CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n\t\t}\n\t}\n\treturn CombMemo[n][k];\n}\n\ntemplate<class T> map<T, ll> Dict(V<T> v) {\n\tmap<T, ll> m;\n\tif (!v.sz) return m;\n\tSORT(v);\n\tUNIQUE(v);\n\tREP(i, v.sz) {\n\t\tm[v[i]] = i;\n\t}\n\treturn m;\n}\n\ntemplate <class T> vll Cmprs(V<T> v) {\n\tauto m = Dict(v);\n\tvll ans(v.sz);\n\tREP(i,v.sz) {\n\t\tans[i] = m[v[i]];\n\t}\n\treturn ans;\n}\n\ntemplate <class T> vll PCmprs(V<T> v) {\n\tif (v.sz == 0) return V<T>();\n\tvll tmp(v.sz);\n\tvll ans(v.sz);\n\tIOTA(tmp, 0);\n\tIOTA(ans, 0);\n\tsort(tmp.bgn, tmp.en, clam(v[l] < v[r]));\n\tsort(ans.bgn, ans.en, clam(tmp[l] < tmp[r]));\n\treturn ans;\n}\n\nll BblCnt(vll rv) {\n\tvll v = PCmprs(rv);\n\tSegT<ll> b(v.sz, 0);\n\tll ans = 0;\n\tREP(i, v.sz) {\n\t\tans += (i - b.que(0, v[i]));\n\t\tb.add(v[i], 1);\n\t}\n\treturn ans;\n}\n\npl NGrid(pl p, ll i, ll H, ll W) {\n\tp = mp(p.fi + DX[i], p.se + DY[i]);\n\tif (p.fi < 0 || p.fi >= H || p.se < 0 || p.se >= W) return mp(INF, INF);\n\treturn p;\n}\n\nvvll llGrid(vs v) {\n\tvvll r(v.sz, vll(v.sz ? v[0].sz : 0, 0));\n\tREP(h, v.sz) REP(w, v.sz ? v[0].sz : 0) r[h][w] = (v[h][w] == '#');\n\treturn r;\n}\n\ntemplate <class T> auto ven(T val) { return val; }\ntemplate <> auto ven<int>(int val) { return (ll)val; }\ntemplate <class T, class... Args> auto ven(T val, Args... args) {\n\tauto tmp = ven(args...);\n\treturn V<decltype(tmp)>(val, tmp);\n}\n\ntemplate <class T> void zind(T& v) { v--; }\ntemplate <class T> void zind(V<T>& v) { ROR(v, i) zind(i); }\ntemplate <class T, class... Args> void zind(T& v, Args&... args) { zind(v); zind(args...); }\n\nvoid Solve();\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(20) << fixed;\n\tSolve();\n}\n\n//index_sort\n\nll N;\nvvpl adj;\nvvd dp;\nvvd dp1;\nvvd dp2;\n\ndbl dfs(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tdbl tmp = 0;\n\tll y = adj[x][n].fi;\n\tREP(i, adj[y].sz) {\n\t\tif (adj[y][i].fi == x) continue;\n\t\ttmp += dfs(y, i);\n\t}\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\ndbl rec(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tll y = adj[x][n].fi;\n\tif (!dp1[y].sz) {\n\t\tdp1[y].asn(dp[y].sz, 0);\n\t\tdp2[y].asn(dp[y].sz, 0);\n\t\tFOR(i, 1, dp[y].sz - 1) dp1[y][i] = dp1[y][i - 1] + dp[y][i - 1];\n\t\trFOR(i, 0, dp[y].sz - 2) dp2[y][i] = dp2[y][i + 1] + dp[y][i + 1];\n\t}\n\tdbl tmp = dp1[y][adj[x][n].se] + dp2[y][adj[x][n].se];\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\n\nvoid Solve() {\n\n\tcin >> N;\n\tadj = ven(N, vpl(0));\n\tdp = ven(N, vd(0));\n\tdp1 = ven(N, vd(0));\n\tdp2 = ven(N, vd(0));\n\tREP(i, N - 1) {\n\t\tli(u, v);\n\t\tu--; v--;\n\t\tadj[u].pb(mp(v, adj[v].sz));\n\t\tadj[v].pb(mp(u, adj[u].sz - 1));\n\t\tdp[u].pb(-1);\n\t\tdp[v].pb(-1);\n\t}\n\tREP(i, adj[0].sz) dfs(0, i);\n\tREP(i, N) {\n\t\tdbl tmp = 0;\n\t\tREP(j,adj[i].sz) {\n\t\t\ttmp += rec(i, j);\n\t\t}\n\t\ttmp /= dbl(adj[i].sz);\n\t\tsal(tmp);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <array>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nstruct Graph {\n    struct Edge { int i, n; double t; };\n    struct Vertex { int n; };\n    Graph(int n, int m) : v(n, { -1 }), e(m, { -1, -1, 0.0 }), c(0) {}\n    void add_edge(int i, int j) {\n        e[c] = { j, v[i].n, 0.0 };\n        v[i].n = c;\n        c++;\n    }\n    double foo(int i, int p) {\n        double s = 0;\n        int k = 0;\n        for (int j = v[i].n; j >= 0; j = e[j].n) {\n            Edge& o = e[j];\n            if (o.i == p) continue;\n            double t = o.t;\n            if (t == 0.0) o.t = t = foo(o.i, i) + 1;\n            s += t;\n            k++;\n        }\n        if (k != 0) s /= k;\n        return s;\n    }\n    vector<Edge> e;\n    vector<Vertex> v;\n    int c;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph g(n, (n - 1) * 2);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v);\n        g.add_edge(v, u);\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << fixed << setprecision(12) << g.foo(i, -1) << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint tu[150010], tv[150010];\nvector<int> G[150010];\n\nlong double dfs(int now, int pre, long double E, int dist){\n\tdouble ret = 0;\n\tint nextsize;\n\tif(pre == -1) nextsize = G[now].size();\n\telse nextsize = G[now].size() - 1;\n\tif(nextsize == 0){\n\t\treturn dist * E;\n\t}\n\tfor(auto u : G[now]){\n\t\tif(u == pre) continue;\n\t\tret += dfs(u, now, E / nextsize, dist + 1);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N - 1) cin >> tu[i] >> tv[i];\n\trep(i, N - 1) tu[i]--, tv[i]--;\n\trep(i, N - 1){\n\t\tG[tu[i]].pb(tv[i]);\n\t\tG[tv[i]].pb(tu[i]);\n\t}\n\trep(i, N){\n\t\tlong double ret = dfs(i, - 1, 1.0, 0);\n\t\tprintf(\"%.9Lf\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; const int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//template end\n\nint n; vector<int> g[150010];\ndouble dp[150010],ans[150010];\nvoid dfs1(int v,int pre){\n    dp[v]=0; int cnt=0;\n    for(int to:g[v])if(to!=pre){\n        dfs1(to,v); \n        dp[v]+=dp[to]+1; cnt++;\n    } if(cnt)dp[v]/=cnt;\n}\nvoid dfs2(int v,int pre,double add){\n    double sum=0;\n    for(int to:g[v]){\n        if(to==pre)sum+=add+1;\n        else sum+=dp[to]+1;\n    } ans[v]=sum/g[v].size();\n    for(int to:g[v])if(to!=pre){\n        dfs2(to,v,(double)((sum-dp[to]-1)/max(1,(int)g[v].size()-1)));\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,0,n-1){\n        int a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    dfs1(0,-1); dfs2(0,-1,1);\n    rep(i,0,n)printf(\"%.12f\\n\",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <functional>\n\ntemplate <typename data_t>\nclass RerootingTree {\n\n    struct edge {\n        int to;      // dest node\n        int rev;     // index of reverse edge\n        data_t data;\n    };\n\n    /* merge_data_func\n     *   merge two datas\n     * \\in : data_t a, data_t b\n     * \\out : data_t (merge of a and b)\n     */\n    using merge_data_func = function<data_t(data_t, data_t)>;\n\n    /* add_root_func\n     *   merge a data and a node\n     * \\in : \n     *   data_t a : sum of the data towards all child subtrees\n     *     // (erased)int root : root of the current subtree\n     *   data_t from_par : original data that was on edge(root<-par)\n     * \\out : data_t (complete data of the current subtree)\n     */\n    using add_root_func = function<data_t(data_t, data_t)>;\n\n    int n;                            // number of edges\n    vector<vector<edge>> G;           // G[i] : list of edges starts from node_i\n    const merge_data_func merge_data;\n    const add_root_func  add_root;\n    const data_t identity;            // identity of data_t (if integer, its 0)\n\n    vector<data_t> result;\n\npublic:\n\n    RerootingTree(int _n, merge_data_func _merge_data, add_root_func _add_root, data_t _identity) \n        : n(_n)\n        , G((size_t)n, vector<edge>())\n        , merge_data(_merge_data)\n        , add_root(_add_root)\n        , identity(_identity)\n        , result((size_t)n) {}\n\n    // add edge a <-> b\n    void add_edge(int a, int b, data_t data) {\n        int arev = (int)G[(size_t)b].size(), brev = (int)G[(size_t)a].size();\n        G[(size_t)a].push_back({b, arev, data});\n        G[(size_t)b].push_back({a, brev, data});\n    }\n    void add_edge(int a, int b) { add_edge(a, b, identity); }\n\n    // the main function\n    vector<data_t> operator()() {\n        dfs_from_root(0, -1, identity);\n        dfs_to_root(0, -1, identity);\n        return result;\n    }\n\n    // get the structure of the tree\n    auto operator[](int i) const { return G.at(i); }\n    auto &operator[](int i) { return G.at(i); }\n\nprivate:\n    // determines all data of edges which directs towards the botom of the tree\n    data_t dfs_from_root(int node, int par, data_t data_from_par) {\n        auto &edges = G[(size_t)node];\n        data_t result = identity;\n        for (auto &e:edges) {\n            if (e.to == par) continue;\n            e.data = dfs_from_root(e.to, node, e.data);\n            result = merge_data(result, e.data);\n        }\n        return add_root(result, data_from_par);\n    }\n\n    // determines all data of edges which directs towards the root\n    void dfs_to_root(int node, int par, data_t data_to_par) {\n        auto &edges = G[(size_t)node];\n        size_t deg = edges.size();\n        vector<data_t> cumul_l(deg+1, identity), cumul_r(deg+1, identity); // cumulative sum of data from both sides\n        for (size_t i=0; i<deg; i++) {\n            if (edges[i].to == par) {\n                edges[i].data = data_to_par;\n            }\n            cumul_l[i+1] = merge_data(cumul_l[i], edges[i].data);\n        }\n        for (size_t i=deg; i>0; i--) {\n            cumul_r[i-1] = merge_data(cumul_r[i], edges[i-1].data);\n        }\n\n        result[(size_t)node] = add_root(cumul_r[0], identity); // sum of all Datas is the result for the node\n\n        for (size_t i=0; i<deg; i++) {\n            if (edges[i].to == par) continue;\n            data_t total_of_others = merge_data(cumul_l[i], cumul_r[i+1]);\n            data_t rev_edge_data = G[(size_t)edges[i].to][(size_t)edges[i].rev].data;\n            dfs_to_root(edges[i].to, node, add_root(total_of_others, rev_edge_data));\n        }\n    }\n};\n/*\nConstructers\nRerootingTree(n, merge_data, add_root, identity)\n*/\n\nusing P = pair<double, int>;\n#define fi first\n#define se second\n\nint main() {\n    int n;\n    cin >> n;\n    int deg[n];\n    fill(deg, deg+n, 0);\n    RerootingTree<P> rrt(\n        n,\n        [](P a, P b) { return P{a.fi + b.fi, a.se + b.se}; },\n        [](P a, P par) { \n            if (a.se > 0)\n                return P{a.fi / a.se + 1, 1}; \n            else\n                return P{a.fi, 1};\n        },\n        P{0, 0}\n    );\n    for (int i=0, ui, vi; i<n-1; i++) {\n        cin >> ui >> vi;\n        rrt.add_edge(--ui, --vi);\n        deg[ui]++;\n        deg[vi]++;\n    }\n    for (auto &ri:rrt()) cout << setprecision(15) << fixed << ri.fi << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<pair<int, int>> g[N];\nvector<double> expect[N];\n\ndouble dfs(int i, int p, int t) {\n  if(expect[i][t] > -1) return expect[i][t];\n  expect[i][t] = 0;\n  for(auto edge : g[i]) if(edge.first != p) {\n    expect[i][t] += (1 + dfs(edge.first, i, edge.second));\n  }\n  if(g[i].size() - (p != -1)) expect[i][t] /= (g[i].size() - (p != -1));\n  return expect[i][t];\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    expect[a].emplace_back(-1);\n    expect[b].emplace_back(-1);\n    g[a].emplace_back(b, expect[b].size() - 1);\n    g[b].emplace_back(a, expect[a].size() - 1);\n  }\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) {\n    expect[i].emplace_back(-1);\n    cout << dfs(i, -1, expect[i].size() - 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nconst int inf=1145141919;\nconst int mod=1000000007;\nconst int dd[]={0,-1,0,1,0};\nusing namespace std;\nint a,b,c,d;\nstruct Node{\n\tdouble u=0;\n\tvector<int> e;\n\tunordered_map<int,double> ma;\n};\nNode *p;\ndouble saiki(int u,int v){\n\tauto it=p[u].ma.find(v);\n\tif(it!=end(p[u].ma))\n\t\treturn it->second;\n\tdouble ans=0;\n\tint i=0;\n\tfor(auto x:p[u].e){\n\t\tif(x==v)\n\t\t\tcontinue;\n\t\tans+=saiki(x,u)+1;\n\t\ti++;\n\t}\n\tif(i!=0)\n\t\tans/=i;\n\tp[u].ma.insert({v,ans});\n\treturn ans;\n}\nsigned main(){\n\tint i,j;\n\tcin>>a;\n\tp=new Node[a];\n\tfor(i=0;i<a-1;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tp[u].e.push_back(v);\n\t\tp[v].e.push_back(u);\n\t}\n\tif(a==1){\n\t\tcout<<\"0\"<<endl;\n\t\treturn 0;\n\t}\n\tfor(i=0;i<a;i++)\n\t\tp[i].ma.reserve(p[i].e.size());\n\tfor(i=0;i<a;i++)\n\t\tcout<<setprecision(15)<<saiki(i,-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cctype>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0))return 0;\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1)x = (mod!=-1)?(x * a) % mod:x*a;\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n\n//const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<std::vector<ll>> graph(n);\n  rep(i,0,n-1){\n    ll a,b;\n    std::cin>>a>>b;\n    a--;b--;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  std::vector<long double> dp(n);\n\n  auto dfs1=[&](auto f,ll now,ll par)->void{\n    dp[now]=0;\n    ll cnt=0;\n    for(auto e:graph[now]){\n      if(e==par)continue;\n      cnt++;\n      f(f,e,now);\n      dp[now]+=(dp[e]+1);\n    }\n\n    if(cnt!=0)dp[now]/=cnt;\n  };\n\n  dfs1(dfs1,0,-1);\n\n  std::vector<long double> ans(n);\n\n  auto dfs2=[&](auto f,ll now,ll par,long double d)->void{\n    ans[now]=d+1;\n    for(auto e:graph[now]){\n      if(e==par)continue;\n      ans[now]+=(dp[e]+1);\n    }\n\n    for(auto e:graph[now]){\n      if(e==par)continue;\n      long double val=ans[now];\n      val-=(dp[e]+1);\n      if(val)val/=(graph[now].size()-1);\n      f(f,e,now,val);\n    }\n    ans[now]/=graph[now].size();\n  };\n\n  dfs2(dfs2,0,-1,-1);\n\n  std::cout<<std::setprecision(10)<<std::fixed;\n  rep(i,0,n){\n    std::cout<<ans[i]<<\"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef pair<double,int> pdi;\n\n\nvector<int> G[150000];\ndouble val[150000];\ndouble ans[150000];\nint deg[150000];\n\npdi dfs(int cur, int prev){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return pdi(val[cur] = 0,0);\n    \n    int height=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        double res;\n        int h;\n        tie(res,h) = dfs(e,cur);\n        ret+=1+res;\n        height = max(1+h,height);\n    }\n    ret/=c;\n    return pdi(val[cur] = ret,height);\n}\n\n\ndouble dfs2(int cur, int prev, double d_par){\n    vector<pdi> v;\n    for(auto e:G[cur]){\n        if(e==prev)v.pb(pdi(d_par+1,e));\n        else v.pb(pdi(val[e]+1,e));\n    }\n    \n    double ave = 0;\n    rep(i,v.size())ave+=v[i].first;\n    ave/=deg[cur];\n    \n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        if(deg[cur]==1)dfs2(e,cur,0);\n        else dfs2(e,cur,(ave*deg[cur]-(val[e]+1))/(deg[cur]-1));\n    }\n    \n    return ans[cur] = ave;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    \n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        deg[u]++;\n        deg[v]++;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    \n    dfs(0,-1);\n    \n    dfs2(0,-1,0);\n    \n    rep(i,n){\n        printf(\"%.20lf\\n\",ans[i]);\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define pii Pi\n#define pll PL\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef tuple<int, int, int, int> t4;\ntypedef pair<ll, ll> PL;\ntypedef long double ldouble;\n\nvector <int> E[150050];\n\ndouble D[150050], P[150050];\n\nvoid pdfs(int x, int fa){\n\tD[x] = 0;\n\tint cnt = 0;\n\tfor(int e : E[x])if(e != fa){\n\t\tpdfs(e, x);\n\t\t++cnt; D[x] += D[e] + 1;\n\t}\n\tif(cnt > 0)D[x] /= cnt;\n}\n\ndouble ans[150050];\n\nvoid dfs(int x, int fa){\n\tdouble sum = 0;\n\tint cnt = 0;\n\tif(fa != -1)cnt++, sum += P[x] + 1;\n\tfor(int e : E[x])if(e != fa)sum += D[e] + 1, cnt++;\n\tfor(int e : E[x])if(e != fa){\n\t\tif(cnt == 1)P[e] = 0;\n\t\telse P[e] = (sum - D[e] - 1) / (cnt - 1);\n\t\tdfs(e, x);\n\t}\n\tans[x] = sum / cnt;\n}\n\nvoid solve(){\n\tint n; scanf(\"%d\", &n);\n\tif(n == 1){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\trep(i, n-1){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\tpdfs(1, -1);\n\tdfs(1, -1);\n\tfor(int i=1;i<=n;i++)printf(\"%.12f\\n\", ans[i]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\t//printf(\"Case #%d: \", tc);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nvector<int>G[150000];\nint d[150000];\n\ndouble dfs(int n, int dis, double p){\n  //  cout << n << \" \" << dis << \" \" << p << endl;\n  d[n] = dis;\n  double res = 0.0;\n  int cnt = 0;\n  for(int i=0;i<G[n].size();i++)\n    if(d[G[n][i]] == -1)\n      cnt += 1;\n  if(cnt){\n    for(int i=0;i<G[n].size();i++){\n      if(d[G[n][i]] == -1){\n\tres += dfs(G[n][i], dis+1, p/(double)cnt);\n      }\n    }\n  }else{\n    return dis*p;\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d\", &N);\n  int endpoint = 0;\n  for(int i=0;i<N-1;i++){\n    int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n\n  for(int i=0;i<N;i++){\n    if(G[i].size() == 1) endpoint = i;\n  }\n\n  if(N <= 1000){\n\n    for(int i=0;i<N;i++){\n      memset(d, -1, sizeof(d));          \n      printf(\"%.10f\\n\", dfs(i, 0, 1.0));\n    }\n    }else{\n    memset(d, -1, sizeof(d));\n    dfs(endpoint, 0, 1.0);\n    for(int i=0;i<N;i++){\n      if(d[i] == 0 || d[i] == N-1){\n\tprintf(\"%.10f\\n\", (double)N-1);\n      }else{\n\tprintf(\"%.10f\\n\", (double)(N-1)/2);\n      }\n    }\n}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint N;\nvector<int> G[202020];\n\ndouble per[202020];\n\nvoid dfs1(int v,int f = -1){\n  int cnt = 0;\n  for(int to : G[v]){\n    if(to == f) continue;\n    dfs1(to,v);\n    cnt++;\n    per[v] += per[to];\n  }\n  if(cnt != 0){\n    per[v] /= cnt;\n    per[v]++;\n  }\n}\n\ndouble ans[202020];\n\nvoid dfs2(int v,int f = -1,double f_per = 0){\n  int cnt = G[v].size();\n  double sum = 0;\n  for(int to : G[v]){\n    if(to == f){\n      sum += f_per;\n    }\n    else{\n      sum += per[to];\n    }\n  }\n  ans[v] = sum / cnt + 1;\n\n  for(int to : G[v]){\n    if(to == f) continue;\n    double t = sum - per[to];\n    if(cnt > 1) t = t / (cnt - 1) + 1;\n    dfs2(to,v,t);\n  }\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0;i < N - 1;i++){\n    int u,v;\n    cin >> u >> v;\n    u--;\n    v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(0);\n  dfs2(0);\n  cout << fixed << setprecision(10);\n  for(int i = 0;i < N;i++){\n    cout << ans[i] <<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n///////////////////////////\n\n#define N 150005\nvector<ll>v[N];\nll chi[N];\ndd pro[N];\ndd dfs(ll id,ll par){\n    pro[id]=0.0;\n    for(auto x:v[id]){\n        if(x==par)continue;\n        pro[id]+=dfs(x,id)+1.0;\n        chi[id]++;\n    }\n    if(chi[id]!=0)pro[id]=pro[id]/chi[id];\n    return pro[id];\n}\nbool dfs2(ll id,ll par,dd d_par){\n    if(par==-1){\n        //pro[id]=(pro[id]*chi[id]+d_par)/(chi[id]);\n        dd sum=pro[id]*chi[id];\n        for(auto x:v[id]){\n            dd res=0;\n            if(chi[id]-1>0)res=(sum-(pro[x]+1))/(chi[id]-1);\n            dfs2(x,id,res+1.0);\n        }\n        return 0;\n    }\n    dd sum=(pro[id]*chi[id]+d_par);\n    pro[id]=sum/(chi[id]+1);\n    for(auto x:v[id]){\n        if(x==par){\n            continue;\n        }else{\n            dd res=0;\n            if(chi[id]>0)res=(sum-(pro[x]+1))/(chi[id]);\n            dfs2(x,id,res+1.0);\n        }\n    }\n    return 0;\n}\n\nint main(){fastio\n    ll n;cin>>n;\n    rep(i,1,n-1){\n        ll a,b;cin>>a>>b;\n        v[a].pb(b);v[b].pb(a);\n    }\n    dfs(1,-1);\n    //rep(i,1,n)cout<<pro[i]<<endl;\n    dfs2(1,-1,0.0);\n    rep(i,1,n)cout<<setprecision(20)<<pro[i]<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint tu[150010], tv[150010];\nvector<int> G[150010];\n\nlong double dfs(int now, int pre, long double E, int dist){\n\tdouble ret = 0;\n\tint nextsize;\n\tif(pre == -1) nextsize = G[now].size();\n\telse nextsize = G[now].size() - 1;\n\tif(nextsize == 0){\n\t\treturn dist * E;\n\t}\n\tfor(auto u : G[now]){\n\t\tif(u == pre) continue;\n\t\tret += dfs(u, now, E / nextsize, dist + 1);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N - 1) cin >> tu[i] >> tv[i];\n\trep(i, N - 1) tu[i]--, tv[i]--;\n\trep(i, N - 1){\n\t\tG[tu[i]].pb(tv[i]);\n\t\tG[tv[i]].pb(tu[i]);\n\t}\n\t\n\tint one = 0, two = 0;\n\trep(i, N){\n\t\tif(G[i].size() == 1) one++;\n\t\telse if(G[i].size() == 2) two++;\n\t}\n\t// printf(\"%d %d\\n\", one, two);\n\tif(one == 2 && two == N - 2){\n\t\t// printf(\"k\\n\");\n\t\trep(i, N){\n\t\t\tif(G[i].size() == 1){\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)(N - 1));\n\t\t\t}else{\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)((N - 1) / 2));\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\trep(i, N){\n\t\tlong double ret = dfs(i, - 1, 1.0, 0);\n\t\tprintf(\"%.9Lf\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    rep(i, N-1) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    cout << fixed << setprecision(10);\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nint edc[150010];\nvector<int> lis[150010];\n\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (edc[nod] == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (edc[nod] - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        cin >> edge[i][0] >> edge[i][1];\n        --edge[i][0];\n        --edge[i][1];\n        ++edc[edge[i][0]];\n        ++edc[edge[i][1]];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        double ans = 0;\n        for (int item : lis[i])\n        {\n            ans += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        printf(\"%.9f\\n\", ans / edc[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = std::int_fast64_t;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nusing value = long double;\nconst value id = 0.;\nvalue marge(value a, value b) { return a + b; }\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<int> a(n - 1), b(n - 1);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\n\t\tg[a[i]].push_back(i);\n\t\tg[b[i]].push_back(i);\n\t}\n\n\tstd::vector<std::map<int, value>> dp(n);\n\tauto solve = [&](auto&& solve, int v, int par, bool flag) -> value {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\t\t\n\t\tvalue res = id;\n\t\tconst int deg = g[v].size() - (par != -1);\n\t\tif(par == -1 or flag) {\n\t\t\tstd::vector<value> ret;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tint id = g[v][i];\n\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\tif(to == par) continue;\n\t\t\t\t\n\t\t\t\tret.push_back(solve(solve, to, v, flag) + 1.);\n\t\t\t}\n\t\t\t\n\t\t\tstd::vector<value> R(ret.size() + 1, id);\n\t\t\tfor(int i = (int)R.size() - 1; i > 0; i--) R[i - 1] = marge(R[i], ret[i - 1]);\n\t\t\tif(par == -1) {\n\t\t\t\tvalue L = id;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tint id = g[v][i];\n\t\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\t\t\n\t\t\t\t\tlong double tmp = marge(L, R[i + 1]);\n\t\t\t\t\tif(deg - 1) tmp = tmp / (deg - 1);\n\t\t\t\t\tdp[v][to] = tmp;\n\t\t\t\t\tL = marge(L, ret[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(deg) res = R[0] / deg;\n\t\t} else {\n\t\t\tsolve(solve, v, -1, flag);\n\n\t\t\treturn solve(solve, v, par, flag);\n\t\t}\n\n\t\treturn dp[v][par] = res;\n\t};\n\tsolve(solve, 0, -1, true);\n\n\tfor(int i = 0; i < n; i++) printf(\"%.12Lf\\n\", solve(solve, i, -1, false));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\nvector<vector<R>> dp;\nvector<vi> graph;\n\nR dfs(int v, int pv){\n    int pi = -1;\n    rep(i, graph[v].size()){\n        if(graph[v][i] == pv) pi = i;\n    }\n\n    R& cur = dp[v][pi + 1];\n    if(cur > -EPS) return cur;\n    cur = (R)0;\n\n    int cnt = 0;\n    rep(i, graph[v].size()){\n        int nv = graph[v][i];\n        if(nv == pv) continue;\n        cur += dfs(nv, v);\n        cnt++;\n    }\n    if(cnt != 0){\n        cur /= cnt;\n    }\n    if(pv != -1) cur++;\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    dp = vector<vector<R>>(n);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n    rep(v, n){\n        dp[v] = vector<R>(graph[v].size() + 1, -1);\n    }\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dfs(i, -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[301000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i].first;\n\t\tif (v == prev) continue;\n\t\t\n\t\tcnt++;\n\t\tres += dfs(v, g[u][i].second, u) + 1;\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = res / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i) + 1;\n\t\t\n\t\tans /= g[i].size();\n\t\t\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<30)\n#define INFLL (1ll<<60)\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n#define MOD (1000000007ll)\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\tb += MOD;\n\ta += b;\n\ta %= MOD;\n}\n\nint d[151515],p[151515],c[151515];\ndouble dp[151515],memo[151515];\nbool done[151515];\nvector<int> g[151515];\n\ndouble treedp(int v, int pr){\n\tint i;\n\tif(d[v]>=0){\n\t\treturn dp[v];\n\t}\n\td[v] = d[pr]+1;\n\tp[v] = pr;\n\tc[v] = 0;\n\tdp[v] = 0.0;\n\tfor(i=(g[v].l_ength()-1); i>=0; --i){\n\t\tif(g[v][i] == pr){\n\t\t\tcontinue;\n\t\t}\n\t\tdp[v] += treedp(g[v][i],v);\n\t\t++c[v];\n\t}\n\tif(!c[v]){\n\t\treturn dp[v];\n\t}\n\tdp[v] /= ((double)(c[v]));\n\tdp[v] += 1.0;\n\treturn dp[v];\n}\n\ndouble solve(int v){\n\tif(done[v]){\n\t\treturn memo[v];\n\t}\n\tdone[v] = true;\n\tif(p[v]==0){\n\t\tif(c[0]>1){\n\t\t\tmemo[v] = (treedp(0,p[0])-1.0)*((double)(c[0]));\n\t\t\tmemo[v] -= treedp(v,0);\n\t\t\tmemo[v] /= ((double)(c[0]-1));\n\t\t\tmemo[v] += 1.0;\n\t\t}else{\n\t\t\tmemo[v] = 0.0;\n\t\t}\n\t\treturn memo[v];\n\t}\n\tmemo[v] = (treedp(p[v],p[p[v]])-1.0)*((double)(c[p[v]]));\n\tmemo[v] -= (treedp(v,p[v])+1.0);\n\tmemo[v] += (solve(p[v])+1.0);\n\tmemo[v] /= ((double)(c[p[v]]));\n\tmemo[v] += 1.0;\n\treturn memo[v];\n}\n\nint main(void){\n\tint n,i,v,u;\n\tfill(d,d+151515,-1);\n\tfill(done,done+151515,false);\n\tcin >> n;\n\tfor(i=1; i<n; ++i){\n\t\tcin >> v >> u;\n\t\t--v; --u;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tprintf(\"%.15lf\\n\",treedp(0,n));\n\tfor(i=1; i<n; ++i){\n\t\tprintf(\"%.15lf\\n\",(treedp(i,p[i])*((double)(g[i].l_ength()-1))+solve(i)+1.0)/((double)(g[i].l_ength())));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<long double,long double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<long double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<61;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvi p,b;\nvvi g;\nvd dp,a;\n\nvoid dfs(int v,int u){\n\tp[v]=u;\n\tint t=0;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint w=g[v][i];\n\t\tif(p[w]==-2){\n\t\t\tdfs(w,v);\n\t\t\tdp[v]+=dp[w];\n\t\t\tt++;\n\t\t}\n\t}\n\tif(t) dp[v]=dp[v]/t+1;\n\tb[v]=t;\n}\n\nvoid DFS(int v,double d){\n\ta[v]=(dp[v]*b[v]+d+1)/(b[v]+1);\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(u!=p[v]) DFS(u,(d-dp[u])/b[v]+dp[v]);\n\t}\n}\n\nint main(){\n\tcin>>n;\n\tp=b=vi(n,-2);\n\tg=vvi(n);\n\tdp=a=vd(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\ta[0]=dp[0];\n\tfor(int i=0;i<g[0].size();i++){\n\t\tint u=g[0][i];\n\t\tDFS(u,(b[0]==1?0:(dp[0]*b[0]-dp[u]-1)/(b[0]-1)));\n\t}\n\tfor(int i=0;i<n;i++) cout<<syosu(9)<<a[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\nstruct edge{ int to, cost; };\n\nsigned main(){\n\n  int n; cin >> n;\n  vector<vector<int>> G(n);\n  for(int i = 0; i < n-1; i++){\n    int a, b; cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  vector<double> dp(n, 0);\n  auto dfs = [&](auto&& dfs, int u, int par)->void{\n    int child = (par == -1 ? G[u].size() : G[u].size()-1);\n    for(int v : G[u]){\n      if(v == par) continue;\n      dfs(dfs, v, u);\n      dp[u] += (dp[v] + 1) / child;\n    }\n  };\n  dfs(dfs, 0, -1);\n\n  vector<double> ans(n);\n  auto dfs2 = [&](auto&& dfs2, int u, int par, double d_par)->void{\n    int child = G[u].size();\n    if(par == -1){\n      ans[u] = dp[u];\n    }else{\n      ans[u] = (dp[u] * (child-1) + d_par) / child;\n    }\n    for(int v : G[u]){\n      if(v == par) continue;\n      d_par = (ans[u] * G[u].size() -  (dp[v]+1)) / max(1LL, child-1) + 1;\n      dfs2(dfs2, v, u, d_par);\n    }\n  };\n  dfs2(dfs2, 0, -1, 0);\n  for(int i = 0; i < n; i++){\n    printf(\"%.9f\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_map>\n#define int long long\nusing namespace std;\n\nint n;\nvector<int> et[150000];\nunordered_map<int, double> dp;\n\ndouble dfs(int p, int v)\n{\n\tint childNum = et[v].size() - (p != -1);\n\tif (childNum == 0) return 0;\n\tif (dp.find(p * n + v) != dp.end()) return dp[p * n + v];\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tret += dfs(v, et[v][i]);\n\t}\n\tret /= childNum;\n\treturn dp[p * n + v] = ret + 1;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tet[a].push_back(b);\n\t\tet[b].push_back(a);\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%.14f\\n\", dfs(-1, i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n\nconst int maxn = 1E5 + 5E4 + 50;\ntypedef double DB;\n\nint n,son[maxn];\nDB f[maxn],g[maxn];\n\nvector <int> v[maxn];\n\nvoid Dfs1(int x,int from)\n{\n\tDB sum = 0;\n\tfor (int i = 0; i < v[x].size(); i++)\n\t{\n\t\tint to = v[x][i];\n\t\tif (to == from) continue;\n\t\tDfs1(to,x); sum += f[to]; ++son[x];\n\t}\n\tif (!son[x]) return;\n\tf[x] = 1.00 + sum / (DB)(son[x]);\n}\n\nvoid Dfs2(int x,int from,DB now)\n{\n\tif (x == 1) g[x] = f[x];\n\telse if (son[x])\n\t{\n\t\tDB t = son[x] + 1;\n\t\tg[x] = f[x] / t * (DB)(son[x]) + (1.00 + now) / t;\n\t}\n\telse g[x] = now + 1.00;\n\tfor (int i = 0; i < v[x].size(); i++)\n\t{\n\t\tint to = v[x][i];\n\t\tif (to == from) continue; DB Nex = f[x];\n\t\tif (x == 1)\n\t\t{\n\t\t\tif (son[x] == 1) Nex = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tNex -= (1.00 + f[to]) / (DB)(son[x]);\n\t\t\t\tNex = Nex / (DB)(son[x] - 1) * (DB)(son[x]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNex += (1.00 + now) / (DB)(son[x]);\n\t\t\tNex -= (1.00 + f[to]) / (DB)(son[x]);\n\t\t}\n\t\tDfs2(to,x,Nex);\n\t}\n}\n\nint main()\n{\n\t#ifdef DMC\n\t\tfreopen(\"DMC.txt\",\"r\",stdin);\n\t#endif\n\t\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tv[x].push_back(y); v[y].push_back(x);\n\t}\n\tDfs1(1,0); Dfs2(1,0,0);\n\tfor (int i = 1; i <= n; i++) printf(\"%.10lf\\n\",g[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, float>dp[150000];\n\nfloat dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tfloat ans = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += dfs(u, v) + 1;\n\t}\n\tif (ans == 0)return dp[v][p] = 0;\n\treturn dp[v][p] = ans / (float)(E[v].size() - (p == -1 ? 0 : 1));\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12f\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t}\n\n\tcout << n - 1 << endl;\n\tfor (int i = 2; i <= n - 1; i++){\n\t\tfloat ans = n - 1;\n\t\tcout << ans/2 << endl;\n\t}\n\tcout << n - 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 2e5 + 5;\nint n;\nint a , b;\nvector < int > v[N];\ndouble sub[N];\nvoid dfs(int node , int parent){\n\tsub[node] = 0;\n\tint child = 0;\n\tfor(int next : v[node]){\n\t\tif(next != parent){\n\t\t\tdfs(next , node);\n\t\t\t++child;\n\t\t\tsub[node] += sub[next] + 1;\n\t\t}\n\t}\n\tif(child){\n\t\tsub[node] /= child;\n\t}\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i < n ; ++i){\n\t\tscanf(\"%d %d\" , &a , &b);\n\t\tv[a].emplace_back(b);\n\t\tv[b].emplace_back(a);\n\t}\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\tdfs(i , 0);\n\t\tprintf(\"%.9lf\\n\" , sub[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr ld PI = acos(-1.0);\nconstexpr ld EPS = 1e-11;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ntemplate <typename T>\nstruct ReRooting\n{\n  using F = function<T(T, int)>;\n  using F2 = function<T(T, T)>;\n  int V;\n  vector<vector<int>> E;\n  vector<vector<T>> dp;\n  //dp_v = g(merge(f(dp_c1,c1), f(dp_c2,c2), ..., f(dp_ck,ck)) , v)\n  F f, g;\n  F2 merge;\n  T mi; //identity of merge\n\n  ReRooting() {}\n  ReRooting(int V_, F f_, F2 merge_, T mi_, F g_)\n  {\n    init(V_, f_, merge_, mi_, g_);\n  }\n\n  void init(int V_, F f_, F2 merge_, T mi_, F g_)\n  {\n    V = V_, f = f_, merge = merge_, mi = mi_, g = g_;\n    E.resize(V);\n    dp.resize(V);\n  }\n\n  void add_E(int a, int b)\n  {\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  T dfs1(int p, int v)\n  {\n    T res = mi;\n    for (int i = 0; i < E[v].size(); ++i)\n    {\n      if (E[v][i] == p)\n        continue;\n      dp[v][i] = dfs1(v, E[v][i]);\n      res = merge(res, f(dp[v][i], E[v][i]));\n    }\n    return g(res, v);\n  }\n\n  void dfs2(int p, int v, T from_par)\n  {\n    for (int i = 0; i < E[v].size(); ++i)\n    {\n      if (E[v][i] == p)\n      {\n        dp[v][i] = from_par;\n        break;\n      }\n    }\n\n    vector<T> pL(E[v].size() + 1), pR(E[v].size() + 1);\n    pL[0] = mi;\n    for (int i = 0; i < E[v].size(); ++i)\n      pL[i + 1] = merge(pL[i], f(dp[v][i], E[v][i]));\n    pR[E[v].size()] = mi;\n    for (int i = E[v].size(); i > 0; --i)\n      pR[i - 1] = merge(pR[i], f(dp[v][i - 1], E[v][i - 1]));\n\n    for (int i = 0; i < E[v].size(); ++i)\n    {\n      if (E[v][i] == p)\n        continue;\n      T val = merge(pL[i], pR[i + 1]);\n      dfs2(v, E[v][i], g(val, v));\n    }\n  }\n\n  void calc(int root = 0)\n  {\n    for (int i = 0; i < V; ++i)\n      dp[i].resize(E[i].size());\n    dfs1(-1, root);\n    dfs2(-1, root, mi);\n  }\n\n  T solve(int v)\n  {\n    T ans = mi;\n    for (int i = 0; i < E[v].size(); ++i)\n    {\n      ans = merge(ans, f(dp[v][i], E[v][i]));\n    }\n    return g(ans, v);\n  }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n\n  int n;\n  cin >> n;\n  ReRooting<ld> re;\n  auto f = [](ld a, int v) {\n    return a;\n  };\n  auto merge = [](ld a, ld b) {\n    return a + b;\n  };\n  auto g = [&](ld a, int v) {\n    if (re.E[v].size() == 1)\n      return ld(0.0);\n    else\n      return a / (ld)(re.E[v].size() - 1) + ld(1.0);\n  };\n  re.init(n, f, merge, 0.0, g);\n  rep(i, n - 1)\n  {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    re.add_E(a, b);\n  }\n  re.calc();\n  rep(i, n)\n  {\n    ld sum = 0;\n    ld c_cnt = re.E[i].size();\n    rep(j, re.E[i].size()) sum += re.dp[i][j];\n    sum /= c_cnt;\n    sum += 1.0;\n    cout << sum << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\nvector<int> G[1<<18];\ndouble dp [1<<18];\ndouble dp2 [1<<18];\n\ndouble dfs(int u,int p) {\n    int cnt = 0;\n    double ans = 0;\n    for(int i = 0; i < G[u].size(); i ++) {\n        if (G[u][i] == p) continue;\n        ans += dfs(G[u][i], u) + 1;\n        cnt ++;\n    }\n    return dp[u] = cnt ? ans / cnt : 1;\n}\n\nvoid dfs2(int u, int p, double a) {\n    double ans=0;\n    for(int i=0;i<G[u].size();i++)\n    {\n        if(G[u][i]==p)ans+=a;\n        else ans+=dp[G[u][i]];\n    }\n    dp2[u] = ans/G[u].size();\n    for(int i=0;i<G[u].size();i++)\n    {\n        if(G[u][i]==p)continue;\n        dfs2(G[u][i],u, 1+(ans-dp[G[u][i]])/max(1,(int)G[u].size()-1));\n    }\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    int u,v;\n    for(int i = 1; i < n; i ++) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    dfs2(1, 0, 0);\n    for(int i = 1; i <= n; i ++) {\n        cout << setprecision(12) << dp2[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\nvector<R> dp1, dp2;\nvector<vi> graph;\n\nR dfs1(int v, int pv){\n    R& cur = dp1[v];\n    cur = (R)0;\n\n    int cnt = 0;\n    for(auto& nv : graph[v]){\n        if(nv == pv) continue;\n\n        cur += (dfs1(nv, v) + 1);\n        cnt++;\n    }\n    if(cnt > 0) cur /= (graph[v].size() - 1);\n\n    return cur;\n}\n\nR dfs2(int v, int pv, R par_val){\n    R& cur = dp2[v];\n    cur = par_val + (pv != -1 ? 1:0);\n\n    int cnt = (pv != -1 ? 1:0);\n    for(auto& nv : graph[v]){\n        if(nv == pv) continue;\n        cur += (dp1[nv] + 1);\n        cnt++;\n    }\n    cur /= cnt;\n\n    for(auto& nv : graph[v]){\n        if(nv == pv) continue;\n        R nval = cur * cnt;\n        nval -= (dp1[nv] + 1);\n        if(cnt - 1 > 0) nval /= (cnt - 1);\n        dfs2(nv, v, nval);\n    }\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    if(n == 1){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    dp1 = dp2 = vector<R>(n, -1);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, -1, 0.0);\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dp2[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n;\nvector<int> g[150001];\nbool used[150001];\ndouble dp[150001];\nint d[150001];\nint s;\nvoid dfs(int x){\n    used[x]=1;\n    int ct=g[x].size();\n    if(x!=s) ct--;\n    if(x==s || ct>0) dp[x]=1; \n    for(auto y:g[x]){\n        if(!used[y]){\n            d[y]=d[x]+1;\n            dfs(y);\n            dp[x]+=dp[y]/(double)ct;\n        }\n    }\n}\ndouble dp2[150001];\nvoid dfs2(int x){\n    used[x]=1;\n    double sum=0;\n    int ct=g[x].size()-1;\n    if(x==s){\n        for(auto y:g[x]){\n            dp2[y]=1;\n            dfs2(y);\n        }\n        return;\n    }\n    for(auto y:g[x]){\n        if(used[y]) continue;\n        sum+=dp[y]/(double)ct;\n    }\n    for(auto y:g[x]){\n        if(used[y]) continue;\n        dp2[y]=1+dp2[x]/(double)ct;\n        dp2[y]+=(sum-dp[y]/(double)ct);\n        dp2[y]+=(1-1/(double)ct);\n        dfs2(y);\n    }\n}\nint main()\n{\n    cin>>n;\n  if(n==1){\n    cout<<0<<endl; return 0;\n  }\n    for(int i=0; i<n-1; i++){\n        int u, v; cin>>u>>v;  u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    for(int i=0; i<n; i++){\n        if(g[i].size()==1){\n            s=i; break;\n        }\n    }\n    dfs(s);\n    fill(used, used+n, 0);\n    dfs2(s);\n    double ans[150001];\n    for(int i=0; i<n; i++){\n        if(i==s) ans[i]=dp[i];\n        else{\n            int ct=g[i].size();\n            ans[i]=dp[i]/(double)ct*(double)(ct-1);\n            ans[i]+=dp2[i]/(double)ct;\n        }\n    }\n    for(int i=0; i<n; i++){\n        printf(\"%.7lf\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n;\n  R n;\n  vector<int> v[n];\n  rep(i,n-1) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    v[x].pb(y);\n    v[y].pb(x);\n  }\n  if(n<=1000) {\n    rep(i,n) {\n      int d[n];\n      fill(d,d+n,MAX);\n      double p[n];\n      mem(p);\n      d[i]=0;\n      p[i]=1;\n      queue<int> que;\n      que.push(i);\n      double ans=0;\n      while(!que.empty()) {\n        int x=que.front();que.pop();\n        bool f=1;\n        rep(j,v[x].size()) {\n          int y=v[x][j];\n          if(d[y]<=d[x]+1) continue;\n          f=0;\n          d[y]=d[x]+1;\n          p[y]+=p[x]/(v[x].size()-(x==i?0:1));\n          que.push(y);\n        }\n        if(f) ans+=d[x]*p[x];\n      }\n      pd(ans);\n    }\n  } else {\n    rep(i,n) {\n      double x;\n      if(v[i].size()==1) x=n-1;\n      else x=(double)(n-1)/2;\n      pd(x);\n    }\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nmap< pair<int,int>,double > memo;\nint vis [150001];\ndouble node [150001];\nvector<int> edge [150001];\n\ndouble rec(int prev,int curr)\n{\n\tif(memo.count(make_pair(prev,curr))) return memo [make_pair(prev,curr)];\n\tdouble res = 0.0;\n\tif(vis [curr] == 0){\n\t\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\t\tres += rec(curr,it) + 1.0;\n\t\t}\n\t\tif(edge [curr].size() > 1){\n\t\t\tres /= edge [curr].size() - 1;\n\t\t}\n\t}\n\telse{\n\t\tif(vis [curr] == 1){\n\t\t\tfor(const auto& it : edge [curr]){\n\t\t\t\tnode [curr] += rec(curr,it) + 1.0;\n\t\t\t}\n\t\t}\n\t\tres = node [curr] - (rec(curr,prev) + 1.0);\n\t\tif(edge [curr].size() > 1){\n\t\t\tres /= edge [curr].size() - 1;\n\t\t}\n\t}\n\tvis [curr]++;\n\treturn memo [make_pair(prev,curr)] = res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tFOR(i,1,N + 1){\n\t\tdouble ans = 0.0;\n\t\tfor(const auto& it : edge [i]){\n\t\t\tans += rec(i,it) + 1.0;\n\t\t}\n\t\tans /= edge [i].size();\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[100000];\nvector<double> dp[100000];\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  for (int i=0; i<G[x].size(); i++) {\n    if (i == p) continue;\n    int t = G[x][i];\n    r += dfs(t, find(all(G[t]), x)-G[t].begin())/c;\n  }\n  return dp[x][p] = r+1;\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) {\n    dp[i].resize(G[i].size()+1, -1);\n  }\n  rep(i, N) {\n    cout << fixed << setprecision(15) << dfs(i, G[i].size()) << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define INF_LL (ll)1e18\n#define INF (int)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\nusing ll = long long;\nusing PII = pair<int, int>;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nclass LazySegTree{\nprivate:\n\tint n;\n\tvector<ll> node, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tLazySegTree(vector<ll> v){\n\t\tint sz = v.size();\n\t\tn = 1; while(n < sz) n *= 2;\n\t\tnode.resize(2*n-1, 0);\n\t\tlazy.resize(2*n-1, 0);\n\t\tlazyFlag.resize(2*n-1, false);\n\t\tREP(i, sz) node[i+n-1] = v[i];\n\t\tfor(int i = n-2;i >= 0;i--) node[i] = node[2*i+1]+node[2*i+2];\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazyFlag[k]){\n\t\t\tnode[k] += lazy[k] * (r-l);\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] += lazy[k];\n\t\t\t\tlazy[2*k+2] += lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\n\tvoid add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return;\n\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tadd(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\tadd(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\tnode[k] = node[k*2+1] + node[k*2+2];\n\t\t}\n\t}\n\n\tll query(int a, int b, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\n\t\tif(b <= l || r <= a) return 0;\n\t\tif(a <= l && r <= b) return node[k];\n\n\t\treturn query(a, b, k*2+1, l, (l+r)/2) + query(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nclass Bucket{\nprivate:\n\tint n, bs, bn; // 要素数、バケットサイズ、バケットの数\n\tvector<ll> data;\n\tvector<ll> bucket, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tBucket(vector<ll> v, int sz){\n\t\tdata = v;\n\t\tn = v.size();\n\t\tbs = sz;\n\t\tbn = (n + bs - 1) / bs;\n\t\tdata.resize(bn*bs, INF_LL);\n\t\tbucket.assign(bn, INF_LL);\n\t\tlazy.assign(bn, 0);\n\t\tlazyFlag.assign(bn, 0);\n\t\tREP(i, bn){\n\t\t\tll minx = INF_LL;\n\t\t\tREP(j, bs){\n\t\t\t\tchmin(minx, data[i*bs+j]);\n\t\t\t}\n\t\t\tbucket[i] = minx;\n\t\t}\n\t}\n\n\tvoid eval(int k){\n\t\tif(lazyFlag[k]){\n\t\t\tlazyFlag[k] = false;\n\t\t\tFOR(i, bs*k, bs*(k+1)){\n\t\t\t\tdata[i] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tlazyFlag[k] = true;\n\t\t\t\tbucket[k] = x;\n\t\t\t\tlazy[k] = x;\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t\tbucket[k] = INF_LL;\n\t\t\t\tFOR(i, l, r){\n\t\t\t\t\tchmin(bucket[k], data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll query(int s, int t){\n\t\tll res = INF_LL;\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tchmin(res, bucket[k]);\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tchmin(res, data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n};\n\nvector<int> G[150150];\ndouble dp[150150] = {};\n\ndouble dfs(int v, int p){\n\tdouble res = 0;\n\tint f = 0;\n\tif(p != -1) f = 1;\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tres += dfs(G[v][i], v)/(G[v].size()-f);\n\t}\n\tdp[v] = res;\n\treturn res+1;\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tREP(i, N-1){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0, -1);\n\tqueue<PII> q;\n\tREP(i, G[0].size()){\n\t\tq.push({G[0][i], 0});\n\t}\n\n\twhile(q.size()){\n\t\tint v= q.front().first, p = q.front().second; q.pop();\n\t\tint div = G[p].size()-1;\n\t\tif(div == 0) div = 1;\n\t\tdouble val = (dp[p]*(G[p].size())-dp[v]-1)/div+1;\n\t\tdp[v] = (dp[v]*(G[v].size()-1)+val)/G[v].size();\n\t\tREP(i, G[v].size()){\n\t\t\tif(G[v][i] == p) continue;\n\t\t\tq.push({G[v][i], v});\n\t\t}\n\t}\n\tREP(i, N){\n\t\tcout << fixed << setprecision(10) << dp[i] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n*/\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);i++)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;i--)\n#define FOR(i,s,n) for(int i = s;i < (int)n;i++)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;i--)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void in(T&t){cin>>t;}\ntemplate<class T,class... Ts>inline void in(T&t,Ts&...ts){cin>>t;in(ts...);}\ntemplate<class T>inline void out(T t){cout<<t<<\"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout<<t<<\" \";out(ts...);}\ntemplate<typename T=int>vector<T>mv(size_t a){return vector<T>(a);}\ntemplate<typename T=int,typename... Ts>auto mv(size_t a,Ts... ts){return vector<decltype(mv<T>(ts...))>(a,mv<T>(ts...));}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type fill(T&t,const V&v){t=v;}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type fill(T&t,const V&v){for(auto &e:t)fill(e,v);}\nconstexpr long long INF = 1e18;\n\ntemplate<int MOD> struct Fp {\n\tlong long val;\n\tconstexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n\t\tif (val < 0) val += MOD;\n\t}\n\tconstexpr int getmod() { return MOD; }\n\tconstexpr Fp operator - () const noexcept {\n\t\treturn val ? MOD - val : 0;\n\t}\n\tconstexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n\tconstexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n\tconstexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n\tconstexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n\tconstexpr Fp& operator += (const Fp& r) noexcept {\n\t\tval += r.val;\n\t\tif (val >= MOD) val -= MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator -= (const Fp& r) noexcept {\n\t\tval -= r.val;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator *= (const Fp& r) noexcept {\n\t\tval = val * r.val % MOD;\n\t\treturn *this;\n\t}\n\tconstexpr Fp& operator /= (const Fp& r) noexcept {\n\t\tlong long a = r.val, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator == (const Fp& r) const noexcept {\n\t\treturn this->val == r.val;\n\t}\n\tconstexpr bool operator != (const Fp& r) const noexcept {\n\t\treturn this->val != r.val;\n\t}\n\tfriend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n\t\treturn os << x.val;\n\t}\n\tfriend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n\t\tif (n == 0) return 1;\n\t\tauto t = modpow(a, n / 2);\n\t\tt = t * t;\n\t\tif (n & 1) t = t * a;\n\t\treturn t;\n\t}\n};\n \n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n\tvector<T> fact_, inv_, finv_;\n\tconstexpr BiCoef() {}\n\tconstexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n\t\tinit(n);\n\t}\n\tconstexpr void init(int n) noexcept {\n\t\tfact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n\t\tint MOD = fact_[0].getmod();\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tfact_[i] = fact_[i-1] * i;\n\t\t\tinv_[i] = -inv_[MOD%i] * (MOD/i);\n\t\t\tfinv_[i] = finv_[i-1] * inv_[i];\n\t\t}\n\t}\n\tconstexpr T com(int n, int k) const noexcept {\n\t\tif (n < k || n < 0 || k < 0) return 0;\n\t\treturn fact_[n] * finv_[k] * finv_[n-k];\n\t}\n\tconstexpr T fact(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn fact_[n];\n\t}\n\tconstexpr T inv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn inv_[n];\n\t}\n\tconstexpr T finv(int n) const noexcept {\n\t\tif (n < 0) return 0;\n\t\treturn finv_[n];\n\t}\n};\n \n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n//using mint = Fp<MOD>;\n//BiCoef<mint> bc;\n// bc.init(500050);\n#pragma endregion\n\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n\nsigned main(){\n\tint N;\n\tin(N);\n\tvector<vector<int>>g(N);\n\tREP(i,N-1){\n\t\tint a,b;\n\t\tin(a,b);\n\t\ta--;b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\tauto dp = mv<double>(N);\n\tauto dfs = [&](auto&&f,int now,int par)->double{\n\t\tdouble ret = 0.0;\n\t\tint child = 0;\n\t\tREP(i,g[now].size()){\n\t\t\tint e = g[now][i];\n\t\t\tif(e == par)continue;\n\t\t\tret += f(f,e,now);\n\t\t\t++child;\n\t\t}\n\t\tif(child == 0)return 0;\n\t\treturn dp[now] = ret / child + 1.0;\n\t};\n\tdfs(dfs,0,-1);\n\tauto dfs2 = [&](auto&&f,int now,int par,double parData)->void{\n\t\tint nowSize = g[now].size();\n\t\tdouble ret = 0.0;\n\t\tint child = 0;\n\t\tREP(i,nowSize){\n\t\t\tint e = g[now][i];\n\t\t\tif(e == par)ret += parData;\n\t\t\telse ret += dp[e];\n\t\t\t++child;\n\t\t}\n\t\tdp[now] = ret / nowSize + 1.;\n\t\tREP(i,nowSize){\n\t\t\tint e = g[now][i];\n\t\t\tif(e == par)continue;\n\t\t\tif(child == 1){\n\t\t\t\tf(f,e,now,0.0);\n\t\t\t}else{\n\t\t\t\tf(f,e,now,(ret-dp[e])/(nowSize-1)+1.);\n\t\t\t}\n\t\t}\n\t};\n\tdfs2(dfs2,0,-1,0.0);\n\tREP(i,N)printf(\"%.20f\\n\",dp[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i].first;\n\t\tif (v == prev) continue;\n\t\t\n\t\tcnt++;\n\t\tres += dfs(v, g[u][i].second, u) + 1;\n\t}\n\t\n\tif (cnt == 0) return 0.0;\n\treturn res / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i) + 1;\n\t\t\n\t\tans /= g[i].size();\n\t\t\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define eb emplace_back\n#define sz(s) ((int) s.size ())\n#define all(s) (s.begin (), s.end ())\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = (int) 2e5 + 5;\nconst int mod = (int) 1e9 + 7;\n\nvector<double> pf[N], sf[N];\nvector<int> g[N];\ndouble d[N];\nint n;\n\nvoid dfs (int v, int p = -1) {\n        d[v] = 0;\n        for (int to : g[v]) {\n                if (to != p) {\n                        dfs (to, v);\n                        d[v] += d[to];\n                }\n        }\n        if (p == -1) {\n                d[v] = d[v] / sz (g[v]) + 1;\n        } else if (sz (g[v]) > 1) {\n                d[v] = d[v] / (sz (g[v]) - 1) + 1;\n        }\n}\n\n//void sdfs (int v, int p = -1, double u = 0) {\n//        ans[v] +=\n//        for (int )\n//}\n\ninline void solve () {\n        scanf (\"%d\", &n);\n        for (int i = 1; i < n; i++) {\n                int x, y;\n                scanf (\"%d%d\", &x, &y);\n                g[x].emplace_back (y);\n                g[y].emplace_back (x);\n        }\n        for (int i = 1; i <= n; i++) {\n                dfs (i);\n                printf (\"%.6f\\n\", d[i]);\n        }\n}\n\nint tests = 1;\n\nint main () {\n//        freopen (\".in\", \"r\", stdin);\n//        freopen (\".out\", \"w\", stdout);\n//        scanf (\"%d\", &tests);\n        while (tests--) {\n                solve ();\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<b)\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nvector<int> e[160000];\nint main(){\n\tint N;\n\tcin>>N;\n\n\tint a,b;\n\tREP(i,0,N-1) {\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tint now[2];\n\ta=0;\n\tREP(i,0,N){\n\t\tif(e[i].size()<2) {\n\t\t\tnow[a]=i;\n\t\t\ta++;\n\t\t}if(a==2) break;\n\t}\n\tdouble ans[160000];\n\tans[now[0]]=ans[now[1]]=(double)N-1;\n\tbool f[160000];\n\tREP(i,0,N) f[i]=false;\n\tf[now[0]]=f[now[1]]=true;\n\tREP(i,1,(N+1)/2){\n\t\tbool flag1=false,flag2=false;\n\t\tREP(j,0,2){\n\t\t\tif(!f[e[now[0]][j]]&&!flag1)\tnow[0]=e[now[0]][j],flag1=true;\n\t\t\tif(!f[e[now[1]][j]]&&!flag2)\tnow[1]=e[now[1]][j],flag2=true;\n\t\t}\n\t\tans[now[0]]=ans[now[1]]=(N-1-i)/2.0+i/2.0;\n\t\tf[now[0]]=f[now[1]]=true;\n\t}\n\tREP(i,0,N) printf(\"%0.7lf\\n\",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    if(dp2[a]>0)return ;\n    if(a==0)return ;\n    dfs2(par[a]);\n    int b=par[a];\n    ld p=v[b].size();\n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    cout<<\"W\"<<endl;\n  \treturn 0;\n    for(auto x:u){\n        for(int i=0;i<n;i++)ch[i]=0;\n        ch[x]=1;\n        dfs2(x);\n    }\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint F[150000];\nvector<int> G[150000], B[150000];\nvector<double> dp[150000];\n\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  for (int i=0; i<G[x].size(); i++) {\n    if (i == p) continue;\n    int t = G[x][i];\n    r += dfs(t, lower_bound(all(G[t]), x)-G[t].begin())/c;\n  }\n  return dp[x][p] = r+1;\n}\n\ndouble dfs2(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  if (F[x] == -1) {\n    for (int i=0; i<G[x].size(); i++) {\n      if (i == p) continue;\n      r += dfs2(G[x][i], B[x][i]);\n    }\n    dp[x][p] = (r/c)+1;\n    F[x] = r;\n    if (p < G[x].size()) F[x] += dfs2(G[x][p], B[x][p]);\n    return dp[x][p];\n  }\n  else {\n    r = F[x];\n    if (p < G[x].size()) r -= dfs2(G[x][p], B[x][p]);\n  }\n  return dp[x][p] = (r/c)+1;\n}\n\n\nsigned main() {\n  scanf(\"%d\", &N);\n  rep(i, N-1) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  bool f = false;\n  rep(x, N) {\n    F[x] = -1;\n    sort(all(G[x]));\n    B[x].resize(G[x].size());\n    dp[x].resize(G[x].size()+1, -1);\n    if (G[x].size() > 1000) f = true;\n  }\n\n  rep(x, N) {\n    for (int i=0; i<G[x].size(); i++) {\n      int t = G[x][i];\n      B[x][i] = lower_bound(all(G[t]), x) - G[t].begin();\n    }\n  }\n  rep(i, N) {\n    if (f)\n    printf(\"%.15f\\n\", dfs2(i, G[i].size()));\n    else\n    printf(\"%.15f\\n\", dfs(i, G[i].size()));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint N;\nvector<int> V[150010];\n\ndouble solve(int root, int from) {\n  int cnt = 0;\n  for (auto x : V[root]) {\n    if (x != from) ++cnt;\n  }\n  if (cnt == 0) return 0;\n  double ans = 0;\n  for (auto x : V[root]) {\n    if (x == from) continue;\n    ans += solve(x, root) + 1;\n  }\n  ans /= cnt;\n  return ans;\n}\n\nint main () {\n  cin >> N;\n  for (auto i = 0; i < N-1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    V[u].push_back(v);\n    V[v].push_back(u);\n  }\n  for (auto i = 0; i < N; ++i) {\n    cout << fixed << setprecision(12) << solve(i, -1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[150000];\ndouble ee[150000], ans[1500000];\n\nvoid dfs1(int idx, int par)\n{\n  double ret = 0;\n  int child = 0;\n\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    ret += ee[to] + 1.0;\n    ++child;\n  }\n  ee[idx] = 0;\n  if(child >= 1) ee[idx] += ret / child;\n}\n\nvoid dfs2(int idx, double d_par, int par)\n{\n  double ret = 0;\n  for(int &to : g[idx]) {\n    if(to == par) ret += d_par + 1.0;\n    else ret += ee[to] + 1.0;\n  }\n  ans[idx] = ret / g[idx].size();\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, (ret - ee[to] - 1.0) / (g[idx].size() - 1), idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if(N <= 2) {\n    if(N == 1) cout << 0 << endl;\n    else cout << 1 << endl << 1 << endl;\n    return (0);\n  }\n\n  int root = 0;\n  for(int i = 0; i < N; i++) {\n    if(g[i].size() >= 2) root = i;\n  }\n\n  dfs1(root, -1);\n  dfs2(root, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string.h>\n#include<iostream>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<string.h>\n#include<algorithm>\n#include <stdlib.h>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\nbool board[100005][7];\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int> >v(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    int root=-1,end=-1;\n    for(int i=0;i<n;i++){\n        if(v[i].size()==1){\n            if(root==-1)root=i;\n            else end=i;\n        }\n    }\n    vector<int>no(n);\n    no[root]=0;\n    no[end]=n-1;\n    int cur=root;\n    int ii=1;\n    while(cur!=root){\n        if(cur!=v[cur][0])cur=v[cur][0];\n        else cur=v[cur][1];\n        no[cur]=ii++;\n    }\n    vector<double>p(n);\n    for(int i=0;i<n;i++){\n        p[i]=(1.0*no[i]+n-1-no[i])/2.0;\n    }\n    for(int i=0;i<n;i++){\n        cout<<p[i]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], deg[150000];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        deg[u]++;\n        deg[v]++;\n        E[i][0] = u;\n        E[i][1] = v;\n    }\n\n    rep(i, N)if (deg[i] > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        rep(i, N)printf(\"%.10f\\n\", ans);\n        exit(0);\n    }\n    rep(i, N - 1)rep(j, 2)G[E[i][j]].push_back(i);\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[150001];\ndouble dp[150001];\nbool used[150001];\ndouble res[150001];\n\ndouble func(int v){\n\tused[v]=true;\n\tdouble res=0.0;\n\tint cnt=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tres+=func(G[v][i]);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt==0){\n\t\tdp[v]=0.0;\n\t\treturn (dp[v]+1.0);\n\t}\n\tdp[v]=(double)res/cnt;\n\treturn (dp[v]+1.0);\n}\n\nvoid solve(int v,int p,double val){\n\tused[v]=true;\n\tif(p==-1){\n\t\tres[v]=val;\n\t}else{\n\t\tdouble pn=(double)G[v].size()-1.0;\n\t\tdouble nn=(double)G[v].size();\n\t\tif(pn==0){\n\t\t\tres[v]=dp[v];\n\t\t\tres[v]+=val;\n\t\t}else{\n\t\t\tres[v]=(dp[v]*pn/nn);\n\t\t\tres[v]+=val/nn;\n\t\t}\n\t}\n\t//printf(\"%d %d %.9f\\n\",v,p,val);\n\tval=res[v];\n\t//printf(\"%d %d %.9f\\n\",v,p,val);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tint nv=G[v][i];\n\t\t\tdouble sendval=val;\n\t\t\t//printf(\"%.9f\\n\",sendval);\n\t\t\tif(p==-1){\n\t\t\t\tif(G[v].size()==1)sendval-=(dp[nv]+1.0);\n\t\t\t\telse{\n\t\t\t\t\tsendval-=(dp[nv]+1.0)/G[v].size();\n\t\t\t\t\tsendval*=(double)G[v].size()/(G[v].size()-1);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(G[v].size()==1)sendval-=(dp[nv]+1.0);\n\t\t\t\telse{\n\t\t\t\t\t//printf(\"sv %d %d %.9f\\n\",v,nv,sendval);\n\t\t\t\t\tsendval-=(dp[nv]+1.0)/((double)G[v].size());\n\t\t\t\t\t//printf(\"sv %d %d %.9f\\n\",v,nv,sendval);\n\t\t\t\t\tsendval*=(double)G[v].size()/(G[v].size()-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve(G[v][i],v,sendval+1.0);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint f,t;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tf--;\n\t\tt--;\n\t\tG[f].push_back(t);\n\t\tG[t].push_back(f);\n\t}\n\tmemset(used,false,sizeof(used));\n\tfunc(0);\n\tmemset(used,false,sizeof(used));\n\tsolve(0,-1,dp[0]);\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%.9f\\n\",res[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\ndouble *dp[150005];\nbool *used[150005];\ndouble dp2[150005];\nbool used2[150005];\nint store[150005];\nvector<int> V[150005];\n\ndouble f(int x, int p) {\n\tif (used[x][p]) return dp[x][p];\n\tdouble ans = 0;\n\tif (!used2[x]) {\n\t\tfor (int i = 0; i < V[x].size(); i++) {\n\t\t\tif (i == p) continue;\n\t\t\tans += f(V[x][i], lower_bound(V[V[x][i]].begin(), V[V[x][i]].end(), x) - V[V[x][i]].begin()) / (V[x].size() - 1);\n\t\t}\n\t\tdp2[x] = ans;\n\t\tused2[x] = 1;\n\t\tstore[x] = p;\n\t} else {\n\t\tans = dp2[x];\n\t\tans += f(V[x][store[x]], lower_bound(V[V[x][store[x]]].begin(), V[V[x][store[x]]].end(), x) - V[V[x][store[x]]].begin()) / (V[x].size() - 1);\n\t\tans -= f(V[x][p], lower_bound(V[V[x][p]].begin(), V[V[x][p]].end(), x) - V[V[x][p]].begin()) / (V[x].size() - 1);\n\t}\n\tused[x][p] = 1;\n\treturn dp[x][p] = ans + 1;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) sort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < N; i++) {\n\t\tdp[i] = new double[V[i].size()];\n\t\tused[i] = new bool[V[i].size()];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j < V[i].size(); j++) ans += f(V[i][j], lower_bound(V[V[i][j]].begin(), V[V[i][j]].end(), i) - V[V[i][j]].begin()) / V[i].size();\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\nusing Graph=vector<vector<int>>;\n\nGraph g;\ndouble dp1[151000];\ndouble dp2[151000];\n\ndouble dfs1(int idx,int pre){\n    int n=(int)g[idx].size()-1;\n    if(pre==-1) n++;\n    for(int next:g[idx]){\n        if(next==pre) continue;\n        dp1[idx]+=(1+dfs1(next,idx))/n;\n    }\n    return dp1[idx];\n}\n\nvoid dfs2(int idx,int pre){\n    if(pre!=-1){\n        int n=(int)g[pre].size();\n        if(pre==0) dp2[idx]=( (dp1[pre]+1)*(n)-(dp1[idx]+2) )/(max(n-1,1) );\n        else dp2[idx]=( (dp2[pre]+1)+(dp1[pre]+1)*(n-1)-(dp1[idx]+2) )/(n-1);\n    }\n    for(int next:g[idx]){\n        if(next==pre) continue;\n        dfs2(next,idx);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n    int n;\n    cin>>n;\n    g.resize(n);\n    for(int i=0;i<n-1;i++){\n        int s,t;\n        cin>>s>>t;\n        s--; t--;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    dfs1(0,-1);\n    dfs2(0,-1);\n    for(int i=0;i<n;i++){\n        int n=(int)g[i].size();\n        if(i!=0) cout<< (dp1[i]*(n-1)+dp2[i])/n<<endl;\n        else cout<<dp1[i]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\nint N;\nint u[150005], v[150005];\nvector<int> Adj[150005];\n\nlong double D[150005];\n\nint check[150005];\n\nlong double dfs(int idx, int par) {\n\n\t//cout << \"idx= \" << idx << \" par= \" << par << endl;\n\n\tif (check[idx] == 1) { return D[idx]; }\n\n\tlong double tmp = 0.0L;\n\n\tint child_num = 0;\n\n\n\tfor (auto y : Adj[idx]) {\n\t\tif (y == par) { continue; }\n\t\ttmp += dfs(y, idx); child_num++;\n\t}\n\n\n\tif (child_num == 0) { D[idx] = 0.0L; check[idx] = 1; return D[idx]; }\n\tD[idx] = tmp / (1.0L*child_num) + 1.0L;\n\n\tcheck[idx] = 1;\n\treturn D[idx];\n}\n\n\nlong double ans[150005];\n\nvoid dfs2(int idx, long double D_par, int par) {\n\n\tint num = Adj[idx].size();\n\n\tlong double tmp = 0.0L;\n\n\tfor (auto y : Adj[idx]) {\n\t\tif (y == par) { tmp += D_par+1.0L; continue; }\n\t\ttmp += D[y]+1.0L;\n\t}\n\n\tans[idx] = tmp / (1.0L*num);\n\n\tfor (auto y : Adj[idx]) {\n\t\tif (y == par) { continue; }\n\t\tlong double D_par;\n\t\tif (num == 1) { D_par = 0.0L; }\n\t\telse {\n\t\t\tD_par = (ans[idx] - (D[y] + 1.0L) / (1.0L*num))*num/(1.0L*num-1.0L);\n\t\t}\n\t\tdfs2(y, D_par, idx);\n\t}\n\n}\n\n\nint main(void) {\n\n\tcin >> N;\n\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> u[i] >> v[i];\n\t\tAdj[u[i]].push_back(v[i]);\n\t\tAdj[v[i]].push_back(u[i]);\n\t}\n\n\tfor (int i = 1; i <= N; i++) { D[i] = 0.0L; }\n\n\tdfs(1, -1);\n\n\n\t/*for (int i = 1; i <= N; i++) {\n\t\tcout << \"i= \" << i << \"  D[\" << i << \"]= \" << D[i] << endl;\n\t}*/\n\n\tfor (int i = 1; i <= N; i++) { ans[i] = 0.0L; }\n\n\tans[1] = D[1];\n\n\tdfs2(1, 0.0, -1);\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tcout <<setprecision(12)<<fixed<< ans[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    Int N;\n\n    vector<vector<Int>> tree;\n    vector<vector<double>> dp;\n    vector<Int> pi;\n\n\n    double dfs1(Int v, Int p = -1) {\n        dp[v].resize(tree[v].size());\n        if (tree[v].size() == 1 && p != -1) {\n            return 0.0;\n        }\n\n        Int cnt = 0;\n        double sum = 0.0;\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) {\n                pi[v] = i;\n                continue;\n            }\n\n            cnt++;\n            double tmp = dfs1(u, v);\n            dp[v][i] = tmp;\n            sum += tmp + 1.0;\n        }\n\n        return sum / cnt;\n    }\n\n    void dfs2(Int v, double res_p = 0.0, Int p = -1) {\n        if (p != -1) {\n            dp[v][pi[v]] = res_p;\n        }\n        if (tree[v].size() == 1 && p != -1) {\n            return;\n        }\n\n        Int cnt = tree[v].size() - 1;\n        double sum = 0.0;\n        for (int i = 0; i < tree[v].size(); ++i) {\n            sum += dp[v][i] + 1.0;\n        }\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) continue;\n            double n_res = cnt > 0 ? (sum - dp[v][i] - 1.0) / cnt : 0;\n            dfs2(u, n_res, v);\n        }\n    }\n\n\n    void solve() {\n        cin >> N;\n        if (N == 1) {\n            cout << 0 << endl;\n            return;\n        }\n        tree.resize(N);\n        dp.resize(N);\n        pi.resize(N);\n        for (int i = 1; i < N; ++i) {\n            Int a, b;\n            cin >> a >> b;\n            a--, b--;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n\n        dfs1(0);\n        dfs2(0);\n\n        vector<double> ans(N);\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < dp[i].size(); ++j) {\n                ans[i] += dp[i][j];\n            }\n            ans[i] /= dp[i].size();\n            ans[i] += 1;\n\n            cout << ans[i] << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\nint N;\nvector<int> E[151010];\n//-----------------------------------------------------------------------------------\ndouble dfs(int cu, int pa = -1) {\n    double ret = 0;\n    int cnt = 0;\n    for (int to : E[cu]) if (to != pa) ret += dfs(to, cu) + 1, cnt++;\n    if (cnt == 0) return 0;\n    return ret / cnt;\n}\n//-----------------------------------------------------------------------------------\nint main() {\n    cin >> N;\n    if (1010 < N) return 0;\n    rep(i, 0, N - 1) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    rep(i, 1, N + 1) printf(\"%.10f\\n\", dfs(i));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\nconst int inf = 1e9 + 7;\nconst ll INF = 1e18;\n#define abs(x) (x >= 0 ? x : -(x))\n#define lb(v, x) (int)(lower_bound(all(v), x) - v.begin())\n#define ub(v, x) (int)(upper_bound(all(v), x) - v.begin())\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\nconst int mod = 1000000007;\nll modpow(ll a, int b) { return b ? modpow(a * a % mod, b / 2) * (b % 2 ? a : 1) % mod : 1; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& vec) { for (auto &vi: vec) os << vi << \" \"; return os; }\ntemplate<class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << p.F << \" \" << p.S; return os; }\ntemplate<class T> inline void add(T &a, int b) { a += b; if (a >= mod) a -= mod; }\n\n\n\nvoid solve();\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed << setprecision(10);\n\n    int T;\n    // cin >> T;\n    T = 1;\n\n    while (T--) {\n        solve();\n    }\n}\n\n\n// https://ei1333.hateblo.jp/entry/2017/04/10/224413\n// ある頂点を根としたものを構成\n// すべての頂点を根としたものを構成\nstruct edge { int to, cost; };\nint n;\nconst int maxn = 100005;\nvector<edge> G[maxn];\ndouble E[maxn];\nvector<double> ans(maxn);\n\nvoid dfs(int v, int p) {\n  double E2 = 0;\n  int cnt = 0;\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    dfs(e.to, v);\n    // dfs から上がってきたタイミングで\n    E2 += E[e.to] + 1;\n    cnt++;\n  }\n  if (cnt) E[v] = E2 / cnt;\n}\n\n// v を根とする答え\nvoid dfs2(int v, double Epar, int p) {\n  double ret = 0;\n  for (edge& e : G[v]) {\n    // 親との距離と, 親方向の部分木で一番遠い頂点との距離の和\n    if (e.to == p) ret += Epar + e.cost;\n    // 部分木の, ある頂点 j への距離と, j と j の部分木内での一番遠い頂点との距離の和\n    else ret += e.cost + E[e.to], e.to;\n  }\n  ans[v] = ret / sz(G[v]);\n\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    dfs2(e.to, sz(G[v]) == 1 ? 0 : (ret - (E[e.to] + 1)) / (sz(G[v]) - 1), v);\n    // sz(G[v]) == 1, 葉\n    // 0 = 0/1\n\n  }\n}\n\nvoid solve() {\n  cin >> n;\n  rep(i, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--; // debuged\n    G[a].eb(edge{b, 1});\n    G[b].eb(edge{a, 1});\n  }\n  dfs(0, -1);\n  rep(i, n) cout << E[i] << \" \"; cout << endl;\n  dfs2(0, 0, -1);\n  rep(i, n) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i].first;\n\t\tif (v == prev) continue;\n\t\t\n\t\tcnt++;\n\t\tres += dfs(v, g[u][i].second, u);\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = (res + cnt) / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i);\n\t\t\n\t\tans = (ans + g[i].size()) / g[i].size();\n\t\t\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 15e4;\nvector<vector<int>> g0(N), g1;\nmap<int, ld> dp[N];\nint n;\nld dfs0(int i, int p) {\n  int cnt = 0;\n  ld res = 0;\n  for(int j : g0[i]) if(j != p) {\n    cnt++;\n    res += dfs0(j, i);\n  }\n  if(cnt) res /= cnt, res += 1.0;\n  return dp[i][p] = res;\n}\nld dfs1(int i, int p) {\n  if(dp[i].count(p)) return dp[i][p];\n  vector<int> gi;\n  int cnt = 0;\n  ld res = 0;\n  if(p == -1) {\n    for(int j : g0[i]) {\n      cnt++;\n      res += dfs1(j, i);\n    }\n  } else {\n    cnt = g0[i].size() - 1;\n    res = (dfs1(i, -1) - 1.0) * g0[i].size() - dfs1(p, i);\n  }\n  if(cnt) res /= cnt, res += 1.0;\n  return dp[i][p] = res;\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g0[a].emplace_back(b);\n    g0[b].emplace_back(a);\n  }\n  // g1 = g0;\n  dfs0(0, -1);\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << dfs1(i, -1) << endl;\n  // for(int i = 0; i < n; i++) cout << dp[i][-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[150000];\ndouble ee[150000], ans[1500000];\n\nvoid dfs1(int idx, int par)\n{\n  double ret = 0;\n  int child = 0;\n\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    ret += ee[to];\n    ++child;\n  }\n  ee[idx] = 0;\n  if(child >= 1) ee[idx] += ret / child;\n}\n\nvoid dfs2(int idx, double d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  double ret = 0;\n  for(int &to : g[idx]) {\n    if(to == par) ret += d_par + 1.0;\n    else ret += ee[to] + 1.0;\n  }\n  ans[idx] = ret / g[idx].size();\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, (ret - ee[to]) / max(1, (int) g[idx].size() - 1), idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << fixed << setprecision(10) << ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = (LL)1e9+7;\nconst int SIZE = 2e5+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\ndouble dp[150009];\ndouble ans[150009];\nvector<int> radj[150009],adj[150009];\nint par[150009];\n\nvoid dfs1(int x,int p=-1){\n\tint cc=SZ(radj[x])-(p!=-1);\n\tfor(int i:radj[x]){\n\t\tif(i==p)continue;\n\t\tadj[x].PB(i);\n\t\tdfs1(i,x);\n\t\tdp[x]+=(dp[i]+1)/cc;\n\t}\n}\n\nvoid dfs2(int x,int p=-1){\n\tif(x==0)ans[x]=dp[x];\n\telse{\n\t\tint cc=SZ(radj[x]);\n\t\tint pcc=SZ(radj[p]);\n\t\tans[x]=(dp[x]*(cc-1))/cc;\n\t\tif(pcc>1)ans[x]+=((ans[p]-(dp[x]+1)/pcc)/(pcc-1)*pcc+1)/cc;\n\t\telse ans[x]+=(double)1/cc;\n\t}\n\tfor(int i:adj[x]){\n\t\tdfs2(i,x);\n\t}\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tradj[a].PB(b);radj[b].PB(a);\n\t}\n\tdfs1(0);dfs2(0);\n\tREP(i,n){\n\t\tif(i)printf(\" \");\n\t\tprintf(\".10%lf\",ans[i]);\n\t\t//printf(\"%lf\",[i]);\n\t}puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\nvector<unordered_map<int, R>> dp;\nvector<vi> graph;\n\nR dfs(int v, int pv){\n    if(dp[v].find(pv) != end(dp[v])) return dp[v][pv];\n    R& cur = dp[v][pv];\n    cur = (R)0;\n\n    int cnt = 0;\n    for(auto& nv : graph[v]){\n        if(nv == pv) continue;\n        cur += dfs(nv, v);\n        cnt++;\n    }\n    if(cnt != 0){\n        cur /= cnt;\n    }\n    if(pv != -1) cur++;\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    dp = vector<unordered_map<int, R>>(n);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dfs(i, -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[202020];\nvector<double> V[202020];\ndouble T[202020];\nint PE[202020];\ndouble ret[202020];\n\ndouble dfs(int cur,int pre) {\n\tV[cur].resize(E[cur].size());\n\tint i;\n\tint num=0;\n\tFOR(i,E[cur].size()) {\n\t\tint e=E[cur][i];\n\t\tif(e==pre) {\n\t\t\tPE[cur]=i;\n\t\t}\n\t\telse {\n\t\t\tV[cur][i] = 1+dfs(e,cur);\n\t\t\tT[cur] += V[cur][i];\n\t\t\tnum++;\n\t\t}\n\t}\n\t\n\tif(T[cur]==0) return 0;\n\treturn T[cur] / num;\n}\n\nvoid dfs2(int cur,int pre,double par) {\n\tif(PE[cur]>=0) {\n\t\tV[cur][PE[cur]]=par;\n\t\tT[cur] += par;\n\t}\n\t\n\tint i;\n\tFOR(i,E[cur].size()) {\n\t\tint e=E[cur][i];\n\t\tif(e!=pre) {\n\t\t\tif(E[cur].size()==1) dfs2(e,cur,1);\n\t\t\telse dfs2(e,cur,(T[cur]-V[cur][i])/(E[cur].size()-1)+1);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(PE);\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tdouble tot=dfs(0,-1);\n\tdfs2(0,-1,0);\n\t\n\tFOR(i,N) _P(\"%.12lf\\n\",T[i]/E[i].size());\n\t/*\n\tFOR(i,N) {\n\t\t_P(\"%d : %lf : \",i,T[i]);\n\t\tFOR(j,E[i].size()) _P(\"%d:%lf \",E[i][j],V[i][j]);\n\t\t_P(\"\\n\");\n\t}*/\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <queue>\n#include<string>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include <iomanip>\nusing namespace std;\n#define rep(i, n)   for(int i = 0; i < (int)(n); i++)\n#define rrp(i, n)   for(int i = ((int)(n)); i >=0; i--)\n#define mpp(i,j,k)  make_pair((int)(i),make_pair((int)(j),(int)(k)))\ntypedef pair<int,pair<int,int > > ppp;\ntypedef pair<int,int> pp;\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int N=15e4+1;\nlong double dp[N];\nlong double dp2[N];\nvvi e(N,vi());\nint p;\n\nlong double dfs(int v,int parent){\n  rep(i,e[v].size()){\n    int u=e[v][i];\n    if(parent==u)continue;\n    else{dp[v]+=dfs(u,v);}\n  }\n  if(e[v].size()>1){\n      if(v==1)dp[v]/=e[v].size();\n      else{\n       dp[v]/=e[v].size()-1;}\n      \n  }\n  if(!(e[v].size()==1&&e[v][0]==parent))dp[v]+=1.0;\nreturn dp[v];}\n\nvoid dfs2(int v,int parent){\n  if(v>1)dp2[v]=dp2[parent];\n  if(parent==1)p=e[parent].size();\n  else{p=e[parent].size()-1;}\n  \n  if (p>1){\n  dp2[v]+=(dp[parent]-(1.0+dp[v])/p)*p;\n  dp2[v]/=e[parent].size()-1;\n  }\n  if(v>1)dp2[v]+=1.0;\n  rep(i,e[v].size()){\n    int u=e[v][i];\n    if(parent==u)continue;\n    else{dfs2(u,v);}\n  }\n} \n\nint main(){\n\nint a,b,n;\ncin>>n;\nrep(i,n-1)cin>>a>>b,e[a].push_back(b),e[b].push_back(a);\n\n\n\ndfs(1,0);\ndfs2(1,0);\ncout << fixed << setprecision(8);\ncout<<dp[1]<<endl;\nfor(int i=2;i<=n;i++)cout<<(dp[i]*(e[i].size()-1)+dp2[i])/e[i].size()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nvector<int> v[200000];\ndouble dp1[200000];\ndouble dp2[200000];\n\ndouble dfs1(int u,int prev){\n    double ret = 0.0;\n    int cnt;\n    if(u==prev) cnt = v[u].size();\n    else cnt = v[u].size()-1;\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev) continue;\n        ret += (dfs1(v[u][i],u)+1.0)/cnt;\n    }\n    return dp1[u] = ret;\n}\n\nvoid dfs2(int u,int prev,double w){\n    double ret = 0.0;\n    int cnt = v[u].size();\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev){\n            ret += (w+1.0)/cnt;\n        }\n        else ret += (dp1[v[u][i]]+1.0)/cnt;\n    }\n    dp2[u] = ret;\n    for (int i = 0; i < v[u].size(); i++) {\n        if(v[u][i]==prev) continue;\n        dfs2(v[u][i],u,(ret*cnt-(dp1[v[u][i]]+1.0))/max(1,cnt-1));\n    }\n}\n\n\nint main(){\n    int N;cin >> N;\n    for (int i = 0; i < N-1; i++) {\n        int x,y;cin >> x >> y;\n        x--,y--;\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    dfs1(0,0);\n    dfs2(0,0,0);\n    for (int i = 0; i < N; i++) {\n        cout << setprecision(10) << fixed << dp2[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 1010\nll n;\nvector<ll> g[N];\ndouble down[N],up[N];\ndouble dsum[N];\nvoid dfs1(ll x,ll p){\n    double sum=0,pa=0;\n    for(auto y:g[x])if(y!=p){\n\tdfs1(y,x);\n\tsum+=down[y]; pa+=1;\n    }\n    if(pa==0)down[x]=0;\n    else down[x]=sum/pa+1;\n    if(~p)dsum[p]+=down[x];\n}\nint main(){\n    cin>>n; if(n>N)return 0;\n    for(int i=0;i<n-1;i++){\n\tll a,b;cin>>a>>b;\n\tg[a].push_back(b);\n\tg[b].push_back(a);\n    }\n    for(int i=1;i<=n;i++){\n\tdfs1(i,-1);\n\tcout<<fixed<<setprecision(9)<<down[i]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define ALL(v) (v).begin(), (v).end()\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst long long MOD = 1e9 + 7;\n\n#define MAX_N 150000\n\nvector<int> G[MAX_N];\n\ndouble dp[MAX_N];\ndouble ans[MAX_N];\n\ndouble dfs(int v, int pre) {\n    vector<double> t;\n    for (auto to : G[v]) {\n        if (to == pre) continue;\n        t.emplace_back(dfs(to, v));\n    }\n    if (t.size() == 0) return dp[v] = 0;\n    double res = 0;\n    rep(i, t.size()) {\n        res += t[i];\n    }\n    return dp[v] = res / t.size() + 1;\n}\n\nvoid ddfs(int v, int pre) {\n    for (auto to : G[v]) {\n        ans[v] += dp[to] + 1;\n    }\n    ans[v] /= G[v].size();\n    for (auto to : G[v]) {\n        if (to == pre) continue;\n        double t = dp[v];\n        if (G[v].size() > 1)\n            dp[v] = (ans[v] * G[v].size() - (dp[to] + 1)) / (G[v].size() - 1);\n        else\n            dp[v] = 0;\n        ddfs(to, v);\n        dp[v] = t;\n    }\n}\n\nsigned main() {\n    int n;\n    cin >> n;\n    int u, v;\n    rep(i, n - 1) {\n        cin >> u >> v;\n        u--;\n        v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs(0, -1);\n    ddfs(0, -1);\n    rep(v, n) {\n        printf(\"%.10lf\\n\", ans[v]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n\ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return dp[P(prev,now)] = 0.0;\n\tif(dp.find(P(prev,now)) != dp.end()) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string.h>\n#include<iostream>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<string.h>\n#include<algorithm>\n#include <stdlib.h>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\nbool board[100005][7];\n\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int> >v(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    int root=-1,end=-1;\n    for(int i=0;i<n;i++){\n        if(v[i].size()==1){\n            if(root==-1)root=i;\n            else end=i;\n        }\n    }\n    vector<int>no(n);\n    no[root]=0;\n    no[end]=n-1;\n    int cur=v[root][0];\n    int last=root;\n    int ii=1;\n    while(cur!=end){\n        if(last!=v[cur][0]){last=cur;cur=v[cur][0];}\n        else{last=cur; cur=v[cur][1];}\n        no[cur]=ii++;\n    }\n    vector<double>p(n);\n    for(int i=0;i<n;i++){\n        p[i]=(1.0*no[i]+n-1-no[i])/2.0;\n    }\n    p[root]=p[end]=n-1;\n    for(int i=0;i<n;i++){\n        cout<<p[i]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << head << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << head << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) &&                                                     \\\n    (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\ntemplate <typename T, typename E> struct ReRooting {\n    struct Edge {\n        int to;\n        E data;\n        T dp, ndp;\n    };\n\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n\n    vector<vector<Edge>> g;\n    vector<T> subdp, dp;\n    const T ident;\n    const F f;\n    const G gg;\n\n    ReRooting(int V, const F f, const G g, const T &ident)\n        : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const E &d) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const E &d, const E &e) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for(auto &e : g[idx]) {\n            if(e.to == par) continue;\n            dfs_sub(e.to, idx);\n            subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const T &top) {\n        T buff{ident};\n        for(int i = 0; i < (int)g[idx].size(); i++) {\n            auto &e = g[idx][i];\n            e.ndp = buff;\n            e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for(int i = (int)g[idx].size() - 1; i >= 0; i--) {\n            auto &e = g[idx][i];\n            if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n            e.ndp = f(e.ndp, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector<T> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n\nsigned main() {\n    LCIN(N);\n    using p = pair<double, ll>;\n    auto f = [](p x, p y) { return p(x.fi + y.fi, x.se + y.se); };\n    auto g = [](p x, ll y) { return p((x.se ? x.fi / x.se : 0.0) + 1.0, 1); };\n    ReRooting<p, ll> tree(N, f, g, p(0, 0));\n    REP(i, N - 1) {\n        LCIN(u, v);\n        u--, v--;\n        tree.add_edge(u, v, 0);\n    }\n    FOREACH(d, tree.build()) {\n        cout << fixed << setprecision(12) << (d.se ? d.fi / d.se : 0) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define MAX_N 150000\n\nint N;\nvector<int> G[MAX_N];\n\ndouble dp[MAX_N];\n\nvoid dfs(int u, int p) {\n  int sz = G[u].size(), ch = sz-1;\n  if(!u) ch++;\n\n  dp[u] = 0;\n  for(int v : G[u]) {\n    if(v == p) continue;\n    dfs(v, u);\n    dp[u] += dp[v]+1;\n  }\n\n  if(ch) dp[u] /= ch;\n}\n\ndouble ans[MAX_N];\n\nvoid dfs2(int u, int p, double rev) {\n  int sz = G[u].size(), ch = sz-1;\n\n  if(u) ans[u] = (dp[u]*ch + rev) / sz; // ch/szの確率で子へ、残りは親へ\n  else ans[u] = dp[u];\n\n  for(int v : G[u]) {\n    if(v == p) continue;\n    if(u) { // 根以外\n      double tmp = dp[u] * ch;\n      tmp -= dp[v]+1; // T(v)以外の部分は再利用\n      tmp += rev;\n      tmp /= ch;\n      dfs2(v, u, tmp+1);\n    } else { // 根\n      if(sz == 1) dfs2(v, u, 1);\n      else {\n\tdouble tmp = dp[u] * sz;\n\ttmp -= dp[v]+1;\n\ttmp /= ch;\n\tdfs2(v, u, tmp+1);\n      }\n    }\n  }\n}\n\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N;\n  rep(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  dfs(0, -1);\n  dfs2(0, -1, 0);\n  rep(i, N) cout << ans[i] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n;;;;;;;;;;;;::;,.,xOOOOOOOkdoc;,,;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,'''',,,,,,,,,'',,:cloo:'.\n;;;;;;;;;;:ccccc,'lOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,,''''''''''',;cloxkOOOOl..\n;;;;;;;;;:cccccc:,;xOOOOOOOOOOOOOxoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,''''''';:loxkOOOOOOOOk:..\n;;;;;;;;;:cccccc::,ck0OOOOO0OO00OOOOxl:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;,'',;codkO0OOOOOOOOOOOo'..\n;;;;;;;;:cccccc:::;,ck0OOOOOOOOOOOOO0Okoc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:cloxOOOOOOOOOOOOOOOO0x;..'\n;;;;;;;:ccccccc::;;,,:xOOOOO0OOOOOOOOOOOkdc;,;;;;;;;::::ccccccccc:::::cldkOOOOOOOOOOOOOOOOOOO0k:..''\n;;;;;;;:cccccc::;;,,,';dO0OOOOO0OOOOOOOOOOkdodddxxxxkkkOOOOOOOOOOkkkxkkO0OOOOOOOOOOOOOOOOOOO0kc'''''\n;;;;;;;::::::::;;,,,''',cxOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOxc,,,,''\n;;;;;,;;;;;;;;;,,,,'''''',lkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko:;;;;,,,\n;;;;,,,,,,,,,,,,''''''''''.,lkOOkxkOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkoc:c:::;;,,\n;;;;'''''''''''''''''''''''..;lodkO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxk0Okxocccccc:::;,,\n;;;,'............'''''''''''..;xOOOOOOOOOOOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkxdol::::cccc:::;;,,\n;;,'..............''''''''''';dOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOko;;::::::::;;;;,,\n;;'................'''''','',dOOOO0OOOxdoccxOO0OOOOOOOOOOOOOOOOOOOOxdoclxOOOOOOOOOOOo;;;;;;;;;;;;,,'\n;,'................'''''',,,lOOOOOOOOoo00c.;xOOOOOOOOOOOOOOOOOOOOOll0O:.:k0OOOOOOOOOOo,,;;;;;;,,,,''\n,'..................''',,,,ckOOO0OO0Ol,::,.,d0OOOOOOOOOOOOOOOOOOOOc,::,.;x0OOOOOOOOOOkc',,,,,,,,,,''\n,'..................''',,';dOOOOOOOO0kc,,,;oOOO0OO0OO0OOOOOOOOOOOOkc,,,:dOOOOOOOOOOOOOd,',,'''''''''\n'...................''',,,lOOOOOOOOOOOOkxxkOOOOOOOOxdddkOOOOOOOOOOOOkxxOOOOOOOOOOOOOO0kc''''''''''''\n'...................''',,;xOOOkkkOOOOOOOOOOOOOOOOOxo:;:dOOOOOOOOOOOOOOOOOOOOkkkkOOOOOOOd;'''''''''''\n'.................'''',,,ckxollllldkOOOOOOOOOOOOOO0OkkOOOOOOOOOOOOOOOOOOOkdlllllodkOOOOOc'',''''''''\n''''...........'''',,,,,;odccccccccokOOOOOOOOOOOOOOO0OOOOOOOOO0OOOOOOOOOxlcccccccclk0OOOd;,,,,,,,,''\n'''''''',''',,,,,,,;;;;;;ddcccccccclxOOOOOOOOOOOOkxdddddooddkOOOOOOOOOOOdccccccccclx0OOOOl,;;;;,,,,'\n',,,,,,;;;;;;;;;;;:::::;:xOdolclllokOOOOOOOOOOOOxllodddxdddllkOOOOOOOOOOkocccccccldOOOOOOd:;:;;;;;,,\n,,,;;;;:::::::::::::::cc;lOOOkkkkOOOOOOOOOOOOOOOdlodxxdxddxdcdOOOOOOOOOOOOkxdoddxkOOOOOOOOl:::::;;,,\n,,;;::::cccccccccccccccc::dOOOOOOOOOOOOOOOOOOOO0kolldxxxxxxoldOOOOOOOOOOOOOOOOOOOOOOOOOOOOd::c::;;,,\n,,;;:::cccccccccccccccccc:cxOOOOOOOOOOOOOOOOOOOOOOkxoooooooodOOOOOOOOOOOOOOOOOOOOOOOOOOOOOkc:c:::;,,\n,,;;::::cccccccccccccccc:c:cxOOOOOOOOOOOOOOOOOOOOOOOOOkkkkkOO0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOo;:::;;,,\n,;;;;::::ccccccccccccccc:::;ck0OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOx::::;;,,\n*/\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,tune=native\")\n//#pragma GCC optimize (\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double old;\n\nconst int N = 150123;\n\nvector<int> g[N];\nold dp[N], ans[N];\nint used[N];\n\nvoid dfs(int v) {\n    used[v] = 1;\n    if (v == 1 || g[v].size() > 1) {\n        dp[v] = 1;\n    }\n    int deg = g[v].size() - (v != 1);\n    for (int u : g[v]) {\n        if (!used[u]) {\n            dfs(u);\n            dp[v] += dp[u] / deg;\n        }\n    }\n}\n\nvoid calc(int v, int par = -1) {\n    used[v] = 1;\n    int deg = g[v].size();\n    ans[v] = 1;\n    for (int u : g[v]) {\n        if (u != par) {\n            ans[v] += dp[u] / deg;\n        }\n    }\n    if (par != -1 && g[par].size() != 1) {\n        int du = g[par].size();\n        ans[v] += (((ans[par] - 1) * du - dp[v]) / (du - 1) + 1) / deg;\n    }\n    for (int u : g[v]) {\n        if (!used[u]) {\n            calc(u, v);\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int v, u;\n        cin >> v >> u;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(1);\n    fill(used + 1, used + 1 + n, 0);\n    calc(1);\n    for (int i = 1; i <= n; ++i) {\n        cout << ans[i] << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\n\nint N, u[151234], v[151234];\nstd::vector<int>G[151234];\n\nint main()\n{\n\tin >> N;\n\trep(i, N - 1)\n\t{\n\t\tin >> u[i] >> v[i];\n\t\tG[u[i]].push_back(v[i]);\n\t\tG[v[i]].push_back(u[i]);\n\t}\n\trep(i, N)\n\t{\n\t\tif (G[i + 1].size() > 2) { return 0; }\n\t}\n\n\tout << std::fixed << std::setprecision(10);\n\trep(i, N)\n\t{\n\t\tif (i == 0 || i == N - 1)\n\t\t{\n\t\t\tout << N - 1 << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong double ans;\n\t\t\tans = (double)i / 2;\n\t\t\tans += (double)(N - i - 1) / 2;\n\t\t\tout << ans << std::endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n#define double float\nconstexpr int32_t MAX_N = 150000;//頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v)+1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\ndouble get(int32_t v) {\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\t++count;\n\t\tsum += get(c.first, v) + 1;\n\t}\n\tif (count == 0) {\n\t\treturn 0;\n\t}\n\treturn sum / count;\n}\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout  << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << get(i) << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> g[150005];\ndouble d[150005];\n\nvoid dfs1(int cur, int par) {\n    int cnt = (int)g[cur].size() - (par != -1);\n    if (cnt == 0) return;\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs1(nex, cur);\n        d[cur] += (d[nex] + 1) / cnt;\n    }\n}\n\ndouble ans[150005];\n\nvoid dfs2(int cur, double d_par, int par) {\n    int cnt = g[cur].size();\n    for (int nex : g[cur]) {\n        if (nex == par) ans[cur] += d_par + 1;\n        else ans[cur] += d[nex] + 1;\n    }\n\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs2(nex, (ans[cur] - d[nex] - 1) / (cnt - (par != -1)), cur);\n    }\n    ans[cur] /= cnt;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << setprecision(10) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint n;\nvector<int> et[150000];\ndouble dp[150000];\ndouble dp2[150000];\n\ndouble dfs(int p, int v) {\n\tif (et[v].size() == 1 && p != -1) return dp[v] = 0;\n\t\n\tint i;\n\tdouble ssum = 0;\n\tint cnt = 0;\n\trep(i, et[v].size()) {\n\t\tint nv = et[v][i];\n\t\tif (nv == p) continue;\n\t\tssum += dfs(v, nv);\n\t\tcnt++;\n\t}\n\treturn dp[v] = ssum / cnt + 1;\n}\n\nvoid dfs2(double pDp, int p, int v) {\n\tint i, j;\n\t\n\t//vについて計算(dp[v]よりもう少し詳しい情報)\n\tdouble ssum = 0;\n\trep(i, et[v].size()) {\n\t\tint nv = et[v][i];\n\t\tif (nv == p) continue;\n\t\tssum += dp[nv];\n\t}\n\tif (p != -1) {\n\t\tssum += pDp;\n\t}\n\t\n\t//ch(vの子)について計算→呼び出し\n\trep(i, et[v].size()) {\n\t\tint ch = et[v][i];\n\t\tif (ch == p) continue;\n\t\t\n\t\tdouble sumCst = 0;\n\t\tdouble pCst;\n\t\tif (et[v].size() == 1) pCst = 0;\n\t\telse pCst = (ssum - dp[ch]) / (et[v].size() - 1) + 1;\n\t\t\n\t\trep(j, et[ch].size()) {\n\t\t\tint nv = et[ch][j];\n\t\t\tdouble cst;\n\t\t\tif (nv == v) {\n\t\t\t\tcst = pCst;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcst = dp[nv];\n\t\t\t}\n\t\t\tsumCst += cst;\n\t\t}\n\t\tdp2[ch] = sumCst / et[ch].size() + 1;\n\t\tdfs2(pCst, v, ch);\n\t}\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tet[u].push_back(v);\n\t\tet[v].push_back(u);\n\t}\n\tdp2[0] = dfs(-1, 0);\n\tdfs2(0, -1, 0);\n\t\n\trep(i, n) {\n\t\tprintf(\"%.14f\\n\", dp2[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ndouble ans = 0.;\n\nvoid dfs(int now, int pre, double prob, int dist, const Graph& G) {\n    if (G[now].size() == 1) {\n        // leaf (not start)\n        ans += prob * dist;\n        return;\n    }\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs(nxt, now, prob / (G[now].size() - 1), dist + 1, G);\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph G(n);\n    rep(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    bool is_path = true;\n    int leaf = -1;\n    rep(i, n) {\n        if (G[i].size() >= 3) is_path = false;\n        if (G[i].size() == 1) leaf = i;\n    }\n\n    if (is_path) {\n        // subtask 1\n        rep(i, n) {\n            cout << fixed << setprecision(10) << (G[i].size() == 1 ? (double)(n - 1) : (n - 1) / 2.) << endl;\n        }\n        return 0;\n    }\n\n    assert(n <= 1000);\n\n    // subtask 2\n    rep(i, n) {\n        ans = 0.;\n        for (auto nxt : G[i]) {\n            dfs(nxt, i, 1. / G[i].size(), 1, G);\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf 1000000000000000000\n\nstruct Data{\n\tint child_num = 0;\n\tdouble child_sum = 0.0;\n\tdouble ans = 0.0;\n};\n\ntemplate <typename T,typename F0,typename F1>\nstruct rerooting{\n\tF0 func0;\n\tF1 func1;\n\tT init_value;\n\t\n\tvector<T> v;\n\tvector<bool> visited;\n\t\n\trerooting(vector<vector<int>> &E,F0 f0,F1 f1,T iv):func0(f0),func1(f1){\n\t\tinit_value = iv;\n\t\tv.resize(E.size());\n\t\tvisited.resize(E.size(),false);\n\t\tfor(int i=0;i<E.size();i++){\n\t\t\tif(visited[i])continue;\n\t\t\tdfs(E,i,-1);\n\t\t\tredfs(E,i,-1,init_value);\n\t\t}\n\t}\n\t\n\tvoid dfs(vector<vector<int>> &E,int now,int p){\n\t\tv[now] = init_value;\n\t\tfor(int i=0;i<E[now].size();i++){\n\t\t\tint to = E[now][i];\n\t\t\tif(to==p)continue;\n\t\t\tdfs(E,to,now);\n\t\t\tv[now] = func0(v[now],v[to]);\n\t\t}\n\t\tv[now] = func1(v[now]);\n\t\tvisited[now]=true;\n\t}\n\t\n\tvoid redfs(vector<vector<int>> &E,int now,int p,T pv){\n\t\tvector<T> P(E[now].size()+1,init_value),S(E[now].size()+1,init_value);\n\t\trep(i,E[now].size()){\n\t\t\tint to = E[now][i];\n\t\t\tif(to!=p)P[i+1] = func0(P[i],v[to]);\n\t\t\telse P[i+1] = func0(P[i],pv);\n\t\t}\n\t\trep(i,E[now].size()){\n\t\t\tint to = E[now][E[now].size()-1-i];\n\t\t\tif(to!=p)S[i+1] = func0(v[to],S[i]);\n\t\t\telse S[i+1] = func0(pv,S[i]);\n\t\t}\n\t\tv[now] = func1(P.back());\n\n\t\tfor(int i=0;i<E[now].size();i++){\n\t\t\tint to = E[now][i];\n\t\t\tif(to!=p){\n\t\t\t\tredfs(E,to,now,func1(func0(P[i],S[E[now].size()-1-i])));\n\t\t\t}\n\t\t}\n\t}\n\t\n};\n\n\nint main(){\n\t\n\tint N;\n\tcin>>N;\n\t\n\tvector<vector<int>> E(N,vector<int>());\n\trep(i,N-1){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tu--;v--;\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\t\n\tauto f0 = [](Data a,Data b){\n\t\ta.child_num += b.child_num;\n\t\ta.child_sum += b.child_sum;\n\t\treturn a;\n\t};\n\t\n\tauto f1 = [](Data a){\n\t\tif(a.child_num==0)a.ans = 0.0;\n\t\telse a.ans = a.child_sum / a.child_num + 1.0;\n\t\ta.child_sum = a.ans;\n\t\ta.child_num = 1;\n\t\treturn a;\n\t};\n\t\n\trerooting<Data,decltype(f0),decltype(f1)> rr(E,f0,f1,Data());\n\t\n\trep(i,N){\n\t\tcout<<fixed<<setprecision(10)<<rr.v[i].ans<<'\\n';\n\t}\n\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v, ans;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t}\n\n\tcout << n - 1 << endl;\n\tfor (int i = 2; i < n - 1; i++){\n\t\tfloat ans = (n - 1) / 2;\n\t\tcout << ans << endl;\n\t}\n\tcout << n - 1 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=15e4;\nvector<int> G[MAX_N];\nint N;\nmap<int,double> dp[MAX_N];\ndouble dfs(int v,int p){\n\tif(dp[v].find(p)!=dp[v].end()){\n\t\treturn dp[v][p];\n\t}\n\tint cnt=0;\n\tfor(auto e:G[v]){\n\t\tif(e!=p){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tdouble ret;\n\tif(cnt==0){\n\t\tret=0;\n\t}else{\n\t\tret=1;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e!=p){\n\t\t\t\tret+=dfs(e,v)/cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[v][p]=ret;\n}\nint main(){\n\tcin>>N;\n\tREP(i,N-1){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tREP(i,N){\n\t\tprintf(\"%.16f\\n\",dfs(i,-1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint N;\nvector<int> G[202020];\n\ndouble per[202020];\n\nvoid dfs1(int v,int f = -1){\n  int cnt = 0;\n  for(int to : G[v]){\n    if(to == f) continue;\n    dfs1(to,v);\n    cnt++;\n    per[v] += per[to];\n  }\n  if(cnt != 0){\n    per[v] /= cnt;\n    per[v]++;\n  }\n}\n\ndouble ans[202020];\n\nvoid dfs2(int v,int f = -1,double f_per = 0){\n  int cnt = G[v].size();\n  double sum = 0;\n  for(int to : G[v]){\n    if(to == f){\n      sum += f_per;\n    }\n    else{\n      sum += per[to];\n    }\n  }\n  cout << v << \" \" << f_per << \" \" << sum <<endl;\n  ans[v] = sum / cnt + 1;\n\n  for(int to : G[v]){\n    if(to == f) continue;\n    double t = sum - per[to];\n    if(cnt > 1) t = t / (cnt - 1) + 1;\n    dfs2(to,v,t);\n  }\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0;i < N - 1;i++){\n    int u,v;\n    cin >> u >> v;\n    u--;\n    v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(0);\n  dfs2(0);\n  cout << fixed << setprecision(10);\n  for(int i = 0;i < N;i++){\n    cout << ans[i] <<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<int> g[N];\ndouble dp[N];\ndouble dp1[N];\ndouble dp2[N];\ndouble ans[N];\n\n// †全方位木DP†はO(N)頂点からやると落とされちゃうめう\n\nvoid dfs(int i, int p = -1) {\n  int sz = (g[i].size() - (p != -1));\n  for(int j : g[i]) if(j != p) {\n    dfs(j, i);\n    dp[i] += (1 + dp1[j]);\n    dp1[i] += (1 + dp1[j]) / sz;\n  }\n}\n\nvoid dfs2(int i, int p = -1) {\n  ans[i] = dp[i] + (p != -1 ? dp2[i] : 0);\n  for(int j : g[i]) if(j != p) {\n    dp2[j] = 1 + (ans[i] - (1 + dp1[j])) / (g[i].size() - 1); /// コーナーに気をつけよう\n    dfs2(j, i); ////\n  }\n  ans[i] /= g[i].size();\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  if(n == 2) { //\n    cout << 1.0 << endl;\n    cout << 1.0 << endl;\n    return 0;\n  }\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  int t = 0;\n  for(int i = 0; i < n; i++) if(g[t].size() >= 2) t = i; /// はい\n  dfs(t);\n  dfs2(t);\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<int> g[N];\nunordered_map<int, double> expect[N];\n\ndouble dfs(int i, int p = -1) {\n  if(expect[i].count(p)) return expect[i][p];\n  expect[i][p] = 0;\n  for(int j : g[i]) if(j != p) {\n    expect[i][p] += (1 + dfs(j, i)) / (g[i].size() - (p != -1));\n  }\n  return expect[i][p];\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) {\n    cout << dfs(i) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e9;\nconst ld infl = 1e100;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nvint edge[150010];\ndouble dp1[150010];\ndouble dp2[150010];\n\nvoid solve1(int pos, int parent) {\n\tdouble ret = 0;\n\tif (parent != -1 && edge[pos].size() == 1) {\n\t\treturn;\n\t}\n\tfor (int to : edge[pos]) {\n\t\tif (to == parent)\tcontinue;\n\t\tsolve1(to, pos);\n\t\tret += dp1[to] + 1;\n\t}\n\tdp1[pos] = ret / (parent == -1 ? edge[pos].size() : edge[pos].size() - 1);\n}\n\nvoid solve2(int pos, int parent) {\n\t// posの答えは、\n\t// dp2[parent]からposの分を引いて、posから生える分(=dp[pos])を足す\n\tdouble ret = ((dp2[parent] * edge[parent].size()) - (dp1[pos] + 1.0));\n\tif (edge[parent].size() > 1)\t\tret /= edge[parent].size() - 1;\n\telse\tret = 0;\n\tdp2[pos] = (dp1[pos] * (edge[pos].size() - 1) + ret + 1.0) / edge[pos].size();\n\t// 隣接する頂点についても調べる\n\tfor (int to : edge[pos]) {\n\t\tif (to == parent)\tcontinue;\n\t\tsolve2(to, pos);\n\t}\n}\n\nint main() {\n\tint n;\tcin >> n;\n\tsrep(i, 1, n) {\n\t\tint u, v;\tcin >> u >> v;\tu--;\tv--;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\t// 頂点1をルートとして頂点1の答えを求める\n\tsolve1(0, -1);\n\t// 今までの計算結果を利用して他の頂点の答えも求める\n\tdp2[0] = dp1[0];\n\trep(i, edge[0].size()) {\n\t\tsolve2(edge[0][i], 0);\n\t}\n\trep(i, n)\tprintf(\"%.15lf\\n\", dp2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nvector<int> edge [150001];\ndouble dp [150001];\ndouble dp2 [150001];\n\ndouble dfs(int curr,int prev)\n{\n\tint num = 0;\n\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\tdp [curr] += dfs(it,curr) + 1.0;\n\t\tnum++;\n\t}\n\tif(num){\n\t\tdp [curr] /= num;\n\t}\n\treturn dp [curr];\n}\n\nvoid dfs2(int curr,int prev,double par)\n{\n\tdp2 [curr] = par;\n\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\tint num = edge [curr].size();\n\t\tif(curr == 1){\n\t\t\tif(num > 1){\n\t\t\t\tdfs2(it,curr,(dp [curr] * num - (dp [it] + 1.0)) / (num - 1) + 1.0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs2(it,curr,1.0);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(num > 1){\n\t\t\t\tdfs2(it,curr,(dp [curr] * (num - 1) + dp2 [curr] - (dp [it] + 1.0)) / (num - 1) + 1.0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs2(it,curr,1.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tdfs(1,-1);\n\tdfs2(1,-1,0);\n\tFOR(i,1,N + 1){\n\t\tint num = edge [i].size();\n\t\tif(i == 1){\n\t\t\tprintf(\"%.10f\\n\",dp [i]);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%.10f\\n\",(dp [i] * (num - 1) + dp2 [i]) / num);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i].first;\n\t\tif (v == prev) continue;\n\t\t\n\t\tcnt++;\n\t\tres += dfs(v, g[u][i].second, u) + 1;\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = res / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i) + 1;\n\t\t\n\t\tans /= g[i].size();\n\t\t\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<random>\n\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll mo = 1e9+7;\nconstexpr int inf = 1<<30;\nconstexpr ll infl = 1ll<<60;\nusing namespace std;\nint n;\nvector<int> E[200000];\nvector<double> ret(200000);\nvoid dfs(int u,int pre){\n    double r = 0.0;\n    int ch = 0;\n    for(auto v : E[u])if(pre != v){\n        dfs(v,u);\n        r += ret[v] + 1.0;\n        ch++;\n    }\n    if(ch >= 1) ret[u] = r/ch;\n}\nvoid dfs2(int u,double pv,int pre){\n    double r = 0.0;\n    for(auto v : E[u]){\n        if(pre == v) r += pv + 1.0;\n        else r += ret[v] + 1.0;\n    }\n    ret[u] =r / E[u].size();\n    for(auto v :E[u])if(pre != v){\n        dfs2(v,(r-ret[v]-1.0)/max(1,(int)(E[u].size() - 1)),u);\n    }\n}\nint main(){\n    cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    \n    cin>>n;\n    for(int i=0;i<n-1;++i){\n        int u,v;\n        cin>>u>>v;\n        u--;v--;\n        E[u].push_back(v);\n        E[v].push_back(u);\n    }\n    dfs(0,-1);\n    dfs2(0,0,-1);\n    \n    for(int i=0;i<n;++i)cout << fixed << std::setprecision(10) << ret[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** Template Begin ***/\n\n#define USING_BOOST\n#define USING_NAMESPACE\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nauto init_ = [] {\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10);\n    return 0;\n}();\n\ntemplate <typename T>\ninline T in() {\n    T x;\n    std::cin >> x;\n    return x;\n}\n\ntemplate <typename T>\ninline void in(T &x) {\n    std::cin >> x;\n}\n\ntemplate <typename T, typename... Ts>\ninline void in(T &t, Ts &... ts) {\n    std::cin >> t;\n    in(ts...);\n}\n\ntemplate <typename T, typename U = std::vector<T>>\ninline U vin(int n) {\n    U v(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> v[i];\n    }\n    return v;\n}\n\ntemplate <typename T, typename U = std::vector<T>, typename V = std::vector<U>>\ninline V vin(int h, int w) {\n    V vv(h, U(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            std::cin >> vv[i][j];\n        }\n    }\n    return vv;\n}\n\ntemplate <typename T>\ninline void out(const T &x) {\n    std::cout << x << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T, typename... Ts>\ninline void out(const T &t, const Ts &... ts) {\n    std::cout << t << delimiter;\n    out(ts...);\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int n) {\n    for (int i = 0; i < n; ++i) {\n        if (i) std::cout << delimiter;\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int h, int w) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (j) std::cout << delimiter;\n            std::cout << v[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\ntemplate <typename T, size_t D>\nstruct multi_vector_type {\n    using type = std::vector<typename multi_vector_type<T, D - 1>::type>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 1> {\n    using type = std::vector<T>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 0> {\n    using type = T;\n};\n\ntemplate <typename T, size_t D>\nusing multi_vector = typename multi_vector_type<T, D>::type;\n\ntemplate <typename T, size_t D, class = typename std::enable_if<D == 0>::type>\nT make_vector(const T &val = T()) {\n    return val;\n}\n\ntemplate <typename T, size_t D = 1, typename... Ts,\n          class = typename std::enable_if<D != 0>::type>\nmulti_vector<T, D> make_vector(size_t n, Ts &&... args) {\n    return multi_vector<T, D>(n, make_vector<T, D - 1>(args...));\n}\n\nnamespace detail {\n\ntemplate <typename F>\nstruct Debug {\n    const char *delim_ = \"\\n\";\n    F fun;\n\n    Debug(F f) : fun(f) {}\n\n    ~Debug() { fun(delim_); }\n\n    Debug &delim(const char *d) {\n        delim_ = d;\n        return *this;\n    }\n};\n\nstd::deque<std::string> split(const std::string &s, char c) {\n    std::deque<std::string> v;\n    std::stringstream ss(s);\n    std::string x;\n    while (std::getline(ss, x, c)) v.emplace_back(x);\n    return v;\n}\n\ntemplate <typename T>\nvoid deb(const char *delim, std::deque<std::string> v, T a) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << '\\n';\n    std::cerr << std::flush;\n}\n\ntemplate <typename T, typename... Args>\nvoid deb(const char *delim, std::deque<std::string> v, T a, Args... args) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << delim;\n    v.pop_front();\n    deb(delim, std::move(v), args...);\n}\n\ntemplate <typename... Args>\nauto wrap(std::deque<std::string> v, Args... args) {\n    auto f = [=](const char *delim = \"\\n\") { deb(delim, v, args...); };\n\n    return Debug<decltype(f)>(f);\n}\n}\n\n#define debug(args...) ::detail::wrap(::detail::split(#args, ','), args)\n\n#ifdef USING_BOOST\n\n#include <boost/math/common_factor.hpp>\n#include <boost/range.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/algorithm_ext.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/numeric.hpp>\n\ninline auto rep(int begin, int end) {\n    if (begin > end) {\n        return boost::irange(0, 0);\n    } else {\n        return boost::irange(begin, end);\n    }\n}\n\ninline auto rep(int begin, int end, int step) {\n    if ((step > 0 && begin > end) || (step < 0 && begin < end)) {\n        return boost::irange(0, 0, step);\n    } else {\n        return boost::irange(begin, end, step);\n    }\n}\n\n#endif\n\n#ifdef USING_NAMESPACE\nusing namespace std;\n\n#ifdef USING_BOOST\nusing namespace boost;\nusing namespace boost::adaptors;\n#endif\n#endif\n\n/*** Template End ***/\n\nint n;\nvector<vector<int>> graph;\nvector<bool> used;\n\ndouble dfs(int i) {\n    used[i] = true;\n\n    int cnt = 0;\n    double res = 0.0;\n\n    for (int to : graph[i]) {\n        if (used[to]) {\n            continue;\n        }\n\n        cnt++;\n\n        res += dfs(to) + 1.0;\n    }\n\n    if (cnt == 0) {\n        return 0.0;\n    } else {\n        return res / cnt;\n    }\n}\n\nint main() {\n    in(n);\n\n    graph.resize(n);\n    used.resize(n);\n\n    for (int i : rep(0, n - 1)) {\n        int u, v;\n        in(u, v);\n        u--;\n        v--;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i : rep(0, n)) {\n        fill(used, false);\n        out(dfs(i));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long int;\nusing P = std::pair<int, int>;\n\n#define rep(i, n) for (int i = 1; i <= (n); ++i)\n#define rag(con) std::begin(con), std::end(con)\n\nconstexpr int MAX = 1e5 + 1e4 + 10;\n\nstd::vector<int> g[MAX];\n\ndouble pre[MAX];\ndouble parv;\n\nbool used[MAX];\n\ndouble ans[MAX];\n\nvoid dfs0(int v)\n{\n\n    used[v] = 1;\n\n    int cnt = 0;\n    for (auto c : g[v])\n    {\n        if (!used[c])\n        {\n            dfs0(c);\n            pre[v] += pre[c];\n            ++cnt;\n        }\n    }\n\n    if (v == 1)\n    {\n        pre[v] /= (double)g[v].size();\n        pre[v] += 1.0;\n    }\n    else if (cnt != 0)\n    {\n        pre[v] /= (double)(g[v].size() - 1);\n        pre[v] += 1.0;\n    }\n}\n\nvoid dfs(int v)\n{\n    used[v] = 1;\n\n    if (pre[v] == 0.0)\n        ans[v] = parv + 1.0;\n    else if (v == 1)\n        ans[v] = pre[v];\n    else\n        ans[v] = ((pre[v] - 1.0) * (double)(g[v].size() - 1) + parv) / (double)g[v].size() + 1.0;\n\n    std::cerr << v << ' ' << parv << ' ' << ans[v] << std::endl;\n\n    double pparv = parv;\n\n    for (auto c : g[v])\n    {\n        if (!used[c])\n        {\n            if (v == 1)\n            {\n                if (g[v].size() != 1)\n                    parv = ((pre[v] - 1.0) * (double)g[v].size() - pre[c]) / (double)(g[v].size() - 1) + 1.0;\n            }\n            else\n                parv = pre[v] + (parv - pre[c]) / (double)(g[v].size() - 1);\n\n            dfs(c);\n\n            parv = pparv;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n\n    std::cin >> n;\n\n    rep(i, n - 1)\n    {\n        int u, v;\n        std::cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs0(1);\n\n    rep(i, n)\n            std::cerr\n        << pre[i] << ' ';\n    std::cerr << std::endl;\n\n    std::memset(used, 0, sizeof(used));\n\n    dfs(1);\n\n    rep(i, n)\n            std::cout\n        << std::fixed << ans[i] << std::setprecision(8) << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing Graph = vector<vector<int>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nGraph g;\n// d[i] := 頂点 i に移動するとき, それ以降に移動する回数の期待値\nvector<double> d;\nvoid dfs(int u, int p) {\n    double sum = 0;\n    int cnt = 0;\n    for (int v: g[u]) if (v != p) {\n        dfs(v, u);\n        sum += d[v] + 1;\n        cnt++;\n    }\n    d[u] = (cnt ? sum / cnt : 0);\n}\nvector<double> res;\nvoid dfs2(int u, int p, double d_par) {\n    double total = 0;\n    for (int v: g[u]) total += (v == p ? d_par : d[v]) + 1;\n    res[u] = total / g[u].size();\n    for (int v: g[u]) if (v != p) {\n        double nd_par = (total - (d[v] + 1)) / max(1, (int)g[u].size() - 1);\n        dfs2(v, u, nd_par);\n    }\n}\n\n#include <iomanip>\nint main() {\n    cout << fixed << setprecision(12);\n    int n; cin >> n;\n    g.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        g[u].emplace_back(v);\n        g[v].emplace_back(u);\n    }\n    d.resize(n);\n    dfs(0, -1);\n    res.resize(n);\n    dfs2(0, -1, 0);\n    for (auto e: res) cout << e << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nconst int MAX_N = 150000;\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\n\ndouble dfs(int now, int pre, const Graph& G) {\n    if (pre != -1 && G[now].size() == 1) return dp[now] = 0.;\n    double& ret = dp[now];\n    int num_ch = 0;\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        ret += dfs(nxt, now, G);\n        num_ch++;\n    }\n    ret /= num_ch;\n    ret += 1.;\n    return ret;\n}\n\nvoid dfs2(int now, int pre, const Graph& G) {\n    double p = G[pre].size();\n    if (pre == 0) {\n        if (p == 1) dp2[now] = 1;\n        else dp2[now] = 1 + (dp[pre] - (dp[now] + 1) / p) * p / (p - 1);\n    }\n    else {\n        dp2[now] = ((dp2[pre] + 1) + (dp[pre] + 1) * (p - 1) - (dp[now] + 2)) / (p - 1);\n    }\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs2(nxt, now, G);\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph G(n);\n    rep(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    dfs(0, -1, G);\n\n    // rep(i, n) {\n    //     cout << fixed << setprecision(10) << dp[i] << endl;\n    // }\n    // cout << endl;\n\n    for (auto ch : G[0]) dfs2(ch, 0, G);\n\n    // rep(i, n) {\n    //     cout << fixed << setprecision(10) << dp2[i] << endl;\n    // }\n    // cout << endl;\n\n    rep(i, n) {\n        int p = G[i].size();\n        double ans = i == 0 ? dp[i] : (dp[i] * (p - 1) + dp2[i]) / p;\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n// #include<iostream>\n// #include<iomanip>\n// #include<algorithm>\n// #include<vector>\n// #include<stack>\n// #include<queue>\n// #include<map>\n// #include<set>\n// #include<tuple>\n// #include<cmath>\n// #include<random>\n// #include<cassert>\n// #include<bitset>\n// #include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\n// using namespace std;\n// using ll = long long;\n\n/// --- ReRooting {{{ ///\n\n#include <cassert>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\ntemplate < class Monoid >\nstruct ReRooting {\n  using size_type = std::size_t;\n  using edge_type = std::tuple< size_type, size_type, size_type >;\n  using graph_type = std::vector< std::vector< edge_type > >;\n  using T = typename Monoid::T;\n  using dig_f_type =\n      std::function< T(T, size_type edge_id, size_type from, size_type to) >;\n  using after_f_type =\n      std::function< T(T, size_type vertex_id, size_type degree_of_this) >;\n  using vector_bool_type = std::vector< int >;\n  graph_type graph;\n\n  size_type n;\n\n  std::vector< std::vector< T > > dp;\n  std::vector< vector_bool_type > did;\n  std::vector< std::vector< T > > L;\n  std::vector< std::vector< T > > R;\n\n  dig_f_type dig;\n  after_f_type after;\n  static T default_dig(const T &a, ...) { return a; }\n  static T default_after(const T &a, ...) { return a; }\n\n  bool built;\n\n  ReRooting() {}\n  ReRooting(size_type n, dig_f_type dig = default_dig, after_f_type after = default_after)\n      : dig(dig), after(after) {\n    clear(n);\n  }\n  ReRooting(std::vector< std::vector< int > > graph, dig_f_type dig = default_dig,\n            after_f_type after = default_after)\n      : ReRooting(graph.size(), dig, after) {\n    for(size_type from = 0; from < n; from++) {\n      for(auto to : graph[from])\n        if(static_cast< size_type >(to) < from) {\n          add_edge(from, to);\n        }\n    }\n  }\n\n  void clear() { clear(n); }\n\n  void clear(size_type n) {\n    this->n = n;\n    graph.resize(n);\n    graph.assign(n, std::vector< edge_type >());\n    dp.resize(n);\n    dp.assign(n, std::vector< T >());\n    did.resize(n);\n    did.assign(n, vector_bool_type());\n    L.resize(n);\n    L.assign(n, std::vector< T >());\n    R.resize(n);\n    R.assign(n, std::vector< T >());\n    built = 0;\n  }\n\n  size_type added = 0;\n  void add_edge(size_type a, size_type b, size_type id = static_cast< size_type >(-1)) {\n    assert(!built);\n    assert(a < n && b < n && a != b);\n    if(id == static_cast< size_type >(-1)) id = added;\n    graph[a].emplace_back(b, graph[b].size(), id);\n    graph[b].emplace_back(a, graph[a].size() - 1, id);\n    added++;\n  }\n\n  void set_dig(dig_f_type dig = default_dig) { this->dig = dig; }\n\n  void set_after(after_f_type after = default_after) { this->after = after; }\n\n  void build() {\n    assert(!built);\n    built = 1;\n    if(n == 0) return;\n\n    assert(added == n - 1);\n    for(size_type i = 0; i < n; i++) {\n      dp[i].resize(graph[i].size() + 1);\n      did[i].resize(graph[i].size() + 1);\n      L[i].reserve(graph[i].size() + 1);\n      R[i].reserve(graph[i].size() + 1);\n    }\n    dfs_first(0, graph[0].size());\n  }\n\npublic:\n  T dfs(size_type i) {\n    return dfs(i, graph[i].size());\n  }\n\n  T dfs_from(size_type i, size_type j) {\n    assert(built);\n    assert(j < n);\n    // TODO : どうする?\n    // return dfs(i, , 0);\n  }\n\nprivate:\n  T proceed_root(size_type i) {\n    for(auto to : graph[i]) {\n      size_type j, rev, edge_id;\n      std::tie(j, rev, edge_id) = to;\n      L[i].push_back(dig(dp[j][rev], edge_id, i, j));\n    }\n    R[i] = L[i];\n    for(int x = 1; x < static_cast<int>(graph[i].size()); x++) L[i][x] = Monoid::op(L[i][x - 1], L[i][x]);\n    for(int x = static_cast<int>(graph[i].size()) - 2; x >= 0; x--) R[i][x] = Monoid::op(R[i][x], R[i][x + 1]);\n    return L[i].back();\n  }\n\n  void dfs_first(size_type i0, size_type p0) {\n    std::vector< std::tuple< size_type, size_type, bool > > stk;\n    stk.reserve(n);\n    stk.emplace_back(i0, p0, 0);\n    while(stk.size()) {\n      size_type i, p;\n      bool up;\n      std::tie(i, p, up) = stk.back();\n      stk.pop_back();\n      int deg = graph[i].size() - (p != graph[i].size() ? 1 : 0);\n      if(up) {\n        did[i][p] = 1;\n        T res = Monoid::identity();\n        if(p == graph[i].size()) {\n          res = proceed_root(i);\n        } else {\n          for(size_type x = 0; x < graph[i].size(); x++)\n            if(x != p) {\n              size_type j, rev, edge_id;\n              std::tie(j, rev, edge_id) = graph[i][x];\n              res = Monoid::op(res, dig(dp[j][rev], edge_id, i, j));\n            }\n        }\n        dp[i][p] = after(res, i, deg);\n      } else {\n        stk.emplace_back(i, p, 1);\n        for(size_type x = 0; x < graph[i].size(); x++)\n          if(x != p) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            stk.emplace_back(j, rev, 0);\n          }\n      }\n    }\n  }\n  T dfs(size_type i0, size_type p0) {\n    assert(built);\n    assert(i0 < n);\n    assert(p0 <= graph[i0].size());\n    if(did[i0][p0]) return dp[i0][p0];\n\n    std::vector< std::tuple< size_type, size_type, bool > > stk;\n    stk.reserve(n);\n    stk.emplace_back(i0, p0, 0);\n    while(stk.size()) {\n      size_type i, p;\n      bool up;\n      std::tie(i, p, up) = stk.back();\n      stk.pop_back();\n      if(up) {\n        int deg = graph[i].size() - (p != graph[i].size() ? 1 : 0);\n        did[i][p] = 1;\n        T res = Monoid::identity();\n        if(p == graph[i].size()) {\n          res = proceed_root(i);\n        } else {\n          res = Monoid::op(p >= 1 ? L[i][p - 1] : Monoid::identity(),\n              p + 1 < R[i].size() ? R[i][p + 1] : Monoid::identity());\n        }\n        dp[i][p] = after(res, i, deg);\n      } else {\n        stk.emplace_back(i, p, 1);\n        if(p == graph[i].size()) {\n          for(size_type x = 0; x < graph[i].size(); x++) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            if(!did[j][rev]) stk.emplace_back(j, rev, 0);\n          }\n        } else {\n          if(!did[i][graph[i].size()]) {\n            stk.emplace_back(i, graph[i].size(), 0);\n          }\n        }\n      }\n    }\n    return dp[i0][p0];\n  }\n};\n\n/// }}}--- ////\n\n\n// includes {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <vector>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// my monoid, m-act {{{\nstruct MyMonoid {\n  using T = double;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n// }}}\n\nusing rerooting = ReRooting< MyMonoid >;\nusing T = rerooting::T;\n\nT dig(T a, int id, int from, int to) { return a + 1; }\n\nT after(T a, int i, int deg) {\n  if(deg == 0) return a;\n  return a / deg;\n}\n\nconst int N = 1e5;\nstd::vector< std::vector< int > > g;\nint n;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; i++) {\n    int a, b;\n    std::cin >> a >> b;\n    a--;\n    b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  rerooting rr(g, dig, after);\n  rr.build();\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << rr.dfs(i) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\n\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing edge_t=pair<int,double>;\nusing vve=vector<vector<edge_t> >;\n\n\ndouble solve_r(vve& v, int cur, int prev)\n{\n\tdouble ret, r;\n\tint n;\n\n\tn=v[cur].size();\n\tif(prev>=0) n--;\n\tif(n==0)\n\t{\n\t\treturn 0.0;\n\t}\n\n\tret=0.0;\n\tr=1.0/n;\n\tfor(auto& e: v[cur])\n\t{\n\t\tif(e.first==prev) continue;\n\t\tif(e.second<0)\n\t\t{\n\t\t\te.second=solve_r(v, e.first, cur);\n\t\t}\n\t\tret+=(e.second+1)*r;\n\t}\n\treturn ret;\n}\n\n\nvoid solve(vector<double>& r, vve& v)\n{\n\tfor(int i=1;i<v.size();i++)\n\t{\n\t\tfor(auto& e: v[i])\n\t\t{\n\t\t\tif(e.second<0)\n\t\t\t{\n\t\t\t\te.second=solve_r(v, e.first, i);\n\t\t\t}\n\t\t\tr[i]+=e.second+1;\n\t\t}\n\t\tr[i]/=v[i].size();\n\t}\n}\n\n\nint main(void)\n{\n\tvector<double> r;\n\tvve v;\n\tint n, a, b;\n\n\twhile(scanf(\"%d\", &n)==1)\n\t{\n\t\tv.clear();\n\t\tv.resize(n+1);\n\t\tr.clear();\n\t\tr.resize(n+1);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tv[a].push_back(make_pair(b, -1.0));\n\t\t\tv[b].push_back(make_pair(a, -1.0));\n\t\t}\n\t\tsolve(r, v);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tprintf(\"%f\\n\", r[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n#include <cassert>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef pair<int,pii> pip;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\n\nint gcd(int a, int b){if(b==0) return a;return gcd(b,a%b);}\nint lcm(int a, int b){return a/gcd(a,b)*b;}\n\n\nstruct edge{\n  int to, cost;\n};\nvector<vector<edge>  >g;\nvector<double> p;//期待値\n\nvoid dfs(int now, int par){\n    int cnt = 0;\n    for(auto e: g[now])if(e.to != par){\n        dfs(e.to,now);\n        p[now] += p[e.to];\n        cnt++;\n    }\n    if(cnt){\n        p[now] /= cnt;\n        p[now] += 1;\n    }\n}\n\nvoid dfs2(int now, double p_par, int par){\n    double sum = 0;\n    int cnt = 0;\n    for(auto e: g[now]){\n        if(e.to == par){\n            sum += p_par;\n        }else{\n            sum += p[e.to];\n        }\n        cnt++;\n    }\n    p[now] = sum/cnt + 1;\n    for(auto e: g[now])if(e.to != par){\n        double p_next = sum - p[e.to];\n        if(cnt > 1)p_next /= cnt-1, p_next += 1;\n        dfs2(e.to, p_next, now);\n    }\n}\n\nsigned main(void) {\n    int n;\n    cin >> n;\n    g.resize(n);\n    p = vector<double>(n,0);\n    rep(i,n-1){\n        int a,b,c;\n        cin >> a >> b;\n        a--,b--;\n        edge e1 = {b,1};\n        g[a].push_back(e1);\n        edge e2 = {a,1};\n        g[b].push_back(e2);\n    }\n    dfs(0,-1);\n    //rep(i,n)cout << shosu(10) << p[i] << endl;\n    dfs2(0,0,-1);\n    rep(i,n){\n        cout << shosu(10) << p[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9+10;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// https://ei1333.hateblo.jp/entry/2017/04/10/224413\n\nvll G[150001];\ndouble ee[150001], ans[150001];\n\nvoid dfs1(int v, int p){\n  double res=0;\n  int child=0;\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs1(nv,v);\n    res+=ee[nv]+1.0;\n    child++;\n  }\n  ee[v]=0;\n  if(child>=1) ee[v]+=res/child;\n}\n\nvoid dfs2(int v, double d_par, int p){\n  double res=0;\n  for(auto &nv: G[v]){\n    if(nv==p) res+=d_par+1.0;\n    else res+=ee[nv]+1.0;\n  }\n  ans[v]=res/G[v].size();\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs2(nv, (res-ee[nv]-1.0)/max(1, (int)G[v].size()-1) , v); // vにおける期待値から部分木nv以降の期待値を除外して渡す\n  }\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  \n  int n; cin>>n;\n  rep(i,n-1){\n    ll a,b; cin>>a>>b;\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  dfs1(0,-1);\n  dfs2(0,0,-1);\n  rep(i,n){\n    cout<<std::setprecision(10)<<ans[i]<<endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n\nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, double>U[150000];\ndouble Q[150000];//Qからの和\ndouble saiki(int i, int j) {\n\tif (rinsetu[j].size() == 1)return 1;\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tif (Q[j] != -1) {\n\t\treturn (Q[j] - saiki(j, i)) / (rinsetu[j].size()-1)+1;\n\t}\n\tdouble F = 0;\n\tdouble K = 1;\n\tbool T = true;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t\tif (U[j][x] == 0) {\n\t\t\t\tT = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF += U[j][x];\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tif(T)Q[j] = F;\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfill(Q, Q + a, -1);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b,ok,ch[150000],L;\nvector<int> v[150000];\nld ans[150000],dp[150000],tmp;\nmap<int,int>mp;\n\nvoid dfs(int A,int B){\n    ld tmp=0;\n    for(auto x:v[A]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        dfs(x,B);\n        tmp+=dp[x]+1.0;\n        //dp[A]=max(dp[A],dp[x]+1.0);\n    }\n    if(A==B)dp[A]=tmp/mp[A];\n    else if(mp[A]>1)dp[A]=tmp/(mp[A]-1);\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        mp[a]++;\n        mp[b]++;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(auto x:mp){\n        if(x.second>2)ok=1;\n    }\n    if(ok==0){\n        for(int i=0;i<n;i++){\n            if(mp[i]==1)ans[i]=n-1;\n            else ans[i]=(ld)(n-1)/2.0;\n        }\n    }\n    else{\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){dp[j]=0;ch[j]=0;}\n            ch[i]=1;\n            dfs(i,i);\n            //cout<<dp[i]<<endl;\n            //if(mp[i]==1)ans[i]=n-1;\n            ans[i]=dp[i];//(ld)(mp[i]);\n        }\n    }\n    for(int i=0;i<n;i++){\n        cout<<setprecision(15)<<ans[i]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\nint n;\nvector<int> e[150000];\nvector<double> val[150000];\n\ndouble dfs(int x, int y){\n    if(val[x][y] > -0.5) return val[x][y];\n    int to = e[x][y];\n    if(e[to].size() == 1){\n        return val[x][y] = 1.0;\n    }\n    double ret = 0.0;\n    rep(i,e[to].size()){\n        if(e[to][i] == x) continue;\n        ret += dfs(to, i)+1.0;\n    }\n    ret /= (double)(e[to].size()-1);\n    return val[x][y] = ret;\n}\n\nint main(){\n    I(n);\n    rep(i,n-1){\n        int u,v; I(u,v);\n        u--; v--;\n        e[u].push_back(v);\n        val[u].push_back(-1.0);\n        e[v].push_back(u);\n        val[v].push_back(-1.0);\n    }\n    rep(i,n){\n        rep(j,e[i].size()){\n            dfs(i,j);\n        }\n    }\n    rep(i,n){\n        double out = 0.0;\n        rep(j,val[i].size()) out += val[i][j];\n        out /= (double)val[i].size();\n        printf(\"%.9f\\n\",out);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[100100];\nmap <pair <int, int> , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, p)] != 0)\n        return mp[make_pair(v, p)];\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, t / k) + t / k;\n    }\n    mp[make_pair(v, p)] = ans;\n    return ans;\n}\nint main()\n{\n    int n, i, x, y;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = std::int_fast64_t;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nusing value = long double;\nconst value id = 0.;\nvalue marge(value a, value b) { return a + b; }\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<int> a(n - 1), b(n - 1);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\n\t\tg[a[i]].push_back(i);\n\t\tg[b[i]].push_back(i);\n\t}\n\n\tstd::vector<std::map<int, value>> dp(n);\n\tauto solve = [&](auto&& solve, int v, int par, bool flag) -> value {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\t\t\n\t\tvalue res = id;\n\t\tconst int deg = g[v].size() - (par != -1);\n\t\tif(par == -1 or flag) {\n\t\t\tstd::vector<value> ret;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tint id = g[v][i];\n\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\tif(to == par) continue;\n\t\t\t\t\n\t\t\t\tret.push_back(solve(solve, to, v, flag) + 1.);\n\t\t\t}\n\t\t\t\n\t\t\tstd::vector<value> R(ret.size() + 1, id);\n\t\t\tfor(int i = (int)R.size() - 1; i > 0; i--) R[i - 1] = marge(R[i], ret[i - 1]);\n\t\t\tif(par == -1) {\n\t\t\t\tvalue L = id;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tint id = g[v][i];\n\t\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\t\t\n\t\t\t\t\tlong double tmp = marge(L, R[i + 1]);\n\t\t\t\t\tif(deg - 1) tmp = tmp / (deg - 1);\n\t\t\t\t\tdp[v][to] = tmp;\n\t\t\t\t\tL = marge(L, ret[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres = R[0];\n\t\t} else {\n\t\t\tsolve(solve, v, -1, flag);\n\n\t\t\tres = solve(solve, v, par, flag);\n\t\t}\n\t\tif(deg) res = res / deg;\n\n\t\treturn dp[v][par] = res;\n\t};\n\tsolve(solve, 0, -1, true);\n\n\tfor(int i = 0; i < n; i++) printf(\"%.12Lf\\n\", solve(solve, i, -1, false));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v, connect[1001];\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t\tconnect[u]++;\n\t\tconnect[v]++;\n\t}\n\n\tfor (int i = 1; i <= n; i++){\n\t\tif (connect[i] == 1){\n\t\t\tcout << n - 1 << endl;\n\t\t}\n\t\telse{\n\t\t\tfloat num = n - 1;\n\t\t\tcout << num / 2 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], deg[150000];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    int isLine = 1;\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        deg[u]++;\n        deg[v]++;\n        E[i][0] = u;\n        E[i][1] = v;\n    }\n\n    rep(i, N)if (deg[i] > 2)isLine = 0;\n    if (isLine) {\n        double ans = 0.5*(N - 1);\n        rep(i, N) {\n            if(deg[i]==2)printf(\"%.10f\\n\", ans);\n            else printf(\"%d\\n\", N - 1);\n        }\n        exit(0);\n    }\n    rep(i, N - 1)rep(j, 2)G[E[i][j]].push_back(i);\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.10f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint n, u, v;\ndouble ans[150051], dp[150051];\nint child[150051];\nvector<int> graph[150051];\n\nvoid dfs1(int v, int p)\n{\n  for (int cv : graph[v])\n  {\n    if (cv == p)\n      continue;\n    dfs1(cv, v);\n    dp[v] += dp[cv] + 1;\n    child[v] += 1;\n  }\n  if (child[v] > 1)\n    dp[v] /= child[v];\n}\n\nvoid dfs2(int v, int p)\n{\n  // vを根とした状態になってる\n\n  double sum = 0.0;\n  for (int cv : graph[v])\n  {\n    sum += dp[cv] + 1;\n  }\n  dp[v] = sum / graph[v].size();\n  ans[v] = dp[v];\n\n  for (int cv : graph[v])\n  {\n    if (cv == p)\n      continue;\n    dp[v] = sum - dp[cv] - 1;\n    if (graph[v].size() > 1)\n    {\n      dp[v] /= graph[v].size() - 1;\n    }\n    dfs2(cv, v);\n    dp[v] = sum / graph[v].size();\n  }\n}\n\nint main()\n{\n  cin >> n;\n  for (int i = 0; i < n - 1; ++i)\n  {\n    cin >> u >> v;\n    --u, --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  dfs1(0, 0);\n  dfs2(0, 0);\n\n  cout << fixed << setprecision(10);\n  for (int i = 0; i < n; ++i)\n    cout << ans[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size()-1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3727691#1\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\nusing LD = long double;\n#define int LL\n#define upto(a, b, i) for(int i = (a), b_ = (b); i <= b_; ++i)\n#define uptil(a, b, i) for(int i = (a), b_ = (b); i < b_; ++i)\n#define downto(a, b, i) for(int i = (a), b_ = (b); i >= b_; --i)\n#define downtil(a, b, i) for(int i = (a), b_ = (b); i > b_; --i)\n#define times(n, i) uptil(0, n, i)\n#define rtimes(n, i) downto((n) - 1, 0, i)\n#define sp << \" \"\n#define ln << \"\\n\"\n#define size(v) ((int)(v).size())\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vec<vec<T>>;\n\nvvec<int> edges;\nvec<pair<LD, int>> om0, oms;\nvec<LD> oa0, oap, ans;\n\ninline LD CORE(LD a, int b) { return b == 0 ? 0 : a / b; }\n\nvoid dfs1(int a, int p) {\n  LD s = 0;\n  int n = 0;\n  for(int c : edges[a]) {\n    if(c == p) continue;\n    dfs1(c, a);\n    s += oa0[c] + 1;\n    ++n;\n  }\n  om0[a] = {s, n}; // FOLD\n  oa0[a] = CORE(s, n);\n}\n\nvoid dfs2(int a, int p) {\n  if(a == 0) {\n    oms[0] = om0[0];\n  } else {\n    oap[a] = CORE(oms[p].first - oa0[a] - 1, oms[p].second - 1); // RMV\n    LD s = 0;\n    int n = 0;\n    for(int c : edges[a]) {\n      if(c == p) {\n        s += oap[a] + 1;\n        ++n;\n      } else {\n        s += oa0[c] + 1;\n        ++n;\n      }\n    }\n    oms[a] = {s, n}; // FOLD\n  }\n  ans[a] = CORE(oms[a].first, oms[a].second);\n\n  for(int c : edges[a]) {\n    if(c != p) dfs2(c, a);\n  }\n}\n\nvoid solve() {\n  int N; cin >> N;\n  edges.clear(); edges.resize(N);\n  om0.clear(); om0.resize(N);\n  oms.clear(); oms.resize(N);\n  oa0.clear(); oa0.resize(N);\n  oap.clear(); oap.resize(N);\n  ans.clear(); ans.resize(N);\n\n  times(N-1, i) {\n    int S, T;\n    cin >> S >> T; --S; --T;\n    edges[S].push_back(T);\n    edges[T].push_back(S);\n  }\n\n  dfs1(0, 0);\n  dfs2(0, 0);\n  //times(N, i) cerr << om0[i].first sp << om0[i].second sp sp; cerr ln;\n  //times(N, i) cerr << oa0[i] sp; cerr ln;\n  //times(N, i) cerr << oap[i] sp; cerr ln;\n  //times(N, i) cerr << oms[i].first sp << oms[i].second sp sp; cerr ln;\n  times(N, i) cout << ans[i] ln;\n}\n\nsigned main(){\n  cin.tie(0);\n  cerr.tie(0);\n  ios::sync_with_stdio(0);\n  cout << fixed << setprecision(20);\n  cerr << fixed << setprecision(6);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 INF = 1e18 + 7;\n\n\nsigned main(){\n    int n;\n    cin >> n;\n    if(n == 1){\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < n - 1; ++i){\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        edges[a].emplace_back(b);\n        edges[b].emplace_back(a);\n    }\n\n    vector<double> mem(n, -1);\n    vector<int> par(n);\n    vector<vector<int>> childs(n);\n    function<void(int)> f = [&](int from){\n        mem[from] = 0;\n        int cnt = 0;\n        for(auto& to : edges[from]){\n            if(mem[to] != -1)\n                continue;\n            childs[from].emplace_back(to);\n            par[to] = from;\n            f(to);\n            ++cnt;\n            mem[from] += mem[to] + 1;\n        }\n        if(cnt)\n            mem[from] /= cnt;\n    };\n    f(0);\n\n    vector<double> ans(n, -1);\n    function<void(int, double, int)> g = [&](int from, double sum, int cnt){\n        for(auto& to : childs[from]){\n            sum += mem[to] + 1;\n            ++cnt;\n        }\n        ans[from] = sum / cnt;\n        for(auto& to : childs[from]){\n            double val = sum;\n            val -= mem[to] + 1;\n            // cout << \"val : \" << val << \" - >  cnt : \" << cnt << endl;\n            if(cnt - 1)\n                val /= cnt - 1;\n            else\n                val = 0;\n            val += 1;\n\n            g(to, val, 1);\n        }\n    };\n    g(0, 0, 0);\n\n    for(auto& x : ans)\n        printf(\"%.20lf\\n\", x);\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a <= x && x < b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\nstd::ostream& operator<<(std::ostream& os, const PAIR& r) {\n\tos << \"(\" << r.first << \", \" << r.second << \")\";\n\treturn os;\n}\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tstd::vector<double> sub(n, 0);\n\tstd::function<double(int, int)> dfs1 = [&](int x, int par) {\n\t\tdouble& res = sub[x] = 0;\n\t\tfor (auto to : g[x]) {\n\t\t\tif (to == par) continue;\n\t\t\tres += (dfs1(to, x) + 1) / (g[x].size() - 1 + (x == 0));\n\t\t}\n\t\treturn res;\n\t};\n\tdfs1(0, -1);\n\n\tstd::vector<double> ans(n, 0);\n\tans[0] = sub[0];\n\tstd::function<void(int, int)> dfs2 = [&](int x, int par) {\n\t\tif (par == -1 && g[x].size() == 1) {\n\t\t\tint to = g[x][0];\n\t\t\tans[to] = (sub[to] * (g[to].size() - 1) + 1) / g[to].size();\n\t\t\tdfs2(to, x);\n\t\t}\n\t\telse {\n\t\t\tfor (auto to : g[x]) {\n\t\t\t\tif (to == par) continue;\n\t\t\t\tdouble r = ans[x];\n\t\t\t\tr *= g[x].size();\n\t\t\t\tr -= sub[to] + 1;\n\t\t\t\tr /= g[x].size() - 1;\n\t\t\t\tr += 1;\n\t\t\t\tans[to] = (r + sub[to] * (g[to].size() - 1)) / g[to].size();\n\t\t\t\tdfs2(to, x);\n\t\t\t}\n\t\t}\n\t};\n\tdfs2(0, -1);\n\t//SHOWVECTOR(sub);\n\t//SHOWVECTOR(ans);\n\tREP(i, n) {\n\t\tFOUT(12, ans[i])BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Majk\n */\n\n#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n\tint N;\n\tvector<vector<int>> E;\n\tunordered_map<pii, double> C;\n\tvector<pair<int, double>> W;\n\n\tdouble count(int u, int v) {\n\t\tauto it = C.find({u,v});\n\t\tif (it != C.end()) return it->y;\n\n\t\tdouble ans = 0.0;\n\t\tif (W[u].x != -2) {\n\t\t\tans = W[u].y;\n\t\t\tif (W[u].x != -1) ans += count(W[u].x, u);\n\t\t\tif (v != -1) ans -= count(v, u);\n\t\t} else {\n\t\t\tfor (int w: E[u]) if (v!=w) ans += count(w,u);\n\t\t\tW[u] = {v, ans};\n\t\t}\n\n\t\tint cnt = E[u].size() - (v != -1);\n\t\tif (cnt > 0) ans /= cnt;\n\t\t++ans;\n\t\treturn C[{u,v}] = ans;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tcin >> N; E.clear(); E.resize(N); W.clear(); W.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tW[i] = {-2, 0.0};\n\t\t}\n\n\t\tC.clear();\n\t\tfor (int i = 0; i < N-1; ++i) {\n\t\t\tint u,v; cin >> u >> v; --u; --v;\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\n\t\tcout << fixed << setprecision(10);\n\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << count(j, -1)-1 << '\\n';\n\t\t}\n\n\t}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target (\"avx\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define endl '\\n'\n\n#pragma region TEMPLATE\n\n/* TYPE */\ntypedef long long ll;       typedef long double ld;\ntypedef pair<int, int> pii; typedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;   typedef vector<pll> vpll;\ntypedef vector<int> vi;     typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb;\ntypedef vector<ld> vld;     typedef vector<vector<int>> vvi;\ntemplate<typename T, typename Cmp = less<>> using prique = priority_queue<T, vector<T>, Cmp>;\ntemplate<typename T> using prique_r = prique<T, greater<>>;\n/* CONSTANT */\n#define ln '\\n'\nconst int INF = 1 << 30;    const ll INFF = 1LL << 60;  const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 1e9 + 7;    const int MODD = 998244353; const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double EPS = 1e-9;    const ld PI = 3.14159265358979323846264338327950288;\nconst int dx[] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nconst int dy[] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n/* CONTAINER */\n#define PB              emplace_back\n#define ALL(v)          (v).begin(), (v).end()\n#define RALL(v)         (v).rbegin(), (v).rend()\n#define SORT(v)         sort(ALL(v))\n#define RSORT(v)        sort(RALL(v))\n#define LESS(x, val)    (lower_bound(x.begin(), x.end(), val) - x.begin())\n#define LEQ(x, val)     (upper_bound(x.begin(), x.end(), val) - x.begin())\n#define GREATER(x, val) (int)(x).size() - LEQ((x), (val))\n#define GEQ(x, val)     (int)(x).size() - LESS((x), (val))\n#define UNIQUE(v)       sort(ALL(v)); (v).erase(unique(ALL(v)), (v).end())\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value != 0> fill_v(U &u, const V... v) { u = U(v...); }\ntemplate<typename T, typename U, typename... V> enable_if_t<is_same<T, U>::value == 0> fill_v(U &u, const V... v) { for (auto &e : u) fill_v<T>(e, v...); }\n/* LOOP */\n#define _overload3(_1, _2, _3, name, ...) name\n#define _REP(i, n)      REPI(i, 0, n)\n#define REPI(i, a, b)   for (ll i = (ll)a; i < (ll)b; ++i)\n#define REP(...)        _overload3(__VA_ARGS__, REPI, _REP,)(__VA_ARGS__)\n#define _RREP(i, n)     RREPI(i, n, 0)\n#define RREPI(i, a, b)  for (ll i = (ll)a; i >= (ll)b; --i)\n#define RREP(...)       _overload3(__VA_ARGS__, RREPI, _RREP,)(__VA_ARGS__)\n#define EACH(e, v)      for (auto& e : v)\n#define PERM(v)         sort(ALL(v)); for (bool c##p = true; c##p; c##p = next_permutation(ALL(v)))\n/* INPUT */\ntemplate<typename T> void SSS(T& t) { cin >> t; }\ntemplate<typename Head, typename... Tail> void SSS(Head&& head, Tail&&... tail) { cin >> head; SSS(tail...); }\n#define SS(T, ...)      T __VA_ARGS__; SSS(__VA_ARGS__);\n#define SV(T, v, n)     vector<T> v(n); for (auto& i : v) cin >> i;\n#define SVV(T, v, n, m) vector<vector<T>> v(n, vector<T>(m)); for (auto& r : v) for (auto& i : r) cin >> i;\n/* OUTPUT */\n// PROTOTYPE DECLARATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j);\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t);\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)> = nullptr> ostream& operator<<(ostream &os, const C &c);\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j);\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j);\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j);\n// IMPLEMENTATION\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &j) { return os << '{' << j.first << \", \" << j.second << '}'; }\ntemplate<size_t num = 0, typename... T> enable_if_t<num == sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) {}\ntemplate<size_t num = 0, typename... T> enable_if_t<num <  sizeof...(T)> PRINT_TUPLE(ostream &os, const tuple<T...> &t) { os << get<num>(t); if (num + 1 < sizeof...(T)) os << \", \"; PRINT_TUPLE<num + 1>(os, t); }\ntemplate<typename... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { PRINT_TUPLE(os << '{', t); return os << '}'; }\ntemplate<class C, enable_if_t<!is_same<C, string>::value, decltype(declval<const C &>().begin(), nullptr)>> ostream& operator<<(ostream &os, const C &c) { os << '{'; for (auto it = begin(c); it != end(c); it++) { if (begin(c) != it) os << \", \"; os << *it; } return os << '}'; }\ntemplate<typename T> ostream &operator<<(ostream &os, const stack<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\ntemplate<typename T> ostream &operator<<(ostream &os, const queue<T> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_back(c.front()); return os << d; }\ntemplate<typename T, typename C, typename Cmp> ostream &operator<<(ostream &os, const priority_queue<T, C, Cmp> &j) { deque<T> d; for (auto c = j; !c.empty(); c.pop()) d.push_front(c.top());  return os << d; }\n// OUTPUT FUNCTION\ntemplate<typename T> int PV(T &v) { int sz = v.size(); for (int i = 0; i < sz; ++i) cout << v[i] << \" \\n\"[i == sz - 1]; return 0; }\ninline int print() { cout << endl; return 0; }\ntemplate<typename Head> int print(Head&& head){ cout << head; return print(); }\ntemplate<typename Head, typename... Tail> int print(Head&& head, Tail&&... tail) { cout << head << \" \"; return print(forward<Tail>(tail)...); }\n#ifdef LOCAL\ninline void dump() { cerr << endl; }\ntemplate<typename Head> void dump(Head&& head) { cerr << head; dump(); }\ntemplate<typename Head, typename... Tail> void dump(Head&& head, Tail&&... tail) { cerr << head << \", \"; dump(forward<Tail>(tail)...); }\n#define debug(...) do {cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; dump(__VA_ARGS__); } while (false)\n#else\n#define dump(...)\n#define debug(...)\n#endif\n/* OTHER */\n#define fi              first\n#define se              second\n#define MP              make_pair\n#define MT              make_tuple\n#define tmax(x, y, z)   max((x), max((y), (z)))\n#define tmin(x, y, z)   min((x), min((y), (z)))\ntemplate<typename T, typename A, typename B> inline bool between(T x, A a, B b) { return ((a <= x) && (x < b)); }\ntemplate<typename A, typename B> inline bool chmax(A &a, const B &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename A, typename B> inline bool chmin(A &a, const B &b) { if (a > b) { a = b; return true; } return false; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ninline ll POW(ll a, ll b)                    { ll r = 1; do { if (b & 1)  r *= a;        a *= a; }       while (b >>= 1); return r; }\ninline ll MOP(ll a, ll b, const ll &m = MOD) { ll r = 1; do { if (b & 1) (r *= a) %= m; (a *= a) %= m; } while (b >>= 1); return r; }\nstruct abracadabra {\n    abracadabra() {\n        cin.tie(nullptr); ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n        cerr << fixed << setprecision(5);\n    };\n} ABRACADABRA;\n\n#pragma endregion\n\ntemplate< typename sum_t, typename key_t >\nstruct ReRooting {\n  struct Edge {\n    int to;\n    key_t data;\n    sum_t dp, ndp;\n  };\n\n  using F = function< sum_t(sum_t, sum_t) >;\n  using G = function< sum_t(sum_t, key_t) >;\n\n  vector< vector< Edge > > g;\n  vector< sum_t > subdp, dp;\n  const sum_t ident;\n  const F f;\n  const G gg;\n\n  ReRooting(int V, const F f, const G g, const sum_t &ident)\n      : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n  void add_edge(int u, int v, const key_t &d) {\n    g[u].emplace_back((Edge) {v, d, ident, ident});\n    g[v].emplace_back((Edge) {u, d, ident, ident});\n  }\n\n  void add_edge_bi(int u, int v, const key_t &d, const key_t &e) {\n    g[u].emplace_back((Edge) {v, d, ident, ident});\n    g[v].emplace_back((Edge) {u, e, ident, ident});\n  }\n\n  void dfs_sub(int idx, int par) {\n    for(auto &e : g[idx]) {\n      if(e.to == par) continue;\n      dfs_sub(e.to, idx);\n      subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n    }\n  }\n\n  void dfs_all(int idx, int par, const sum_t &top) {\n    sum_t buff{ident};\n    for(int i = 0; i < (int) g[idx].size(); i++) {\n      auto &e = g[idx][i];\n      e.ndp = buff;\n      e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n      buff = f(buff, e.dp);\n    }\n    dp[idx] = buff;\n    buff = ident;\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      auto &e = g[idx][i];\n      if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n      e.ndp = f(e.ndp, buff);\n      buff = f(buff, e.dp);\n    }\n  }\n\n  vector< sum_t > build() {\n    dfs_sub(0, -1);\n    dfs_all(0, -1, ident);\n    return dp;\n  }\n};\n\nsigned main() {\n\n    SS(int, N);\n\n    using T = pair<double, int>;\n    ReRooting<T, int> dp(N,\n        [](T a, T b) -> T { return T(a.fi + b.fi, a.se + b.se); },\n        [](T a, int b) -> T { return T((a.se == 0 ? 0.0 : a.fi / a.se) + 1.0, 1); },\n        T(0.0, 0)\n    );\n\n    REP(i, N - 1) {\n        SS(int, U, V);\n        --U, --V;\n        dp.add_edge(U, V, 1);\n    }\n\n    EACH(e, dp.build()) print(e.fi / e.se);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nmap< pair<int,int>,double > memo;\nvector<int> edge [150001];\n\ndouble rec(int prev,int curr)\n{\n\tif(memo.count(make_pair(prev,curr))) return memo [make_pair(prev,curr)];\n\tdouble res = 0.0;\n\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\tres += rec(curr,it) + 1.0;\n\t}\n\tif(edge [curr].size() > 1){\n\t\tres /= edge [curr].size() - 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tFOR(i,1,N + 1){\n\t\tdouble ans = 0.0;\n\t\tfor(const auto& it : edge [i]){\n\t\t\tans += rec(i,it) + 1.0;\n\t\t}\n\t\tans /= edge [i].size();\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI g[150010];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[a].PB(b);\n    g[b].PB(a);\n  }\n\n  vector<double> prob(n);\n  function<double(int,int)> dfs1 = [&](int v, int p) -> double {\n    if(p != -1 && g[v].size() == 1) return 0;\n    int cnt = 0;\n    double ret = 0;\n    for(int &i: g[v]) {\n      if(i == p) continue;\n      cnt++;\n      ret += dfs1(i, v) + 1;\n    }\n    ret /= cnt;\n    return prob[v] = ret;\n  };\n\n  dfs1(0, -1);\n  // cout << prob << endl;\n\n  vector<double> ans(n);\n  function<void(int,double,int)> dfs2 = [&](int v, double d_par, int p) {\n    // cout << v << \" \" << d_par << \" \" << p << endl;\n    // vector<PII> d_child;\n    // d_child.emplace_back(0, -1);\n    double ret = 0;\n    for(int &e : g[v]) {\n      if(e == p) {\n        ret += d_par + 1;\n      } else {\n        ret += prob[e] + 1;\n      }\n    }\n    // sort(d_child.rbegin(), d_child.rend());\n    ans[v] = ret / g[v].size();\n    for(int &e : g[v]) {\n      if(e == p) continue;\n      double nxt = g[v].size() == 1 ? 0 : (ret - prob[e] - 1) / (g[v].size() - 1);\n      dfs2(e, nxt, v);\n    }\n  };\n\n  dfs2(0, 0, -1);\n  REP(i, n) {\n    cout << fixed << setprecision(9) << ans[i] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define F first\n#define S second\n#define int long long\nconst ll INF = 1e15;\n\nconst int N = 150 * 1000 + 1000;\nvector<int> adj[N];\ndouble dp[N], up[N];\nint kid[N];\n\nvoid sfd(int p, int par = 0){\n\tif(p != 0){\n\t\tif(par == 0 && kid[par] != 1)\n\t\t\tup[p] = (dp[par] * kid[par] - dp[p] - 1) / (kid[par] - 1) + 1;\n\t\telse if(par == 0 && kid[par] == 1)\n\t\t\tup[p] = 1;\n\t\telse if(par != 0)\n\t\t\tup[p] = (dp[par] * kid[par] - dp[p] + up[par] - 1) / kid[par] + 1;\n\t}\n\tfor(auto q : adj[p])\n\t\tif(q != par)\n\t\t\tsfd(q, p);\n}\n\nvoid dfs(int p, int par = 0){\n\tkid[p] = adj[p].size();\n\tif(p != 0)\n\t\tkid[p]--;\n\n\tfor(auto q : adj[p])\n\t\tif(q != par){\n\t\t\tdfs(q, p);\n\t\t\tdp[p] += (dp[q] + 1) / kid[p];\n\t\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;v--;\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\n\tdfs(0);\n\tsfd(0);\n\n\tcout << fixed << setprecision(10);\n\tcout << dp[0] << '\\n';\n\tfor(int i = 1; i < n; i++){\n\t\tdouble ans = dp[i] * kid[i];\n\t\tans += up[i];\n\t\tans /= (kid[i] + 1);\n\t\tcout << ans << '\\n';\n\t}\n    return 0;\n}\n\n// Tu te faufiles\n// entre mes lignes\n// Tu te faufiles\n// entre mes lignes\n// Charlotte Cardin - Faufile"
  },
  {
    "language": "C++",
    "code": "//http://s8pc-4.contest.atcoder.jp/tasks/s8pc_4_d\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 150010;\n\nint n,deg[maxn];\ndouble F[maxn],G[maxn];\nvector<int> adj[maxn];\n\nvoid visit(int u,int pa) {\n    int son = deg[u];\n    if (pa!=-1) son--;\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            visit(v,u);\n            F[u] = F[u] + 1.0*(F[v]+1)/son;\n        }\n    }\n}\n\nvoid visit2(int u,int pa) {\n    int p = deg[u];\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            if (pa==-1) {\n                if (p==1) G[v]=1;\n                else G[v] = ((F[u]+1)*p - (F[v]+2))/(p-1);\n            }\n            else G[v] = (G[u]+1)/(p-1) + (F[u]+1) - (F[v]+2)/(p-1);\n            visit2(v,u);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n   // freopen(\"in.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int u,v;\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        deg[u]++; deg[v]++;\n    }\n    visit(1,-1);\n    visit2(1,-1);\n    printf(\"%.8f\\n\", F[1]);\n    for (int i=2;i<=n;i++) printf(\"%.8f\\n\",(F[i]*(deg[i]-1) + G[i])*1.0 / deg[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\nmap<pair<int, int>, double> memo;\n\ndouble solve(int curr, int prev)\n{\n    if(edges[curr].size() == 0)\n        return 0.0;\n    if(prev != -1 && edges[curr].size() == 1)\n        return 0.0;\n\n    if(memo.find(make_pair(curr, prev)) != memo.end()){\n        if(prev == -1)\n            return memo[make_pair(curr, prev)] / edges[curr].size();\n        else\n            return memo[make_pair(curr, prev)] / (edges[curr].size() - 1);\n    }\n    if(memo.find(make_pair(curr, -1)) != memo.end()){\n        double ans = memo[make_pair(curr, -1)];\n        ans -= solve(prev, curr) + 1;\n        memo[make_pair(curr, prev)] = ans;\n        ans /= edges[curr].size() - 1;\n        return ans;\n    }\n\n    auto it = memo.lower_bound(make_pair(curr, 0));\n    if(it != memo.end() && it->first.first == curr){\n        double ans = it->second;\n        ans += solve(it->first.second, curr) + 1;\n        memo[make_pair(curr, -1)] = ans;\n        if(prev == -1){\n            ans /= edges[curr].size();\n        }\n        else{\n            ans -= solve(prev, curr) + 1;\n            memo[make_pair(curr, prev)] = ans;\n            ans /= edges[curr].size() - 1;\n        }\n        return ans;\n    }\n\n    double ans = 0.0;\n    for(int next : edges[curr]){\n        if(next != prev)\n            ans += solve(next, curr) + 1;\n    }\n    memo[make_pair(curr, prev)] = ans;\n    if(prev == -1)\n        ans /= edges[curr].size();\n    else\n        ans /= edges[curr].size() - 1;\n    return ans;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    for(int i=0; i<n; ++i){\n        double ans = solve(i, -1);\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\n\nint n;\nvector<vector<int>> g;\nvector<double> dp,ans;\n\ndouble dfs1(int pre,int now){\n    double p=0,res=0;\n    for(auto to:g[now])if(to!=pre){\n        p++;\n        res+=dfs1(now,to);\n    }\n    if(p==0) return dp[now]=0;\n    else return dp[now]=1.0+res/p;\n}\n\nvoid dfs2(int pre,int now){\n    int memo=dp[now];\n\n    double res=0;int p=0;\n    for(auto to:g[now]){\n        p++;\n        res+=dp[to];\n    }\n    ans[now]=1.0+res/(double)(p);\n    dp[now]=ans[now];\n\n    for(auto to:g[now])if(to!=pre){\n        double memo2=dp[now];\n\n        if(p==1){\n            dp[now]=0;\n        }else{\n            double pp=(double)(p);\n            dp[now]-=1.0;\n            dp[now]*=pp;\n            dp[now]-=dp[to];\n            dp[now]/=(pp-1.0);\n            dp[now]+=1.0;\n        }\n        dfs2(now,to);\n        dp[now]=memo2;\n    }\n    dp[now]=memo;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout<<fixed<<setprecision(8);\n\n    cin>>n;\n    g.resize(n);dp.resize(n);ans.resize(n);\n    rep(i,n-1){\n        int u,v;cin>>u>>v;u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs1(-1,0);dfs2(-1,0);\n    rep(i,n)cout<<ans[i]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2], frm[150001];\nvi G[150000];\ndouble dp[150001][2], sm[150001];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    if (sm[u] > -1) {\n        res = sm[u] + (f(frm[u], E[frm[u]][0] == u) - f(e, !s))*p;\n        return res;\n    }\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    sm[u] = res;\n    frm[u] = e;\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    rep(i, N - 1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n\n    rep(i, N) {\n        sm[i] = -2;\n        rep(j, 2)dp[i][j] = -2;\n    }\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.8f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size()-1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint tu[150010], tv[150010];\nvector<int> G[150010];\n\nlong double dfs(int now, int pre, long double E, int dist){\n\tdouble ret = 0;\n\tint nextsize;\n\tif(pre == -1) nextsize = G[now].size();\n\telse nextsize = G[now].size() - 1;\n\tif(nextsize == 0){\n\t\treturn dist * E;\n\t}\n\tfor(auto u : G[now]){\n\t\tif(u == pre) continue;\n\t\tret += dfs(u, now, E / nextsize, dist + 1);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N - 1) cin >> tu[i] >> tv[i];\n\trep(i, N - 1) tu[i]--, tv[i]--;\n\trep(i, N - 1){\n\t\tG[tu[i]].pb(tv[i]);\n\t\tG[tv[i]].pb(tu[i]);\n\t}\n\n\tint one = 0, two = 0;\n\trep(i, N){\n\t\tif(G[i].size() == 1) one++;\n\t\telse if(G[i].size() == 2) two++;\n\t}\n\t// printf(\"%d %d\\n\", one, two);\n\tif(one == 2 && two == N - 2){\n\t\t// printf(\"k\\n\");\n\t\trep(i, N){\n\t\t\tif(G[i].size() == 1){\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)(N - 1));\n\t\t\t}else{\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)(N - 1) / 2.0);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\trep(i, N){\n\t\tlong double ret = dfs(i, - 1, 1.0, 0);\n\t\tprintf(\"%.9Lf\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[100100];\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, t / k) + t / k;\n    }\n    return ans;\n}\nint main()\n{\n    int n, i, x, y;\n\n    cin >> n;\n\n    for(i = 1; i < n; ++i)\n    {\n        cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\ntemplate <class S, class T> using P = pair<S, T>;\ntemplate <class... T> using TP = tuple<T...>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing dbl = double;\nusing str = string;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing tl = TP<ll, ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vtl = V<tl>;\nusing vvtl = V<vtl>;\nusing vs = V<str>;\nusing vvs = V<vs>;\nusing vd = V<dbl>;\nusing vvd = V<vd>;\nusing vvvd = V<vvd>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing stll = stack<ll>;\nusing stpl = stack<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n//#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define fr front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define ROR(v,i) for(auto &(i):(v))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).bgn,(a).en)\n#define NEXTP(a) next_permutation((a).bgn,(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define fs(a) cout <<((a)?\"second\":\"first\")<<\"\\n\";\n#define Fs(a) cout <<((a)?\"Second\":\"First\")<<\"\\n\";\n#define FS(a) cout <<((a)?\"SECOND\":\"FIRST\")<<\"\\n\";\n//#define say(a) cout <<(a);\n//#define sal(a) cout <<(a)<<\"\\n\";\n#define sak cout <<\"\\n\";\n#define sas cout <<\" \";\n#define sat cout <<\"\\t\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define dbgs(...) dal(#__VA_ARGS__);dal(__VA_ARGS__);\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define LSB(a) ((a)&(-(a)))\n/*#define llin(a) ll (a);cin >>(a);\n#define llin2(a,b) ll (a),(b);cin >>(a)>>(b);\n#define llin3(a,b,c) ll (a),(b),(c);cin >>(a)>>(b)>>(c);\n#define stin(a) string (a);cin >>(a);*/\n#define vin(v) ROR((v),(i)){cin >>(i);};\n#define vllin(N,v) vll (v)((N));vin(v);\n#define vllin2(N,a,b) vll (a)(N),(b)(N);REP(i,N){cin>>(a)[i]>>(b)[i];};\n#define vsin(N,v) vs (v)((N));vin(v);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n#define tg(t,i) get<i>(t)\n\n#define Id(x) get<0>(x)\n#define Act(x) get<1>(x)\n#define InvAct(x) get<2>(x)\n#define mg(id,act) mt(id,act,lam(l))\n//#define MonoidSet(T) TP<T, function<T(T, T)>>\n#define GroupSet(T) TP<T, function<T(T, T)>, function<T(T, T)>>\n#define CompareSet(T) TP<T, function<bool(T, T)>>\n#define lam(lr) ([](auto l, auto r){return (lr);})\n#define elam(lr) ([=](auto l, auto r){return (lr);})\n#define clam(lr) ([&](auto l, auto r){return (lr);})\n#define lamr(lr) ([](auto l, auto r){lr})\n#define elamr(lr) ([=](auto l, auto r){lr})\n#define clamr(lr) ([&](auto l, auto r){lr})\n#define min(...) Operation(MIN,__VA_ARGS__)\n#define max(...) Operation(MAX,__VA_ARGS__)\n#define gcd(...) Operation(GCD,__VA_ARGS__)\n#define lcm(...) Operation(LCM,__VA_ARGS__)\n#define vmin(...) VOperation(MIN,__VA_ARGS__)\n#define vmax(...) VOperation(MAX,__VA_ARGS__)\n#define vgcd(...) VOperation(GCD,__VA_ARGS__)\n#define vlcm(...) VOperation(LCM,__VA_ARGS__)\n#define vsum(...) VOperation(ADD,__VA_ARGS__)\n#define vpro(...) VOperation(MUL,__VA_ARGS__)\n#define emin(a, ...) ((a)=min((a),__VA_ARGS__))\n#define emax(a, ...) ((a)=max((a),__VA_ARGS__))\n#define egcd(a, ...) ((a)=gcd((a),__VA_ARGS__))\n#define elcm(a, ...) ((a)=lcm((a),__VA_ARGS__))\n#define ope Operation\n#define vope VOperation\n\n#define svll SumV<ll>\n#define svvll SumV2<ll>\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) str __VA_ARGS__;Input(__VA_ARGS__);\n//#define vli(size, ...) vll __VA_ARGS__;vInitInput(size,__VA_ARGS__);\n#define vlr(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vlc(size, ...) vll __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsr(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsc(size, ...) vs __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vli2(rowSize,columnSize, ...) vvll __VA_ARGS__;vInitInput2(rowSize,columnSize,__VA_ARGS__);\n#define vplr(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vplc(size, ...) vpl __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vpli(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst vll DX = { 0,-1,0,1,0,-1,1,1,-1 };\nconst vll DY = { 0,0,-1,0,1,-1,-1,1,1 };\nconst str alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst str ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <class T> auto GetVectorValueType(T v) { return v; }\ntemplate <class T> auto GetVectorValueType(V<T> v) { return GetVectorValueType(T()); }\n\ntemplate <class S, class T> istream &operator>>(istream &in, P<S, T> &p) { return in >> p.fi >> p.se; }\ntemplate <class T> istream &operator>>(istream &in, V<T> &v) { REP(i, v.sz) in >> v[i]; return in; }\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n\tcin >> var;\n\tInput(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n\tv.res(size);\n\tvInit(size, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class T, class... Args> void vInput(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInput(size, args...);\n}\nvoid vInputR(ll size) {}\ntemplate <class T, class... Args> void vInputR(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInputR(size, args...);\n}\nvoid vInputNumC(ll num) {}\ntemplate <class T, class... Args> void vInputNumC(ll num, V<T>& v, Args&... args) {\n\tcin >> v[num];\n\tvInputNumC(num, args...);\n}\nvoid vInputC(ll size) {}\ntemplate <class... Args> void vInputC(ll size, Args&... args) {\n\tREP(i, size) vInputNumC(i, args...);\n}\nvoid vInitInputR(ll size) {}\ntemplate <class... Args> void vInitInputR(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputR(size, args...);\n}\nvoid vInitInputC(ll size) {}\ntemplate <class... Args> void vInitInputC(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputC(size, args...);\n}\nvoid vInit2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInit2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tv.asn(rowSize, V<T>(columnSize));\n\tvInit2(rowSize, columnSize, args...);\n}\nvoid vInput2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInput2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tREP(r, rowSize) {\n\t\tREP(c, columnSize) {\n\t\t\tcin >> v[r][c];\n\t\t}\n\t}\n\tvInput2(rowSize, columnSize, args...);\n}\nvoid vInitInput2(ll rowSize, ll columnSize) {}\ntemplate <class... Args> void vInitInput2(ll rowSize, ll columnSize, Args&... args) {\n\tvInit2(rowSize, columnSize, args...);\n\tvInput2(rowSize, columnSize, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n\treturn out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n\tif (v.emp) return out << \"{}\";\n\telse {\n\t\tauto itr = v.bgn;\n\t\tout << \"{\" << *itr;\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \"}\";\n\t\treturn out;\n\t}\n}\ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n\tif (m.emp) return out << \"<[]>\";\n\telse {\n\t\tauto itr = m.bgn;\n\t\tout << \"< [\" << (itr->fi) << \": \" << (itr->se);\n\t\titr++;\n\t\twhile (itr != m.en) {\n\t\t\tout << \"], [\" << (itr->fi) << \": \" << (itr->se);\n\t\t\titr++;\n\t\t}\n\t\tout << \"] >\";\n\t\treturn out;\n\t}\n}\ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n\tif (s.emp) return out << \"<>\";\n\telse {\n\t\tauto itr = s.bgn;\n\t\tout << \"<\" << *itr;\n\t\titr++;\n\t\twhile (itr != s.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \">\";\n\t\treturn out;\n\t}\n}\n\nvoid say() {}\ntemplate <class T> void say(T t) { cout << t; }\ntemplate <class Head, class... Body> void say(Head head, Body... body) {\n\tcout << head << \" \";\n\tsay(body...);\n}\nvoid sal() { cout << \"\\n\"; }\ntemplate <class... Args> void sal(Args... args) {\n\tsay(args...);\n\tcout << \"\\n\";\n}\n\nvoid day() {}\ntemplate <class T> void day(T t) { cerr << t; }\ntemplate <class Head, class... Body> void day(Head head, Body... body) {\n\tcerr << head << \" \";\n\tday(body...);\n}\nvoid dal() { cerr << \"\\n\"; }\ntemplate <class... Args> void dal(Args... args) {\n\tday(args...);\n\tcerr << \"\\n\";\n}\n\nvoid salv() {}\ntemplate <class T> void salv(V<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tauto itr = v.bgn;\n\t\tsay(*itr);\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tsas;\n\t\t\tsay(*itr);\n\t\t\titr++;\n\t\t}\n\t\tsak;\n\t}\n}\ntemplate <class T> void salv(VV<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tROR(v, i) salv(i);\n\t}\n}\ntemplate <class T, class... Args> void salv(T v, Args... args) {\n\tsalv(v);\n\tsalv(args...);\n}\n\n\ntemplate <class L, class R> auto Gcd(L l, R r) -> decltype(l + r) {\n\tif (l < r) swap(l, r);\n\treturn r ? Gcd(r, l%r) : l;\n}\ntemplate <class L, class R> auto Lcm(L l, R r) {\n\tif (!l || !r) return 0;\n\treturn l / Gcd(l, r) * r;\n}\n\n/*\nauto LES = mp(INF, lam(return l < r;));\nauto GRT = mp(-INF, lam(return l > r;));\nauto EQ = mp(0, lam(return l == r;));\n\nauto ADD = mp(0, lam(return l + r;));\nauto SUB = mp(0, lam(return l - r;));\nauto MUL = mp(1, lam(return l * r;));\nauto DIV = mp(1, lam(return l / r;));\nauto MDL = mp(1, lam(return l % r;));\nauto XOR = mp(0, lam(return l ^ r;));\nauto OR = mp(0, lam(return l | r;));\nauto AND = mp(((ll)(1) << 63) - 1, lam(return l & r;));\nauto MIN = mp(INF, lam(return (l < r) ? l : r;));\nauto MAX = mp(-INF, lam(return (l > r) ? l : r;));\nauto GCD = mp(0, lam(return Gcd(l, r);));\nauto LCM = mp(1, lam(return Lcm(l, r);));\n*/\n\nauto LES = mp(INF, lam(l < r));\nauto GRT = mp(-INF, lam(l > r));\nauto EQ = mp(0, lam(l == r));\n\nauto ADD = mt(0, lam(l + r), lam(l - r));\nauto MUL = mt(1, lam(l * r), lam(l / r));\nauto XOR = mt(0, lam(l ^ r), lam(l ^ r));\nauto OR = mg(0, lam(l | r));\nauto AND = mg(((ll)(1) << 63) - 1, lam(l & r));\nauto MIN = mg(0, lam((l < r) ? l : r));\nauto MAX = mg(0, lam((l > r) ? l : r));\nauto GCD = mg(0, lam(Gcd(l, r)));\nauto LCM = mg(0, lam(Lcm(l, r)));\n\ntemplate <class OperationType> auto Operation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto Operation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T, class... Args> auto Operation(OperationType A, T x, Args... args) {\n\tauto tmp = Operation(A, args...);\n\treturn Act(A)(x, tmp);\n}\n\ntemplate <class OperationType> auto VOperation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, V<T> v) {\n\tif (v.emp) {\n\t\tdecltype(GetVectorValueType(T())) tmp = Id(A);\n\t\treturn tmp;\n\t}\n\tauto tmp = VOperation(A, v[0]);\n\tFOR(i, 1, v.sz - 1) tmp = Act(A)(tmp, VOperation(A, v[i]));\n\treturn tmp;\n}\ntemplate <class OperationType, class T, class... Args> auto VOperation(OperationType A, T x, Args... args) {\n\tauto xResult = VOperation(A, x);\n\tauto tmp = VOperation(A, args...);\n\treturn Act(A)(xResult, tmp);\n}\n\n\nll Bset(ll a, ll b, ll c) {\n\tif (c) a |= b;\n\telse a &= ~b;\n\treturn a;\n}\n\n\nstruct UFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tUFT(ll tsizeget, ll modeget = 0){\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct pUFT {\n\npublic:\n\n\tll tsize;\n\tll now;\n\tvll par;\n\tvll rank;\n\tvll mtime;\n\tvvll sizepi;\n\tVV<T> sizepv;\n\tV<T> elm;\n\tGroupSet(T) Add;\n\n\tpUFT(ll tsize, GroupSet(T) Add = ADD) : tsize(tsize), Add(Add) { init(); }\n\tvoid init() {\n\t\tnow = 0;\n\t\tpar.asn(tsize, -1);\n\t\trank.asn(tsize, 0);\n\t\tmtime.asn(tsize, INF);\n\t\tsizepi.asn(tsize, { 0 });\n\t\tsizepv.asn(tsize, {});\n\t}\n\tvoid set(ll x, T s) {\n\t\telm[x] = s;\n\t\tsizepv[x] = { s };\n\t}\n\tll root(ll x, ll t) {\n\t\treturn (mtime[x] > t) ? x : root(par[x], t);\n\t}\n\tbool same(ll x, ll y, ll t) {\n\t\treturn root(x, t) == root(y, t);\n\t}\n\tll merge(ll x, ll y) {\n\t\tnow++;\n\t\tx = root(x, now);\n\t\ty = root(y, now);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[y].pb(now);\n\t\t\t\tsizepv[y].pb(elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t\tmtime[x] = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[x].pb(now);\n\t\t\t\tsizepv[x].pb(elm[x]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tmtime[y] = now;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tT size(ll x, ll t) {\n\t\tx = root(x, t);\n\t\treturn sizepv[x][UPB(sizepi[x], t) - 1];\n\t}\n\n};\n\nstruct wUFT {\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tvll dweight;\n\twUFT(ll tsizeget, ll modeget = 0) {\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\tdweight.asn(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\tif (par[x] < 0) return x;\n\t\telse {\n\t\t\tll r = root(par[x]);\n\t\t\tdweight[x] += dweight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\tll weight(ll x) {\n\t\troot(x);\n\t\treturn dweight[x];\n\t}\n\tll diff(ll x, ll y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y, ll w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t\tdweight[x] = -w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t\tdweight[y] = w;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct sUFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tGroupSet(T) Add;\n\tV<T> elm;\n\tsUFT(ll tsize, GroupSet(T) Add = ADD, ll mode = 0) : tsize(tsize), Add(Add), mode(mode) { init(); }\n\tvoid init() {\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\telm.asn(tsize, Id(Add));\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tT size(ll x) {\n\t\treturn elm[root(x)];\n\t}\n\tT& operator[](ll x) { return elm[x]; }\n};\n\ntemplate <typename valtype> class SegT {\n\npublic:\n\n\tll size;\n\tvector<valtype> v;\n\n\tvaltype initv;\n\tfunction<valtype(valtype x, valtype y)> calc;\n\n\tSegT() {}\n\tSegT(const SegT &segt) {}\n\n\tSegT(ll sizeget, ll modeget = 0) {\n\t\tsizeset(sizeget);\n\t\tmodeset(modeget);\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, ll modeget = 0) {\n\t\tsizeset(cpyvec.sz);\n\t\tmodeset(modeget);\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tSegT(ll sizeget, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(sizeget);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(cpyvec.sz);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tvoid sizeset(ll rsize) {\n\t\tsize = DigN2(rsize);\n\t\tif (rsize == Pow2(size - 1)) size--;\n\t\treturn;\n\t}\n\tvoid modeset(ll mode) {\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tinitv = 0;\n\t\t\tcalc = [](valtype x, valtype y) {return x + y; };\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinitv = INF;\n\t\t\tcalc = [](valtype x, valtype y) {return min(x, y); };\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinitv = -INF;\n\t\t\tcalc = [](valtype x, valtype y) {return max(x, y); };\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tvoid init() {\n\t\tv.asn(Pow2(size + 1) - 1, initv);\n\t}\n\tvoid copy(vector<valtype> cpyvec) {\n\t\tREP(i, min(cpyvec.sz, Pow2(size))) set(i, cpyvec[i]);\n\t}\n\tll i2v(ll i) const{\n\t\tif (i < 0 || i >= Pow2(size)) return -1;\n\t\treturn Pow2(size) + i - 1;\n\t}\n\tll top(ll i) const{\n\t\tif (i == 0) return -1;\n\t\treturn (i - 1) / 2;\n\t}\n\tpl bot(ll i) const{\n\t\tif (i + 1 >= Pow2(size)) return mp(-1, -1);\n\t\treturn mp(2 * i + 1, 2 * i + 2);\n\t}\n\tvoid set(ll i, valtype x) {\n\t\ti = i2v(i);\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = top(i);\n\t\t\tv[i] = calc(v[bot(i).fi], v[bot(i).se]);\n\t\t}\n\t\treturn;\n\t}\n\tvoid add(ll i, valtype x) {\n\t\tset(i, v[i2v(i)] + x);\n\t\treturn;\n\t}\n\tvaltype operator[](const ll &i) const {\n\t\treturn v[i2v(i)];\n\t}\n//\tvaltype que(ll a = 0, ll b = Pow2(size) - 1) {\n\tvaltype que(ll a, ll b) {\n\t\tif (a == b) return v[i2v(a)];\n\t\tif (a > b) return initv;//swap(a, b);\n\t\tvaltype ans = initv;\n\t\tll ai = i2v(a);\n\t\tll bi = i2v(b);\n\t\tFOR(i, 1, size + 1) {\n\t\t\tif (a > b) break;\n\t\t\tif (a%Pow2(i)) {\n\t\t\t\tans = calc(ans, v[ai]);\n\t\t\t\ta += Pow2(i - 1);\n\t\t\t\tai = top(ai) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tai = top(ai);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t\tif ((b + 1) % Pow2(i)) {\n\t\t\t\tans = calc(ans, v[bi]);\n\t\t\t\tb -= Pow2(i - 1);\n\t\t\t\tbi = top(bi) - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbi = top(bi);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t}\n\t\treturn ans;\n\t}\n\tvaltype que(ll b) {\n\t\treturn que(0, b);\n\t}\n\tvaltype que() {\n\t\treturn que(0, Pow2(size) - 1);\n\t}\n\n\n};\n\n\n/*template <class Type> class DP {\n\npublic:\n\n\tvector<Type> v;\n\tType initv;\n\tvll size, block;\n\n\tDP() {}\n\tDP(const DP &dp) {}\n\n\ttemplate<class... Args> DP(Args... args) {\n\t\tblock.asn(1, 1);\n\t\tInitialize(args...);\n\t}\n\n\tvoid Initialize(Type initv_) {\n\t\tinitv = initv_;\n\t\tv.asn(block.bk, initv);\n\t}\n\ttemplate<class... Args> void Initialize(ll val, Args... args) {\n\t\tsize.pb(val);\n\t\tblock.pb(block.bk*val);\n\t\tInitialize(args...);\n\t}\n\n\n\n};*/\n\n\npl Bezout(ll a, ll b) {\n\tif (b != 0) {\n\t\tpl xy;\n\t\txy = Bezout(b, a%b);\n\t\treturn mp(xy.se, xy.fi - ((a / b)*xy.se));\n\t}\n\telse {\n\t\treturn mp(1, 0);\n\t}\n}\npl Bez(ll a, ll b, ll c) {\n\tpl xy;\n\tll x, y, z, gc;\n\txy = Bezout(a, b);\n\tgc = gcd(a, b);\n\tif (c%gc != 0) return mp(-1, -1);\n\tx = xy.fi*(c / gc); y = xy.se*(c / gc);\n\tif (x < 0) z = rup(-x, (b / gc));\n\tif (x >= 0) z = -x / (b / gc);\n\tx += z * (b / gc);\n\ty -= z * (a / gc);\n\treturn mp(x, y);\n}\n\nll DigS10(ll n) {\n\tll ans = 0;\n\twhile(1) {\n\t\tans += n % 10;\n\t\tn /= 10;\n\t\tif (!n) break;\n\t}\n\treturn ans;\n}\n\nll isP(ll n) {\n\tif (n <= 1) return 0;\n\tFOR(i, 2, (ll)sqrt(n) + 1) {\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nll Tot(ll n) {\n\tif (n <= 0) return 0;\n\tll ans = n, x = 2;\n\twhile (x*x <= n) {\n\t\tif (n%x == 0) {\n\t\t\tans -= ans / x;\n\t\t\twhile (n%x == 0) n /= x;\n\t\t}\n\t\tx++;\n\t}\n\tif (n > 1) ans -= ans / n;\n\treturn ans;\n}\n\ntemplate <class T> struct Graph {\npublic:\n\tll vSize;\n\tll eMode;\n\tll mapMode;\n\tGroupSet(T) Add;\n\tCompareSet(T) Less;\n\tCompareSet(T) Equal;\n\tVV<P<T, ll>> adj;\n\tmap<pl, T> len;\n\tGraph(ll vSize, ll eMode = 0, ll mapMode = 0, GroupSet(T) Add = ADD, CompareSet(T) Less = LES, CompareSet(T) Equal = EQ) : vSize(vSize), eMode(eMode), mapMode(mapMode), Add(Add), Less(Less), Equal(Equal) {}\n\tvoid Init() {\n\t\tadj.asn(vSize, V<P<T, ll>>());\n\t}\n\tvoid AddE(ll x, ll y, T cost) {\n\t\tiAddE(x, y, cost);\n\t\tif (!eMode) iAddE(y, x, cost);\n\t}\n\tvoid iAddE(ll x, ll y, T cost) {\n\t\tadj[x].pb(mp(cost, y));\n\t\tif (mapMode) len[mp(x, y)] = cost;\n\t}\n\tP<bool, T> getE(ll x, ll y) {\n\t\tif (!len.count(mp(x, y))) return mp(false, Id(Less));\n\t\treturn mp(true, len[mp(x, y)]);\n\t}\n\tV<T> Dijk(ll x) {\n\t\tV<T> ans(vSize, Id(Less));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se] = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se], i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tV<P<T, vll>> rDijk(ll x) {\n\t\tV<P<T, vll>> ans(vSize, mp(Id(Less), vll()));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se].fi = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tans[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tT Prim(ll x = 0) {\n\t\tT ans = Id(Add);\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans = Act(Add)(ans, segt[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tP<T, V<P<T, vll>>> rPrim(ll x = 0) {\n\t\tP<T, V<P<T, vll>>> ans = mp(Id(Add), V<P<T, vll>>(vSize, mp(Id(Less), vll())));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans.se[now.se].fi = segt[now.se].fi;\n\t\t\tans.fi = Act(Add)(ans.fi, ans.se[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tans.se[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\ntemplate <class T> struct Sum {\npublic:\n\tV<T> v, s;\n\tll size;\n\tGroupSet(T) Add;\n\tSum(V<T> v, GroupSet(T) Add = ADD) : v(v), size(v.sz), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(size + 1, Id(Add));\n\t}\n\tvoid Calc() {\n\t\tREP(i, size) s[i + 1] = Act(Add)(s[i], v[i]);\n\t}\n\tT operator()(ll x) {\n\t\tif (x < -1) x = -1;\n\t\tif (x > size - 1) x = size - 1;\n\t\treturn s[x + 1];\n\t}\n\tT operator()(ll l, ll r) {\n\t\tif (l < 0) l = 0;\n\t\tif (r >= size) r = size - 1;\n\t\tif (l > r) return Id(Add);\n\t\treturn InvAct(Add)(s[r + 1], s[l]);\n\t}\n};\nusing sumll = Sum<ll>;\n\ntemplate <class T> struct Sum2 {\npublic:\n\tVV<T> v, s;\n\tll RowSize, ColumnSize;\n\tGroupSet(T) Add;\n\tSum2(VV<T> v, GroupSet(T) Add = ADD) : v(v), RowSize(v.sz), ColumnSize(v.sz ? v[0].sz : 0), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(RowSize + 1, V<T>(ColumnSize + 1, Id(Add)));\n\t}\n\tvoid Calc() {\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n//\t\t\t\ts[r][c] = InvAct(Add)(Act(Add)(Act(Add)(v[r - 1][c - 1], operator()(r - 1, c - 2)), operator()(r - 2, c - 1)), operator()(r - 2, c - 2));\n\t\t\t\ts[r][c] = Act(Add)(s[r][c - 1], v[r - 1][c - 1]);\n\t\t\t}\n\t\t}\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n\t\t\t\ts[r][c] = Act(Add)(s[r - 1][c], s[r][c]);\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(ll r, ll c) {\n\t\tif (r < -1) r = -1;\n\t\tif (c < -1) c = -1;\n\t\tif (r > RowSize - 1) r = RowSize - 1;\n\t\tif (c > ColumnSize - 1) c = ColumnSize - 1;\n\t\treturn s[r + 1][c + 1];\n\t}\n\tT operator()(ll r1, ll c1, ll r2, ll c2) {\n\t\tif (r1 < 0) r1 = 0;\n\t\tif (c1 < 0) c1 = 0;\n\t\tif (r2 >= RowSize) r2 = RowSize - 1;\n\t\tif (c2 >= ColumnSize) c2 = ColumnSize - 1;\n\t\tif (r1 > r2) return Id(Add);\n\t\tif (c1 > c2) return Id(Add);\n\t\treturn InvAct(Add)(Act(Add)(s[r2 + 1][c2 + 1], s[r1][c1]), Act(Add)(s[r2 + 1][c1], s[r1][c2 + 1]));\n\t}\n};\nusing sumll2 = Sum2<ll>;\n\ntemplate <class T> struct Point2 {\npublic:\n\tVV<T> v;\n\tll h, w;\n\tPoint2() : h(0), w(0) {}\n\tPoint2(ll h, ll w) : h(h), w(w) { asn(h, w); }\n\tPoint2(ll h, ll w, T val) : h(h), w(w) { asn(h, w, val); }\n\tPoint2(VV<T> cv) : h(cv.sz), w(cv.sz ? cv[0].sz : 0) { asn(h, w); copy(cv); }\n\tvoid assign(ll h, ll w) { v.asn(h, V<T>(w)); }\n\tvoid assign(ll h, ll w, ll val) { v.asn(h, V<T>(w, val)); }\n\tvoid copy(VV<T> cv) { REP(_h, h) REP(_w, w) v[_h][_w] = cv[_h][_w]; }\n\tT& operator()(ll h, ll w) { return v[h][w]; }\n\tT& operator()(pl p) { return v[p.fi][p.se]; }\n\tT& operator[](pl p) { return v[p.fi][p.se]; }\n};\ntemplate <class T> using P2 = Point2<T>;\n\ntemplate <ll Mod> struct Modll {\npublic:\n\tll v;\n\tModll() : v(0) {}\n\tModll(ll _v) { set(_v % Mod + Mod); }\n\tModll& set(ll _v) {\n\t\tv = (_v < Mod) ? _v : (_v - Mod);\n\t\treturn *this;\n\t}\n\tModll pow(ll n) const {\n\t\tModll x = *this, ans = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) ans *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tModll inverse() const { return (*this).pow(Mod - 2); }\n\tModll operator+(const Modll& m) const { return Modll().set(v + m.v); }\n\tModll operator-(const Modll& m) const { return Modll().set(Mod + v - m.v); }\n\tModll operator*(const Modll& m) const { return Modll().set((ull(v) * m.v) % Mod); }\n\tModll operator/(const Modll& m) const { return *this * m.inv; }\n\tModll& operator+=(const Modll& m) { return *this = *this + m; }\n\tModll& operator-=(const Modll& m) { return *this = *this - m; }\n\tModll& operator*=(const Modll& m) { return *this = *this * m; }\n\tModll& operator/=(const Modll& m) { return *this = *this / m; }\n\tModll operator-() const { return Modll(0) - *this; }\n\texplicit operator bool() const { return v != 0; }\n\tfriend istream& operator>>(istream& in, Modll& m) { return in >> m.v; }\n\tfriend ostream& operator<<(ostream& out, const Modll& m) { return out << m.v; }\n};\nusing mll = Modll<MOD>;\nusing vmll = V<mll>;\nusing vvmll = V<vmll>;\nusing vvvmll = V<vvmll>;\n\nvmll MFactMemo(2, 1);\nvmll MIFactMemo(2, 1);\n\nmll mFact(ll n) {\n\tif (MFactMemo.sz <= n) {\n\t\tll oldsize = MFactMemo.sz;\n\t\tMFactMemo.res(n + 1, 1);\n\t\tFOR(i, oldsize, n) MFactMemo[i] = MFactMemo[i - 1] * i;\n\t}\n\treturn MFactMemo[n];\n}\nmll miFact(ll n) {\n\tif (MIFactMemo.sz <= n) {\n\t\tll oldsize = MIFactMemo.sz;\n\t\tMIFactMemo.res(n + 1, 1);\n\t\tMIFactMemo.bk = mFact(n).inv;\n\t\trFOR(i, oldsize + 1, n) MIFactMemo[i - 1] = MIFactMemo[i] * i;\n\t}\n\treturn MIFactMemo[n];\n}\nmll mComb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn mFact(n) * miFact(k) * miFact(n - k);\n}\n\nll LIS(vll v, ll m = 0) {\n\n\tif (v.sz > 0) {\n\t\tll ans = 0;\n\t\tvll dp(v.sz, INF);\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tdp[m ? UPB(dp, v[i]) : LOWB(dp, v[i])] = v[i];\n\t\t}\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tif (dp[i] == INF) break;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n}\n\nll Bsrch(function<bool(ll x)> f, ll mi, ll ma) {\n\tll ng = mi - 1, ok = ma, mid;\n\twhile (ok - ng > 1) {\n\t\tmid = (ng + ok) / 2;\n\t\t(f(mid) ? ok : ng) = mid;\n\t}\n\treturn ok;\n}\n\ntemplate <class T, class M = decltype(MUL), class S = decltype(ADD)> VV<T> MultiMatrix(VV<T> A, VV<T> B, M Mul = MUL, S Add = ADD) {\n\tVV<T> ans;\n\tll ii = A.sz;\n\tif (!ii) return ans;\n\tll jj = A[0].sz;\n\tif (!jj) return ans;\n\tll jj2 = B.sz;\n\tif (!jj2) return ans;\n\tif (jj != jj2) return ans;\n\tll kk = B[0].sz;\n\tif (!kk) return ans;\n\tans.asn(ii, V<T>(kk, 0));\n\tREP(i, ii) {\n\t\tREP(k, kk) {\n\t\t\tREP(j, jj) {\n\t\t\t\tans[i][k] = Act(Add)(ans[i][k], Act(Mul)(A[i][j], B[j][k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n\tif ((n < 0) || (k < 0)) return 0;\n\tif (CombMemo[n][k] == -1) {\n\t\tif (n < k) CombMemo[n][k] = 0;\n\t\telse {\n\t\t\tif (n == 0) CombMemo[n][k] = 1;\n\t\t\telse if (k == 0) CombMemo[n][k] = 1;\n\t\t\telse if (n == k) CombMemo[n][k] = 1;\n\t\t\telse CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n\t\t}\n\t}\n\treturn CombMemo[n][k];\n}\n\ntemplate<class T> map<T, ll> Dict(V<T> v) {\n\tmap<T, ll> m;\n\tif (!v.sz) return m;\n\tSORT(v);\n\tUNIQUE(v);\n\tREP(i, v.sz) {\n\t\tm[v[i]] = i;\n\t}\n\treturn m;\n}\n\ntemplate <class T> vll Cmprs(V<T> v) {\n\tauto m = Dict(v);\n\tvll ans(v.sz);\n\tREP(i,v.sz) {\n\t\tans[i] = m[v[i]];\n\t}\n\treturn ans;\n}\n\ntemplate <class T> vll PCmprs(V<T> v) {\n\tif (v.sz == 0) return V<T>();\n\tvll tmp(v.sz);\n\tvll ans(v.sz);\n\tIOTA(tmp, 0);\n\tIOTA(ans, 0);\n\tsort(tmp.bgn, tmp.en, clam(v[l] < v[r]));\n\tsort(ans.bgn, ans.en, clam(tmp[l] < tmp[r]));\n\treturn ans;\n}\n\nll BblCnt(vll rv) {\n\tvll v = PCmprs(rv);\n\tSegT<ll> b(v.sz, 0);\n\tll ans = 0;\n\tREP(i, v.sz) {\n\t\tans += (i - b.que(0, v[i]));\n\t\tb.add(v[i], 1);\n\t}\n\treturn ans;\n}\n\npl NGrid(pl p, ll i, ll H, ll W) {\n\tp = mp(p.fi + DX[i], p.se + DY[i]);\n\tif (p.fi < 0 || p.fi >= H || p.se < 0 || p.se >= W) return mp(INF, INF);\n\treturn p;\n}\n\nvvll llGrid(vs v) {\n\tvvll r(v.sz, vll(v.sz ? v[0].sz : 0, 0));\n\tREP(h, v.sz) REP(w, v.sz ? v[0].sz : 0) r[h][w] = (v[h][w] == '#');\n\treturn r;\n}\n\ntemplate <class T> auto ven(T val) { return val; }\ntemplate <> auto ven<int>(int val) { return (ll)val; }\ntemplate <class T, class... Args> auto ven(T val, Args... args) {\n\tauto tmp = ven(args...);\n\treturn V<decltype(tmp)>(val, tmp);\n}\n\ntemplate <class T> void zind(T& v) { v--; }\ntemplate <class T> void zind(V<T>& v) { ROR(v, i) zind(i); }\ntemplate <class T, class... Args> void zind(T& v, Args&... args) { zind(v); zind(args...); }\n\nvoid Solve();\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(20) << fixed;\n\tSolve();\n}\n\n//index_sort\n\nll N;\nvvpl adj;\nvvd dp;\nvvd dp1;\nvvd dp2;\n\ndbl dfs(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tdbl tmp = 0;\n\tll y = adj[x][n].fi;\n\tREP(i, adj[y].sz) {\n\t\tif (adj[y][i].fi == x) continue;\n\t\ttmp += dfs(y, i);\n\t}\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\ndbl rec(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tll y = adj[x][n].fi;\n\tif (!dp1[y].sz) {\n\t\tdp1[y].asn(dp[y].sz, 0);\n\t\tdp2[y].asn(dp[y].sz, 0);\n\t\tFOR(i, 1, dp[y].sz - 1) dp1[y][i] = dp1[y][i - 1] + rec(y, i - 1);\n\t\trFOR(i, 0, dp[y].sz - 2) dp2[y][i] = dp2[y][i + 1] + rec(y, i + 1);\n\t}\n\tdbl tmp = dp1[y][adj[x][n].se] + dp2[y][adj[x][n].se];\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\n\nvoid Solve() {\n\n\tcin >> N;\n\tif (N == 1) { sal(0); return; }\n\tadj = ven(N, vpl(0));\n\tdp = ven(N, vd(0));\n\tdp1 = ven(N, vd(0));\n\tdp2 = ven(N, vd(0));\n\tREP(i, N - 1) {\n\t\tli(u, v);\n\t\tu--; v--;\n\t\tadj[u].pb(mp(v, adj[v].sz));\n\t\tadj[v].pb(mp(u, adj[u].sz - 1));\n\t\tdp[u].pb(-1);\n\t\tdp[v].pb(-1);\n\t}\n\tREP(i, adj[0].sz) dfs(0, i);\n\tREP(i, N) {\n\t\tdbl tmp = 0;\n\t\tREP(j,adj[i].sz) {\n\t\t\ttmp += rec(i, j);\n\t\t}\n\t\ttmp /= dbl(adj[i].sz);\n\t\tsal(tmp);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 150000;//頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v)+1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\ndouble get(int32_t v) {\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\t++count;\n\t\tsum += get(c.first, v) + 1;\n\t}\n\tif (count == 0) {\n\t\treturn 0;\n\t}\n\treturn sum / count;\n}\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout  << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << get(i) << endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n\ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return 0.0;\n\tif(dp[P(prev,now)] >= EPS) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t}\n\n\tcout << n - 1 << endl;\n\tfor (int i = 2; i < n - 1; i++){\n\t\tfloat ans = (n - 1) / 2;\n\t\tcout << ans << endl;\n\t}\n\tcout << n - 1 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, int> , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, p)] != 0)\n        return mp[make_pair(v, p)] * t;\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, 1.0 / k) + 1.0 / k;\n    }\n    mp[make_pair(v, p)] = ans;\n    return ans * t;\n}\nint main()\n{\n    int n, i, x, y;\n\n    scanf(\"%d\", &n);\n\n    for(i = 1; i < n; ++i)\n    {\n        scanf(\"%d %d\", &x, &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint n;\nvector<int> vec[150000];\ndouble ans[150000];\ndouble p[150000];\n// 0-rootでそのノード以下で訪れる期待値\n\ndouble dfs1(int d, int from=-1){\n  double ret=0;\n  int cnt=0;\n  for(auto to : vec[d]) if(to != from){\n    ret += dfs1(to, d);\n    cnt++;\n  }\n  if(cnt==0) ret = 1.0;\n  else ret = ret/cnt + 1.0;\n\n  return p[d] = ret;\n}\n\nvoid dfs2(int d, int from=-1, double pass=0){\n  double acc = pass;\n  for(auto to : vec[d]) if(to != from) acc += p[to];\n  ans[d] = acc/vec[d].size() + 1.0;\n\n  for(auto to : vec[d]) if(to != from){\n    double tmp;\n    if(vec[d].size()==1) tmp = 1.0;\n    else tmp = (acc - p[to])/(vec[d].size()-1) + 1.0;\n    dfs2(to, d, tmp);\n  }\n}\n\nint main(){\n  cin>>n;\n  rep(i,n-1){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    vec[a].pb(b);\n    vec[b].pb(a);\n  }\n\n  dfs1(0);\n//  rep(i,n) dbg(p[i]);\n  dfs2(0);\n\n  rep(i,n) printf(\"%.7f\\n\", ans[i]-1.0);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nVI e[150000];\ndouble p1[150000], ans[150000];\n\ndouble dfs(int now, int past){\n    double res = 0.0;\n    double p = 1.0/e[now].size();\n    if (past != -1) p = 1.0/(e[now].size()-1);\n    for (auto next : e[now]){\n        if (next == past) continue;\n        double a = dfs(next,now);\n        res += p * (1 + a);\n        ans[now] += 1.0/e[now].size() * (1 + a);\n    }\n    return p1[now] = res;\n}\n\ndouble dfs2(int now, int past, double pp){\n    int n = e[now].size();\n    pp /= n;\n    ans[now] += pp;\n    if (n == 1){\n        if (e[now][0] != past) dfs2(e[now][0], now, 1.0);\n        return 0;\n    }\n    for (auto next : e[now]){\n        if (next == past) continue;\n        dfs2(next, now, (ans[now] - (p1[next]+1)/n)*n/(n-1.0) + 1);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--;\n        v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0,-1,0.0);\n    REP(i,n){\n        printf(\"%.10f\\n\", ans[i]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=150001;\nint i,j,t,n,d[N],fa[N],en[N+N],nxt[N+N];\ndouble f[N],g[N];\nvoid dfs1(int u,int p)\n{\n\tfor(int i=fa[u];i;i=nxt[i])if(en[i]^p)\n\t\t++d[u],dfs1(en[i],u),f[u]+=f[en[i]];\n\tif(d[u])f[u]=f[u]/d[u]+1;\n}\nvoid dfs2(int u,int p)\n{\n\tfor(int i=fa[u],v;i;i=nxt[i])if((v=en[i])^p)\n\t{\n\t\tif(p)g[v]=(f[u]*d[u]-f[v]-1+g[u])/d[u];else\n\t\tif(d[u]>1)g[v]=(f[u]*d[u]-f[v]-1)/(d[u]-1);\n\t\t++g[v],dfs2(v,u);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(;++t<n+n-1;)\n\t{\n\t\tscanf(\"%d%d\",&i,&j);\n\t\ten[t]=j,nxt[t]=fa[i],fa[i]=t;\n\t\ten[++t]=i,nxt[t]=fa[j],fa[j]=t;\n\t}\n\tfor(dfs1(1,0),dfs2(1,i=0);i++<n;)\n\t\tprintf(\"%.6lf\\n\",g[i]?(f[i]*d[i]+g[i])/(d[i]+1):f[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nvector<int> vec[1000];\n\ndouble dfs(int x, int p) {\n\tdouble ans = 0;\n\tinc(i, vec[x].size()) {\n\t\tif(vec[x][i] == p) { continue; }\n\t\tans += dfs(vec[x][i], x) / (vec[x].size() - (p != -1));\n\t}\n\t\n\treturn ans + 1.0;\n}\n\nint main() {\n\tcin >> n;\n\tinc(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tvec[u].PB(v);\n\t\tvec[v].PB(u);\n\t}\n\t\n\tif(n > 1000) { return 1; }\n\t\n\tinc(i, n) {\n\t\tcout << dfs(i, -1) - 1.0 << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) if (abs(g[u][i].second - gnum) != n) {\n\t\tcnt++;\n\t\tif (dp[g[u][i].second] != -1.0) res += dp[g[u][i].second];\n\t\telse res += dfs(g[u][i].first, g[u][i].second);\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = (res + cnt) / cnt;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second);\n\t\t\n\t\tif (g[i].size() == 0) ans = 0;\n\t\telse ans = (ans + g[i].size()) / g[i].size();\n\t\t\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  D\n//\n//  Created by 黄宇凡 on 2017/4/9.\n//  Copyright © 2017年 黄宇凡. All rights reserved.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 150000 + 5;\n\ndouble dp[maxn][2];\nvector<int> G[maxn];\n\nint n;\n\nvoid dfs(int u,int fa){\n    dp[u][0] = 1.0;\n    int deg = G[u].size() - (u != fa);\n    //cout << deg << endl;\n    for(int i = 0;i < G[u].size();i++){\n        int v = G[u][i];\n        if(v == fa) continue;\n        dfs(v,u);\n        dp[u][0] += 1.0 / deg * dp[v][0];\n    }\n    //cout << u << \"!!!\" << dp[u][0] << endl;\n}\n\nvoid Dfs(int u,int fa){\n    if(u == fa){\n        dp[u][1] = dp[u][0];\n    }else{\n        int d1 = G[u].size();\n        int d2 = G[fa].size();\n        dp[u][1] = 1.0 * (d1 - 1) / d1 * (dp[u][0] - 1) + 1 + 1.0 / d1 * ((d2 == 1 ? 0 : ((dp[fa][1] - 1) - 1.0 / d2 * dp[u][0]) * 1.0 * d2 / (d2 - 1)) + 1);\n    }\n    for(int i = 0;i < G[u].size();i++){\n        int v = G[u][i];\n        if(v == fa) continue;\n        Dfs(v,u);\n    }\n}\n\n\nint main(int argc, const char * argv[]) {\n    cin >> n;\n    for(int i = 1;i <= n;i++) G[i].clear();\n    for(int i = 1;i < n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1,1);\n    Dfs(1,1);\n    for(int i = 1;i <= n;i++){\n        //cout << dp[i][0] << endl;\n        //cout << dp[i][1] - 1 << endl;\n        printf(\"%.10lf\\n\",dp[i][1] - 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nVI g[150010];\nsigned main(void)\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n-1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].PB(v);\n\t\tg[v].PB(u);\n\t}\n\n\tREP(i, n) {\n\t\t//cout << i << \" \" << g[i].size() << endl;\n\t\tif(g[i].size() == 1) {\n\t\t\tcout << fixed << setprecision(9) << (double)n-1 << endl;\n\t\t} else {\n\t\t\tcout << fixed << setprecision(9) << ((double)n-1)/2 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define __ <<\" \"<<\n#define ___ <<\" \"\n#define bash push_back\n#define ALL(x) x.begin(),x.end()\n//#define int long long\nstruct IoSetup {\n    IoSetup() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n}IoSetup;\n\nusing Int = int;\nusing ll = long long;\nusing pii = pair<int, int>;\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr int SMOD = 1000000007;\nconstexpr int NMOD = 998244353;\nconstexpr int dx[]={1,0,-1,0,1,1,-1,-1};\nconstexpr int dy[]={0,-1,0,1,-1,1,-1,1};\n\ninline bool inside(int x,int y,int w,int h){return (x>=0 && y>=0 && x<w && y<h);}\ntemplate<class T>bool chmax(T &a, const T&b){if(a<b)return(a=b,1);return 0;}\ntemplate<class T>bool chmin(T &a, const T&b){if(b<a)return(a=b,1);return 0;}\n\ntemplate< typename sum_t, typename key_t >\nstruct ReRooting {\n    struct Edge {\n        int to;\n        key_t data;\n        sum_t dp, ndp;\n    };\n\n    using F = function< sum_t(sum_t, sum_t) >;\n    using G = function< sum_t(sum_t, key_t) >;\n\n    vector< vector< Edge > > g;\n    vector< sum_t > subdp, dp;\n    const sum_t ident;\n    const F f;\n    const G gg;\n\n    ReRooting(int V, const F f, const G g, const sum_t &ident)\n        : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const key_t &d = key_t(1)) {\n        g[u].emplace_back((Edge) {v, d, ident, ident});\n        g[v].emplace_back((Edge) {u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const key_t &d, const key_t &e) {\n        g[u].emplace_back((Edge) {v, d, ident, ident});\n        g[v].emplace_back((Edge) {u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for(auto &e : g[idx]) {\n            if(e.to == par) continue;\n            dfs_sub(e.to, idx);\n            subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const sum_t &top) {\n        sum_t buff{ident};\n        for(int i = 0; i < (int) g[idx].size(); i++) {\n            auto &e = g[idx][i];\n            e.ndp = buff;\n            e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n            auto &e = g[idx][i];\n            if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n            e.ndp = f(e.ndp, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector< sum_t > build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n\nsigned main() {\n\n    int n;\n    cin >> n;\n\n    using P = pair<double, int>;\n\n    auto f1 = [](P a, P b) {\n        return P(a.first + b.first, a.second + b.second);\n    };\n\n    auto f2 = [](P a, int data) {\n        return P((a.second?a.first/a.second:0) + 1.0, 1);\n    };\n\n    ReRooting<P, int> g(n, f1, f2, P(0.0,0));\n\n    for(int i = 1; i < n; i++) {\n        int s, t;\n        cin >> s >> t;\n        s--,--t;\n\n        g.add_edge(s, t);\n    }\n\n    for(auto&p:g.build()) {\n        cout << (p.second?p.first/p.second:0.0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    int b=par[a];\n    ld p=v[b].size();\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    \n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        dfs2(x);\n    }\n    \n    \n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    //cout<<\"W\"<<endl;\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    dfs2(0);\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t}\n\n\tcout << n - 1 << endl;\n\tfor (int i = 2; i <= n - 1; i++){\n\t\tdouble ans = n - 1;\n\t\tcout << ans/2 << endl;\n\t}\n\tcout << n - 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\ntemplate <class S, class T> using P = pair<S, T>;\ntemplate <class... T> using TP = tuple<T...>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing dbl = double;\nusing str = string;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing tl = TP<ll, ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vtl = V<tl>;\nusing vvtl = V<vtl>;\nusing vs = V<str>;\nusing vvs = V<vs>;\nusing vd = V<dbl>;\nusing vvd = V<vd>;\nusing vvvd = V<vvd>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing stll = stack<ll>;\nusing stpl = stack<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n//#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define fr front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define ROR(v,i) for(auto &(i):(v))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).bgn,(a).en)\n#define NEXTP(a) next_permutation((a).bgn,(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define fs(a) cout <<((a)?\"second\":\"first\")<<\"\\n\";\n#define Fs(a) cout <<((a)?\"Second\":\"First\")<<\"\\n\";\n#define FS(a) cout <<((a)?\"SECOND\":\"FIRST\")<<\"\\n\";\n//#define say(a) cout <<(a);\n//#define sal(a) cout <<(a)<<\"\\n\";\n#define sak cout <<\"\\n\";\n#define sas cout <<\" \";\n#define sat cout <<\"\\t\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define dbgs(...) dal(#__VA_ARGS__);dal(__VA_ARGS__);\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define LSB(a) ((a)&(-(a)))\n/*#define llin(a) ll (a);cin >>(a);\n#define llin2(a,b) ll (a),(b);cin >>(a)>>(b);\n#define llin3(a,b,c) ll (a),(b),(c);cin >>(a)>>(b)>>(c);\n#define stin(a) string (a);cin >>(a);*/\n#define vin(v) ROR((v),(i)){cin >>(i);};\n#define vllin(N,v) vll (v)((N));vin(v);\n#define vllin2(N,a,b) vll (a)(N),(b)(N);REP(i,N){cin>>(a)[i]>>(b)[i];};\n#define vsin(N,v) vs (v)((N));vin(v);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n#define tg(t,i) get<i>(t)\n\n#define Id(x) get<0>(x)\n#define Act(x) get<1>(x)\n#define InvAct(x) get<2>(x)\n#define mg(id,act) mt(id,act,lam(l))\n//#define MonoidSet(T) TP<T, function<T(T, T)>>\n#define GroupSet(T) TP<T, function<T(T, T)>, function<T(T, T)>>\n#define CompareSet(T) TP<T, function<bool(T, T)>>\n#define lam(lr) ([](auto l, auto r){return (lr);})\n#define elam(lr) ([=](auto l, auto r){return (lr);})\n#define clam(lr) ([&](auto l, auto r){return (lr);})\n#define lamr(lr) ([](auto l, auto r){lr})\n#define elamr(lr) ([=](auto l, auto r){lr})\n#define clamr(lr) ([&](auto l, auto r){lr})\n#define min(...) Operation(MIN,__VA_ARGS__)\n#define max(...) Operation(MAX,__VA_ARGS__)\n#define gcd(...) Operation(GCD,__VA_ARGS__)\n#define lcm(...) Operation(LCM,__VA_ARGS__)\n#define vmin(...) VOperation(MIN,__VA_ARGS__)\n#define vmax(...) VOperation(MAX,__VA_ARGS__)\n#define vgcd(...) VOperation(GCD,__VA_ARGS__)\n#define vlcm(...) VOperation(LCM,__VA_ARGS__)\n#define vsum(...) VOperation(ADD,__VA_ARGS__)\n#define vpro(...) VOperation(MUL,__VA_ARGS__)\n#define emin(a, ...) ((a)=min((a),__VA_ARGS__))\n#define emax(a, ...) ((a)=max((a),__VA_ARGS__))\n#define egcd(a, ...) ((a)=gcd((a),__VA_ARGS__))\n#define elcm(a, ...) ((a)=lcm((a),__VA_ARGS__))\n#define ope Operation\n#define vope VOperation\n\n#define svll SumV<ll>\n#define svvll SumV2<ll>\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) str __VA_ARGS__;Input(__VA_ARGS__);\n//#define vli(size, ...) vll __VA_ARGS__;vInitInput(size,__VA_ARGS__);\n#define vlr(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vlc(size, ...) vll __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsr(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsc(size, ...) vs __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vli2(rowSize,columnSize, ...) vvll __VA_ARGS__;vInitInput2(rowSize,columnSize,__VA_ARGS__);\n#define vplr(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vplc(size, ...) vpl __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vpli(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst vll DX = { 0,-1,0,1,0,-1,1,1,-1 };\nconst vll DY = { 0,0,-1,0,1,-1,-1,1,1 };\nconst str alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst str ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <class T> auto GetVectorValueType(T v) { return v; }\ntemplate <class T> auto GetVectorValueType(V<T> v) { return GetVectorValueType(T()); }\n\ntemplate <class S, class T> istream &operator>>(istream &in, P<S, T> &p) { return in >> p.fi >> p.se; }\ntemplate <class T> istream &operator>>(istream &in, V<T> &v) { REP(i, v.sz) in >> v[i]; return in; }\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n\tcin >> var;\n\tInput(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n\tv.res(size);\n\tvInit(size, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class T, class... Args> void vInput(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInput(size, args...);\n}\nvoid vInputR(ll size) {}\ntemplate <class T, class... Args> void vInputR(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInputR(size, args...);\n}\nvoid vInputNumC(ll num) {}\ntemplate <class T, class... Args> void vInputNumC(ll num, V<T>& v, Args&... args) {\n\tcin >> v[num];\n\tvInputNumC(num, args...);\n}\nvoid vInputC(ll size) {}\ntemplate <class... Args> void vInputC(ll size, Args&... args) {\n\tREP(i, size) vInputNumC(i, args...);\n}\nvoid vInitInputR(ll size) {}\ntemplate <class... Args> void vInitInputR(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputR(size, args...);\n}\nvoid vInitInputC(ll size) {}\ntemplate <class... Args> void vInitInputC(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputC(size, args...);\n}\nvoid vInit2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInit2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tv.asn(rowSize, V<T>(columnSize));\n\tvInit2(rowSize, columnSize, args...);\n}\nvoid vInput2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInput2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tREP(r, rowSize) {\n\t\tREP(c, columnSize) {\n\t\t\tcin >> v[r][c];\n\t\t}\n\t}\n\tvInput2(rowSize, columnSize, args...);\n}\nvoid vInitInput2(ll rowSize, ll columnSize) {}\ntemplate <class... Args> void vInitInput2(ll rowSize, ll columnSize, Args&... args) {\n\tvInit2(rowSize, columnSize, args...);\n\tvInput2(rowSize, columnSize, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n\treturn out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n\tif (v.emp) return out << \"{}\";\n\telse {\n\t\tauto itr = v.bgn;\n\t\tout << \"{\" << *itr;\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \"}\";\n\t\treturn out;\n\t}\n}\ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n\tif (m.emp) return out << \"<[]>\";\n\telse {\n\t\tauto itr = m.bgn;\n\t\tout << \"< [\" << (itr->fi) << \": \" << (itr->se);\n\t\titr++;\n\t\twhile (itr != m.en) {\n\t\t\tout << \"], [\" << (itr->fi) << \": \" << (itr->se);\n\t\t\titr++;\n\t\t}\n\t\tout << \"] >\";\n\t\treturn out;\n\t}\n}\ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n\tif (s.emp) return out << \"<>\";\n\telse {\n\t\tauto itr = s.bgn;\n\t\tout << \"<\" << *itr;\n\t\titr++;\n\t\twhile (itr != s.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \">\";\n\t\treturn out;\n\t}\n}\n\nvoid say() {}\ntemplate <class T> void say(T t) { cout << t; }\ntemplate <class Head, class... Body> void say(Head head, Body... body) {\n\tcout << head << \" \";\n\tsay(body...);\n}\nvoid sal() { cout << \"\\n\"; }\ntemplate <class... Args> void sal(Args... args) {\n\tsay(args...);\n\tcout << \"\\n\";\n}\n\nvoid day() {}\ntemplate <class T> void day(T t) { cerr << t; }\ntemplate <class Head, class... Body> void day(Head head, Body... body) {\n\tcerr << head << \" \";\n\tday(body...);\n}\nvoid dal() { cerr << \"\\n\"; }\ntemplate <class... Args> void dal(Args... args) {\n\tday(args...);\n\tcerr << \"\\n\";\n}\n\nvoid salv() {}\ntemplate <class T> void salv(V<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tauto itr = v.bgn;\n\t\tsay(*itr);\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tsas;\n\t\t\tsay(*itr);\n\t\t\titr++;\n\t\t}\n\t\tsak;\n\t}\n}\ntemplate <class T> void salv(VV<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tROR(v, i) salv(i);\n\t}\n}\ntemplate <class T, class... Args> void salv(T v, Args... args) {\n\tsalv(v);\n\tsalv(args...);\n}\n\n\ntemplate <class L, class R> auto Gcd(L l, R r) -> decltype(l + r) {\n\tif (l < r) swap(l, r);\n\treturn r ? Gcd(r, l%r) : l;\n}\ntemplate <class L, class R> auto Lcm(L l, R r) {\n\tif (!l || !r) return 0;\n\treturn l / Gcd(l, r) * r;\n}\n\n/*\nauto LES = mp(INF, lam(return l < r;));\nauto GRT = mp(-INF, lam(return l > r;));\nauto EQ = mp(0, lam(return l == r;));\n\nauto ADD = mp(0, lam(return l + r;));\nauto SUB = mp(0, lam(return l - r;));\nauto MUL = mp(1, lam(return l * r;));\nauto DIV = mp(1, lam(return l / r;));\nauto MDL = mp(1, lam(return l % r;));\nauto XOR = mp(0, lam(return l ^ r;));\nauto OR = mp(0, lam(return l | r;));\nauto AND = mp(((ll)(1) << 63) - 1, lam(return l & r;));\nauto MIN = mp(INF, lam(return (l < r) ? l : r;));\nauto MAX = mp(-INF, lam(return (l > r) ? l : r;));\nauto GCD = mp(0, lam(return Gcd(l, r);));\nauto LCM = mp(1, lam(return Lcm(l, r);));\n*/\n\nauto LES = mp(INF, lam(l < r));\nauto GRT = mp(-INF, lam(l > r));\nauto EQ = mp(0, lam(l == r));\n\nauto ADD = mt(0, lam(l + r), lam(l - r));\nauto MUL = mt(1, lam(l * r), lam(l / r));\nauto XOR = mt(0, lam(l ^ r), lam(l ^ r));\nauto OR = mg(0, lam(l | r));\nauto AND = mg(((ll)(1) << 63) - 1, lam(l & r));\nauto MIN = mg(0, lam((l < r) ? l : r));\nauto MAX = mg(0, lam((l > r) ? l : r));\nauto GCD = mg(0, lam(Gcd(l, r)));\nauto LCM = mg(0, lam(Lcm(l, r)));\n\ntemplate <class OperationType> auto Operation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto Operation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T, class... Args> auto Operation(OperationType A, T x, Args... args) {\n\tauto tmp = Operation(A, args...);\n\treturn Act(A)(x, tmp);\n}\n\ntemplate <class OperationType> auto VOperation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, V<T> v) {\n\tif (v.emp) {\n\t\tdecltype(GetVectorValueType(T())) tmp = Id(A);\n\t\treturn tmp;\n\t}\n\tauto tmp = VOperation(A, v[0]);\n\tFOR(i, 1, v.sz - 1) tmp = Act(A)(tmp, VOperation(A, v[i]));\n\treturn tmp;\n}\ntemplate <class OperationType, class T, class... Args> auto VOperation(OperationType A, T x, Args... args) {\n\tauto xResult = VOperation(A, x);\n\tauto tmp = VOperation(A, args...);\n\treturn Act(A)(xResult, tmp);\n}\n\n\nll Bset(ll a, ll b, ll c) {\n\tif (c) a |= b;\n\telse a &= ~b;\n\treturn a;\n}\n\n\nstruct UFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tUFT(ll tsizeget, ll modeget = 0){\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct pUFT {\n\npublic:\n\n\tll tsize;\n\tll now;\n\tvll par;\n\tvll rank;\n\tvll mtime;\n\tvvll sizepi;\n\tVV<T> sizepv;\n\tV<T> elm;\n\tGroupSet(T) Add;\n\n\tpUFT(ll tsize, GroupSet(T) Add = ADD) : tsize(tsize), Add(Add) { init(); }\n\tvoid init() {\n\t\tnow = 0;\n\t\tpar.asn(tsize, -1);\n\t\trank.asn(tsize, 0);\n\t\tmtime.asn(tsize, INF);\n\t\tsizepi.asn(tsize, { 0 });\n\t\tsizepv.asn(tsize, {});\n\t}\n\tvoid set(ll x, T s) {\n\t\telm[x] = s;\n\t\tsizepv[x] = { s };\n\t}\n\tll root(ll x, ll t) {\n\t\treturn (mtime[x] > t) ? x : root(par[x], t);\n\t}\n\tbool same(ll x, ll y, ll t) {\n\t\treturn root(x, t) == root(y, t);\n\t}\n\tll merge(ll x, ll y) {\n\t\tnow++;\n\t\tx = root(x, now);\n\t\ty = root(y, now);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[y].pb(now);\n\t\t\t\tsizepv[y].pb(elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t\tmtime[x] = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[x].pb(now);\n\t\t\t\tsizepv[x].pb(elm[x]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tmtime[y] = now;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tT size(ll x, ll t) {\n\t\tx = root(x, t);\n\t\treturn sizepv[x][UPB(sizepi[x], t) - 1];\n\t}\n\n};\n\nstruct wUFT {\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tvll dweight;\n\twUFT(ll tsizeget, ll modeget = 0) {\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\tdweight.asn(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\tif (par[x] < 0) return x;\n\t\telse {\n\t\t\tll r = root(par[x]);\n\t\t\tdweight[x] += dweight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\tll weight(ll x) {\n\t\troot(x);\n\t\treturn dweight[x];\n\t}\n\tll diff(ll x, ll y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y, ll w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t\tdweight[x] = -w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t\tdweight[y] = w;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct sUFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tGroupSet(T) Add;\n\tV<T> elm;\n\tsUFT(ll tsize, GroupSet(T) Add = ADD, ll mode = 0) : tsize(tsize), Add(Add), mode(mode) { init(); }\n\tvoid init() {\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\telm.asn(tsize, Id(Add));\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tT size(ll x) {\n\t\treturn elm[root(x)];\n\t}\n\tT& operator[](ll x) { return elm[x]; }\n};\n\ntemplate <typename valtype> class SegT {\n\npublic:\n\n\tll size;\n\tvector<valtype> v;\n\n\tvaltype initv;\n\tfunction<valtype(valtype x, valtype y)> calc;\n\n\tSegT() {}\n\tSegT(const SegT &segt) {}\n\n\tSegT(ll sizeget, ll modeget = 0) {\n\t\tsizeset(sizeget);\n\t\tmodeset(modeget);\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, ll modeget = 0) {\n\t\tsizeset(cpyvec.sz);\n\t\tmodeset(modeget);\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tSegT(ll sizeget, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(sizeget);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(cpyvec.sz);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tvoid sizeset(ll rsize) {\n\t\tsize = DigN2(rsize);\n\t\tif (rsize == Pow2(size - 1)) size--;\n\t\treturn;\n\t}\n\tvoid modeset(ll mode) {\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tinitv = 0;\n\t\t\tcalc = [](valtype x, valtype y) {return x + y; };\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinitv = INF;\n\t\t\tcalc = [](valtype x, valtype y) {return min(x, y); };\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinitv = -INF;\n\t\t\tcalc = [](valtype x, valtype y) {return max(x, y); };\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tvoid init() {\n\t\tv.asn(Pow2(size + 1) - 1, initv);\n\t}\n\tvoid copy(vector<valtype> cpyvec) {\n\t\tREP(i, min(cpyvec.sz, Pow2(size))) set(i, cpyvec[i]);\n\t}\n\tll i2v(ll i) const{\n\t\tif (i < 0 || i >= Pow2(size)) return -1;\n\t\treturn Pow2(size) + i - 1;\n\t}\n\tll top(ll i) const{\n\t\tif (i == 0) return -1;\n\t\treturn (i - 1) / 2;\n\t}\n\tpl bot(ll i) const{\n\t\tif (i + 1 >= Pow2(size)) return mp(-1, -1);\n\t\treturn mp(2 * i + 1, 2 * i + 2);\n\t}\n\tvoid set(ll i, valtype x) {\n\t\ti = i2v(i);\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = top(i);\n\t\t\tv[i] = calc(v[bot(i).fi], v[bot(i).se]);\n\t\t}\n\t\treturn;\n\t}\n\tvoid add(ll i, valtype x) {\n\t\tset(i, v[i2v(i)] + x);\n\t\treturn;\n\t}\n\tvaltype operator[](const ll &i) const {\n\t\treturn v[i2v(i)];\n\t}\n//\tvaltype que(ll a = 0, ll b = Pow2(size) - 1) {\n\tvaltype que(ll a, ll b) {\n\t\tif (a == b) return v[i2v(a)];\n\t\tif (a > b) return initv;//swap(a, b);\n\t\tvaltype ans = initv;\n\t\tll ai = i2v(a);\n\t\tll bi = i2v(b);\n\t\tFOR(i, 1, size + 1) {\n\t\t\tif (a > b) break;\n\t\t\tif (a%Pow2(i)) {\n\t\t\t\tans = calc(ans, v[ai]);\n\t\t\t\ta += Pow2(i - 1);\n\t\t\t\tai = top(ai) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tai = top(ai);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t\tif ((b + 1) % Pow2(i)) {\n\t\t\t\tans = calc(ans, v[bi]);\n\t\t\t\tb -= Pow2(i - 1);\n\t\t\t\tbi = top(bi) - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbi = top(bi);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t}\n\t\treturn ans;\n\t}\n\tvaltype que(ll b) {\n\t\treturn que(0, b);\n\t}\n\tvaltype que() {\n\t\treturn que(0, Pow2(size) - 1);\n\t}\n\n\n};\n\n\n/*template <class Type> class DP {\n\npublic:\n\n\tvector<Type> v;\n\tType initv;\n\tvll size, block;\n\n\tDP() {}\n\tDP(const DP &dp) {}\n\n\ttemplate<class... Args> DP(Args... args) {\n\t\tblock.asn(1, 1);\n\t\tInitialize(args...);\n\t}\n\n\tvoid Initialize(Type initv_) {\n\t\tinitv = initv_;\n\t\tv.asn(block.bk, initv);\n\t}\n\ttemplate<class... Args> void Initialize(ll val, Args... args) {\n\t\tsize.pb(val);\n\t\tblock.pb(block.bk*val);\n\t\tInitialize(args...);\n\t}\n\n\n\n};*/\n\n\npl Bezout(ll a, ll b) {\n\tif (b != 0) {\n\t\tpl xy;\n\t\txy = Bezout(b, a%b);\n\t\treturn mp(xy.se, xy.fi - ((a / b)*xy.se));\n\t}\n\telse {\n\t\treturn mp(1, 0);\n\t}\n}\npl Bez(ll a, ll b, ll c) {\n\tpl xy;\n\tll x, y, z, gc;\n\txy = Bezout(a, b);\n\tgc = gcd(a, b);\n\tif (c%gc != 0) return mp(-1, -1);\n\tx = xy.fi*(c / gc); y = xy.se*(c / gc);\n\tif (x < 0) z = rup(-x, (b / gc));\n\tif (x >= 0) z = -x / (b / gc);\n\tx += z * (b / gc);\n\ty -= z * (a / gc);\n\treturn mp(x, y);\n}\n\nll DigS10(ll n) {\n\tll ans = 0;\n\twhile(1) {\n\t\tans += n % 10;\n\t\tn /= 10;\n\t\tif (!n) break;\n\t}\n\treturn ans;\n}\n\nll isP(ll n) {\n\tif (n <= 1) return 0;\n\tFOR(i, 2, (ll)sqrt(n) + 1) {\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nll Tot(ll n) {\n\tif (n <= 0) return 0;\n\tll ans = n, x = 2;\n\twhile (x*x <= n) {\n\t\tif (n%x == 0) {\n\t\t\tans -= ans / x;\n\t\t\twhile (n%x == 0) n /= x;\n\t\t}\n\t\tx++;\n\t}\n\tif (n > 1) ans -= ans / n;\n\treturn ans;\n}\n\ntemplate <class T> struct Graph {\npublic:\n\tll vSize;\n\tll eMode;\n\tll mapMode;\n\tGroupSet(T) Add;\n\tCompareSet(T) Less;\n\tCompareSet(T) Equal;\n\tVV<P<T, ll>> adj;\n\tmap<pl, T> len;\n\tGraph(ll vSize, ll eMode = 0, ll mapMode = 0, GroupSet(T) Add = ADD, CompareSet(T) Less = LES, CompareSet(T) Equal = EQ) : vSize(vSize), eMode(eMode), mapMode(mapMode), Add(Add), Less(Less), Equal(Equal) {}\n\tvoid Init() {\n\t\tadj.asn(vSize, V<P<T, ll>>());\n\t}\n\tvoid AddE(ll x, ll y, T cost) {\n\t\tiAddE(x, y, cost);\n\t\tif (!eMode) iAddE(y, x, cost);\n\t}\n\tvoid iAddE(ll x, ll y, T cost) {\n\t\tadj[x].pb(mp(cost, y));\n\t\tif (mapMode) len[mp(x, y)] = cost;\n\t}\n\tP<bool, T> getE(ll x, ll y) {\n\t\tif (!len.count(mp(x, y))) return mp(false, Id(Less));\n\t\treturn mp(true, len[mp(x, y)]);\n\t}\n\tV<T> Dijk(ll x) {\n\t\tV<T> ans(vSize, Id(Less));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se] = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se], i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tV<P<T, vll>> rDijk(ll x) {\n\t\tV<P<T, vll>> ans(vSize, mp(Id(Less), vll()));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se].fi = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tans[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tT Prim(ll x = 0) {\n\t\tT ans = Id(Add);\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans = Act(Add)(ans, segt[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tP<T, V<P<T, vll>>> rPrim(ll x = 0) {\n\t\tP<T, V<P<T, vll>>> ans = mp(Id(Add), V<P<T, vll>>(vSize, mp(Id(Less), vll())));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans.se[now.se].fi = segt[now.se].fi;\n\t\t\tans.fi = Act(Add)(ans.fi, ans.se[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tans.se[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\ntemplate <class T> struct Sum {\npublic:\n\tV<T> v, s;\n\tll size;\n\tGroupSet(T) Add;\n\tSum(V<T> v, GroupSet(T) Add = ADD) : v(v), size(v.sz), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(size + 1, Id(Add));\n\t}\n\tvoid Calc() {\n\t\tREP(i, size) s[i + 1] = Act(Add)(s[i], v[i]);\n\t}\n\tT operator()(ll x) {\n\t\tif (x < -1) x = -1;\n\t\tif (x > size - 1) x = size - 1;\n\t\treturn s[x + 1];\n\t}\n\tT operator()(ll l, ll r) {\n\t\tif (l < 0) l = 0;\n\t\tif (r >= size) r = size - 1;\n\t\tif (l > r) return Id(Add);\n\t\treturn InvAct(Add)(s[r + 1], s[l]);\n\t}\n};\nusing sumll = Sum<ll>;\n\ntemplate <class T> struct Sum2 {\npublic:\n\tVV<T> v, s;\n\tll RowSize, ColumnSize;\n\tGroupSet(T) Add;\n\tSum2(VV<T> v, GroupSet(T) Add = ADD) : v(v), RowSize(v.sz), ColumnSize(v.sz ? v[0].sz : 0), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(RowSize + 1, V<T>(ColumnSize + 1, Id(Add)));\n\t}\n\tvoid Calc() {\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n//\t\t\t\ts[r][c] = InvAct(Add)(Act(Add)(Act(Add)(v[r - 1][c - 1], operator()(r - 1, c - 2)), operator()(r - 2, c - 1)), operator()(r - 2, c - 2));\n\t\t\t\ts[r][c] = Act(Add)(s[r][c - 1], v[r - 1][c - 1]);\n\t\t\t}\n\t\t}\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n\t\t\t\ts[r][c] = Act(Add)(s[r - 1][c], s[r][c]);\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(ll r, ll c) {\n\t\tif (r < -1) r = -1;\n\t\tif (c < -1) c = -1;\n\t\tif (r > RowSize - 1) r = RowSize - 1;\n\t\tif (c > ColumnSize - 1) c = ColumnSize - 1;\n\t\treturn s[r + 1][c + 1];\n\t}\n\tT operator()(ll r1, ll c1, ll r2, ll c2) {\n\t\tif (r1 < 0) r1 = 0;\n\t\tif (c1 < 0) c1 = 0;\n\t\tif (r2 >= RowSize) r2 = RowSize - 1;\n\t\tif (c2 >= ColumnSize) c2 = ColumnSize - 1;\n\t\tif (r1 > r2) return Id(Add);\n\t\tif (c1 > c2) return Id(Add);\n\t\treturn InvAct(Add)(Act(Add)(s[r2 + 1][c2 + 1], s[r1][c1]), Act(Add)(s[r2 + 1][c1], s[r1][c2 + 1]));\n\t}\n};\nusing sumll2 = Sum2<ll>;\n\ntemplate <class T> struct Point2 {\npublic:\n\tVV<T> v;\n\tll h, w;\n\tPoint2() : h(0), w(0) {}\n\tPoint2(ll h, ll w) : h(h), w(w) { asn(h, w); }\n\tPoint2(ll h, ll w, T val) : h(h), w(w) { asn(h, w, val); }\n\tPoint2(VV<T> cv) : h(cv.sz), w(cv.sz ? cv[0].sz : 0) { asn(h, w); copy(cv); }\n\tvoid assign(ll h, ll w) { v.asn(h, V<T>(w)); }\n\tvoid assign(ll h, ll w, ll val) { v.asn(h, V<T>(w, val)); }\n\tvoid copy(VV<T> cv) { REP(_h, h) REP(_w, w) v[_h][_w] = cv[_h][_w]; }\n\tT& operator()(ll h, ll w) { return v[h][w]; }\n\tT& operator()(pl p) { return v[p.fi][p.se]; }\n\tT& operator[](pl p) { return v[p.fi][p.se]; }\n};\ntemplate <class T> using P2 = Point2<T>;\n\ntemplate <ll Mod> struct Modll {\npublic:\n\tll v;\n\tModll() : v(0) {}\n\tModll(ll _v) { set(_v % Mod + Mod); }\n\tModll& set(ll _v) {\n\t\tv = (_v < Mod) ? _v : (_v - Mod);\n\t\treturn *this;\n\t}\n\tModll pow(ll n) const {\n\t\tModll x = *this, ans = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) ans *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tModll inverse() const { return (*this).pow(Mod - 2); }\n\tModll operator+(const Modll& m) const { return Modll().set(v + m.v); }\n\tModll operator-(const Modll& m) const { return Modll().set(Mod + v - m.v); }\n\tModll operator*(const Modll& m) const { return Modll().set((ull(v) * m.v) % Mod); }\n\tModll operator/(const Modll& m) const { return *this * m.inv; }\n\tModll& operator+=(const Modll& m) { return *this = *this + m; }\n\tModll& operator-=(const Modll& m) { return *this = *this - m; }\n\tModll& operator*=(const Modll& m) { return *this = *this * m; }\n\tModll& operator/=(const Modll& m) { return *this = *this / m; }\n\tModll operator-() const { return Modll(0) - *this; }\n\texplicit operator bool() const { return v != 0; }\n\tfriend istream& operator>>(istream& in, Modll& m) { return in >> m.v; }\n\tfriend ostream& operator<<(ostream& out, const Modll& m) { return out << m.v; }\n};\nusing mll = Modll<MOD>;\nusing vmll = V<mll>;\nusing vvmll = V<vmll>;\nusing vvvmll = V<vvmll>;\n\nvmll MFactMemo(2, 1);\nvmll MIFactMemo(2, 1);\n\nmll mFact(ll n) {\n\tif (MFactMemo.sz <= n) {\n\t\tll oldsize = MFactMemo.sz;\n\t\tMFactMemo.res(n + 1, 1);\n\t\tFOR(i, oldsize, n) MFactMemo[i] = MFactMemo[i - 1] * i;\n\t}\n\treturn MFactMemo[n];\n}\nmll miFact(ll n) {\n\tif (MIFactMemo.sz <= n) {\n\t\tll oldsize = MIFactMemo.sz;\n\t\tMIFactMemo.res(n + 1, 1);\n\t\tMIFactMemo.bk = mFact(n).inv;\n\t\trFOR(i, oldsize + 1, n) MIFactMemo[i - 1] = MIFactMemo[i] * i;\n\t}\n\treturn MIFactMemo[n];\n}\nmll mComb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn mFact(n) * miFact(k) * miFact(n - k);\n}\n\nll LIS(vll v, ll m = 0) {\n\n\tif (v.sz > 0) {\n\t\tll ans = 0;\n\t\tvll dp(v.sz, INF);\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tdp[m ? UPB(dp, v[i]) : LOWB(dp, v[i])] = v[i];\n\t\t}\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tif (dp[i] == INF) break;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n}\n\nll Bsrch(function<bool(ll x)> f, ll mi, ll ma) {\n\tll ng = mi - 1, ok = ma, mid;\n\twhile (ok - ng > 1) {\n\t\tmid = (ng + ok) / 2;\n\t\t(f(mid) ? ok : ng) = mid;\n\t}\n\treturn ok;\n}\n\ntemplate <class T, class M = decltype(MUL), class S = decltype(ADD)> VV<T> MultiMatrix(VV<T> A, VV<T> B, M Mul = MUL, S Add = ADD) {\n\tVV<T> ans;\n\tll ii = A.sz;\n\tif (!ii) return ans;\n\tll jj = A[0].sz;\n\tif (!jj) return ans;\n\tll jj2 = B.sz;\n\tif (!jj2) return ans;\n\tif (jj != jj2) return ans;\n\tll kk = B[0].sz;\n\tif (!kk) return ans;\n\tans.asn(ii, V<T>(kk, 0));\n\tREP(i, ii) {\n\t\tREP(k, kk) {\n\t\t\tREP(j, jj) {\n\t\t\t\tans[i][k] = Act(Add)(ans[i][k], Act(Mul)(A[i][j], B[j][k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n\tif ((n < 0) || (k < 0)) return 0;\n\tif (CombMemo[n][k] == -1) {\n\t\tif (n < k) CombMemo[n][k] = 0;\n\t\telse {\n\t\t\tif (n == 0) CombMemo[n][k] = 1;\n\t\t\telse if (k == 0) CombMemo[n][k] = 1;\n\t\t\telse if (n == k) CombMemo[n][k] = 1;\n\t\t\telse CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n\t\t}\n\t}\n\treturn CombMemo[n][k];\n}\n\ntemplate<class T> map<T, ll> Dict(V<T> v) {\n\tmap<T, ll> m;\n\tif (!v.sz) return m;\n\tSORT(v);\n\tUNIQUE(v);\n\tREP(i, v.sz) {\n\t\tm[v[i]] = i;\n\t}\n\treturn m;\n}\n\ntemplate <class T> vll Cmprs(V<T> v) {\n\tauto m = Dict(v);\n\tvll ans(v.sz);\n\tREP(i,v.sz) {\n\t\tans[i] = m[v[i]];\n\t}\n\treturn ans;\n}\n\ntemplate <class T> vll PCmprs(V<T> v) {\n\tif (v.sz == 0) return V<T>();\n\tvll tmp(v.sz);\n\tvll ans(v.sz);\n\tIOTA(tmp, 0);\n\tIOTA(ans, 0);\n\tsort(tmp.bgn, tmp.en, clam(v[l] < v[r]));\n\tsort(ans.bgn, ans.en, clam(tmp[l] < tmp[r]));\n\treturn ans;\n}\n\nll BblCnt(vll rv) {\n\tvll v = PCmprs(rv);\n\tSegT<ll> b(v.sz, 0);\n\tll ans = 0;\n\tREP(i, v.sz) {\n\t\tans += (i - b.que(0, v[i]));\n\t\tb.add(v[i], 1);\n\t}\n\treturn ans;\n}\n\npl NGrid(pl p, ll i, ll H, ll W) {\n\tp = mp(p.fi + DX[i], p.se + DY[i]);\n\tif (p.fi < 0 || p.fi >= H || p.se < 0 || p.se >= W) return mp(INF, INF);\n\treturn p;\n}\n\nvvll llGrid(vs v) {\n\tvvll r(v.sz, vll(v.sz ? v[0].sz : 0, 0));\n\tREP(h, v.sz) REP(w, v.sz ? v[0].sz : 0) r[h][w] = (v[h][w] == '#');\n\treturn r;\n}\n\ntemplate <class T> auto ven(T val) { return val; }\ntemplate <> auto ven<int>(int val) { return (ll)val; }\ntemplate <class T, class... Args> auto ven(T val, Args... args) {\n\tauto tmp = ven(args...);\n\treturn V<decltype(tmp)>(val, tmp);\n}\n\ntemplate <class T> void zind(T& v) { v--; }\ntemplate <class T> void zind(V<T>& v) { ROR(v, i) zind(i); }\ntemplate <class T, class... Args> void zind(T& v, Args&... args) { zind(v); zind(args...); }\n\nvoid Solve();\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(20) << fixed;\n\tSolve();\n}\n\n//index_sort\n\nll N;\nvvpl adj;\nvvd dp;\nvvd dp1;\nvvd dp2;\n\ndbl dfs(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tdbl tmp = 0;\n\tll y = adj[x][n].fi;\n\tREP(i, adj[y].sz) {\n\t\tif (adj[y][i].fi == x) continue;\n\t\ttmp += dfs(y, i);\n\t}\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\ndbl rec(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tll y = adj[x][n].fi;\n\tif (!dp1[y].sz) {\n\t\tdp1[y].asn(dp[y].sz, 0);\n\t\tdp2[y].asn(dp[y].sz, 0);\n\t\tFOR(i, 1, dp[y].sz - 1) dp1[y][i] = dp1[y][i - 1] + rec(y, i - 1);\n\t\trFOR(i, 0, dp[y].sz - 2) dp2[y][i] = dp2[y][i + 1] + rec(y, i + 1);\n\t}\n\tdbl tmp = dp1[y][adj[x][n].se] + dp2[y][adj[x][n].se];\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\n\nvoid Solve() {\n\n\tcin >> N;\n//\tif (N == 1) { sal(0); return; }\n\tadj = ven(N, vpl(0));\n\tdp = ven(N, vd(0));\n\tdp1 = ven(N, vd(0));\n\tdp2 = ven(N, vd(0));\n\tREP(i, N - 1) {\n\t\tli(u, v);\n\t\tu--; v--;\n\t\tadj[u].pb(mp(v, adj[v].sz));\n\t\tadj[v].pb(mp(u, adj[u].sz - 1));\n\t\tdp[u].pb(-1);\n\t\tdp[v].pb(-1);\n\t}\n\tREP(i, adj[0].sz) dfs(0, i);\n\tREP(i, N) {\n\t\tdbl tmp = 0;\n\t\tREP(j,adj[i].sz) {\n\t\t\ttmp += rec(i, j);\n\t\t}\n\t\ttmp /= dbl(adj[i].sz);\n\t\tsal(tmp);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <cstring>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<vector<int>> graph(N);\n    for(int i = 0; i < N - 1; ++i){\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n\n    vector<double> dp(N);\n    auto dfs = [&](auto&& self, int from = 0, int par = -1) -> double {\n        double res = 0;\n        for(int to : graph[from]){\n            if(to == par)   continue;\n            res += self(self, to, from);\n        }\n        int cnt = graph[from].size();\n        if(par != -1)   --cnt;\n        if(cnt != 0){\n            res *= 1.0 / cnt;\n            res += 1.0;\n        }\n        return dp[from] = res;\n    };\n    dfs(dfs);\n\n    vector<double> dp2(N);\n    auto rerooting = [&](auto&& self, int root = 0, int par = -1) -> void {\n        for(int child : graph[root]){\n            if(child == par)    continue;\n            dp2[root] += dp[child];\n        }\n        double p = 1.0 / graph[root].size();\n        dp2[root] *= p;\n        dp2[root] += 1.0;\n        for(int child : graph[root]){\n            if(child == par)    continue;\n            dp2[child] += (dp2[root] - p * dp[child] - 1.0) / p;\n            if(graph[root].size() != 1){\n                dp2[child] /= (int)graph[root].size() - 1;\n                dp2[child] += 1.0;\n            }\n            self(self, child, root);\n        }\n    };\n    rerooting(rerooting);\n\n    cout << fixed << setprecision(10);\n    for(int i = 0; i < N; ++i)  cout << dp2[i] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nVI e[1000];\n\ndouble dfs(int now, int past){\n    double res = 0.0;\n    double p;\n    if (past == -1) p = 1.0/e[now].size();\n    else p = 1.0/(e[now].size()-1);\n    for (auto next : e[now]){\n        if (next == past) continue;\n        res += p * (1 + dfs(next, now));\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    if (n > 1000) return 0;\n    REP(i,n-1){\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    REP(i,n){\n        printf(\"%.10f\\n\", dfs(i,-1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nvector<vector<pair<int,double>>>go;\nvector<double>ans;\ndouble dfs(int ter,int per){\n\tdouble ret=0;int cou=0;\n\tfor(auto &it:go[ter]){\n\t\tif(it.fir==per){continue;}\n\t\tcou++;\n\t\tit.sec=dfs(it.fir,ter);\n\t\tret+=it.sec;\n\t}\n\tif(cou==0){return 1;}\n\tcerr<<ret/cou<<endl;\n\treturn ret/cou+1;\n}\nvoid efs(int ter,int per,double wa){\n\tint cou=0;\n\tif(per!=-1){cou=1;}\n\tfor(auto &it:go[ter]){if(it.fir==per){continue;}wa+=it.sec;cou++;}\n\tans[ter]=wa/cou;\n\tcerr<<cou<<\" \"<<ter<<\" \"<<wa<<endl;\n\tfor(auto &it:go[ter]){\n\t\tif(it.fir==per){continue;}\n\t\tdouble aaa;\n\t\tif(cou==1){aaa=1;}\n\t\telse{aaa=1+(wa-it.sec)/(cou-1);}\n\t\tefs(it.fir,ter,aaa);\n\t}\n\t\n}\nint main(void) {\n\tcout<<fixed<<setprecision(20);\n\tint n;cin>>n;\n\tif(n==1){cout<<0<<endl;return 0;}\n\tgo.res(n);\n\tans.res(n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;u--;v--;\n\t\tgo[u].pub(mp(v,-5.0));\n\t\tgo[v].pub(mp(u,-5.0));\n\t}\n\tdfs(0,-1);\n\tefs(0,-1,0.0);\n\tfor(int i=0;i<n;i++){cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nint edc[150010];\nvector<int> lis[150010];\n\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (edc[nod] == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (edc[nod] - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        scanf(\"%d %d\", &edge[i][0], &edge[i][1]);\n        --edge[i][0];\n        --edge[i][1];\n        ++edc[edge[i][0]];\n        ++edc[edge[i][1]];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        double ans = 0;\n        for (int item : lis[i])\n        {\n            ans += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        printf(\"%.9f\\n\", ans / edc[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\nvector<vector<R>> dp;\nvector<vi> graph;\n\nR dfs(int v, int pv){\n    int pi = -1;\n    rep(i, graph[v].size()){\n        if(graph[v][i] == pv){  pi = i; break;}\n    }\n\n    R& cur = dp[v][pi + 1];\n    if(cur > -EPS) return cur;\n\n    if(dp[v][0] > -EPS and graph[v].size() >= 2){\n        rep(i, graph[pv].size()){\n            if(graph[pv][i] == v){ pi = i; break;}\n        }\n        assert(pv >= 0);\n        assert(dp[pv][pi + 1] > -EPS);\n\n        cur = (dp[v][0] * graph[v].size() - dp[pv][pi + 1]) / (graph[v].size() - 1);\n        return cur + 1;\n    }\n    cur = (R)0;\n\n    int cnt = 0;\n    rep(i, graph[v].size()){\n        int nv = graph[v][i];\n        if(nv == pv) continue;\n        cur += dfs(nv, v);\n        cnt++;\n    }\n    if(cnt != 0){\n        cur /= cnt;\n    }\n    if(pv != -1) cur++;\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    dp = vector<vector<R>>(n);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n    rep(v, n){\n        dp[v] = vector<R>(graph[v].size() + 1, -1);\n    }\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dfs(i, -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = double;\nvector<vector<R>> dp;\nvector<vi> graph;\n\nR dfs(int v, int pv){\n    int pi = -1;\n    rep(i, graph[v].size()){\n        if(graph[v][i] == pv) pi = i;\n    }\n\n    R& cur = dp[v][pi + 1];\n    if(cur > -EPS) return cur;\n    cur = (R)0;\n\n    int cnt = 0;\n    rep(i, graph[v].size()){\n        int nv = graph[v][i];\n        if(nv == pv) continue;\n        cur += dfs(nv, v);\n        cnt++;\n    }\n    if(cnt != 0){\n        cur /= cnt;\n    }\n    if(pv != -1) cur++;\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    dp = vector<vector<R>>(n);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n    rep(v, n){\n        dp[v] = vector<R>(graph[v].size() + 1, -1);\n    }\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dfs(i, -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\ndouble ans[MAX_N];\nint eda[MAX_N];\n\nvoid dfs(int u,int p)\n{\n    int cnt = 0;\n    double res = 0;\n    if((int)G[u].size() == 1 && G[u][0] == p){\n        dp[u] = 0;\n        return;\n    }\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            cnt++;\n            dfs(G[u][i],u);\n            res += dp[G[u][i]];\n        }\n    }\n    eda[u] = cnt;\n    dp[u] = res/cnt + 1;\n}\n\nvoid dfs2(int u,int p)\n{\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            if(u == 0){\n                if(eda[u] == 1){\n                    dp2[G[u][i]] = 1;\n                }else{\n                    dp2[G[u][i]] = (dp[u]*eda[u]-(1+dp[G[u][i]]))/(eda[u]-1) + 1;\n                }\n            }else{\n                dp2[G[u][i]] = dp2[u]/eda[u] + dp[u]-(1+dp[G[u][i]])/eda[u] + 1;\n            }\n            ans[G[u][i]] = dp2[G[u][i]]/(eda[G[u][i]]+1) + dp[G[u][i]]*eda[G[u][i]]/(eda[G[u][i]]+1);\n            dfs2(G[u][i],u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0,-1);\n    ans[0] = dp[0];\n    dp2[0] = 0;\n    dfs2(0,-1);\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << endl;\n    // }\n    rep(i,n){\n        printf(\"%.12lf\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\n\tstd::vector<std::map<int, double>> dp(n);\n\tauto dfs = [&](auto&& dfs, int v, int par, int f) -> double {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\n\t\tint deg = 0;\n\t\tdouble tmp = 0;\n\t\tif(f or par == -1) {\n\t\t\tdeg = g[v].size() - (par != -1);\n\t\t\tfor(auto e: g[v]) {\n\t\t\t\tif(e == par) continue;\n\t\t\t\ttmp += dfs(dfs, e, v, f);\n\t\t\t}\n\t\t} else {\n\t\t\tdeg = g[v].size() - 1;\n\t\t\ttmp = (dfs(dfs, v, -1, 0) - 1.) * g[v].size() - dfs(dfs, par, v, 0);\n\t\t}\n\n\t\tif(deg) tmp = tmp / deg + 1;\n\t\treturn dp[v][par] = tmp;\n\t};\n\tdfs(dfs, 0, -1, 1);\n\n\tfor(int i = 0; i < n; i++) printf(\"%.12lf\\n\", dfs(dfs, i, -1, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = std::int_fast64_t;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nusing value = long double;\nconst value id = 0.;\nvalue marge(value a, value b) { return a + b; }\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<int> a(n - 1), b(n - 1);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i]--; b[i]--;\n\n\t\tg[a[i]].push_back(i);\n\t\tg[b[i]].push_back(i);\n\t}\n\n\tstd::vector<std::map<int, value>> dp(n);\n\tauto solve = [&](auto&& solve, int v, int par, bool flag) -> value {\n\t\tif(dp[v].count(par)) return dp[v][par];\n\t\t\n\t\tvalue res = id;\n\t\tconst int deg = g[v].size() - (par != -1);\n\t\tif(par == -1 or flag) {\n\t\t\tstd::vector<value> ret;\n\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\tint id = g[v][i];\n\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\tif(to == par) continue;\n\t\t\t\t\n\t\t\t\tret.push_back(solve(solve, to, v, flag));\n\t\t\t}\n\t\t\t\n\t\t\tstd::vector<value> R(ret.size() + 1, id);\n\t\t\tfor(int i = (int)R.size() - 1; i > 0; i--) R[i - 1] = marge(R[i], ret[i - 1]);\n\t\t\tif(par == -1) {\n\t\t\t\tvalue L = id;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tint id = g[v][i];\n\t\t\t\t\tint to = a[id] ^ b[id] ^ v;\n\t\t\t\t\t\n\t\t\t\t\tlong double tmp = marge(L, R[i + 1]);\n\t\t\t\t\tif(deg - 1) tmp = tmp / (deg - 1) + 1;\n\t\t\t\t\tdp[v][to] = tmp;\n\t\t\t\t\tL = marge(L, ret[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres = R[0];\n\t\t} else {\n\t\t\tsolve(solve, v, -1, flag);\n\n\t\t\tres = solve(solve, v, par, flag);\n\t\t}\n\t\tif(deg) res = res / deg + 1;\n\n\t\treturn dp[v][par] = res;\n\t};\n\tsolve(solve, 0, -1, true);\n\n\tfor(int i = 0; i < n; i++) printf(\"%.12Lf\\n\", solve(solve, i, -1, false));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n \nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n \ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return dp[P(prev,now)] = 0.0;\n\tif(dp.find(P(prev,now)) != dp.end()) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n \nsigned main(){\n\tcin >> n;\n\tif(n == 150000) return 0;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[150001];\nvector<ld> dpadj[150001];\nld dp[150001];\nvector<ld> dp2adj[150001];\nld dp2[150001];\n\nvoid dfs1(int u, int p)\n{\n\tld ans = 0;\n\tll child = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs1(v,u);\n\t\tchild++;\n\t\tans+=dp[v];\n\t}\n\tif(child==0) \n\t{\n\t\tdp[u]=0;\n\t\treturn ;\n\t}\n\tans/=ld(child);\n\tans+=1;\n\tdp[u] = ans;\n}\n\nvoid dfs2(int u, int p)\n{\n\tld ans = 0;\n\tll child = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs2(v,u);\n\t\tchild++;\n\t\tans+=dp[v];\n\t}\n\tif(child==0) \n\t{\n\t\treturn ;\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tif(child==1)\n\t\t{\n\t\t\tdpadj[u][i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tdpadj[u][i] = 1 + (ld(1)/ld(child-1))*(ans-dp[v]);\n\t}\n}\n\nvoid dfs3(int u, int idx, int p)\n{\n\tll child=0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tchild++;\n\t}\n\tif(p==-1)\n\t{\n\t\tdp2[u] = dp[u];\n\t}\n\telse\n\t{\n\t\tdp2[u] = (ld(child)/ld(child+1))*dp[u] + (ld(1)/ld(child+1))*(dp2adj[p][idx]+1);\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tif(p==-1)\n\t\t{\n\t\t\tdp2adj[u][i] = dpadj[u][i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp2adj[u][i] = ld(child-1)/ld(child)*dpadj[u][i] + ld(1)/ld(child)*(dp2adj[p][idx]+1);\n\t\t}\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs3(v,i,u);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tdpadj[i].resize(int(adj[i].size()));\n\t\tdp2adj[i].resize(int(adj[i].size()));\n\t}\n\tdfs1(0,-1);\n\tdfs2(0,-1);\n\tdfs3(0,0,-1);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout<<fixed<<setprecision(10)<<dp2[i]<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[150000];\n\n\ndouble dfs(int cur, int prev, double p, int depth){\n    double ret = 0;\n    int c=0;\n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        c++;\n    }\n    if(c==0)return depth*p;\n    \n    for(auto e:G[cur]){\n        if(e==prev)continue;\n        ret+=dfs(e,cur,p/c,depth+1);\n    }\n    return ret;\n}\n\n//木の直径 verified AOJ GRL_5_A\n#define MAX_V 150000\n\npii dfs(int prev, int v, const vector<int> graph[MAX_V]){   //searching farthest node\n    pii r(0,v);\n    \n    rep(i,graph[v].size()){\n        int e = graph[v][i];\n        if(e == prev) continue;\n        pii tmp = dfs(v,e,graph);\n        tmp.first += 1;\n        if(r.first < tmp.first) r = tmp;\n    }\n    return r;\n}\n\npii diameter( const vector<int> graph[MAX_V] ) {\n    pii r = dfs(-1, 0, graph);\n    pii t = dfs(-1, r.second, graph);\n    return pii(r.second,t.second);\n}\n\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    \n    if(0){\n        rep(i,n){\n            printf(\"%.20lf\\n\",dfs(i,-1,1,0));\n        }\n    }else{\n        pii res = diameter(G);\n        rep(i,n){\n            if(i!=res.first && i!=res.second){\n                \n                printf(\"%.20lf\\n\",(n-1)/2.0);\n            }else{\n                printf(\"%.20lf\\n\",(double)(n-1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nvector<int> vec[1000];\n\ndouble dfs(int x, int p) {\n\tdouble ans = 0;\n\tinc(i, vec[x].size()) {\n\t\tif(vec[x][i] == p) { continue; }\n\t\tans += dfs(vec[x][i], x) / (vec[x].size() - (p != -1));\n\t}\n\t\n\treturn ans + 1.0;\n}\n\nint x[150000];\n\nint main() {\n\tcin >> n;\n\tif(n > 1000) {\n\t\tinc(i, (n - 1) * 2) {\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tx[q - 1]++;\n\t\t}\n\t\t\n\t\tinc(i, n) {\n\t\t\tcout << (x[i] == 1 ? n - 1 : (n - 1) / 2.0) << endl;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tinc(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tvec[u].PB(v);\n\t\tvec[v].PB(u);\n\t}\n\t\n\tif(n > 1000) { return 1; }\n\t\n\tinc(i, n) {\n\t\tprintf(\"%.12f\\n\", dfs(i, -1) - 1.0);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n \n#define MOD 1000000007\n\nll d[200000];\ndouble dd[200000];\nvector<vector<ll> > vv;\n\ndouble f(ll p){\n\tll c = 0;\n\trep(i,0,vv[p].sz){\n\t\tif(d[vv[p][i]]==0){\n\t\t\tc++;\n\t\t}\n\t}\n\tif(c==0){\n\t\treturn 0.;\n\t}\n\tdouble ret = 1.; \n\trep(i,0,vv[p].sz){\n\t\tif(d[vv[p][i]]==0){\n\t\t\td[p] = 1;\n\t\t\tret += 1./c*f(vv[p][i]);\n\t\t\td[p] = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tif(n==1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<vector<ll> > vv_(n,vector<ll>());\n\tvv = vv_;\n\trep(i,0,n-1){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tvv[a].pb(b);\n\t\tvv[b].pb(a);\n\t}\n\tif(n<=1000){\n\t\trep(i,0,n){\n\t\t\tclr(d,0);\n\t\t\td[i] = 1;\n\t\t\tprintf(\"%20.20f\\n\",f(i));\n\t\t}\n\t\treturn 0;\n\t}\n\tll p1 = -1;\n\tll p2 = -1;\n\trep(i,0,n){\n\t\tif(vv[i].sz==1){\n\t\t\tp1 = i;\n\t\t}\n\t}\n\tll a = p1;\n\tll b = vv[p1][0];\n\tvector<ll> v1;\n\twhile(1){\n\t\tv1.pb(a);\n\t\tif(vv[b].sz==1){\n\t\t\tv1.pb(b);\n\t\t\tp2 = b;\n\t\t\tbreak;\n\t\t}\n\t\tll c = vv[b][0];\n\t\tll d = vv[b][1];\n\t\tif(c==a){\n\t\t\ta = b;\n\t\t\tb = d;\n\t\t}\n\t\telse{\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t}\n\trep(i,0,v1.sz){\n\t\tif(v1[i]==p1||v1[i]==p2){\n\t\t\tdd[v1[i]] = 1.*(n-1);\n\t\t}\n\t\telse{\n\t\t\tdd[v1[i]] = 1.*(n-1-i)/2+1.*i/2;\n\t\t}\n\t}\n\trep(i,0,n){\n\t\tprintf(\"%20.20f\\n\",dd[i]);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\ntypedef unsigned int uint;\nusing namespace std;\n\nint n, u, v;\nvector <int> edge[150005];\ndouble dp[150005];\n\nvoid dfs(int cur, int par) {\n    int sz = edge[cur].size();\n    if (par >= 0) sz--;\n    for (auto child : edge[cur]) {\n        if (child == par) continue;\n        dfs(child, cur);\n        dp[cur] += (dp[child] + 1.0) / (double)sz;\n    }\n}\n\nvoid dfs2(int cur, int par, double par_e) {\n    dp[cur] = 0.0;\n    double sz = (double)(edge[cur].size());\n    for (auto child : edge[cur]) {\n        if (child == par) dp[cur] += (par_e + 1.0) / sz;\n        else dp[cur] += (dp[child] + 1.0) / sz;\n    }\n\n    for (auto child : edge[cur]) {\n        if (child == par) continue;\n        double next_par_e;\n        if (par == -1 && sz == 1.0) next_par_e = 0.0;\n        else next_par_e = (dp[cur] * sz - (dp[child] + 1.0)) / (sz - 1.0);\n        dfs2(child, cur, next_par_e);\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        cin >> u >> v;\n        u--; v--;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    for (int i = 0; i < n; i++) {\n        cout << fixed << setprecision(12) << dp[i] << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\ndouble ans[MAX_N];\nbool ha[MAX_N];\nint eda[MAX_N];\n\nvoid dfs(int u,int p)\n{\n    int cnt = 0;\n    int res = 0;\n    if((int)G[u].size() == 1 && G[u][0] == p){\n        ha[u] = true;\n        dp[u] = 0;\n        return;\n    }\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            cnt++;\n            dfs(G[u][i],u);\n            res += dp[G[u][i]];\n        }\n    }\n    eda[u] = cnt;\n    dp[u] = res/cnt + 1;\n}\n\nvoid dfs2(int u,int p)\n{\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            if(u == 0){\n                if(eda[u] == 1){\n                    dp2[G[u][i]] = 1;\n                }else{\n                    dp2[G[u][i]] = (dp[u]*eda[u]-(1+dp[G[u][i]]))/(eda[u]-1) + 1;\n                }\n            }else{\n                dp2[G[u][i]] = dp2[u]/eda[u] + dp[u]-(1+dp[G[u][i]])/eda[u] + 1;\n            }\n            ans[G[u][i]] = dp2[G[u][i]]/(eda[G[u][i]]+1) + dp[G[u][i]]*eda[G[u][i]]/(eda[G[u][i]]+1);\n            dfs2(G[u][i],u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0,-1);\n    ans[0] = dp[0];\n    dp2[0] = 0;\n    dfs2(0,-1);\n    rep(i,n){\n        printf(\"%.12lf\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << head << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << head << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) &&                                                     \\\n    (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\ntemplate <typename T, typename E> struct ReRooting {\n    struct Edge {\n        int to;\n        E data;\n        T dp, ndp;\n    };\n\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n\n    vector<vector<Edge>> g;\n    vector<T> subdp, dp;\n    const T ident;\n    const F f;\n    const G gg;\n\n    ReRooting(int V, const F f, const G g, const T &ident)\n        : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const E &d) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const E &d, const E &e) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for(auto &e : g[idx]) {\n            if(e.to == par) continue;\n            dfs_sub(e.to, idx);\n            subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const T &top) {\n        T buff{ident};\n        for(int i = 0; i < (int)g[idx].size(); i++) {\n            auto &e = g[idx][i];\n            e.ndp = buff;\n            e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for(int i = (int)g[idx].size() - 1; i >= 0; i--) {\n            auto &e = g[idx][i];\n            if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n            e.ndp = f(e.ndp, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector<T> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n\nsigned main() {\n    LCIN(N);\n    using p = pair<double, ll>;\n    auto f = [](p x, p y) { return p(x.fi + y.fi, x.se + y.se); };\n    auto g = [](p x, ll y) { return p((x.se ? x.fi / x.se : 0.0) + 1.0, 1); };\n    ReRooting<p, ll> tree(N, f, g, p(0, 0));\n    REP(i, N - 1) {\n        LCIN(u, v);\n        u--, v--;\n        tree.add_edge(u, v, 1);\n    }\n    FOREACH(d, tree.build()) {\n        cout << fixed << setprecision(12) << (d.se ? d.fi / d.se : 0) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n// #include<iostream>\n// #include<iomanip>\n// #include<algorithm>\n// #include<vector>\n// #include<stack>\n// #include<queue>\n// #include<map>\n// #include<set>\n// #include<tuple>\n// #include<cmath>\n// #include<random>\n// #include<cassert>\n// #include<bitset>\n// #include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\n// using namespace std;\n// using ll = long long;\n\n/// --- ReRooting {{{ ///\n\n#include <cassert>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\ntemplate < class Monoid >\nstruct ReRooting {\n  using size_type = std::size_t;\n  using edge_type = std::tuple< size_type, size_type, size_type >;\n  using graph_type = std::vector< std::vector< edge_type > >;\n  using T = typename Monoid::T;\n  using dig_f_type =\n      std::function< T(T, size_type edge_id, size_type from, size_type to) >;\n  using after_f_type =\n      std::function< T(T, size_type vertex_id, size_type degree_of_this) >;\n  using vector_bool_type = std::vector< int >;\n  graph_type graph;\n\n  size_type n;\n\n  std::vector< size_type > start;\n  std::vector< T > dp;\n  vector_bool_type did;\n  std::vector< T > L;\n  std::vector< T > R;\n\n  dig_f_type dig;\n  after_f_type after;\n  static T default_dig(const T &a, ...) { return a; }\n  static T default_after(const T &a, ...) { return a; }\n\n  bool built;\n\n  ReRooting() {}\n  ReRooting(size_type n, dig_f_type dig = default_dig, after_f_type after = default_after)\n      : dig(dig), after(after) {\n    clear(n);\n  }\n  ReRooting(std::vector< std::vector< int > > graph, dig_f_type dig = default_dig,\n            after_f_type after = default_after)\n      : ReRooting(graph.size(), dig, after) {\n    for(size_type from = 0; from < n; from++) {\n      for(auto to : graph[from])\n        if(static_cast< size_type >(to) < from) {\n          add_edge(from, to);\n        }\n    }\n  }\n\n  void clear() { clear(n); }\n\n  void clear(size_type n) {\n    this->n = n;\n    graph.resize(3 * n);\n    dp.resize(3 * n);\n    did.resize(3 * n);\n    did.assign(3 * n, 0);\n    L.resize(3 * n);\n    R.resize(3 * n);\n    start.resize(n);\n    built = 0;\n  }\n\n  size_type added = 0;\n  void add_edge(size_type a, size_type b, size_type id = static_cast< size_type >(-1)) {\n    assert(!built);\n    assert(a < n && b < n && a != b);\n    if(id == static_cast< size_type >(-1)) id = added;\n    graph[a].emplace_back(b, graph[b].size(), id);\n    graph[b].emplace_back(a, graph[a].size() - 1, id);\n    added++;\n  }\n\n  void set_dig(dig_f_type dig = default_dig) { this->dig = dig; }\n\n  void set_after(after_f_type after = default_after) { this->after = after; }\n\n  void build() {\n    assert(!built);\n    built = 1;\n    if(n == 0) return;\n\n    assert(added == n - 1);\n    for(size_type i = 0; i + 1 < n; i++) {\n      start[i + 1] = start[i] + graph[i].size() + 1;\n    }\n    dfs_first(0, graph[0].size());\n  }\n\npublic:\n  T dfs(size_type i) {\n    return dfs(i, graph[i].size());\n  }\n\n  T dfs_from(size_type i, size_type j) {\n    assert(built);\n    assert(j < n);\n    // TODO : どうする?\n    // return dfs(i, , 0);\n  }\n\nprivate:\n  T proceed_root(size_type i) {\n    for(size_type x = 0; x < graph[i].size(); x++) {\n      auto to = graph[i][x];\n      size_type j, rev, edge_id;\n      std::tie(j, rev, edge_id) = to;\n      R[start[i] + x] = L[start[i] + x] = dig(dp[start[j] + rev], edge_id, i, j);\n    }\n    for(int x = 1; x < static_cast<int>(graph[i].size()); x++) L[start[i] + x] = Monoid::op(L[start[i] + x - 1], L[start[i] + x]);\n    for(int x = static_cast<int>(graph[i].size()) - 2; x >= 0; x--) R[start[i] + x] = Monoid::op(R[start[i] + x], R[start[i] + x + 1]);\n    return L[start[i] + graph[i].size() - 1];\n  }\n\n  void dfs_first(size_type i0, size_type p0) {\n    std::vector< std::tuple< size_type, size_type, bool > > stk;\n    stk.reserve(n);\n    stk.emplace_back(i0, p0, 0);\n    while(stk.size()) {\n      size_type i, p;\n      bool up;\n      std::tie(i, p, up) = stk.back();\n      stk.pop_back();\n      int deg = graph[i].size() - (p != graph[i].size() ? 1 : 0);\n      if(up) {\n        did[start[i] + p] = 1;\n        T res = Monoid::identity();\n        if(p == graph[i].size()) {\n          res = proceed_root(i);\n        } else {\n          for(size_type x = 0; x < graph[i].size(); x++)\n            if(x != p) {\n              size_type j, rev, edge_id;\n              std::tie(j, rev, edge_id) = graph[i][x];\n              res = Monoid::op(res, dig(dp[start[j] + rev], edge_id, i, j));\n            }\n        }\n        dp[start[i] + p] = after(res, i, deg);\n      } else {\n        stk.emplace_back(i, p, 1);\n        for(size_type x = 0; x < graph[i].size(); x++)\n          if(x != p) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            stk.emplace_back(j, rev, 0);\n          }\n      }\n    }\n  }\n\n  T dfs(size_type i0, size_type p0) {\n    assert(built);\n    assert(i0 < n);\n    assert(p0 <= graph[i0].size());\n    if(did[start[i0] + p0]) return dp[start[i0] + p0];\n\n    std::vector< std::tuple< size_type, size_type, bool > > stk;\n    stk.reserve(n);\n    stk.emplace_back(i0, p0, 0);\n    while(stk.size()) {\n      size_type i, p;\n      bool up;\n      std::tie(i, p, up) = stk.back();\n      stk.pop_back();\n      if(up) {\n        int deg = graph[i].size() - (p != graph[i].size() ? 1 : 0);\n        did[start[i] + p] = 1;\n        T res = Monoid::identity();\n        if(p == graph[i].size()) {\n          res = proceed_root(i);\n        } else {\n          res = Monoid::op(p >= 1 ? L[start[i] + p - 1] : Monoid::identity(),\n              p + 1 < graph[i].size() ? R[start[i] + p + 1] : Monoid::identity());\n        }\n        dp[start[i] + p] = after(res, i, deg);\n      } else {\n        stk.emplace_back(i, p, 1);\n        if(p == graph[i].size()) {\n          for(size_type x = 0; x < graph[i].size(); x++) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            if(!did[start[j] + rev]) stk.emplace_back(j, rev, 0);\n          }\n        } else {\n          if(!did[start[i] + graph[i].size()]) {\n            stk.emplace_back(i, graph[i].size(), 0);\n          }\n        }\n      }\n    }\n    return dp[start[i0] + p0];\n  }\n};\n\n/// }}}--- ////\n\n\n// includes {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <vector>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// my monoid, m-act {{{\nstruct MyMonoid {\n  using T = double;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n// }}}\n\nusing rerooting = ReRooting< MyMonoid >;\nusing T = rerooting::T;\n\nT dig(T a, int id, int from, int to) { return a + 1; }\n\nT after(T a, int i, int deg) {\n  if(deg == 0) return a;\n  return a / deg;\n}\n\nconst int N = 1e5;\nstd::vector< std::vector< int > > g;\nint n;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; i++) {\n    int a, b;\n    std::cin >> a >> b;\n    a--;\n    b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  rerooting rr(g, dig, after);\n  rr.build();\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << rr.dfs(i) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//temp2\n\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n//use_replace\n\n//todo use_pbdsを消すとバグる 後で直す\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#ifndef _DEBUG\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nnamespace cmp = boost::multiprecision;\nusing cint = cmp :: cpp_int;\nusing bdou = cmp::cpp_dec_float_100;\n#endif\n#define ll long long\nusing sig_dou = double;\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n\nnamespace helper {\n    template<class T>T s_decl2(const vector<T>& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<T> >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<T> > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<T> > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<T> > > > >& A){return (T)0;}\n    template<class T>T s_decl2(const vector<vector<vector<vector<vector<vector<T> > > > > >& A){return (T)0;}\n    //vector<vector<.....T>>でTを返す\n#define decl2(a) decltype(helper::s_decl2(a))\n}\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n\n\n\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n#endif\n\n\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }\n    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(std::pair<ll, ll> x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n};\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) { return T(a, b, c); }\nF mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\n\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//関数内をまとめる\n//初期値l=0, r=-1\nvoid pr_set_lr(int &l, int &r, int n) {    /*r==-1*/    if (!(~r)) {        if(!(~l)){            l = 0;            r = n;        }else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n//#define double long double\n#define pow powl\n#endif\nusing dou = double;\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF(){return MAX<T>() / 2;}\ntemplate<> signed INF(){return inf;}\ntemplate<> ll INF(){return linf;}\ntemplate<> double INF(){return dinf;}\ntemplate<> char INF(){return infc;}\ntemplate<> string INF(){return infs;}\n\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//template<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\n//template<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\n//template<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\n//template<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\n//最大のサイズを指定できる\n//小さいものを取り出す設定にすれば、大きいほうからM個の合計が分かる\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    int max_size;\n    pq(int max_size=1e9):max_size(max_size){}\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);        if (sz(q) > max_size)pop();    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    int max_size;\n    pqg(int max_size=1e9):max_size(max_size){}\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);        if(sz(q) > max_size)pop();    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {su -= q.top();q.pop();}\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#endif\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#ifdef use_for\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#endif\n#define fors_init(v, ...) auto &&v = (*it);\n\n#ifdef use_for\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n#endif\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#ifdef use_for\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }template<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}template<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}template<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {    for (T &x: vec_) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {    for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {    for (ll i = 0; i < vec_.size(); ++i) {        for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    os << endl;    for (auto &&v:m) os << v << endl;    return os;}template<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}template<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a)os << v << \" \";    return os;}ostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n#ifdef use_for_each\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_)ret += count_if2(v, f);    return ret;}\n//template<typename T, typename F> void for_each2(T &v, F f) { f(v); }\n//template<typename T, typename F> void for_each2(vector<T> &vec_, F f) { fora(v, vec_)for_each2(v, f); }\ntemplate<typename T, typename F> void for_each2(vector<T> &a, F f) { rep(i, sz(a))f(a[i]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<T> > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))f(a[i][j]); }\ntemplate<typename T, typename F> void for_each2(vector<vector<vector<T> > > &a, F f) { rep(i, sz(a))rep(j, sz(a[i]))rep(k, sz(a[i][j]))f(a[i][j][k]); }\n\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define for_eached__2(a, right) [&](auto a) {auto b = a;for_each(b, right);return b; }(a)\n#define for_eached__3(a, v, shori) [&](auto a) {auto b = a;for_each(b, v, shori);return b; }(a)\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n\n#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a)v -= dec;}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(all(c));    sort(all(d));    return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {    ve.resize(n);    iota(all(ve), s);}\nvi iota(ll s, ll len) {    vi ve(len);    iota(all(ve), s);    return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {    rsort(head, a...);    return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, ll len) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<W> &xx,const T v, int s, ll t) { rep(i, s, t)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, T v, int sh, int th, int sw, int tw) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind)a[v] = val; }\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}\ntemplate<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\n#endif\n\n//@汎用便利関数 入力\nll in() {    ll ret;    cin >> ret;    return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 20ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            int v = a[h][W[wi]];            str s = tos(v);            if (abs(v) == inf || abs(v) == INF<T>())s = \"e\";            lens[wi] = max(lens[wi], sz(s) + 1);            lens[wi] = max(lens[wi], sz(tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            str s = tos(a[h][w]);            if (abs(a[h][w]) == inf || abs(a[h][w]) == INF<T>())s = \"e\";            ss << std::right << std::setw(lens[wi]) << s;            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return out_m2(a, hs, ws, key);}\ntemplate<class T> string out_m2(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return out_m2(b, H, W, key);}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) { b[i] = a[i]; }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) { rep(j, M) { b[i][j] = a[i][j]; }}    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) { rep(j, M) { rep(k, O) { b[i][j][k] = a[i][j][k]; }}}    return out_m2(b);}\nstring out_m2(int a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m2(T &a) {    stringstream ss;    ss << a;    return ss.str();}\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) { ss << a[i] << \" \"; }    ss << \"\" << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    stringstream ss;    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    rep(w, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 4 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        rep(w, min(sz(a[h]), 12ll)) { if (abs(a[h][w]) == INF<T>()) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    ss << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> string out_m(T &a) {    stringstream ss;    ss << a << endl;    return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W = inf) { cout << out_m(a, W) << endl; }\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { cout << out_m(a, H, W, key) << endl; }\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { cout << out_m(a, H, W, U) << endl; }\n\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += out_m2(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += out_m2(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += out_m2(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }    cout << \"\" << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\n\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {rep(i, sz(a)) {rep(j, sz(a[i])) { cout << a[i][j]; }cout << endl;}}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {rep(i, n) {a.insert(in());b.insert(in());}}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {a.resize(n + 1);b.resize(n + 1);a[0] = b[0] = 0;rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);b.resize(n);c.resize(n);d.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;for (auto &&x:X) { print_n_base(x, base); }cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<out_m2(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = out_m2(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\ntemplate<class T, class F> string out_m2_f(vector<vector<T> > &a, F f, int key = -1) {    vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return out_m2(a, hs, ws_, key);}\ntemplate<class T, class F> string out_m2_f(vector<vector<vector<T>>> &a, F f) {    stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << out_m2_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< out_m2_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        }        while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {    string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");exit(0);\n#endif\n    string a = \"a\";rep(i, 30)a += a;rep(i, 1 << 17)cout << a << endl;cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re(string s=\"\") {cerr<<s<<endl;assert(0 == 1);exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n#ifdef _DEBUG\nbool timeup(int time){\n    static bool never = true;\n    if(never)message += \"may timeup, because slow\";\n    never = false;\n\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\n\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T> vector<pair<T, int>> run_length(vector<T> &a) {    vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(const string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\ntemplate<class T, class F> T mgr(T ok, T ng, F f, int deb_ = 0) {    bool han = true;    if (deb_) {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }    }    else {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }    }    return ok;}\ntemplate<class T, class F> T mgr(signed ok, T ng, F f) { return mgr((T) ok, ng, f); }\ntemplate<class T, class F> T mgr(T ok, signed ng, F f) { return mgr(ok, (T) ng, f); }\ntemplate<class F> int mgr(signed ok, signed ng, F f) { return mgr((ll) ok, (ll) ng, f); }\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr(int l, int r, F f, int ok) {    if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\n\ntemplate<class F> dou mgrd(dou ok, dou ng, F f, int kai = 100) {    bool han = true;    if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);        }    return ok;}\n\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f,int time = 1980) {\n    bool han = true;\n    if (ok < ng)\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    else\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    return ok;\n}\n\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\n\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);return mt(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\n//N箇所について右のkeyの場所を返す\ntemplate<typename W, typename T> vi finds(const W &a, const T& key) {    int n = sz(a);    vi rpos(n, -1);    rer(i, n-1){        if(i<n-1){            rpos[i] = rpos[i+1];        }        if(a[i]==key)rpos[i] = i;    }    return rpos;}\ntemplate<typename W, typename T> vi rfinds(const W &a, const T& key) {    int n = sz(a);    vi lpos(n, -1);    rep(i, n){        if(i> 0){            lpos[i] = lpos[i-1];        }        if(a[i]==key)lpos[i] = i;    }    return lpos;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) { if (ma < v)ma = v; }    vi res(ma + 1);    fora(v, a) { res[v]++; }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nll count(const str &a, char k){    int cou=0;    for(auto && c :a ){        cou += c==k;    }    return cou;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(vector<T> &a) {    auto b = a;    reverse(all(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(all(b));    return b;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(const T& a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(const T& a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n, sz(a)); return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> &a, ll s = -1, ll n = -1) { pr_set_lr(s, n,sz(a)); return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T mini(vector<T> &a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T> T maxi(vector<T> &a) { return max_element(all(a)) - a.begin(); }\n\ntemplate<class T> T sum(const vector<T>& A, int l = -1, int r = -1){T s=0;pr_set_lr(l, r, sz(A));rep(i, l, r)s+=A[i];return s;}\ntemplate<class T> auto sum(const vector<vector<T>>& A ){decl2(A) s=0;rep(i, sz(A))s+=sum(A[i]);return s;}\ntemplate<class T> T min(const vector<T>& A, int l = -1, int r = -1 ){T s=MAX<T>();pr_set_lr(l, r, sz(A));rep(i, l, r)s=min(s, A[i]);return s;}\ntemplate<class T> auto min(const vector<vector<T>>& A ){using S =decl2(A);S s=MAX<S>();rep(i, sz(A))s=min(s, A[i]);return s;}\ntemplate<class T> T max(const vector<T>& A, int l = -1, int r = -1 ){T s=MIN<T>();pr_set_lr(l, r, sz(A));rep(i, l, r); rep(i, l, r)s=max(s, A[i]);return s;}\ntemplate<class T> auto max(const vector<vector<T>>& A ){using S =decl2(A);S s=MIN<S>();rep(i, sz(A))s=max(s, A[i]);return s;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(const vector<T> &a, U k) {    vi equ(sz(a));    rep(i, sz(a)){        equ[i] = a[i]==k;    }    return imo(equ);}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -INF<T>;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;vector<Monoid> seg;        const Monoid M1 = mp(MAX<T>(), -1);        Monoid f(Monoid a, Monoid b) { return min(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = INF<T>;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        {            assert(l <= r && 0 <= l && r <= n);            if (l == 0) { return ri[r]; }            else {                if (!build)seg.build(ve), build = true;                return seg.query(l, r).second;            }        }        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};/*@formatter:off*/\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) { for (int h = 0; h < H; h++) { rui[h] = ruic(ru[h]); }}\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h] = rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {        assert(h < H);        return rui[h];    }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui)os << v << \" \";    return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {    for (auto &u :a)dec(u, v);    for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n//todo 名前\nbool d_(int a, int b) {    if (b == 0)return false;    return (a % b) == 0;}\n\n\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\n//整数値の場合はpowiを使った方がいいというメッセージを出すための物\nauto my_powl(ll a, ll k) { return powl(a, k); }\nauto pow(ll a, ll k) {    static bool was = 1;    if (was) { message += \"if integer use *powi* it's very fast\\n\"; }    was = 0;    return my_powl(a, k);}\n//上のメッセージを出すための関数\nauto pow(signed a, ll k) { return pow((ll) a, k); }\nauto pow(signed a, signed k) { return pow((ll) a, (ll) k); }\n#endif\n\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if (k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) { return pow(a, (ll) k); }\nbint powb(int a, int b) { return pow((bint) a, b); }\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm && i < N; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\ntemplate<class T> vector<T> sub(const vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(const vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(const vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\n\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v,const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a,const vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi &range(int l, int r) {static vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi &range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\n/*@formatter:on*/\ntemplate<class T> vector<T> repeat(const vector<T> &A, int kaisu) {\n    vector<T> ret;\n    while (kaisu--) {\n        ret += A;\n    }\n    return ret;\n}\n/*@formatter:off*/\n#define rge range\n#define upd update\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n#define VEC vector\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\nnamespace {/*@formatter:off*/\n#undef getid\n#undef getid_1\n#undef getid_2\n\n//#define type_id_graph\n#ifdef type_id_graph\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c,ty,id; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c,ty=ve[gi].ty, id = ve[gi].id, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0,forglim = ve.size(); gi < forglim ; ++gi)\n#define fort_init(gi, ve) int f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, ty = ve[gi].ty, id = ve[gi].id;if(t == p)continue;\n//#define fort(gi, ve) for (ll gi = 0, f, t, c, ty, id,wasp = (p != -1 && ve[gi].t == p) ? 1 : 0; (wasp = wasp ? 1 : (p != -1 && ve[gi].t == p) ? 1 : 0,gi + wasp < ve.size()) &&(tie(f, t, c, ty, id) = wasp ?  make_tuple(ve[gi + 1].f, ve[gi + 1].t, ve[gi + 1].c, ve[gi + 1].ty, ve[gi + 1].id) : make_tuple(ve[gi].f, ve[gi].t, ve[gi].c, ve[gi].ty, ve[gi].id), true); ++gi)\n#define fore(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c, ty, id; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, ty = ve[gi].ty, id = ve[gi].id, true); ++gi)\n\ntemplate<class T> struct edge_ {    int f, t, ty, id;    T c;    edge_(int f, int t, T c = 1, int ty = -1, int id= -1) : f(f), t(t), c(c), ty(ty), id(id) {}    bool operator<(const edge_ &b) const { return c < b.c; }    bool operator>(const edge_ &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge_<T> &e) {os << e.f << \" \" << e.t << \" \" << e.c<<\" \"<< e.ty<<\" \"<<e.id;return os;}\ntemplate<typename T> class graph {\npublic :\n    vector<vector<edge_<T>>> g;\n    vector<edge_<T>> edges;\n    int n;\n    explicit graph(int n) : n(n) { g.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {this->n = n;g.resize(n);}\n    int size() { return n; }\n    vector<edge_<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int ty, int id) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    explicit digraph(int n) : graph<T>(n) {}\n    explicit digraph(int n, const vector<edge_<T>>& E) : graph<T>(n) {        fora(e,E){            add(e.f,e.t,e.c);        }    }\n    void add(int f, int t, T c = 1, int ty = -1, int eid = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {debugline(\"digraph add\");deb(f, t, c);ole();}\n        int id = sz(edges);\n        if(eid != -1)id = eid;\n        g[f].emplace_back(f, t, c, ty, id);\n        edges.emplace_back(f, t, c, ty, id);//edgesを使わないなら消せる\n    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges() override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;    using graph<T>::n;    using graph<T>::edges;\n    explicit undigraph(int n) : graph<T>(n) {}\n    explicit undigraph(int n, const vector<edge_<T>>& E) : graph<T>(n) {        fora(e,E){            add(e.f,e.t,e.c);        }    }\n    int next_id = 0;\n    // f < t\n    void add(int f, int t, T c = 1, int ty = -1, int eid = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"undigraph add\");            deb(f, t, c);            ole();        }\n        int id = eid;\n        if(id == -1){\n            id = next_id++;\n        }\n        g[f].emplace_back(f, t, c, ty, id);\n        g[t].emplace_back(t, f, c, ty, id);\n        edges.emplace_back(f, t, c, ty, id);//edgesを使わないなら消せる\n        edges.emplace_back(t, f, c, ty, id);\n    }\n    void add(edge_<T> &e) {        int f = e.f, t = e.t,ty = e.ty,id=e.id;        T c = e.c;        add(f, t, c, ty, id);    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges () override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n#else\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n//#define fort(gi, ve) for (ll gi = 0, f, t, c,wasp = (p != -1 && ve[gi].t == p) ? 1 : 0; (wasp = wasp ? 1 : (p != -1 && ve[gi].t == p) ? 1 : 0,gi + wasp < ve.size()) &&(tie(f, t, c) = wasp ?  make_tuple(ve[gi + 1].f, ve[gi + 1].t, ve[gi + 1].c) : make_tuple(ve[gi].f, ve[gi].t, ve[gi].c), true); ++gi)\n#define fort(gi, ve) for (ll gi = 0,forglim = ve.size(); gi < forglim ; ++gi)\n#define fort_init(gi, ve) int f = ve[gi].f, t = ve[gi].t, c = ve[gi].c;if(t == p)continue;\n#define fore(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n\ntemplate<class T> struct edge_ {    int f, t;    T c;    edge_(int f, int t, T c = 1) : f(f), t(t), c(c) {}    bool operator<(const edge_ &b) const { return c < b.c; }    bool operator>(const edge_ &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge_<T> &e) {os << e.f << \" \" << e.t << \" \" << e.c;return os;}\ntemplate<typename T> class graph {\npublic :\n    vector<vector<edge_<T>>> g;\n    vector<edge_<T>> edges;\n    int n;\n    explicit graph(int n) : n(n) { g.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {this->n = n;g.resize(n);}\n    int size() { return n; }\n    vector<edge_<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    explicit digraph(int n) : graph<T>(n) {}\n    explicit digraph(int n, const vector<edge_<T>>& E) : graph<T>(n) {        fora(e,E){            add(e.f,e.t,e.c);        }    }\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {debugline(\"digraph add\");deb(f, t, c);ole();}\n        g[f].emplace_back(f, t, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges() override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;    using graph<T>::n;    using graph<T>::edges;\n    explicit undigraph(int n) : graph<T>(n) {}\n    explicit undigraph(int n, const vector<edge_<T>>& E) : graph<T>(n) {        fora(e,E){            add(e.f,e.t,e.c);        }    }\n    // f < t\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"undigraph add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n        edges.emplace_back(t, f, c);\n    }\n    void add(edge_<T> &e) {        int f = e.f, t = e.t;        T c = e.c;        add(f, t, c);    }\n    void ing(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t;            cin >> f >> t;            f -= minus;            t -= minus;            add(f, t);        }    }\n    void ingc(int n, int m, int minus = 1) {        this->resize(n);        rep(i, m) {            int f, t, c;            cin >> f >> t >> c;            f -= minus;            t -= minus;            add(f, t, c);        }    }\n    void set_edges () override{        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n#endif\n\n#define dijkstra_path dis_path\ntemplate<class T,class I> vi dis_path(digraph<T> &g, vector<T> &dis, int s, int t, I init_value) {    assert(dis[t] != init_value);    auto rg = rev(g);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(rg[now])) {            int m = rg[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + rg[now][gi].c + cost == dis[t]) {                cost += rg[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T,class I> vi dis_path(undigraph<T> &g, vector<T> &dis, int s, int t, I init_value) {    assert(dis[t] != init_value);    int now = t;    vi path;    path.push_back(now);    T cost = 0;    while (now != s) {        rep(gi, sz(g[now])) {            int m = g[now][gi].t;            if (dis[m] == init_value)continue;            if (dis[m] + g[now][gi].c + cost == dis[t]) {                cost += g[now][gi].c;                now = m;                break;            }        }        path.push_back(now);    }    rev(path);    return path;}\ntemplate<class T,class I> vi dis_path(digraph<T> &g, vector<vector<T>> &dis, int s, int t, I init_value) { return dis_path(g, dis[s], s, t, init_value); }\ntemplate<class T,class I> vi dis_path(undigraph<T> &g, vector<vector<T>> &dis, int s, int t, I init_value) { return dis_path(g, dis[s], s, t, init_value); }\nvi to_vi(const int& i){return vi{i};}\nvi to_vi(const vi& v){return v;}\n//O(N^2)\ntemplate<class T, class U, class I> vector<T> dijkstra_mitu(graph<T> &g, const U &S_, I init_value) {    vi S = to_vi(S_);    int n = g.n;    int initValue = MAX<T>();    vector<T> dis(n, initValue);    fora(s, S) {        if (!(0 <= s && s < g.n)) {            debugline(\"dijkstra_mitu\");            deb(s, g.n);            ole();        }        dis[s] = 0;    }    vb used(n);    while (true) {        int v = -1;        rep(u, n) { if (!used[u] && (v == -1 || dis[u] < dis[v]))v = u; }        if (v == -1)break;        if (dis[v] == initValue)break;        used[v] = true;        rep(u, sz(g[v])) {            auto e = g[v][u];            dis[e.t] = min(dis[e.t], dis[v] + e.c);        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) { if (d == initValue) { d = init_value; }}    return dis;}\ntemplate<class T, class U, class I> vector<T> dijkstra_01(graph<T> &g, const U &S_, I init_value) {int N = g.n;    vi S = to_vi(S_);    T tinf = INF<T>();    vector<T> dis(N, tinf);    deque<int> q;    fora(s, S) {        dis[s] = 0;        q.push_back(s);    }    vb was(N);    while (!q.empty()) {        int f = q.front();        q.pop_front();        if (was[f])continue;        was[f] = true;        fora(e, g[f]) {            if (dis[e.t] > dis[f] + e.c) {                if (e.c) {                    dis[e.t] = dis[f] + 1;                    q.push_back(e.t);                }                else {                    dis[e.t] = dis[f];                    q.push_front(e.t);                }            }        }    }    rep(i, N)if (dis[i] == tinf)dis[i] = init_value;    return dis;}\ntemplate<typename T> struct radixheap {    vector<pair<u64, T> > v[65];    u64 size_, last;    radixheap() : size_(0), last(0) {}    bool empty() const { return size_ == 0; }    int getbit(int a) { return a ? 64 - __builtin_clzll(a) : 0; }    void emplace(u64 key, const T &value) {        ++size_;        v[getbit(key ^ last)].emplace_back(key, value);    }    void push(u64 key, const T &value) { emplace(key, value); }    pair<u64, T> top() {        if (v[0].empty()) {            int idx = 1;            while (v[idx].empty()) ++idx;            last = min_element(begin(v[idx]), end(v[idx]))->first;            for (auto &p : v[idx]) v[getbit(p.first ^ last)].emplace_back(p);            v[idx].clear();        }        --size_;        auto ret = v[0].back();        v[0].pop_back();        return ret;    }    void pop() { ; }    int size() { return size_; }};\n//01, 密グラフ, normalを自動で判断する\ntemplate<class Q, class T, class U,class I> vector<T> private_dijkstra(graph<T> &g, U &S_, I init_value) {    vi S = to_vi(S_);    fora(s, S) {        if (!(0 <= s && s < g.n)) {            debugline(\"dijkstra\");            deb(s, g.n);            ole();        }    }    bool cost01 = true;    rep(i, g.n) { forg(gi, g[i]) { cost01 &= (c == 0 || c == 1); }}    if (cost01)return dijkstra_01(g, S_, init_value); else if ((g.n + sz(g.edges)) * log2(g.n) > g.n * g.n) { return dijkstra_mitu(g, S, init_value); }    T initValue = MAX<T>();    vector<T> dis(g.n, initValue);    Q q;    fora(s, S) {        dis[s] = 0;        q.emplace(0, s);    }    while (q.size()) {        T nowc;        int i;        tie(nowc, i) = q.top();        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                q.emplace(dis[to], to);            }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return dis;}\ntemplate<class T, class U,class I> vector<T> dijkstra(graph<T> &g, U S_, I init_value) { if (typeid(T) == typeid(int)) { return private_dijkstra<radixheap<int>>(g, S_, init_value); } else { return private_dijkstra<priority_queue<pair<T, int>, vector<pair<T, int >>, greater<pair<T, int >> >>(g, S_, init_value); }}\n//dijkstra_cou<mint> : 数える型で書く return vp(dis,cou)\ntemplate<class COU,class T=int,class I> auto dijkstra_cou(const graph<T> &g, int s, I init_value) {    if (!(0 <= s && s < g.n)) {        debugline(\"dijkstra\");        deb(s, g.n);        ole();    }    err(\"count by type COU \");    err(\"int or mint\");    T initValue = MAX<T>();    vector<T> dis(g.n, initValue);    vector<COU> cou(g.n);    cou[s] = 1;    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;    dis[s] = 0;    q.emplace(0, s);    while (q.size()) {        T nowc = q.top().fi;        int i = q.top().se;        q.pop();        if (dis[i] != nowc)continue;        for (auto &&e  : g.g[i]) {            int to = e.t;            T c = nowc + e.c;            if (dis[to] > c) {                dis[to] = c;                cou[to] = cou[e.f];                q.emplace(dis[to], to);            }            else if (dis[to] == c) { cou[to] += cou[e.f]; }        }    }    /*基本、たどり着かないなら-1*/    for (auto &&d :dis) if (d == initValue)d = init_value;    return vtop(dis, cou);}\n//コストを無限に減らせる := -linf\n//たどり着けない := linf\ntemplate<class T> vector<T> bell(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく */    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge_<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] + e.c) {                upd = true;                res[e.t] = res[e.f] + e.c;            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] + e.c) {                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    return res;}\n//コストを無限に増やせる := linf\n//たどり着けない := -linf\ntemplate<class T> vector<T> bell_far(graph<T> &g, int s) {    if (g.n >= 1e4) {        cout << \"bell_far size too big\" << endl;        exit(0);    }    vector<T> res(g.n, linf);    res[s] = 0;    vb can(g.n);    /*頂点から行けない頂点を持つ、辺を消しておく*/    fix([&](auto ds, int p, int i) -> void {        if (can[i])return;        can[i] = true;        forg(gi, g[i])if (t != p)ds(i, t);    })(-1, 0);    vector<edge_<T>> es;    fora(e, g.edges) { if (can[e.f])es += e; }    rep(i, g.n) {        bool upd = false;        fora(e, es) {            if (res[e.f] != linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = true;                res[e.t] = res[e.f] - e.c;/*-c*/            }        }        if (!upd)break;    }    rep(i, g.n * 2) {        bool upd = 0;        fora(e, g.edges) {            if (res[e.f] != linf && res[e.t] != -linf && res[e.t] > res[e.f] - e.c) {/*-c*/                upd = 1;                res[e.t] = -linf;            }        }        if (!upd)break;    }    rep(i, g.n)res[i] *= -1;    return res;}\n//コストが負の場合も扱えたはず\ntemplate<class T, class I> vector<vector<T>> warshall(graph<T> &g, I init_value) {    int n = g.n;    assert(n < 1e4);    vector<vector<T> > dis(n, vector<T>(n, INF<T>()));    rep(i, n)fora(e, g.g[i]) { if (dis[e.f][e.t] > e.c) { dis[e.f][e.t] = e.c; }}    rep(i, n)dis[i][i] = 0;    rep(k, n) rep(i, n) rep(j, n) { if (dis[i][j] > dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; }}    rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = init_value;    return dis;}\n//密グラフの時、warshallに投げる\n//01等の判定もここで出来る\ntemplate<class T, class I> vector<vector<T>> dijkstra_all(graph<T> &g, I init_value) {    int n = g.n;    assert(n < 1e4);    if (n * n < (n + sz(g.edges)) * 14) {        /*O(N^3) vs O(N (N+M)log N)*/        return warshall(g, init_value); }    vector<vector<T>> dis(n);    rep(i, n) { dis[i] = dijkstra(g, i, init_value); }    return dis;}\ntemplate<class T> class MinOp { public: T operator()(T a, T b) { return min(a, b); }};\ntemplate<typename OpFunc> struct SparseTable {    OpFunc op;    signed size;    vector<signed> lg;    vector<vector<pair<signed, signed>>> table;    void init( vector<pair<signed, signed>> &array, OpFunc opfunc) {        signed n = array.size();        op = opfunc;        lg.assign(n + 1, 0);        for (signed i = 1; i <= n; i++) { lg[i] = 31 - __builtin_clz(i); }        table.assign(lg[n] + 1, array);        for (signed i = 1; i <= lg[n]; i++) { for (signed j = 0; j < n; j++) { if (j + (1 << (i - 1)) < n) { table[i][j] = op(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]); } else { table[i][j] = table[i - 1][j]; }}}    }    pair<signed, signed> query(signed l, signed r) {        assert(l < r);        return op(table[lg[r - l]][l], table[lg[r - l]][r - (1 << lg[r - l])]);    }};\nstruct PMORMQ {    vector<signed> a;    SparseTable<MinOp<pair<signed, signed> > > sparse_table;    vector<vector<vector<signed> > > lookup_table;    vector<signed> block_type;    signed block_size, n_block;    void init( vector<signed> &array) {        a = array;        signed n = a.size();        block_size = std::max(1, (31 - __builtin_clz(n)) / 2);        while (n % block_size != 0) {            a.push_back(a.back() + 1);            n++;        }        n_block = n / block_size;        vector<pair<signed, signed> > b(n_block, make_pair(INT_MAX, INT_MAX));        for (signed i = 0; i < n; i++) { b[i / block_size] = min(b[i / block_size], make_pair(a[i], i)); }        sparse_table.init(b, MinOp<pair<signed, signed> >());        block_type.assign(n_block, 0);        for (signed i = 0; i < n_block; i++) {            signed cur = 0;            for (signed j = 0; j < block_size - 1; j++) {                signed ind = i * block_size + j;                if (a[ind] < a[ind + 1]) { cur |= 1 << j; }            }            block_type[i] = cur;        }        lookup_table.assign(1 << (block_size - 1), vector<vector<signed> >(block_size, vector<signed>(block_size + 1)));        for (signed i = 0; i < (1 << (block_size - 1)); i++) {            for (signed j = 0; j < block_size; j++) {                signed res = 0;                signed cur = 0;                signed pos = j;                for (signed k = j + 1; k <= block_size; k++) {                    lookup_table[i][j][k] = pos;                    if (i & (1 << (k - 1))) { cur++; } else { cur--; }                    if (res > cur) {                        pos = k;                        res = cur;                    }                }            }        }    }    signed query(signed l, signed r) {        assert(l < r);        signed lb = l / block_size;        signed rb = r / block_size;        if (lb == rb) { return lb * block_size + lookup_table[block_type[lb]][l % block_size][r % block_size]; }        signed pl = lb * block_size + lookup_table[block_type[lb]][l % block_size][block_size];        signed pr = rb * block_size + lookup_table[block_type[rb]][0][r % block_size];        signed pos = pl;        if (r % block_size > 0 && a[pl] > a[pr]) { pos = pr; }        if (lb + 1 == rb) { return pos; }        signed spv = sparse_table.query(lb + 1, rb).second;        if (a[pos] > a[spv]) { return spv; }        return pos;    }};\n\ntemplate<class T=int> class tree : public undigraph<T> {\n    PMORMQ rmq;    int cnt;    vector<signed> id_, in;    bool never = true;    bool never_hld = true;\n    void dfs(int x, int p, int d, int dis = 0) {        id_[cnt] = x;        par_[x] = p;        rmq_dep.push_back(d);        disv[x] = dis;        in[x] = cnt++;        forg(gi, g[x]) {            if (t == p) { continue; }            dfs(t, x, d + 1, dis + c);            id_[cnt] = x;            rmq_dep.push_back(d);            cnt++;        }    }    void precalc() {        never = false;        cnt = 0;        rmq_dep.clear();        disv.assign(n, 0);        in.assign(n, -1);        id_.assign(2 * n - 1, -1);        par_.assign(n, -1);        dfs(root, -1, 0);        rmq.init(rmq_dep);\n#ifdef _DEBUG\n        if(n>=100)return;cerr << \"---tree---\" << endl;        rep(i, n) {            if (!(i == root || sz(g[i]) > 1))continue;            cerr << i << \" -> \";            vi ts;            forg(gi, g[i]) { if (t != par_[i])ts.push_back(t); }            rep(i, sz(ts) - 1)cerr << ts[i] << \", \";            if(sz(ts))cerr << ts.back() << endl;        }        cerr << endl;\n#endif\n    }    int pos;    void hld_build() {        never_hld = false;        if (never)precalc();        g.resize(n);        vid.resize(n, -1);        head.resize(n);        heavy.resize(n, -1);        depth.resize(n);        inv.resize(n);        subl.resize(n);        subr.resize(n);        dfs(root, -1);        t = 0;        dfs_hld(root);\n#ifdef _DEBUG\n        if (n >= 100)return;        cerr << \"---hld_index---\" << endl;        vi inds;        rep(i, n) if (sz(g[i]))inds.push_back(i);        rep(i, sz(inds)) {            str s = tos(bel(inds[i]));            cerr << std::right << std::setw(sz(s) + (i ? 1 : 0)) << inds[i];        }        cerr << endl;        rep(i, sz(inds)) { cerr << bel(inds[i]) << \" \"; }        cerr << endl << endl;        cerr << \"---hld_edge_index---\" << endl;        fora(e, edges) { if (e.f <= e.t) cerr << e.f << \"-\" << e.t << \" \" << bel(e) << endl; }        cerr << endl << endl;        cerr << \"!!query!! edge or not edge carefull!!\" << endl;\n#endif\n    }    int dfs(int curr, int prev) {        int sub = 1, max_sub = 0;        heavy[curr] = -1;        forg(i, g[curr]) {            int next = t;            if (next != prev) {                depth[next] = depth[curr] + 1;                int sub_next = dfs(next, curr);                sub += sub_next;                if (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;            }        }        return sub;    }    int t = 0;\n#ifndef __CLION_IDE__\n    void dfs_hld(int v = 0) {        vid[v] = subl[v] = t;        t++;        inv[subl[v]] = v;        if (0 <= heavy[v]) {            head[heavy[v]] = head[v];            dfs_hld(heavy[v]);        }        forg(i, g[v])if (depth[v] < depth[t])                if (t != heavy[v]) {                    head[t] = t;                    dfs_hld(t);                }        subr[v] = t;    }\n#endif//__CLION_IDE__\n    vector<signed> rmq_dep;\n    vi par_, depth, disv;\n    vi childs_;\n    vi par_id_;//親への辺のidを持つ\n    vvi(ids_);//隣接で辺のidを持つ\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int root;\n    //(f,t)と(t,f)は同じidを持ち、[0,n-1]でadd順に割り振られる\n\n    //部分木の  [左端、右端)  index\n    //部分木の辺に加算する場合\n    //add(subl[i],subr[i],x)\n    //add(sub[i],sub[i+1],-x)\n    vector<int> vid, head, heavy, inv, subl, subr;\n\n    tree(int n_, int root = 0) : undigraph<T>(n_), root(root) { n = n_; }\n    tree(int n_, int root ,const vector<edge_<T>>& E) : undigraph<T>(n_), root(root) { n = n_;        fora(e, E){            add(e.f,e.t,e.c);        }    }\n    // f < t\n    void add(int f, int t, T c = 1) {\n        #ifdef _DEBUG\n            if((n% k5)==0){\n                re(\"tree must resize\");\n            }\n        #endif\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"tree add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n        edges.emplace_back(t, f, c);\n    }\n    void add_di(int f, int t, T c = 1){\n        #ifdef _DEBUG\n            if((n% k5)==0){\n                re(\"tree must resize\");\n            }\n        #endif\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"tree add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        edges.emplace_back(f, t, c);//edgesを使わないなら消せる\n    }\n    void root_change(int roo){root = roo;precalc();}\n    //葉になりえない頂点を根にする\n    void root_change_mid(){\n        #ifdef _DEBUG\n            message+=\"N>2 (mid)\\n\";\n        #endif\n        assert(n>2);        rep(i, n){            if(sz(g[i])>1){                root_change(i);                return;            }        }\n    }\n    int lca(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        return id_[pos];    }\n    int dis(int a, int b) {        if (never)precalc();        int x = in[a];        int y = in[b];        if (x > y) { swap(x, y); }        int pos = rmq.query(x, y + 1);        int p = id_[pos];        return disv[a] + disv[b] - disv[p] * 2;    }\n    int dep(int a){if (never)precalc(); return disv[a];}\n    int par(int a){if (never)precalc(); return par_[a];}\n    bool isleaf(int i){if(never)precalc();return(sz(g[i])==1 && i!=root);}\n    bool leaf(int i){return isleaf(i);}\n    int child(int r){return g[r].size() - (r != root);}\n    vi childs(int r) {        vi res;        res.push_back(r);        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res.push_back(i);            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }\n    vb child_ex(int r) {        vb res(n);        res[r] = true;        queue<int> q;        q.push(r);        while (!q.empty()) {            int i = q.front();            res[i] = true;            q.pop();            forg(gi, g[i]) {                if (t != par(i))q.push(t);            }        }        return res;    }int dfs_count_subtree(int p,int i){        childs_[i] =1;        fort(gi, g[i]){fort_init(gi, g[i]);            childs_[i] += dfs_count_subtree(i,t);        }        return childs_[i];    }\n    #define count_child count_subtree\n    int count_subtree(int f){        if(sz(childs_)==0){            if(never)precalc();            childs_.resize(n);            dfs_count_subtree(-1,root);        }        return childs_[f];    }\n    //fからtの辺を切った時のtの大きさ\n    int count_subtree(int f, int t) {        if (par(f) == t) {            return n - count_subtree(f);        } else {            return count_subtree(t);        }    }\n    int size(int f, int t){return count_subtree(f, t);}\n    int size(){return  n;}\n    vi path(int a, int b) {        vi res;        for_each_l(a, b, [&](int i) { res.push_back(i); });        return res;    }\n    //idはedgesに使えない ↓edge(id)とする\n    //pathに含まれる辺のid達を返す\n    vi pathe(int a,int b){\n        #ifdef _DEBUG\n        static bool was = 0;if(!was)message+=\"can't edges[id]. must edge(id)\\n\";was=1;\n        #endif\n        if(sz(par_id_)==0){            ids_.resize(n);            par_id_.resize(n);            rep(i,0,sz(edges),2){                ids_[edges[i].f].emplace_back(i>>1);                ids_[edges[i].t].emplace_back(i>>1);            }            if(never)precalc();/*par_を呼ぶため*/            rep(i, n){                int pa = par_[i];                forg(gi, g[i]){                    if(t==pa){                        par_id_[i] = ids_[i][gi];                    }                }            }            }        int u = lca(a,b);        vi res;        if (a != u) {            do {                res.emplace_back(par_id_[a]);                a = par_[a];            } while (a != u);        }        vi rev;        if (b != u) {            do {                rev.emplace_back(par_id_[b]);                b = par_[b];            } while (b != u);        }        rer(i,sz(rev)-1){            res.emplace_back(rev[i]);        }        return res;\n    }\n    //親の辺のidを返す\n    int par_id(int i){if(sz(par_id_)==0){pathe(0,0);}return par_id_[i];}\n    //fのi番目の辺のidを返す\n    int ids(int f,int i) {if(sz(ids_)==0){pathe(0,0);}return ids_[f][i];}\n    //idから辺を返す\n    edge_<T> edge(int id){return edges[id<<1];}\n\n    /*O(N) hldを使わず木を普通にたどる liteの意*/\n    void for_each_l(int u, int v, function<void(int)> fnode) {        int r = lca(u, v);        while (u != r) {            fnode(u);            u = par_[u];        }        fnode(r);        vi a;        while (v != r) {            a.push_back(v);            v = par_[v];        }        while(sz(a)){            fnode(a.back());            a.pop_back();        }    }\n    void for_each_edge_l(int u, int v, function<void(edge_<int> &)> fedge) {        int r = lca(u, v);        while (u != r) {                forg(gi, g[u]) {                    if (t == par_[u]) {                        fedge(g[u][gi]);                        u = par_[u];                        break;                    }                }            }        vector<edge_<int>> qs;        while (v != r) {                forg(gi, g[v]) {                    if (t == par_[v]) {                        qs.push_back(g[v][gi]);                        v = par_[v];                        break;                    }                }            }        while(sz(qs)){            fedge(qs.back());            qs.pop_back();        }    }\n    //Fは半開 (u,v)は木の頂点\n    //中ではhldの頂点を見るため、seg木のupdateはhldのindexで行なう\n    void for_each_/*[l,r)*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            int l = max(vid[head[v]], vid[u]);            int r = vid[v] + 1;            f(l, r);            if (head[u] != head[v]) v = par_[head[v]]; else break;        }    }\n    void for_each_edge/*[l,r) O(log(N)) 辺を頂点として扱っている 上と同じ感じで使える*/(int u, int v, const function<void(int, int)> &f) {        if (never_hld)hld_build();        while (1) {            if (vid[u] > vid[v]) swap(u, v);            if (head[u] != head[v]) {                int l = vid[head[v]];                int r = vid[v] + 1;                f(l, r);                v = par_[head[v]];            } else {                if (u != v) {                    int l = vid[u] + 1;                    int r = vid[v] + 1;                    f(l, r);                }                break;            }        }    }\n    int bel(int v) {        /*hld内での頂点番号を返す*/        if (never_hld)hld_build();return vid[v];}\n    //下の頂点に辺のクエリを持たせている\n    int bel(int f, int t) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[f] > depth[t] ? vid[f] : vid[t];}\n    int bel(edge_<T> &e) {        /*辺のクエリを扱うときどの頂点に持たせればいいか(vidを返すのでそのままupd出来る)*/        if (never_hld)hld_build();return depth[e.f] > depth[e.t] ? vid[e.f] : vid[e.t];}\n    template<class ... U> int operator()(U ... args) { return bel(args...); }\n    //path l -> r += v\n    template<class S> void seg_add(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); });}\n    template<class S> void seg_update(S &seg, int lhei, int rhei, int v) {for_each_(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); });}\n    template<class S> T seg_get(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    template<class S> void seg_add_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.add(l, r, v); }); }\n    template<class S> void seg_update_edge(S &seg, int lhei, int rhei, int v) { for_each_edge(lhei, rhei, [&](int l, int r) { seg.update(l, r, v); }); }\n    template<class S> T seg_get_edge(S &seg, int lhei, int rhei) {        T res = seg.e;        for_each_edge(lhei, rhei, [&](int l, int r) { res = seg.f(res, seg.get(l, r)); });        return res;    }\n    //単体   edgeは上で処理できる\n    template<class S> void seg_add(S &seg, int i, int v) { seg.add(bel(i), v); }\n    template<class S> void seg_update(S &seg, int i, int v) { seg.update(bel(i), v); }\n    template<class S> T seg_get(S &seg, int i) { return seg[i]; }\n    template<class S> void seg_del(S &seg, int i) { seg.del(bel(i)); }\n\n    //部分木iに対するクエリ\n    template<class S> void seg_add_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.add(subl[i], subr[i], v);}\n    template<class S> void seg_update_sub(S &seg, int i, int v) {if (never_hld)hld_build();seg.update(subl[i], subr[i], v);}\n    template<class S> T seg_get_sub(S &seg, int i, int v) {if (never_hld)hld_build();return seg.get(subl[i], subr[i], v);}\n    template<class S> void seg_add_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.add(subl[i] + 1, subr[i], v);}\n    template<class S> void seg_update_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/seg.update(subl[i] + 1, subr[i], v);}\n    template<class S> T seg_get_sub_edge(S &seg, int i, int v) {if (never_hld)hld_build();/*iの上の辺が数えられてしまうため、i+1から*/return seg.get(subl[i] + 1, subr[i], v);}\n};\n//辺が多いのでedgesを持たない\n//cost oo, ox, xo, xx 渡す\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\n    vi costs;\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;\n    int H, W;\n    vector<vector<char>> ba;\n    char wall;\n\n    void add(int f, int t, T c = 1){\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"grid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        g[t].emplace_back(t, f, c);\n        //undigraphと違い、edgesを持たない\n    }\n    int getid(int h, int w) {        assert(ins(h, w, H, W));        return W * h + w;    }\n    int getid(P p) { return getid(p.first, p.second); }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    int operator()(P p) { return getid(p); }\n    //辺は無い\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {}\n    grid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    /*o -> o, o -> x, x -> o, x-> x*/\n    grid_k6(vector<vector<char>> ba, int oo, int ox, int xo, int xx, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])), costs({oo, ox, xo, xx}), ba(ba), wall(wall) {        rep(h, H) {            rep(w, W) {                add(h, w, h + 1, w);                add(h, w, h - 1, w);                add(h, w, h, w + 1);                add(h, w, h, w - 1);            }        }    }\n    void add(int fh, int fw, int th, int tw) {\n        if (ins(fh, fw, H, W) && ins(th, tw, H, W)) {\n            int cm = 0;\n            if (ba[fh][fw] == wall) { cm += 2; }\n            if (ba[th][tw] == wall) { cm++; }\n            int f = getid(fh, fw);\n            int t = getid(th, tw);\n            g[f].emplace_back(f, t, costs[cm]);\n        }\n    }\n    void set_edges() { rep(i, n)fora(e, g[i])if (e.f < e.t)edges.push_back(e); }\n};\n\n//辺によりメモリを大量消費ためedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    int H, W;\n    void add(int f, int t, T c = 1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"digrid_k6 add\");            deb(f, t, c);            ole();        }\n        g[f].emplace_back(f, t, c);\n        /*digraphと違いedgesを持たない*/\n    }\n    int getid(int h, int w) {        if (!ins(h, w, H, W))return -1;        return W * h + w;    }\n    P get2(int id) { return mp(id / W, id % W); }\n    P operator()(int id) { return get2(id); }\n    int operator()(int h, int w) { return getid(h, w); }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W){}\n    digrid_k6(vector<vector<char>> ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {        rep(h, H) {            rep(w, W) {                if (ba[h][w] == wall)con;                int f = getid(h, w);                if (w + 1 < W && ba[h][w + 1] != wall) { add(f, getid(h, w + 1)); }                if (h + 1 < H && ba[h + 1][w] != wall) { add(f, getid(h + 1, w)); }            }        }    }\n    void add(int fh, int fw, int th, int tw) { add(getid(fh, fw), getid(th, tw)); }\n    void set_edges() { rep(i, n)fora(e, g[i])edges.push_back(e); }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segdi : public digraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segdi add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/    }int mid;int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segdi(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n//edgesを持たない\n//dijkstra(g,0)[t] とかける (t+n-1等とする必要はない)\ntemplate<class T=int>class segun : public undigraph<T>{int getid(int k){        if(k >= len*2-1){            return k;        }        else if(k < len - 1){            return k + len;        }else{            return k - len + 1;        }    }void add(int f, int t, T c = 1) {        f = getid(f);        t = getid(t);        if (!(0 <= f && f < n && 0 <= t && t < n)) {            debugline(\"segun add\");            deb(f, t, c);            ole();        }        g[f].emplace_back(f, t, c);        /*digraphと違いedgesを持たない*/            g[t].emplace_back(t, f, c);        /*digraphと違いedgesを持たない*/    }    int mid;    int len;\npublic:\n    using digraph<T>::g;    using digraph<T>::n;    using digraph<T>::edges;\n    //頂点が足りなくなったらresize\n    segun(int n_) : digraph<T>(1) {        int nn = 1;        while (nn < n_)nn *= 2;        n_ = nn;        len = n_;        this->resize(n_ + (n_ - 1) * 2 + n_);        mid = n_ + (n_ - 1) * 2;        int ad = len * 2 - 1;        rep(i, len - 1) {            add(i, i * 2 + 1, 0);            add(i, i * 2 + 2, 0);            if (i * 2 + 1 >= len - 1) {                add(i * 2 + 1, i + ad, 0);                add(i * 2 + 2, i + ad, 0);            } else {                add(i * 2 + 1 + ad, i + ad, 0);                add(i * 2 + 2 + ad, i + ad, 0);            }        }    }\n    void dfs(vi &list, int nl, int nr, int k, int l, int r) {        if (r <= nl || nr <= l)return;        if (l <= nl && nr <= r) {            list += k;        } else {            dfs(list, nl, (nl + nr) / 2, k * 2 + 1, l, r);            dfs(list, (nl + nr) / 2, nr, k * 2 + 2, l, r);        }    }\n    void rekkyo(vi &list, int l, int r) {        l += len - 1;        r += len - 1;        while (l < r) {            if (!(l & 1)) { list.push_back(l); }            if (!(r & 1)) { list.push_back(r - 1); }            l >>= 1;            r = (r - 1) >> 1;        }    }\n    //半開\n    void add(int fl, int fr, int tl, int tr, int cost) {        /*fは下側*/        int ad = 2 * len - 1;        if (mid >= n) { this->resize(n + 100); }        {            int l = fl, r = fr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) {                    if (l - len + 1 < 0)add(l + ad, mid, cost);                    else add(l, mid, cost);                }                if (!(r & 1)) {                    if (r - 1 - len + 1 < 0)add(r - 1 + ad, mid, cost);                    else add(r - 1, mid, cost);                }                l >>= 1;                r = (r - 1) >> 1;            }        }        {            int l = tl, r = tr;            l += len - 1;            r += len - 1;            while (l < r) {                if (!(l & 1)) { add(mid, l, 0); }                if (!(r & 1)) { add(mid, r - 1, 0); }                l >>= 1;                r = (r - 1) >> 1;            }        }        mid++;    }\n};\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define o_getid(a,b,name,...) name\n#define getid(...) o_getid(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n\n#define unionfind unionfind_graph\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    template<class T>unionfind(graph<T>& g) : n(g.n), trees(g.n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }        add(g);    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    template<class T>void add(graph<T>&g){fora(e,g.edges){unite(e.f,e.t);}}\n    template<class T>void unite(graph<T>&g){add(g);}\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\n//@出力\ntemplate<class T> ostream &operator<<(ostream &os, digraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges) << endl;    fore(gi, g.edges)    { os << f << \" \" << t << \" \" << c << endl; }    return os;}template<class T> ostream &operator<<(ostream &os, undigraph<T> &g) {    os << endl << g.n << \" \" << sz(g.edges) / 2 << endl;    fore(gi, g.edges){ if (f < t)os << f << \" \" << t << \" \" << c << endl; }    return os;}\n//@判定\ntemplate<class T> bool nibu( graph<T> &g) {    int size = 0;    rep(i, g.n)size += sz(g.g[i]);    if (size == 0)return true;    unionfind uf(g.n * 2);    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);    rep(i, g.n)if (uf.same(i, i + g.n))return 0;    return true;}\n//頂点ではなく辺の数に依存した計算量 O(E)\ntemplate<class T> bool nibu_sub( graph<T> &g) {    umapi col;/*0なら無色 */   queue<int> q;    /*色は01か11 */    fora(e, g.edegs) {        /*fとtの色を持つか否かは同じ*/        if (col[e.f] == 0)q.push(e.f);        while (!q.empty()) {            int f = q.front();            q.pop();            int fc = col[f];            forg(gi, g[f]) {                int &tc = col[t];                /*fcには色がある*/                if (fc == tc)return false;                /*違う色*/                if (tc)continue;                /*無色*/                tc = fc ^ 2;                q.push(tc);            }        }    }    return true;}\n    //二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {    vp cg;    if (!nibu(g)) {        debugline(\"nibu\");        ole();    }    int n = g.size();    vb was(n);    queue<P> q;    rep(i, n) {        if (was[i])continue;        q.push(mp(i, 1));        was[i] = 1;        int red = 0;        int coun = 0;        while (q.size()) {            int now = q.front().fi;            int col = q.front().se;            red += col;            coun++;            q.pop();            forg(gi, g[now]) {                if (was[t])continue;                q.push(mp(t, col ^ 1));                was[t] = 1;            }        }        cg.push_back(mp(red, coun - red));    }    return cg;}\n    //連結グラフが与えられる 閉路があるか\ntemplate<class T> bool close(undigraph<T> &g) {    int n = 0;    int e = 0;    rep(i, g.n) {        if (sz(g[i]))n++;        forg(gi, g[i]) { e++; }    }    return (e >> 1) >= n;}\ntemplate<class T> bool close(undigraph<T> &g, int v) {    unionfind uf(g.n);    rep(i, g.n) {        forg(gi, g[i]) {            if (f < t)break;            if (f == t && f == v)return true;            if (uf.same(f, v) && uf.same(t, v))return true;            uf.unite(f, t);        }    }    return false;}template<class T> bool close(digraph<T> &g) {    vi res;    return topo(res, g);}\n\n//@変形\n//条件(f!=0等 f,t,cが使える)を満たすsubgraphをg2に代入\n#define sub_di(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){if(zhouken){g2.add(f,t,c);}}}\n#define sub_un(g, g2, zhouken) {g2.resize(g.n);fore(gi, g.edges){bool ok = zhouken; /*片方がアウトなら駄目という扱い*/swap(f,t); ok &= zhouken;if(ok && f < t){g2.add(f,t,c);}}}\n//誘導部分グラフ(両辺がVに含まれる辺を含む最大のグラフを返す) yuudou\n#define sub_di_guided(g, g2, V) {vi ex(max(V)); fora(v,V){ex[v]=1;}sub_di(g, g2, ex[f] && ex[t]);}\n#define sub_un_guided(g, g2, V) {vi ex(max(V)); fora(v,V){ex[v]=1;}sub_un(g, g2, ex[f] && ex[t]);}\n\n#define sub_tree sub_un\n    //閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    queue<int> st;    rep(i, n)if (nyu[i] == 0)st.push(i);    while (st.size()) {        int v = st.front();        st.pop();        res.push_back(v);        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);    }    return res.size() == n;}\n    //辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {    int n = g.g.size();    vi nyu(n);    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;    /*小さい順*/    priority_queue<int, vector<int>, greater<int> > q;    rep(i, n)if (nyu[i] == 0)q.push(i);    while (q.size()) {        int i = q.top();        q.pop();        res.push_back(i);        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);    }    return res.size() == n;}\ntemplate<class T> digraph<T> rev(digraph<T> &g) {    digraph<T> r(g.n);    rep(i, g.n) { forg(gi, g[i]) { r.add(t, f, c); }}    return r;}\n    //lc,rcは子を持つ中で一番左、右\n    //(g,ind,l,r)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r) {if (sz(ind)) {cerr << \"ind must be empty\" << endl;exit(0);}int N = sz(g);ind.resize(N);l.resize(N, inf);r.resize(N, -1);tree<T> h(N);queue<P> q;q.emplace(-1, 0);int c = 0;while (sz(q)) {int p = q.front().first;int i = q.front().second;q.pop();ind[i] = c;if (~p)chmi(l[ind[p]], c);if (~p)chma(r[ind[p]], c);c++;forg(gi, g[i]) {if (t != p)q.emplace(i, t);}}fora(e, g.edges) {if (e.f < e.t) {h.add(ind[e.f], ind[e.t], e.c);}}rep(i, N) {if (l[i] == inf)l[i] = -1;}return h;}\n    //lc,rcは子を持つ中で一番左、右\n    // たとえばl[lc[x]は2段下の最左\n    //(g,ind,l,r,lc,rc)\ntemplate<class T> tree<T> get_bfs_tree(tree<T> &g, vi &ind, vi &l, vi &r, vi &lc, vi &rc) {    if (sz(ind)) {        cerr << \"ind must be empty\" << endl;        exit(0);    }    int N = sz(g);    ind.resize(N);    l.resize(N, inf);    lc.resize(N, inf);    r.resize(N, -1);    rc.resize(N, -1);    tree<T> h(N);    queue<P> q;    q.emplace(-1, 0);    int c = 0;    while (sz(q)) {        int p = q.front().first;        int i = q.front().second;        q.pop();        ind[i] = c;        if (~p) {            chmi(l[ind[p]], c);            chma(r[ind[p]], c);            if (sz(g[i]) > 1) {                chmi(lc[ind[p]], c);                chma(rc[ind[p]], c);            }        }        c++;        forg(gi, g[i]) {            if (t != p)q.emplace(i, t);        }    }    fora(e, g.edges) {        if (e.f < e.t) {            h.add(ind[e.f], ind[e.t], e.c);        }    }    rep(i, N) {        if (l[i] == inf)l[i] = -1;        if (lc[i] == inf)lc[i] = -1;    }    return h;}\n\n//@集計\ntemplate<class T> vi indegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { forg(gi, g[i]) { ret[t]++; }}return ret;}\ntemplate<class T> vi outdegree(graph<T> &g) {vi ret(g.size());rep(i, g.size()) { ret[i] = g[i].size(); }return ret;}\n#define kansetu articulation\n//private\n/*private*/  P farthest____(tree<> &E, int cur, int pre, int d, vi &D) {    D[cur] = d;    P r = {d, cur};    forg(gi, E[cur]) if (t != pre) {            P v = farthest____(E, t, cur, d + c, D);            r = max(r, v);        }    return r;}\n//dagでなければ-1を返す\nint diameter(digraph<> &g) {    vi per;    if (!topo(per, g))return -1;    int n = g.n;    vi dp(n);    fora(v, per) { forg(gi, g[v]) { chma(dp[t], dp[f] + c); }}    return max(dp);}\n//iから最も離れた距離\nvi diameters(tree<> &E) { /* diameter,center*/vi D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    rep(i, D[0].size()) D[2].push_back(max(D[0][i], D[1][i]));    return D[2];}\n//iに対応するjと距離\nvp diameters_p(tree<> &E) { /* diameter,center*/vector<int> D[3];    D[0].resize(E.size());    D[1].resize(E.size());    auto v1 = farthest____(E, 0, 0, 0, D[0]);    auto v2 = farthest____(E, v1.second, v1.second, 0, D[0]);    farthest____(E, v2.second, v2.second, 0, D[1]);    int i;    vp res(E.size());    rep(i, D[0].size()) { if (D[0][i] > D[1][i])res[i] = mp(v1.second, D[0][i]); else res[i] = mp(v2.second, D[1][i]); }    return res;}\nint diameter(tree<> &E) {    vi d = diameters(E);    return max(d);}\n//最も離れた二点を返す\nP diameter_p(tree<> &E) {    auto d = diameters_p(E);    int dis = -1;    int l = -1, r = -1;    rep(i, sz(d)) {        if (chma(dis, d[i].se)) {            l = i;            r = d[i].fi;        }    }    return mp(l, r);}\n\n\n//@列挙 取得\n//閉路がある時linfを返す\ntemplate<class T> int longest_path(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return linf; }    int n = sz(top);    vi dp(n, 0);    for (auto &&i : top) { forg(gi, g[i]) { chma(dp[t], dp[i] + 1); }}    return max(dp);}\ntemplate<class T> vi longest_path_v(digraph<T> &g) {    vi top;    if (!topo(top, g)) { return vi(); }    int n = sz(top);    vi dp(n, 0);    vi pre(n, -1);    for (auto &&i : top) { forg(gi, g[i]) { if (chma(dp[t], dp[i] + 1)) { pre[t] = i; }}}    int s = std::max_element(dp.begin(), dp.end()) - dp.begin();    vi path;    while (s != -1) {        path.push_back(s);        s = pre[s];    }    std::reverse(path.begin(), path.end());    return path;}\n//橋を列挙する (取り除くと連結でなくなる辺)\ntemplate<class T> vp bridge(graph<T> &G) {    static bool was;    vp brid;    vi articulation;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) brid.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) articulation.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(brid.begin(), brid.end());    return brid;}\n//間接点を列挙する (取り除くと連結でなくなる点)\ntemplate<class T> vi articulation(undigraph<T> &G) {    static bool was;    vp bridge;    vi arti;    vi ord(G.n), low(G.n);    vb vis(G.n);    function<void(int, int, int)> dfs = [&](int v, int p, int k) {        vis[v] = true;        ord[v] = k++;        low[v] = ord[v];        bool isArticulation = false;        int ct = 0;        for (int i = 0; i < G[v].size(); i++) {            if (!vis[G[v][i].t]) {                ct++;                dfs(G[v][i].t, v, k);                low[v] = min(low[v], low[G[v][i].t]);                if (~p && ord[v] <= low[G[v][i].t]) isArticulation = true;                if (ord[v] < low[G[v][i].t]) bridge.push_back(make_pair(min(v, G[v][i].t), max(v, G[v][i].t)));            } else if (G[v][i].t != p) { low[v] = min(low[v], ord[G[v][i].t]); }        }        if (p == -1 && ct > 1) isArticulation = true;        if (isArticulation) arti.push_back(v);    };    int k = 0;    rep(i, G.n) { if (!vis[i]) dfs(i, -1, k); }    sort(arti.begin(), arti.end());    return arti;}\n//閉路パスを一つ返す\n\nvi close_path(digraph<> &g) {    int n = g.n;    vi state(n);    vi path;    rep(i, n) if (!state[i]) {            if (fix([&](auto dfs, int v) -> bool {                if (state[v]) {                    if (state[v] == 1) {                        path.erase(path.begin(), find(path.begin(), path.end(), v));                        return true;                    }                    return false;                }                path.push_back(v);                state[v] = 1;                forg(gi, g[v]) { if (dfs(t))return true; }                state[v] = -1;                path.pop_back();                return false;            })(i)) { return path; }        }    return vi();}\n#ifdef type_id_graph\nvi close_path_id(digraph<> &g) {    auto D = close_path(g);    if(sz(D)==0)return vi();    D += D[0];    vi ret;    int cur = D[0];    rep(i,sz(D)-1){        forg(gi, g[D[i]]){            if(t == D[i+1]){                ret += id;                break;            }        }    }    return ret;}\n#endif\nvi close_path_min(digraph<> &g) {    int n = g.n;    vvi(dis, n);    rep(i, n)dis[i] = dijkstra(g, i, linf);    int mind = linf;    int f = 0, t = 0;    rep(i, n) {        rep(j, n) {            if (i == j)continue;            if (chmi(mind, dis[i][j] + dis[j][i])) {                f = i;                t = j;            }        }    }    vi path;    auto add = [&](int f, int t) {        int now = f;        while (now != t) {            rep(i, n) {                if (dis[now][i] == 1 && dis[f][i] + dis[i][t] == dis[f][t]) {                    path.push_back(i);                    now = i;                    break;                }            }        }    };    add(f, t);    add(t, f);    return path;}\n//iを含む最短閉路 https://atcoder.jp/contests/abc022/tasks/abc022_c\n/*閉路が1つしかない場合、その閉路に含まれる頂点を1としたvectorを返す*/;\ntemplate<class T> vi get_close1(digraph<T> &g) {    int n = g.n;    queue<int> q;    vi d = outdegree(g);    vi res(n, 1);    rep(i, n) {        if (d[i] == 0) {            q += i;            res[i] = 0;        }    }    auto rg = rev(g);    while (q.size()) {        auto now = q.front();        q.pop();        forg(gi, rg[now]) {            if (--d[t] == 0) {                q += t;                res[t] = 0;            }        }    }    return res;}\n\n//@アルゴリズム\n//下にkrus_idがある\n#define mst krus\ntemplate<class T> vi krus_i(vector<edge_<T>> &g, int group = 1, int n = -1) {    if (n == -1)fora(e, g) { chma(n, max(e.f, e.t) + 1); };    vi res;    unionfind uf(n);    auto eis = sorti(g);    int gcou = n;    fora(ei, eis) {        if (gcou == group)break;        if (uf.unite(g[ei].f, g[ei].t)) {            res += ei;            gcou--;        }    }    return res;}\ntemplate<class T> vector<edge_<T>> krus_ed(vector<edge_<T>> &g, int group=1, int n = -1) {    auto inds = krus_i(g, group, n);    vector<edge_<T>> ret;    fora(i, inds) ret += g[i];    return ret;}\ntemplate<class T> vector<edge_<T>> krus_ed(undigraph<T> &g, int group = 1) {    if (sz(g.edges) == 0)g.set_edges();    return krus_ed(g.edges, group, g.n);}\ntemplate<class T> T krus(undigraph<T> &g, int group = 1) {    auto edges = krus_ed(g, group);    T res=0;    fora(e,edges)res += e.c;    return res;}\n//森を返す\ntemplate<class T> undigraph<T> krus_un(undigraph<T> &g, int group/*森になるので*/) {    return undigraph<T>(g.n, krus_ed(g, group));}\ntemplate<class T> tree<T> krus_tr(undigraph<T> &g) {    return tree<T>(g.n, 0,krus_ed(g));}\n\ntemplate<class T> int krus(vector<edge_<T>> &g, int group = 1) {    auto edges = krus_ed(g, group);    T res=0;    fora(e, edges)res += e.c;    return res;}\n\n\n/*@formatter:off*/\n//@実験\ndigraph<> rang_di(int n, int m, bool zibun = 0, bool taju = 0) {umapp was;    digraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(f, t)])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(f, t)] = 1;        m--;    }    return g;}\ndigraph<> perfect_di(int n, bool zibun = 0) {    digraph<> g(n);    rep(i, n) {        rep(j, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\nundigraph<> rang_un(int n, int m, bool zibun = 0, bool taju = 0) {    umapp was;    undigraph<> g(n);    was[mp(-1, -2)] = 1;    while (m) {        int f = -1, t = -2;        while (f < 0 || (!taju && was[mp(min(f, t), max(f, t))])) {            f = rand(0, n - 1);            t = rand(0, n - 1);            if (!zibun && f == t)f = -1;        }        g.add(f, t);        was[mp(min(f, t), max(f, t))] = 1;        m--;    }    return g;}\nundigraph<> perfect_un(int n, bool zibun = 0){    undigraph<> g(n);    rep(i, n) {        rep(j, i, n) {            if (!zibun && i == j)con;            g.add(i, j);        }    }    return g;}\n/*頂点数がkの木を一つ返す サイズが0の木が帰ったら終了*/\ntree<int> next_tree(int k) {    assert(2 <= k && k < 11);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\nazeka6.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\trees_sizek\\\\tree_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = pow(k, k - 2);/*Cayleyの定理*/        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    tree<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nundigraph<int> next_undi(int k) {    assert(2 <= k && k < 9);    static str name;    static ifstream ina;    static int rem;    static vp edges;    static vi lims = {-1, -1, 1, 4, 38, 728, 26704, 1866256};    static int pk = -1;/*前回見たk*/    if (pk != k) {        if (~pk)ina.close();        edges.clear();        pk = k;        name = (k == 6) ? \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\roku.txt\" : \"C:\\\\Users\\\\kaout\\\\Desktop\\\\undi_sizek\\\\undi_size\" + tos(k) + \".txt\";        ina = ifstream(name);        rem = lims[k];        rep(i, k)rep(j, i + 1, k)edges.emplace_back(i, j);        pk = k;    }    undigraph<int> g(k);    if (rem == 0) {        g.resize(0);        return g;    }    int m;    ina >> m;    while (m) {        int lb = lbit(m);        int id = log2(lb);        g.add(edges[id].first, edges[id].second);        m ^= lb;    }    rem--;    return g;}\nvector<tree<int>> trees(int k) {    vector<tree<int>> res;    while (1) {        tree<int> g = next_tree(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\nvector<undigraph<int>> undis(int k) {    vector<undigraph<int>> res;    while (1) {        undigraph<int> g = next_undi(k);        if (sz(g) == 0)break;        res.push_back(g);    }    return res;}\ntemplate<class T,class I> vector<vector<int>> table(graph<T> &g,I init_value) {    vvi(res, g.n, g.n,init_value);    rep(i, g.n) { forg(gi, g[i]) { res[i][t] = c; }}    return res;}\n\n#ifdef type_id_graph\ntemplate<class T> vector<vector<edge_<T>>> type_list(digraph<T> &g) {    vector<vector<edge_<T>>> res;    rep(i, g.n) { forg(gi, g[i]) { res[ty].push_back(g[i][gi]); }}    return res;}\ntemplate<class T> vector<vector<edge_<T>>> type_list(undigraph<T> &g, int types = -1) {    int tn = types;    if (types == -1)tn = g.n;    rep(i, g.n) { forg(gi, g[i]) { chma(tn, ty); }}    vector<vector<edge_<T>>> res(tn + 1);    vi was(g.n);    rep(i, g.n) {        forg(gi, g[i]) {            if (f < t)res[ty].push_back(g[i][gi]);            else if (f == t && !was[f]) {                res[ty].push_back(g[i][gi]);                was[f] = 1;            }        }    }    return res;}\n//idは 00 11 22のようにedgesに持たれている\ntemplate<class T> vi krus_id(undigraph<T> &g) {    unionfind uf(g.n);    if (sz(g.edges) == 0)g.set_edges();    int i = 0;    auto E = g.edges;    sort(E);    vi res;    fora(e, E) { if (uf.unite(e.f, e.t)) { res.push_back(e.id); }}    return res;}\n//graの方が早い\n#endif\n//type,idが使いたい場合は\n//type_id_graph\n// を付ける\n#define edge edge_\n/*@formatter:on*/}\nnamespace {/*@formatter:off*/\ntemplate<typename sum_t, typename F, typename G, typename Graph>\nstruct Body_Rerooting {\n//    using F = function< sum_t(sum_t, sum_t) >;\n//    using G = function< sum_t(sum_t, cost_t) >;\n    Graph g;\n    vector<sum_t> dp_base, dp_all;\n    const sum_t ident;\n    const F f;\n    const G gg;\n    /*@formatter:on*/\n    Body_Rerooting(Graph &tr, const F &f, const G &gg, const sum_t &ident) : g(tr), f(f), gg(gg), ident(ident), dp_base(tr.n, ident), dp_all(tr.n, ident) {}\n    /*@formatter:on*/\n    sum_t dfs_sub(int i, int p) {\n        int tpi;\n        rep(gi, sz(g[i])) {\n            if (g[i][gi].t == p) {\n                tpi = gi;\n                continue;\n            }\n            dp_base[i] = f(dp_base[i], dfs_sub(g[i][gi].t, i));\n        }\n        if (p == -1) { return dp_base[i]; }\n        else {\n            return dp_base[i] = gg(dp_base[i], g[i][tpi]);\n        }\n    }\n    void dfs_all(int i, int p, const sum_t &top) {\n        int n = sz(g[i]);        /*iより右の結果*/\n        vector<sum_t> rrui(n + 1, ident);\n        rer(gi, n - 1) {\n            if (g[i][gi].t == p) {\n                rrui[gi] = f(ident, rrui[gi + 1]);\n            } else {\n                /*メモ*/\n                rrui[gi] = f(dp_base[g[i][gi].t], rrui[gi + 1]);\n            }\n        }\n        dp_all[i] = f(top, rrui[0]);\n        sum_t lv = top;\n        rep(gi, n) {\n            if (g[i][gi].t == p)continue;\n            dfs_all(g[i][gi].t, i, gg(f(lv, rrui[gi + 1]), g[i][gi]));\n            lv = f(lv, dp_base[g[i][gi].t]);\n        }\n    }\n    vector<sum_t> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp_all;\n    }\n};\n//Body_Rerooting<decltype(M(1,0)), decltype(f1), decltype(f2),decltype(g) > rero(g, f1, f2, M(1,0));\n\n//#define reroot(g, f_merge, f_eval, e) call_reroot<decltype(e), decltype(f_merge), decltype(f_eval)>(g, f_merge, f_eval, e)\n\n//要素数などが必要な時は\n//pair(val, 要素数)等を持たせる\n\n//merge := (val, val)\n\n//edgeで伝播(根元がtになっている)\n//eval  := (val, edge)\n\n//reroot(g, f_merge, f_eval, e)\n    int sa = 0, sb = 0;\n    template<class SUM, class F, class G, class T> vector<SUM> reroot(tree<T> &g, F &f_merge, G &f_eval, SUM e) {\n        Body_Rerooting<SUM, F, G, tree<T>> rero(g, f_merge, f_eval, e);\n        return rero.build();\n    }\n\n    template<class SUM, class F, class G, class T> vector<SUM> reroot_size(tree<T> &g, F &f_merge, G &f_eval, SUM e) {\n        auto f_cou = [&](const pair<SUM, int> &a, const pair<SUM, int> &b) {\n            sa = a.se;\n            sb = b.se;\n            return pair<SUM, int>(f_merge(a.fi, b.fi), a.se + b.se);\n        };\n        auto g_cou = [&](const pair<SUM, int> &a, edge_<T> &e) {\n            sa = a.se + 1;/*自分を伝播する際のサイズを入れた*/\n            return pair<SUM, int>(f_eval(a.fi, e), a.se + 1);/*根(自分)をマージする操作なので+1*/\n        };\n        Body_Rerooting<pair<SUM, int>, decltype(f_cou), decltype(g_cou), tree<T>> rero(g, f_cou, g_cou, pair<SUM, int>(e, 0));\n        return keys(rero.build());\n    }\n/*@formatter:off*/\n///\n//rerootと\n//reroot_size (sa, sbで左右のサイズにアクセスできる)がある\n//\n//f_merge := SUM(SUM, SUM)\n\n//f_eval  := SUM(SUM, edge_<T>)\n//add_root_evalは根を付け足し、伝播する操作\n//reroot_sizeの要素数は根の要素数を含むことにしている\n///\n}\n\n//16:39\nvoid solve() {\n    in(N);\n    tree<> g(2 * k5);\n    g.ing(N, N - 1);\n    using P = pair<double, int>;\n    auto f1=[&](P a, P b){\n        return a+ b;\n    };\n    auto div=[&] (P a){\n        if(a.se==0){\n            return P(0., 1);\n        }else {\n            return P(a.fi/a.se+1., 1);\n        }\n    };\n    auto f2=[&](P a, auto e){\n        return div(a);\n    };\n    auto ret = reroot(g, f1,f2,P(0,0));\n    fora(r,ret ) {                                                                                                          /*@formatter:off*/fora_init(r,ret );/*@formatter:on*/\n        out(div(r).fi);\n    }\n\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint n, u, v;\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tcin >> u >> v;\n\t}\n\n\tcout << n - 1 << endl;\n\tfor (int i = 2; i <= n - 1; i++){\n\t\tfloat ans = (n - 1) / 2;\n\t\tcout << ans << endl;\n\t}\n\tcout << n - 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int,double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += dfs(u, v) + 1;\n\t}\n\tif (ans == 0)return dp[v][p] = 0;\n\treturn dp[v][p] = ans / (double)(E[v].size() - (p == -1 ? 0 : 1));\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<61;\nconst ll mod=1e9+7;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nvector<ll> inv,fact,invfact;\nvoid Mod_build(int n=201010){\n\tfact.resize(n+1);\n\tinv.resize(n+1);\n\tinvfact.resize(n+1);\n\tfact[0]=inv[0]=invfact[0]=1;\n\tinv[1]=1;\n\tfor(ll i=0;i<n;i++){\n\t\tfact[i+1]=fact[i]*(i+1)%mod;\n\t\tif(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n\t\tinvfact[i+1]=invfact[i]*inv[i+1]%mod;\n\t}\n}\nll perm(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n\tif(n<0||k<0||k>n)return 0;\n\treturn (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n\tk%=mod-1;\n\tif(k<0)k+=mod-1;\n\tll ret=1;\n\twhile(k){\n\t\tif(k&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tk>>=1;\n\t}\n\treturn ret;\n}\n\n\nll modinv(ll a) {\n    ll m=mod;\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\nint n;\nvector<int> E[201010];\nvector<double> dp1(201010,0);\nvector<double> dp2(201010);\nVI size1(201010,0);\nVI size2(201010);\nvector<double> ans(201010);\n\nvoid dfs1(int cu, int pa = -1) {\n  for(int to:E[cu]) {\n    if (to != pa) {\n      dfs1(to,cu);\n      dp1[cu]+=dp1[to];\n\t    size1[cu]++;\n    }\n  }\n  if(size1[cu]) {\n    dp1[cu]/=size1[cu];\n    dp1[cu]+=1.0;\n  }\n}\n\nvoid dfs2(int cu, int pa = -1) {\n  if(pa==-1) {\n    dp2[cu]=0;\n    ans[cu]=dp1[cu];\n  } \n  else ans[cu]=(dp1[cu]*size1[cu]+dp2[cu])/(size1[cu]+1);\n  for(int to:E[cu]){\n    if(to==pa) continue; \n    if(pa!=-1){ \n      dp2[to]=ans[cu]*(size1[cu]+1)-(dp1[to]+1);\n      dp2[to]/=size1[cu]; \n    }\n    else {\n      dp2[to]=ans[cu]*size1[cu]-(dp1[to]+1);\n      if(size1[cu]-1) dp2[to]/=(size1[cu]-1);\n    }\n    dp2[to]+=1;\n    dfs2(to,cu);\n  }\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint i,j;\n\tcin>>n;\n\tMod_build();\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--; b--;\n\t\tE[a].pb(b);\n\t\tE[b].pb(a);\n\t}\n\tdfs1(0);\n  dfs2(0);\n  for(i=0;i<n;i++){\n    //cout<<dp1[i]<<\" \"<<dp2[i]<<endl;\n  }\n\tfor(i=0;i<n;i++) cout<<fixed<<setprecision(12)<<ans[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 5;\n\nvector<int> G[maxn];\nint deg[maxn];\n\ndouble ans = 0;\n\nvoid dfs(int u, int fa, double p) {\n    for (int v : G[u]) if (v != fa) {\n        ans += p;\n//        if (deg[v] == 1) return;\n        double x = deg[v] - 1;\n        dfs(v, u, p / x);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        deg[u] ++, deg[v] ++;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; i ++) {\n        ans = 0;\n        dfs(i, -1, 1.0 / deg[i]);\n        printf(\"%.6f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[150000];\nvector<double> dp[150000];\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  for (int i=0; i<G[x].size(); i++) {\n    if (i == p) continue;\n    int t = G[x][i];\n    r += dfs(t, find(all(G[t]), x)-G[t].begin())/c;\n  }\n  return dp[x][p] = r+1;\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) {\n    dp[i].resize(G[i].size()+1, -1);\n  }\n  rep(i, N) {\n    cout << fixed << setprecision(15) << dfs(i, G[i].size()) << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\ndouble ans[MAX_N];\nint eda[MAX_N];\n\nvoid dfs(int u,int p)\n{\n    int cnt = 0;\n    double res = 0;\n    if((int)G[u].size() == 1 && G[u][0] == p){\n        dp[u] = 0;\n        return;\n    }\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            cnt++;\n            dfs(G[u][i],u);\n            res += dp[G[u][i]];\n        }\n    }\n    eda[u] = cnt;\n    dp[u] = res/cnt + 1;\n}\n\nvoid dfs2(int u,int p)\n{\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            if(u == 0){\n                if(eda[u] == 1){\n                    dp2[G[u][i]] = 1;\n                }else{\n                    dp2[G[u][i]] = (dp[u]*eda[u]-(1+dp[G[u][i]]))/(eda[u]-1) + 1;\n                }\n            }else{\n                dp2[G[u][i]] = dp2[u]/eda[u] + dp[u]-(1+dp[G[u][i]])/eda[u] + 1;\n            }\n            ans[G[u][i]] = dp2[G[u][i]]/(eda[G[u][i]]+1) + dp[G[u][i]]*eda[G[u][i]]/(eda[G[u][i]]+1);\n            dfs2(G[u][i],u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0,-1);\n    ans[0] = dp[0];\n    dp2[0] = 0;\n    dfs2(0,-1);\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << endl;\n    // }\n    rep(i,n){\n        printf(\"%.12lf\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\ntypedef tuple<int, double> pass;\n\nint N;\nvector<pass> V[150010];\n\ndouble solve(int root, int from) {\n  int cnt = 0;\n  for (auto x : V[root]) {\n    if (get<0>(x) != from) ++cnt;\n  }\n  if (cnt == 0) return 0;\n  double ans = 0;\n  for (auto x : V[root]) {\n    if (get<0>(x) == from) continue;\n    if (get<1>(x) < 0) {\n      get<1>(x) = solve(get<0>(x), root) + 1;\n    }\n    ans += get<1>(x);\n  }\n  ans /= cnt;\n  return ans;\n}\n\nint main () {\n  cin >> N;\n  for (auto i = 0; i < N-1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    V[u].push_back(pass(v, -1));\n    V[v].push_back(pass(u, -1));\n  }\n  for (auto i = 0; i < N; ++i) {\n    cout << fixed << setprecision(12) << solve(i, -1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define FOR(i,n,m) for(int i=(n);i<(m);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REPR(i,n) for(int i=(n);i>=0;i--)\n#define all(vec) vec.begin(),vec.end()\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing P=pair<ll,ll>;\nusing PP=pair<ll,P>;\nusing vp=vector<P>;\nusing vpp=vector<PP>;\nusing vs=vector<string>;\n#define fi first\n#define se second\n#define pb push_back\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(a>b){a=b;return true;}return false;}\ntemplate<typename A,typename B>istream&operator>>(istream&is,pair<A,B> &p){is>>p.fi>>p.se;return is;}\ntemplate<typename A,typename B>ostream&operator<<(ostream&os,const pair<A,B> &p){os<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return os;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T> &t){REP(i,t.size())is>>t[i];return is;}\ntemplate<typename T>ostream&operator<<(ostream&os,const vector<T>&t){os<<\"{\";REP(i,t.size()){if(i)os<<\",\";os<<t[i];}cout<<\"}\";return os;}\nconst ll MOD=1000000007LL;\nconst int INF=1<<30;\nconst ll LINF=1LL<<60;\nint n;\nvector<vector<int>> G;\nvector<double> dp;\ndouble dfs(int x,int parent){\n    double res=0;\n    int cnt=0;\n    for(int i=0;i<G[x].size();i++){\n        if(G[x][i]!=parent){\n            res+=dfs(G[x][i],x)+1;\n            cnt++;\n        }\n    }\n    if(!cnt){\n        return 0;\n    }\n    return dp[x]=res/cnt;\n}\nvector<double> dp2;\ndouble dfs2(int x,int parent){\n    if(parent==-1){\n        dp2[x]=dp[x];\n    }else{\n        int d=G[x].size();\n        double dif;\n        if(G[parent].size()==1){\n            dif=1;\n        }else{\n            dif=(dp2[parent]*G[parent].size()-(dp[x]+1))/(G[parent].size()-1)+1;\n        }\n        dp2[x]=(dp[x]*(d-1)+dif)/d;\n    }\n    for(int i=0;i<G[x].size();i++){\n        if(G[x][i]!=parent){\n            dfs2(G[x][i],x);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    G.resize(n);\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    dp.resize(n);\n    dp2.resize(n);\n    dfs(0,-1);\n    dfs2(0,-1);\n    for(int i=0;i<n;i++){\n        printf(\"%.10f\\n\",dp2[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\ndouble ans[MAX_N];\nint eda[MAX_N];\n\nvoid dfs(int u,int p)\n{\n    int cnt = 0;\n    double res = 0;\n    if((int)G[u].size() == 1 && G[u][0] == p){\n        dp[u] = 0;\n        return;\n    }\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            cnt++;\n            dfs(G[u][i],u);\n            res += dp[G[u][i]];\n        }\n    }\n    eda[u] = cnt;\n    dp[u] = res/cnt + 1;\n}\n\nvoid dfs2(int u,int p)\n{\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            if(u == 0){\n                if(eda[u] == 1){\n                    dp2[G[u][i]] = 1;\n                }else{\n                    dp2[G[u][i]] = (dp[u]*eda[u]-(1+dp[G[u][i]]))/(eda[u]-1) + 1;\n                }\n            }else{\n                dp2[G[u][i]] = dp2[u]/eda[u] + dp[u]-(1+dp[G[u][i]])/eda[u] + 1;\n            }\n            ans[G[u][i]] = dp2[G[u][i]]/(eda[G[u][i]]+1) + dp[G[u][i]]*eda[G[u][i]]/(eda[G[u][i]]+1);\n            dfs2(G[u][i],u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0,-1);\n    ans[0] = dp[0];\n    dp2[0] = 0;\n    dfs2(0,-1);\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << endl;\n    // }\n    rep(i,n){\n        printf(\"%.12lf\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nVI e[15000];\ndouble p1[15000], ans[15000];\n\ndouble dfs(int now, int past){\n    double res = 0.0;\n    double p = 1.0/e[now].size();\n    if (past != -1) p = 1.0/(e[now].size()-1);\n    for (auto next : e[now]){\n        if (next == past) continue;\n        double a = dfs(next,now);\n        res += p * (1 + a);\n        ans[now] += 1.0/e[now].size() * (1 + a);\n    }\n    return p1[now] = res;\n}\n\ndouble dfs2(int now, int past, double pp){\n    int n = e[now].size();\n    pp /= n;\n    ans[now] += pp;\n    if (n == 1){\n        if (e[now][0] != past) dfs2(e[now][0], now, 1.0);\n        return 0;\n    }\n    for (auto next : e[now]){\n        if (next == past) continue;\n        dfs2(next, now, (ans[now] - (p1[next]+1)/n)*n/(n-1.0) + 1);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    REP(i,n-1){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--;\n        v--;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0,-1,0.0);\n    REP(i,n){\n        printf(\"%.10f\\n\", ans[i]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://s8pc-4.contest.atcoder.jp/tasks/s8pc_4_d\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 150000;\n\nint n,deg[maxn];\ndouble F[maxn],G[maxn];\nvector<int> adj[maxn];\n\nvoid visit(int u,int pa) {\n    int son = deg[u] - ((pa!=-1)?1:0);\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            visit(v,u);\n            F[u] = F[u] + 1.0*(F[v]+1)/son;\n        }\n    }\n}\n\nvoid visit2(int u,int pa) {\n    int p = deg[u];\n    for (int j=0;j<adj[u].size();j++) {\n        int v=adj[u][j];\n        if (v!=pa) {\n            if (pa==-1) {\n                if (p==1) G[v]=1;\n                else G[v] = ((F[u]+1)*p - (F[v]+2))/(p-1);\n            }\n            else G[v] = (G[u]+1)/(p-1) + (F[u]+1) - (F[v]+2)/(p-1);\n            visit2(v,u);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n //   freopen(\"in.txt\",\"r\",stdin);\n    cin>>n;\n    for (int i=1;i<n;i++) {\n        int u,v;\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        deg[u]++; deg[v]++;\n    }\n    visit(1,-1);\n    visit2(1,-1);\n    printf(\"%.8f\\n\", F[1]);\n    for (int i=2;i<=n;i++) printf(\"%.8f\\n\",(F[i]*(deg[i]-1) + G[i])*1.0 / deg[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n\nvector<int> G[1<<18];\ndouble dp [1<<18];\ndouble dp2 [1<<18];\n\ndouble dfs(int u,int p) {\n    int cnt = 0;\n    double ans = 0;\n    for(int i = 0; i < G[u].size(); i ++) {\n        if (G[u][i] == p) continue;\n        ans += dfs(G[u][i], u) + 1;\n        cnt ++;\n    }\n    return dp[u] = cnt ? ans / cnt : 1;\n}\n\nvoid dfs2(int u, int p, double a) {\n    double ans=0;\n    for(int i=0;i<G[u].size();i++)\n    {\n        if(G[u][i]==p)ans+=a;\n        else ans+=dp[G[u][i]];\n    }\n    dp2[u] = ans/G[u].size();\n    for(int i=0;i<G[u].size();i++)\n    {\n        if(G[u][i]==p)continue;\n        dfs2(G[u][i],u, 1+(ans-dp[G[u][i]])/max(1,(int)G[u].size()-1));\n    }\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    int u,v;\n    for(int i = 1; i < n; i ++) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    dfs2(1, 0, 0);\n    for(int i = 1; i <= n; i ++) {\n        cout << dp2[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=150000;\nconst int MAXM=MAXN-1;\n\nint n;\nint ghead[MAXN],gnxt[2*MAXM],gto[2*MAXM];\n\ndouble Edown[MAXN];\ndouble Enotto[MAXN];\ndouble E[MAXN];\n\nvoid dfs1(int at,int par) {\n\tEdown[at]=0; int cnt=0;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tdfs1(to,at);\n\t\tEdown[at]+=1+Edown[to];\n\t\t++cnt;\n\t}\n\tif(cnt!=0) Edown[at]/=cnt;\n}\n\nvoid dfs2(int at,int par) {\n\tdouble sum=0; int cnt=0;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tsum+=1+Edown[to],++cnt;\n\t}\n\tif(par!=-1) sum+=1+Enotto[at],++cnt;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tEnotto[to]=cnt==1?0:(sum-(1+Edown[to]))/(cnt-1);\n\t\tdfs2(to,at);\n\t}\n\tE[at]=cnt==0?0:sum/cnt;\n}\n\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) ghead[i]=-1;\n\tREP(i,n-1) {\n\t\tint a,b; scanf(\"%d%d\",&a,&b); --a,--b;\n\t\tgnxt[2*i+0]=ghead[a],ghead[a]=2*i+0,gto[2*i+0]=b;\n\t\tgnxt[2*i+1]=ghead[b],ghead[b]=2*i+1,gto[2*i+1]=a;\n\t}\n\tdfs1(0,-1);\n\tdfs2(0,-1);\n\tREP(i,n) printf(\"%.9lf\\n\",E[i]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\ntemplate <typename T>\nstruct edge {\n    int to, id;\n    T cost;\n    edge(int to) : to(to), id(-1), cost(1) {}\n    edge(int to, T cost) : to(to), id(-1), cost(cost) {}\n    edge(int to, T cost, int id) : to(to), id(id), cost(cost) {}\n    operator int() const { return to; }\n    /*\n        edge& operator=(const int& x) {\n            to = x;\n            return *this;\n        }\n        */\n};\ntemplate <typename T>\nclass Graph : public vector<vector<edge<T>>> {\n    //--------Basic--------\nprivate:\n    using Edge = edge<T>;\n    int M;  //M:辺の数\n    bool undirected = false;\n    bool directed = false;\n    bool unweighted = false;\n    bool weighted = false;\n    bool tree = false;\n    //\npublic:\n    //\npublic:\n    Graph() = default;\n    //unweighted\n    void add_edge_undirected(int u, int v, int id = -1) {\n        assert(!directed);\n        assert(!weighted);\n        undirected = true;\n        unweighted = true;\n        (*this)[u].emplace_back(Edge{v, 1, id});\n        (*this)[v].emplace_back(Edge{u, 1, id});\n    }\n    void build_undirected(int m) {\n        assert(!(*this).empty());\n        assert(!directed);\n        assert(!weighted);\n        undirected = true;\n        unweighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            cin >> u >> v;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, 1, i});\n            (*this)[v].emplace_back(Edge{u, 1, i});\n        }\n    }\n    void build_undirected(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    void add_edge_directed(int u, int v, int id = -1) {\n        assert(!undirected);\n        assert(!weighted);\n        directed = true;\n        unweighted = true;\n        (*this)[u].emplace_back(Edge{v, 1, id});\n    }\n    void build_directed(int m) {\n        assert(!(*this).empty());\n        assert(!undirected);\n        assert(!weighted);\n        directed = true;\n        unweighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            cin >> u >> v;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, 1, i});\n        }\n    }\n    void build_directed(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    //weighed\n    void add_edge_undirected_weighed(int u, int v, T cost, int id = -1) {\n        assert(!directed);\n        assert(!unweighted);\n        undirected = true;\n        weighted = true;\n        (*this)[u].emplace_back(Edge{v, cost, id});\n        (*this)[v].emplace_back(Edge{u, cost, id});\n    }\n    void build_undirected_weighted(int m) {\n        assert(!(*this).empty());\n        assert(!directed);\n        assert(!unweighted);\n        undirected = true;\n        weighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            T cost;\n            cin >> u >> v >> cost;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, cost, i});\n            (*this)[v].emplace_back(Edge{u, cost, i});\n        }\n    }\n    void build_undirected_weighted(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    void add_edge_directed_weighted(int u, int v, T cost, int id = -1) {\n        assert(!undirected);\n        assert(!unweighted);\n        directed = true;\n        weighted = true;\n        (*this)[u].emplace_back(Edge{v, cost, id});\n    }\n    void build_directed_weighted(int m) {\n        assert(!(*this).empty());\n        assert(!undirected);\n        assert(!unweighted);\n        directed = true;\n        weighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            T cost;\n            cin >> u >> v >> cost;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, cost, i});\n        }\n    }\n    void build_directed_weighted(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    //tree\n    void istree() {\n        tree = true;\n    }\n    void build_tree(int n) {\n        istree();\n        build_undirected(n, n - 1);\n    }\n    void build_tree_weighted(int n) {\n        istree();\n        build_undirected_weighted(n, n - 1);\n    }\n    //print state\n    void state() {\n        cerr << endl\n             << \"Print State\" << endl\n             << \"Edge :\" << endl\n             << \"    Directed   : \" << (directed ? \"Yes\" : \"No\") << endl\n             << \"    Undirected : \" << (undirected ? \"Yes\" : \"No\") << endl\n             << \"    Weighted   : \" << (weighted ? \"Yes\" : \"No\") << endl\n             << \"    Unweighted : \" << (unweighted ? \"Yes\" : \"No\") << endl\n             << \"    Tree       : \" << (tree ? \"Yes\" : \"No\") << endl\n             << \"Usable Functions : Graph\" << endl\n             << \"    StronglyConnectedComponent(unverified): \" << (StronglyConnectedComponent_ready ? \"Yes\" : \"No\") << endl\n             << \"Usable Funcitons : Tree\" << endl\n             << \"    ReRooting(verified) : Yes\" << endl;\n    }\n    //\n    //\n    //\n    //--------StronglyConnectedComponent--------\n    //Unverified\npublic:\n    vector<vector<int>> SCC_R, SCC_T;\n    //\nprivate:\n    bool StronglyConnectedComponent_ready = false;\n    vector<int> SCC_cmp, SCC_ord;\n    vector<bool> SCC_used;\n    //\npublic:\n    int SCC_build() {\n        cerr << \"Please Verify\" << endl;\n        assert(!undirected);\n        assert(directed);\n        int N = (*this).size();\n        SCC_R.resize(N);\n        for (int i = 0; i < N; i++) {\n            for (int& x : (*this)[i]) {\n                SCC_R[x].emplace_back(i);\n            }\n        }\n        SCC_cmp.resize(N);\n        fill(SCC_cmp.begin(), SCC_cmp.end(), -1);\n        SCC_used.resize(N);\n        fill(SCC_used.begin(), SCC_used.end(), false);\n        StronglyConnectedComponent_ready = true;\n        return build_StronglyConnectedComponent_init();\n    }\n    int SCC(int k) {\n        assert(StronglyConnectedComponent_ready);\n        return SCC_cmp[k];\n    }\n    //\nprivate:\n    void dfs(int now) {\n        if (SCC_used[now])\n            return;\n        SCC_used[now] = true;\n        for (auto nxt : (*this)[now])\n            dfs(nxt);\n        SCC_ord.emplace_back(now);\n    }\n    void rdfs(int now, int count) {\n        if (SCC_cmp[now] != -1)\n            return;\n        SCC_cmp[now] = count;\n        for (auto to : SCC_R[now])\n            rdfs(to, count);\n    }\n    int build_StronglyConnectedComponent_init() {\n        int n = (int)(*this).size();\n        for (int i = 0; i < n; i++)\n            dfs(i);\n        reverse(SCC_ord.begin(), SCC_ord.end());\n        int group = 0;\n        for (auto& i : SCC_ord) {\n            if (SCC_cmp[i] == -1) {\n                rdfs(i, group);\n                group++;\n            }\n        }\n        SCC_T.resize(group);\n        for (int i = 0; i < n; i++) {\n            for (auto& to : (*this)[i]) {\n                int s = SCC_cmp[i], t = SCC_cmp[to];\n                if (s != t)\n                    SCC_T[s].emplace_back(t);\n            }\n        }\n        return group;\n    }\n    //\n    //\n    //\n    //--------TopologicalSort--------\n    //未実装\n    //\n    //\n    //\n    //--------Tree--------\n    //\n    //\n    //--------ReRooting--------\npublic:\n    template <typename sum_t>\n    pair<vector<sum_t>, vector<vector<sum_t>>> Tbuild_ReRooting(\n        const function<sum_t(sum_t, sum_t)> f,\n        const function<sum_t(sum_t, Edge)> gg,\n        sum_t ident) {\n        assert(tree);\n        int N = (*this).size();\n        vector<sum_t> subdp(N, ident), dp(N, ident);\n        vector<vector<sum_t>> g_dp(N), g_ndp(N), memo(N);\n        vector<vector<bool>> seen(N);\n        for (int i = 0; i < N; i++) {\n            int S = (*this)[i].size();\n            g_dp[i].resize(S, ident);\n            g_ndp[i].resize(S, ident);\n            memo[i].resize(S);\n            seen[i].resize(S, false);\n        }\n        stack<int> stk;\n        stk.push(0);\n        vector<int> par(N), ord(N);\n        int index = 0;\n        par[0] = -1;\n        while (!stk.empty()) {\n            int node = stk.top();\n            stk.pop();\n            ord[index++] = node;\n            for (auto& e : (*this)[node]) {\n                if (e.to == par[node])\n                    continue;\n                stk.push(e.to);\n                par[e.to] = node;\n            }\n        }\n        for (int k = ord.size() - 1; k >= 0; k--) {\n            int idx = ord[k];\n            for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n                auto& e = (*this)[idx][i];\n                if (e.to == par[idx])\n                    continue;\n                if (!seen[idx][i]) {\n                    memo[idx][i] = gg(subdp[e.to], e);\n                    seen[idx][i] = true;\n                }\n                subdp[idx] = f(subdp[idx], memo[idx][i]);\n            }\n        }\n        vector<sum_t> top(N, ident);\n        for (int k = 0; k < (int)(ord.size()); k++) {\n            int idx = ord[k];\n            sum_t buff{ident};\n            for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n                auto& e = (*this)[idx][i];\n                g_ndp[idx][i] = buff;\n                if (!seen[idx][i]) {\n                    memo[idx][i] = gg(par[idx] == e.to ? top[idx] : subdp[e.to], e);\n                    seen[idx][i] = true;\n                }\n                g_dp[idx][i] = memo[idx][i];\n                buff = f(buff, g_dp[idx][i]);\n            }\n            dp[idx] = buff;\n            buff = ident;\n            for (int i = (*this)[idx].size() - 1; i >= 0; i--) {\n                auto& e = (*this)[idx][i];\n                if (e.to != par[idx])\n                    top[e.to] = f(g_ndp[idx][i], buff);\n                g_ndp[idx][i] = f(g_ndp[idx][i], buff);\n                buff = f(buff, g_dp[idx][i]);\n            }\n        }\n        return make_pair(dp, memo);\n    }\n};\n//グローバルでの使用のみ想定\n\n\nint N;\n\nstruct node {\n    double exp;\n    int num;\n};\n\nGraph<int> G;\n\nvoid solve() {\n    auto f1 = [](node a, node b) {\n        if (a.num + b.num == 0) {\n            return node{0, 0};\n        } else {\n            return node{(a.exp * a.num + b.exp * b.num) / (a.num + b.num), a.num + b.num};\n        };\n    };\n    auto f2 = [](node a, edge<int> x) {\n        return node{a.exp + 1.0, 1};\n    };\n    for (auto& a : G.Tbuild_ReRooting<node>(f1, f2, node{0, 0}).first) {\n        cout << a.exp << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n\n    cin >> N;\n    G.build_tree(N);\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nvector<vector<int>> g;\n\nvector<double> e;\nvector<double> ans;\nvoid dfs1(int v, int p = -1){\n\tdouble res = 0;\n\tint ch = 0;\n\tfor(auto nv : g[v]){\n\t\tif(nv == p)continue;\n\t\tdfs1(nv, v);\n\t\tres += e[nv] + 1.0;\n\t\t++ch;\n\t}\n\te[v] = 0;\n\tif(ch >= 1)e[v] += res / ch;\n}\n\nvoid dfs2(int v, int p = -1, double d_par = 0){\n\tdouble res = 0;\n\tfor(auto nv : g[v]){\n\t\tif(nv == p)res += d_par + 1.0;\n\t\telse res += e[nv] + 1.0;\n\t}\n\tans[v] = res / g[v].size();\n\tfor(auto nv : g[v]){\n\t\tif(nv == p)continue;\n\t\tdfs2(nv, v, (res - e[nv] - 1.0) / max(1, (int)g[v].size() - 1));\n\t}\n}\n\nint main(){\n  int n;\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; ++i){\n  \tint u, v;\n  \tcin >> u >> v;\n  \t--u;\n  \t--v;\n  \tg[u].push_back(v);\n  \tg[v].push_back(u);\n  }\n\n  e.assign(n, 0);\n  ans.assign(n, 0);\n  dfs1(0);\n  dfs2(0);\n  for(int i = 0; i < n; ++i)printf(\"%.12f\\n\", ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, double>dp[150000];\n\ndouble dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tdouble ans = 0;\n\tint cnt = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12lf\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=double;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nconst int limit=150010;\nusing edge=struct{int to,rev;};\nvector<edge> graph[limit];\nvector<R> dp[limit];\n\nvoid add_edge(int from,int to){ \n\tgraph[from].push_back({to,int(graph[to].size())});\n\tgraph[to].push_back({from,int(graph[from].size())-1});\n\tdp[from].push_back(-1.0);\n\tdp[to].push_back(-1.0);\n}\n\n\n\nR dfs(int v,int i){\n\tif(i==-1){\n\t\tR ret=0.0;\n\t\tconst int m=graph[v].size();\n\t\trep(j,m){\n\t\t\tconst int nv=graph[v][j].to;\n\t\t\tconst int ni=graph[v][j].rev;\n\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t}\n\t\tret/=m;\n\t\treturn ret;\n\t}else{\n\t\tR &ret=dp[v][i];\n\t\tif(ret>=0.0) return ret;\n\t\tret=0.0; \n\t\tconst int m=int(graph[v].size());\n\t\trep(j,m){\n\t\t\tif(j==i) continue;\n\t\t\tconst int nv=graph[v][j].to;\n\t\t\tconst int ni=graph[v][j].rev;\n\t\t\tret+=dfs(nv,ni)+1.0;\n\t\t}\n\t\tif(m!=1) ret/=(m-1);\n\t\treturn ret;\n\t}\n}\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\trep(i,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\n\trep(i,n) printf(\"%.20lf\\n\",dfs(i,-1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\n#define double float\nusing namespace std;\n\nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, unordered_map<int, double>>U;//頂点IからJに進むときの進む距離の平均\ndouble saiki(int i, int j) {\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tdouble K = 1;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<int> G[150000];\nmap<P,double> dp;\n\ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return dp[P(prev,now)] = 0.0;\n\tif(dp.find(P(prev,now)) != dp.end()) return dp[P(prev,now)];\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n\nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef pair<double, long long> pdl;\n\nconst long double pi = 3.141592653589793;\n\n#define debug(x) cout << #x << \" = \" << (x) << endl;\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n\nint n, x, y;\nvector<int> g[1<<20];\nvector<long double> A(1<<20);\nvector<long double> B(1<<20);\n\nlong double dfs(int s, int p) {\n\tif(g[s].size() == 1 and g[s][0] == p) {\n\t\treturn 1;\n\t}\n\n\tlong double sum = 0;\n\tfor(auto &x : g[s]) {\n\t\tif(x == p) continue;\n\t\tsum += dfs(x, s);\n\t}\n\n\tA[s] = sum;\n\tif(p == -1) return sum/(g[s].size());\n\treturn 1 + sum/(g[s].size()-1);\n}\n\nvoid modify(int s, int p) {\n\tif(p != -1 and g[s].size() == 1 and g[p].size() == 1) {\n\t\tA[s] = 1;\n\t\treturn;\n\t}\n\n\tif(p != -1 and g[s].size() != 1 and g[p].size() == 1) {\n\t\tA[s] += 1;\n\t}\n\n\tif(p != -1 and g[s].size() == 1 and g[p].size() != 1) {\n\t\tA[s] += 1+(A[p]-1)/(g[p].size()-1);\n\t\treturn;\n\t}\n\n\tif(p != -1 and g[s].size() != 1 and g[p].size() != 1) {\n\t\tA[s] += 1+(A[p]-(A[s]/(g[s].size()-1))-1)/(g[p].size()-1);\n\t}\n\n\tfor(auto &x : g[s]) {\n\t\tif(x == p) continue;\n\t\tmodify(x, s);\n\t}\n}\n\nint main() {\n  \t//freopen(\"input.in\",\"r\",stdin);\n  \t//freopen(\"output.out\",\"w\",stdout);\n\tcin>>n;\n\trep(i, n-1) {\n\t\tcin>>x>>y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\n\tif(n == 1) {\n\t\tcout<<\"0\"<<endl; return 0;\n\t}\n\n\tdfs(1, -1);\n\tmodify(1, -1);\n\trep(i, n) printf(\"%.12Lf\\n\", A[i+1]/g[i+1].size());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\nconst int inf = 1e9 + 7;\nconst ll INF = 1e18;\n#define abs(x) (x >= 0 ? x : -(x))\n#define lb(v, x) (int)(lower_bound(all(v), x) - v.begin())\n#define ub(v, x) (int)(upper_bound(all(v), x) - v.begin())\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\nconst int mod = 1000000007;\nll modpow(ll a, int b) { return b ? modpow(a * a % mod, b / 2) * (b % 2 ? a : 1) % mod : 1; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& vec) { for (auto &vi: vec) os << vi << \" \"; return os; }\ntemplate<class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << p.F << \" \" << p.S; return os; }\ntemplate<class T> inline void add(T &a, int b) { a += b; if (a >= mod) a -= mod; }\n\n\n\nvoid solve();\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout << fixed << setprecision(10);\n\n    int T;\n    // cin >> T;\n    T = 1;\n\n    while (T--) {\n        solve();\n    }\n}\n\n\n// https://ei1333.hateblo.jp/entry/2017/04/10/224413\n// ある頂点を根としたものを構成\n// すべての頂点を根としたものを構成\nstruct edge { int to, cost; };\nint n;\nconst int maxn = 150005;\nvector<edge> G[maxn];\ndouble E[maxn];\nvector<double> ans(maxn);\n\nvoid dfs(int v, int p) {\n  double E2 = 0;\n  int cnt = 0;\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    dfs(e.to, v);\n    // dfs から上がってきたタイミングで\n    E2 += E[e.to] + 1;\n    cnt++;\n  }\n  if (cnt) E[v] = E2 / cnt;\n}\n\n// v を根とする答え\nvoid dfs2(int v, double Epar, int p) {\n  double ret = 0;\n  for (edge& e : G[v]) {\n    // 親との距離と, 親方向の部分木で一番遠い頂点との距離の和\n    if (e.to == p) ret += Epar + e.cost;\n    // 部分木の, ある頂点 j への距離と, j と j の部分木内での一番遠い頂点との距離の和\n    else ret += e.cost + E[e.to], e.to;\n  }\n  ans[v] = ret / sz(G[v]);\n\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    dfs2(e.to, sz(G[v]) == 1 ? 0 : (ret - (E[e.to] + 1)) / (sz(G[v]) - 1), v);\n    // sz(G[v]) == 1, 葉\n    // 0 = 0/1\n\n  }\n}\n\nvoid solve() {\n  cin >> n;\n  rep(i, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--; // debuged\n    G[a].eb(edge{b, 1});\n    G[b].eb(edge{a, 1});\n  }\n  dfs(0, -1);\n  // rep(i, n) cout << E[i] << \" \"; cout << endl;\n  dfs2(0, 0, -1);\n  rep(i, n) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <time.h>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w = 1) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed = 0) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tcon(a - oindexed, b - oindexed);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//無向\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nsigned main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBiDGraph g(n);\n\tg.scan(n-1,1);\n\n\tvector<double> per(n);\n\n\tfunction<double(int, int)> dfs = [&](int cur, int p) {\n\t\tdouble ret = 0;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\n\t\t\tret += (1+dfs(itr.first, cur))/(double)(g.g[cur].size()-(bool)(p+1));\n\n\t\t}\n\t\treturn per[cur] = ret;\n\t};\n\n\tdfs(0,-1);\n\tvector<double> ans(n);\n\tfunction<void(int, int, double)> dfs2 = [&](int cur, int p, double par) {\n\t\tdouble np = par;\n\t\tdouble sum = np;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t\tans[cur] = sum / g.g[cur].size();\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum -= per[itr.first]+1;\n\t\t\tdfs2(itr.first, cur, 1+ (p != -1 ? (sum) / (g.g[cur].size() - 1) : 0));\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t};\n\tdfs2(0, -1, 0);\n\tans[0] = per[0];\n\tREP(i, n)\n\t\tprintf(\"%lf\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst double pi = acos(-1.0);\nconst double EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nstruct Graph{\n    vector<vector<int>> es;\n    vector<double> ex, up, ans;\n    vector<int> cnt;\n    const int n;\n\n    Graph(int n) : n(n){\n        es.resize(n);\n        ex.resize(n), up.resize(n), ans.resize(n), cnt.resize(n);\n    }\n\n    void add_edge(int from, int to, bool directed = false){\n        es[from].pb(to);\n        if(!directed) es[to].pb(from);\n    }\n\n    double dfs1(int now, int pre){\n        ex[now] = 0.0, cnt[now] = 0;\n        for(auto &e: es[now]){\n            if(e == pre) continue;\n            cnt[now]++;\n            ex[now] += dfs1(e, now);\n        }\n        if(cnt[now] == 0) return ex[now];\n        return ex[now] = 1.0+ex[now]/cnt[now];\n    }\n\n    void dfs2(int now, int pre){\n        for(auto &e: es[now]){\n            if(e == pre) continue;\n            if(pre == -1){\n                if(cnt[now] == 1) up[e] = 0.0;\n                else up[e] = 1.0+((ex[now]-1.0)*cnt[now]-ex[e])/(cnt[now]-1);\n            }\n            else{\n                up[e] = 1.0+((ex[now]-1.0)*cnt[now]-ex[e]+up[now])/cnt[now];\n            }\n            dfs2(e, now);\n        }\n    }\n\n    void solve(int root = 0){\n        dfs1(root, -1), dfs2(root, -1);\n        rep(i, n){\n            if(i == root) ans[i] = ex[i];\n            else ans[i] = 1.0+((ex[i]-1.0)*cnt[i]+up[i])/(cnt[i]+1);\n        }\n        rep(i, n) cout << sp(10) << ans[i] << endl;\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    Graph G(N);\n    rep(i, N-1){\n        int u, v; cin >> u >> v; u--, v--;\n        G.add_edge(u, v);\n    }\n    G.solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ndouble memo[100010];\ndouble ans[100010];\nvector<int> G[100010];\n\nvoid dfs(int idx, int par) {\n    int sz = G[idx].size();\n    for(auto &to : G[idx]) {\n        if(to == par) {\n            sz--; continue;\n        }\n        dfs(to, idx);\n        memo[idx] += memo[to] + 1.0;\n    }\n    if(sz) memo[idx] /= sz;\n}\n\nvoid dfs2(int idx, double d_par, int par) {\n    double sum = 0.0;\n    int sz = G[idx].size();\n    for(auto &to : G[idx]) {\n        if(to == par) sum += d_par + 1.0;\n        else sum += memo[to] + 1.0;\n    }\n    // printf(\"idx = %lld, d_par = %.12lf, par = %lld, sum = %.12lf\\n\", idx, d_par, par, sum);\n    ans[idx] = (sz > 0 ? sum / sz : 0.0);\n    for(auto &to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, sz > 1 ? (sum - memo[to] - 1.0) / (sz - 1) : 0.0, idx);\n    }\n}\n\nsigned main() {\n    int n; cin >> n;\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, 0.0, -1);\n    rep(i,0,n) printf(\"%.12f\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nvector<vint> graph;\nvint id;\n\npint dfs(int u, int p, int k) {\n  if(~k) id[u] = k++;\n  pint res = pint(0, u);\n  for(int v : graph[u]) {\n    if(v == p) continue;\n    pint dist = dfs(v, u, k);\n    dist.first++;\n    chmax(res, dist);\n  }\n  return res;\n}\n\nint dfs2() {\n  pint p = dfs(0, -1, -1);\n  pint q = dfs(p.second, -1, 0);\n  return q.first;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  graph.resize(N);\n  rep(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  id.resize(N);\n  dfs2();\n  rep(i, N) {\n    if(id[i] == 0 || id[i] == N-1) {\n      cout << N-1.0 << endl;\n    } else {\n      cout << (id[i]+N-id[i]-1)/2.0 << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nmap< pair<int,int>,double > memo;\nvector<int> edge [150001];\n\ndouble rec(int prev,int curr)\n{\n\tif(memo.count(make_pair(prev,curr))) return memo [make_pair(prev,curr)];\n\tdouble res = 0.0;\n\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\tres += rec(curr,it) + 1.0;\n\t}\n\tif(edge [curr].size() > 1){\n\t\tres /= edge [curr].size() - 1;\n\t}\n\treturn memo [make_pair(prev,curr)] = res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tFOR(i,1,N + 1){\n\t\tdouble ans = 0.0;\n\t\tfor(const auto& it : edge [i]){\n\t\t\tans += rec(i,it) + 1.0;\n\t\t}\n\t\tans /= edge [i].size();\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n;\n  R n;\n  vector<int> v[n];\n  rep(i,n-1) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    v[x].pb(y);\n    v[y].pb(x);\n  }\n  rep(i,n) {\n    int d[n];\n    fill(d,d+n,MAX);\n    double p[n];\n    mem(p);\n    d[i]=0;\n    p[i]=1;\n    queue<int> que;\n    que.push(i);\n    double ans=0;\n    while(!que.empty()) {\n      int x=que.front();que.pop();\n      bool f=1;\n      rep(j,v[x].size()) {\n        int y=v[x][j];\n        if(d[y]<=d[x]+1) continue;\n        f=0;\n        d[y]=d[x]+1;\n        p[y]+=p[x]/(v[x].size()-(x==i?0:1));\n        que.push(y);\n      }\n      if(f) ans+=d[x]*p[x];\n    }\n    pd(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nmap< pair<int, int>, double > M;\nvector<int> V[150005];\n\ndouble f(int x, int p) {\n\tif (M.find(make_pair(x, p)) != M.end()) return M[make_pair(x, p)];\n\tdouble ans = 0;\n\tfor (int i = 0; i < V[x].size(); i++) {\n\t\tif (V[x][i] == p) continue;\n\t\tans += f(V[x][i], x) / (V[x].size() - 1);\n\t}\n\treturn M[make_pair(x, p)] = ans + 1;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j < V[i].size(); j++) ans += f(V[i][j], i) / V[i].size();\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> v(n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    \n    double ans;\n    for (int i = 0; i < n; i++) {\n        if (v[i].size() == 1) {\n            ans = (double)(n - 1);\n        } else {\n            ans = (double)(n - 1) / 2.0;\n        }\n        printf(\"%f\\n\", ans);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n\nusing namespace std;\n\n\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing edge_t=pair<int,double>;\nusing vve=vector<vector<edge_t> >;\n\n\nvve v;\n\n\ndouble solve_r(int cur, int prev)\n{\n\tdouble ret;\n\tint n;\n\n\tn=v[cur].size();\n\tif(prev>=0) n--;\n\tif(n==0)\n\t{\n\t\treturn 0.0;\n\t}\n\n\tret=0.0;\n\tfor(auto& e: v[cur])\n\t{\n\t\tif(e.first==prev) continue;\n\t\tif(e.second<0)\n\t\t{\n\t\t\te.second=solve_r(e.first, cur);\n\t\t}\n\t\tret+=e.second+1;\n\t}\n\treturn ret/n;\n}\n\n\nvoid solve(vector<double>& r)\n{\n\tfor(int i=1;i<v.size();i++)\n\t{\n\t\tr[i]=solve_r(i, -1);\n\t}\n}\n\n\nint main(void)\n{\n\tvector<double> r;\n\tint n, a, b;\n\n\twhile(scanf(\"%d\", &n)==1)\n\t{\n\t\tv.clear();\n\t\tv.resize(n+1);\n\t\tr.resize(n+1);\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tv[a].push_back(make_pair(b, -1.0));\n\t\t\tv[b].push_back(make_pair(a, -1.0));\n\t\t}\n\t\tsolve(r);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tprintf(\"%f\\n\", r[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nint n;\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) if (g[u][i].second != gnum - n && g[u][i].second != gnum + n) {\n\t\tcnt++;\n\t\tres += dfs(g[u][i].first, g[u][i].second);\n\t}\n\t\n\tif (cnt == 0) return dp[gnum] = 0.0;\n\treturn dp[gnum] = (res + cnt) / cnt;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second);\n\t\t\n\t\tif (g[i].size() == 0) ans = 0;\n\t\telse ans = (ans + g[i].size()) / g[i].size();\n\t\t\n\t\tprintf(\"%.10lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, l, r) for (int i = (int)(l); i < (int)(r); i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)x.size())\ntemplate <class T> bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <class T> using V = vector<T>;\nusing P = pair<int, int>;\n\n/*\n *  */\n\nconst int inf = 1LL<<60;\n\nint n;\nV<int> es[101010];\ndouble dp[101010];\ndouble ans[101010];\n\nvoid dfs(int v, int p){\n  double sum = 0;\n  int k = 0;\n  for(auto to : es[v]){\n    if(to == p) continue;\n    dfs(to, v);\n    sum += dp[to]+1.0;\n    k++;\n  }\n\n  if(k) dp[v] += sum/k;\n}\n\ndouble dfs2(int v, int p, double d_p){\n  double sum = 0;\n  for(auto to : es[v]){\n    if(to == p){\n      sum += d_p + 1.0;\n    }else{\n      sum += dp[to] + 1.0;\n    }\n  }\n\n  int k = sz(es[v]);\n  ans[v] = sum/k;\n\n  for(auto to : es[v]){\n    if(to == p) continue;\n    dfs2(to, v, (sum-dp[to]-1.0)/max(1LL, k-1));\n  }\n}\n\nsigned main() {\n  cin >> n;\n  rep(i, 0, n-1){\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    es[a].emplace_back(b);\n    es[b].emplace_back(a);\n  }\n\n  dfs(0, -1);\n  dfs2(0, -1, 0);\n  rep(i, 0, n){\n    printf(\"%.12f\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<unordered_map>\n#include<vector>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[150000];\nunordered_map<int, float>dp[150000];\n\nfloat dfs(int v, int p) {\n\tif (dp[v].find(p) != dp[v].end())return dp[v][p];\n\tfloat ans = 0;\n\tfor (int u : E[v]) {\n\t\tif (u != p)ans += (dfs(u, v) + 1) / (double)(E[v].size() - (p == -1 ? 0 : 1));\n\t}\n\treturn dp[v][p] = ans;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n - 1) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tprintf(\"%.12f\\n\", dfs(i, -1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 150000;//頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v) {\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\t++count;\n\t\tsum += get(c.first, v) + 1;\n\t}\n\tif (count == 0) {\n\t\treturn 0;\n\t}\n\treturn sum / count;\n}\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v)+1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout  << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << get(i) << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::string S[10000];\nstd::string T;\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> S[i];\n\t}\n\tin >> T;\n\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\nusing ll = long long;\nll mp(int x, int y) {\n    return (ll)x << 32 | y & 0xFFFFFFFF;\n}\nmap<ll, double> dp;\n\n\ndouble rec(int u, int p) {\n    if (dp.count(mp(u, p))) {\n        return dp[mp(u, p)];\n    }\n    double &res = dp[mp(u, p)];\n    res = 0;\n    int cnt = 0;\n    for (auto &v : g[u]) {\n        if (v != p) ++cnt;\n    }\n    if (cnt == 0) {\n        res = 0;\n    } else {\n        for (auto &v : g[u]) {\n            if (v != p) {\n                res += 1 + rec(v, u);\n            }\n        }\n        res /= cnt;\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n) {\n        dp.clear();\n        g.assign(n, {});\n        for (int i = 0; i < n - 1; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        for (int i = 0; i < n; i++) {\n            printf(\"%.10f\\n\", rec(i, -1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\nvector<map<int, R>> dp;\nvector<vi> graph;\n\nR dfs(int v, int pv){\n    if(dp[v].find(pv) != end(dp[v])) return dp[v][pv];\n    R& cur = dp[v][pv];\n    cur = (R)0;\n\n    int cnt = 0;\n    for(auto& nv : graph[v]){\n        if(nv == pv) continue;\n        cur += dfs(nv, v);\n        cnt++;\n    }\n    if(cnt != 0){\n        cur /= cnt;\n    }\n    if(pv != -1) cur++;\n\n    return cur;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    dp = vector<map<int, R>>(n);\n    graph = vector<vi>(n);\n    rep(loop, n - 1){\n        int u, v; cin >> u >> v;\n        u--, v--;\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n\n    cout.precision(20);\n    rep(i, n){\n        cout << fixed << dfs(i, -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 0)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += p * (1.0 + f(ne, E[ne][0] == u));\n    }\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N;\n    rep(i, N-1) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    cout << fixed << setprecision(10);\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += (1.0 + f(e, E[e][0] == i)) * p;\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rep1(i,n) for(int i = 1; i < n; i++)\n#define repv(i,n) for(int i = n-1; i >= 0; i--)\n#define fi first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nchar BUF[3500000];\ninline void I(int&a){scanf(\"%d\",&a);}\ninline void I(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void I(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void I(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void L(ll&a){scanf(\"%lld\",&a);}\ninline void L(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void L(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void L(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void S(string&str){str.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)str.pb(BUF[i]);}\ninline void SV(vector<int>&v){v.clear();scanf(\"%s\",BUF);int s=strlen(BUF);rep(i,s)if('a'<=BUF[i]&&BUF[i]<='z')v.pb(BUF[i]-'a');else v.pb(BUF[i]-'A');}\n\nconst auto EPS = 1e-10;\nconst auto INF = 100000000;\nconst auto MOD = 1000000007;\ntypedef pair<ll,ll> P;\n\nint n;\nvector<int> e[150000];\nvector<double> val[150000];\ndouble ans[150000];\n\ndouble dfs(int x, int y){\n    if(val[x][y] > -0.5) return val[x][y];\n    int to = e[x][y];\n    if(e[to].size() == 1){\n        ans[x] += 1.0;\n        return val[x][y] = 1.0;\n    }\n    double ret = 0.0;\n    rep(i,e[to].size()){\n        if(e[to][i] == x) continue;\n        ret += dfs(to, i)+1.0;\n    }\n    ret /= (double)(e[to].size()-1);\n    ans[x] += ret;\n    return val[x][y] = ret;\n}\n\nvoid dfs2(int v, int p, double value){\n    if(v != 0){\n        if(e[p].size() == 1) ans[v] += 1.0;\n        else ans[v] += 1.0 + (ans[p]-value)/(double)(e[p].size()-1);\n    }\n    rep(i,e[v].size()){\n        if(e[v][i] == p) continue;\n        dfs2(e[v][i], v, val[v][i]);\n    }\n}\n\nint main(){\n    I(n);\n    rep(i,n-1){\n        int u,v; I(u,v);\n        u--; v--;\n        e[u].push_back(v);\n        val[u].push_back(-1.0);\n        e[v].push_back(u);\n        val[v].push_back(-1.0);\n    }\n    rep(i,e[0].size()){\n        dfs(0,i);\n    }\n    dfs2(0, 0, 0.0);\n    rep(i,n){\n        printf(\"%.9f\\n\",ans[i]/(double)e[i].size());\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 2e4 + 5;\n\nvector<int> G[maxn];\nint deg[maxn];\n\ndouble ans = 0;\n\nvoid dfs(int u, int fa, double p) {\n    for (int v : G[u]) if (v != fa) {\n        ans += p;\n//        if (deg[v] == 1) return;\n        double x = deg[v] - 1;\n        dfs(v, u, p / x);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        deg[u] ++, deg[v] ++;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; i ++) {\n        ans = 0;\n        dfs(i, -1, 1.0 / deg[i]);\n        printf(\"%.6f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 150010\nll n;\nvector<ll> g[N];\ndouble down[N],up[N];\ndouble dsum[N];\nvoid dfs1(ll x,ll p){\n    double sum=0,pa=0;\n    for(auto y:g[x])if(y!=p){\n\tdfs1(y,x);\n\tsum+=down[y]; pa+=1;\n    }\n    if(pa==0)down[x]=0;\n    else down[x]=sum/pa+1;\n    if(~p)dsum[p]+=down[x]+1;\n}\nvoid dfs2(ll x,ll p){\n    if(x==1)up[x]=0;\n    else if(p==1){\n\tdouble sum=dsum[p]-(down[x]+1);\n\tdouble pa=g[p].size()-1;\n\tif(pa==0)up[x]=1;\n\telse up[x]=sum/pa+1;\n    }\n    else{\n\tdouble sum=dsum[p]-(down[x]+1)+up[p];\n\tdouble pa=g[p].size()-1;\n\tup[x]=sum/pa+1;\n    }\n    for(auto y:g[x])if(y!=p){\n\tdfs2(y,x);\n    }\n}\nint main(){\n    cin>>n; if(n>N)return 0;\n    for(int i=0;i<n-1;i++){\n\tll a,b;cin>>a>>b;\n\tg[a].push_back(b);\n\tg[b].push_back(a);\n    }\n    dfs1(1,0);\n    dfs2(1,0);\n    for(int i=1;i<=n;i++){\n\tdouble ans=(up[i]+dsum[i])/double(g[i].size());\n\tcout<<fixed<<setprecision(9)<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\ntemplate <class S, class T> using P = pair<S, T>;\ntemplate <class... T> using TP = tuple<T...>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing dbl = double;\nusing str = string;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing tl = TP<ll, ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vtl = V<tl>;\nusing vvtl = V<vtl>;\nusing vs = V<str>;\nusing vvs = V<vs>;\nusing vd = V<dbl>;\nusing vvd = V<vd>;\nusing vvvd = V<vvd>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing stll = stack<ll>;\nusing stpl = stack<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n//#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define asn assign\n#define emp empty()\n#define fr front()\n#define bk back()\n#define clr clear()\n#define ins insert\n#define ers erase\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define ROR(v,i) for(auto &(i):(v))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define PREVP(a) prev_permutation((a).bgn,(a).en)\n#define NEXTP(a) next_permutation((a).bgn,(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define REGS(a,b) regex_search((a),regex(b))\n#define REGM(a,b) regex_match((a),regex(b))\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define fs(a) cout <<((a)?\"second\":\"first\")<<\"\\n\";\n#define Fs(a) cout <<((a)?\"Second\":\"First\")<<\"\\n\";\n#define FS(a) cout <<((a)?\"SECOND\":\"FIRST\")<<\"\\n\";\n//#define say(a) cout <<(a);\n//#define sal(a) cout <<(a)<<\"\\n\";\n#define sak cout <<\"\\n\";\n#define sas cout <<\" \";\n#define sat cout <<\"\\t\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define dbgs(...) dal(#__VA_ARGS__);dal(__VA_ARGS__);\n#define c2l(a) ((ll)(a-48))\n#define a2l(a) ((ll)(a-97))\n#define A2l(a) ((ll)(a-65))\n#define l2c(a) ((char)(a+48))\n#define l2a(a) ((char)(a+97))\n#define l2A(a) ((char)(a+65))\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define LSB(a) ((a)&(-(a)))\n/*#define llin(a) ll (a);cin >>(a);\n#define llin2(a,b) ll (a),(b);cin >>(a)>>(b);\n#define llin3(a,b,c) ll (a),(b),(c);cin >>(a)>>(b)>>(c);\n#define stin(a) string (a);cin >>(a);*/\n#define vin(v) ROR((v),(i)){cin >>(i);};\n#define vllin(N,v) vll (v)((N));vin(v);\n#define vllin2(N,a,b) vll (a)(N),(b)(N);REP(i,N){cin>>(a)[i]>>(b)[i];};\n#define vsin(N,v) vs (v)((N));vin(v);\n#define rdn(a,b) ((a)/(b))\n#define rou(a,b) ((((double(a)/double(b))-((a)/(b)))<0.5)?((a)/(b)):(((a)/(b))+1))\n#define rup(a,b) ((((a)%(b))==0)?((a)/(b)):(((a)/(b))+1))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n#define Triangle(x1,y1,x2,y2,x3,y3) (((x1)-(x2))*((y1)-(y3))-((x1)-(x3))*((y1)-(y2)))\n#define tg(t,i) get<i>(t)\n\n#define Id(x) get<0>(x)\n#define Act(x) get<1>(x)\n#define InvAct(x) get<2>(x)\n#define mg(id,act) mt(id,act,lam(l))\n//#define MonoidSet(T) TP<T, function<T(T, T)>>\n#define GroupSet(T) TP<T, function<T(T, T)>, function<T(T, T)>>\n#define CompareSet(T) TP<T, function<bool(T, T)>>\n#define lam(lr) ([](auto l, auto r){return (lr);})\n#define elam(lr) ([=](auto l, auto r){return (lr);})\n#define clam(lr) ([&](auto l, auto r){return (lr);})\n#define lamr(lr) ([](auto l, auto r){lr})\n#define elamr(lr) ([=](auto l, auto r){lr})\n#define clamr(lr) ([&](auto l, auto r){lr})\n#define min(...) Operation(MIN,__VA_ARGS__)\n#define max(...) Operation(MAX,__VA_ARGS__)\n#define gcd(...) Operation(GCD,__VA_ARGS__)\n#define lcm(...) Operation(LCM,__VA_ARGS__)\n#define vmin(...) VOperation(MIN,__VA_ARGS__)\n#define vmax(...) VOperation(MAX,__VA_ARGS__)\n#define vgcd(...) VOperation(GCD,__VA_ARGS__)\n#define vlcm(...) VOperation(LCM,__VA_ARGS__)\n#define vsum(...) VOperation(ADD,__VA_ARGS__)\n#define vpro(...) VOperation(MUL,__VA_ARGS__)\n#define emin(a, ...) ((a)=min((a),__VA_ARGS__))\n#define emax(a, ...) ((a)=max((a),__VA_ARGS__))\n#define egcd(a, ...) ((a)=gcd((a),__VA_ARGS__))\n#define elcm(a, ...) ((a)=lcm((a),__VA_ARGS__))\n#define ope Operation\n#define vope VOperation\n\n#define svll SumV<ll>\n#define svvll SumV2<ll>\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) str __VA_ARGS__;Input(__VA_ARGS__);\n//#define vli(size, ...) vll __VA_ARGS__;vInitInput(size,__VA_ARGS__);\n#define vlr(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vlc(size, ...) vll __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsr(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vsc(size, ...) vs __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vli2(rowSize,columnSize, ...) vvll __VA_ARGS__;vInitInput2(rowSize,columnSize,__VA_ARGS__);\n#define vplr(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n#define vplc(size, ...) vpl __VA_ARGS__;vInitInputC(size,__VA_ARGS__);\n#define vpli(size, ...) vpl __VA_ARGS__;vInitInputR(size,__VA_ARGS__);\n\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst vll DX = { 0,-1,0,1,0,-1,1,1,-1 };\nconst vll DY = { 0,0,-1,0,1,-1,-1,1,1 };\nconst str alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst str ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ntemplate <class T> auto GetVectorValueType(T v) { return v; }\ntemplate <class T> auto GetVectorValueType(V<T> v) { return GetVectorValueType(T()); }\n\ntemplate <class S, class T> istream &operator>>(istream &in, P<S, T> &p) { return in >> p.fi >> p.se; }\ntemplate <class T> istream &operator>>(istream &in, V<T> &v) { REP(i, v.sz) in >> v[i]; return in; }\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n\tcin >> var;\n\tInput(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n\tv.res(size);\n\tvInit(size, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class T, class... Args> void vInput(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInput(size, args...);\n}\nvoid vInputR(ll size) {}\ntemplate <class T, class... Args> void vInputR(ll size, V<T>& v, Args&... args) {\n\tREP(i, size) cin >> v[i];\n\tvInputR(size, args...);\n}\nvoid vInputNumC(ll num) {}\ntemplate <class T, class... Args> void vInputNumC(ll num, V<T>& v, Args&... args) {\n\tcin >> v[num];\n\tvInputNumC(num, args...);\n}\nvoid vInputC(ll size) {}\ntemplate <class... Args> void vInputC(ll size, Args&... args) {\n\tREP(i, size) vInputNumC(i, args...);\n}\nvoid vInitInputR(ll size) {}\ntemplate <class... Args> void vInitInputR(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputR(size, args...);\n}\nvoid vInitInputC(ll size) {}\ntemplate <class... Args> void vInitInputC(ll size, Args&... args) {\n\tvInit(size, args...);\n\tvInputC(size, args...);\n}\nvoid vInit2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInit2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tv.asn(rowSize, V<T>(columnSize));\n\tvInit2(rowSize, columnSize, args...);\n}\nvoid vInput2(ll rowSize, ll columnSize) {}\ntemplate <class T, class... Args> void vInput2(ll rowSize, ll columnSize, VV<T>& v, Args&... args) {\n\tREP(r, rowSize) {\n\t\tREP(c, columnSize) {\n\t\t\tcin >> v[r][c];\n\t\t}\n\t}\n\tvInput2(rowSize, columnSize, args...);\n}\nvoid vInitInput2(ll rowSize, ll columnSize) {}\ntemplate <class... Args> void vInitInput2(ll rowSize, ll columnSize, Args&... args) {\n\tvInit2(rowSize, columnSize, args...);\n\tvInput2(rowSize, columnSize, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n\treturn out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n\tif (v.emp) return out << \"{}\";\n\telse {\n\t\tauto itr = v.bgn;\n\t\tout << \"{\" << *itr;\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \"}\";\n\t\treturn out;\n\t}\n}\ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n\tif (m.emp) return out << \"<[]>\";\n\telse {\n\t\tauto itr = m.bgn;\n\t\tout << \"< [\" << (itr->fi) << \": \" << (itr->se);\n\t\titr++;\n\t\twhile (itr != m.en) {\n\t\t\tout << \"], [\" << (itr->fi) << \": \" << (itr->se);\n\t\t\titr++;\n\t\t}\n\t\tout << \"] >\";\n\t\treturn out;\n\t}\n}\ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n\tif (s.emp) return out << \"<>\";\n\telse {\n\t\tauto itr = s.bgn;\n\t\tout << \"<\" << *itr;\n\t\titr++;\n\t\twhile (itr != s.en) {\n\t\t\tout << \", \" << *itr;\n\t\t\titr++;\n\t\t}\n\t\tout << \">\";\n\t\treturn out;\n\t}\n}\n\nvoid say() {}\ntemplate <class T> void say(T t) { cout << t; }\ntemplate <class Head, class... Body> void say(Head head, Body... body) {\n\tcout << head << \" \";\n\tsay(body...);\n}\nvoid sal() { cout << \"\\n\"; }\ntemplate <class... Args> void sal(Args... args) {\n\tsay(args...);\n\tcout << \"\\n\";\n}\n\nvoid day() {}\ntemplate <class T> void day(T t) { cerr << t; }\ntemplate <class Head, class... Body> void day(Head head, Body... body) {\n\tcerr << head << \" \";\n\tday(body...);\n}\nvoid dal() { cerr << \"\\n\"; }\ntemplate <class... Args> void dal(Args... args) {\n\tday(args...);\n\tcerr << \"\\n\";\n}\n\nvoid salv() {}\ntemplate <class T> void salv(V<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tauto itr = v.bgn;\n\t\tsay(*itr);\n\t\titr++;\n\t\twhile (itr != v.en) {\n\t\t\tsas;\n\t\t\tsay(*itr);\n\t\t\titr++;\n\t\t}\n\t\tsak;\n\t}\n}\ntemplate <class T> void salv(VV<T> v) {\n\tif (v.emp) sal();\n\telse {\n\t\tROR(v, i) salv(i);\n\t}\n}\ntemplate <class T, class... Args> void salv(T v, Args... args) {\n\tsalv(v);\n\tsalv(args...);\n}\n\n\ntemplate <class L, class R> auto Gcd(L l, R r) -> decltype(l + r) {\n\tif (l < r) swap(l, r);\n\treturn r ? Gcd(r, l%r) : l;\n}\ntemplate <class L, class R> auto Lcm(L l, R r) {\n\tif (!l || !r) return 0;\n\treturn l / Gcd(l, r) * r;\n}\n\n/*\nauto LES = mp(INF, lam(return l < r;));\nauto GRT = mp(-INF, lam(return l > r;));\nauto EQ = mp(0, lam(return l == r;));\n\nauto ADD = mp(0, lam(return l + r;));\nauto SUB = mp(0, lam(return l - r;));\nauto MUL = mp(1, lam(return l * r;));\nauto DIV = mp(1, lam(return l / r;));\nauto MDL = mp(1, lam(return l % r;));\nauto XOR = mp(0, lam(return l ^ r;));\nauto OR = mp(0, lam(return l | r;));\nauto AND = mp(((ll)(1) << 63) - 1, lam(return l & r;));\nauto MIN = mp(INF, lam(return (l < r) ? l : r;));\nauto MAX = mp(-INF, lam(return (l > r) ? l : r;));\nauto GCD = mp(0, lam(return Gcd(l, r);));\nauto LCM = mp(1, lam(return Lcm(l, r);));\n*/\n\nauto LES = mp(INF, lam(l < r));\nauto GRT = mp(-INF, lam(l > r));\nauto EQ = mp(0, lam(l == r));\n\nauto ADD = mt(0, lam(l + r), lam(l - r));\nauto MUL = mt(1, lam(l * r), lam(l / r));\nauto XOR = mt(0, lam(l ^ r), lam(l ^ r));\nauto OR = mg(0, lam(l | r));\nauto AND = mg(((ll)(1) << 63) - 1, lam(l & r));\nauto MIN = mg(0, lam((l < r) ? l : r));\nauto MAX = mg(0, lam((l > r) ? l : r));\nauto GCD = mg(0, lam(Gcd(l, r)));\nauto LCM = mg(0, lam(Lcm(l, r)));\n\ntemplate <class OperationType> auto Operation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto Operation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T, class... Args> auto Operation(OperationType A, T x, Args... args) {\n\tauto tmp = Operation(A, args...);\n\treturn Act(A)(x, tmp);\n}\n\ntemplate <class OperationType> auto VOperation(OperationType A) { return Id(A); }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, T x) { return x; }\ntemplate <class OperationType, class T> auto VOperation(OperationType A, V<T> v) {\n\tif (v.emp) {\n\t\tdecltype(GetVectorValueType(T())) tmp = Id(A);\n\t\treturn tmp;\n\t}\n\tauto tmp = VOperation(A, v[0]);\n\tFOR(i, 1, v.sz - 1) tmp = Act(A)(tmp, VOperation(A, v[i]));\n\treturn tmp;\n}\ntemplate <class OperationType, class T, class... Args> auto VOperation(OperationType A, T x, Args... args) {\n\tauto xResult = VOperation(A, x);\n\tauto tmp = VOperation(A, args...);\n\treturn Act(A)(xResult, tmp);\n}\n\n\nll Bset(ll a, ll b, ll c) {\n\tif (c) a |= b;\n\telse a &= ~b;\n\treturn a;\n}\n\n\nstruct UFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tUFT(ll tsizeget, ll modeget = 0){\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct pUFT {\n\npublic:\n\n\tll tsize;\n\tll now;\n\tvll par;\n\tvll rank;\n\tvll mtime;\n\tvvll sizepi;\n\tVV<T> sizepv;\n\tV<T> elm;\n\tGroupSet(T) Add;\n\n\tpUFT(ll tsize, GroupSet(T) Add = ADD) : tsize(tsize), Add(Add) { init(); }\n\tvoid init() {\n\t\tnow = 0;\n\t\tpar.asn(tsize, -1);\n\t\trank.asn(tsize, 0);\n\t\tmtime.asn(tsize, INF);\n\t\tsizepi.asn(tsize, { 0 });\n\t\tsizepv.asn(tsize, {});\n\t}\n\tvoid set(ll x, T s) {\n\t\telm[x] = s;\n\t\tsizepv[x] = { s };\n\t}\n\tll root(ll x, ll t) {\n\t\treturn (mtime[x] > t) ? x : root(par[x], t);\n\t}\n\tbool same(ll x, ll y, ll t) {\n\t\treturn root(x, t) == root(y, t);\n\t}\n\tll merge(ll x, ll y) {\n\t\tnow++;\n\t\tx = root(x, now);\n\t\ty = root(y, now);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[y].pb(now);\n\t\t\t\tsizepv[y].pb(elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t\tmtime[x] = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tsizepi[x].pb(now);\n\t\t\t\tsizepv[x].pb(elm[x]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tmtime[y] = now;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\tT size(ll x, ll t) {\n\t\tx = root(x, t);\n\t\treturn sizepv[x][UPB(sizepi[x], t) - 1];\n\t}\n\n};\n\nstruct wUFT {\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tvll dweight;\n\twUFT(ll tsizeget, ll modeget = 0) {\n\t\ttsize = tsizeget;\n\t\tmode = modeget;\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\tdweight.asn(tsize, 0);\n\t}\n\tll root(ll x) {\n\t\tif (par[x] < 0) return x;\n\t\telse {\n\t\t\tll r = root(par[x]);\n\t\t\tdweight[x] += dweight[par[x]];\n\t\t\treturn par[x] = r;\n\t\t}\n\t}\n\tll weight(ll x) {\n\t\troot(x);\n\t\treturn dweight[x];\n\t}\n\tll diff(ll x, ll y) {\n\t\treturn weight(y) - weight(x);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y, ll w) {\n\t\tw += weight(x);\n\t\tw -= weight(y);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\tpar[x] += par[y];\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[y] += par[x];\n\t\t\t\tpar[x] = y;\n\t\t\t\tdweight[x] = -w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpar[x] += par[y];\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t\tdweight[y] = w;\n\t\t\t}\n\t\t}\n\t}\n\tll size(ll x) {\n\t\treturn -par[root(x)];\n\t}\n};\n\ntemplate <class T> struct sUFT {\n\npublic:\n\tll tsize;\n\tll mode;\n\tvll par;\n\tvll rank;\n\tGroupSet(T) Add;\n\tV<T> elm;\n\tsUFT(ll tsize, GroupSet(T) Add = ADD, ll mode = 0) : tsize(tsize), Add(Add), mode(mode) { init(); }\n\tvoid init() {\n\t\tpar.asn(tsize, -1);\n\t\tif (!mode) rank.res(tsize, 0);\n\t\telm.asn(tsize, Id(Add));\n\t}\n\tll root(ll x) {\n\t\treturn par[x] < 0 ? x : par[x] = root(par[x]);\n\t}\n\tbool isRoot(ll x) {\n\t\treturn x == root(x);\n\t}\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return;\n\t\tif (mode) {\n\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\tpar[y] = x;\n\t\t}\n\t\telse {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\telm[y] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\telm[x] = Act(Add)(elm[x], elm[y]);\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tT size(ll x) {\n\t\treturn elm[root(x)];\n\t}\n\tT& operator[](ll x) { return elm[x]; }\n};\n\ntemplate <typename valtype> class SegT {\n\npublic:\n\n\tll size;\n\tvector<valtype> v;\n\n\tvaltype initv;\n\tfunction<valtype(valtype x, valtype y)> calc;\n\n\tSegT() {}\n\tSegT(const SegT &segt) {}\n\n\tSegT(ll sizeget, ll modeget = 0) {\n\t\tsizeset(sizeget);\n\t\tmodeset(modeget);\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, ll modeget = 0) {\n\t\tsizeset(cpyvec.sz);\n\t\tmodeset(modeget);\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tSegT(ll sizeget, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(sizeget);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t}\n\tSegT(vector<valtype> cpyvec, valtype initvget, function<valtype(valtype x, valtype y)> calcget) {\n\t\tsizeset(cpyvec.sz);\n\t\tinitv = initvget;\n\t\tcalc = calcget;\n\t\tinit();\n\t\tcopy(cpyvec);\n\t}\n\tvoid sizeset(ll rsize) {\n\t\tsize = DigN2(rsize);\n\t\tif (rsize == Pow2(size - 1)) size--;\n\t\treturn;\n\t}\n\tvoid modeset(ll mode) {\n\t\tswitch (mode) {\n\t\tcase 0:\n\t\t\tinitv = 0;\n\t\t\tcalc = [](valtype x, valtype y) {return x + y; };\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinitv = INF;\n\t\t\tcalc = [](valtype x, valtype y) {return min(x, y); };\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinitv = -INF;\n\t\t\tcalc = [](valtype x, valtype y) {return max(x, y); };\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tvoid init() {\n\t\tv.asn(Pow2(size + 1) - 1, initv);\n\t}\n\tvoid copy(vector<valtype> cpyvec) {\n\t\tREP(i, min(cpyvec.sz, Pow2(size))) set(i, cpyvec[i]);\n\t}\n\tll i2v(ll i) const{\n\t\tif (i < 0 || i >= Pow2(size)) return -1;\n\t\treturn Pow2(size) + i - 1;\n\t}\n\tll top(ll i) const{\n\t\tif (i == 0) return -1;\n\t\treturn (i - 1) / 2;\n\t}\n\tpl bot(ll i) const{\n\t\tif (i + 1 >= Pow2(size)) return mp(-1, -1);\n\t\treturn mp(2 * i + 1, 2 * i + 2);\n\t}\n\tvoid set(ll i, valtype x) {\n\t\ti = i2v(i);\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = top(i);\n\t\t\tv[i] = calc(v[bot(i).fi], v[bot(i).se]);\n\t\t}\n\t\treturn;\n\t}\n\tvoid add(ll i, valtype x) {\n\t\tset(i, v[i2v(i)] + x);\n\t\treturn;\n\t}\n\tvaltype operator[](const ll &i) const {\n\t\treturn v[i2v(i)];\n\t}\n//\tvaltype que(ll a = 0, ll b = Pow2(size) - 1) {\n\tvaltype que(ll a, ll b) {\n\t\tif (a == b) return v[i2v(a)];\n\t\tif (a > b) return initv;//swap(a, b);\n\t\tvaltype ans = initv;\n\t\tll ai = i2v(a);\n\t\tll bi = i2v(b);\n\t\tFOR(i, 1, size + 1) {\n\t\t\tif (a > b) break;\n\t\t\tif (a%Pow2(i)) {\n\t\t\t\tans = calc(ans, v[ai]);\n\t\t\t\ta += Pow2(i - 1);\n\t\t\t\tai = top(ai) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tai = top(ai);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t\tif ((b + 1) % Pow2(i)) {\n\t\t\t\tans = calc(ans, v[bi]);\n\t\t\t\tb -= Pow2(i - 1);\n\t\t\t\tbi = top(bi) - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbi = top(bi);\n\t\t\t}\n\t\t\tif (a > b) break;\n\t\t}\n\t\treturn ans;\n\t}\n\tvaltype que(ll b) {\n\t\treturn que(0, b);\n\t}\n\tvaltype que() {\n\t\treturn que(0, Pow2(size) - 1);\n\t}\n\n\n};\n\n\n/*template <class Type> class DP {\n\npublic:\n\n\tvector<Type> v;\n\tType initv;\n\tvll size, block;\n\n\tDP() {}\n\tDP(const DP &dp) {}\n\n\ttemplate<class... Args> DP(Args... args) {\n\t\tblock.asn(1, 1);\n\t\tInitialize(args...);\n\t}\n\n\tvoid Initialize(Type initv_) {\n\t\tinitv = initv_;\n\t\tv.asn(block.bk, initv);\n\t}\n\ttemplate<class... Args> void Initialize(ll val, Args... args) {\n\t\tsize.pb(val);\n\t\tblock.pb(block.bk*val);\n\t\tInitialize(args...);\n\t}\n\n\n\n};*/\n\n\npl Bezout(ll a, ll b) {\n\tif (b != 0) {\n\t\tpl xy;\n\t\txy = Bezout(b, a%b);\n\t\treturn mp(xy.se, xy.fi - ((a / b)*xy.se));\n\t}\n\telse {\n\t\treturn mp(1, 0);\n\t}\n}\npl Bez(ll a, ll b, ll c) {\n\tpl xy;\n\tll x, y, z, gc;\n\txy = Bezout(a, b);\n\tgc = gcd(a, b);\n\tif (c%gc != 0) return mp(-1, -1);\n\tx = xy.fi*(c / gc); y = xy.se*(c / gc);\n\tif (x < 0) z = rup(-x, (b / gc));\n\tif (x >= 0) z = -x / (b / gc);\n\tx += z * (b / gc);\n\ty -= z * (a / gc);\n\treturn mp(x, y);\n}\n\nll DigS10(ll n) {\n\tll ans = 0;\n\twhile(1) {\n\t\tans += n % 10;\n\t\tn /= 10;\n\t\tif (!n) break;\n\t}\n\treturn ans;\n}\n\nll isP(ll n) {\n\tif (n <= 1) return 0;\n\tFOR(i, 2, (ll)sqrt(n) + 1) {\n\t\tif (n%i == 0) return 0;\n\t}\n\treturn 1;\n}\n\nll Tot(ll n) {\n\tif (n <= 0) return 0;\n\tll ans = n, x = 2;\n\twhile (x*x <= n) {\n\t\tif (n%x == 0) {\n\t\t\tans -= ans / x;\n\t\t\twhile (n%x == 0) n /= x;\n\t\t}\n\t\tx++;\n\t}\n\tif (n > 1) ans -= ans / n;\n\treturn ans;\n}\n\ntemplate <class T> struct Graph {\npublic:\n\tll vSize;\n\tll eMode;\n\tll mapMode;\n\tGroupSet(T) Add;\n\tCompareSet(T) Less;\n\tCompareSet(T) Equal;\n\tVV<P<T, ll>> adj;\n\tmap<pl, T> len;\n\tGraph(ll vSize, ll eMode = 0, ll mapMode = 0, GroupSet(T) Add = ADD, CompareSet(T) Less = LES, CompareSet(T) Equal = EQ) : vSize(vSize), eMode(eMode), mapMode(mapMode), Add(Add), Less(Less), Equal(Equal) {}\n\tvoid Init() {\n\t\tadj.asn(vSize, V<P<T, ll>>());\n\t}\n\tvoid AddE(ll x, ll y, T cost) {\n\t\tiAddE(x, y, cost);\n\t\tif (!eMode) iAddE(y, x, cost);\n\t}\n\tvoid iAddE(ll x, ll y, T cost) {\n\t\tadj[x].pb(mp(cost, y));\n\t\tif (mapMode) len[mp(x, y)] = cost;\n\t}\n\tP<bool, T> getE(ll x, ll y) {\n\t\tif (!len.count(mp(x, y))) return mp(false, Id(Less));\n\t\treturn mp(true, len[mp(x, y)]);\n\t}\n\tV<T> Dijk(ll x) {\n\t\tV<T> ans(vSize, Id(Less));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se] = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se], i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se], i.fi), i.se));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tV<P<T, vll>> rDijk(ll x) {\n\t\tV<P<T, vll>> ans(vSize, mp(Id(Less), vll()));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans[now.se].fi = segt[now.se].fi;\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, mp(Act(Add)(ans[now.se].fi, i.fi), i.se));\n\t\t\t\t\tans[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(Act(Add)(ans[now.se].fi, i.fi), segt[i.se].fi)) {\n\t\t\t\t\tans[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tT Prim(ll x = 0) {\n\t\tT ans = Id(Add);\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans = Act(Add)(ans, segt[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tP<T, V<P<T, vll>>> rPrim(ll x = 0) {\n\t\tP<T, V<P<T, vll>>> ans = mp(Id(Add), V<P<T, vll>>(vSize, mp(Id(Less), vll())));\n\t\tif (x < 0 || x >= vSize) return ans;\n\t\tSegT<P<T, ll>> segt(vSize, mp(Id(Less), -1), clamr(\n\t\t\tif (l.se < 0) return r;\n\t\tif (r.se < 0) return l;\n\t\treturn Act(Less)(l.fi, r.fi) ? l : r;\n\t\t));\n\t\tsegt.set(x, mp(Id(Add), x));\n\t\tP<T, ll> now;\n\t\twhile ((now = segt.que(0, vSize - 1)).se >= 0) {\n\t\t\tans.se[now.se].fi = segt[now.se].fi;\n\t\t\tans.fi = Act(Add)(ans.fi, ans.se[now.se].fi);\n\t\t\tsegt.set(now.se, mp(Id(Less), -2));\n\t\t\tROR(adj[now.se], i) {\n\t\t\t\tif (segt[i.se].se == -2) continue;\n\t\t\t\tif (segt[i.se].se == -1) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Less)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tsegt.set(i.se, i);\n\t\t\t\t\tans.se[i.se].se = { now.se };\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Act(Equal)(i.fi, segt[i.se].fi)) {\n\t\t\t\t\tans.se[i.se].se.pb(now.se);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\ntemplate <class T> struct Sum {\npublic:\n\tV<T> v, s;\n\tll size;\n\tGroupSet(T) Add;\n\tSum(V<T> v, GroupSet(T) Add = ADD) : v(v), size(v.sz), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(size + 1, Id(Add));\n\t}\n\tvoid Calc() {\n\t\tREP(i, size) s[i + 1] = Act(Add)(s[i], v[i]);\n\t}\n\tT operator()(ll x) {\n\t\tif (x < -1) x = -1;\n\t\tif (x > size - 1) x = size - 1;\n\t\treturn s[x + 1];\n\t}\n\tT operator()(ll l, ll r) {\n\t\tif (l < 0) l = 0;\n\t\tif (r >= size) r = size - 1;\n\t\tif (l > r) return Id(Add);\n\t\treturn InvAct(Add)(s[r + 1], s[l]);\n\t}\n};\nusing sumll = Sum<ll>;\n\ntemplate <class T> struct Sum2 {\npublic:\n\tVV<T> v, s;\n\tll RowSize, ColumnSize;\n\tGroupSet(T) Add;\n\tSum2(VV<T> v, GroupSet(T) Add = ADD) : v(v), RowSize(v.sz), ColumnSize(v.sz ? v[0].sz : 0), Add(Add) { Init(); Calc(); }\n\tvoid Init() {\n\t\ts.asn(RowSize + 1, V<T>(ColumnSize + 1, Id(Add)));\n\t}\n\tvoid Calc() {\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n//\t\t\t\ts[r][c] = InvAct(Add)(Act(Add)(Act(Add)(v[r - 1][c - 1], operator()(r - 1, c - 2)), operator()(r - 2, c - 1)), operator()(r - 2, c - 2));\n\t\t\t\ts[r][c] = Act(Add)(s[r][c - 1], v[r - 1][c - 1]);\n\t\t\t}\n\t\t}\n\t\tREP1(r, RowSize) {\n\t\t\tREP1(c, ColumnSize) {\n\t\t\t\ts[r][c] = Act(Add)(s[r - 1][c], s[r][c]);\n\t\t\t}\n\t\t}\n\t}\n\tT operator()(ll r, ll c) {\n\t\tif (r < -1) r = -1;\n\t\tif (c < -1) c = -1;\n\t\tif (r > RowSize - 1) r = RowSize - 1;\n\t\tif (c > ColumnSize - 1) c = ColumnSize - 1;\n\t\treturn s[r + 1][c + 1];\n\t}\n\tT operator()(ll r1, ll c1, ll r2, ll c2) {\n\t\tif (r1 < 0) r1 = 0;\n\t\tif (c1 < 0) c1 = 0;\n\t\tif (r2 >= RowSize) r2 = RowSize - 1;\n\t\tif (c2 >= ColumnSize) c2 = ColumnSize - 1;\n\t\tif (r1 > r2) return Id(Add);\n\t\tif (c1 > c2) return Id(Add);\n\t\treturn InvAct(Add)(Act(Add)(s[r2 + 1][c2 + 1], s[r1][c1]), Act(Add)(s[r2 + 1][c1], s[r1][c2 + 1]));\n\t}\n};\nusing sumll2 = Sum2<ll>;\n\ntemplate <class T> struct Point2 {\npublic:\n\tVV<T> v;\n\tll h, w;\n\tPoint2() : h(0), w(0) {}\n\tPoint2(ll h, ll w) : h(h), w(w) { asn(h, w); }\n\tPoint2(ll h, ll w, T val) : h(h), w(w) { asn(h, w, val); }\n\tPoint2(VV<T> cv) : h(cv.sz), w(cv.sz ? cv[0].sz : 0) { asn(h, w); copy(cv); }\n\tvoid assign(ll h, ll w) { v.asn(h, V<T>(w)); }\n\tvoid assign(ll h, ll w, ll val) { v.asn(h, V<T>(w, val)); }\n\tvoid copy(VV<T> cv) { REP(_h, h) REP(_w, w) v[_h][_w] = cv[_h][_w]; }\n\tT& operator()(ll h, ll w) { return v[h][w]; }\n\tT& operator()(pl p) { return v[p.fi][p.se]; }\n\tT& operator[](pl p) { return v[p.fi][p.se]; }\n};\ntemplate <class T> using P2 = Point2<T>;\n\ntemplate <ll Mod> struct Modll {\npublic:\n\tll v;\n\tModll() : v(0) {}\n\tModll(ll _v) { set(_v % Mod + Mod); }\n\tModll& set(ll _v) {\n\t\tv = (_v < Mod) ? _v : (_v - Mod);\n\t\treturn *this;\n\t}\n\tModll pow(ll n) const {\n\t\tModll x = *this, ans = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) ans *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tModll inverse() const { return (*this).pow(Mod - 2); }\n\tModll operator+(const Modll& m) const { return Modll().set(v + m.v); }\n\tModll operator-(const Modll& m) const { return Modll().set(Mod + v - m.v); }\n\tModll operator*(const Modll& m) const { return Modll().set((ull(v) * m.v) % Mod); }\n\tModll operator/(const Modll& m) const { return *this * m.inv; }\n\tModll& operator+=(const Modll& m) { return *this = *this + m; }\n\tModll& operator-=(const Modll& m) { return *this = *this - m; }\n\tModll& operator*=(const Modll& m) { return *this = *this * m; }\n\tModll& operator/=(const Modll& m) { return *this = *this / m; }\n\tModll operator-() const { return Modll(0) - *this; }\n\texplicit operator bool() const { return v != 0; }\n\tfriend istream& operator>>(istream& in, Modll& m) { return in >> m.v; }\n\tfriend ostream& operator<<(ostream& out, const Modll& m) { return out << m.v; }\n};\nusing mll = Modll<MOD>;\nusing vmll = V<mll>;\nusing vvmll = V<vmll>;\nusing vvvmll = V<vvmll>;\n\nvmll MFactMemo(2, 1);\nvmll MIFactMemo(2, 1);\n\nmll mFact(ll n) {\n\tif (MFactMemo.sz <= n) {\n\t\tll oldsize = MFactMemo.sz;\n\t\tMFactMemo.res(n + 1, 1);\n\t\tFOR(i, oldsize, n) MFactMemo[i] = MFactMemo[i - 1] * i;\n\t}\n\treturn MFactMemo[n];\n}\nmll miFact(ll n) {\n\tif (MIFactMemo.sz <= n) {\n\t\tll oldsize = MIFactMemo.sz;\n\t\tMIFactMemo.res(n + 1, 1);\n\t\tMIFactMemo.bk = mFact(n).inv;\n\t\trFOR(i, oldsize + 1, n) MIFactMemo[i - 1] = MIFactMemo[i] * i;\n\t}\n\treturn MIFactMemo[n];\n}\nmll mComb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn mFact(n) * miFact(k) * miFact(n - k);\n}\n\nll LIS(vll v, ll m = 0) {\n\n\tif (v.sz > 0) {\n\t\tll ans = 0;\n\t\tvll dp(v.sz, INF);\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tdp[m ? UPB(dp, v[i]) : LOWB(dp, v[i])] = v[i];\n\t\t}\n\t\tFOR(i, 0, v.sz - 1) {\n\t\t\tif (dp[i] == INF) break;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n}\n\nll Bsrch(function<bool(ll x)> f, ll mi, ll ma) {\n\tll ng = mi - 1, ok = ma, mid;\n\twhile (ok - ng > 1) {\n\t\tmid = (ng + ok) / 2;\n\t\t(f(mid) ? ok : ng) = mid;\n\t}\n\treturn ok;\n}\n\ntemplate <class T, class M = decltype(MUL), class S = decltype(ADD)> VV<T> MultiMatrix(VV<T> A, VV<T> B, M Mul = MUL, S Add = ADD) {\n\tVV<T> ans;\n\tll ii = A.sz;\n\tif (!ii) return ans;\n\tll jj = A[0].sz;\n\tif (!jj) return ans;\n\tll jj2 = B.sz;\n\tif (!jj2) return ans;\n\tif (jj != jj2) return ans;\n\tll kk = B[0].sz;\n\tif (!kk) return ans;\n\tans.asn(ii, V<T>(kk, 0));\n\tREP(i, ii) {\n\t\tREP(k, kk) {\n\t\t\tREP(j, jj) {\n\t\t\t\tans[i][k] = Act(Add)(ans[i][k], Act(Mul)(A[i][j], B[j][k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n\tif ((n < 0) || (k < 0)) return 0;\n\tif (CombMemo[n][k] == -1) {\n\t\tif (n < k) CombMemo[n][k] = 0;\n\t\telse {\n\t\t\tif (n == 0) CombMemo[n][k] = 1;\n\t\t\telse if (k == 0) CombMemo[n][k] = 1;\n\t\t\telse if (n == k) CombMemo[n][k] = 1;\n\t\t\telse CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n\t\t}\n\t}\n\treturn CombMemo[n][k];\n}\n\ntemplate<class T> map<T, ll> Dict(V<T> v) {\n\tmap<T, ll> m;\n\tif (!v.sz) return m;\n\tSORT(v);\n\tUNIQUE(v);\n\tREP(i, v.sz) {\n\t\tm[v[i]] = i;\n\t}\n\treturn m;\n}\n\ntemplate <class T> vll Cmprs(V<T> v) {\n\tauto m = Dict(v);\n\tvll ans(v.sz);\n\tREP(i,v.sz) {\n\t\tans[i] = m[v[i]];\n\t}\n\treturn ans;\n}\n\ntemplate <class T> vll PCmprs(V<T> v) {\n\tif (v.sz == 0) return V<T>();\n\tvll tmp(v.sz);\n\tvll ans(v.sz);\n\tIOTA(tmp, 0);\n\tIOTA(ans, 0);\n\tsort(tmp.bgn, tmp.en, clam(v[l] < v[r]));\n\tsort(ans.bgn, ans.en, clam(tmp[l] < tmp[r]));\n\treturn ans;\n}\n\nll BblCnt(vll rv) {\n\tvll v = PCmprs(rv);\n\tSegT<ll> b(v.sz, 0);\n\tll ans = 0;\n\tREP(i, v.sz) {\n\t\tans += (i - b.que(0, v[i]));\n\t\tb.add(v[i], 1);\n\t}\n\treturn ans;\n}\n\npl NGrid(pl p, ll i, ll H, ll W) {\n\tp = mp(p.fi + DX[i], p.se + DY[i]);\n\tif (p.fi < 0 || p.fi >= H || p.se < 0 || p.se >= W) return mp(INF, INF);\n\treturn p;\n}\n\nvvll llGrid(vs v) {\n\tvvll r(v.sz, vll(v.sz ? v[0].sz : 0, 0));\n\tREP(h, v.sz) REP(w, v.sz ? v[0].sz : 0) r[h][w] = (v[h][w] == '#');\n\treturn r;\n}\n\ntemplate <class T> auto ven(T val) { return val; }\ntemplate <> auto ven<int>(int val) { return (ll)val; }\ntemplate <class T, class... Args> auto ven(T val, Args... args) {\n\tauto tmp = ven(args...);\n\treturn V<decltype(tmp)>(val, tmp);\n}\n\ntemplate <class T> void zind(T& v) { v--; }\ntemplate <class T> void zind(V<T>& v) { ROR(v, i) zind(i); }\ntemplate <class T, class... Args> void zind(T& v, Args&... args) { zind(v); zind(args...); }\n\nvoid Solve();\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(20) << fixed;\n\tSolve();\n}\n\n//index_sort\n\nll N;\nvvpl adj;\nvvd dp;\nvvd dp1;\nvvd dp2;\n\ndbl dfs(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tdbl tmp = 0;\n\tll y = adj[x][n].fi;\n\tREP(i, adj[y].sz) {\n\t\tif (adj[y][i].fi == x) continue;\n\t\ttmp += dfs(y, i);\n\t}\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\ndbl rec(ll x, ll n) {\n\tif (dp[x][n] > -0.5) return dp[x][n];\n\tll y = adj[x][n].fi;\n\tif (!dp1[y].sz) {\n\t\tdp1[y].asn(dp[y].sz, 0);\n\t\tdp2[y].asn(dp[y].sz, 0);\n\t\tFOR(i, 1, dp[y].sz - 1) dp1[y][i] = dp1[y][i - 1] + dp[y][i - 1];\n\t\trFOR(i, 0, dp[y].sz - 2) dp2[y][i] = dp2[y][i + 1] + dp[y][i + 1];\n\t}\n\tdbl tmp = dp1[y][adj[x][n].se] + dp2[y][adj[x][n].se];\n\treturn dp[x][n] = ((adj[y].sz - 1) ? (tmp / (adj[y].sz - 1)) : dbl(0)) + 1;\n}\n\nvoid Solve() {\n\n\tcin >> N;\n\tif (N == 1) { sal(0); return; }\n\tadj = ven(N, vpl(0));\n\tdp = ven(N, vd(0));\n\tdp1 = ven(N, vd(0));\n\tdp2 = ven(N, vd(0));\n\tREP(i, N - 1) {\n\t\tli(u, v);\n\t\tu--; v--;\n\t\tadj[u].pb(mp(v, adj[v].sz));\n\t\tadj[v].pb(mp(u, adj[u].sz - 1));\n\t\tdp[u].pb(-1);\n\t\tdp[v].pb(-1);\n\t}\n\tREP(i, adj[0].sz) dfs(0, i);\n\tREP(i, N) {\n\t\tdbl tmp = 0;\n\t\tREP(j,adj[i].sz) {\n\t\t\ttmp += rec(i, j);\n\t\t}\n\t\ttmp /= dbl(adj[i].sz);\n\t\tsal(tmp);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp[MAX_N];\ndouble dp2[MAX_N];\ndouble ans[MAX_N];\nint eda[MAX_N];\n\nvoid dfs(int u,int p)\n{\n    int cnt = 0;\n    double res = 0;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            cnt++;\n            dfs(G[u][i],u);\n            res += dp[G[u][i]];\n        }\n    }\n    eda[u] = cnt;\n    dp[u] = res/cnt + 1;\n}\n\nvoid dfs2(int u,int p)\n{\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            if(u == 0){\n                if(eda[u] == 1){\n                    dp2[G[u][i]] = 1;\n                }else{\n                    dp2[G[u][i]] = (dp[u]*eda[u]-(1+dp[G[u][i]]))/(eda[u]-1) + 1;\n                }\n            }else{\n                dp2[G[u][i]] = dp2[u]/eda[u] + dp[u]-(1+dp[G[u][i]])/eda[u] + 1;\n            }\n            ans[G[u][i]] = dp2[G[u][i]]/(eda[G[u][i]]+1) + dp[G[u][i]]*eda[G[u][i]]/(eda[G[u][i]]+1);\n            dfs2(G[u][i],u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    dfs(0,-1);\n    ans[0] = dp[0];\n    dp2[0] = 0;\n    dfs2(0,-1);\n    // rep(i,n){\n    //     cout << i << \" \" << dp[i] << endl;\n    // }\n    rep(i,n){\n        printf(\"%.12lf\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <time.h>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w = 1) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed = 0) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tcon(a - oindexed, b - oindexed);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//無向\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nsigned main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBiDGraph g(n);\n\tg.scan(n-1,1);\n\n\tvector<double> per(n);\n\n\tfunction<double(int, int)> dfs = [&](int cur, int p) {\n\t\tdouble ret = 0;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\n\t\t\tret += (1+dfs(itr.first, cur))/(double)(g.g[cur].size()-(bool)(p+1));\n\n\t\t}\n\t\treturn per[cur] = ret;\n\t};\n\n\tdfs(0,-1);\n\tvector<double> ans(n);\n\tfunction<void(int, int, double)> dfs2 = [&](int cur, int p, double par) {\n\t\tdouble np = par;\n\t\tdouble sum = np;\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t\tans[cur] = sum / g.g[cur].size();\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (itr.first == p) continue;\n\t\t\tsum -= per[itr.first]+1;\n\t\t\tdfs2(itr.first, cur, 1+ (p != -1 ? (sum) / (g.g[cur].size() - 1) : 0));\n\t\t\tsum += per[itr.first]+1;\n\t\t}\n\t};\n\tdfs2(0, -1, 0);\n\tans[0] = per[0];\n\tREP(i, n)\n\t\tprintf(\"%.10lf\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n \nusing namespace std;\n \n#define int long long\n//typedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-11;\nconst int MOD = 1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n \nint n;\ndouble kitai[150000];\nvector<int> G[150000];\nmap<P,double> dp;\n \ndouble dfs(int prev,int now){\n\tif(G[now].size() == 1) return dp[P(prev,now)] = 0.0;\n\tif(dp.find(P(prev,now)) != dp.end()) return dp[P(prev,now)];\n\tif(kitai[now] >= -EPS){\n\t\tdouble sum = ((kitai[now] - 1.0) * (double)G[now].size() - dp[P(now,prev)]) / (double)(G[now].size() - 1);\n\t\treturn dp[P(prev,now)] = sum + 1.0;\n\t}\n\tdouble sum = 0.0;\n\tfor(int i = 0;i < G[now].size();i++){\n\t\tif(G[now][i] == prev) continue;\n\t\tif(G[G[now][i]].size() == 1) continue;\n\t\tsum += dfs(now,G[now][i]);\n\t}\n\treturn dp[P(prev,now)] = sum / (double)(G[now].size() - 1) + 1.0;\n}\n \nsigned main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tkitai[i] = -1.0;\n\t}\n\tfor(int i = 0;i < n - 1;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld %lld\",&u,&v); u--;v--;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tdouble sum = 0.0;\n\t\tfor(int j = 0;j < G[i].size();j++) sum += dfs(i,G[i][j]);\n\t\tprintf(\"%.9lf\\n\",sum / (double)G[i].size() + 1.0);\n\t\tkitai[i] = sum / (double)G[i].size() + 1.0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef pair<double, long long> pdl;\n\nconst long double pi = 3.141592653589793;\n\n#define debug(x) cout << #x << \" = \" << (x) << endl;\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n\nint n, x, y;\nvector<int> g[1<<20];\n\nlong double dfs(int s, int p) {\n\tif(g[s].size() == 1 and g[s][0] == p) return 1;\n\tlong double sum = 0;\n\tfor(auto &x : g[s]) {\n\t\tif(x == p) continue;\n\t\tsum += dfs(x, s);\n\t}\n\n\tif(p == -1) return sum/(g[s].size());\n\treturn 1 + sum/(g[s].size()-1);\n}\n\nint main() {\n  \t//freopen(\"input.in\",\"r\",stdin);\n  \t//freopen(\"output.out\",\"w\",stdout);\n\tcin>>n;\n\trep(i, n-1) {\n\t\tcin>>x>>y;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\n\tif(n == 1) {\n\t\tcout<<\"0\"<<endl; return 0;\n\t}\n\n\trep(i, n) {\n\t\tprintf(\"%.12Lf\\n\", dfs(i+1, -1));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    if(dp2[a]>0)return ;\n    if(a==0)return ;\n    //if(dp2[(int)par[a]]==0)この違いよ！\n    dfs2(par[a]);\n    int b=par[a];\n    ld p=v[b].size();\n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    //cout<<\"W\"<<endl;\n  \t//for(int i=0;i<n;i++)dp2[i]=0;\n    for(auto x:u){\n        dfs2(x);\n    }\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cctype>\n#include <cassert>\n#include <sstream>\n#include <ctime>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> P;\n\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\nvector<pii> g[150000];\ndouble dp[300000];\n\ndouble dfs(int u, int gnum, int prev) {\n\tif (dp[gnum] != -1.0) return dp[gnum];\n\t\n\tdouble res = 0.0;\n\tint cnt = 0;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i].first;\n\t\tif (v == prev) continue;\n\t\t\n\t\tcnt++;\n\t\tres += dfs(v, g[u][i].second, u) + 1;\n\t}\n\t\n\tif (cnt == 0) return 0.0;\n\treturn dp[gnum] = res / cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tREP(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(pii(v, i));\n\t\tg[v].push_back(pii(u, i + n));\n\t}\n\t\n\tfill(dp, dp + n * 2, -1.0);\n\t\n\tREP(i, n) {\n\t\tdouble ans = 0;\n\t\tREP(j, g[i].size()) ans += dfs(g[i][j].first, g[i][j].second, i) + 1;\n\t\t\n\t\tans /= g[i].size();\n\t\t\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** Template Begin ***/\n\n#define USING_BOOST\n#define USING_NAMESPACE\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nauto init_ = [] {\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10);\n    return 0;\n}();\n\ntemplate <typename T>\ninline T in() {\n    T x;\n    std::cin >> x;\n    return x;\n}\n\ntemplate <typename T>\ninline void in(T &x) {\n    std::cin >> x;\n}\n\ntemplate <typename T, typename... Ts>\ninline void in(T &t, Ts &... ts) {\n    std::cin >> t;\n    in(ts...);\n}\n\ntemplate <typename T, typename U = std::vector<T>>\ninline U vin(int n) {\n    U v(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> v[i];\n    }\n    return v;\n}\n\ntemplate <typename T, typename U = std::vector<T>, typename V = std::vector<U>>\ninline V vin(int h, int w) {\n    V vv(h, U(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            std::cin >> vv[i][j];\n        }\n    }\n    return vv;\n}\n\ntemplate <typename T>\ninline void out(const T &x) {\n    std::cout << x << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T, typename... Ts>\ninline void out(const T &t, const Ts &... ts) {\n    std::cout << t << delimiter;\n    out(ts...);\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int n) {\n    for (int i = 0; i < n; ++i) {\n        if (i) std::cout << delimiter;\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\ntemplate <char delimiter = ' ', typename T>\ninline void vout(const T &v, int h, int w) {\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (j) std::cout << delimiter;\n            std::cout << v[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\ntemplate <typename T, size_t D>\nstruct multi_vector_type {\n    using type = std::vector<typename multi_vector_type<T, D - 1>::type>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 1> {\n    using type = std::vector<T>;\n};\n\ntemplate <typename T>\nstruct multi_vector_type<T, 0> {\n    using type = T;\n};\n\ntemplate <typename T, size_t D>\nusing multi_vector = typename multi_vector_type<T, D>::type;\n\ntemplate <typename T, size_t D, class = typename std::enable_if<D == 0>::type>\nT make_vector(const T &val = T()) {\n    return val;\n}\n\ntemplate <typename T, size_t D = 1, typename... Ts,\n          class = typename std::enable_if<D != 0>::type>\nmulti_vector<T, D> make_vector(size_t n, Ts &&... args) {\n    return multi_vector<T, D>(n, make_vector<T, D - 1>(args...));\n}\n\nnamespace detail {\n\ntemplate <typename F>\nstruct Debug {\n    const char *delim_ = \"\\n\";\n    F fun;\n\n    Debug(F f) : fun(f) {}\n\n    ~Debug() { fun(delim_); }\n\n    Debug &delim(const char *d) {\n        delim_ = d;\n        return *this;\n    }\n};\n\nstd::deque<std::string> split(const std::string &s, char c) {\n    std::deque<std::string> v;\n    std::stringstream ss(s);\n    std::string x;\n    while (std::getline(ss, x, c)) v.emplace_back(x);\n    return v;\n}\n\ntemplate <typename T>\nvoid deb(const char *delim, std::deque<std::string> v, T a) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << '\\n';\n    std::cerr << std::flush;\n}\n\ntemplate <typename T, typename... Args>\nvoid deb(const char *delim, std::deque<std::string> v, T a, Args... args) {\n    std::cerr << v[0].substr(v[0][0] == ' ', v[0].length()) << \" = \" << a\n              << delim;\n    v.pop_front();\n    deb(delim, std::move(v), args...);\n}\n\ntemplate <typename... Args>\nauto wrap(std::deque<std::string> v, Args... args) {\n    auto f = [=](const char *delim = \"\\n\") { deb(delim, v, args...); };\n\n    return Debug<decltype(f)>(f);\n}\n}\n\n#define debug(args...) ::detail::wrap(::detail::split(#args, ','), args)\n\n#ifdef USING_BOOST\n\n#include <boost/math/common_factor.hpp>\n#include <boost/range.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/algorithm_ext.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/numeric.hpp>\n\ninline auto rep(int begin, int end) {\n    if (begin > end) {\n        return boost::irange(0, 0);\n    } else {\n        return boost::irange(begin, end);\n    }\n}\n\ninline auto rep(int begin, int end, int step) {\n    if ((step > 0 && begin > end) || (step < 0 && begin < end)) {\n        return boost::irange(0, 0, step);\n    } else {\n        return boost::irange(begin, end, step);\n    }\n}\n\n#endif\n\n#ifdef USING_NAMESPACE\nusing namespace std;\n\n#ifdef USING_BOOST\nusing namespace boost;\nusing namespace boost::adaptors;\n#endif\n#endif\n\n/*** Template End ***/\n\nint n;\nvector<vector<int>> graph;\nvector<bool> used;\n\ndouble dfs(int i) {\n    used[i] = true;\n\n    int cnt = 0;\n    double res = 0.0;\n\n    for (int to : graph[i]) {\n        if (used[to]) {\n            continue;\n        }\n\n        cnt++;\n\n        res += dfs(to) + 1.0;\n    }\n\n    if (cnt == 0) {\n        return 0.0;\n    } else {\n        return res / cnt;\n    }\n}\n\nint main() {\n    in(n);\n    assert(n <= 1000);\n    graph.resize(n);\n    used.resize(n);\n\n    for (int i : rep(0, n - 1)) {\n        int u, v;\n        in(u, v);\n        u--;\n        v--;\n\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i : rep(0, n)) {\n        fill(used, false);\n        out(dfs(i));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n    }\n    double ans;\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || i == n - 1) {\n            ans = (double)(n - 1);\n        } else {\n            ans = (double)(n - 1) / 2.0;\n        }\n        printf(\"%f\\n\", ans);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9;\nconst double EPS = 1e-10;\nconst bool debug = 0;\n//------------------------------//\n\nint N;\nvector<int> g[212345];\ndouble dp[212345], dp2[212345];\n\ndouble dfs1(int u, int pre) {\n\tdouble res = 0.0;\n\tREP(i, g[u].size()) if (g[u][i] != pre)\n\t\tres += dfs1(g[u][i], u) + 1;\n\t\n\tif (g[u].size() > 1) res /= g[u].size() - 1;\n\treturn dp[u] = res;\n}\n\nvoid dfs2(int u, int pre, double par) {\n\tdouble sum = 0.0;\n\tREP(i, g[u].size()) {\n\t\tif (g[u][i] == pre) sum += par + 1;\n\t\telse sum += dp[g[u][i]] + 1;\n\t}\n\t\n\tif (g[u].size() > 0) dp2[u] = sum / g[u].size();\n\t\n\tREP(i, g[u].size()) if (g[u][i] != pre) {\n\t\tdouble d = sum - (dp[g[u][i]] + 1);\n\t\tif (g[u].size() > 1) d /= g[u].size() - 1;\n\t\tdfs2(g[u][i], u, d);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, N - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tdfs1(0, -1);\n\tdfs2(0, -1, 0);\n\t\n\tREP(i, N) printf(\"%.15f\\n\", dp2[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size()-1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n\nint n;\n\n\n#define MAX 150002\nvector<int> v[MAX];\n\nlong double dp[MAX];\nlong double sum[MAX];\n\nint pa[MAX];\n\nint deg[MAX];\n\ninline void dfs(int b, int pr = -1){\n\tpa[b] = pr;\n\tif (v[b].size() == 1 && pr != -1)return;\n\tlong double p = 1.0 / (long double)(v[b].size()-(pr!=-1));\n\tdeg[b] = v[b].size() - (pr != -1);\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (pr == v[b][i])continue;\n\t\tdfs(v[b][i], b);\n\t\tdp[b] += p*(1.0+dp[v[b][i]]);\n\t\tif (v[b].size() - 1){\n\t\t\tlong double pp = 1.0 / (long double)(v[b].size() - 1);\n\t\t\tsum[b] += pp*(1.0 + dp[v[b][i]]);\n\t\t}\n\t}\n}\nmap<int, long double> mp[MAX];\ninline long double rdfs(int b, int pr = -1){\n\tif (pa[b] == pr){\n\t\treturn dp[b];\n\t}\n\tif (mp[b].count(pr)){\n\t\treturn mp[b][pr];\n\t}\n\tif (pr == -1){\n\t\tlong double p = 1.0 / (long double)(v[b].size());\n\t\tmp[b][-1] = 0;\n\t\tfor (int i = 0; i < v[b].size(); i++){\n\t\t\tmp[b][-1] += p*(1.0 + rdfs(v[b][i], b));\n\t\t}\n\t\treturn mp[b][-1];\n\t}\n\tif (v[b].size() == 1){\n\t\tmp[b][pr] = 0;\n\t\treturn 0;\n\t}\n\tlong double nex = sum[b];\n\tlong double p = 1.0 / (long double)(v[b].size() - 1);\n\tnex -= p*(1.0+dp[pr]);\n\tif (b != 0){\n\t\tif (v[b].size() > 1){\n\t\t\tnex += p*(1.0 + rdfs(pa[b], b));\n\t\t}\n\t}\n\tmp[b][pr] = nex;\n\treturn nex;\n}\nint main(){\n\tcin >> n;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tfor (int i = 0; i < n; i++){\n\t\tdouble ans=rdfs(i);\n\t\tprintf(\"%.16f\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int_fast64_t;\nusing ui64 = uint_fast64_t;\n#define REP(i, n) for (i64 (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for (i64 (i) = (a); (i) < (b); ++(i))\n\nint N;\nvector<vector<int>> graph;\n\nvector<double> dp;\ndouble dfs(int cur, int prv = -1) {\n    int child = 0;\n    double sum = 0.0;\n    for (auto& nxt: graph[cur]) {\n        if (nxt == prv) continue;\n        sum += dfs(nxt, cur);\n        ++child;\n    }\n    if (child == 0) {\n        return dp[cur] = 0.0;\n    } else {\n        return dp[cur] = sum / child + 1;\n    }\n}\n\nvector<double> ans;\ndouble reroot(int cur, double d_par, int prv = -1) {\n    int child = 0;\n    double sum = 0.0;\n    for (auto& nxt: graph[cur]) {\n        if (nxt == prv) {\n            sum += d_par;\n        } else {\n            sum += dp[nxt];\n        }\n        ++child;\n    }\n    ans[cur] = sum / child + 1;\n\n    for (auto& nxt: graph[cur]) {\n        if (nxt == prv) continue;\n        double nxt_d_par;\n        if (child == 1) {\n            nxt_d_par = 0;\n        } else {\n            nxt_d_par = (ans[cur] * child - 1 - dp[nxt]) / (child - 1);\n        }\n        reroot(nxt, nxt_d_par, cur);\n    }\n    return ans[cur];\n}\n\nsigned main() {\n\n    cout << fixed << setprecision(20);\n\n    cin >> N;\n\n    graph.resize(N);\n    REP(i, N - 1) {\n        int U, V;\n        cin >> U >> V;\n        --U, --V;\n        graph[U].emplace_back(V);\n        graph[V].emplace_back(U);\n    }\n\n    dp.assign(N, 0);\n    dfs(0);\n\n    ans.assign(N, 0);\n    reroot(0, 0.0);\n\n    REP(i, N) cout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    double p = G[u].size();\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    double p = G[u].size();\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dp2[v] = (dp[u] + 1) + (dp2[u] - dp[v] - 1) / p;\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    dfs(1, -1);\n    dfs2(1, -1);\n    \n    cout<<dp[1]<<endl;\n    for (int i = 2; i <= N; i ++) {\n        double p = G[i].size();\n        printf(\"%f\\n\", (dp[i] * (p - 1) + dp2[i]) / p);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 214514\nvector<int> G[MAX];\nvector<double> L[MAX];\ndouble ans[MAX];\ndouble memo[MAX];\nint n;\ndouble dfs(int v,int p){\n  double res=0;\n  L[v].resize(G[v].size());\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i];\n    if(u==p) continue;\n    L[v][i]=dfs(u,v);\n    //cout<<v<<\":\"<<u<<\"/\"<<k<<endl;\n    res+=L[v][i];\n  }\n  if(G[v].size()==1) return memo[v]=1.0;\n  //cout<<v<<\"-\"<<res<<endl;\n  return memo[v]=(res/(G[v].size()-1))+1.0;\n}\n\n\nvoid dfs2(int v,int p,double x){\n  ans[v]=x;\n  //cout<<v<<\" \"<<x<<endl;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i];\n    if(u==p) continue;\n    ans[v]+=memo[u];\n    //cout<<v<<\" \"<<i<<\":\"<<((memo[v]-1.0)*(G[v].size()-1))<<\" \"<<L[v][i]<<\" \"<<x<<endl;\n    dfs2(u,v,(G[v].size()>1?\n\t      (((memo[v]-1.0)*(G[v].size()-1)-L[v][i]+x)\n\t       /(double)(G[v].size()-1))\n\t       :x)+1.0);\n\t \n  }\n  ans[v]/=G[v].size();\n}\n\nsigned main(){\n  cin>>n;\n  int u[n-1],v[n-1];\n  for(int i=0;i<n-1;i++) cin>>u[i]>>v[i];\n  for(int i=0;i<n-1;i++){\n    u[i]--;v[i]--;\n    G[u[i]].push_back(v[i]);\n    G[v[i]].push_back(u[i]);\n  }\n  dfs(0,-1);\n  dfs2(0,-1,0);\n  //for(int i=0;i<n;i++) printf(\"%.12f\\n\",memo[i]);puts(\"\");\n  for(int i=0;i<n;i++) printf(\"%.12f\\n\",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nint edc[150010];\nvector<int> lis[150010];\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (edc[nod] == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (edc[nod] - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    if (n == 1)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        scanf(\"%d %d\", &edge[i][0], &edge[i][1]);\n        --edge[i][0];\n        --edge[i][1];\n        ++edc[edge[i][0]];\n        ++edc[edge[i][1]];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    double ans[150010];\n    for (int i = 0; i < n; i++)\n    {\n        ans[i] = 0;\n        if (edc[i] == 1 && edge[lis[i][0]][0] + edge[lis[i][0]][1] - i < i)\n        {\n            int j = edge[lis[i][0]][0] + edge[lis[i][0]][1] - i;\n            printf(\"%.9f\\n\", ans[i] = (ans[j] * edc[j] - 1) / (edc[j] - 1) + 1);\n            continue;\n        }\n        for (int item : lis[i])\n        {\n            ans[i] += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        ans[i] /= edc[i];\n        printf(\"%.9f\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<string>\n#define N 100010\nusing namespace std;\nint head[N], k, sz[N];\ndouble E[N], ans[N];\nstruct Edge\n{\n    int v, next;\n}edge[2 * N];\nvoid add_edge(int u, int v)\n{\n    edge[++k].v = v;\n    edge[k].next = head[u];\n    head[u] = k;\n}\nvoid dfs1(int u, int pre)\n{\n    for(int kk = head[u]; ~kk; kk = edge[kk].next)\n    {\n        int v = edge[kk].v;\n        if(v == pre) continue;\n        dfs1(v, u);\n        E[u] += 1.0 / sz[u] * (E[v] + 1);\n    }\n}\nvoid dfs2(int u, int pre)\n{\n    double t = 1.0 / sz[pre] * (E[u] + 1);\n    t = ans[pre] - t;\n    if(sz[pre] != 1)\n        t = t * sz[pre] / (sz[pre] - 1);\n    ans[u] = E[u] * (sz[u] - 1) / sz[u] + 1.0 / sz[u] * (t + 1);\n    for(int kk = head[u]; ~kk; kk = edge[kk].next)\n    {\n        int v = edge[kk].v;\n        if(v == pre) continue;\n        dfs2(v, u);\n    }\n}\nint main()\n{\n    int n, u, v, i;\n    scanf(\"%d\", &n);\n    memset(sz, -1, sizeof(sz));\n    k = -1;\n    memset(head, -1, sizeof(head));\n    for(i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n        sz[u]++;\n        sz[v]++;\n    }\n    sz[1]++;\n    dfs1(1, -1);\n    for(i = 2; i <= n; ++i) sz[i]++;\n    ans[1] = E[1];\n    for(i = head[1]; ~i; i = edge[i].next)\n    {\n        int v = edge[i].v;\n        dfs2(v, 1);\n    }\n    for(i = 1; i <= n; ++i)\n    {\n        printf(\"%.10lf\\n\", ans[i]);\n    }\n    return 0;\n}\n/*\n3\n1 2\n1 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b;\nld dp[150000],dp2[150000],ch[150000],par[150000];\nvector<int> v[150000],u;\nvoid dfs(int a){\n    ld tmp=0.0;\n    for(int x:v[a]){\n        if(ch[x]!=0)continue;\n        ch[x]=1;\n        par[x]=a;\n        dfs(x);\n        tmp+=dp[x]+1.0;\n    }\n    if(a==0)dp[a]=tmp/(ld)v[a].size();\n    else if(v[a].size()>1)dp[a]=tmp/ld(v[a].size()-1.0);\n    else u.push_back(a);\n    return ;\n}\nvoid dfs2(int a){\n    if(dp2[a]>0)return ;\n    if(a==0)return ;\n    dfs2(par[a]);\n    int b=par[a];\n    ld p=v[b].size();\n    //cout<<\"P\"<<p<<\" \"<<b<<endl;\n    if(p==1)dp2[a]=1;\n    else if(b==0)dp2[a]=((dp[b]+1)*p-(dp[a]+2))/(p-1);\n    else if(p>1)dp2[a]=((dp2[b]+1)+(dp[b]+1)*(p-1)-(dp[a]+2))/(p-1);\n    //cout<<a<<\" \"<<dp2[a]<<endl;\n    //cout<<a<<\" \"<<dp2[a]<<\"W\"<<endl;\n    return ;\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(int i=0;i<n;i++)ch[i]=0;\n    ch[0]=1;\n    par[0]=-1;\n    dfs(0);\n    cout<<\"W\"<<endl;\n    for(auto x:u){\n        for(int i=0;i<n;i++)ch[i]=0;\n        ch[x]=1;\n        dfs2(x);\n    }\n    for(int i=0;i<n;i++){\n        //cout<<dp[i]<<\" \"<<dp2[i]<<endl;\n        if(i==0)cout<<setprecision(15)<<dp[i]<<endl;\n        else cout<<setprecision(15)<<(dp[i]*ld(v[i].size()-1)+dp2[i])/(ld)v[i].size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define REP(i,n) for(int i=0,_n=(n);i<_n;++i)\n#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)\n\ntypedef long long llong;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\n#define MAXN 150004\nint N;\nVI adj[MAXN];\n\nint par[MAXN];\nint nchildren[MAXN];\ndouble E_down[MAXN];\ndouble sum_children_E[MAXN];\nvoid dfs1(int u) {\n   nchildren[u] = 0;\n   sum_children_E[u] = 0.0;\n   for (int v : adj[u]) {\n      if (v != par[u]) {\n         par[v] = u;\n         nchildren[u]++;\n         dfs1(v);\n         sum_children_E[u] += E_down[v];\n      }\n   }\n   if (nchildren[u] == 0)\n      E_down[u] = 0.0;\n   else\n      E_down[u] = 1 + sum_children_E[u] / nchildren[u];\n}\n\ndouble E_up[MAXN];\ndouble E[MAXN];\nvoid dfs2(int u) {\n   int p = par[u];\n   if (p == -1) {\n      E_up[u] = 0.0;\n      E[u] = E_down[u];\n   }\n   else {\n      E_up[u] = 1 + (E_up[p] + (sum_children_E[p] - E_down[u]) + nchildren[p] - 1) / nchildren[p];\n      E[u] = E_up[u] / (nchildren[u]+1) + E_down[u] * nchildren[u] * 1.0 / (nchildren[u]+1);\n   }\n   for (int v : adj[u]) {\n      if (v != p)\n         dfs2(v);\n   }\n}\n\nint main(int argc, char* argv[]) {\n   scanf(\"%d\", &N);\n   REP(j, N-1) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      --u, --v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n   }\n\n   par[0] = -1;\n   dfs1(0);\n\n   dfs2(0);\n\n   REP(u, N) {\n   // fprintf(stderr, \"%d: Edown=%.05f  Eup=%.05f  E=%.05f\\n\", u+1, E_down[u], E_up[u], E[u]);\n      printf(\"%.010f\\n\", E[u]);\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nvector<vector<int>> G;\nvector<double> up, down, ans;\nvoid recur1(int node, int prev) {\n    vector<int> A;\n    for (int next : G[node]) if (next != prev) A.push_back(next);\n    for (int next : A) {\n        recur1(next, node);\n        down[node] += down[next];\n    }\n    if (A.size() != 0) {\n        down[node] /= A.size();\n    }\n    down[node] += 1;\n}\nvoid recur2(int node, int prev) {\n    double total = 0;\n    int cnt = 0;\n    if (prev == -1) {\n        up[node] = 0;\n        ans[node] = down[node];\n    } else {\n        total += up[node];\n        cnt += 1;\n    }\n    for (int next : G[node]) if (next != prev) {\n        total += down[next];\n        cnt += 1;\n    }\n    ans[node] = total / cnt;\n    for (int next : G[node]) if (next != prev) {\n        if (cnt == 1) {\n            up[next] = 1;\n        } else {\n            up[next] = 1 + (total - down[next]) / (cnt - 1);\n        }\n        recur2(next, node);\n    }\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int N; cin >> N;\n    G.resize(N), up.resize(N), down.resize(N), ans.resize(N);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v; cin >> u >> v; u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    recur1(0, -1);\n    recur2(0, -1);\n    cout << fixed << setprecision(9);\n    for (int i = 0; i < N; i++) {\n        cout << ans[i] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define eb emplace_back\n#define sz(s) ((int) s.size ())\n#define all(s) (s.begin (), s.end ())\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = (int) 2e5 + 5;\nconst int mod = (int) 1e9 + 7;\n\ndouble d[N], ans[N];\nvector<int> g[N];\nint n;\n\nvoid dfs (int v, int p = -1) {\n        d[v] = 0;\n        for (int to : g[v]) {\n                if (to != p) {\n                        dfs (to, v);\n                        if (sz (g[to]) > 1) {\n                                d[v] += d[to] / (sz (g[to]) - 1);\n                        }\n                }\n        }\n        d[v] += sz (g[v]) - (p != -1);\n}\n\nvoid sdfs (int v, int p = -1, double u = 0) {\n//        printf (\"%d %.6f\\n\", v, u);\n        ans[v] = (u + d[v]) / sz (g[v]);\n        for (int to : g[v]) {\n                if (to != p) {\n                        double cur = d[v] + u - 1;\n                        if (sz (g[to]) > 1) {\n                                cur -= d[to] / (sz (g[to]) - 1);\n                        }\n                        if (sz (g[v]) > 1) {\n                                cur /= sz (g[v]) - 1;\n                        }\n                        sdfs (to, v, cur + 1);\n                }\n        }\n}\n\ninline void solve () {\n        scanf (\"%d\", &n);\n        for (int i = 1; i < n; i++) {\n                int x, y;\n                scanf (\"%d%d\", &x, &y);\n                g[x].emplace_back (y);\n                g[y].emplace_back (x);\n        }\n        dfs (1); sdfs (1);\n        for (int i = 1; i <= n; i++) {\n                printf (\"%.6f\\n\", ans[i]);\n        }\n}\n\nint tests = 1;\n\nint main () {\n//        freopen (\".in\", \"r\", stdin);\n//        freopen (\".out\", \"w\", stdout);\n//        scanf (\"%d\", &tests);\n        while (tests--) {\n                solve ();\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define uint unsigned int\n#define pii pair<int, int>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORR(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) FOR(i,0,n)\n#define REPR(i,n) FORR(i,n,0)\n#define ALL(c) ((c).begin()), ((c).end())\n\n#define PB(a) push_back(a)\n#define EMPB(...) emplace_back(__VA_ARGS__)\n#define EMP(...) emplace(__VA_ARGS__)\n#define MP(a,b) make_pair(a,b)\n#define MT(...) make_tuple(__VA_ARGS__)\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n\n#define PW(n) (1LL << (n))\n\nusing namespace std;\n\ntemplate <class T> inline bool CHMIN(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate <class T> inline bool CHMAX(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <class T> inline void SORT(T &a) { sort(a.begin(), a.end()); }\ntemplate <class T> inline void REV(T &a) { reverse(a.begin(), a.end()); }\ntemplate <class T> inline void UNI(T &a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate <class S, class T> ostream& operator << (ostream& os, const pair<S, T> v) {\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\n\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N;\nvector<int> G[150010];\ndouble dp1[150010];\ndouble dp2[150010];\n\nvoid dfs1(int v, int pv) {\n  int num = G[v].size();\n  if (!(pv < 0)) num--;\n  for (int& nv : G[v]) if (nv != pv) {\n    dfs1(nv, v);\n    dp1[v] += (dp1[nv] + 1) / num;\n  }\n}\n\nvoid dfs2(int v, int pv, double d_pv) {\n  double sum = 0;\n  for (int& nv : G[v]) {\n    sum += (nv == pv ? d_pv : dp1[nv]) + 1;\n  }\n  dp2[v] = sum / G[v].size();\n  for (int& nv : G[v]) if (nv != pv) {\n    double d_v = (G[v].size() == 1 ? 0 : (sum - dp1[nv] - 1) / (G[v].size() - 1));\n    dfs2(nv, v, d_v);\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> N;\n  REP(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    G[u].PB(v);\n    G[v].PB(u);\n  }\n  dfs1(0, -1);\n  dfs2(0, -1, 0);\n  REP(i, N) cout << dp2[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007,N=150001;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\nvector<vector<ll> > v(N);\nll pa[N];\ndouble dpin[N],dpout[N];\nvoid dfs1(ll now,ll p){\n\tpa[now]=p;\n\tdouble ans=0.0;\n\tdouble sum=double(v[now].size());\n\tif(p!=-1)sum-=1.0;\n\tif(sum==0){\n\t\tdpin[now]=1.0;\n\t\treturn;\n\t}\n\n\tfor(auto& to:v[now]){\n\t\tif(to==p)continue;\n\t\tdfs1(to,now);\n\t\tans+=dpin[to];\n\t}\n\tans/=sum;\n\tdpin[now]=ans+1;\n\treturn;\n}\nvoid dfs2(ll now,ll p){\n\tvector<double> v1,v2;\n\tll niko=v[now].size();\n\tdouble s=double(niko)-1.0;\n\tfor(auto& to:v[now]){\n\t\tif(to==p)v1.pb(dpout[now]),v2.pb(dpout[now]);\n\t\telse v1.pb(dpin[to]),v2.pb(dpin[to]);\n\t}\n\tfor(int i=1;i<niko;i++){\n\t\tv1[i]+=v1[i-1];\n\t}\n\tfor(int i=niko-2;i>=0;i--){\n\t\tv2[i]+=v2[i+1];\n\t}\n\tfor(int i=0;i<niko;i++){\n\t\tint to=v[now][i];\n\t\tif(to==p)continue;\n\t\tdouble ans=0;\n\t\tif(i>0)ans+=v1[i-1];\n\t\tif(i<niko-1)ans+=v2[i+1];\n\t\tif(niko==1)s=1;\n\t\tans/=s;\n\n\t\tdpout[to]=ans+1.0;\n\t\tdfs2(to,now);\n\t}\n\treturn;\n}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,a,b;\n    cin>>n;\n    for(int i=1;i<n;i++){\n    \tcin>>a>>b;\n    \ta--;b--;\n    \tv[a].pb(b);\n    \tv[b].pb(a);\n    }\n    if(n==1){\n    \tcout << 0 <<endl;\n    \treturn 0;\n    }\n    dfs1(0,-1);\n    dpout[0]=0.0;\n    dfs2(0,-1);\n    for(int i=0;i<n;i++){\n    \tdouble ans=0;\n    \tdouble sum=double(v[i].size());\n    \tans+=dpout[i];\n    \tfor(auto& to:v[i]){\n    \t\tif(to==pa[i])continue;\n    \t\tans+=dpin[to];\n    \t}\n    \tdoublecout(ans/sum);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)-form-)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n\ntemplate <class N, class E>\nstruct Rerooting {\n\tint n;\n\tconst vector<vector<E>>& G;\n\tvector<N> subtreesum;\n\tvector<vector<N>> dp; // L\n\tvoid dfs1(int v, int p) {\n\t\tsubtreesum[v] = N();\n\t\tfor (auto e : G[v]) {\n\t\t\tint nx = e.to;\n\t\t\tif (nx == p) continue;\n\t\t\tdfs1(nx, v);\n\t\t\tsubtreesum[v] = subtreesum[v] + subtreesum[nx].include_e(v, e);\n\t\t}\n\t\tsubtreesum[v] = subtreesum[v].include_v(v);\n\t}\n\tvoid dfs2(int v, int p, N top) {\n\t\tint deg = int(G[v].size());\n\t\tdp[v] = vector<N>(deg + 1);\n\t\tdp[v][0] = N();\n\t\tfor (int i = 0; i < deg; i++) {\n\t\t\tint nx = G[v][i].to;\n\t\t\tdp[v][i + 1] =\n\t\t\t\tdp[v][i] + (nx == p ? top : subtreesum[nx]).include_e(v, G[v][i]);\n\t\t}\n\t\tN rnode = N();\n\t\tdp[v].back() = dp[v].back().include_v(v);\n\t\tfor (int i = deg - 1; i >= 0; i--) {\n\t\t\tdp[v][i] = (dp[v][i] + rnode).include_v(v);\n\t\t\tint nx = G[v][i].to;\n\t\t\tif (nx != p) dfs2(nx, v, dp[v][i]);\n\t\t\trnode = rnode + (nx == p ? top : subtreesum[nx]).include_e(v, G[v][i]);\n\t\t}\n\t}\n\tRerooting(const vector<vector<E>>& _g) : n(int(_g.size())), G(_g), subtreesum(n), dp(n) {\n\t\tdfs1(0, -1);\n\t\tdfs2(0, -1, N());\n\t}\n};\n\ntemplate <class N, class E> vector<vector<N>> Rerooting_get(const vector<vector<E>>& g) {\n\treturn Rerooting<N, E>(g).dp;\n}\n\ninline int ri() { int in; int y = scanf(\"%d\", &in); return in; }\ninline void oi(int i) { printf(\"%d\\n\", i); }\ninline void od(double i) { printf(\"%.9f\\n\", i); }\n\n\n\n\nvoid solve_S8PC_4_D() {\n\tint N = ri();\n\tstruct Edge\n\t{\n\t\tint to;\n\t\tEdge(int t) :to(t) {}\n\t};\n\tvector<vector<Edge>>G(N);\n\tFOR(i, 0, N - 1) {\n\t\tint s = ri() - 1, t = ri() - 1;\n\t\tG[s].push_back(Edge(t));\n\t\tG[t].push_back(Edge(s));\n\t}\n\n\tstruct Node {\n\t\tdouble E;\n\t\tint childs;\n\t\tNode(double e = 0, int c = 0) :E(e), childs(c) {}\n\t\tNode include_e(int, const Edge&) const {\n\t\t\tdouble resE = 0;\n\t\t\tif (childs) {\n\t\t\t\tresE = E / childs;\n\t\t\t}\n\t\t\tresE += 1.0;\n\t\t\treturn Node(resE, 1);\n\t\t}\n\t\tNode operator + (const Node& r) const {\n\t\t\t// tree-tree\n\t\t\treturn Node(E + r.E, childs + r.childs);\n\t\t}\n\t\tNode include_v(int) const {\n\t\t\treturn *this;\n\t\t}\n\t};\n\n\tauto tree_res = Rerooting_get<Node>(G);\n\tFOR(i, 0, N) {\n\t\tNode it = tree_res[i].back();\n\t\tdouble ans = 0;\n\t\tDD(de(i + 1, it.E, it.childs));\n\t\tif (it.childs) {\n\t\t\tans = it.E / it.childs;\n\t\t}\n\t\tod(ans);\n\t}\n}\n\nint main() {\n\tsolve_S8PC_4_D();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nint n,a,b,ok,ch[15000],L;\nvector<int> v[15000];\nld ans[15000];\nmap<int,int>mp;\n/*\nvoid dfs(int A){\n    if(mp[A]==1)ans[A]=n-1;\n    else ans[A]=ld(n-1)/2.0;\n    for(auto x:v[A]){\n        if(ch[x]!=0)continue;\n        ch[x]=ch[A]+1;\n        dfs(x);\n    }\n    return ;\n}*/\nint main(void){\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        cin>>a>>b;\n        a--,b--;\n        mp[a]++;\n        mp[b]++;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for(auto x:mp){\n        if(x.second>2)ok=1;\n    }\n    if(ok==0){\n        for(int i=0;i<n;i++){\n            if(mp[i]==1)ans[i]=n-1;\n            else ans[i]=(ld)(n-1)/2.0;\n        }\n    }\n    for(int i=0;i<n;i++){\n        cout<<ans[i]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\n\nvector<int> G[maxn];\nint deg[maxn];\n\ndouble ans = 0;\n\nvoid dfs(int u, int fa, double p) {\n    for (int v : G[u]) if (v != fa) {\n        ans += p;\n//        if (deg[v] == 1) return;\n        double x = deg[v] - 1;\n        dfs(v, u, p / x);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        deg[u] ++, deg[v] ++;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; i ++) {\n        ans = 0;\n        dfs(i, -1, 1.0 / deg[i]);\n        printf(\"%.6f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define maxn 150010\nstruct Edge {\n\tEdge *next;\n\tint to;\n} *last[maxn], e[maxn << 1], *ecnt = e;\nint deg[maxn];\ninline void link(int a, int b)\n{\n\t++deg[a]; ++deg[b];\n\t*++ecnt = (Edge) {last[a], b}; last[a] = ecnt;\n\t*++ecnt = (Edge) {last[b], a}; last[b] = ecnt;\n}\ndouble f[maxn], g[maxn];\nvoid dfs1(int x, int fa)\n{\n\tfor (Edge *iter = last[x]; iter; iter = iter -> next)\n\t\tif (iter -> to != fa)\n\t\t{\n\t\t\tdfs1(iter -> to, x);\n\t\t\tf[x] += f[iter -> to] / (deg[iter -> to] > 1 ? deg[iter -> to] - 1 : 1) + 1;\n\t\t}\n}\nvoid dfs2(int x, int fa)\n{\n\tfor (Edge *iter = last[x]; iter; iter = iter -> next)\n\t\tif (iter -> to != fa)\n\t\t{\n\t\t\tg[iter -> to] = (f[x] - f[iter -> to] / (deg[iter -> to] > 1 ? deg[iter -> to] - 1 : 1) - 1 + g[x]) / (deg[x] > 1 ? deg[x] - 1 : deg[x]) + 1;\n\t\t\tdfs2(iter -> to, x);\n\t\t}\n}\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b); link(a, b);\n\t}\n/*\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(f, 0, sizeof (f));\n\t\tdfs1(i, 0);\n\t\tprintf(\"%.12lf\\n\", f[i] / deg[i]);\n\t}*/\n\tdfs1(1, 0); dfs2(1, 0);\n//\tprintf(\"%.12lf %.12lf\\n\", g[2], f[1]);\n\tfor (int i = 1; i <= n; ++i) printf(\"%.12lf\\n\", (f[i] + g[i]) / deg[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Majk\n */\n\n#include <vector>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\n#define x first\n#define y second\nconstexpr int MOD = 1000000007;\n\ntypedef std::pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned int ui;\n\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector<vector<T>>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector<vector<T>>>(a,vector<vector<T>>(b,vector<T>(c,t))){}};\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n\tint N;\n\tvector<vector<int>> E;\n\tunordered_map<pii, double> C;\n\n\tdouble count(int u, int v) {\n\t\tauto it = C.find({u,v});\n\t\tif (it != C.end()) return it->y;\n\t\tdouble ans = 0.0;\n\t\tint cnt = 0;\n\n\t\tfor (int w: E[u]) if (v!=w) {\n\t\t\t\t++cnt;\n\t\t\t\tans += 1+count(w,u);\n\t\t\t}\n\n\t\tif (cnt > 0) ans /= cnt;\n\t\treturn C[{u,v}] = ans;\n\t}\n\n\tvoid solve(istream& cin, ostream& cout) {\n\t\tcin >> N; E.clear(); E.resize(N);\n\t\tC.clear();\n\t\tfor (int i = 0; i < N-1; ++i) {\n\t\t\tint u,v; cin >> u >> v; --u; --v;\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\n\t\tcout << fixed << setprecision(10);\n\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << count(j, -1) << '\\n';\n\t\t}\n\n\t}\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[150000];\ndouble sum1[150000];\ndouble sum2[150000];\ndouble dp1[150000];\ndouble dp2[150000];\ndouble M[150000];\ndouble ans[150000];\n\ndouble dfs1(int v, int p){\n\tM[v] = G[v].size();\n\tif(p != -1) M[v]--;\n\tif(M[v] == 0) return 0;\n\n\tfor(auto c : G[v]){\n\t\tif(c == p) continue;\n\t\tsum1[v] += dfs1(c, v) + 1;\n\t}\n\treturn dp1[v] = sum1[v] / M[v];\n}\n\nvoid dfs2(int v, int p){\n\tfor(auto c : G[v]){\n\t\tif(c == p) continue;\n\t\tsum2[v] += dp1[c] + 1.0;\n\t}\n\tif(p != -1){\n\t\tif(G[p].size() != 1){\n\t\t\tsum2[v] += (sum2[p] - (dp1[v] + 1.0)) / (G[p].size() - 1) + 1.0;\n\t\t}\n\t\telse{\n\t\t\tsum2[v] += 1.0;\n\t\t}\n\t}\n\tans[v] = sum2[v] / G[v].size();\n\tfor(auto c : G[v]){\n\t\tif(c == p) continue;\n\t\tdfs2(c, v);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tdfs1(0, -1);\n\tdfs2(0, -1);\n\tfor(int i = 0; i < N; i++){\n\t\tcout << fixed << setprecision(15) << ans[i] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string.h>\n#include<iostream>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<string.h>\n#include<algorithm>\n#include <stdlib.h>\n#include<queue>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\nbool board[100005][7];\n\nint main(){\n    int n;\n    vector<vector<int> >v(n);\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    int root=-1,end=-1;\n    for(int i=0;i<n;i++){\n        if(v[i].size()==1){\n            if(root==-1)root=i;\n            else end=i;\n        }\n    }\n    vector<int>no(n);\n    no[root]=0;\n    no[end]=n-1;\n    int cur=root;\n    int ii=1;\n    while(cur!=root){\n        if(cur!=v[cur][0])cur=v[cur][0];\n        else cur=v[cur][1];\n        no[cur]=ii++;\n    }\n    vector<double>p(n);\n    for(int i=0;i<n;i++){\n        p[i]=(1.0*no[i]+n-1-no[i])/2.0;\n    }\n    for(int i=0;i<n;i++){\n        cout<<p[i]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\nvector<int>G[1<<18];\ndouble dp[1<<18];\ndouble dp2[1<<18];\ndouble dfs(int u,int p)\n{\n\tint cnt=0;double ans=0;\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(G[u][i]==p)continue;\n\t\tans+=dfs(G[u][i],u)+1;\n\t\tcnt++;\n\t}\n\treturn dp[u]=cnt?ans/cnt:1;\n}\nvoid dfs2(int u,int p,double a)\n{\n\tdouble ans=0;\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(G[u][i]==p)ans+=a;\n\t\telse ans+=dp[G[u][i]];\n\t}\n\tdp2[u]=ans/G[u].size();\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(G[u][i]==p)continue;\n\t\tdfs2(G[u][i],u,1+(ans-dp[G[u][i]])/max(1,(int)G[u].size()-1));\n\t}\n}\nmain()\n{\n\tint n;cin>>n;int u,v;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tdfs2(1,0,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<fixed<<setprecision(9)<<dp2[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\n\nstruct edge{ int to,cost; };\nconst int N = 2e5+10;\nvector<vector<edge>> G(N);\nvector<double> dp(N),dp2(N);\n\nvoid dfs1(int u,int pre){\n  double res = 0;\n  int child = 0;\n  for(auto e : G[u]){\n    if(e.to == pre) continue;\n    dfs1(e.to,u);\n    res += dp[e.to] + 1.0;\n    child++;\n  }\n  if(child > 0) dp[u] = res / child;\n  else dp[u] = 0;\n}\n\nvoid dfs2(int u,int pre,double d_par){\n  double res = 0;\n  for(auto e : G[u]){\n    if(e.to == pre) res += d_par + 1;\n    else res += dp[e.to] + 1;\n  }\n  dp2[u] = res / G[u].size();\n\n  for(auto e : G[u]){\n    if(e.to == pre) continue;\n    dfs2(e.to,u,(res - dp[e.to] - 1) / (G[u].size() - 1.0));\n  }\n}\n\nsigned main(){\n\n  int n; cin >> n;\n  for(int i = 0; i < n-1; i++){\n    int s,t; cin >> s >> t;\n    s--,t--;\n    G[s].push_back({t,1});\n    G[t].push_back({s,1});\n  }\n  if(n <= 2){\n    cout << 1 << endl << 1 << endl;\n    return 0;\n  }\n\n  int root = 0;\n  for(int i = 0; i < n; i++){\n    if(G[i].size() >= 2) root = i;\n  }\n\n  dfs1(root,-1);\n  dfs2(root,-1,0);\n  for(int i = 0; i < n; i++){\n    printf(\"%.6f\\n\",dp2[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#ifdef WINT_MIN\n#define __MAI\n#endif\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define debugv(v) printf(\"L%d %s => \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;\n#define debugm(m) printf(\"L%d %s is..\\n\",__LINE__,#m);for(auto v:m){for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) printf(\"L%d %s is => \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;\n#define debugaa(m,w,h) printf(\"L%d %s is..\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[x][y]<<\" \";}cout<<endl;}\n#define debugaar(m,w,h) printf(\"L%d %s is..\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}\n#define ALL(v) (v).begin(),(v).end()\n#define BIGINT 0x7FFFFFFF\n#define E107 1000000007ll\nvoid printbit(int u) { if (u == 0)cout << 0; else { int s = 0, k = 0; for (; 0<u; u >>= 1, k++)s = (s << 1) | (u & 1); for (; 0<k--; s >>= 1)cout << (s & 1); } }template<typename T1, typename T2>\n    ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\n\n#define TIME chrono::system_clock::now()\n#define MILLISEC(t) (chrono::duration_cast<chrono::milliseconds>(t).count())\n\nnamespace {\n    std::chrono::system_clock::time_point t;\n    void tic() { t = TIME; }\n    void toc() { fprintf(stderr, \"TIME : %lldms\\n\", MILLISEC(TIME - t)); }\n    std::chrono::system_clock::time_point tle = TIME;\n#ifdef __MAI\n    void safe_tle(int msec) { assert(MILLISEC(TIME - tle) < msec); }\n#else\n#define safe_tle(k) ;\n#endif\n}\n\n#ifndef __MAI \nnamespace {\n    class MaiScanner {\n    public:\n        template<typename T>\n        void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        void ign() { getchar_unlocked(); }\n        MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\n#else\n#define scanner cin\n#endif\n\nclass UndirectedGraphE {\npublic:\n    size_t n;\n    struct Edge {\n        int u, v;\n        Edge(int from = 0, int to = 0) :u(from), v(to) {}\n\n        int to(int _v) { return _v == v ? u : v; }\n    };\n    vector<vector<int>> vertex_to;\n    vector<Edge> edge;\n\n    UndirectedGraphE(int n, int m = 5010) :n(n), vertex_to(n) { edge.reserve(m); }\n\n    void connect(int from, int to) {\n        vertex_to[from].push_back(edge.size()); // toto\n        vertex_to[to].push_back(edge.size()); // fromfrom\n        edge.emplace_back(from, to);\n    }\n    size_t degree(int v) {\n        return vertex_to[v].size();\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\n\nint width, height;\nint m, n, kei;\n\nGraph graph(0);\nint visit[200010];\n\nint idx[200010];\n\nint dfs(int v, int walk = 1) {\n    if (visit[v]) return 0;\n    visit[v] = walk;\n    ++walk;\n    int r = 0;\n    for (int u : graph.vertex_to[v]) {\n        r = max(r, dfs(u, walk));\n    }\n    return r + 1;\n}\n\nint result[200010];\n\nint main() {\n    int i, j, k;\n    int x, y, a, b;\n\n\n    scanner >> n;\n    m = n - 1;\n\n    graph.resize(n);\n\n    for (i = 0; i < m; ++i) {\n        scanner >> a >> b;\n        --a; --b;\n        graph.connect(a, b);\n    }\n\n    x = (find(visit, visit + n, dfs(0)) - visit);\n\n    fill(visit, visit + n, 0);\n\n    y = (find(visit, visit + n, dfs(x)) - visit);\n\n    assert(visit[y]-1 == m);\n    \n    result[0] = result[n - 1] = (n - 1) * 2;\n    for (i = 1; i < n-1; ++i) {\n        result[i] = (n-1-i)+(i);\n    }\n\n    for (i = 0; i < n; ++i) {\n        cout << 0.5*result[visit[i] - 1] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI g[100010];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[a].PB(b);\n    g[b].PB(a);\n  }\n\n  vector<double> prob(n);\n  function<double(int,int)> dfs1 = [&](int v, int p) -> double {\n    if(p != -1 && g[v].size() == 1) return 0;\n    int cnt = 0;\n    double ret = 0;\n    for(int &i: g[v]) {\n      if(i == p) continue;\n      cnt++;\n      ret += dfs1(i, v) + 1;\n    }\n    ret /= cnt;\n    return prob[v] = ret;\n  };\n\n  dfs1(0, -1);\n  // cout << prob << endl;\n\n  vector<double> ans(n);\n  function<void(int,double,int)> dfs2 = [&](int v, double d_par, int p) {\n    // cout << v << \" \" << d_par << \" \" << p << endl;\n    // vector<PII> d_child;\n    // d_child.emplace_back(0, -1);\n    double ret = 0;\n    for(int &e : g[v]) {\n      if(e == p) {\n        ret += d_par + 1;\n      } else {\n        ret += prob[e] + 1;\n      }\n    }\n    // sort(d_child.rbegin(), d_child.rend());\n    ans[v] = ret / g[v].size();\n    for(int &e : g[v]) {\n      if(e == p) continue;\n      double nxt = g[v].size() == 1 ? 0 : (ret - prob[e] - 1) / (g[v].size() - 1);\n      dfs2(e, nxt, v);\n    }\n  };\n\n  dfs2(0, 0, -1);\n  REP(i, n) {\n    cout << fixed << setprecision(9) << ans[i] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, l, r) for (int i = (int)(l); i < (int)(r); i++)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((int)x.size())\ntemplate <class T> bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <class T> using V = vector<T>;\nusing P = pair<int, int>;\n\n/*\n *  */\n\nconst int inf = 1LL<<60;\n\nint n;\nV<int> es[151010];\ndouble dp[151010];\ndouble ans[151010];\n\nvoid dfs(int v, int p){\n  double sum = 0;\n  int k = 0;\n  for(auto to : es[v]){\n    if(to == p) continue;\n    dfs(to, v);\n    sum += dp[to]+1.0;\n    k++;\n  }\n\n  if(k) dp[v] += sum/k;\n}\n\ndouble dfs2(int v, int p, double d_p){\n  double sum = 0;\n  for(auto to : es[v]){\n    if(to == p){\n      sum += d_p + 1.0;\n    }else{\n      sum += dp[to] + 1.0;\n    }\n  }\n\n  int k = sz(es[v]);\n  ans[v] = sum/k;\n\n  for(auto to : es[v]){\n    if(to == p) continue;\n    dfs2(to, v, (sum-dp[to]-1.0)/max(1LL, k-1));\n  }\n}\n\nsigned main() {\n  cin >> n;\n  rep(i, 0, n-1){\n    int a, b;\n    cin >> a >> b;\n    a--; b--;\n    es[a].emplace_back(b);\n    es[b].emplace_back(a);\n  }\n\n  dfs(0, -1);\n  dfs2(0, -1, 0);\n  rep(i, 0, n){\n    printf(\"%.12f\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nint n;\nint deg[150005], par[150005];\nLdouble dp[150005], dp2[150005];\nLdouble ans[150005];\n\nvector<int> v[150005];\n\nvoid dfs(int id, int pv){\n\tpar[id] = pv;\n\tfor(auto to: v[id]){\n\t\tif(to == pv) continue;\n\t\tdfs(to, id);\n\t\tdeg[id]++;\n\t\tdp[id] += dp2[to] + 1;\n\t}\n\tif(deg[id]) dp2[id] = dp[id] / deg[id];\n\treturn;\n}\n\nvoid calc(int id, int pv, Ldouble up){\n\t\n//\tprintf(\"%d %d %.10lf\\n\", id, pv, (double)up);\n\t\n\tif(pv == 0) ans[id] = dp2[id];\n\telse ans[id] = (dp[id] + up) / (deg[id] + 1);\n\t\n\tfor(auto to: v[id]){\n\t\tif(to == pv) continue;\n\t\tif(pv == 0){\n\t\t\tif(deg[id] == 1) calc(to, id, 1.0);\n\t\t\telse calc(to, id, (dp[id] - (1 + dp2[to])) / (deg[id] - 1) + 1);\n\t\t}\n\t\telse calc(to, id, ((dp[id] - (1 + dp2[to])) + up) / deg[id] + 1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFI(i, 2, n){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tcalc(1, 0, 0.0);\n//\tFI(i, 1, n) printf(\"%d: %.10lf %.10lf\\n\", i, (double)dp[i], (double)dp2[i]);\n\tFI(i, 1, n) printf(\"%.10lf\\n\", (double)ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip>\n\nusing namespace std;\n\nint n;\nvector<vector<int>> edges(150000 + 10);\n\nvoid read() {\n    cin >> n;\n    for(int i = 1; i <= n - 1; i++) {\n\n        int x, y;\n        cin >> x >> y;\n        edges[x].push_back(y);\n        edges[y].push_back(x);\n    }\n}\n\nint par[150000 + 10], co[150000 + 10];\ndouble expected[150000 + 10], result[150000 + 10];\n\ndouble dfs(int node, int parent) {\n    par[node] = parent;\n    for(int son : edges[node]) {\n        if(son != parent)\n        dfs(son, node);\n    }\n    for(int son : edges[node]) {\n        if(son != parent) {\n                co[node]++;\n        }\n    }\n    if(co[node])\n    for(int son : edges[node]) {\n        if(son != parent)\n        expected[node] += (1 + expected[son]) / (double)co[node];\n    }\n}\n\n\nvoid dfs1(int node, int parent) {\n    if(node == 1) {\n        result[1] = expected[1];\n    }\n    else{\n    result[node] = ((double) co[node]/ ((double) (co[node] + 1))) * expected[node];\n    if(par[node] != 1) {\n        double res = (double) result[par[node]] * (co[par[node]] + 1) - expected[node] - 1;\n        res = res / (double)(co[par[node]]);\n        res++;\n        result[node] += 1/((double)(co[node] + 1)) * res;\n    } else {\n        if(par[node] == 1 && co[1] >= 2) {\n            double res = (double) result[par[node]] * (co[par[node]]) - expected[node] - 1;\n            res = res / (double)(co[par[node]] - 1);\n            res++;\n            result[node] += 1/((double)(co[node] + 1)) * res;\n        } else {\n            result[node] += 1/(double)(1 + co[node]);\n        }\n    }\n    }\n    for(int i : edges[node]) {\n        if(i != parent) {\n            dfs1(i, node);\n        }\n    }\n}\n\nvoid solve() {\n    dfs1(1, 0);\n    for(int i = 1; i <= n; i++) {\n        cout << setprecision(15) << result[i] << endl;\n    }\n\n}\n\nint main()\n{\n    read();\n    dfs(1, 0);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\ntypedef long double ld;\n\nint n;\nvector<int> t[150000];\nbool used[150000];\nvector<int> g[150000];\nld e[150000];\nld ans[150000];\n\nvoid make_graph(int i){\n    used[i] = true;\n    for(int v: t[i]){\n        if(!used[v]){\n            g[i].push_back(v);\n            make_graph(v);\n        }\n    }\n}\n\nld dfs(int i){\n    ld c = 0;\n    for(int v: g[i]){\n        c += dfs(v) + 1;\n    }\n    return e[i] = c / max((int)g[i].size(), 1);\n}\n\nvoid solve(int i, ld u){\n    if(i == 0){\n        ans[i] = e[i];\n        ld s = 0;\n        for(int v: g[i]){\n            s += e[v];\n        }\n        for(int v: g[i]){\n            solve(v, g[i].size() == 1 ? 0 : (s - e[v]) / (g[i].size() - 1) + 1);\n        }\n        return;\n    }\n    ans[i] = (u + 1 + g[i].size() * e[i]) / (g[i].size() + 1);\n    ld s = 0;\n    for(int v: g[i]){\n        s += e[v];\n    }\n    for(int v: g[i]){\n        solve(v, (s - e[v] + u) / g[i].size() + 1);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        t[u - 1].push_back(v - 1);\n        t[v - 1].push_back(u - 1);\n    }\n\n    make_graph(0);\n\n    dfs(0);\n\n    solve(0, -1);\n\n    rep(i, n){\n        cout << fixed << setprecision(10) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(bool& v)noexcept { char c; InputF(c); v = c == '1'; }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\tfor (int i = 0; i < H; ++i)for (int j = 0; j < W; ++j)ret[j].push_back(InputF<T>());\n\t\treturn ret;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define input2(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) input2(int, __VA_ARGS__)\n#define LL(...) input2(ll, __VA_ARGS__)\n#define STRING(...) input2(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(ll v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tOutput& operator()() { printf(\"%s\", D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; return *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() { cout.flush(); return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It()noexcept : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s)noexcept : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++()noexcept { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int)noexcept { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const noexcept { return a; }\n\t\tconstexpr const T* operator->()const noexcept { return &a; }\n\t\tconstexpr bool operator==(const It& i)const noexcept { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const noexcept { return !(b == i.b); }\n\t\tconstexpr T start()const noexcept { return a; }\n\t\tconstexpr T count()const noexcept { return b; }\n\t\tconstexpr T step()const noexcept { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s)noexcept : be(b, c, s) {}\n\tconstexpr It begin()const noexcept { return be; }\n\tconstexpr It end()const noexcept { return en; }\n\tconstexpr T start()const noexcept { return be.start(); }\n\tconstexpr T count()const noexcept { return be.count(); }\n\tconstexpr T step()const noexcept { return be.step(); }\n\toperator vector<T>()const noexcept { return as_vector(); }\n\tvector<T> as_vector()const noexcept {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const noexcept { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const noexcept {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const noexcept {\n\t\tint res = 0; each([&](T i) {i += f(i); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const noexcept {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto sum(const F& f)const noexcept {\n\t\tdecay_t<result_of_t<F(T)>> res = 0; each([&](T i) {res += f(i); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a)noexcept { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b)noexcept { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c)noexcept { return Step<T>(a, (b - a - 1) / c + 1, c); }\n\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f)noexcept {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f)noexcept {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\n\ttemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f)noexcept {\n\t\treturn max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f)noexcept {\n\t\treturn min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v)noexcept { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f)noexcept { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f)noexcept { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a)noexcept { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T())noexcept { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len)noexcept {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Select(const T& v, F f)noexcept {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f)noexcept {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n)noexcept { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m)noexcept { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m)noexcept { return Age(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n)noexcept { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r)noexcept { return l + (r - l) / 2; }\n\ttemplate<class T>inline int pop_count(T n)noexcept { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b)noexcept { return T{ 1 } << b; }\n\ttemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v)noexcept {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v)noexcept {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// ---------------------------------------------------------------- //\n\nstruct DP {\n\tld sum; ll cnt;\n\tDP(ld a = 0, ll b = 0) :sum(a), cnt(b) {}\n\tDP operator+(const DP& d)const {\n\t\treturn DP(*this) += d;\n\t}\n\tDP& operator+=(const DP& d) {\n\t\tsum += d.sum;\n\t\tcnt += d.cnt;\n\t\treturn *this;\n\t}\n\tDP add_root()const {\n\t\tDP res = *this;\n\t\tif (cnt != 0) {\n\t\t\tres.sum = (sum + cnt) / cnt;\n\t\t}\n\t\tres.cnt = 1;\n\t\treturn res;\n\t}\n};\nostream& operator<<(ostream& os, const DP& d) {\n\treturn os << '(' << d.sum << \", \" << d.cnt << ')';\n}\n\nint main() {\n\tint n = in;\n\tVVI g(n);\n\trep(i, n - 1) {\n\t\tINT(a, b); a--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\tVI size(n);\n\tvector<DP> ans(n);\n\tvector<vector<DP>> dp(n);\n\trep(i, n) {\n\t\tsize[i] = sz(g[i]);\n\t\tdp[i].resize(size[i]);\n\t}\n\n\tfunction<DP(int, int)> dfs = [&](int v, int p) {\n\t\tDP sum;\n\t\trep(i, size[v]) {\n\t\t\tint e = g[v][i]; DP& e_dp = dp[v][i];\n\t\t\tif (e != p) {\n\t\t\t\te_dp = dfs(e, v);\n\t\t\t\tsum += e_dp;\n\t\t\t}\n\t\t}\n\t\treturn sum.add_root();\n\t};\n\tfunction<void(int, int, const DP&)> bfs = [&](int v, int p, const DP& dp_par) {\n\t\trep(i, size[v])if (g[v][i] == p) {\n\t\t\tdp[v][i] = dp_par;\n\t\t}\n\n\t\tvector<DP> dp_left(size[v] + 1);\n\t\trep(i, size[v]) {\n\t\t\tdp_left[i + 1] = dp_left[i] + dp[v][i];\n\t\t}\n\t\tvector<DP> dp_right(size[v] + 1);\n\t\trrep(i, size[v]) {\n\t\t\tdp_right[i] = dp_right[i + 1] + dp[v][i];\n\t\t}\n\t\tans[v] = dp_left[size[v]].add_root();\n\n\t\trep(i, sz(g[v])) {\n\t\t\tint e = g[v][i];\n\t\t\tif (e != p) {\n\t\t\t\tbfs(e, v, (dp_left[i] + dp_right[i + 1]).add_root());\n\t\t\t}\n\t\t}\n\t};\n\n\tdfs(0, -1);\n\tbfs(0, -1, DP());\n\n\trep(i, n) {\n\t\tout(ans[i].sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\nstruct edge{ int to, cost; };\n\nsigned main(){\n\n  int n; cin >> n;\n  vector<vector<int>> G(n);\n  for(int i = 0; i < n-1; i++){\n    int a, b; cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  vector<double> dp(n, 0);\n  auto dfs = [&](auto&& dfs, int u, int par)->void{\n    int child = (par == -1 ? G[u].size() : G[u].size()-1);\n    for(int v : G[u]){\n      if(v == par) continue;\n      dfs(dfs, v, u);\n      dp[u] += (dp[v] + 1) / child;\n    }\n  };\n  dfs(dfs, 0, -1);\n  cout << dp << endl;\n\n  vector<double> ans(n);\n  auto dfs2 = [&](auto&& dfs2, int u, int par, double d_par)->void{\n    int child = G[u].size();\n    if(par == -1){\n      ans[u] = dp[u];\n    }else{\n      ans[u] = (dp[u] * (child-1) + d_par) / child;\n    }\n    for(int v : G[u]){\n      if(v == par) continue;\n      d_par = (ans[u] * G[u].size() -  (dp[v]+1)) / max(1LL, child-1) + 1;\n      dfs2(dfs2, v, u, d_par);\n    }\n  };\n  dfs2(dfs2, 0, -1, 0);\n  for(int i = 0; i < n; i++){\n    printf(\"%.9f\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\ntemplate <typename T>\nstruct edge {\n    int to, id;\n    T cost;\n    edge(int to) : to(to), id(-1), cost(1) {}\n    edge(int to, T cost) : to(to), id(-1), cost(cost) {}\n    edge(int to, T cost, int id) : to(to), id(id), cost(cost) {}\n    operator int() const { return to; }\n    /*\n        edge& operator=(const int& x) {\n            to = x;\n            return *this;\n        }\n        */\n};\ntemplate <typename T>\nclass Graph : public vector<vector<edge<T>>> {\n    //--------Basic--------\nprivate:\n    using Edge = edge<T>;\n    int M;  //M:辺の数\n    bool undirected = false;\n    bool directed = false;\n    bool unweighted = false;\n    bool weighted = false;\n    bool tree = false;\n    //\npublic:\n    //\npublic:\n    Graph() = default;\n    //unweighted\n    void add_edge_undirected(int u, int v, int id = -1) {\n        assert(!directed);\n        assert(!weighted);\n        undirected = true;\n        unweighted = true;\n        (*this)[u].emplace_back(Edge{v, 1, id});\n        (*this)[v].emplace_back(Edge{u, 1, id});\n    }\n    void build_undirected(int m) {\n        assert(!(*this).empty());\n        assert(!directed);\n        assert(!weighted);\n        undirected = true;\n        unweighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            cin >> u >> v;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, 1, i});\n            (*this)[v].emplace_back(Edge{u, 1, i});\n        }\n    }\n    void build_undirected(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    void add_edge_directed(int u, int v, int id = -1) {\n        assert(!undirected);\n        assert(!weighted);\n        directed = true;\n        unweighted = true;\n        (*this)[u].emplace_back(Edge{v, 1, id});\n    }\n    void build_directed(int m) {\n        assert(!(*this).empty());\n        assert(!undirected);\n        assert(!weighted);\n        directed = true;\n        unweighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            cin >> u >> v;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, 1, i});\n        }\n    }\n    void build_directed(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    //weighed\n    void add_edge_undirected_weighed(int u, int v, T cost, int id = -1) {\n        assert(!directed);\n        assert(!unweighted);\n        undirected = true;\n        weighted = true;\n        (*this)[u].emplace_back(Edge{v, cost, id});\n        (*this)[v].emplace_back(Edge{u, cost, id});\n    }\n    void build_undirected_weighted(int m) {\n        assert(!(*this).empty());\n        assert(!directed);\n        assert(!unweighted);\n        undirected = true;\n        weighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            T cost;\n            cin >> u >> v >> cost;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, cost, i});\n            (*this)[v].emplace_back(Edge{u, cost, i});\n        }\n    }\n    void build_undirected_weighted(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    void add_edge_directed_weighted(int u, int v, T cost, int id = -1) {\n        assert(!undirected);\n        assert(!unweighted);\n        directed = true;\n        weighted = true;\n        (*this)[u].emplace_back(Edge{v, cost, id});\n    }\n    void build_directed_weighted(int m) {\n        assert(!(*this).empty());\n        assert(!undirected);\n        assert(!unweighted);\n        directed = true;\n        weighted = true;\n        M = m;\n        for (int i = 0; i < m; i++) {\n            int u, v;\n            T cost;\n            cin >> u >> v >> cost;\n            u--;\n            v--;\n            (*this)[u].emplace_back(Edge{v, cost, i});\n        }\n    }\n    void build_directed_weighted(int n, int m) {\n        (*this).resize(n);\n        build_undirected(m);\n    }\n    //tree\n    void istree() {\n        tree = true;\n    }\n    void build_tree(int n) {\n        istree();\n        build_undirected(n, n - 1);\n    }\n    void build_tree_weighted(int n) {\n        istree();\n        build_undirected_weighted(n, n - 1);\n    }\n    //print state\n    void state() {\n        cerr << endl\n             << \"Print State\" << endl\n             << \"Edge :\" << endl\n             << \"    Directed   : \" << (directed ? \"Yes\" : \"No\") << endl\n             << \"    Undirected : \" << (undirected ? \"Yes\" : \"No\") << endl\n             << \"    Weighted   : \" << (weighted ? \"Yes\" : \"No\") << endl\n             << \"    Unweighted : \" << (unweighted ? \"Yes\" : \"No\") << endl\n             << \"    Tree       : \" << (tree ? \"Yes\" : \"No\") << endl\n             << \"Usable Functions : Graph\" << endl\n             << \"    StronglyConnectedComponent(unverified): \" << (StronglyConnectedComponent_ready ? \"Yes\" : \"No\") << endl\n             << \"Usable Funcitons : Tree\" << endl\n             << \"    ReRooting(verified) : Yes\" << endl;\n    }\n    //\n    //\n    //\n    //--------StronglyConnectedComponent--------\n    //Unverified\npublic:\n    vector<vector<int>> SCC_R, SCC_T;\n    //\nprivate:\n    bool StronglyConnectedComponent_ready = false;\n    vector<int> SCC_cmp, SCC_ord;\n    vector<bool> SCC_used;\n    //\npublic:\n    int SCC_build() {\n        cerr << \"Please Verify\" << endl;\n        assert(!undirected);\n        assert(directed);\n        int N = (*this).size();\n        SCC_R.resize(N);\n        for (int i = 0; i < N; i++) {\n            for (int& x : (*this)[i]) {\n                SCC_R[x].emplace_back(i);\n            }\n        }\n        SCC_cmp.resize(N);\n        fill(SCC_cmp.begin(), SCC_cmp.end(), -1);\n        SCC_used.resize(N);\n        fill(SCC_used.begin(), SCC_used.end(), false);\n        StronglyConnectedComponent_ready = true;\n        return build_StronglyConnectedComponent_init();\n    }\n    int SCC(int k) {\n        assert(StronglyConnectedComponent_ready);\n        return SCC_cmp[k];\n    }\n    //\nprivate:\n    void dfs(int now) {\n        if (SCC_used[now])\n            return;\n        SCC_used[now] = true;\n        for (auto nxt : (*this)[now])\n            dfs(nxt);\n        SCC_ord.emplace_back(now);\n    }\n    void rdfs(int now, int count) {\n        if (SCC_cmp[now] != -1)\n            return;\n        SCC_cmp[now] = count;\n        for (auto to : SCC_R[now])\n            rdfs(to, count);\n    }\n    int build_StronglyConnectedComponent_init() {\n        int n = (int)(*this).size();\n        for (int i = 0; i < n; i++)\n            dfs(i);\n        reverse(SCC_ord.begin(), SCC_ord.end());\n        int group = 0;\n        for (auto& i : SCC_ord) {\n            if (SCC_cmp[i] == -1) {\n                rdfs(i, group);\n                group++;\n            }\n        }\n        SCC_T.resize(group);\n        for (int i = 0; i < n; i++) {\n            for (auto& to : (*this)[i]) {\n                int s = SCC_cmp[i], t = SCC_cmp[to];\n                if (s != t)\n                    SCC_T[s].emplace_back(t);\n            }\n        }\n        return group;\n    }\n    //\n    //\n    //\n    //--------TopologicalSort--------\n    //未実装\n    //\n    //\n    //\n    //--------Tree--------\n    //\n    //\n    //--------ReRooting--------\n    //unverified\nprivate:\n    template <typename sum_t>\n    void ReRooting_dfs_sub(int idx, int par,\n        const function<sum_t(sum_t, sum_t)>& f,\n        const function<sum_t(sum_t, Edge)>& gg,\n        const sum_t& ident,\n        vector<sum_t>& subdp,\n        vector<sum_t>& dp,\n        vector<vector<sum_t>>& g_dp,\n        vector<vector<sum_t>>& g_ndp,\n        vector<vector<sum_t>>& memo,\n        vector<vector<bool>>& seen) {\n        for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n            auto& e = (*this)[idx][i];\n            if (e.to == par)\n                continue;\n            ReRooting_dfs_sub<sum_t>(e.to, idx, f, gg, ident, subdp, dp, g_dp, g_ndp, memo, seen);\n            if (!seen[idx][i]) {\n                memo[idx][i] = gg(subdp[e.to], e);\n                seen[idx][i] = true;\n            }\n            subdp[idx] = f(subdp[idx], memo[idx][i]);\n        }\n    }\n    template <typename sum_t>\n    void ReRooting_dfs_all(int idx, int par, const sum_t& top,\n        const function<sum_t(sum_t, sum_t)>& f,\n        const function<sum_t(sum_t, Edge)>& gg,\n        const sum_t& ident,\n        vector<sum_t>& subdp,\n        vector<sum_t>& dp,\n        vector<vector<sum_t>>& g_dp,\n        vector<vector<sum_t>>& g_ndp,\n        vector<vector<sum_t>>& memo,\n        vector<vector<bool>>& seen) {\n        sum_t buff{ident};\n        for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n            auto& e = (*this)[idx][i];\n            g_ndp[idx][i] = buff;\n            if (!seen[idx][i]) {\n                memo[idx][i] = gg(par == e.to ? top : subdp[e.to], e);\n                seen[idx][i] = true;\n            }\n            g_dp[idx][i] = memo[idx][i];\n            buff = f(buff, g_dp[idx][i]);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for (int i = (*this)[idx].size() - 1; i >= 0; i--) {\n            auto& e = (*this)[idx][i];\n            if (e.to != par)\n                ReRooting_dfs_all<sum_t>(e.to, idx, f(g_ndp[idx][i], buff), f, gg, ident, subdp, dp, g_dp, g_ndp, memo, seen);\n            g_ndp[idx][i] = f(g_ndp[idx][i], buff);\n            buff = f(buff, g_dp[idx][i]);\n        }\n    }\n    //\npublic:\n    template <typename sum_t>\n    pair<vector<sum_t>, vector<vector<sum_t>>> Tbuild_ReRooting(\n        const function<sum_t(sum_t, sum_t)> f,\n        const function<sum_t(sum_t, Edge)> gg,\n        sum_t ident) {\n        assert(tree);\n        int N = (*this).size();\n        vector<sum_t> subdp(N, ident), dp(N, ident);\n        vector<vector<sum_t>> g_dp(N), g_ndp(N), memo(N);\n        vector<vector<bool>> seen(N);\n        for (int i = 0; i < N; i++) {\n            int S = (*this)[i].size();\n            g_dp[i].resize(S, ident);\n            g_ndp[i].resize(S, ident);\n            memo[i].resize(S);\n            seen[i].resize(S, false);\n        }\n        stack<int> stk;\n        stk.push(0);\n        vector<int> par(N), ord(N);\n        int index = 0;\n        par[0] = -1;\n        while (!stk.empty()) {\n            int node = stk.top();\n            stk.pop();\n            ord[index++] = node;\n            for (auto& e : (*this)[node]) {\n                if (e.to == par[node])\n                    continue;\n                stk.push(e.to);\n                par[e.to] = node;\n            }\n        }\n        for (int k = ord.size() - 1; k >= 0; k--) {\n            int idx = ord[k];\n            for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n                auto& e = (*this)[idx][i];\n                if (e.to == par[idx])\n                    continue;\n                if (!seen[idx][i]) {\n                    memo[idx][i] = gg(subdp[e.to], e);\n                    seen[idx][i] = true;\n                }\n                subdp[idx] = f(subdp[idx], memo[idx][i]);\n            }\n        }\n        vector<sum_t> top(N, ident);\n        for (int k = 0; k < (int)(ord.size()); k++) {\n            int idx = ord[k];\n            sum_t buff{ident};\n            for (int i = 0; i < (int)((*this)[idx].size()); i++) {\n                auto& e = (*this)[idx][i];\n                g_ndp[idx][i] = buff;\n                if (!seen[idx][i]) {\n                    memo[idx][i] = gg(par[idx] == e.to ? top[idx] : subdp[e.to], e);\n                    seen[idx][i] = true;\n                }\n                g_dp[idx][i] = memo[idx][i];\n                buff = f(buff, g_dp[idx][i]);\n            }\n            dp[idx] = buff;\n            buff = ident;\n            for (int i = (*this)[idx].size() - 1; i >= 0; i--) {\n                auto& e = (*this)[idx][i];\n                if (e.to != par[idx])\n                    top[e.to] = f(g_ndp[idx][i], buff);\n                g_ndp[idx][i] = f(g_ndp[idx][i], buff);\n                buff = f(buff, g_dp[idx][i]);\n            }\n        }\n        return make_pair(dp, memo);\n    }\n};\n//グローバルでの使用のみ想定\n\n\nint N;\n\nstruct node {\n    double exp;\n    int num;\n};\n\nGraph<int> G;\n\nvoid solve() {\n    auto f1 = [](node a, node b) {\n        if (a.num + b.num == 0) {\n            return node{0, 0};\n        } else {\n            return node{(a.exp * a.num + b.exp * b.num) / (a.num + b.num), a.num + b.num};\n        };\n    };\n    auto f2 = [](node a, edge<int> x) {\n        return node{a.exp + 1.0, 1};\n    };\n    for (auto& a : G.Tbuild_ReRooting<node>(f1, f2, node{0, 0}).first) {\n        cout << a.exp << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n\n    cin >> N;\n    G.build_tree(N);\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define EPS 1e-9\ntypedef pair<int, int> ii;\n\nvector<vector<int> > g; vector<map<int, double> > m;\nvector<map<int, double> > v;\nint N;\n\ndouble solve(int n, int p){\n\tdouble tot = 0, np = 0;\n\tif(p!=-1&&v[n][p]==1)\n\t\treturn m[n][p];\n\tfor(int x=0; x<g[n].size(); x++){\n\t\tif(g[n][x]!=p){\n//\t\t\tcout << n << \" \" << g[n][x] << endl;\n//\t\t\tcout << x << g[n].size() << endl;\n\t\t\tdouble res = solve(g[n][x], n);\n\t\t\ttot += res+1;\n\t\t\tnp++;\n\t\t}\n\t}\n\tif(np==0){\n\t\t//endnode\n\t\tnp++;\n\t}\n\tv[n][p] = 1;\n//\tcout << n << \" \" << p << \" \" << np << endl;\n\tif(p==-1)\n\t\treturn (tot/((double)np));\n\telse\n\t\treturn m[n][p] = (tot/((double)np));\n}\n\nint main(){\n\tiostream::sync_with_stdio(false); cin.tie(0);\n\tcin>>N;\n\tg.assign(N+1, vector<int>());\n\tm.assign(N+1, map<int, double>());\n\tv.assign(N+1, map<int, double>());\n\tint A, B;\n\tfor(int n=1; n<N; n++){\n\t\tcin>>A>>B;\n\t\tg[A].push_back(B);\n\t\tg[B].push_back(A);\n\t//\tcout << A << \" \" << B << endl;\n\t}\n\t//for(int x=0; x<g[5].size(); x++)\n\t//\tcout << g[5][x] << endl;\n\tfor(int n=1; n<=N; n++){\n\t\tdouble r = solve(n, -1);\n\t//\tcout << g[5][2] << endl;\n\t\tprintf(\"%.8f\\n\", r);\n\t//\tcout << n << endl;\n\t}\n\t//cout << \"f\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    Int N;\n\n    vector<vector<Int>> tree;\n    vector<vector<double>> dp;\n    vector<Int> pi;\n\n\n    double dfs1(Int v, Int p = -1) {\n        dp[v].resize(tree[v].size());\n        if (tree[v].size() == 1 && p != -1) {\n            return 0.0;\n        }\n\n        Int cnt = 0;\n        double sum = 0.0;\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) {\n                pi[i] = u;\n                continue;\n            }\n\n            cnt++;\n            double tmp = dfs1(u, v);\n            dp[v][i] = tmp;\n            sum += tmp + 1.0;\n        }\n\n        return sum / cnt;\n    }\n\n    void dfs2(Int v, double res_p = 0.0, Int p = -1) {\n        if (p != -1) {\n            dp[v][pi[v]] = res_p;\n        }\n        if (tree[v].size() == 1 && p != -1) {\n            return;\n        }\n\n        Int cnt = tree[v].size() - 1;\n        double sum = 0.0;\n        for (int i = 0; i < tree[v].size(); ++i) {\n            sum += dp[v][i] + 1.0;\n        }\n\n        for (int i = 0; i < tree[v].size(); ++i) {\n            Int u = tree[v][i];\n            if (u == p) continue;\n            double n_res = cnt > 0 ? (sum - dp[v][i] - 1.0) / cnt : 0;\n            dfs2(u, n_res, v);\n        }\n    }\n\n\n    void solve() {\n        cin >> N;\n        if (N == 1) {\n            cout << 0 << endl;\n            return;\n        }\n        tree.resize(N);\n        dp.resize(N);\n        pi.resize(N);\n        for (int i = 1; i < N; ++i) {\n            Int a, b;\n            cin >> a >> b;\n            a--, b--;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n\n        dfs1(0);\n        dfs2(0);\n\n        vector<double> ans(N);\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < dp[i].size(); ++j) {\n                ans[i] += dp[i][j];\n            }\n            ans[i] /= dp[i].size();\n            ans[i] += 1;\n\n            cout << ans[i] << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 15e4;\nvector<vector<int>> g0(N), g1;\nmap<int, ld> dp[N];\nint n;\nld dfs(int i, int p) {\n  if(dp[i].count(p)) return dp[i][p];\n  vector<int> gi;\n  int cnt = 0;\n  ld res = 0;\n  for(int j : g0[i]) {\n    if(j == p) gi.emplace_back(j);\n    else {\n      dfs(j, i);\n    }\n  }\n  g0[i] = gi;\n  for(int j : g1[i]) {\n    if(j == p) ;\n    else {\n      cnt++;\n      res += 1.0 + dp[j][i];\n    }\n  }\n  if(cnt) res /= cnt;\n  return dp[i][p] = res;\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g0[a].emplace_back(b);\n    g0[b].emplace_back(a);\n  }\n  g1 = g0;\n  for(int i = 0; i < n; i++) dfs(i, -1);\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << dp[i][-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<pair<int, int> > > graph(150001);\n\nvector<vector<double> > result(150001, vector<double>(2, -1.0));\n// result[i] : 番号iの枝(向き有り)を、向き通りにたどった先の結果\nvector<bool> canuse(150001, true);\n\ndouble solve(int nownode)\n{\n\tdouble ans = 0.0;\n\tdouble cnt = 0.0;\n\tfor(int i = 0; i < graph[nownode].size(); i++){\n\t\tint nextnode = graph[nownode][i].first;\n\t\tint edgenum = graph[nownode][i].second;\n\t\tif(!canuse[edgenum]) continue;\n\t\tcnt += 1.0;\n\t\tint tmp;\n\t\tif(nownode < nextnode) tmp = 0;\n\t\telse tmp = 1;\n\t\tif(result[edgenum][tmp] < 0.0){\n\t\t\tcanuse[edgenum] = false;\n\t\t\t// 枝を切り離す\n\t\t\tresult[edgenum][tmp] = solve(nextnode);\n\t\t\tcanuse[edgenum] = true;\n\t\t}\n\t\tans += result[edgenum][tmp] + 1;\n\t}\n\tif(cnt == 0.0) return 0.0;\n\tans = ans / cnt;\n\treturn ans;\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif(u > v) swap(u, v);\n\t\tgraph[u].push_back(make_pair(v, i));\n\t\tgraph[v].push_back(make_pair(u, i));\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tprintf(\"%.10f\\n\", solve(i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N;\nint tu[150010], tv[150010];\nvector<int> G[150010];\n\nlong double dfs(int now, int pre, long double E, int dist){\n\tdouble ret = 0;\n\tint nextsize;\n\tif(pre == -1) nextsize = G[now].size();\n\telse nextsize = G[now].size() - 1;\n\tif(nextsize == 0){\n\t\treturn dist * E;\n\t}\n\tfor(auto u : G[now]){\n\t\tif(u == pre) continue;\n\t\tret += dfs(u, now, E / nextsize, dist + 1);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tcin >> N;\n\trep(i, N - 1) cin >> tu[i] >> tv[i];\n\trep(i, N - 1) tu[i]--, tv[i]--;\n\tint one = 0, two = 0;\n\trep(i, N - 1){\n\t\tif(G[i].size() == 1) one++;\n\t\telse if(G[i].size() == 2) two++;\n\t}\n\tif(one == 2 && two == N - 2){\n\t\trep(i, N){\n\t\t\tif(G[i].size() == 1){\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)(N - 1));\n\t\t\t}else{\n\t\t\t\tprintf(\"%.9Lf\\n\", (long double)((N - 1) / 2));\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\trep(i, N - 1){\n\t\tG[tu[i]].pb(tv[i]);\n\t\tG[tv[i]].pb(tu[i]);\n\t}\n\trep(i, N){\n\t\tlong double ret = dfs(i, - 1, 1.0, 0);\n\t\tprintf(\"%.9Lf\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int N = 150000;\nvector<pair<int, int>> g[N];\nvector<double> expect[N];\n\ndouble dfs(int i, int p, int t) {\n  if(expect[i][t] >= 0) return expect[i][t];\n  expect[i][t] = 0;\n  for(auto edge : g[i]) if(edge.first != p) {\n    expect[i][t] += (1 + dfs(edge.first, i, edge.second)) / (g[i].size() - (p != -1));\n  }\n  return expect[i][t];\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n;\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    expect[a].emplace_back(-1);\n    expect[b].emplace_back(-1);\n    g[a].emplace_back(b, expect[b].size() - 1);\n    g[b].emplace_back(a, expect[a].size() - 1);\n  }\n  cout << fixed << setprecision(7);\n  for(int i = 0; i < n; i++) {\n    expect[i].emplace_back(-1);\n    cout << dfs(i, -1, expect[i].size() - 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include <map>\n#include <queue>\n#include <stack>\n#include<set>\n\n#define DIV 1000000007\nusing namespace std;\nusing ll = long long;\n\ntypedef struct {\n    vector<int> edge;\n    int par = 0;\n    double dp1 = 0, e = 0;\n    bool vi1 = 0, vi2 = 0;\n}node_t;\nvector<node_t> node;\n\ndouble dfs(int x) {\n    double sum = 0.0;\n    double n = node[x].edge.size();\n    double cnt = 0;\n    for (int i = 0; i < n; i++) {\n        int to = node[x].edge[i];\n        if (node[to].vi1) continue;\n        node[to].par = x;\n        node[to].vi1 = true;\n        sum += dfs(to) + 1;\n        cnt++;\n    }\n    if (cnt == 0) node[x].dp1 = 0;\n    else  node[x].dp1 = (double)sum / cnt;\n    return node[x].dp1;\n\n}\n\ndouble dfs2(int y) {\n    int par = node[y].par;\n    double sp = node[par].edge.size();\n    double sn = node[y].edge.size();\n    //for(int i=0;i<)\n    if (y == 1) node[y].e = node[y].dp1;\n    else {\n        /*\n        double pp;\n        if (node[par].par == 0) pp = 0;\n        else pp = 1;\n        */\n        //node[y].e = (node[par].e * sp + (sn - 2) * node[y].dp1 + node[par].edge.size()-2) / sn;\n        double temp = node[par].e * sp - node[y].dp1 - 1.0;\n        if (temp == 0) node[y].e = (1 + (sn - 1.0) * node[y].dp1) / sn;\n        else node[y].e = (temp / (sp - 1.0) + 1.0 + (sn - 1.0) * node[y].dp1) / sn;\n        //node[y].e = ((node[par].e * sp - node[y].dp1 - 1 + (sp - 1)) / (sp - 1) + (sn - 1) * node[y].dp1) / sn;\n    }\n    //printf(\"node[%d].e=%lf\\n\", y, node[y].e);\n    for (int i = 0; i < sn; i++) {\n        int to = node[y].edge[i];\n        if (node[to].vi2) continue;\n        node[to].vi2 = true;\n        dfs2(node[y].edge[i]);\n    }\n    return node[y].e;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    node = vector<node_t>(N + 1);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        node[u].edge.push_back(v);\n        node[v].edge.push_back(u);\n    }\n\n    node[1].vi1 = true;\n    dfs(1);\n    /*\n    for (int i = 1; i <= N; i++) {\n        printf(\"node[%d].dp1=%lf\\n\", i, node[i].dp1);\n    }\n    */\n    node[1].vi2 = true;\n    dfs2(1);\n    //cout << endl;\n    for (int i = 1; i <= N; i++) {\n        //printf(\"node[%d].e=%lf\\n\", i, node[i].e);\n        printf(\"%.10lf\\n\", node[i].e);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- ReRooting {{{ ///\n\n#include <functional>\n#include <vector>\ntemplate < class Monoid >\nstruct ReRooting {\n  using size_type = std::size_t;\n  using edge_type = std::tuple< size_type, size_type, size_type >;\n  using graph_type = std::vector< std::vector< edge_type > >;\n  using T = typename Monoid::T;\n  using dig_f_type = std::function< T(T, size_type edge_id, size_type from, size_type to) >;\n  using after_f_type = std::function< T(T, size_type vertex_id, size_type degree_of_this) >;\n  using vector_bool_type = std::vector< int >;\n  graph_type graph;\n\n  size_type n;\n\n  std::vector< std::vector< T > > dp;\n  std::vector< vector_bool_type > did;\n  std::vector< std::vector< T > > L;\n  std::vector< std::vector< T > > R;\n\n  dig_f_type dig;\n  after_f_type after;\n  static T default_dig(const T&a, ...) {\n    return a;\n  }\n  static T default_after(const T&a, ...) {\n    return a;\n  }\n\n  bool built;\n\n  ReRooting() {}\n  ReRooting(size_type n, dig_f_type dig = default_dig, after_f_type after = default_after) : dig(dig), after(after) {\n    clear(n);\n  }\n  ReRooting(std::vector<std::vector<int>> graph, dig_f_type dig = default_dig, after_f_type after = default_after) : ReRooting(graph.size(), dig, after) {\n    for(size_type from = 0; from < n; from++) {\n      for(auto to : graph[from]) if(to < from) {\n        add_edge(from, to);\n      }\n    }\n  }\n\n  void clear() { clear(n); }\n\n  void clear(size_type n) {\n    this->n = n;\n    graph.resize(n);\n    graph.assign(n, std::vector< edge_type >());\n    dp.resize(n);\n    dp.assign(n, std::vector< T >());\n    did.resize(n);\n    did.assign(n, vector_bool_type());\n    L.resize(n);\n    L.assign(n, std::vector< T >());\n    R.resize(n);\n    R.assign(n, std::vector< T >());\n    built = 0;\n  }\n\n  size_type added = 0;\n  void add_edge(size_type a, size_type b, size_type id = static_cast<size_type>(-1)) {\n    assert(a < n && b < n && a != b);\n    if(id == static_cast<size_type>(-1)) id = added;\n    graph[a].emplace_back(b, graph[b].size(), id);\n    graph[b].emplace_back(a, graph[a].size() - 1, id);\n    added++;\n  }\n\n  void set_dig(dig_f_type dig = default_dig) { this->dig = dig; }\n\n  void set_after(after_f_type after = default_after) { this->after = after; }\n\n  void build() {\n    assert(!built);\n    assert(added == n - 1);\n    built = 1;\n    if(n == 0) return;\n    for(size_type i = 0; i < n; i++) {\n      dp[i].resize(graph[i].size() + 1);\n      did[i].resize(graph[i].size() + 1);\n      L[i].reserve(graph[i].size() + 1);\n      R[i].reserve(graph[i].size() + 1);\n    }\n    dfs(0, graph[0].size(), 1);\n  }\n\npublic:\n  T dfs(size_type i) {\n    assert(built);\n    return dfs(i, graph[i].size(), 0);\n  }\n\n  T dfs(size_type i, size_type k) {\n    assert(built);\n    assert(k <= graph[i].size());\n    return dfs(i, k, 0);\n  }\n\n  T dfs_from(size_type i, size_type j) {\n    assert(built);\n    assert(j < n);\n    // TODO : どうする?\n    // return dfs(i, , 0);\n  }\n\nprivate:\n  T dfs(size_type i, size_type p, bool f) {\n    int deg = graph[i].size() - static_cast< size_type >(p != graph[i].size());\n    if(did[i][p]) return dp[i][p];\n    did[i][p] = 1;\n    T res = Monoid::identity();\n    if(f || p == graph[i].size()) {\n      // O(deg)\n      // go only child\n\n      if(p == graph[i].size()) {\n        for(auto to : graph[i]) {\n          size_type j, rev, edge_id;\n          std::tie(j, rev, edge_id) = to;\n          L[i].push_back(dig(dfs(j, rev, f), edge_id, i, j));\n        }\n        R[i] = L[i];\n        for(int x = 1; x < deg; x++) L[i][x] = Monoid::op(L[i][x - 1], L[i][x]);\n        for(int x = deg - 2; x >= 0; x--) R[i][x] = Monoid::op(R[i][x], R[i][x + 1]);\n        res = L[i].back();\n      } else {\n        for(size_type x = 0; x < graph[i].size(); x++)\n          if(x != p) {\n            size_type j, rev, edge_id;\n            std::tie(j, rev, edge_id) = graph[i][x];\n            res = Monoid::op(res, dig(dfs(j, rev, f), edge_id, i, j));\n          }\n      }\n    } else {\n      // O(1)\n      dfs(i, graph[i].size(), f);\n      res = Monoid::op(p >= 1 ? L[i][p - 1] : Monoid::identity(),\n                       p + 1 < R[i].size() ? R[i][p + 1] : Monoid::identity());\n    }\n    return dp[i][p] = after(res, i, deg);\n  }\n};\n\n/// }}}--- ////\n\n// my monoid, m-act {{{\nstruct MyMonoid {\n  using T = double;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n// }}}\n\nusing rerooting = ReRooting<MyMonoid>;\nusing T = rerooting::T;\n\nT dig(T a, int id, int from, int to) {\n  return a + 1;\n}\n\nT after(T a, int i, int deg) {\n  if(deg == 0) return a;\n  return a / deg;\n}\n\nconst int N = 1e5;\nstd::vector<std::vector<int>> g;\nint n;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; std::cin >> a >> b;\n    a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  rerooting rr(g, dig, after);\n  rr.build();\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << rr.dfs(i) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\nint N;\nvector<int> E[151010];\n//-----------------------------------------------------------------------------------\ndouble dp[151010];\ndouble dfs(int cu, int pa = -1) {\n    double ret = 0;\n    int cnt = 0;\n    for (int to : E[cu]) if (to != pa) ret += dfs(to, cu) + 1, cnt++;\n    if (0 < cnt) ret /= cnt;\n    return dp[cu] = ret;\n}\n//-----------------------------------------------------------------------------------\ndouble ans[151010];\nvoid dfs2(int cu, int pa = -1) {\n    // for ans\n    double sm = 0; int cnt = 0;\n    for (int to : E[cu]) sm += dp[to] + 1, cnt++;\n    if (0 < cnt) ans[cu] = sm / cnt;\n    else ans[cu] = sm;\n\n    for (int to : E[cu]) if (pa != to) {\n        dp[cu] = sm - dp[to] - 1;\n        if (1 < cnt) dp[cu] /= (cnt - 1);\n        dfs2(to, cu);\n    }\n}\n//-----------------------------------------------------------------------------------\nint main() {\n    cin >> N;\n    rep(i, 0, N - 1) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    dfs(1);\n    dfs2(1);\n\n    rep(i, 1, N + 1) printf(\"%.10f\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nint deg[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    int p = deg[u];\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) * 1.0 / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    int p = deg[u];\n    for (int v : G[u]) if (v != fa) {\n        if (fa == -1) {\n            if (p == 1)\n                dp2[v] = 1;\n            else\n                dp2[v] = ((dp[u] + 1) * p - (dp[v] + 2)) / (p - 1);\n        }\n        else\n            dp2[v] = ((dp2[u] + 1) + (dp[u] + 1) * (p - 1) - (dp[v] + 2)) / (p - 1);\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    \n    for (int i = 1; i < N; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n        deg[u] ++, deg[v] ++;\n    }\n    \n    dp2[1] = 0;\n    dfs(1, -1);\n    dfs2(1, -1);\n    \n//    for (int i = 1; i <= N; i ++)\n//        cout<<i<<\" \"<<dp[i]<<\" \"<<dp2[i]<<\" \"<<deg[i]<<endl;\n    \n    cout<<dp[1]<<endl;\n    for (int i = 2; i <= N; i ++) {\n        printf(\"%.6f\\n\", (dp[i] * (deg[i] - 1) + dp2[i]) * 1.0 / deg[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\n\nconstexpr int32_t MAX_N = 300000;//頂点数\nconstexpr int32_t MAX_LOGN = 30;//log2頂点数\nstd::unordered_map<int32_t, double> graph[MAX_N];//木\ndouble get(int32_t v, int32_t p) {\n\tauto& memo = graph[v][p];\n\tif (memo >= 0 && p!= -1) {\n\t\treturn memo;\n\t}\n\tint32_t count = 0;\n\tdouble sum = 0;\n\tfor (auto& c : graph[v]) {\n\t\tif (c.first != p && c.first != -1) {\n\t\t\t++count;\n\t\t\tsum += get(c.first, v)+1;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\treturn memo = 0;\n\t}\n\treturn memo = sum / count;\n}\nvoid input_tree()\n{\n\tin >> N;\n\tfor (int32_t i = 0; i < N - 1; ++i)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a][b] = -1;\n\t\tgraph[b][a] = -1;\n\t}\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tout  << std::fixed << std::setprecision(9);\n\tinput_tree();\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tout << get(i, -1) << endl;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N;\nstd::string S[10000];\nstd::string T;\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> S[i];\n\t}\n\tin >> T;\n\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nint deg[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    int p = deg[u];\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) * 1.0 / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    int p = deg[u];\n    for (int v : G[u]) if (v != fa) {\n        if (fa == -1) {\n            if (p == 1)\n                dp2[v] = 1;\n            else\n                dp2[v] = ((dp[u] + 1) * p - (dp[v] + 2)) / (p - 1);\n        }\n        else\n            dp2[v] = ((dp2[u] + 1) + (dp[u] + 1) * (p - 1) - (dp[v] + 2)) / (p - 1);\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int N; cin>>N;\n    \n    for (int i = 1; i < N; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n        deg[u] ++, deg[v] ++;\n    }\n    \n    dp2[1] = 0;\n    dfs(1, -1);\n    dfs2(1, -1);\n    \n//    for (int i = 1; i <= N; i ++)\n//        cout<<i<<\" \"<<dp[i]<<\" \"<<dp2[i]<<\" \"<<deg[i]<<endl;\n    \n    printf(\"%.8f\\n\", dp[1]);\n    for (int i = 2; i <= N; i ++) {\n        printf(\"%.8f\\n\", (dp[i] * (deg[i] - 1) + dp2[i]) * 1.0 / deg[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<list>\n#define LL long long\n#define FF(i,a,b) for(int i=a;i<=b;++i)\n#define RR(i,a,b) for(int i=a;i>=b;--i)\n#define SC(x) scanf(\"%d\",&x)\n#define SCC(x,y) scanf(\"%d%d\",&x,&y)\n#define SCCC(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\n#define SS(x) scanf(\"%s\",x)\n#define PR(x) printf(\"%d\\n\",x)\n#define CL(a,b) memset(a,b,sizeof(a))\n#define ll rt<<1\n#define rr rt<<1|1\n#define mid int m=(x+((y-x)>>1))\n#define lson x,m,rt<<1\n#define rson m+1,y,rt<<1|1\n#define lowbit(x) (x&-x)\n#define PB push_back\n#define pii pair<int, int>\n#define mp(x, y) make_pair(x, y)\n#define IN freopen(\"in.txt\",\"r\",stdin)\n#define OUT freopen(\"out.txt\",\"w\",stdout)\n#define fi freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\nusing namespace std;\n\nconst int N = 150000 + 20;\nconst int inf = 1e9;\nvector<int>g[N];\ndouble ans[N], xia[N], sha[N];\nint n;\nint du[N], down[N];\nvoid dfs1(int u, int fa)\n{\n    int sz = g[u].size();\n    if(fa == -1) down[u] = sz;\n    else down[u] = sz-1;\n    FF(i, 0, sz-1)\n    {\n        int v = g[u][i]; if(v == fa) continue;\n        dfs1(v, u);\n        xia[u] += xia[v] + 1;\n    }\n    if(xia[u] != 0)\n        xia[u] /= down[u];\n}\nvoid dfs2(int u, int fa)\n{\n    if(fa == -1) sha[u] = 0;\n    else{\n        if(du[fa] - 1 == 0)\n            sha[u] = 0;\n        else\n            sha[u] = (xia[fa] * down[fa] - xia[u] - 1 + sha[fa]) / (du[fa] - 1);\n        sha[u] += 1;\n    }\n    if(fa == -1) ans[u] = xia[u];\n    else{\n        ans[u] = xia[u] * down[u] / du[u] + sha[u] / du[u];\n    }\n    int sz = g[u].size();\n    FF(i, 0, sz-1)\n    {\n        int v = g[u][i]; if(v == fa) continue;\n        dfs2(v, u);\n    }\n}\nint main()\n{\n\n\n    SC(n);\n    FF(i, 1, n-1){\n        int x, y; SCC(x, y);\n        g[x].PB(y); g[y].PB(x);\n        ++du[x]; ++du[y];\n    }\n    dfs1(1, -1);\n    dfs2(1, -1);\n    FF(i, 1, n)\n        printf(\"%.8lf\\n\", ans[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 210000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nstruct TreeDP{\n\ttypedef double vint;\n\tstatic const int maxN=210000;\n\tstruct edge{\n\t\tint to;\n\t\tint rev;\n\t\t// ここに何かをもたせたいときはその都度編集する\n\t\tedge(int a,int b){to=a;rev=b;}\n\t\tedge(){to=rev=0;}\n\t};\n\tvector<edge>g[maxN];\n\tvector<int>lp;\n\tvector<int>rp;\n\tvector<vint>L[maxN];\n\tvector<vint>R[maxN];\n\tint N;\n\tvint dfs(int a,int b){\n\t\tL[a][0]=R[a][0]=0;\n\t\twhile(lp[a]<g[a].size()&&b!=lp[a]){\n\t\t\tL[a][lp[a]+1]=L[a][lp[a]]+(1+dfs(g[a][lp[a]].to,g[a][lp[a]].rev));\n\t\t\tlp[a]++;\n\t\t}\n\t\twhile(rp[a]<g[a].size()&&b!=g[a].size()-1-rp[a]){\n\t\t\tR[a][rp[a]+1]=R[a][rp[a]]+(1+dfs(g[a][g[a].size()-1-rp[a]].to,g[a][g[a].size()-1-rp[a]].rev));\n\t\t\trp[a]++;\n\t\t}\n\t\tif(b==-1){\n\t\t\tif(g[a].size()==0)return 0;\n\t\t\treturn L[a][g[a].size()]/g[a].size();\n\t\t}else{\n\t\t\tif(g[a].size()==1)return 0;\n\t\t\treturn (L[a][b]+R[a][g[a].size()-b-1])/(g[a].size()-1);\n\t\t}\n\t}\n\n\t// 何か重みのある辺が追加したいときはここを変える\n\t// 各辺について2度以上呼ばないようにする\n\tvoid add_edge(int from,int to){\n\t\tg[from].push_back(edge(to,g[to].size()));\n\t\tg[to].push_back(edge(from,g[from].size()-1));\n\t}\n\tvector<vint> solve(int n){\n\t\tN=n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tL[i]=vector<vint>(g[i].size()+1);\n\t\t\tR[i]=vector<vint>(g[i].size()+1);\n\t\t}\n\t\tlp=vector<int>(n);\n\t\trp=vector<int>(n);\n\t\tvector<vint>ret(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tret[i]=dfs(i,-1);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tTreeDP td;\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\ttd.add_edge(p,q);\n\t}\n\tvector<double>ret=td.solve(a);\n\tfor(int i=0;i<a;i++)printf(\"%.12f\\n\",ret[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[150100];\nmap <pair <int, int> , double> mp;\ndouble dfs(int v, int p = -1, double t = 1)\n{\n    if(mp[make_pair(v, p)] != 0)\n        return mp[make_pair(v, p)] * t;\n    double ans = 0;\n    int k = g[v].size();\n    if(p != -1)\n        k--;\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        if(g[v][i] != p)\n            ans += dfs(g[v][i], v, 1.0 / k) + 1.0 / k;\n    }\n    mp[make_pair(v, p)] = ans;\n    return ans * t;\n}\nint main()\n{\n    int n, i, x, y;\n\n    scanf(\"%d\", &n)\n\n    for(i = 1; i < n; ++i)\n    {\n        scanf(\"%d %d\", &x, &y);\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    for(i = 1; i <= n; ++i)\n        cout << fixed << setprecision(12) << dfs(i) << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 150005;\n\nvector<int> G[MAX_N];\ndouble dp1[MAX_N], dp2[MAX_N];\n\nvoid dfs(int u, int p)\n{\n    each(v,G[u]){\n        if(v != p){\n            dfs(v, u);\n            dp1[u] += dp1[v] + 1;\n        }\n    }\n    if(u == 0){\n        dp1[u] /= (double)G[u].size();\n    }else if(len(G[u]) > 1){\n        dp1[u] /= (double)G[u].size() - 1;\n    }\n}\n\nvoid redfs(int u, int p)\n{\n    if(p > 0){\n        dp2[u] = (dp1[p]*((double)G[p].size()-1)-dp1[u]-1+dp2[p])/((double)G[p].size()-1) + 1;\n    }else if(p == 0){\n        if(len(G[p]) == 1){\n            dp2[u] = 1;\n        }else{\n            dp2[u] = (dp1[p]*(double)G[p].size()-dp1[u]-1)/((double)G[p].size()-1) + 1;\n        }\n    }\n    each(v, G[u]){\n        if(v != p){\n            redfs(v, u);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n-1){\n        int u,v;\n        cin >> u >> v;\n        G[u-1].pb(v-1), G[v-1].pb(u-1);\n    }\n    dfs(0, -1);\n    redfs(0, -1);\n    rep(i,n){\n        if(i == 0){\n            printf(\"%.12lf\\n\", dp1[i]);\n        }else{\n            printf(\"%.12lf\\n\", (dp1[i]*(G[i].size()-1)+dp2[i])/G[i].size());\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvv vector<vvl>\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvvl(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define rep(c, a, b) for(ll c=a;c<b;c++)\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\n//typedef __int128_t lll;\nusing namespace std;\n\ntemplate<typename T>\nstruct treeDP{\n  vvl G;\n  T INIT, ZERO;\n  vector<T> TMP_DATA, dat;\n  function<T(T, T)> f;\n  function<T(T)> g;\n  // f: merge g: step\n  treeDP(ll n, T init, T zero, function<T(T, T)> func, function<T(T)> func2):\n  INIT(init), ZERO(zero), f(func), g(func2){\n    G.resize(n+1, vector<ll>(0));\n    dat.resize(n+1, zero);\n    TMP_DATA.resize(n+1, zero);\n  }\n\n  inline void dfs(ll now, ll from){\n    ll cnt = 0;\n    for(int i=0;i<G[now].size();i++){\n      if(G[now][i]==from) continue;\n      dfs(G[now][i], now);\n      TMP_DATA[now] = f(TMP_DATA[now], g(TMP_DATA[G[now][i]]));\n      cnt++;\n    }\n    if(cnt==0) TMP_DATA[now] = INIT;\n    else TMP_DATA[now] /= (ld)cnt;\n  }\n\n  inline void dfs2(ll now, ll from, T rev){\n    vector<T> left, right;\n    for(int i=0;i<G[now].size();i++){\n      ll to = G[now][i];\n      if(to==from) continue;\n      left.push_back(g(TMP_DATA[to]));\n      ll s = left.size();\n      if(s!=1) left[s-1] = f(left[s-1], left[s-2]);\n    }\n    ld c = 0;\n    for(int i=0;i<G[now].size();i++){\n      ll to = G[now][G[now].size()-1-i];\n      if(to==from) continue;\n      right.push_back(g(TMP_DATA[to]));\n      ll s = right.size();\n      if(s!=1) right[s-1] = f(right[s-1], right[s-2]);\n      c++;\n    }\n    if(left.size()==0) dat[now] = rev;\n    else if(rev==0) dat[now] =  left[left.size()-1];\n    else{\n      dat[now] = (left[left.size()-1] + rev)/(c+1.0);\n    }\n    //std::cout << \"now\" << now << \" \" << c << \" \" << left[left.size()-1] << \" \" << rev << '\\n';\n    //std::cout << dat[now] << '\\n';\n    ll cnt = 0;\n    for(int i=0;i<G[now].size();i++){\n      ll to = G[now][i];\n      if(to==from) continue;\n      T tmp = rev;\n      if(cnt!=0) tmp = f(tmp, left[cnt-1]);\n      if(cnt!=right.size()-1) tmp = f(tmp, right[right.size()-2-cnt]);\n      dfs2(to, now, g(tmp/c));\n      cnt++;\n    }\n  }\n  void insert(ll a, ll b){ G[a].push_back(b);G[b].push_back(a); }\n  void calc(){\n    ll root = -1;\n    for(int i=1;i<=G.size();i++) {\n      if(G[i].size()==1||G[i].size()==0) {\n        root = i;\n        break;\n      }\n    }\n    dfs(root, -1);\n    dfs2(root, -1, ZERO);\n  }\n  T & operator [](int i){return dat[i];}\n};\n\n\nld mg(ld a, ld b){\n  return a+b;\n}\nld step(ld a){\n  return a+1;\n}\n\nint main(int argc, char const *argv[]) {\n  ll n;std::cin >> n;\n  treeDP<ld> tdp(n+1, 0, 0, mg, step);\n  for(int i=0;i<n-1;i++){\n    ll a, b;std::cin >> a >> b;\n    tdp.insert(a, b);\n  }\n  tdp.calc();\n\n  //std::cout << \"----------\" << '\\n';\n  //for(int i=1;i<=n;i++){\n    //std::cout << fixed << setprecision(20) << tdp.TMP_DATA[i] << endl;\n  //}\n  //std::cout << '\\n';\n  //std::cout << \"----------\" << '\\n';\n  for(int i=1;i<=n;i++){\n    std::cout << fixed << setprecision(20) << tdp[i] << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n \nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, double>U[150000];\ndouble saiki(int i, int j) {\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tdouble K = 1;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n\nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, unordered_map<int, double>>U;//頂点IからJに進むときの進む距離の平均\ndouble saiki(int i, int j) {\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tdouble K = 1;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 15e4;\nvector<vector<int>> g(N);\nmap<int, ld> dp[N];\nint n;\nld dfs(int i, int p, int f = 0) {\n  if(dp[i].count(p)) return dp[i][p];\n  int cnt = 0;\n  ld res = 0;\n  if(f || p == -1) {\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      res += dfs(j, i, f);\n    }\n  } else {\n    cnt = g[i].size() - 1;\n    res = (dfs(i, -1, f) - 1.0) * g[i].size() - dfs(p, i, f);\n  }\n  if(cnt) res /= cnt, res += 1.0;\n  return dp[i][p] = res;\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  dfs(0, -1, 1);\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << dfs(i, -1) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = (LL)1e9+7;\nconst int SIZE = 2e5+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\ndouble dp[150009];\ndouble ans[150009];\nvector<int> radj[150009],adj[150009];\nint par[150009];\n\nvoid dfs1(int x,int p=-1){\n\tint cc=SZ(radj[x])-(p!=-1);\n\tfor(int i:radj[x]){\n\t\tif(i==p)continue;\n\t\tadj[x].PB(i);\n\t\tdfs1(i,x);\n\t\tdp[x]+=(dp[i]+1)/cc;\n\t}\n}\n\nvoid dfs2(int x,int p=-1){\n\tif(x==0)ans[x]=dp[x];\n\telse{\n\t\tint cc=SZ(radj[x]);\n\t\tint pcc=SZ(radj[p]);\n\t\tans[x]=(dp[x]*(cc-1))/cc;\n\t\tif(pcc>1)ans[x]+=((ans[p]-(dp[x]+1)/pcc)/(pcc-1)*pcc+1)/cc;\n\t\telse ans[x]+=(double)1/cc;\n\t}\n\tfor(int i:adj[x]){\n\t\tdfs2(i,x);\n\t}\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tradj[a].PB(b);radj[b].PB(a);\n\t}\n\tdfs1(0);dfs2(0);\n\tREP(i,n){\n\t\tprintf(\".10%lf\\n\",ans[i]);\n\t\t//printf(\"%lf\",[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 200005\n#define M 200005\n#define LL long long\n#define FF(i,a,b) for(int i=a;i<=b;++i)\n#define RR(i,a,b) for(int i=a;i>=b;--i)\n#define FJ(i,a,b) for(int i=a;i<b;++i)\n#define SC(x) scanf(\"%d\",&x)\n#define SCC(x,y) scanf(\"%d%d\",&x,&y)\n#define SCCC(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\n#define SS(x) scanf(\"%s\",x)\n#define PR(x) printf(\"%d\\n\",x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _q fd[rt]\n#define _l fd[rt<<1]\n#define _r fd[rt<<1|1]\n#define MID int mid=((l+r)>>1)\n#define lson rt<<1,l,mid\n#define rson rt<<1|1,mid+1,r\n#define PB push_back\n#define SZ size\n#define PII pair<int,int>\n#define PLL pair<long long,long long>\n#define MP make_pair\n#define IN freopen(\"in.txt\",\"r\",stdin)\n#define OUT freopen(\"out.txt\",\"w\",stdout)\nusing namespace std;\nconst int MOD=1000000007;\nconst double PI=acos(-1.0);\nconst double EPS=1e-8;\ninline void II(int &n){char ch=getchar();n=0;bool t=0;\nfor(;ch<'0';ch=getchar())if(ch=='-')t=1;\nfor(;ch>='0';n=n*10+ch-'0',ch=getchar());if(t)n=-n;}\ninline void OO(int a){if(a<0){putchar('-');a=-a;}\nif(a>=10)OO(a/10);putchar(a%10+'0');}\ninline int sgn(double x){return(x>EPS)-(x<-EPS);}\nstruct EE{int v,nx;}E[M*2+N*2];int hd[N],EN;\nvoid init_edge(int num){EN=0;memset(hd,-1,(num+3)<<2);}\nvoid add_edge(int u,int v){\n    E[EN].v=v;E[EN].nx=hd[u];hd[u]=EN++;\n    E[EN].v=u;E[EN].nx=hd[v];hd[v]=EN++;\n}\nLL down[N];\ndouble g[N], f[N], s[N];\nbool leaf[N];\nvoid dfs1(int u, int fa){\n    for(int k = hd[u]; ~k; k = E[k].nx){\n        int v = E[k].v;\n        if(v == fa)continue;\n        ++down[u];\n        dfs1(v, u);\n        f[u] += f[v] + 1;\n    }\n    if(down[u])f[u] /= down[u];\n}\nvoid dfs2(int u, int fa){\n    if(u != 1){\n        if(fa == 1){\n            if(down[fa] == 1)g[u] = 1;\n            else g[u] = (f[fa] * down[fa] - f[u] - 1) / (down[fa] - 1) + 1;\n            s[u] = (f[u] * down[u] + g[u]) / (down[u] + 1);\n        }else {\n            g[u] = (g[fa] + (f[fa] * down[fa] - f[u] - 1)) / down[fa] + 1;\n            s[u] = (f[u] * down[u] + g[u]) / (down[u] + 1);\n        }\n    }\n    for(int k = hd[u]; ~k; k = E[k].nx){\n        int v = E[k].v;\n        if(v == fa)continue;\n        dfs2(v, u);\n    }\n}\nint n;\nint main(){\n//IN;\n    SC(n);\n    init_edge(n);\n    FF(i, 1, n - 1){\n        int u, v;\n        SCC(u, v);\n        add_edge(u, v);\n    }\n    dfs1(1, 0);\n    dfs2(1, 0);\n    s[1] = f[1];\n    FF(i, 1, n)printf(\"%.8f\\n\", s[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\ndouble d[200000];\ndouble dd[200000];\nvector<vector<ll> > vv;\n\ndouble f(ll p, ll parent){\n\tdouble ret = 0.0;\n\tll c = 0;\n\trep(i,0,vv[p].sz){\n\t\tif(vv[p][i] == parent)continue;\n\t\tret += f(vv[p][i], p);\n\t\tc++;\n\t}\n\tif(c>0)ret = 1. + ret / c;\n\treturn d[p] = ret;\n}\n\nvoid f1(ll p, double a, ll parent){\n\tdouble ret = 0.0;\n\trep(i,0,vv[p].sz){\n\t\tif(vv[p][i] == parent){\n\t\t\tret += 1. + a;\n\t\t}\n\t\telse{\n\t\t\tret += 1. + d[vv[p][i]];\n\t\t}\n\t}\n\tdd[p] = ret / vv[p].sz;\n\trep(i,0,vv[p].sz){\n\t\tif(vv[p][i] == parent)continue;\n\t\tif(vv[p].sz-1==0){\n\t\t\tf1(vv[p][i], 0.,p);\n\t\t}\n\t\telse{\n\t\t\tf1(vv[p][i], (ret-d[vv[p][i]]-1.)/(vv[p].sz-1),p);\n\t\t}\n\t}\n}\n\nint main() {\n\tll n;\n\tcin>>n;\n\tvector<vector<ll> > vv_(n,vector<ll>());\n\tvv = vv_;\n\trep(i,0,n-1){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tvv[a].pb(b);\n\t\tvv[b].pb(a);\n\t}\n\tf(0,-1);\n\tf1(0,0,-1);\n\trep(i,0,n){\n\t\tprintf(\"%20.20f\\n\",dd[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint N, E[150000][2];\nvi G[150000];\ndouble dp[150001][2];\n\ndouble f(int e, int s) {\n    double &res = dp[e][s];\n    if (res > -1)return res;\n    int u = E[e][s];\n    res = 0;\n    if (sz(G[u]) == 1)return res;\n    double p = 1.0 / (sz(G[u]) - 1);\n\n    each(ne, G[u])if (ne != e) {\n        res += f(ne, E[ne][0] == u);\n    }\n    res = res*p + 1.0;\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n    rep(i, N-1) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        E[i][0] = u;\n        E[i][1] = v;\n        G[u].push_back(i);\n        G[v].push_back(i);\n    }\n\n    rep(i, N)rep(j, 2)dp[i][j] = -2;\n    rep(i, N) {\n        double ans = 0, p = -1;\n        if (sz(G[i]))p = 1.0 / sz(G[i]);\n        each(e, G[i]) {\n            ans += f(e, E[e][0] == i);\n        }\n        if (sz(G[i]))ans = ans*p + 1;\n        printf(\"%.8f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include <map>\n#include <queue>\n#include <stack>\n#include<set>\n\n#define DIV 1000000007\nusing namespace std;\nusing ll = long long;\n\ntypedef struct {\n    vector<int> edge;\n    int par = 0;\n    double dp1 = 0, e = 0;\n    bool vi1=0, vi2=0;\n}node_t;\nvector<node_t> node;\n\ndouble dfs(int x) {\n    double sum = 0;\n    double n = node[x].edge.size();\n    double cnt = 0;\n    for (int i = 0; i < n; i++) {\n        int to = node[x].edge[i];\n        if (node[to].vi1) continue;\n        node[to].par = x;\n        node[to].vi1 = true;\n        sum += dfs(to) + 1;\n        cnt++;\n    }\n    if (cnt == 0) node[x].dp1 = 0;\n    else  node[x].dp1 = (double)sum / cnt;\n    return node[x].dp1;\n   \n}\n\ndouble dfs2(int y) {\n    int par = node[y].par;\n    double sp = node[par].edge.size();\n    double sn = node[y].edge.size();\n    //for(int i=0;i<)\n    if (y == 1) node[y].e = node[y].dp1;\n    else {\n        /*\n        double pp;\n        if (node[par].par == 0) pp = 0;\n        else pp = 1;\n        */\n        //node[y].e = (node[par].e * sp + (sn - 2) * node[y].dp1 + node[par].edge.size()-2) / sn;\n        double temp= node[par].e * sp - node[y].dp1 - 1;\n        if (temp == 0) node[y].e = (1+(sn - 1) * node[y].dp1) / sn;\n        else node[y].e = (temp / (sp - 1)+1 + (sn - 1) * node[y].dp1) / sn;\n        //node[y].e = ((node[par].e * sp - node[y].dp1 - 1 + (sp - 1)) / (sp - 1) + (sn - 1) * node[y].dp1) / sn;\n    }\n    //printf(\"node[%d].e=%lf\\n\", y, node[y].e);\n    for (int i = 0; i < sn; i++) {\n        int to = node[y].edge[i];\n        if (node[to].vi2) continue;\n        node[to].vi2 = true;\n        dfs2(node[y].edge[i]);\n    }\n    return node[y].e;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    node = vector<node_t>(N + 1);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        node[u].edge.push_back(v);\n        node[v].edge.push_back(u);\n    }\n   \n    node[1].vi1 = true;\n    dfs(1);\n    /*\n    for (int i = 1; i <= N; i++) {\n        printf(\"node[%d].dp1=%lf\\n\", i, node[i].dp1);\n    }\n    */\n    node[1].vi2 = true;\n    dfs2(1);\n    cout << endl;\n    for (int i = 1; i <= N; i++) {\n        //printf(\"node[%d].e=%lf\\n\", i, node[i].e);\n        printf(\"%.10lf\\n\",node[i].e);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = long long;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tstd::vector<std::vector<int>> g(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\n\t\tg[a - 1].push_back(b - 1);\n\t\tg[b - 1].push_back(a - 1);\n\t}\n\n\tstd::vector<double> dp(n);\n\tstd::vector<std::vector<std::pair<double, int>>> d(n);\n\tauto dfs = [&](auto&& dfs, int v, int par) -> void {\n\t\tint deg = g[v].size() - (par != -1);\n\t\tfor(auto e: g[v]) {\n\t\t\tif(e == par) continue;\n\t\t\tdfs(dfs, e, v);\n\t\t\tdp[v] += (dp[e] + 1) / deg;\n\t\t\td[v].push_back({dp[e], e});\n\t\t}\n\t};\n\tdfs(dfs, 0, -1);\n\t\n\tstd::vector<double> t(n), ans(n);\n\tauto solve = [&](auto&& solve, int v, int par) -> void {\n\t\tdouble sum = 0;\n\t\tfor(auto e: d[v]) sum += e.first;\n\t\tfor(auto e: d[v]) t[e.second] = e.first;\n\n\t\tfor(auto e: g[v]) {\n\t\t\tif(e == par) continue;\n\t\t\tint deg = g[e].size() - (g[e].size() != 1);\n\t\t\tdouble tmp = (sum - t[e]) / (g[v].size() - (g[v].size() != 1)) + 1;\n\t\t\tif(g[v].size() == 1) tmp = 0;\n\n\t\t\tans[e] += (tmp + 1) / g[e].size();\n\t\t\tans[v] += (dp[e] + 1) / g[v].size();\n\t\t\td[e].push_back({tmp, v});\n\t\t\tsolve(solve, e, v);\n\t\t}\n\t};\n\tsolve(solve, 0, -1);\n\n\tfor(auto v: ans) printf(\"%.12lf\\n\", v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define MP(a,b) make_pair(a,b)\ntypedef long long LL;\ntypedef pair<int, int> PI;\ntypedef vector<int> VI;\nconst LL MOD = 1000000007LL;\nvector<int> G[150000];\ndouble dp[150000];\ndouble dp2[150000];\nvoid dfs1(int v, int par) {\n\tint cnt = 0;\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) continue;\n\t\tdfs1(to, v);\n\t\tdp[v] += (dp[to] + 1);\n\t\tcnt++;\n\t}\n\tif (cnt > 0) dp[v] /= cnt;\n}\nvoid dfs2(int v, double d_par, int par) {\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) dp2[v] += (d_par + 1);\n\t\telse dp2[v] += (dp[to] + 1);\n\t}\n\trep(i, G[v].size()) {\n\t\tint to = G[v][i];\n\t\tif (to == par) continue;\n\t\tdouble D = dp2[v] - (dp[to] + 1);\n\t\tif (G[v].size() > 1) D /= (G[v].size() - 1);\n\t\tdfs2(to, D, v);\n\t}\n\tdp2[v] /= G[v].size();\n}\nint main() {\n\tint N;\n\tcin >> N;\n\trep(i, N - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs1(0, -1);\n\tdfs2(0, 0, -1);\n\trep(i, N) {\n\t\tprintf(\"%.15lf\\n\", dp2[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<list>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<string.h>\n#include<limits.h>\nusing namespace std;\n\nint a;\nvector<int>rinsetu[150000];\nunordered_map<int, double>U[150000];\ndouble Q[150000];\ndouble saiki(int i, int j) {\n\tif (rinsetu[j].size() == 1)return 1;\n\tif (U[i][j] != 0)return U[i][j] - 1;\n\tif (Q[j] != -1) {\n\t\tU[i][j]= (Q[j] - saiki(i, j)) / (rinsetu[j].size() - 1) + 2;\n\t\treturn (Q[j] - saiki(i, j)) / (rinsetu[j].size() - 1) + 1;\n\t}\n\tdouble K = 1;\n\tdouble T = 0;\n\tbool I = true;\n\tif (rinsetu[j].size() != 1) {\n\t\tdouble n = 0;\n\t\tfor (int x : rinsetu[j]) {\n\t\t\tif (x != i) {\n\t\t\t\tn += saiki(j, x);\n\t\t\t}\n\t\t\tif (U[x][j] != 0) {\n\t\t\t\tT += U[x][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tI = false;\n\t\t\t}\n\t\t}\n\t\tK += n / (rinsetu[j].size() - 1);\n\t}\n\tif (I)Q[j] = T;\n\tU[i][j] = K + 1;\n\treturn K;\n}\nsigned main() {\n\tscanf(\"%d\", &a);\n\tfill(Q, Q + a, -1);\n\tfor (int b = 1; b < a; b++) {\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tc--; d--;\n\t\trinsetu[c].push_back(d);\n\t\trinsetu[d].push_back(c);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j : rinsetu[i]) {\n\t\t\tans += saiki(i, j);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", ans / rinsetu[i].size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing Pos = complex<double>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nstruct ci : public iterator<forward_iterator_tag, ll> { ll n; ci(const ll n) : n(n) { } bool operator==(const ci& x) { return n == x.n; } bool operator!=(const ci& x) { return !(*this == x); } ci &operator++() { n++; return *this; } ll operator*() const { return n; } };\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n#define ldout fixed << setprecision(40) \n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vector<double> d(n);\n    function<double(ll, ll)> dfs1 = [&](ll u, ll p) {\n        ll num = (p == -1 ? g[u].size() : g[u].size() - 1);\n        if (p != -1 && g[u].size() <= 1) {\n            return d[u] = 0;\n        }\n        double ret = 1;\n        for (auto v : g[u]) if (v != p) {\n            ret += dfs1(v, u) / num;\n        }\n        return d[u] = ret;\n    };\n    dfs1(0, -1);\n//    cout << d << endl;\n\n    vector<double> ret(n);\n    // dpar = pからuに来た時、pのu以外の部分木の期待値\n    function<void(ll, ll, double)> dfs2 = [&](ll u, ll p, double dpar) {\n        double sum = 0;\n        for (auto v : g[u]) if (v != p) {\n            sum += d[v] + 1;\n        }\n        if (p != -1) sum += dpar + 1;\n//        cout << u << \" \" << p << \" \" << dpar<< \" : \" << sum << endl;\n\n        if (p == -1) {\n            ret[u] = d[u];\n        } else {\n            ret[u] = sum / g[u].size();\n        }\n\n        for (auto v : g[u]) if (v != p) {\n            // dpar = uのv以外の部分木の期待値\n            double next_dpar = 0;\n            if (g[u].size() > 1) \n                next_dpar = (sum - d[v] - 1) / (g[u].size() - 1);\n            dfs2(v, u, next_dpar);\n        }\n\n        return;\n    };\n    dfs2(0, -1, 0);\n\n    rep(i, n) {\n        cout << ldout << ret[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string& s, char c) { vector<string> v; stringstream ss(s); string x; while(getline(ss,x,c)) v.emplace_back(x); return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\ndouble re[151234];\ndouble dp[151234];\n\ndouble dfs(const vv<int> &g,int v,int p){\n  double re=0;\n  int cnt=0;\n  for(int w:g[v])if(w!=p) re+=dfs(g,w,v)+1, ++cnt;\n  return dp[v]=cnt?re/cnt:0;\n}\nvoid dfs(const vv<int> &g,int v,int p,double P){\n  double sum=P;\n  for(int w:g[v])if(w!=p) sum+=dp[w]+1;\n  //out(v,sum,P,1);\n  re[v]=sum/g[v].size();\n  for(int w:g[v])if(w!=p) dfs(g,w,v,(sum-dp[w]-1)/(g[v].size()-!!v)+1);\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int n;\n  cin>>n;\n  if(n==1){\n    cout<<0<<endl;\n    return 0;\n  }\n  vv<int> g(n);\n  rep(i,n-1){\n    int x,y;\n    cin>>x>>y; --x; --y;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  dfs(g,0,-1);\n  //rep(i,n) cout<<dp[i]<<endl;\n  dfs(g,0,-1,0);\n  rep(i,n) cout<<re[i]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<fstream>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define INF 0X3F3F3F3F\n#define N 200005\n#define M 200005\n#define LL long long\n#define FF(i,a,b) for(int i=a;i<=b;++i)\n#define RR(i,a,b) for(int i=a;i>=b;--i)\n#define FJ(i,a,b) for(int i=a;i<b;++i)\n#define SC(x) scanf(\"%d\",&x)\n#define SCC(x,y) scanf(\"%d%d\",&x,&y)\n#define SCCC(x,y,z) scanf(\"%d%d%d\",&x,&y,&z)\n#define SS(x) scanf(\"%s\",x)\n#define PR(x) printf(\"%d\\n\",x)\n#define CL(a, x) memset(a, x, sizeof(a))\n#define _q fd[rt]\n#define _l fd[rt<<1]\n#define _r fd[rt<<1|1]\n#define MID int mid=((l+r)>>1)\n#define lson rt<<1,l,mid\n#define rson rt<<1|1,mid+1,r\n#define PB push_back\n#define SZ size\n#define PII pair<int,int>\n#define PLL pair<long long,long long>\n#define MP make_pair\n#define IN freopen(\"in.txt\",\"r\",stdin)\n#define OUT freopen(\"out.txt\",\"w\",stdout)\nusing namespace std;\nconst int MOD=1000000007;\nconst double PI=acos(-1.0);\nconst double EPS=1e-8;\ninline void II(int &n){char ch=getchar();n=0;bool t=0;\nfor(;ch<'0';ch=getchar())if(ch=='-')t=1;\nfor(;ch>='0';n=n*10+ch-'0',ch=getchar());if(t)n=-n;}\ninline void OO(int a){if(a<0){putchar('-');a=-a;}\nif(a>=10)OO(a/10);putchar(a%10+'0');}\ninline int sgn(double x){return(x>EPS)-(x<-EPS);}\nstruct EE{int v,nx;}E[M*2+N*2];int hd[N],EN;\nvoid init_edge(int num){EN=0;memset(hd,-1,(num+3)<<2);}\nvoid add_edge(int u,int v){\n    E[EN].v=v;E[EN].nx=hd[u];hd[u]=EN++;\n    E[EN].v=u;E[EN].nx=hd[v];hd[v]=EN++;\n}\nLL down[N];\ndouble g[N], f[N], s[N];\nbool leaf[N];\nvoid dfs1(int u, int fa){\n    for(int k = hd[u]; ~k; k = E[k].nx){\n        int v = E[k].v;\n        if(v == fa)continue;\n        ++down[u];\n        dfs1(v, u);\n        f[u] += f[v] + 1;\n    }\n    if(down[u])f[u] /= down[u];\n}\nvoid dfs2(int u, int fa){\n    if(u != 1){\n        if(fa == 1){\n            if(down[fa] == 1)g[u] = 1;\n            else g[u] = (f[fa] * down[fa] - f[u] - 1) / (down[fa] - 1) + 1;\n            s[u] = (f[u] * down[u] + g[u]) / (down[u] + 1);\n        }else {\n            g[u] = (g[fa] + (f[fa] * down[fa] - f[u] - 1)) / down[fa] + 1;\n            s[u] = (f[u] * down[u] + g[u]) / (down[u] + 1);\n        }\n    }\n    for(int k = hd[u]; ~k; k = E[k].nx){\n        int v = E[k].v;\n        if(v == fa)continue;\n        dfs2(v, u);\n    }\n}\nint n;\nint main(){\n//IN;\n    SC(n);\n    init_edge(n);\n    FF(i, 1, n - 1){\n        int u, v;\n        SCC(u, v);\n        add_edge(u, v);\n    }\n    dfs1(1, 0);\n    dfs2(1, 0);\n    s[1] = f[1];\n    FF(i, 1, n)printf(\"%.8f\\n\", s[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\n\nint n, par[150005];\nvector<int> gph[150005];\nvector<int> ord;\n\nvoid dfs(int x, int p){\n\tord.push_back(x);\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\tpar[i] = x;\n\t\tdfs(i, x);\n\t}\n}\n\ndouble dp[150005], pdp[150005], val[150005];\nint cnt[150005];\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tdfs(1, -1);\n\tfor(int i=ord.size()-1; i>=0; i--){\n\t\tint p = ord[i];\n\t\tfor(auto &j : gph[p]){\n\t\t\tif(j != par[p]){\n\t\t\t\tcnt[p]++;\n\t\t\t\tval[p] += 1 + dp[j];\n\t\t\t}\n\t\t}\n\t\tif(cnt[p]) dp[p] = val[p] / cnt[p];\n\t\telse dp[p] = 0;\n\t}\n\tfor(int i=1; i<ord.size(); i++){\n\t\tint p = ord[i];\n\t\tint cs = cnt[par[p]];\n\t\tdouble vs = val[par[p]];\n\t\tif(par[p] != 1){\n\t\t\tcs++;\n\t\t\tvs += 1 + pdp[par[p]];\n\t\t}\n\t\tcs--;\n\t\tvs -= 1 + dp[p];\n\t\tif(cs) pdp[p] = vs / cs;\n\t\telse pdp[p] = 0;\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tdouble tsum = val[i];\n\t\tint tcnt = cnt[i];\n\t\tif(i > 1){\n\t\t\ttcnt++;\n\t\t\ttsum += pdp[i] + 1;\n\t\t}\n\t\tprintf(\"%.10f\\n\", tsum / tcnt);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\nvector< int > g[150000];\ndouble dp1[150000];\ndouble dp2[150000];\n\ndouble dfs(int idx, int par = -1)\n{\n  dp1[idx] = 0;\n  int child = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ++child;\n  }\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dp1[idx] += (dfs(to, idx) + 1) / child;\n  }\n  return (dp1[idx]);\n}\n\nvoid dfs2(int idx, double beet = 0, int par = -1)\n{\n  int child = 0;\n  double latte = 0;\n\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ++child;\n    dp2[idx] += (dp1[to] + 1) / g[idx].size();\n  }\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(g[idx].size() - 1 == 0) latte += dp1[to] + 1;\n    else latte += (dp1[to] + 1) / (g[idx].size() - 1);\n  }\n\n  if(~par) dp2[idx] += (beet + 1) / g[idx].size();\n  if(~par) {\n    if(g[idx].size() - 1 == 0) latte += beet + 1;\n    else latte += (beet + 1) / (g[idx].size() - 1);\n  }\n\n  if(child == 0) return;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, latte - (g[idx].size() - 1 == 0 ? dp1[to] + 1 : (dp1[to] + 1) / (g[idx].size() - 1)), idx);\n  }\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0);\n  dfs2(0);\n  for(int i = 0; i < N; i++) {\n\n    cout << fixed << setprecision(10) << dp2[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nstruct Init{\n  Init(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n}init;\n\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n\n  Edge rev() const {return Edge(to,from,cost);}\n  \n  friend ostream& operator<<(ostream &os, const Edge &e){\n    os << \"(FROM: \" << e.from << \",\" << \"TO: \" << e.to << \",\" << \"COST: \" << e.cost << \")\";\n    return os;\n  }\n};\n\ntemplate <typename T> using Graph = vector<vector<Edge<T>>>;\ntemplate <typename T> using Tree = vector<vector<Edge<T>>>;\n\ntemplate <typename C, typename T> void add_edge(C &g, int from, int to, T w){\n  g[from].push_back(Edge<T>(from, to, w));  \n}\n\ntemplate <typename C, typename T> void add_undirected(C &g, int a, int b, T w){\n  g[a].push_back(Edge<T>(a, b, w));\n  g[b].push_back(Edge<T>(b, a, w));\n}\n\nint N;\nTree<int> tree;\n\ndouble dp1[200000];\ndouble dp2[200000];\n\nint deg[200000];\n\nvoid dfs1(int cur){\n  for(auto &e : tree[cur]){\n    dfs1(e.to);\n    dp1[cur] += (dp1[e.to]+1) / tree[cur].size();\n  }\n}\n\nvoid dfs2(int cur){\n  int c = tree[cur].size();\n\n  vector<double> left(c+1);\n  REP(i,c) left[i+1] = left[i] + (dp1[tree[cur][i].to]+1);\n\n  double right = 0;\n\n  REV(i,(int)tree[cur].size()-1,0){\n    int nxt = tree[cur][i].to;\n\n    if(deg[cur] == 1){\n      dp2[nxt] = 0;\n    }else{\n      if(cur == 0){\n        dp2[nxt] = (left[i] + right) / (deg[cur]-1);        \n      }else{\n        dp2[nxt] = ((dp2[cur]+1) + left[i] + right) / (deg[cur]-1);\n      }\n    }\n\n    right += dp1[tree[cur][i].to]+1;\n    dfs2(nxt);\n  }\n}\n\ndouble dp[200000];\n\nvoid dfs(int cur){\n  if(deg[cur] != (int)tree[cur].size()) dp[cur] = dp2[cur]+1;\n  for(auto &e : tree[cur]){\n    dfs(e.to);\n    dp[cur] += (dp1[e.to]+1);\n  }\n  dp[cur] /= deg[cur];\n}\n\ntemplate <typename T>\nvoid convert_rooted_tree(Tree<T> &tree, int cur, int par=-1){\n  auto it = tree[cur].begin();\n  while(it != tree[cur].end()){\n    if(it->to == par) break;\n    ++it;\n  }\n  if(it != tree[cur].end()) tree[cur].erase(it);\n  for(auto &e : tree[cur]){\n    convert_rooted_tree(tree,e.to,e.from);\n  }\n}\n\n\nint main(){\n  while(cin >> N){\n    tree = Tree<int>(N);\n    fill_array(deg, 0);\n\n    REP(i,N-1){\n      int u,v; cin >> u >> v;\n      --u, --v;\n      add_undirected(tree, u, v, 1);\n      deg[u]++;\n      deg[v]++;\n    }\n\n    convert_rooted_tree(tree, 0);\n\n\n    fill_array(dp1, 0);\n    fill_array(dp2, 0);\n    fill_array(dp, 0);\n\n    \n    dfs1(0);\n    dfs2(0);\n    \n    dfs(0);\n\n    REP(i,N){\n      double ans = dp[i];\n      cout << fixed << setprecision(12) << ans << endl;\n    }\n    cerr << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> g[150005];\ndouble d[150005];\n\nvoid dfs1(int cur, int par) {\n    int cnt = (int)g[cur].size() - (par != -1);\n    if (cnt == 0) return;\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        dfs1(nex, cur);\n        d[cur] += (d[nex] + 1) / cnt;\n    }\n}\n\ndouble ans[150005];\n\nvoid dfs2(int cur, double d_par, int par) {\n    int cnt = g[cur].size();\n    for (int nex : g[cur]) {\n        if (nex == par) ans[cur] += d_par + 1;\n        else ans[cur] += d[nex] + 1;\n    }\n\n    for (int nex : g[cur]) {\n        if (nex == par) continue;\n        if (cnt > 1) dfs2(nex, (ans[cur] - d[nex] - 1) / (cnt - 1), cur);\n    }\n    ans[cur] /= cnt;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << setprecision(20) << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[150000];\nvector<double> dp[150000];\n\ndouble dfs(int x, int p) {\n  if (dp[x][p] != -1) return dp[x][p];\n  int c = G[x].size();\n  if (p != G[x].size()) c--;\n\n  if (c == 0) return dp[x][p] = 0;\n  double r = 0;\n  for (int i=0; i<G[x].size(); i++) {\n    if (i == p) continue;\n    int t = G[x][i];\n    r += dfs(t, lower_bound(all(G[t]), x)-G[t].begin())/c;\n  }\n  return dp[x][p] = r+1;\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) {\n    sort(all(G[i]));\n    dp[i].resize(G[i].size()+1, -1);\n  }\n  rep(i, N) {\n    cout << fixed << setprecision(15) << dfs(i, G[i].size()) << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/***********************************************\n#\n#      Filename: d.cpp\n#\n#        Author: Comsyl - ylsong15@fudan.edu.cn\n#   Description: ---\n#        Create: 2017-05-20 10:05:23\n***********************************************/\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<vector<int>> a;\n\ndouble dfs(int cur, int par) {\n    double ans = 0;\n    int choice = a[cur].size();\n    if (par != -1) -- choice;\n    for (auto v : a[cur]) {\n        if (v != par) {\n            ans += 1.0 / choice * (1.0 + dfs(v, cur));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    int u, v;\n    a = vector<vector<int>> (n);\n    for (int i = 0; i < n-1; ++ i) {\n        cin >> u >> v;\n        -- u; -- v;\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 0; i < n; ++ i) {\n        cout << setprecision(12) << dfs(i, -1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nvi g[252521];\ndouble val[252521];\n\ndouble ans[252521];\n\ndouble dfs1(int p,int bef){\n  double sum = 0.0;\n  double cnt = 0.0;\n  for(int to : g[p])if(to!=bef){\n    sum += dfs1(to,p)+1.0;\n    cnt += 1.0;\n  }\n  if(cnt != 0.0)sum /= cnt;\n  return val[p] = sum;\n}\n\nvoid dfs2(int p,int bef){\n  // root is p\n  ans[p] = val[p];\n  // summation\n  double childsum = 0.0;\n  double cnt = (double)g[p].size();\n  for(int to : g[p]){\n    childsum += val[to];\n  }\n  for(int to : g[p])if(to!=bef){\n    // rotate root to\n    double bef = val[to];\n    val[p] = cnt==1.0 ? 0.0 : (childsum - val[to] + cnt - 1) / (cnt - 1);\n    val[to] = (val[to] * (g[to].size()-1) + val[p] + 1) / g[to].size();\n    dfs2(to,p);\n    val[to] = bef;\n  }\n  val[p] = ans[p];\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n-1){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    --u;--v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs1(0,-1);\n  dfs2(0,-1);\n  REP(i,n)printf(\"%.9f\\n\",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nvint G[222222];\n\ndouble P[222222];\nvoid dfs(int v,int p){\n    int cnt=0;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        cnt++;\n        dfs(u,v);\n        P[v]+=P[u]+1;\n    }\n\n    if(cnt==0)return;\n    P[v]/=cnt;\n}\n\ndouble ans[222222];\nvoid dfs2(int v,int p,double luz){\n    if(v==0){\n        ans[v]=P[v];\n    }\n    else{\n        ans[v]=(P[v]*(G[v].size()-1)+luz)/G[v].size();\n    }\n\n    for(auto u:G[v]){\n        if(u==p)continue;\n        if(v==0){\n            if(G[v].size()==1){\n                dfs2(u,v,1);\n            }\n            else{\n                double tmp=P[v]*G[v].size();\n                tmp-=P[u]+1;\n                tmp/=(G[v].size()-1);\n                dfs2(u,v,tmp+1);\n            }\n        }\n        else{\n            int deg=G[v].size()-1;\n            double tmp=P[v]*deg;\n            tmp-=P[u]+1;\n            tmp+=luz;\n            tmp/=deg;\n            dfs2(u,v,tmp+1);\n        }\n    }\n}\n\nsigned main(){\n    scanf(\"%lld\",&N);\n    rep(i,N-1){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    dfs(0,-1);\n    dfs2(0,-1,0.0);\n    rep(i,N)printf(\"%.20f\\n\",ans[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define  inc(i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define  dec(i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define UB upper_bound\n#define LB lower_bound\n#define PQ priority_queue\n\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\n#define  FOR(it, v) for(auto it =  v.begin(); it !=  v.end(); ++it)\n#define RFOR(it, v) for(auto it = v.rbegin(); it != v.rend(); ++it)\n\ntemplate<typename T> bool   setmin(T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool   setmax(T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nvector<int> vec[1000];\n\ndouble dfs(int x, int p) {\n\tdouble ans = 0;\n\tinc(i, vec[x].size()) {\n\t\tif(vec[x][i] == p) { continue; }\n\t\tans += dfs(vec[x][i], x) / (vec[x].size() - (p != -1));\n\t}\n\t\n\treturn ans + 1.0;\n}\n\nint main() {\n\tcin >> n;\n\tinc(i, n - 1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tvec[u].PB(v);\n\t\tvec[v].PB(u);\n\t}\n\t\n\tif(n > 1000) { return 1; }\n\t\n\tinc(i, n) {\n\t\tprintf(\"%.12f\\n\", dfs(i, -1) - 1.0);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define MAXN 150009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<\"----------------\"<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nvector<int>adj[MAXN];\ndouble ans[MAXN],suf[MAXN],pre[MAXN],res[MAXN];\ndouble dfs(int nd,int pr){\n\tif(~pr and adj[nd].size()==1)\n\t\treturn 0.0;\n\tfor(int i=0;i<int(adj[nd].size());i++){\n\t\tint to=adj[nd][i];\n\t\tif(to==pr)\n\t\t\tcontinue;\n\t\tans[nd]+=dfs(to,nd);\t\n\t}\n\tif(~pr)\n\t\tans[nd]=ans[nd]/double(adj[nd].size()-1)+1.0;\n\telse\t\n\t\tans[nd]=ans[nd]/double(adj[nd].size())+1.0;\n\treturn ans[nd];\t\n}\nvoid dfs1(int nd,int pr,double par){\n\tres[nd]=par;\n\tfor(int i=0;i<int(adj[nd].size());i++){\n\t\tint to=adj[nd][i];\n\t\tif(to==pr)\n\t\t\tcontinue;\n\t\tres[nd]+=ans[to];\t\n\t}\n\tres[nd]=res[nd]/double(adj[nd].size())+1;\n\tif(adj[nd].size()==1){\n\t\tif(pr==-1)\n\t\t\tdfs1(adj[nd][0],nd,0);\n\t\treturn;\n\t}\n\tdouble sum=0;\n\tfor(int i=0;i<int(adj[nd].size());i++){\n\t\tint to=adj[nd][i];\n\t\tif(to==pr)\n\t\t\tcontinue;\n\t\tpre[to]=sum;\n\t\tsum+=ans[to];\n\t}sum=0;\n\tfor(int i=int(adj[nd].size()-1);i>=0;i--){\n\t\tint to=adj[nd][i];\n\t\tif(to==pr)\n\t\t\tcontinue;\n\t\tsuf[to]=sum;\n\t\tsum+=ans[to];\n\t}\n\tfor(int i=0;i<int(adj[nd].size());i++){\n\t\tint to=adj[nd][i];\n\t\tif(to==pr)\t\n\t\t\tcontinue;\n\t\tdfs1(to,nd,(par+suf[to]+pre[to])/double(adj[nd].size()-1)+1.0);\t\n\t}\n}\nint main(){\n\t//~ #ifndef ONLINE_JUDGE\n    //~ freopen(\"file.in\", \"r\", stdin);\n\t//~ #endif\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\tdfs(1,-1);\n\tdfs1(1,-1,0);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%.12lf\\n\",res[i]);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[150000];\ndouble sum1[150000];\ndouble sum2[150000];\ndouble dp1[150000];\ndouble ans[150000];\n\ndouble dfs1(int v, int p){\n\tint M = G[v].size();\n\tif(p != -1) M--;\n\tif(M == 0) return 0;\n\n\tfor(auto c : G[v]){\n\t\tif(c == p) continue;\n\t\tsum1[v] += dfs1(c, v) + 1;\n\t}\n\treturn dp1[v] = sum1[v] / M;\n}\n\nvoid dfs2(int v, int p){\n\tfor(auto c : G[v]){\n\t\tif(c == p) continue;\n\t\tsum2[v] += dp1[c] + 1.0;\n\t}\n\tif(p != -1){\n\t\tif(G[p].size() != 1){\n\t\t\tsum2[v] += (sum2[p] - (dp1[v] + 1.0)) / (G[p].size() - 1) + 1.0;\n\t\t}\n\t\telse{\n\t\t\tsum2[v] += 1.0;\n\t\t}\n\t}\n\tans[v] = sum2[v] / G[v].size();\n\n\tfor(auto c : G[v]){\n\t\tif(c != p) dfs2(c, v);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N - 1; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tdfs1(0, -1);\n\tdfs2(0, -1);\n\tfor(int i = 0; i < N; i++){\n\t\tcout << fixed << setprecision(15) << ans[i] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nint edc[150010];\nvector<int> lis[150010];\n\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (edc[nod] == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (edc[nod] - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    if (n == 1)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        scanf(\"%d %d\", &edge[i][0], &edge[i][1]);\n        --edge[i][0];\n        --edge[i][1];\n        ++edc[edge[i][0]];\n        ++edc[edge[i][1]];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        double ans = 0;\n        for (int item : lis[i])\n        {\n            ans += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        printf(\"%.9f\\n\", ans / edc[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n\nusing namespace std;\n\nconst int maxn = 15e4 + 5;\n\ndouble dp[maxn], dp2[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u, int fa) {\n    dp[u] = 0;\n    double p = G[u].size();\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dfs(v, u);\n        dp[u] += (dp[v] + 1) / p;\n    }\n}\n\nvoid dfs2(int u, int fa) {\n    double p = G[u].size();\n    if (fa != -1) p --;\n    for (int v : G[u]) if (v != fa) {\n        dp2[v] = (dp[u] + 1) + (dp2[u] - dp[v] - 1) / p;\n        dfs2(v, u);\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int N; cin>>N;\n    for (int i = 0; i < N - 1; i ++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    dfs(1, -1);\n    dfs2(1, -1);\n    \n    printf(\"%.6f\\n\", dp[1]);\n    for (int i = 2; i <= N; i ++) {\n        double p = G[i].size();\n        printf(\"%.6f\\n\", (dp[i] * (p - 1) + dp2[i]) / p);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\n\nint n;\nvector<int> gph[150005];\n\ndouble f(int x, int p){\n\tdouble ret = 0;\n\tint cnt = 0;\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\tcnt++;\n\t\tret += 1 + f(i, x);\n\t}\n\tif(cnt == 0) return 0;\n\treturn ret / cnt;\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tprintf(\"%.10f\\n\", f(i, -1));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\nusing namespace std;\n#define SZ 666666\n#define Edg int M = 0,fst[SZ],vb[SZ],nxt[SZ]\n#define es(x,e) (int e = fst[x]; e; e = nxt[e])\n#define esb(x,e,b) (int e = fst[x], b = vb[e]; e; e = nxt[e], b = vb[e])\nint n,d[SZ]; Edg;\nvoid ad_de(int a,int b)\n{\n\t++ M;\n\tnxt[M] = fst[a];\n\tfst[a] = M;\n\tvb[M] = b;\n}\nvoid adde(int a,int b)\n{\n\tad_de(a,b);\n\tad_de(b,a);\n}\nld f[SZ],ca=0;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nvoid dp1(int x,int fa=0)\n{\n\tf[x] = 0;\n\tfor esb(x, e, b)\n\t\tif(b != fa)\n\t\t\tdp1(b,x), f[x] += (f[b] + 1) / ld(d[x] - bool(fa));\n}\nld anss[SZ];\nvoid dp2(int x, int fa = 0)\n{\n\tld cc = ca;\n\tanss[x] = cc;\n\tfor esb(x,e,b)\n\t\tif(b != fa)\n\t\t{\n\t\t\tld ts = (f[b]+1)/ld(d[x]);\n\t\t\tld ot = 0;\n\t\t\tif(fabs(cc - ts) > 1e-6)\n\t\t\t\tot = (cc - ts) / (1 - 1.0 / ld(d[x]));\n\t\t\tot ++;\n\t\t\tca = f[b] * (1 - 1.0 / ld(d[b])) + ot * 1.0 / ld(d[b]);\n\t\t\tdp2(b,x);\n\t\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i < n; i ++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a, b);\n\t\td[a] ++;\n\t\td[b] ++;\n\t}\n\tdp1(1);\n\tca = f[1];\n\tdp2(1);\n\tfor(int i = 1; i <= n; i ++)\n\t\tprintf(\"%.10lf\\n\",anss[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <vector>\n#include <iostream>\n#include<algorithm>\n#include<string>\n#include <map>\n#include <queue>\n#include <stack>\n#include<set>\n\n#define DIV 1000000007\nusing namespace std;\nusing ll = long long;\nusing ldb = long double;\n\ntypedef struct {\n    vector<int> edge;\n    int par = 0;\n    ldb dp1 = 0, e = 0;\n    bool vi1 = 0, vi2 = 0;\n}node_t;\nvector<node_t> node;\n\nldb dfs(int x) {\n    ldb sum = 0.0;\n    ldb n = node[x].edge.size();\n    ldb cnt = 0;\n    for (int i = 0; i < n; i++) {\n        int to = node[x].edge[i];\n        if (node[to].vi1) continue;\n        node[to].par = x;\n        node[to].vi1 = true;\n        sum += dfs(to) + 1;\n        cnt++;\n    }\n    if (cnt == 0) node[x].dp1 = 0;\n    else  node[x].dp1 = (double)sum / cnt;\n    return node[x].dp1;\n\n}\n\nvoid dfs2(int y) {\n    int par = node[y].par;\n    ldb sp = node[par].edge.size();\n    ldb sn = node[y].edge.size();\n    if (y == 1) node[y].e = node[y].dp1;\n    else {\n        ldb temp = node[par].e * sp - node[y].dp1 - 1.0;\n        if (temp == 0) node[y].e = (1.0 + (sn - 1.0) * node[y].dp1) / sn;\n        else node[y].e = (temp / (sp - 1.0) + 1.0 + (sn - 1.0) * node[y].dp1) / sn;\n    }\n    for (int i = 0; i < sn; i++) {\n        int to = node[y].edge[i];\n        if (node[to].vi2) continue;\n        node[to].vi2 = true;\n        dfs2(node[y].edge[i]);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    node = vector<node_t>(N + 1);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        node[u].edge.push_back(v);\n        node[v].edge.push_back(u);\n    }\n\n    node[1].vi1 = true;\n    dfs(1);\n    node[1].vi2 = true;\n    dfs2(1);\n    for (int i = 1; i <= N; i++) {\n        printf(\"%.15Lf\\n\", node[i].e);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 210000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nstruct TreeDP{\n\ttypedef double vint;\n\tstatic const int maxN=110000;\n\tstruct edge{\n\t\tint to;\n\t\tint rev;\n\t\t// ここに何かをもたせたいときはその都度編集する\n\t\tedge(int a,int b){to=a;rev=b;}\n\t\tedge(){to=rev=0;}\n\t};\n\tvector<edge>g[maxN];\n\tvector<int>lp;\n\tvector<int>rp;\n\tvector<vint>L[maxN];\n\tvector<vint>R[maxN];\n\tint N;\n\tvint dfs(int a,int b){\n\t\tL[a][0]=R[a][0]=0;\n\t\twhile(lp[a]<g[a].size()&&b!=lp[a]){\n\t\t\tL[a][lp[a]+1]=L[a][lp[a]]+(1+dfs(g[a][lp[a]].to,g[a][lp[a]].rev));\n\t\t\tlp[a]++;\n\t\t}\n\t\twhile(rp[a]<g[a].size()&&b!=g[a].size()-1-rp[a]){\n\t\t\tR[a][rp[a]+1]=R[a][rp[a]]+(1+dfs(g[a][g[a].size()-1-rp[a]].to,g[a][g[a].size()-1-rp[a]].rev));\n\t\t\trp[a]++;\n\t\t}\n\t\tif(b==-1){\n\t\t\tif(g[a].size()==0)return 0;\n\t\t\treturn L[a][g[a].size()]/g[a].size();\n\t\t}else{\n\t\t\tif(g[a].size()==1)return 0;\n\t\t\treturn (L[a][b]+R[a][g[a].size()-b-1])/(g[a].size()-1);\n\t\t}\n\t}\n\n\t// 何か重みのある辺が追加したいときはここを変える\n\t// 各辺について2度以上呼ばないようにする\n\tvoid add_edge(int from,int to){\n\t\tg[from].push_back(edge(to,g[to].size()));\n\t\tg[to].push_back(edge(from,g[from].size()-1));\n\t}\n\tvector<vint> solve(int n){\n\t\tN=n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tL[i]=vector<vint>(g[i].size()+1);\n\t\t\tR[i]=vector<vint>(g[i].size()+1);\n\t\t}\n\t\tlp=vector<int>(n);\n\t\trp=vector<int>(n);\n\t\tvector<vint>ret(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tret[i]=dfs(i,-1);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tTreeDP td;\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\ttd.add_edge(p,q);\n\t}\n\tvector<double>ret=td.solve(a);\n\tfor(int i=0;i<a;i++)printf(\"%.12f\\n\",ret[i]);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct directedGraph{\n  int *vertex;\n  int *next;\n  int *start;\n  int v,e;\n  int pointer;\n} graph;\n\ngraph* newGraph(const int v,const int e){\n  graph *g=(graph *)malloc(sizeof(graph));\n  g->vertex=(int *)calloc(e,sizeof(int));\n  g->next=(int *)calloc(e,sizeof(int));\n  g->start=(int *)calloc(v,sizeof(int));\n  for(int i=0;i<v;i++) g->start[i]=-1;\n  g->v=v;\n  g->e=e;\n  g->pointer=0;\n  return g;\n}\n\nvoid freeGraph(graph *g){\n  free(g->vertex);\n  free(g->next);\n  free(g->start);\n  free(g);\n  return;\n}\n\nvoid addEdge(graph *g,const int from,const int to){\n  const int p=g->pointer;\n  g->vertex[p]=to;\n  g->next[p]=g->start[from];\n  g->start[from]=p;\n  g->pointer++;\n  return;\n}\n\nvoid run(void){\n  int n;\n  scanf(\"%d\",&n);\n  if(n==1){\n    printf(\"0\\n\");\n    return;\n  }\n  graph *g=newGraph(n,2*n);\n  int i;\n  for(i=0;i<n-1;i++){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    a--;b--;\n    addEdge(g,a,b);\n    addEdge(g,b,a);\n  }\n  int *parent=(int *)calloc(n,sizeof(int));\n  int *q=(int *)calloc(n,sizeof(int));\n  int front=0;\n  int last=0;\n  q[last++]=0;\n  while(last<n){\n    int v=q[front++];\n    for(int p=g->start[v];p!=-1;p=g->next[p]){\n      int u=g->vertex[p];\n      if(u==parent[v]) continue;\n      parent[u]=v;\n      q[last++]=u;\n    }\n  }\n  double *dp1=(double *)calloc(n,sizeof(double));\n  for(i=n-1;i>=0;i--){\n    int v=q[i];\n    double sum=0;\n    int cnt=0;\n    for(int p=g->start[v];p!=-1;p=g->next[p]){\n      int u=g->vertex[p];\n      if(u==parent[v]) continue;\n      sum+=dp1[u];\n      cnt++;\n    }\n    dp1[v]=cnt==0?0:(1+sum/cnt);\n  }\n  double *dp2=(double *)calloc(n,sizeof(double));\n  double *ans=(double *)calloc(n,sizeof(double));\n  for(i=0;i<n;i++){\n    int v=q[i];\n    double sum=dp2[v];\n    int cnt=(i>0?1:0);\n    for(int p=g->start[v];p!=-1;p=g->next[p]){\n      int u=g->vertex[p];\n      if(u==parent[v]) continue;\n      sum+=dp1[u]+1;\n      cnt++;\n    }\n    ans[v]=sum/cnt;\n    for(int p=g->start[v];p!=-1;p=g->next[p]){\n      int u=g->vertex[p];\n      if(u==parent[v]) continue;\n      dp2[u]=1;\n      if(cnt>1) dp2[u]+=(sum-dp1[u]-1)/(cnt-1);\n    }\n  }\n  for(i=0;i<n;i++) printf(\"%.9f\\n\",ans[i]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong t[150001],u[150000],v[150000];\nint main(int argc, char const *argv[]){\n\tlong n,i,s,e;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%ld %ld\",&u[i],&v[i]);\n\t}\n\tt[u[0]]=0;\n\tt[v[0]]=1;\n\ts=u[0];\n\te=v[0];\n\tfor(i=1;t[e]-t[s]+1<n;i++){\n\t\tif(u[i]==s || v[i]==s){\n\t\t\tt[(u[i]==s)?v[i]:u[i]]=t[s]-1;\n\t\t\ts=(u[i]==s)?v[i]:u[i];\n\t\t\ti=1;\n\t\t}else if(u[i]==e || v[i]==e){\n\t\t\tt[(u[i]==e)?v[i]:u[i]]=t[e]+1;\n\t\t\te=(u[i]==e)?v[i]:u[i];\n\t\t\ti=1;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(s==i || e==i){\n\t\t\tprintf(\"%f\\n\",(double)(n-1));\n\t\t}else{\n\t\t\tprintf(\"%f\\n\",(n-1)/2.0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong t[150001][2],u[150000],v[150000];\nint main(int argc, char const *argv[]){\n\tlong n,i,s,e,j;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%ld %ld\",&u[i],&v[i]);\n\t\tif(t[u[i]][0]==0) t[u[i]][0]=v[i];\n\t\telse t[u[i]][1]=v[i];\n\t\tif(t[v[i]][0]==0) t[v[i]][0]=u[i];\n\t\telse t[v[i]][1]=u[i];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(t[i][1]==0) break;\n\t}\n\ts=i;\n\tj=s;\n\ti=t[s][0];\n\twhile(t[i][1]!=0){\n\t\tif(t[i][0]==j){\n\t\t\tj=i;\n\t\t\ti=t[i][1];\n\t\t}else{\n\t\t\tj=i;\n\t\t\ti=t[i][0];\n\t\t}\n\t}\n\te=i;\n\tfor(i=1;i<=n;i++){\n\t\tif(s==i || e==i){\n\t\t\tprintf(\"%f\\n\",n-1);\n\t\t}else{\n\t\t\tprintf(\"%f\\n\",(n-1)/2.0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_ON\t\t\t1\t\t\t\t\t\t\t\t\t\t// 汎用フラグ - ON\n#define D_OFF\t\t\t0\t\t\t\t\t\t\t\t\t\t// 汎用フラグ - OFF\n#define D_VTX_MAX\t\t150000\t\t\t\t\t\t\t\t\t// 最大頂点数\n#define D_EDGE_MAX\t\tD_VTX_MAX\t\t\t\t\t\t\t\t// 最大辺数\n\n// 内部構造体 - 辺情報\ntypedef struct Edge {\n\tint miVNo;\t\t\t\t\t\t\t\t\t\t\t\t\t// 接続先頂点\n\tstruct Edge *mzpNext;\t\t\t\t\t\t\t\t\t\t// 次の辺\n\tstruct Edge *mzpRev;\t\t\t\t\t\t\t\t\t\t// 逆側の辺\n\tchar mcNG;\t\t\t\t\t\t\t\t\t\t\t\t\t// 使用不可フラグ\n} Edge;\n\n// 内部構造体 - 頂点情報\ntypedef struct Vtx {\n\tEdge *mzpEdge;\t\t\t\t\t\t\t\t\t\t\t\t// 辺\n\tdouble mdDVal;\t\t\t\t\t\t\t\t\t\t\t\t// 下方向の期待値\n\tdouble mdAVal;\t\t\t\t\t\t\t\t\t\t\t\t// 全方向の期待値\n} Vtx;\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic Vtx sz1Vtx[D_VTX_MAX];\t\t\t\t\t\t\t\t\t// 頂点\nstatic int siVCnt;\t\t\t\t\t\t\t\t\t\t\t\t// 頂点数\nstatic Edge sz1Edge[D_EDGE_MAX * 2];\t\t\t\t\t\t\t// 辺\nstatic int siECnt;\t\t\t\t\t\t\t\t\t\t\t\t// 辺数\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// 辺 - 追加\nint\nfAddEdge(\n\tint piVFNo\t\t\t\t\t// <I> 頂点 - 元\n\t, int piVTNo\t\t\t\t// <I> 頂点 - 先\n\t, Edge *pzpRev\t\t\t\t// <I> 逆側の辺\n)\n{\n\tsz1Edge[siECnt].miVNo = piVTNo;\n\tsz1Edge[siECnt].mzpNext = sz1Vtx[piVFNo].mzpEdge;\n\tsz1Edge[siECnt].mzpRev = pzpRev;\n\tsz1Edge[siECnt].mcNG = D_OFF;\n\tsz1Vtx[piVFNo].mzpEdge = &sz1Edge[siECnt];\n\tsiECnt++;\n\n\treturn 0;\n}\n\n// 使用不可フラグ - セット\nint\nfSetNG(\n\tint piVNo\t\t\t\t\t// <I> 頂点\n)\n{\n\t// 辺でループ\n\tEdge *lzpEdge = sz1Vtx[piVNo].mzpEdge;\n\twhile (lzpEdge != NULL) {\n\n\t\t// 使用不可フラグ - セット\n\t\tif (lzpEdge->mcNG == D_OFF) {\n\t\t\tlzpEdge->mzpRev->mcNG = D_ON;\n\t\t\tfSetNG(lzpEdge->miVNo);\n\t\t}\n\n\t\t// 次の辺へ\n\t\tlzpEdge = lzpEdge->mzpNext;\n\t}\n\n\treturn 0;\n}\n\n// 下方向の期待値 - セット\nint\nfSetDVal(\n\tint piVNo\t\t\t\t\t// <I> 頂点\n)\n{\n\t// 辺でループ\n\tEdge *lzpEdge = sz1Vtx[piVNo].mzpEdge;\n\twhile (lzpEdge != NULL) {\n\t\tif (lzpEdge->mcNG == D_OFF) {\n\n\t\t\t// 下位へ\n\t\t\tfSetDVal(lzpEdge->miVNo);\n\t\t}\n\n\t\t// 次の辺へ\n\t\tlzpEdge = lzpEdge->mzpNext;\n\t}\n\n\t// 下方向の期待値 - セット\n\tsz1Vtx[piVNo].mdDVal = 0.0;\n\tdouble ldECnt = 0.0;\n\tlzpEdge = sz1Vtx[piVNo].mzpEdge;\n\twhile (lzpEdge != NULL) {\n\t\tif (lzpEdge->mcNG == D_OFF) {\n\n\t\t\t// 下方向の期待値 - セット\n\t\t\tsz1Vtx[piVNo].mdDVal += sz1Vtx[lzpEdge->miVNo].mdDVal + 1.0;\n\n\t\t\t// 個数 - 加算\n\t\t\tldECnt++;\n\t\t}\n\n\t\t// 次の辺へ\n\t\tlzpEdge = lzpEdge->mzpNext;\n\t}\n\tif (ldECnt > 0.0) {\n\t\tsz1Vtx[piVNo].mdDVal /= ldECnt;\n\t}\n\n\treturn 0;\n}\n\n// 全方向の期待値 - セット\nint\nfSetAVal(\n\tint piVNo\t\t\t\t\t// <I> 頂点\n\t, double pdUVal\t\t\t\t// <I> 上方向の期待値\n)\n{\n\t// 全方向の期待値\n\tdouble ldAVal = 0.0;\n\tdouble ldECnt = 0.0;\n\tif (pdUVal >= 0.0) {\n\t\tldAVal += pdUVal + 1.0;\n\t\tldECnt++;\n\t}\n\n\t// 下方向の期待値 - 加算\n\tEdge *lzpEdge = sz1Vtx[piVNo].mzpEdge;\n\twhile (lzpEdge != NULL) {\n\t\tif (lzpEdge->mcNG == D_OFF) {\n\t\t\tldAVal += sz1Vtx[lzpEdge->miVNo].mdDVal + 1.0;\n\t\t\tldECnt++;\n\t\t}\n\n\t\t// 次の辺へ\n\t\tlzpEdge = lzpEdge->mzpNext;\n\t}\n\n\t// 全方向の期待値 - セット\n\tsz1Vtx[piVNo].mdAVal = ldAVal / ldECnt;\n\n\t// 下位へ\n\tlzpEdge = sz1Vtx[piVNo].mzpEdge;\n\twhile (lzpEdge != NULL) {\n\t\tif (lzpEdge->mcNG == D_OFF) {\n\n\t\t\t// 全方向の期待値\n\t\t\tdouble ldAVal2 = ldAVal - sz1Vtx[lzpEdge->miVNo].mdDVal - 1.0;\n\t\t\tif (ldECnt > 1.0) {\n\t\t\t\tldAVal2 /= ldECnt - 1.0;\n\t\t\t}\n\n\t\t\t// 下位へ\n\t\t\tfSetAVal(lzpEdge->miVNo, ldAVal2);\n\t\t}\n\n\t\t// 次の辺へ\n\t\tlzpEdge = lzpEdge->mzpNext;\n\t}\n\n\treturn 0;\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i;\n\tchar lc1Buf[1024];\n\n\t// データ - 初期化\n\tmemset(sz1Vtx, 0, sizeof(sz1Vtx));\n\tsiECnt = 0;\n\n\t// 頂点数 - 取得\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d\", &siVCnt);\n\n\t// 辺 - 取得\n\tfor (i = 0; i < siVCnt - 1; i++) {\n\t\tint liVNo1, liVNo2;\n\t\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\t\tsscanf(lc1Buf, \"%d%d\", &liVNo1, &liVNo2);\n\t\tliVNo1--;\n\t\tliVNo2--;\n\n\t\t// 辺 - 追加\n\t\tfAddEdge(liVNo1, liVNo2, &sz1Edge[siECnt + 1]);\n\t\tfAddEdge(liVNo2, liVNo1, &sz1Edge[siECnt - 1]);\n\t}\n\n\t// 使用不可フラグ - セット\n\tfSetNG(0);\n\n\t// 下方向の期待値 - セット\n\tfSetDVal(0);\n\n\t// 全方向の期待値 - セット\n\tfSetAVal(0, -1.0);\n\n\t// 出力\n\tfor (i = 0; i < siVCnt; i++) {\n\t\tsprintf(lc1Buf, \"%.7lf\\n\", sz1Vtx[i].mdAVal);\n\t\tfOutLine(lc1Buf);\n\t}\n\n\treturn 0;\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nlong t[150001][2],u[150000],v[150000];\nint main(int argc, char const *argv[]){\n\tlong n,i,s,e,j;\n\tscanf(\"%ld\",&n);\n\tfor(i=0;i<n-1;i++){\n\t\tscanf(\"%ld %ld\",&u[i],&v[i]);\n\t\tif(t[u[i]][0]==0) t[u[i]][0]=v[i];\n\t\telse t[u[i]][1]=v[i];\n\t\tif(t[v[i]][0]==0) t[v[i]][0]=u[i];\n\t\telse t[v[i]][1]=u[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(t[i][1]==0) break;\n\t}\n\ts=i;\n\tj=s;\n\ti=t[s][0];\n\twhile(t[i][1]!=0){\n\t\tif(t[i][0]==j){\n\t\t\tj=i;\n\t\t\ti=t[i][1];\n\t\t}else{\n\t\t\tj=i;\n\t\t\ti=t[i][0];\n\t\t}\n\t}\n\te=i;\n\tfor(i=1;i<=n;i++){\n\t\tif(s==i || e==i){\n\t\t\tprintf(\"%f\\n\",(double)(n-1));\n\t\t}else{\n\t\t\tprintf(\"%f\\n\",(n-1)/2.0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null parent[N_MAX];\null subs[N_MAX];\ndouble edgeD[N_MAX];\ndouble edgeU[N_MAX];\n\null root;\n\ndouble dfs (ull v) {\n\tdouble sum = 0;\n\tsubs[v] = 0;\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull e = xy[i].b;\n\t\tull u = (a[e] ^ b[e] ^ v);\n\t\tif (u == parent[v]) continue;\n\n\t\tparent[u] = v;\n\t\tedgeD[e] = dfs(u);\n\t\tsum += edgeD[e];\n\t\tsubs[v]++;\n\t}\n\tif (!subs[v]) return 0;\n\treturn sum / (double)subs[v] + 1.0;\n}\n\ndouble ddr (ull v, ull upe) {\n\tdouble sum = 0;\n\tull sub = subs[v];\n\tif (v != root) {\n\t\tsum += edgeU[upe];\n\t\tsub++;\n\t}\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull e = xy[i].b;\n\t\tull u = (a[e] ^ b[e] ^ v);\n\t\tif (e == upe) continue;\n\n\t\tsum += edgeD[e];\n\t}\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull e = xy[i].b;\n\t\tull u = (a[e] ^ b[e] ^ v);\n\t\tif (e == upe) continue;\n\t\tedgeU[e] = (sum - edgeD[e]) / (sub - 1) + 1;\n\t\tddr(u, e);\n\t}\n\treturn 0;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tif (n == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t} else if (n == 2) {\n\t\tputs(\"1\");\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\txy[i * 2] = (hwll){a[i], i};\n\t\txy[i * 2 + 1] = (hwll){b[i], i};\n\t\td[a[i]]++;\n\t\td[b[i]]++;\n\t}\n\tqsort(xy, (n - 1) * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < (n - 1) * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (d[i] > d[root]) root = i;\n\t}\n\n\tparent[root] = n;\n\tdfs(root);\n\tddr(root, (n - 1) * 2);\n\n\tfor (i = 0; i < n; i++) {\n\t\tdresult = 0;\n\t\tsum = 0;\n\t\tfor (sll j = gin[i]; j < gin[i + 1]; j++) {\n\t\t\tull e = xy[j].b;\n\t\t\tull u = (a[e] ^ b[e] ^ i);\n\t\t\tif (u == parent[i]) {\n\t\t\t\tdresult += edgeU[e];\n\t\t\t} else {\n\t\t\t\tdresult += edgeD[e];\n\t\t\t}\n\t\t\tsum++;\n\t\t}\n\t\tprintf(\"%.15lf\\n\", dresult / sum + 1.0);\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n - 1; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic final int mod = (int) 1e9 + 7;\n\tstatic final int DX[] = { -1, 0, 1, 0 }, DY[] = { 0, -1, 0, 1 };\n\tstatic final int[] DX8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, DY8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\tstatic final long LINF = Long.MAX_VALUE / 3;\n\tstatic final String nextLine = \"\\n\";\n\n\tstatic int n;\n\tstatic int MAX_N = 150100;\n\tstatic List<Integer> graph[];\n\tstatic double dp1[] = new double[MAX_N], dp2[] = new double[MAX_N];\n\tstatic double ans[] = new double[MAX_N];\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner(System.in);\n\t\tn = fs.nextInt();\n\t\tgraph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)graph[i] = new ArrayList<>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint u = fs.nextInt()-1, v = fs.nextInt()-1;\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t\tdfs1(0,-1);\n\t\tdfs2(0,-1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint child = graph[i].size()-1;\n\t\t\tif(i==0)child ++;\n\t\t\tans[i] = dp2[i];\n\t\t\tans[i] += child * dp1[i];\n\t\t\tans[i] /= graph[i].size();\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\t}\n\n\tstatic void dfs1(int v, int p) {\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdfs1(to, v);\n\t\t\tdp1[v] += dp1[to]+1;\n\t\t}\n\t\tif(graph[v].size()>1) {\n\t\t\tdp1[v] /= (graph[v].size()-1+(p==-1?1:0));\n\t\t}\n\t}\n\t\n\tstatic void dfs2(int v, int p) {\n\t\tif(p == -1)dp2[v] = 0;\n\t\tdouble tot = dp2[v];\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\ttot += (dp1[to] + 1);\n\t\t}\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdp2[to] = tot - (dp1[to] + 1);\n\t\t\tif(graph[v].size()>1)dp2[to] /= (graph[v].size()-1);\n\t\t\tdp2[to] += 1;\n\t\t\tdfs2(to, v);\n\t\t}\n\t}\n\t\n\t//MOD culculations\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n}\n\n//高速なScanner\nclass FastScanner {\n\tprivate BufferedReader reader = null;\n\tprivate StringTokenizer tokenizer = null;\n\n\tpublic FastScanner(InputStream in) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nextLine() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken(\"\\n\");\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tArrayDeque<Integer> deque = new ArrayDeque<>(n);\n\t\tdeque.add(s.nextInt()-1);\n\t\tdeque.add(s.nextInt()-1);\n\t\tfor(int i=1; i<n-1; i++){\n\t\t\tint v=s.nextInt()-1;\n\t\t\tif(deque.peekFirst().equals(v)) {\n\t\t\t\tdeque.addFirst(s.nextInt()-1);\n\t\t\t}else if(deque.peekLast().equals(v)) {\n\t\t\t\tdeque.addLast(s.nextInt()-1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"nullpo\");\n\t\t\t\treturn;//Judge Reject;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] graph = new int[deque.size()];\n\t\tfor(int i=0;!deque.isEmpty();i++) {\n\t\t\tgraph[i]=deque.poll();\n\t\t}\n\t\t//System.out.println(Arrays.toString(graph));\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.println(graph[0]==i||graph[n-1]==i?n-1.0:(n-1)/2.0);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tArrayList<HashSet<Integer>> adj = new ArrayList<HashSet<Integer>>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tadj.add(new HashSet<Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\t\tfinal int A = sc.nextInt() - 1;\n\t\t\t\tfinal int B = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tadj.get(A).add(B);\n\t\t\t\tadj.get(B).add(A);\n\t\t\t}\n\t\t\t\n\t\t\tint leafs = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){ leafs++; }\n\t\t\t}\n\t\t\t\n\t\t\tif(leafs != 2){ throw new RuntimeException(); }\n\t\t\t\n\t\t\tint[] heads = new int[leafs];\n\t\t\tfor(int i = 0, count = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){\n\t\t\t\t\theads[count++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] distance = new int[N][2];\n\t\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 0; i < heads.length; i++){\n\t\t\t\tfinal int start = heads[i];\n\t\t\t\tqueue.clear();\n\t\t\t\t\n\t\t\t\tqueue.add(start);\n\t\t\t\tqueue.add(-1);\n\t\t\t\tqueue.add(0);\n\t\t\t\t\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tfinal int pos = queue.poll();\n\t\t\t\t\tfinal int prev = queue.poll();\n\t\t\t\t\tfinal int depth = queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tdistance[pos][i] = depth;\n\t\t\t\t\tfor(final int next : adj.get(pos)){\n\t\t\t\t\t\tif(next == prev){ continue; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\tqueue.add(pos);\n\t\t\t\t\t\tqueue.add(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tdouble answer = 0;\n\t\t\t\t\n\t\t\t\tif(distance[i][0] == 0){\n\t\t\t\t\tanswer += distance[i][1];\n\t\t\t\t}else if(distance[i][1] == 0){\n\t\t\t\t\tanswer += distance[i][0];\n\t\t\t\t}else{\n\t\t\t\t\tanswer += (distance[i][0] / 2.0) + (distance[i][1] / 2.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.printf(\"%.12f\\n\", answer);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tArrayList<HashSet<Integer>> adj = new ArrayList<HashSet<Integer>>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tadj.add(new HashSet<Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\t\tfinal int A = sc.nextInt() - 1;\n\t\t\t\tfinal int B = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tadj.get(A).add(B);\n\t\t\t\tadj.get(B).add(A);\n\t\t\t}\n\t\t\t\n\t\t\tint leafs = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){ leafs++; }\n\t\t\t}\n\t\t\t\n\t\t\tif(N == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(leafs != 2){ throw new RuntimeException(); }\n\t\t\t\n\t\t\tint[] heads = new int[leafs];\n\t\t\tfor(int i = 0, count = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){\n\t\t\t\t\theads[count++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] distance = new int[N][2];\n\t\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 0; i < heads.length; i++){\n\t\t\t\tfinal int start = heads[i];\n\t\t\t\tqueue.clear();\n\t\t\t\t\n\t\t\t\tqueue.add(start);\n\t\t\t\tqueue.add(-1);\n\t\t\t\tqueue.add(0);\n\t\t\t\t\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tfinal int pos = queue.poll();\n\t\t\t\t\tfinal int prev = queue.poll();\n\t\t\t\t\tfinal int depth = queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tdistance[pos][i] = depth;\n\t\t\t\t\tfor(final int next : adj.get(pos)){\n\t\t\t\t\t\tif(next == prev){ continue; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\tqueue.add(pos);\n\t\t\t\t\t\tqueue.add(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tdouble answer = 0;\n\t\t\t\t\n\t\t\t\tif(distance[i][0] == 0){\n\t\t\t\t\tanswer += distance[i][1];\n\t\t\t\t}else if(distance[i][1] == 0){\n\t\t\t\t\tanswer += distance[i][0];\n\t\t\t\t}else{\n\t\t\t\t\tanswer += (distance[i][0] / 2.0) + (distance[i][1] / 2.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.printf(\"%.8f\\n\", answer);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1));\n\t\t\t}\n\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n\t\tsb.append(\"\\n\");\n\t\tres.append(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge{\n\t\tint src;\n\t\tint dst;\n\t\tint idx;\n\t\tpublic Edge(int s , int d , int i) {\n\t\t\tsrc = s;\n\t\t\tdst = d;\n\t\t\tidx = i;\n\t\t}\n\t}\n\tstatic class Vertex{\n\t\tList<Edge> adj;\n\t\tpublic Vertex() {\n\t\t\tadj = new ArrayList<Edge>();\n\t\t}\n\t\tvoid add(int s , int d , int i){\n\t\t\tadj.add(new Edge(s, d, i));\n\t\t}\n\t}\n\tstatic double rec(int parent , int cur , double memo[] , List<Integer> ordering, Vertex[] vs){\n\t\tordering.add(cur);\n\t\tint P = 0;\n\t\tdouble S = 0.0;\n\t\tfor(Edge e : vs[cur].adj){\n\t\t\tif(e.dst == parent){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(memo[e.idx] < 0.0){\n\t\t\t\tdouble p = rec(cur , e.dst , memo , ordering , vs) + 1.0;\n\t\t\t\tmemo[e.idx] = p;\n\t\t\t}\n\t\t\tS += memo[e.idx];\n\t\t\t++P;\n\t\t}\n\t\tif(P == 0){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn S / P;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tVertex[] vs = new Vertex[N];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tvs[i] = new Vertex();\n\t\t}\n\t\tfor(int i = 0 ; i < N - 1 ; ++i){\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tvs[u].add(u , v , i * 2);\n\t\t\tvs[v].add(v , u , i * 2 + 1);\n\t\t}\n\t\tList<Integer> ordering = new ArrayList<Integer>();\n\t\tdouble memo[] = new double[(N - 1) * 2];\n\t\tArrays.fill(memo, -1);\n\t\tdouble ans[] = new double[N];\n\t\trec(0, 0, memo, ordering, vs);\n\t\tfor(int cur : ordering){\n\t\t\tdouble S = 0.0;\n\t\t\tfor(Edge e : vs[cur].adj){\n\t\t\t\tS += memo[e.idx];\n\t\t\t}\n\t\t\tint size = vs[cur].adj.size();\n\t\t\tans[cur] = S / size;\n\t\t\tfor(Edge e : vs[cur].adj){\n\t\t\t\tint redge = e.idx % 2 == 0 ? e.idx + 1 : e.idx - 1;\n\t\t\t\tif(size == 1){\n\t\t\t\t\tmemo[redge] = 1.0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble v = S - memo[e.idx];\t\t\t\t\t\n\t\t\t\t\tmemo[redge] = 1.0 + v / (size - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(double v : ans){\n\t\t\tSystem.out.println(v);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((int)x);\n\t\t}\n\t\tio.out.println(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tArrayDeque<Integer> deque = new ArrayDeque<>(n);\n\t\t\n\t\tif(n==1) {\n\t\t\tSystem.out.println(0.0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdeque.add(s.nextInt()-1);\n\t\tdeque.add(s.nextInt()-1);\n\t\tfor(int i=1; i<n-1; i++){\n\t\t\tint v=s.nextInt()-1;\n\t\t\tif(deque.peekFirst().equals(v)) {\n\t\t\t\tdeque.addFirst(s.nextInt()-1);\n\t\t\t}else if(deque.peekLast().equals(v)) {\n\t\t\t\tdeque.addLast(s.nextInt()-1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"nullpo\");\n\t\t\t\treturn;//Judge Reject;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] graph = new int[deque.size()];\n\t\tfor(int i=0;!deque.isEmpty();i++) {\n\t\t\tgraph[i]=deque.poll();\n\t\t}\n\t\t//System.out.println(Arrays.toString(graph));\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.printf(\"%.6f\\n\",graph[0]==i||graph[n-1]==i?n-1.0:(n-1)/2.0);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tlong[] ary = new long[2 * (n - 1)];\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t\tary[2*i+0] = (long)s<<32|t;\n\t\t\t\tary[2*i+1] = (long)t<<32|s;\n\t\t\t}\n\t\t\tradixSortSimple(ary);\n\t\t\t\n\t\t\tes = new int[n][][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i] = new int[g[i].size()][];\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tint[] index = new int[n];\n\t\t\tfor (int i = 0, j; i < ary.length; i = j) {\n\t\t\t\tfinal int s0 = (int)(ary[i]>>>32);\n\t\t\t\tfor (j = i; j < ary.length; j++) {\n\t\t\t\t\tfinal int s = (int)(ary[j]>>>32);\n\t\t\t\t\tfinal int t = (int)(ary[j]&0xFFFFFFFF);\n\t\t\t\t\tif (s != s0) break;\n\t\t\t\t\tes[t][index[t]++] = new int[]{ s, j-i+1 };\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tdump(es);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1, 0));\n\t\t\t}\n//\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tint[][][] es;\n\tdouble[][] memo;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p, int idx) {\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int[] t : es[v]) if (t[0] != p) {\n\t\t\tans += rec(t[0], v, t[1]) + 1;\n\t\t}\n\t\tif (childs > 0) ans /= childs;\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n//\t\tsb.append(\"\\n\");\n//\t\tres.append(sb);\n\t\tio.out.println(sb);\n\t}\n\tstatic void radixSortSimple(long[] xs) {\n\t\tint[] cnt = new int[(1<<16)+1];\n\t\tlong[] ys = new long[xs.length];\n\t\t\n\t\tfor(int j = 0; j < 64; j += 16) {\n\t\t\tArrays.fill(cnt, 0);\n\t\t\tfor(long x : xs) { cnt[(int)(x>>j&0xFFFF)+1]++; }\n\t\t\tfor(int i = 1; i < cnt.length; i++) { cnt[i] += cnt[i-1]; }\n\t\t\tfor(long x : xs) { ys[cnt[(int)(x>>j&0xFFFF)]++] = x; }\n\t\t\t{ final long[] t = xs; xs = ys; ys = t; }\n\t\t}\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tNode[] ns=new Node[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tns[i]=new Node(i);\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tint a=s.nextInt()-1, b=s.nextInt()-1;\n\t\t\tns[a].add(ns[b]);\n\t\t\tns[b].add(ns[a]);\n\t\t}\n\t\t\n\t\tArrayDeque<Node> deque=new ArrayDeque<>(3);\n\t\tArrays.stream(ns).filter(o->o.neighbor.size()==1).forEach(v->{\n//\t\t\tSystem.out.println(v.id);\n\t\t\tv.dist.put(v.id,-114514);\n\t\t\tdeque.add(v);\n\t\t\t\n\t\t\tint dist=0;\n\t\t\twhile(!deque.isEmpty()){\n\t\t\t\tdist++;\n\t\t\t\tfor(int j=deque.size(); j>0; j--){\n\t\t\t\t\tNode p=deque.poll();\n\t\t\t\t\tfor(Node t:p.neighbor){\n\t\t\t\t\t\tif(!t.dist.containsKey(v.id)){\n\t\t\t\t\t\t\tt.dist.put(v.id,dist);\n\t\t\t\t\t\t\tdeque.add(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(Node v:ns){\n//\t\t\tSystem.out.println(v.dist.toString());\n\t\t\tint sum=0,count=0;\n\t\t\tfor(int i:v.dist.values()) {\n\t\t\t\tif(i!=-114514) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tsum+=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum*1.0/count);\n\t\t}\n\t}\n}\n\nclass Node{\n\t\n\tArrayList<Node>\t\t\t\tneighbor=new ArrayList<>(3);\n\tHashMap<Integer, Integer>\tdist\t=new HashMap<>(2);\n\t\n\tint\t\t\t\t\t\t\tid;\n\t\n\tNode(int id){\n\t\tthis.id=id;\n\t}\n\t\n\tvoid add(Node n){\n\t\tneighbor.add(n);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\t\t\t\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tes2 = new int[n][][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes2[i] = new int[g[i].size()][2];\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes2[i][j][0] = g[i].get(j);\n\t\t\t\t\tes2[i][j][1] = Arrays.binarySearch(es[g[i].get(j)], i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1, 0));\n\t\t\t}\n//\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tint[][][] es2;\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p, int idx) {\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int[] t : es2[v]) if (t[0] != -1 && t[0] != p) {\n\t\t\tans += (rec(t[0], v, t[1]) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n//\t\tsb.append(\"\\n\");\n//\t\tres.append(sb);\n\t\tio.out.println(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tmemo = new Map[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tmemo[i] = new HashMap<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tMap<Integer, Double>[] memo;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tDouble x = memo[v].get(p);\n\t\tif (x != null) { return x; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v].put(p, ans);\n\t\treturn ans;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tArrayDeque<Integer> deque = new ArrayDeque<>(n);\n\t\tdeque.add(s.nextInt()-1);\n\t\tdeque.add(s.nextInt()-1);\n\t\tfor(int i=1; i<n-1; i++){\n\t\t\tint v=s.nextInt()-1;\n\t\t\tif(deque.peekFirst().equals(v)) {\n\t\t\t\tdeque.addFirst(s.nextInt()-1);\n\t\t\t}else if(deque.peekLast().equals(v)) {\n\t\t\t\tdeque.addLast(s.nextInt()-1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"nullpo\");\n\t\t\t\treturn;//Judge Reject;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] graph = new int[deque.size()];\n\t\tfor(int i=0;!deque.isEmpty();i++) {\n\t\t\tgraph[i]=deque.poll();\n\t\t}\n\t\t//System.out.println(Arrays.toString(graph));\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.println(graph[0]==i||graph[n-1]==i?n-1.0:(n-1)/2.0);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n\t\tio.out.println(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic final int mod = (int) 1e9 + 7;\n\tstatic final int DX[] = { -1, 0, 1, 0 }, DY[] = { 0, -1, 0, 1 };\n\tstatic final int[] DX8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, DY8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\tstatic final long LINF = Long.MAX_VALUE / 3;\n\tstatic final String nextLine = \"\\n\";\n\n\tstatic int n;\n\tstatic int MAX_N = 150100;\n\tstatic List<Integer> graph[];\n\tstatic double dp1[] = new double[MAX_N], dp2[] = new double[MAX_N];\n\tstatic double ans[] = new double[MAX_N];\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner(System.in);\n\t\tn = fs.nextInt();\n\t\tgraph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)graph[i] = new ArrayList<>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint u = fs.nextInt()-1, v = fs.nextInt()-1;\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t\tdfs1(0,-1);\n\t\tdfs2(0,-1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint child = graph[i].size()-1;\n\t\t\tif(i==0)child ++;\n\t\t\tans[i] = dp2[i];\n\t\t\tans[i] += child * dp1[i];\n\t\t\tans[i] /= graph[i].size();\n\t\t\tsb.append(ans[i] + nextLine);\n\t\t\t//System.out.println(ans[i]);\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tstatic void dfs1(int v, int p) {\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdfs1(to, v);\n\t\t\tdp1[v] += dp1[to]+1;\n\t\t}\n\t\tif(graph[v].size()>1) {\n\t\t\tdp1[v] /= (graph[v].size()-1+(p==-1?1:0));\n\t\t}\n\t}\n\t\n\tstatic void dfs2(int v, int p) {\n\t\tif(p == -1)dp2[v] = 0;\n\t\tdouble tot = dp2[v];\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\ttot += (dp1[to] + 1);\n\t\t}\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdp2[to] = tot - (dp1[to] + 1);\n\t\t\tif(graph[v].size()>1)dp2[to] /= (graph[v].size()-1);\n\t\t\tdp2[to] += 1;\n\t\t\tdfs2(to, v);\n\t\t}\n\t}\n\t\n\t//MOD culculations\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n}\n\n//高速なScanner\nclass FastScanner {\n\tprivate BufferedReader reader = null;\n\tprivate StringTokenizer tokenizer = null;\n\n\tpublic FastScanner(InputStream in) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nextLine() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken(\"\\n\");\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] u = new int[n];\n\t\tint[] v = new int[n];\n\t\tList<List<Integer>> edges = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tedges.add(new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tu[i] = sc.nextInt() - 1;\n\t\t\tv[i] = sc.nextInt() - 1;\n\n\t\t\tedges.get(u[i]).add(v[i]);\n\t\t\tedges.get(v[i]).add(u[i]);\n\t\t}\n\n\t\tif (n > 1000) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\n\t\tfor (int vv = 0; vv < n; vv++) {\n\t\t\tdouble[] p = new double[n];\n\t\t\tint[] d = new int[n];\n\t\t\tArrays.fill(d, -1);\n\n\t\t\tdouble ret = 0;\n\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tq.add(vv);\n\t\t\tp[vv] = 1;\n\t\t\td[vv] = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint e = q.remove();\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\tif (d[next] == -1) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cnt == 0) {\n\t\t\t\t\tret += d[e] * p[e];\n\t\t\t\t} else {\n\t\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\t\tif (d[next] == -1) {\n\t\t\t\t\t\t\td[next] = d[e] + 1;\n\t\t\t\t\t\t\tp[next] = p[e] * (double)1 / cnt;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpr.printf(\"%.7f\\n\", ret);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tNode[] ns=new Node[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t\tns[i]=new Node(i);\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tint a=s.nextInt()-1, b=s.nextInt()-1;\n\t\t\tns[a].add(ns[b]);\n\t\t\tns[b].add(ns[a]);\n\t\t}\n\t\t\n\t\tArrayDeque<Node> deque=new ArrayDeque<>(3);\n\t\tArrays.stream(ns).filter(o->o.neighbor.size()==1).forEach(v->{\n//\t\t\tSystem.out.println(v.id);\n\t\t\tv.dist.put(v.id,-114514);\n\t\t\tdeque.add(v);\n\t\t\t\n\t\t\tint dist=0;\n\t\t\twhile(!deque.isEmpty()){\n\t\t\t\tdist++;\n\t\t\t\tfor(int j=deque.size(); j>0; j--){\n\t\t\t\t\tNode p=deque.poll();\n\t\t\t\t\tfor(Node t:p.neighbor){\n\t\t\t\t\t\tif(!t.dist.containsKey(v.id)){\n\t\t\t\t\t\t\tt.dist.put(v.id,dist);\n\t\t\t\t\t\t\tdeque.add(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(Node v:ns){\n//\t\t\tSystem.out.println(v.dist.toString());\n\t\t\tSystem.out.println(v.dist.values().stream().mapToInt(i->i)\n\t\t\t\t\t.filter(i->i!=-114514)\n\t\t\t\t\t.average().getAsDouble());\n\t\t}\n\t}\n}\n\nclass Node{\n\t\n\tArrayList<Node>\t\t\t\tneighbor=new ArrayList<>(3);\n\tHashMap<Integer, Integer>\tdist\t=new HashMap<>(2);\n\t\n\tint\t\t\t\t\t\t\tid;\n\t\n\tNode(int id){\n\t\tthis.id=id;\n\t}\n\t\n\tvoid add(Node n){\n\t\tneighbor.add(n);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tstatic final int mod = (int) 1e9 + 7;\n\tstatic final int DX[] = { -1, 0, 1, 0 }, DY[] = { 0, -1, 0, 1 };\n\tstatic final int[] DX8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, DY8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\tstatic final long LINF = Long.MAX_VALUE / 3;\n\tstatic final String nextLine = \"\\n\";\n\n\tstatic int n;\n\tstatic int MAX_N = 150100;\n\tstatic List<Integer> graph[];\n\tstatic double dp1[] = new double[MAX_N], dp2[] = new double[MAX_N];\n\tstatic double ans[] = new double[MAX_N];\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs = new FastScanner(System.in);\n\t\tn = fs.nextInt();\n\t\tgraph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)graph[i] = new ArrayList<>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint u = fs.nextInt()-1, v = fs.nextInt()-1;\n\t\t\tgraph[u].add(v);\n\t\t\tgraph[v].add(u);\n\t\t}\n\t\tdfs1(0,-1);\n\t\tdfs2(0,-1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint child = graph[i].size()-1;\n\t\t\tif(i==0)child ++;\n\t\t\tans[i] = dp2[i];\n\t\t\tans[i] += child * dp1[i];\n\t\t\tans[i] /= graph[i].size();\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\t}\n\n\tstatic void dfs1(int v, int p) {\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdfs1(to, v);\n\t\t\tdp1[v] += dp1[to]+1;\n\t\t}\n\t\tif(graph[v].size()>1) {\n\t\t\tdp1[v] /= (graph[v].size()-1+(p==-1?1:0));\n\t\t}\n\t}\n\t\n\tstatic void dfs2(int v, int p) {\n\t\tif(p == -1)dp2[v] = 0;\n\t\tdouble tot = dp2[v];\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\ttot += (dp1[to] + 1);\n\t\t}\n\t\tfor(int to:graph[v]) {\n\t\t\tif(to == p)continue;\n\t\t\tdp2[to] = tot - (dp1[to] + 1);\n\t\t\tif(graph[v].size()>1)dp2[to] /= (graph[v].size()-1);\n\t\t\tdp2[to] += 1;\n\t\t\tdfs2(to, v);\n\t\t}\n\t}\n\t\n\t//MOD culculations\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n}\n\n//高速なScanner\nclass FastScanner {\n\tprivate BufferedReader reader = null;\n\tprivate StringTokenizer tokenizer = null;\n\n\tpublic FastScanner(InputStream in) {\n\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String nextLine() {\n\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken(\"\\n\");\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge{\n\t\tint dst;\n\t\tint idx;\n\t\tpublic Edge(int d , int i) {\n\t\t\tdst = d;\n\t\t\tidx = i;\n\t\t}\n\t}\n\tstatic class Vertex{\n\t\tList<Edge> adj;\n\t\tpublic Vertex() {\n\t\t\tadj = new ArrayList<Edge>();\n\t\t}\n\t\tvoid add(int s , int d , int i){\n\t\t\tadj.add(new Edge(d, i));\n\t\t}\n\t}\n\tstatic double rec(int parent , int cur , double memo[] , List<Integer> ordering, int adj[][] , int idx[][]){\n\t\tordering.add(cur);\n\t\tint P = 0;\n\t\tdouble S = 0.0;\n\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\tint dst = adj[cur][i];\n\t\t\tif(dst == parent){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint id = idx[cur][i];\n\t\t\tif(memo[id] < 0.0){\n\t\t\t\tdouble p = rec(cur , dst , memo , ordering , adj , idx) + 1.0;\n\t\t\t\tmemo[id] = p;\n\t\t\t}\n\t\t\tS += memo[id];\n\t\t\tP = P + 1;\n\t\t}\n\t\tif(P == 0){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn S / P;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tVertex[] vs = new Vertex[N];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tvs[i] = new Vertex();\n\t\t}\n\t\tfor(int i = 0 ; i < N - 1 ; ++i){\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tvs[u].add(u , v , i * 2);\n\t\t\tvs[v].add(v , u , i * 2 + 1);\n\t\t}\n\t\tint adj[][] = new int[N][];\n\t\tint idx[][] = new int[N][];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tadj[i] = new int[vs[i].adj.size()];\n\t\t\tidx[i] = new int[vs[i].adj.size()];\t\t\t\n\t\t\tfor(int j = 0 ; j < vs[i].adj.size() ; ++j){\n\t\t\t\tadj[i][j] = vs[i].adj.get(j).dst;\n\t\t\t\tidx[i][j] = vs[i].adj.get(j).idx;\n\t\t\t}\n\t\t}\n\t\tList<Integer> ordering = new ArrayList<Integer>();\n\t\tdouble memo[] = new double[(N - 1) * 2];\n\t\tArrays.fill(memo, -1);\n\t\tdouble ans[] = new double[N];\n\t\trec(0, 0, memo, ordering, adj , idx);\n\t\tfor(int cur : ordering){\n\t\t\tdouble S = 0.0;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tS += memo[idx[cur][i]];\n\t\t\t}\n\t\t\tint size = vs[cur].adj.size();\n\t\t\tans[cur] = S / size;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tint id = idx[cur][i];\n\t\t\t\tint redge = id % 2 == 0 ? id + 1 : id - 1;\n\t\t\t\tif(size == 1){\n\t\t\t\t\tmemo[redge] = 1.0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble v = S - memo[id];\n\t\t\t\t\tmemo[redge] = 1.0 + v / (size - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(double v : ans){\n\t\t\tSystem.out.println(v);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tmemo = new Map[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\tmemo[i] = new TreeMap<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tMap<Integer, Double>[] memo;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tif (memo[v].containsKey(p)) { return memo[v].get(p); }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v].put(p, ans);\n\t\treturn ans;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tstatic Scanner s=new Scanner(System.in);\n\t\n\tpublic static void main(String[] __){\n\t\tint n=s.nextInt();\n\t\tArrayDeque<Integer> deque = new ArrayDeque<>(n);\n\t\tdeque.add(s.nextInt()-1);\n\t\tdeque.add(s.nextInt()-1);\n\t\tfor(int i=1; i<n-1; i++){\n\t\t\tint v=s.nextInt()-1;\n\t\t\tif(deque.peekFirst().equals(v)) {\n\t\t\t\tdeque.addFirst(s.nextInt()-1);\n\t\t\t}else if(deque.peekLast().equals(v)) {\n\t\t\t\tdeque.addLast(s.nextInt()-1);\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"nullpo\");\n\t\t\t\treturn;//Judge Reject;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] graph = new int[deque.size()];\n\t\tfor(int i=0;!deque.isEmpty();i++) {\n\t\t\tgraph[i]=deque.poll();\n\t\t}\n\t\t//System.out.println(Arrays.toString(graph));\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tSystem.out.printf(\"%.6f\\n\",graph[0]==i||graph[n-1]==i?n-1.0:(n-1)/2.0);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tio.out.print((int)x);\n\t\tio.out.print('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tio.out.print((int)x);\n\t\t}\n\t\tio.out.println();\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic class Edge{\n\t\tint dst;\n\t\tint idx;\n\t\tpublic Edge(int d , int i) {\n\t\t\tdst = d;\n\t\t\tidx = i;\n\t\t}\n\t}\n\tstatic class Vertex{\n\t\tList<Edge> adj;\n\t\tpublic Vertex() {\n\t\t\tadj = new ArrayList<Edge>();\n\t\t}\n\t\tvoid add(int s , int d , int i){\n\t\t\tadj.add(new Edge(d, i));\n\t\t}\n\t}\n\tstatic double rec(int parent , int cur , double memo[] , List<Integer> ordering, int adj[][] , int idx[][]){\n\t\tordering.add(cur);\n\t\tint P = 0;\n\t\tdouble S = 0.0;\n\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\tint dst = adj[cur][i];\n\t\t\tif(dst == parent){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint id = idx[cur][i];\n\t\t\tif(memo[id] < 0.0){\n\t\t\t\tdouble p = rec(cur , dst , memo , ordering , adj , idx) + 1.0;\n\t\t\t\tmemo[id] = p;\n\t\t\t}\n\t\t\tS += memo[id];\n\t\t\tP = P + 1;\n\t\t}\n\t\tif(P == 0){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn S / P;\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tVertex[] vs = new Vertex[N];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tvs[i] = new Vertex();\n\t\t}\n\t\tfor(int i = 0 ; i < N - 1 ; ++i){\n\t\t\tString line = br.readLine();\n\t\t\tint i0 = line.indexOf(' ');\t\t\t\n\t\t\tint u = Integer.parseInt(line.substring(0, i0)) - 1;\n\t\t\tint v = Integer.parseInt(line.substring(i0 + 1)) - 1;\n\t\t\tvs[u].add(u , v , i * 2);\n\t\t\tvs[v].add(v , u , i * 2 + 1);\n\t\t}\n\t\tint adj[][] = new int[N][];\n\t\tint idx[][] = new int[N][];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tadj[i] = new int[vs[i].adj.size()];\n\t\t\tidx[i] = new int[vs[i].adj.size()];\t\t\t\n\t\t\tfor(int j = 0 ; j < vs[i].adj.size() ; ++j){\n\t\t\t\tadj[i][j] = vs[i].adj.get(j).dst;\n\t\t\t\tidx[i][j] = vs[i].adj.get(j).idx;\n\t\t\t}\n\t\t}\n\t\tList<Integer> ordering = new ArrayList<Integer>();\n\t\tdouble memo[] = new double[(N - 1) * 2];\n\t\tArrays.fill(memo, -1);\n\t\tdouble ans[] = new double[N];\n\t\trec(0, 0, memo, ordering, adj , idx);\n\t\tfor(int cur : ordering){\n\t\t\tdouble S = 0.0;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tS += memo[idx[cur][i]];\n\t\t\t}\n\t\t\tint size = vs[cur].adj.size();\n\t\t\tans[cur] = S / size;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tint id = idx[cur][i];\n\t\t\t\tint redge = id % 2 == 0 ? id + 1 : id - 1;\n\t\t\t\tif(size == 1){\n\t\t\t\t\tmemo[redge] = 1.0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble v = S - memo[id];\n\t\t\t\t\tmemo[redge] = 1.0 + v / (size - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(double v : ans){\n\t\t\tSystem.out.println(v);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tArrayList<HashSet<Integer>> adj = new ArrayList<HashSet<Integer>>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tadj.add(new HashSet<Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N - 1; i++){\n\t\t\t\tfinal int A = sc.nextInt() - 1;\n\t\t\t\tfinal int B = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tadj.get(A).add(B);\n\t\t\t\tadj.get(B).add(A);\n\t\t\t}\n\t\t\t\n\t\t\tint leafs = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){ leafs++; }\n\t\t\t}\n\t\t\t\n\t\t\tif(N == 1){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(leafs != 2){ throw new RuntimeException(); }\n\t\t\t\n\t\t\tint[] heads = new int[leafs];\n\t\t\tfor(int i = 0, count = 0; i < N; i++){\n\t\t\t\tif(adj.get(i).size() == 1){\n\t\t\t\t\theads[count++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] distance = new int[N][2];\n\t\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\t\tfor(int i = 0; i < heads.length; i++){\n\t\t\t\tfinal int start = heads[i];\n\t\t\t\tqueue.clear();\n\t\t\t\t\n\t\t\t\tqueue.add(start);\n\t\t\t\tqueue.add(-1);\n\t\t\t\tqueue.add(0);\n\t\t\t\t\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tfinal int pos = queue.poll();\n\t\t\t\t\tfinal int prev = queue.poll();\n\t\t\t\t\tfinal int depth = queue.poll();\n\t\t\t\t\t\n\t\t\t\t\tdistance[pos][i] = depth;\n\t\t\t\t\tfor(final int next : adj.get(pos)){\n\t\t\t\t\t\tif(next == prev){ continue; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\tqueue.add(pos);\n\t\t\t\t\t\tqueue.add(depth + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tdouble answer = 0;\n\t\t\t\t\n\t\t\t\tif(distance[i][0] == 0){\n\t\t\t\t\tanswer += distance[i][1];\n\t\t\t\t}else if(distance[i][1] == 0){\n\t\t\t\t\tanswer += distance[i][0];\n\t\t\t\t}else{\n\t\t\t\t\tanswer += (distance[i][0] / 2.0) + (distance[i][1] / 2.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.printf(\"%.12f\\n\", answer);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n \n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n \n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n \n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tfinal int[] ret = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tfinal long[] ret = new long[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tret[i] = this.nextLong();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n \n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : g[v]) if (t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\t\t\t\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tes2 = new int[n][][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes2[i] = new int[g[i].size()][2];\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes2[i][j][0] = g[i].get(j);\n\t\t\t\t\tes2[i][j][1] = Arrays.binarySearch(es[g[i].get(j)], i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1, 0));\n\t\t\t}\n\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tint[][][] es2;\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p, int idx) {\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int[] t : es2[v]) if (t[0] != -1 && t[0] != p) {\n\t\t\tans += (rec(t[0], v, t[1]) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n\t\tsb.append(\"\\n\");\n\t\tres.append(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p) {\n\t\tint idx = Arrays.binarySearch(es[v], p);\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int t : es[v]) if (t != -1 && t != p) {\n\t\t\tans += (rec(t, v) + 1) / childs;\n\t\t}\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tio.out.print((int)x);\n\t\tio.out.print('.');\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tio.out.print((int)x);\n\t\t}\n\t\tio.out.println();\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tlong[] ary = new long[2 * (n - 1)];\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t\tary[2*i+0] = (long)s<<32|t;\n\t\t\t\tary[2*i+1] = (long)t<<32|s;\n\t\t\t}\n\t\t\tradixSortSimple(ary);\n\t\t\t\n\t\t\tes = new int[n][][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i] = new int[g[i].size()][];\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tint[] index = new int[n];\n\t\t\tfor (int i = 0, j; i < ary.length; i = j) {\n\t\t\t\tfinal int s0 = (int)(ary[i]>>>32);\n\t\t\t\tfor (j = i; j < ary.length; j++) {\n\t\t\t\t\tfinal int s = (int)(ary[j]>>>32);\n\t\t\t\t\tfinal int t = (int)(ary[j]&0xFFFFFFFF);\n\t\t\t\t\tif (s != s0) break;\n\t\t\t\t\tes[t][index[t]++] = new int[]{ s, j-i+1 };\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tdump(es);\n\t\t\tif (true) return;\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1, 0));\n\t\t\t}\n//\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tint[][][] es;\n\tdouble[][] memo;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p, int idx) {\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int[] t : es[v]) if (t[0] != p) {\n\t\t\tans += rec(t[0], v, t[1]) + 1;\n\t\t}\n\t\tif (childs > 0) ans /= childs;\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n//\t\tsb.append(\"\\n\");\n//\t\tres.append(sb);\n\t\tio.out.println(sb);\n\t}\n\tstatic void radixSortSimple(long[] xs) {\n\t\tint[] cnt = new int[(1<<16)+1];\n\t\tlong[] ys = new long[xs.length];\n\t\t\n\t\tfor(int j = 0; j < 64; j += 16) {\n\t\t\tArrays.fill(cnt, 0);\n\t\t\tfor(long x : xs) { cnt[(int)(x>>j&0xFFFF)+1]++; }\n\t\t\tfor(int i = 1; i < cnt.length; i++) { cnt[i] += cnt[i-1]; }\n\t\t\tfor(long x : xs) { ys[cnt[(int)(x>>j&0xFFFF)]++] = x; }\n\t\t\t{ final long[] t = xs; xs = ys; ys = t; }\n\t\t}\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic double rec(int parent , int cur , double memo[] , List<Integer> ordering, int adj[][] , int idx[][]){\n\t\tordering.add(cur);\n\t\tint P = 0;\n\t\tdouble S = 0.0;\n\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\tint dst = adj[cur][i];\n\t\t\tif(dst == parent){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint id = idx[cur][i];\n\t\t\tif(memo[id] < 0.0){\n\t\t\t\tdouble p = rec(cur , dst , memo , ordering , adj , idx) + 1.0;\n\t\t\t\tmemo[id] = p;\n\t\t\t}\n\t\t\tS += memo[id];\n\t\t\tP = P + 1;\n\t\t}\n\t\tif(P == 0){\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn S / P;\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tint srcs[] = new int[N - 1];\n\t\tint dsts[] = new int[N - 1];\n\t\tint vsize[] = new int[N];\n\t\tfor(int i = 0 ; i < N - 1 ; ++i){\n\t\t\tString line = br.readLine();\n\t\t\tint i0 = line.indexOf(' ');\t\t\t\n\t\t\tint u = Integer.parseInt(line.substring(0, i0)) - 1;\n\t\t\tint v = Integer.parseInt(line.substring(i0 + 1)) - 1;\n\t\t\tsrcs[i] = u;\n\t\t\tdsts[i] = v;\n\t\t\tvsize[u]++;\n\t\t\tvsize[v]++;\n\t\t}\n\t\tint adj[][] = new int[N][];\n\t\tint idx[][] = new int[N][];\n\t\tfor(int i = 0 ; i < N ; ++i){\n\t\t\tadj[i] = new int[vsize[i]];\n\t\t\tidx[i] = new int[vsize[i]];\t\n\t\t}\n\t\tint pointer[] = new int[N];\n\t\tfor(int i = 0 ; i < N  - 1 ; ++i){\n\t\t\tint s = srcs[i];\n\t\t\tint d = dsts[i];\n\t\t\tadj[s][pointer[s]] = d;\n\t\t\tidx[s][pointer[s]++] = i * 2;\n\t\t\tadj[d][pointer[d]] = s;\n\t\t\tidx[d][pointer[d]++] = i * 2 + 1;\n\n\t\t}\n\t\tList<Integer> ordering = new ArrayList<Integer>();\n\t\tdouble memo[] = new double[(N - 1) * 2];\n\t\tArrays.fill(memo, -1);\n\t\tdouble ans[] = new double[N];\n\t\trec(0, 0, memo, ordering, adj , idx);\n\t\tfor(int cur : ordering){\n\t\t\tdouble S = 0.0;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tS += memo[idx[cur][i]];\n\t\t\t}\n\t\t\tint size = adj[cur].length;\n\t\t\tans[cur] = S / size;\n\t\t\tfor(int i = 0 ; i < adj[cur].length ; ++i){\n\t\t\t\tint id = idx[cur][i];\n\t\t\t\tint redge = id % 2 == 0 ? id + 1 : id - 1;\n\t\t\t\tif(size == 1){\n\t\t\t\t\tmemo[redge] = 1.0;\n\t\t\t\t}else{\n\t\t\t\t\tdouble v = S - memo[id];\n\t\t\t\t\tmemo[redge] = 1.0 + v / (size - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(double v : ans){\n\t\t\tsb.append(v);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tint[] u = new int[n];\n\t\tint[] v = new int[n];\n\t\tList<List<Integer>> edges = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tedges.add(new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tu[i] = sc.nextInt() - 1;\n\t\t\tv[i] = sc.nextInt() - 1;\n\n\t\t\tedges.get(u[i]).add(v[i]);\n\t\t\tedges.get(v[i]).add(u[i]);\n\t\t}\n\n\t\tif (n > 1000) {\n//\t\tif (n > 0) {\n\t\t\tint root = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edges.get(i).size() == 1) {\n\t\t\t\t\troot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (root == -1) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\n\t\t\tdouble[] ans = new double[n];\n\t\t\tList<Integer> vl = new ArrayList<>(n);\n\t\t\tvl.add(root);\n\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tq.add(root);\n\t\t\tused[root] = true;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint e = q.remove();\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\tif (!used[next]) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cnt > 1) {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t} else {\n\t\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\t\tif (!used[next]) {\n\t\t\t\t\t\t\tvl.add(next);\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t\tused[next] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i == 0 || i == n - 1) {\n\t\t\t\t\tans[vl.get(i)] = n - 1;\n\t\t\t\t} else {\n\t\t\t\t\tans[vl.get(i)] = (double) i / 2 + (double)(n - 1 - i) / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpr.printf(\"%.7f\\n\", ans[i]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int vv = 0; vv < n; vv++) {\n\t\t\tdouble[] p = new double[n];\n\t\t\tint[] d = new int[n];\n\t\t\tArrays.fill(d, -1);\n\n\t\t\tdouble ret = 0;\n\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tq.add(vv);\n\t\t\tp[vv] = 1;\n\t\t\td[vv] = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint e = q.remove();\n\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\tif (d[next] == -1) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cnt == 0) {\n\t\t\t\t\tret += d[e] * p[e];\n\t\t\t\t} else {\n\t\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\t\tif (d[next] == -1) {\n\t\t\t\t\t\t\td[next] = d[e] + 1;\n\t\t\t\t\t\t\tp[next] = p[e] * (double)1 / cnt;\n\t\t\t\t\t\t\tq.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpr.printf(\"%.7f\\n\", ret);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n//\t\t\tint n = 150000;\n\t\t\t\n\t\t\tg = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n//\t\t\t\tint s = random.nextInt(i + 1);\n//\t\t\t\tint t = i + 1;\n\t\t\t\tg[s].add(t);\n\t\t\t\tg[t].add(s);\n\t\t\t}\n\t\t\t\n\t\t\tes = new int[n][];\n\t\t\tmemo = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes[i] = new int[g[i].size() + 1];\n\t\t\t\tmemo[i] = new double[g[i].size() + 1];\n\t\t\t\tes[i][g[i].size()] = -1;\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes[i][j] = g[i].get(j);\n\t\t\t\t}\n\t\t\t\tArrays.sort(es[i]);\n\t\t\t\tArrays.fill(memo[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tes2 = new int[n][][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tes2[i] = new int[g[i].size()][2];\n\t\t\t\tfor (int j = 0; j < g[i].size(); j++) {\n\t\t\t\t\tes2[i][j][0] = g[i].get(j);\n\t\t\t\t\tes2[i][j][1] = Arrays.binarySearch(es[g[i].get(j)], i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\tio.out.printf(\"%.10f\\n\", rec(i, -1));\n\t\t\t\tprint(rec(i, -1, 0));\n\t\t\t}\n//\t\t\tio.out.println(res);\n\t\t}\n\t}\n\t\n\tint[][][] es2;\n\tdouble[][] memo;\n\tint[][] es;\n\tList<Integer>[] g;\n\tdouble rec(int v, int p, int idx) {\n\t\tif (memo[v][idx] >= 0) { return memo[v][idx]; }\n\t\tint childs = p == -1 ? g[v].size() : g[v].size() - 1;\n\t\tdouble ans = 0;\n\t\tfor (int[] t : es2[v]) if (t[0] != -1 && t[0] != p) {\n\t\t\tans += rec(t[0], v, t[1]) + 1;\n\t\t}\n\t\tif (childs > 0) ans /= childs;\n\t\tmemo[v][idx] = ans;\n\t\treturn ans;\n\t}\n\n\tStringBuilder res = new StringBuilder();\n\tStringBuilder sb = new StringBuilder();\n\tvoid print(double x) {\n//\t\tx += 5e-11;\n\t\tsb.setLength(0);\n\t\tsb.append((int)x);\n\t\tsb.append('.');\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tx -= (int)x;\n\t\t\tx *= 10;\n\t\t\tsb.append((char)((int)x + '0'));\n\t\t}\n//\t\tio.out.println(sb);\n//\t\tsb.append(\"\\n\");\n//\t\tres.append(sb);\n\t\tio.out.println(sb);\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tdouble[] dp = new double[n];\n\t\tint[] nums = new int[n];\n\t\tdouble[] sums = new double[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tint num = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tnum++;\n\t\t\t\tsum += dp[e];\n\t\t\t}\n\t\t\tif(num == 0){\n\t\t\t\tdp[cur] = 0;\n\t\t\t}else{\n\t\t\t\tdp[cur] = sum / num + 1;\n\t\t\t}\n\t\t\tsums[cur] = sum;\n\t\t\tnums[cur] = num;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tint cur = ord[i];\n\t\t\tint p = par[cur];\n\t\t\tsums[cur] += nums[p] == 1 ? 0. : (sums[p] + nums[p] - 1 - dp[cur]) / (nums[p] - 1);\n\t\t\tnums[cur]++;\n\t\t\tdp[cur] = sums[cur] / nums[cur] + 1;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tout.printf(\"%.14f\\n\", dp[i]);\n\t\t}\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tdouble[] dp = new double[n];\n\t\tint[] nums = new int[n];\n\t\tdouble[] sums = new double[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tint num = 0;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tnum++;\n\t\t\t\tsum += dp[e];\n\t\t\t}\n\t\t\tif(num == 0){\n\t\t\t\tdp[cur] = 0;\n\t\t\t}else{\n\t\t\t\tdp[cur] = sum / num + 1;\n\t\t\t}\n\t\t\tsums[cur] = sum;\n\t\t\tnums[cur] = num;\n\t\t}\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tint cur = ord[i];\n\t\t\tint p = par[cur];\n\t\t\tsums[cur] += nums[p] == 1 ? 0. : (sums[p] + nums[p] - 1 - dp[cur]) / (nums[p] - 1);\n\t\t\tnums[cur]++;\n\t\t\tdp[cur] = sums[cur] / nums[cur] + 1;\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n//\t\t\tout.printf(\"%.14f\\n\", dp[i]);\n\t\t\tout.println(dtos(dp[i], 10));\n\t\t}\n\t}\n\t\n\tpublic static String dtos(double x, int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(x < 0){\n\t\t\tsb.append('-');\n\t\t\tx = -x;\n\t\t}\n\t\tx += Math.pow(10, -n)/2;\n//\t\tif(x < 0){ x = 0; }\n\t\tsb.append((long)x);\n\t\tsb.append(\".\");\n\t\tx -= (long)x;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tx *= 10;\n\t\t\tsb.append((int)x);\n\t\t\tx -= (int)x;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.Square4\n{\n    class D\n    {\n        static int n;\n        static List<int>[] graph;\n        static double[] dp;\n        static double[] res;\n\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            n = ReadInt();\n            graph = new List<int>[n];\n            for (int i = 0; i < n; i++) graph[i] = new List<int>();\n            dp = new double[n];\n            res = new double[n];\n            for(int i = 0; i < n - 1; i++)\n            {\n                int[] uv = ReadInts();\n                int u = uv[0] - 1;\n                int v = uv[1] - 1;\n                graph[u].Add(v);\n                graph[v].Add(u);\n            }\n            DFS1(-1, 0);\n            DFS2(-1, 0, 0);\n            for(int i = 0; i < n; i++)\n            {\n                WriteLine(res[i]);\n            }\n        }\n\n        static double DFS1(int from,int to)\n        {\n            if (to != 0 && graph[to].Count == 1)\n            {\n                dp[to] = 0;\n            }\n            else\n            {\n                double val = 0;\n                for(int i = 0; i < graph[to].Count; i++)\n                {\n                    int next = graph[to][i];\n                    if (from == next) continue;\n\n                    val += DFS1(to, next) + 1;\n                }\n                if (to == 0) val /= graph[to].Count;\n                else val /= graph[to].Count - 1;\n                dp[to] = val;\n            }\n            return dp[to];\n        }\n\n        static void DFS2(int from, int to, double pValue)\n        {\n            if (to == 0)\n            {\n                res[to] = dp[to];\n            }\n            else\n            {\n                res[to] = (dp[to] * (graph[to].Count - 1) + pValue + 1) / graph[to].Count;\n            }\n\n            for (int i = 0; i < graph[to].Count; i++)\n            {\n                int next = graph[to][i];\n                if (from == next) continue;\n\n                double pNext;\n                if (to == 0 && graph[to].Count == 1) pNext = 0;\n                else pNext = (res[to] * graph[to].Count - dp[next] - 1) / (graph[to].Count - 1);\n                DFS2(to, next, pNext);\n            }\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n    int N;\n    List<int>[] G, P;\n    int[] A;\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int u = cin.Nextint - 1;\n            int v = cin.Nextint - 1;\n            G[u].Add(v);\n            G[v].Add(u);\n        }\n        var K = new List<int>();\n        for (int i = 0; i < N; i++)\n        {\n            if (G[i].Count == 1)\n            {\n                K.Add(i);\n            }\n        }\n\n        //solve\n        A = new int[N];\n        Dfs(G[K[0]][0], 1, K[0]);\n        Dfs(G[K[1]][0], 1, K[1]);\n\n        for (int i = 0; i < N; i++)\n        {\n            if (i == K[0])\n            {\n                WriteLine(A[K[1]]);\n            }\n            else if (i == K[1])\n            {\n                WriteLine(A[K[0]]);\n            }\n            else\n            {\n                WriteLine((double)A[i] / 2);\n            }\n        }\n            \n\n\n        /*P = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        var ashi = start;\n        var Q = new List<int>();\n        Q.Add(ashi);\n        //maeoki\n        var B = new bool[N];\n        B[ashi] = true;\n\n\n        var S= new Stack<int>();\n        S.Push(ashi);\n        while (S.Any())\n        {\n\n            int cnt = 0;\n            var L = new List<int>();\n            foreach (var item in G[ashi])\n            {\n                if (B[item]) continue;\n                cnt++;\n                L.Add(item);\n            }\n            if (cnt == 1)\n            {\n                ashi = L[0];\n                P[ashi].Add(start);\n                Q.Add(ashi);\n                B[ashi] = true;\n            }\n        }*/\n\n    }\n    void Dfs(int u, int depth, int back)\n    {\n        A[u] += depth;\n        int x = -1;\n        foreach (var item in G[u])\n        {\n            if (item == back) continue;\n            x = item;\n        }\n        if (x == -1) return;\n        Dfs(x, depth + 1, u);\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n        HashSet<long> s = new HashSet<long> { };\n        for (long i = 0; i < n - 1; i++)\n        {\n            int[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            if (!s.Add(a[0])) { s.Remove(a[0]); }\n            else { s.Add(a[0]); }\n            if (!s.Add(a[1])) { s.Remove(a[1]); }\n            else { s.Add(a[1]); }\n        }\n        List<long> d = s.ToList();\n        for (long i = 0; i < n; i++)\n        {\n            if (i == d[0] -1|| i == d[1]-1) { Console.WriteLine(n - 1); }\n            else { Console.WriteLine((n - 1) / (double)2); }\n        }\n        Console.ReadLine();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n        List<int> s = new List<int> { };\n        for (long i = 0; i < n - 1; i++)\n        {\n            int[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            if (s.IndexOf(a[0]) > -1) { s.Remove(a[0]); }\n            else { s.Add(a[0]); }\n            if (s.IndexOf(a[1]) > -1) { s.Remove(a[1]); }\n            else { s.Add(a[1]); }\n        }\n        for (long i = 0; i < n; i++)\n        {\n            if (i == s[0] -1|| i == s[1]-1) { Console.WriteLine(n - 1); }\n            else { Console.WriteLine((n - 1) / (double)2); }\n        }\n        Console.ReadLine();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n        for (long i = 0; i < n - 1; i++) { Console.ReadLine(); }\n        for (long i = 0; i < n; i++)\n        {\n            if (i == 0 || i == n - 1) { Console.Write(n - 1 + \".0\"); }\n            else { Console.Write((n - 1) / (double)2); if (((n - 1) / (double)2) % 2 == 0) { Console.Write(\".0\"); } }\n            Console.WriteLine();\n        }\n        Console.ReadLine();\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace s8pc_4_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n = long.Parse(Console.ReadLine());\n            for(long i = 0; i < n - 1; i++) { Console.ReadLine(); }\n           for(long i = 0; i < n ; i++)\n            {\n                if (i == 0 || i == n - 1) { Console.Write(n-1+\".0\"); }\n                else { Console.Write((n-1)/(double)2);if (((n - 1) / (double)2) % 2 == 0) { Console.Write(\",0\"); } }\n            }Console.ReadLine();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\nusing static System.Math;\nnamespace AtCoder\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        static readonly long Mod = 1000000000 + 7;\n\n        static void Main(string[] args)\n        {\n            var N = Sarray()[0];\n            grf = new int[N].Select(_ => new List<long>()).ToArray();\n            for (var i = 0; i < N - 1; ++i) \n            {\n                var stw = Sarray();\n                --stw[0];--stw[1];\n                grf[stw[0]].Add(stw[1]);\n                grf[stw[1]].Add(stw[0]);\n            }\n            dptree = new double[N];\n            prob = 1.0d / N;\n\n            dfs(0, -1);\n            dp = new double[N];\n            maxdfs(0, 0, 0);\n            for (var i = 0; i < N; ++i)\n                WriteLine(dp[i]);\n        }\n        static List<long>[] grf;\n        static double[] dptree;\n        static double[] dp;\n        static double prob;\n        static void dfs(long n, long p)\n        {\n            double deno = 0.0;\n            if (0 <= p)\n                deno = prob * (grf[n].Count - 1);\n            else\n                deno = prob * grf[n].Count;\n            if (deno <= 0) return;\n            double nume = 0.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p) continue;\n                dfs(next, n);\n                nume += dptree[next];\n            }\n            dptree[n] = prob * nume / deno + 1.0;\n        }\n        static void maxdfs(long n, long p, double pinfo)\n        {\n            double deno = prob * grf[n].Count;\n            double nume = 0.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p)\n                {\n                    nume += pinfo;\n                    continue;\n                }\n                nume += dptree[next];\n            }\n            dp[n] = prob * nume / deno + 1.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p) continue;\n                if (grf[n].Count == 1)\n                    maxdfs(next, n, 0);\n                else\n                    maxdfs(next, n, prob * (nume - dptree[next]) / (deno - prob) + 1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nusing vt=System.ValueTuple<int,int>;\nusing nint=System.Double;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<vt>[] li;\n\tstatic bool[] b;\n\tstatic int[] pa;\n\tstatic nint[] dp;\n\tstatic nint[][] dpl,dpr;\n\tconst int ie=0;\n\tstatic int ro;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0],m=n-1;\n\t\tli=new List<vt>[n+1];\n\t\tb=new bool[n+1];\n\t\tdp=new nint[n+1];\n\t\tdpl=new nint[n+1][];\n\t\tdpr=new nint[n+1][];\n\t\tpa=new int[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<vt>();\n\t\t\tli[i].Add((-1,-1));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvar e=sc.Ia;\n\t\t\tli[e[0]].Add((e[1],1));\n\t\t\tli[e[1]].Add((e[0],1));\n\t\t}\n\t\tro=1;\n\t\tfor(int i = 1;i<=n;i++) {if(li[i].Count==2){ro=i;break;}}\n\t\tFu1(ro,0);\n\t\tFu2(ro,ie);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 1;i<=n;i++) {sb.Append(dp[i]+\"\\n\");}\n\t\tConsole.Write(sb);\n\t}\n\tstatic void Fu2(int a,nint g){\n\t\tdp[a]=Fop(dpl[a][li[a].Count-1],g)/(li[a].Count-1);\n\t\tfor(int i=1;i<li[a].Count;i++){\n\t\t\tif(li[a][i].Item1!=pa[a]){\n\t\t\t\tFu2(li[a][i].Item1,Fop(Fop(dpl[a][i-1],dpr[a][i+1]),g)/(li[a].Count-(a==ro?1:2))+li[a][i].Item2);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void Fu1(int a,int o){\n\t\tb[a]=true;\n\t\tpa[a]=o;\n\t\tdpl[a]=new nint[li[a].Count];\n\t\tdpr[a]=new nint[li[a].Count+1];\n\t\tdpl[a][0]=dpr[a][li[a].Count]=ie;\n\t\tfor(int i=1;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i].Item1]){\n\t\t\t\tFu1(li[a][i].Item1,a);\n\t\t\t\tdpl[a][i]=dpr[a][i]=dp[li[a][i].Item1]+li[a][i].Item2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdpl[a][i]=dpr[a][i]=ie;\n\t\t\t}\n\t\t\tdpl[a][i]=Fop(dpl[a][i],dpl[a][i-1]);\n\t\t}\n\t\tfor(int i = li[a].Count-1;i>=0;i--) {\n\t\t\tdpr[a][i]=Fop(dpr[a][i],dpr[a][i+1]);\n\t\t}\n\t\tdp[a]=dpl[a][li[a].Count-1];\n\t\tif(li[a].Count>2){dp[a]/=li[a].Count-(o==0?1:2);}\n\t}\n\tstatic nint Fop(nint a,nint b){\n\t\treturn a+b;\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static double[][] memo;\n    static int[][] edge;\n    static List<int>[] lis;\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new int[n - 1][];\n        lis = new List<int>[n];\n        memo = new double[n - 1][];\n        for (int i = 0; i < n; i++)\n        {\n            lis[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            memo[i] = new double[2];\n            memo[i][0] = memo[i][1] = -1;\n            edge[i] = sc.IntArr.Select(x => x - 1).ToArray();\n            lis[edge[i][0]].Add(i);\n            lis[edge[i][1]].Add(i);\n        }\n        var ans = new double[n];\n        for (int i = n - 1; i >= 0; i--)\n        {\n            foreach (var item in lis[i])\n            {\n                ans[i] += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            ans[i] /= lis[i].Count;\n        }\n        foreach (var item in ans)\n        {\n            Prt(item);\n        }\n        sw.Flush();\n    }\n    static double dfs(int j, int d)\n    {\n        if (memo[j][d] > -0.5) return memo[j][d];\n\n        int nod = edge[j][d];\n        if (lis[nod].Count == 1)\n        {\n            return memo[j][d] = 1;\n        }\n        double ret = 0;\n        foreach (var item in lis[nod])\n        {\n            if (item == j) continue;\n\n            ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n        }\n        return memo[j][d] = ret / (lis[nod].Count - 1);\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace s8pc_4_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            for(int i = 0; i < n - 1; i++) { Console.ReadLine(); }\n           for(int i = 0; i < n ; i++)\n            {\n                if (i == 0 || i == n - 1) { Console.WriteLine(n-1); }\n                else { Console.WriteLine((n - 1) / (double)2); }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static double[][] memo;\n    static int[][] edge;\n    static List<int>[] lis;\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new int[n - 1][];\n        lis = new List<int>[n];\n        memo = new double[n - 1][];\n        for (int i = 0; i < n; i++)\n        {\n            lis[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            memo[i] = new double[2];\n            memo[i][0] = memo[i][1] = -1;\n            edge[i] = sc.IntArr.Select(x => x - 1).ToArray();\n            lis[edge[i][0]].Add(i);\n            lis[edge[i][1]].Add(i);\n        }\n        for (int i = 0; i < n; i++)\n        {\n            double ans = 0;\n            foreach (var item in lis[i])\n            {\n                ans += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            Prt(ans / lis[i].Count);\n        }\n        sw.Flush();\n    }\n    static double dfs(int j, int d)\n    {\n        if (memo[j][d] > -0.5) return memo[j][d];\n\n        if (lis[edge[j][d]].Count == 1)\n        {\n            return memo[j][d] = 1;\n        }\n        double ret = 0;\n        foreach (var item in lis[edge[j][d]])\n        {\n            if (item == j) continue;\n\n            ret += dfs(item, edge[item][0] == edge[j][d] ? 1 : 0) + 1;\n        }\n        return memo[j][d] = ret / (lis[edge[j][d]].Count - 1);\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n    int N;\n    List<int>[] G, P;\n    int[] A;\n    bool[] B;\n    double cnt;\n\n    void Calc(double per, int u, int depth, bool start)\n    {\n        if (!start && G[u].Count == 1)\n        {\n            cnt += per * depth;\n            return;\n        }\n \n        foreach (var v in G[u])\n        {\n            if (B[v]) continue;\n            B[v] = true;\n            int way = G[u].Count - 1;\n            if (start) way++;\n\n            Calc(per / way, v, depth + 1, false);\n        }\n    }\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int u = cin.Nextint - 1;\n            int v = cin.Nextint - 1;\n            G[u].Add(v);\n            G[v].Add(u);\n        }\n\n        var K = new List<int>();\n        for (int i = 0; i < N; i++)\n        {\n            if (G[i].Count == 1)\n            {\n                K.Add(i);\n            }\n        }\n        if (K.Count > 2)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                B = new bool[N];\n                cnt = 0;\n                B[i] = true;\n                Calc(1, i, 0, true);\n                WriteLine(cnt.ToString(\"F7\"));\n            }\n        }\n\n\n        else\n        {\n            //solve\n            A = new int[N];\n            Dfs(G[K[0]][0], 1, K[0]);\n            Dfs(G[K[1]][0], 1, K[1]);\n\n            for (int i = 0; i < N; i++)\n            {\n                if (i == K[0])\n                {\n                    WriteLine(A[K[1]]);\n                }\n                else if (i == K[1])\n                {\n                    WriteLine(A[K[0]]);\n                }\n                else\n                {\n                    WriteLine((double)A[i] / 2);\n                }\n            }\n        }\n\n\n\n        \n            \n\n\n        /*P = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        var ashi = start;\n        var Q = new List<int>();\n        Q.Add(ashi);\n        //maeoki\n        var B = new bool[N];\n        B[ashi] = true;\n\n\n        var S= new Stack<int>();\n        S.Push(ashi);\n        while (S.Any())\n        {\n\n            int cnt = 0;\n            var L = new List<int>();\n            foreach (var item in G[ashi])\n            {\n                if (B[item]) continue;\n                cnt++;\n                L.Add(item);\n            }\n            if (cnt == 1)\n            {\n                ashi = L[0];\n                P[ashi].Add(start);\n                Q.Add(ashi);\n                B[ashi] = true;\n            }\n        }*/\n\n    }\n    void Dfs(int u, int depth, int back)\n    {\n        A[u] += depth;\n        int x = -1;\n        foreach (var item in G[u])\n        {\n            if (item == back) continue;\n            x = item;\n        }\n        if (x == -1) return;\n        Dfs(x, depth + 1, u);\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace s8pc_4_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n = long.Parse(Console.ReadLine());\n            for(long i = 0; i < n - 1; i++) { Console.ReadLine(); }\n           for(long i = 0; i < n ; i++)\n            {\n                if (i == 0 || i == n - 1) { Console.Write(n-1+\".0\"); }\n                else { Console.Write((n-1)/(double)2);if (((n - 1) / (double)2) % 2 == 0) { Console.Write(\",0\"); } }\n            }Console.WriteLine(); Console.ReadLine();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static double[][] memo;\n    static int[][] edge;\n    static List<int>[] lis;\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new int[n - 1][];\n        lis = new List<int>[n];\n        memo = new double[n - 1][];\n        for (int i = 0; i < n; i++)\n        {\n            lis[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            memo[i] = new double[2];\n            memo[i][0] = memo[i][1] = -1;\n            edge[i] = sc.IntArr.Select(x => x - 1).ToArray();\n            lis[edge[i][0]].Add(i);\n            lis[edge[i][1]].Add(i);\n        }\n        var ans = new double[n];\n        for (int i = n / 2; i < n; i++)\n        {\n            foreach (var item in lis[i])\n            {\n                ans[i] += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            ans[i] /= lis[i].Count;\n        }\n        for (int i = n / 2 - 1; i >= 0; i--)\n        {\n            foreach (var item in lis[i])\n            {\n                ans[i] += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            ans[i] /= lis[i].Count;\n        }\n        foreach (var item in ans)\n        {\n            Prt(item);\n        }\n        sw.Flush();\n    }\n    static double dfs(int j, int d)\n    {\n        if (memo[j][d] > -0.5) return memo[j][d];\n\n        int nod = edge[j][d];\n        if (lis[nod].Count == 1)\n        {\n            return memo[j][d] = 1;\n        }\n        double ret = 0;\n        foreach (var item in lis[nod])\n        {\n            if (item == j) continue;\n\n            ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n        }\n        return memo[j][d] = ret / (lis[nod].Count - 1);\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        List<int>[] neighbours = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        int[][] edges = Enumerable.Repeat(0, n - 1).Select(_ => Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray()).ToArray();\n        ReRooting treeDP = new ReRooting(n, edges);\n        Console.WriteLine(string.Join(\"\\n\", Enumerable.Range(0, n).Select(x => treeDP.Query(x))));\n    }\n}\n\n\nclass ReRooting\n{\n    int[][] Neighbours;\n    int[][] IndexForNeighbours;\n\n    double[] res;\n    double[][] dp;\n    int[] SearchState;\n\n    public ReRooting(int nodeCount, int[][] edges)\n    {\n        List<int>[] neighbours = new List<int>[nodeCount];\n        List<int>[] indexForNeighbours = new List<int>[nodeCount];\n\n        for (int i = 0; i < nodeCount; i++)\n        {\n            neighbours[i] = new List<int>();\n            indexForNeighbours[i] = new List<int>();\n        }\n        for (int i = 0; i < edges.Length; i++)\n        {\n            var edge = edges[i];\n            indexForNeighbours[edge[0]].Add(neighbours[edge[1]].Count);\n            indexForNeighbours[edge[1]].Add(neighbours[edge[0]].Count);\n            neighbours[edge[0]].Add(edge[1]);\n            neighbours[edge[1]].Add(edge[0]);\n        }\n\n        Neighbours = new int[nodeCount][];\n        IndexForNeighbours = new int[nodeCount][];\n        for (int i = 0; i < nodeCount; i++)\n        {\n            Neighbours[i] = neighbours[i].ToArray();\n            IndexForNeighbours[i] = indexForNeighbours[i].ToArray();\n        }\n\n        dp = new double[Neighbours.Length][];\n        SearchState = new int[Neighbours.Length];\n\n        res = new double[Neighbours.Length];\n        for (int i = 0; i < Neighbours.Length; i++)\n        {\n            dp[i] = new double[Neighbours[i].Length];\n            SearchState[i] = -2;\n        }\n    }\n\n    public double Query(int x)\n    {\n        if (SearchState[x] != -1) DFS(x, -1);\n        return res[x];\n    }\n\n    public double Query(int x, int toIndex)\n    {\n        if (SearchState[x] != -1 && SearchState[x] != toIndex) DFS(x, Neighbours[x][toIndex]);\n        return dp[Neighbours[x][toIndex]][IndexForNeighbours[x][toIndex]];\n    }\n\n    private void DFS(int x, int parent)\n    {\n        Debug.Assert(SearchState[x] != -1 && (SearchState[x] == -2 || Neighbours[x][SearchState[x]] != parent));\n\n        double accum = 0;\n        if (SearchState[x] == -2)\n        {\n            SearchState[x] = -1;\n            for (int i = 0; i < Neighbours[x].Length; i++)\n            {\n                if (Neighbours[x][i] == parent)\n                {\n                    SearchState[x] = i;\n                    continue;\n                }\n                var state = SearchState[Neighbours[x][i]];\n                if (state != -1 && state != IndexForNeighbours[x][i]) DFS(Neighbours[x][i], x);\n                accum = accum + dp[x][i];\n            }\n            if (SearchState[x] != -1)\n            {\n                dp[parent][IndexForNeighbours[x][SearchState[x]]] = Neighbours[x].Length == 1 ? 1 : accum / (Neighbours[x].Length - 1) + 1;\n                return;\n            }\n            accum = 0;\n        }\n        else\n        {\n            var targetInd = SearchState[x];\n            var target = Neighbours[x][targetInd];\n            var targetState = SearchState[target];\n            if (targetState != -1 && targetState != IndexForNeighbours[x][targetInd]) DFS(Neighbours[x][targetInd], x);\n        }\n\n        double[] accumsFromTail = new double[Neighbours[x].Length];\n        accumsFromTail[accumsFromTail.Length - 1] = 0;\n        for (int i = accumsFromTail.Length - 2; i >= 0; i--) accumsFromTail[i] = accumsFromTail[i + 1] + dp[x][i + 1];\n        for (int i = 0; i < accumsFromTail.Length; i++)\n        {\n            dp[Neighbours[x][i]][IndexForNeighbours[x][i]] = Neighbours[x].Length == 1 ? 1 : (accum + accumsFromTail[i]) / (Neighbours[x].Length - 1) + 1;\n            accum = accum + dp[x][i];\n        }\n\n        res[x] = accum / Neighbours[x].Length;\n        SearchState[x] = -1;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\nusing static System.Math;\nnamespace AtCoder\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        static readonly long Mod = 1000000000 + 7;\n\n        static void Main(string[] args)\n        {\n            var N = Sarray()[0];\n            grf = new int[N].Select(_ => new List<long>()).ToArray();\n            for (var i = 0; i < N - 1; ++i) \n            {\n                var stw = Sarray();\n                --stw[0];--stw[1];\n                grf[stw[0]].Add(stw[1]);\n                grf[stw[1]].Add(stw[0]);\n            }\n            dptree = new double[N];\n            prob = 1.0d / N;\n\n            dfs(0, -1);\n            dp = new double[N];\n            maxdfs(0, 0, 0);\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            for (var i = 0; i < N; ++i)\n                WriteLine(dp[i]);\n            Console.Out.Flush();\n        }\n        static List<long>[] grf;\n        static double[] dptree;\n        static double[] dp;\n        static double prob;\n        static void dfs(long n, long p)\n        {\n            double deno = 0.0;\n            if (0 <= p)\n                deno = prob * (grf[n].Count - 1);\n            else\n                deno = prob * grf[n].Count;\n            if (deno <= 0) return;\n            double nume = 0.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p) continue;\n                dfs(next, n);\n                nume += dptree[next];\n            }\n            dptree[n] = prob * nume / deno + 1.0;\n        }\n        static void maxdfs(long n, long p, double pinfo)\n        {\n            double deno = prob * grf[n].Count;\n            double nume = 0.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p)\n                {\n                    nume += pinfo;\n                    continue;\n                }\n                nume += dptree[next];\n            }\n            dp[n] = prob * nume / deno + 1.0;\n            foreach (var next in grf[n])\n            {\n                if (next == p) continue;\n                if (grf[n].Count == 1)\n                    maxdfs(next, n, 0);\n                else\n                    maxdfs(next, n, prob * (nume - dptree[next]) / (deno - prob) + 1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1000000007\n\ndouble memo[150010][2];\nint edge[150010][2];\nint edc[150010];\nvector<int> lis[150010];\n\ndouble dfs(int j, int d)\n{\n    if (memo[j][d] > -0.5) return memo[j][d];\n\n    int nod = edge[j][d];\n    if (edc[nod] == 1)\n    {\n        return memo[j][d] = 1;\n    }\n    double ret = 0;\n    for (int item : lis[nod])\n    {\n        if (item == j) continue;\n\n        ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n    }\n    return memo[j][d] = ret / (edc[nod] - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++)\n    {\n        memo[i][0] = memo[i][1] = -1;\n        cin >> edge[i][0] >> edge[i][1];\n        --edge[i][0];\n        --edge[i][1];\n        ++edc[edge[i][0]];\n        ++edc[edge[i][1]];\n        lis[edge[i][0]].emplace_back(i);\n        lis[edge[i][1]].emplace_back(i);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        double ans = 0;\n        for (int item : lis[i])\n        {\n            ans += dfs(item, edge[item][0] == i ? 1 : 0);\n        }\n        printf(\"%.9f\\n\", ans / edc[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n        List<int> s = new List<int> { };\n        for (long i = 0; i < n - 1; i++)\n        {\n            int[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            if (s.IndexOf(a[0]) > -1) { s.Remove(a[0]); }\n            else { s.Add(a[0]); }\n            if (s.IndexOf(a[1]) > -1) { s.Remove(a[1]); }\n            else { s.Add(a[1]); }\n        }\n        int hajime = s[0];\n        int owari = s[1];\n        \n        for (long i = 0; i < n; i++)\n        {\n            if (i == hajime || i == owari) { Console.WriteLine(n - 1); }\n            else { Console.WriteLine((n - 1) / (double)2); }\n        }\n        Console.ReadLine();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    Random rnd = new Random();\n    Stopwatch sw = new Stopwatch();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n\n    int N;\n    List<int>[] G, P;\n    int[] A;\n    bool[] B;\n    double cnt;\n\n    void Calc(double per, int u, int depth, bool start)\n    {\n        if (!start && G[u].Count == 1)\n        {\n            cnt += per * depth;\n            return;\n        }\n \n        foreach (var v in G[u])\n        {\n            if (B[v]) continue;\n            B[v] = true;\n            int way = G[u].Count - 1;\n            if (start) way++;\n\n            Calc(per / way, v, depth + 1, false);\n        }\n    }\n    void Solve()\n    {\n        N = cin.Nextint;\n        G = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < N - 1; i++)\n        {\n            int u = cin.Nextint - 1;\n            int v = cin.Nextint - 1;\n            G[u].Add(v);\n            G[v].Add(u);\n        }\n\n        for (int i = 0; i < N; i++)\n        {\n            B = new bool[N];\n            cnt = 0;\n            B[i] = true;\n            Calc(1, i, 0, true);\n            WriteLine(cnt.ToString(\"F7\"));\n        }\n\n\n\n        /*var K = new List<int>();\n        for (int i = 0; i < N; i++)\n        {\n            if (G[i].Count == 1)\n            {\n                K.Add(i);\n            }\n        }\n        //solve\n        A = new int[N];\n        Dfs(G[K[0]][0], 1, K[0]);\n        Dfs(G[K[1]][0], 1, K[1]);\n\n        for (int i = 0; i < N; i++)\n        {\n            if (i == K[0])\n            {\n                WriteLine(A[K[1]]);\n            }\n            else if (i == K[1])\n            {\n                WriteLine(A[K[0]]);\n            }\n            else\n            {\n                WriteLine((double)A[i] / 2);\n            }\n        }*/\n            \n\n\n        /*P = Enumerable.Range(0, N).Select(i => new List<int>()).ToArray();\n        var ashi = start;\n        var Q = new List<int>();\n        Q.Add(ashi);\n        //maeoki\n        var B = new bool[N];\n        B[ashi] = true;\n\n\n        var S= new Stack<int>();\n        S.Push(ashi);\n        while (S.Any())\n        {\n\n            int cnt = 0;\n            var L = new List<int>();\n            foreach (var item in G[ashi])\n            {\n                if (B[item]) continue;\n                cnt++;\n                L.Add(item);\n            }\n            if (cnt == 1)\n            {\n                ashi = L[0];\n                P[ashi].Add(start);\n                Q.Add(ashi);\n                B[ashi] = true;\n            }\n        }*/\n\n    }\n    /*void Dfs(int u, int depth, int back)\n    {\n        A[u] += depth;\n        int x = -1;\n        foreach (var item in G[u])\n        {\n            if (item == back) continue;\n            x = item;\n        }\n        if (x == -1) return;\n        Dfs(x, depth + 1, u);\n    }*/\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace s8pc_4_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n = long.Parse(Console.ReadLine());\n            for(long i = 0; i < n - 1; i++) { Console.ReadLine(); }\n           for(long i = 0; i < n ; i++)\n            {\n                if (i == 0 || i == n - 1) { Console.WriteLine(n-1); }\n                else { Console.WriteLine((n - 1) / (double)2); }\n            }Console.ReadLine();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static double[][] memo;\n    static int[][] edge;\n    static List<int>[] lis;\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new int[n - 1][];\n        lis = new List<int>[n];\n        memo = new double[n - 1][];\n        for (int i = 0; i < n; i++)\n        {\n            lis[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            memo[i] = new double[2];\n            memo[i][0] = memo[i][1] = -1;\n            edge[i] = sc.IntArr.Select(x => x - 1).ToArray();\n            lis[edge[i][0]].Add(i);\n            lis[edge[i][1]].Add(i);\n        }\n        var ans = new double[n];\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var item in lis[i])\n            {\n                ans[i] += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            ans[i] /= lis[i].Count;\n        }\n        foreach (var item in ans)\n        {\n            Prt(item);\n        }\n        sw.Flush();\n    }\n    static double dfs(int j, int d)\n    {\n        if (memo[j][d] > -eps) return memo[j][d];\n\n        if (lis[edge[j][d]].Count == 1)\n        {\n            return memo[j][d] = 1;\n        }\n        double ret = 0;\n        foreach (var item in lis[edge[j][d]])\n        {\n            if (item == j) continue;\n\n            ret += dfs(item, edge[item][0] == edge[j][d] ? 1 : 0) + 1;\n        }\n        return memo[j][d] = ret / (lis[edge[j][d]].Count - 1);\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n//    static Scan sc = new ScanCHK();\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static double[][] memo;\n    static int[][] edge;\n    static List<int>[] lis;\n    static void Main()\n    {\n        int n = sc.Int;\n        edge = new int[n - 1][];\n        lis = new List<int>[n];\n        memo = new double[n - 1][];\n        for (int i = 0; i < n; i++)\n        {\n            lis[i] = new List<int>();\n        }\n        for (int i = 0; i < n - 1; i++)\n        {\n            memo[i] = new double[2];\n            memo[i][0] = memo[i][1] = -1;\n            edge[i] = sc.IntArr.Select(x => x - 1).ToArray();\n            lis[edge[i][0]].Add(i);\n            lis[edge[i][1]].Add(i);\n        }\n        for (int i = 0; i < n; i++)\n        {\n            double ans = 0;\n            foreach (var item in lis[i])\n            {\n                ans += dfs(item, edge[item][0] == i ? 1 : 0);\n            }\n            Prt(ans / lis[i].Count);\n        }\n        sw.Flush();\n    }\n    static double dfs(int j, int d)\n    {\n        if (memo[j][d] > -0.5) return memo[j][d];\n\n        int nod = edge[j][d];\n        if (lis[nod].Count == 1)\n        {\n            return memo[j][d] = 1;\n        }\n        double ret = 0;\n        foreach (var item in lis[nod])\n        {\n            if (item == j) continue;\n\n            ret += dfs(item, edge[item][0] == nod ? 1 : 0) + 1;\n        }\n        return memo[j][d] = ret / (lis[nod].Count - 1);\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { Console.WriteLine(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { sw.WriteLine(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { sw.WriteLine(string.Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass ScanCHK : Scan\n{\n    public new string Str { get { var s = Console.ReadLine(); if (s != s.Trim()) throw new Exception(); return s; } }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (declare #.cl-user::opt)\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.cl-user::opt)\n  (let* ((n (read))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (dp (make-array n :element-type 'double-float :initial-element 0d0))\n         (res (make-array n :element-type 'double-float :initial-element 0d0))\n         (degs (make-array n :element-type 'uint31 :initial-element 0)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read-fixnum) 1))\n            (v (- (read-fixnum) 1)))\n        (incf (aref degs u))\n        (incf (aref degs v))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (let ((sum 0d0)\n            (count (+ (aref degs v) (if (= -1 parent) 0 -1))))\n        (declare (double-float sum))\n        (dolist (child (aref graph v))\n          (unless (eql child parent)\n            (dfs child v)\n            (incf sum (+ 1 (aref dp child)))))\n        (setf (aref dp v)\n              (if (zerop count) 0d0 (/ sum count)))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (setf (aref res v) (aref dp v))\n      (let ((v-deg (aref degs v)))\n        (dolist (child (aref graph v))\n          (unless (eql child parent)\n            (let* ((old-v-value (aref dp v))\n                   (old-child-value (aref dp child))\n                   (new-v-value (let ((num (* (- old-v-value\n                                                 (/ (+ old-child-value 1) v-deg))\n                                              v-deg)))\n                                  (if (zerop num)\n                                      num\n                                      (/ num (- v-deg 1)))))\n                   (new-child-value (/ (+ (* (- (aref degs child) 1) old-child-value)\n                                          new-v-value\n                                          1)\n                                       (aref degs child))))\n              (setf (aref dp v) new-v-value\n                    (aref dp child) new-child-value)\n              (dfs child v)\n              (setf (aref dp v) old-v-value\n                    (aref dp child) old-child-value))))))\n    (write-string\n     (with-output-to-string (*standard-output* nil :element-type 'base-char)\n       (map () #'println res)))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"2.0\n1.0\n2.0\n2.0\n\"\n          (run \"4\n1 2\n2 3\n2 4\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.0\n1.5\n3.0\n1.5\n\"\n          (run \"4\n1 2\n2 4\n4 3\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"4.0\n2.0\n2.0\n2.0\n4.0\n\"\n          (run \"5\n1 2\n2 3\n3 4\n4 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"2.000000000000\n1.666666666667\n1.666666666667\n3.000000000000\n3.000000000000\n3.000000000000\n3.000000000000\n\"\n          (run \"7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.666666666667\n2.250000000000\n3.666666666667\n2.833333333333\n2.555555555556\n2.666666666667\n4.333333333333\n2.666666666667\n5.333333333333\n2.500000000000\n2.500000000000\n5.000000000000\n\"\n          (run \"12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"1.0\n1.0\n\"\n          (run \"2\n1 2\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n(defpackage :cp/read-fixnum\n  (:use :cl)\n  (:export #:read-fixnum))\n(in-package :cp/read-fixnum)\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setq minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;; BEGIN_USE_PACKAGE\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (use-package :cp/read-fixnum :cl-user))\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (dp (make-array n :element-type 'double-float :initial-element 0d0))\n         (res (make-array n :element-type 'double-float :initial-element 0d0))\n         (degs (make-array n :element-type 'uint31 :initial-element 0)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read-fixnum) 1))\n            (v (- (read-fixnum) 1)))\n        (incf (aref degs u))\n        (incf (aref degs v))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (let ((sum 0d0)\n            (count (+ (aref degs v) (if (= -1 parent) 0 -1))))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (dfs child v)\n            (incf sum (+ 1 (aref dp child)))))\n        (setf (aref dp v)\n              (if (zerop count) 0d0 (/ sum count)))))\n    #>dp\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (setf (aref res v) (aref dp v))\n      (let ((v-deg (aref degs v)))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (let* ((old-v-value (aref dp v))\n                   (old-child-value (aref dp child))\n                   (new-v-value (let ((num (* (- old-v-value\n                                                 (/ (+ old-child-value 1) v-deg))\n                                              v-deg)))\n                                  (if (zerop num)\n                                      num\n                                      (/ num (- v-deg 1)))))\n                   (new-child-value (/ (+ (* (- (aref degs child) 1) old-child-value)\n                                          new-v-value\n                                          1)\n                                       (aref degs child))))\n              (setf (aref dp v) new-v-value\n                    (aref dp child) new-child-value)\n              (dfs child v)\n              (setf (aref dp v) old-v-value\n                    (aref dp child) old-child-value))))))\n    (write-string\n     (with-output-to-string (*standard-output* nil :element-type 'base-char)\n       (map () #'println res)))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"2.0\n1.0\n2.0\n2.0\n\"\n          (run \"4\n1 2\n2 3\n2 4\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.0\n1.5\n3.0\n1.5\n\"\n          (run \"4\n1 2\n2 4\n4 3\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"4.0\n2.0\n2.0\n2.0\n4.0\n\"\n          (run \"5\n1 2\n2 3\n3 4\n4 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"2.000000000000\n1.666666666667\n1.666666666667\n3.000000000000\n3.000000000000\n3.000000000000\n3.000000000000\n\"\n          (run \"7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.666666666667\n2.250000000000\n3.666666666667\n2.833333333333\n2.555555555556\n2.666666666667\n4.333333333333\n2.666666666667\n5.333333333333\n2.500000000000\n2.500000000000\n5.000000000000\n\"\n          (run \"12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"1.0\n1.0\n\"\n          (run \"2\n1 2\n\" nil))))\n"
  },
  {
    "language": "Lisp",
    "code": "#-swank\n(unless (member :child-sbcl *features*)\n  (quit\n   :unix-status\n   (process-exit-code\n    (run-program *runtime-pathname*\n                 `(\"--control-stack-size\" \"128MB\"\n                   \"--noinform\" \"--disable-ldb\" \"--lose-on-corruption\" \"--end-runtime-options\"\n                   \"--eval\" \"(push :child-sbcl *features*)\"\n                   \"--script\" ,(namestring *load-pathname*))\n                 :output t :error t :input t))))\n(in-package :cl-user)\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 1000000007)\n\n(defmacro dbg (&rest forms)\n  #+swank (if (= (length forms) 1)\n              `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n              `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;; BEGIN_INSERTED_CONTENTS\n;; BEGIN_USE_PACKAGE\n(in-package :cl-user)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (graph (make-array n :element-type 'list :initial-element nil))\n         (dp (make-array n :element-type 'double-float :initial-element 0d0))\n         (res (make-array n :element-type 'double-float :initial-element 0d0))\n         (degs (make-array n :element-type 'uint31 :initial-element 0)))\n    (dotimes (i (- n 1))\n      (let ((u (- (read-fixnum) 1))\n            (v (- (read-fixnum) 1)))\n        (incf (aref degs u))\n        (incf (aref degs v))\n        (push u (aref graph v))\n        (push v (aref graph u))))\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (let ((sum 0d0)\n            (count (+ (aref degs v) (if (= -1 parent) 0 -1))))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (dfs child v)\n            (incf sum (+ 1 (aref dp child)))))\n        (setf (aref dp v)\n              (if (zerop count) 0d0 (/ sum count)))))\n    #>dp\n    (sb-int:named-let dfs ((v 0) (parent -1))\n      (setf (aref res v) (aref dp v))\n      (let ((v-deg (aref degs v)))\n        (dolist (child (aref graph v))\n          (unless (= child parent)\n            (let* ((old-v-value (aref dp v))\n                   (old-child-value (aref dp child))\n                   (new-v-value (let ((num (* (- old-v-value\n                                                 (/ (+ old-child-value 1) v-deg))\n                                              v-deg)))\n                                  (if (zerop num)\n                                      num\n                                      (/ num (- v-deg 1)))))\n                   (new-child-value (/ (+ (* (- (aref degs child) 1) old-child-value)\n                                          new-v-value\n                                          1)\n                                       (aref degs child))))\n              (setf (aref dp v) new-v-value\n                    (aref dp child) new-child-value)\n              (dfs child v)\n              (setf (aref dp v) old-v-value\n                    (aref dp child) old-child-value))))))\n    (write-string\n     (with-output-to-string (*standard-output* nil :element-type 'base-char)\n       (map () #'println res)))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let* ((*standard-output* (or out (make-string-output-stream)))\n         (res (etypecase thing\n                (null\n                 (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n                   (main)))\n                (string\n                 (with-input-from-string (*standard-input* (delete #\\Return thing))\n                   (main)))\n                (symbol (5am:run! thing))\n                (pathname\n                 (with-open-file (*standard-input* thing)\n                   (main))))))\n    (if out res (get-output-stream-string *standard-output*))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (equal \"2.0\n1.0\n2.0\n2.0\n\"\n          (run \"4\n1 2\n2 3\n2 4\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.0\n1.5\n3.0\n1.5\n\"\n          (run \"4\n1 2\n2 4\n4 3\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"4.0\n2.0\n2.0\n2.0\n4.0\n\"\n          (run \"5\n1 2\n2 3\n3 4\n4 5\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"2.000000000000\n1.666666666667\n1.666666666667\n3.000000000000\n3.000000000000\n3.000000000000\n3.000000000000\n\"\n          (run \"7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"3.666666666667\n2.250000000000\n3.666666666667\n2.833333333333\n2.555555555556\n2.666666666667\n4.333333333333\n2.666666666667\n5.333333333333\n2.500000000000\n2.500000000000\n5.000000000000\n\"\n          (run \"12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n\" nil)))\n  (it.bese.fiveam:is\n   (equal \"1.0\n1.0\n\"\n          (run \"2\n1 2\n\" nil))))\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n@ee = Array.new(N, 0.0)\n@ans = Array.new(N, 0.0)\n@g = {}\n(N-1).times do\n  s, t = gets.split.map(&:to_i)\n  (@g[s-1] ||= []) << t-1\n  (@g[t-1] ||= []) << s-1\nend\n# p @g\n\ndef dfs1(now, prev)\n  ret = 0.0\n  child = 0\n  @g[now].each do |to|\n    next if to == prev\n    dfs1(to, now)\n    ret += @ee[to] + 1.0\n    child += 1\n  end\n  @ee[now] = 0\n  @ee[now] += ret / child if child >= 1\nend\n\ndef dfs2(now, d_prev, prev)\n  ret = 0\n  @g[now].each do |to|\n    if to == prev\n      ret += d_prev + 1.0\n    else\n      ret += @ee[to] + 1.0\n    end\n  end\n  @ans[now] = ret / @g[now].size\n  @g[now].each do |to|\n    next if to == prev\n    dfs2(to, (ret - @ee[to] - 1.0) / [1, @g[now].size - 1].max, now)\n  end\nend\n\ndfs1(0, -1)\ndfs2(0, 0, -1)\nN.times do |i|\n  puts @ans[i].round(10)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport std.regex;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/5;\n\nvoid main() {\n  long N;\n  scanln(N);\n\n  struct M {\n    double p;\n    long num;\n  }\n\n  auto tree = Rerooting!(\n    M, bool,\n    (a, b) => M(\n      a.p + b.p,\n      a.num + b.num,\n    ),\n    (a, _) => M(\n      1 + (a.num == 0 ? 0 : a.p / a.num),\n      1,\n    ),\n    M(0, 0),\n  )(N);\n\n  foreach(i; 0..N-1) {\n    long u, v;\n    scanln(u, v);\n    u--; v--;\n    tree.addEdge(u, v);\n  }\n\n  foreach(m; tree.solve) {\n    writefln(\"%0.8f\", m.p - 1);\n  }\n}\n\ntemplate Rerooting(\n  M,              // DPの要素の型\n  X,              // 各頂点がもつ値の型\n  alias fun,      // DPの要素間の2項演算\n  alias afterFun, // 頂点の値からDPの要素への作用\n  M identity,     // DPの要素の単位元\n  bool ctfeCheckActive = true,\n) {\n  import std.algorithm : map;\n  import std.array : array;\n  import std.functional : binaryFun;\n\n  static if (ctfeCheckActive) {\n    static assert(is(typeof(binaryFun!fun(identity, identity)) : M));\n    static assert(is(typeof(binaryFun!afterFun(identity, X.init)) : M));\n    static assert(binaryFun!fun(identity, identity) == identity);\n  }\n\n  struct Rerooting {\n\n  private:\n    alias _fun = binaryFun!fun;\n    alias _afterFun = binaryFun!afterFun;\n\n    Vertex[] _vertices;\n\n  public:\n    // O(n)\n    this(size_t n) {\n      _vertices.length = n;\n      foreach(i; 0..n) {\n        _vertices[i] = new Vertex(X.init);\n      }\n    }\n\n    // O(n)\n    this(X[] values) {\n      _vertices = values.map!(\n        value => new Vertex(value)\n      ).array;\n    }\n\n    size_t size() {\n      return _vertices.length;\n    }\n\n    void addEdge(size_t x, size_t y) {\n      _vertices[x].adj ~= _vertices[y];\n      _vertices[y].adj ~= _vertices[x];\n    }\n\n    M[] solve(size_t rootIndex = 0) in {\n      assert(rootIndex < size);\n    } body {\n      Vertex[] vs = getOrderedVertices(rootIndex);\n\n      foreach_reverse(v; vs) {\n        M acc = identity;\n        foreach(u; v.adj) {\n          if (u is v.parent) continue;\n          acc = _fun(acc, u.dpValue);\n        }\n        acc = _afterFun(acc, v.value);\n        v.dpValue = acc;\n      }\n\n      M[] accL = new M[size];\n      M[] accR = new M[size];\n      foreach(v; vs) {\n        size_t len = v.adj.length;\n        assert(len+1 <= size);\n        accL[0] = identity;\n        accR[len] = identity;\n        foreach(j, u; v.adj) {\n          accL[j+1] = _fun(\n            accL[j],\n            u is v.parent ? v.parentDpValue : u.dpValue\n          );\n        }\n        foreach_reverse(j, u; v.adj) {\n          accR[j] = _fun(\n            u is v.parent ? v.parentDpValue : u.dpValue,\n            accR[j+1]\n          );\n        }\n        assert(accL[len] == accR[0]);\n        v.dpValue = _afterFun(accL[len], v.value);\n\n        foreach(j, u; v.adj) {\n          if (u is v.parent) continue;\n          u.parentDpValue = _afterFun(\n            _fun(accL[j], accR[j+1]),\n            v.value\n          );\n        }\n      }\n\n      return _vertices.map!\"a.dpValue\".array;\n    }\n\n  private:\n    class Vertex {\n      X value;\n      M dpValue;\n      Vertex[] adj;\n      Vertex parent;\n      M parentDpValue;\n      this(X value) {\n        this.value = value;\n      }\n    }\n\n    Vertex[] getOrderedVertices(size_t rootIndex) {\n      Vertex[] vs = new Vertex[size];\n      size_t index = 0;\n\n      auto stack = DList!Vertex(_vertices[rootIndex]);\n      while(!stack.empty) {\n        Vertex v = stack.back;\n        stack.removeBack;\n        vs[index++] = v;\n        foreach(u; v.adj) {\n          if (u is v.parent) continue;\n          u.parent = v;\n          stack.insertBack(u);\n        }\n      }\n      assert(index == size);\n\n      return vs;\n    }\n  }\n}\n\n\n// ----------------------------------------------\n\n\nvoid times(alias fun)(long n) {\n  // n.iota.each!(i => fun());\n  foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n  // return n.iota.map!(i => fun()).array;\n  T[] res = new T[n];\n  foreach(ref e; res) e = fun();\n  return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  // `(x+y-1)/y` will only work for positive numbers ...\n  T t = x / y;\n  if (y > 0 && t * y < x) t++;\n  if (y < 0 && t * y > x) t++;\n  return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  T t = x / y;\n  if (y > 0 && t * y > x) t--;\n  if (y < 0 && t * y < x) t--;\n  return t;\n}\n\nref T ch(alias fun, T, S...)(ref T lhs, S rhs) {\n  return lhs = fun(lhs, rhs);\n}\nunittest {\n  long x = 1000;\n  x.ch!min(2000);\n  assert(x == 1000);\n  x.ch!min(3, 2, 1);\n  assert(x == 1);\n  x.ch!max(100).ch!min(1000); // clamp\n  assert(x == 100);\n  x.ch!max(0).ch!min(10); // clamp\n  assert(x == 10);\n}\n\nmixin template Constructor() {\n  import std.traits : FieldNameTuple;\n  this(Args...)(Args args) {\n    // static foreach(i, v; args) {\n    foreach(i, v; args) {\n      mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n    }\n  }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n  enum sep = \" \";\n  enum n = Args.length;\n  enum fmt = n.rep!(()=>\"%s\").join(sep);\n\n  string line = readln.chomp;\n  static if (__VERSION__ >= 2074) {\n    line.formattedRead!fmt(args);\n  } else {\n    enum argsTemp = n.iota.map!(\n      i => \"&args[%d]\".format(i)\n    ).join(\", \");\n    mixin(\n      \"line.formattedRead(fmt, \" ~ argsTemp ~ \");\"\n    );\n  }\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  template fold(fun...) if (fun.length >= 1) {\n    auto fold(R, S...)(R r, S seed) {\n      static if (S.length < 2) {\n        return reduce!fun(seed, r);\n      } else {\n        return reduce!fun(tuple(seed), r);\n      }\n    }\n  }\n}\n\n// popcnt with ulongs was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  ulong popcnt(ulong x) {\n    x = (x & 0x5555555555555555L) + (x>> 1 & 0x5555555555555555L);\n    x = (x & 0x3333333333333333L) + (x>> 2 & 0x3333333333333333L);\n    x = (x & 0x0f0f0f0f0f0f0f0fL) + (x>> 4 & 0x0f0f0f0f0f0f0f0fL);\n    x = (x & 0x00ff00ff00ff00ffL) + (x>> 8 & 0x00ff00ff00ff00ffL);\n    x = (x & 0x0000ffff0000ffffL) + (x>>16 & 0x0000ffff0000ffffL);\n    x = (x & 0x00000000ffffffffL) + (x>>32 & 0x00000000ffffffffL);\n    return x;\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nint N;\nint[][] adj;\nint[] parent;\nreal[] ex, ans;\n\nreal dfs(int n, int prev) {\n    parent[n] = prev;\n    if (adj[n].length == 1 && prev != -1) return ex[n] = 0;\n    real ret = 0;\n    real num = adj[n].length.to!real;\n    if (prev != -1) num -= 1;\n\n    foreach (m; adj[n]) {\n        if (m == prev) continue;\n        ret += dfs(m, n) + 1;\n    }\n\n    return ex[n] = ret / num;\n}\n\nvoid dfs2(int n, int prev) {\n    if (prev == -1) {\n        ans[n] = ex[n];\n    }\n    else if (adj[n].length > 1 && adj[prev].length > 1) {\n        ans[n] = ex[n] * (adj[n].length.to!real - 1) / (adj[n].length.to!real);\n        ans[n] += ((ans[prev] - (ex[n]+1) / adj[prev].length) * adj[prev].length / (adj[prev].length - 1) + 1) / adj[n].length;\n    }\n    else if (adj[n].length > 1) {\n        ans[n] = ex[n] * (adj[n].length.to!real - 1) / (adj[n].length.to!real);\n        ans[n] += 1.0L / adj[n].length;\n    }\n    else {\n        ans[n] += ((ans[prev] - (ex[n]+1) / adj[prev].length) * adj[prev].length / (adj[prev].length - 1) + 1) / adj[n].length;\n        //ans[n] += (ans[prev] - (ex[n]) / (adj[prev].length.to!real) + 1) / adj[n].length;\n    }\n\n    foreach (m; adj[n]) {\n        if (m != prev) dfs2(m, n);\n    }\n}\n\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n    adj = new int[][](N);\n    parent = new int[](N);\n    ex = new real[](N);\n    ans = new real[](N);\n    fill(ex, 0);\n    fill(ans, 0);\n\n    foreach (i; 0..N-1) {\n        auto s = readln.split.map!(x => x.to!int - 1);\n        adj[s[0]] ~= s[1];\n        adj[s[1]] ~= s[0];\n    }\n\n    dfs(0, -1);\n    dfs2(0, -1);\n\n    foreach (i; 0..N) writefln(\"%.9f\", ans[i]);\n}\n"
  },
  {
    "language": "Bash",
    "code": "/**\n    why I'm too lazy?\n**/\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n#define pb push_back\n#define pp pop_back\n#define ll long long\n#define ld long double\n#define OK puts(\"OK\");\n#define sz(s) (int)s.size()\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\n\ninline int min(int a, int b)\n{\n    return (a > b) ? b : a;\n}\ninline int max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nconst int N = 2e5 + 10;\nconst int inf = 1e9 + 7;\nconst ll linf = 1e17 + 7;\n\nint n, x, y;\nvector <int> g[N];\n\ndouble dfs(int v, int p, double d)\n{\n    double ans = 0;\n    for(auto to : g[v])\n    {\n        if(to == p) continue;\n        if(v == p)\n            ans += dfs(to, v, 1.0 / sz(g[v]) * d);\n        else\n            ans += dfs(to, v, 1.0 / (sz(g[v]) - 1) * d);\n    }\n    return ans + d;\n}\n\nmain()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++)\n        scanf(\"%d%d\", &x, &y), g[x].pb(y), g[y].pb(x);\n    for(int i = 1 ; i <= n; i++)\n        cout << fixed << setprecision(17) << dfs(i, i, 1.0) - 1.0 << endl;\n}\n"
  },
  {
    "language": "Bash",
    "code": "/**\n    why I'm too lazy?\n**/\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n#define pb push_back\n#define pp pop_back\n#define ll long long\n#define ld long double\n#define OK puts(\"OK\");\n#define sz(s) (int)s.size()\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\n\ninline int min(int a, int b)\n{\n    return (a > b) ? b : a;\n}\ninline int max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nconst int N = 2e5 + 10;\nconst int inf = 1e9 + 7;\nconst ll linf = 1e17 + 7;\n\nint n, x, y;\nvector <int> g[1005];\n\ndouble dfs(int v, int p, double d)\n{\n    double ans = 0;\n    for(auto to : g[v])\n    {\n        if(to == p) continue;\n        if(v == p)\n            ans += dfs(to, v, 1.0 / sz(g[v]) * d);\n        else\n            ans += dfs(to, v, 1.0 / (sz(g[v]) - 1) * d);\n    }\n    return ans + d;\n}\n\nmain()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; i++)\n        scanf(\"%d%d\", &x, &y), g[x].pb(y), g[y].pb(x);\n    for(int i = 1 ; i <= n; i++)\n        cout << fixed << setprecision(17) << dfs(i, i, 1.0) - 1.0 << endl;\n}\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false\n  result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) > int(' '):\n      get = true\n      result.add(c)\n    else:\n      if get: break\n      get = false\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate infty(T): untyped = ((T(1) shl T(sizeof(T)*8-2)) - 1)\n#}}}\n\n#{{{ ReRooting\nimport sequtils, future\ntype\n  Node[Data] = object\n    to, rev: int\n    data: Data\n  ReRooting[Data, T] = object\n    g:seq[seq[Node[Data]]]\n    ldp, rdp: seq[seq[T]]\n    lptr, rptr: seq[int]\n    ident: T\n    f_up: (T,Data)->T\n    f_merge: (T,T)->T\n\nproc initNode[Data](to, rev:int, d: Data):Node[Data] = Node[Data](to: to, rev: rev, data: d)\nproc initReRooting[Data, T](n:int, f_up:(T,Data)->T, f_merge:(T,T)->T, ident:T):ReRooting[Data,T] =\n  return ReRooting[Data,T](\n    g:newSeqWith(n, newSeq[Node[Data]]()),\n    ldp:newSeqWith(n, newSeq[T]()),\n    rdp:newSeqWith(n, newSeq[T]()),\n    lptr:newSeq[int](n), rptr:newSeq[int](n),\n    f_up:f_up, f_merge:f_merge, ident:ident)\n\nproc addEdge[Data, T](self: var ReRooting[Data, T]; u,v:int, d:Data) =\n  self.g[u].add(initNode[Data](v, self.g[v].len, d))\n  self.g[v].add(initNode[Data](u, self.g[u].len - 1, d))\nproc addEdgeBi[Data, T](self: var ReRooting[Data, T]; u,v:int, d,e:Data) =\n  self.g[u].add(initNode[Data](v, self.g[v].len, d))\n  self.g[v].add(initNode[Data](u, self.g[u].len - 1, e))\nproc dfs[Data, T](self: var ReRooting[Data, T], idx, par:int):T =\n  while self.lptr[idx] != par and self.lptr[idx] < self.g[idx].len:\n    var e = self.g[idx][self.lptr[idx]].addr\n    self.ldp[idx][self.lptr[idx] + 1] = self.f_merge(self.ldp[idx][self.lptr[idx]], self.f_up(self.dfs(e[].to, e[].rev), e[].data))\n    self.lptr[idx] += 1\n  while self.rptr[idx] != par and self.rptr[idx] >= 0:\n    var e = self.g[idx][self.rptr[idx]].addr\n    self.rdp[idx][self.rptr[idx]] = self.f_merge(self.rdp[idx][self.rptr[idx] + 1], self.f_up(self.dfs(e[].to, e[].rev), e[].data))\n    self.rptr[idx] -= 1\n  if par < 0: return self.rdp[idx][0]\n  return self.f_merge(self.ldp[idx][par], self.rdp[idx][par + 1])\n\nproc solve[Data, T](self: var ReRooting[Data, T]):seq[T] =\n  for i in 0..<self.g.len:\n    self.ldp[i] = newSeqWith(self.g[i].len + 1, self.ident)\n    self.rdp[i] = newSeqWith(self.g[i].len + 1, self.ident)\n    self.lptr[i] = 0\n    self.rptr[i] = self.g[i].len - 1\n  result = newSeq[T]()\n  for i in 0..<self.g.len: result.add(self.dfs(i, -1))\n#}}}\n\nproc main():void =\n  proc f_up(a:(float,int), data: int):(float, int) =\n    result = ((if a[1] == 0: 0.0 else: a[0] / float(a[1])) + 1.0, 1)\n  proc f_merge(a,b:(float,int)):(float, int) =\n    result = (a[0] + b[0], a[1] + b[1])\n  let N = nextInt()\n  var g = initReRooting[int, (float, int)](N, f_up, f_merge, (0.0, 0))\n  for i in 0..<N-1:\n    let u, v = nextInt() - 1\n    g.addEdge(u, v, 0)\n  let dp = g.solve()\n  for p in dp:\n    echo if p[1] == 0: 0.0 else: p[0]/float(p[1])\n  discard\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(i)*[identify] for i in edges]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ninpPh = 1\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nline = []\nfor n in range(N - 1):\n\ta,b = map(int,input().split())\n\ta = a - 1\n\tb = b - 1\n\tline.append((a,b))\nglaf = [[0] * N for i in range(N)]\nkitaiti = [[0] * N for i in range(N)]\nfor l in line:\n\ta = l[0]\n\tb = l[1]\n\tglaf[a][b] = 1\n\tglaf[b][a] = 1\ndef K(p,cp):\n\teda = 0\n\tc = 0\n\tfor i in range(N):\n\t\tif glaf[p][i] == 1 and i != cp:\n\t\t\teda = eda + 1\n\t\t\tif kitaiti[p][i] == 0:\n\t\t\t\tc = c + K(i,p) + 1\n\t\t\telse:\n\t\t\t\tc = c + kitaiti[p][i] + 1\n\tif eda == 0:\n\t\treturn 0\n\tc = c / eda\n\tkitaiti[cp][p] = c\n\treturn c\n\t\n'''\nfor m in range(N):\n\tif sum(glaf[m]) > 2:\n\t\tfor mi,m2 in enumerate(glaf[m]):\n\t\t\tif m2 == 1:\n\t\t\t\tK(mi,m)\n'''\nfor m in range(N):\n\tans = 0\n\te = 0\n\tfor i,mj in enumerate(glaf[m]):\n\t\tif mj == 1:\n\t\t\te = e + 1\n\t\t\tans = ans + K(i,m) + 1\n\tprint(ans / e)"
  },
  {
    "language": "Python",
    "code": "def ReRooting(n, e, identify):\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for u, v in e:\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  for i in dp:print(i)\nn=int(input())\nedges=[]*n\nfor _ in range(n-1):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  edges.append([a,b])\nReRooting(n,edges,0)"
  },
  {
    "language": "Python",
    "code": "class ReRooting(object):\n    \"\"\" 全方位木DP \"\"\"\n    def processing(self, in_:list, v:int):\n        \"\"\"\n        単項演算(加工) f \n        \n        v: 頂点\n        \"\"\"\n        res = in_[0] + 1\n        cnt = 1\n        return [res, cnt]\n    \n    def merge(self, in1:list, in2:list):\n        \"\"\" 二項演算(マージ) ・ \"\"\"\n        res = in1[0] + in2[0]\n        cnt = in1[1] + in2[1]\n        return [res, cnt]\n\n    def adjustment(self, in_:list, v:int):\n        \"\"\"\n        単項演算(調整) g\n        \n        v: 頂点\n        \"\"\"\n        res = 0 if (in_[1] == 0) else in_[0] / in_[1]\n        cnt = in_[1]\n        return  [res, cnt]\n    \n    def solve(self):\n        \"\"\"\n        計算結果を返す\n        \n        Ex. [cnt for cnt, _ in self.calc()]\n        \"\"\"\n        return [res for res,_ in self.calc()]\n\n    def __init__(self, V:int, e:list):\n        \"\"\"\n        V: 頂点数\n        e: 単位元\n        \"\"\"\n        self.V, self.e = V, e\n        self.edge = [[] for _ in range(V)]\n        self.par = [-1] * V\n        self.order = []\n    \n    def add_edge(self, u:int, v:int):\n        \"\"\" 辺(u,v)をグラフに追加する \"\"\"\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    \n    def topological_sort(self, root:int = 0):\n        \"\"\" トポロジカルソート \"\"\"\n        from collections import deque\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            self.order.append(v)\n            for w in self.edge[v]:\n                if w != self.par[v]:\n                    self.par[w] = v\n                    self.edge[w].remove(v)\n                    que.append(w)\n    \n    def bottom_up(self):\n        \"\"\" Bottom-Up DP \"\"\"\n        accBU = [self.e for _ in range(self.V)]\n        resBU = [None] * self.V\n        for v in reversed(self.order):\n            for c in self.edge[v]:\n                accBU[v] = self.merge(accBU[v], self.processing(resBU[c], c))\n            resBU[v] = self.adjustment(accBU[v], v)\n        return accBU, resBU\n    \n    def top_down(self, resBU:list):\n        \"\"\" Top-Down DP \"\"\"\n        accTD = [self.e for _ in range(self.V)]\n        resTD = [self.e for _ in range(self.V)]\n\n        for p in self.order:\n            ac = self.e if (p == self.order[0]) else self.processing(resTD[p], p)\n            for v in self.edge[p]:\n                accTD[v] = ac[:]\n                ac = self.merge(ac, self.processing(resBU[v], v))\n            \n            ac = self.e\n            for v in reversed(self.edge[p]):\n                accTD[v] = self.merge(accTD[v], ac)\n                resTD[v] = self.adjustment(accTD[v], v)\n                ac = self.merge(ac, self.processing(resBU[v], v))\n        return resTD\n    \n    def calc(self):\n        \"\"\" 計算結果を返す \"\"\"\n        self.topological_sort()\n        accBU, resBU = self.bottom_up()\n        resTD = self.top_down(resBU)\n\n        res = [None] * self.V\n        for v in self.order:\n            res[v] = self.e if (v == self.order[0]) else self.processing(resTD[v], v)\n            res[v] = self.merge(accBU[v], res[v])\n            res[v] = self.adjustment(res[v], v)\n        return res\n\n##############################################\nN = int(input())\n\nRR = ReRooting(N, [0, 0])\n\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    RR.add_edge(u - 1, v - 1)\n\nprint(*RR.solve(), sep=\"\\n\")"
  },
  {
    "language": "Python",
    "code": "def ReRooting(n, e, identify):\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for u, v in e:\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  def merge1(a, b):\n    return a+b\n  def addnode1(a, id):\n    if id == 0:\n      return a/len(edges[id])+1\n    elif len(edges[id])==1:\n      return 1\n    else:\n      return a/(len(edges[id])-1)+1\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans = merge1(ans, subdp[node][j])\n    subdp[parent][indexedges[node][indexparent]] = addnode1(ans, node)\n  def merge2(a,b):\n    return a+b\n  def addnode2(a, id, flag):\n    if flag:return a/len(edges[id])\n    if len(edges[id])==1:return a+1\n    return a/(len(edges[id])-1)+1\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = merge2(b[i], subdp[node][i])\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = merge2(bb, b[i])\n      subdp[edges[node][i]][indexedges[node][i]] = addnode2(ans, node, 0)\n      bb = merge2(bb, subdp[node][i])\n    dp[node] = addnode2(bb, node, 1)\n  return dp\nn=int(input())\nedges=[]*n\nfor _ in range(n-1):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  edges.append([a,b])\nfor i in ReRooting(n,edges,0):print(i)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nline = []\nfor n in range(N - 1):\n\ta,b = map(int,input().split())\n\ta = a - 1\n\tb = b - 1\n\tline.append((a,b))\nglaf = [[0] * N for i in range(N)]\nkitaiti = [[0] * N for i in range(N)]\nfor l in line:\n\ta = l[0]\n\tb = l[1]\n\tglaf[a][b] = 1\n\tglaf[b][a] = 1\ndef K(p,cp):\n\teda = 0\n\tc = 0\n\tfor i in range(N):\n\t\tif glaf[p][i] == 1 and i != cp:\n\t\t\teda = eda + 1\n\t\t\tif kitaiti[p][i] == 0:\n\t\t\t\tc = c + K(i,p) + 1\n\t\t\telse:\n\t\t\t\tc = c + kitaiti[p][i] + 1\n\tif eda == 0:\n\t\treturn 0\n\tc = c / eda\n\tkitaiti[cp][p] = c\n\treturn c\n\t\n\t\nfor m in range(N):\n\tif sum(glaf[m]) > 2:\n\t\tfor mi,m2 in enumerate(glaf[m]):\n\t\t\tif m2 == 1:\n\t\t\t\tK(mi,m)\nfor m in range(N):\n\tans = 0\n\te = 0\n\tfor i,mj in enumerate(glaf[m]):\n\t\tif mj == 1:\n\t\t\te = e + 1\n\t\t\tans = ans + K(i,m) + 1\n\tprint(ans / e)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nm = map(int,read().split())\nUV = zip(m,m)\n\nif N == 1:\n    print(0)\n    exit()\n\ngraph = [[] for _ in range(N+1)]\nfor u,v in UV:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndeg = [len(x) for x in graph]\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nparent,order\n\n# dp1：その頂点に上から辿り着いてきたとする。残り回数期待値\ndp1 = [0.0]*(N+1)\nfor v in order[::-1]:\n    d = deg[v]\n    if v != root and d == 1:\n        continue\n    x = sum(dp1[c] for c in graph[v])\n    if v == root:\n        dp1[v] = x/deg[v] + 1\n    else:\n        dp1[v] = x/(deg[v]-1) + 1\n\n# dp2：その頂点から上に進んだとする。残り回数期待値。上移動を含まない。\ndp2 = [0.0] * (N+1)\nfor v in order:\n    d = deg[v]\n    n_child = d if v == root else d-1\n    S = dp1[v] * n_child # 子に進んだ場合の値の総和\n    if v != root:\n        S += dp2[v]+1# あらゆる移動の値の総和\n    for c in graph[v]:\n        if c == parent[v]:\n            continue\n        if d == 1:\n            dp2[c] = 0\n        else:\n            dp2[c] = (S-dp1[c]-1) / (d-1)\n\nanswer = []\nfor v in range(1,N+1):\n    d = deg[v]\n    n_child = d if v == root else d-1\n    S = dp1[v] * n_child\n    if v != root:\n        S += dp2[v]+1# あらゆる移動の値の総和\n    answer.append(S/d)\n\nprint('\\n'.join(map(str,answer)))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    fl = defaultdict(lambda : 0)\n    fr = defaultdict(lambda : 0)\n\n    def dfs(x):\n        sx = s[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y]:continue\n            sy,ey = s[y],e[y]\n            if nsx:\n                nex = ((ex-1)*sx-ey)/nsx+1\n            else:\n                nex = 1\n            nsy = sy+1\n            ney = ((ey-1)*sy+nex)/nsy+1\n            ans[y] = ney\n            s[x] = nsx\n            e[x] = nex\n            s[y] = nsy\n            e[y] = ney\n            dfs(y)\n            s[x] = sx\n            e[x] = ex\n            s[y] = sy\n            e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [0]*n\n    ans[0] = e[0]\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    q.append((0,s[0],e[0]))\n    while q:\n        x,sx,ex = q.pop()\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                q.append((y,nsy,ney))\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = deque([0])\nT = []\nwhile Q:\n    i = deque.popleft(Q)\n    T.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nBU = [0] * N # Bottom Up\nTD = [1] * N # Top Down\nfor i in T[::-1]:\n    if len(X[i]) == 0:\n        BU[i] = 0\n        continue\n    s = 0\n    for j in X[i]:\n        s += BU[j]\n    BU[i] = s / len(X[i]) + 1\n\nfor i in T:\n    if i == 0:\n        for j in X[i]:\n            TD[j] = 2 + ((BU[i]-1) * len(X[i]) - BU[j]) / (len(X[i]) - 1) if len(X[i]) > 1 else 1\n    else:\n        for j in X[i]:\n            TD[j] = BU[i] + (TD[i] - BU[j] - 1) / len(X[i]) + 1\n\nfor i in range(N):\n    print((len(X[i]) * BU[i] + TD[i]) / (len(X[i]) + 1) if i else BU[i])"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, edge):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - 1].append(e[1] - 1)\n            self.tree[e[1] - 1].append(e[0] - 1)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        self.order = []\n        self.order.append(root)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node] + 1\n                    self.order.append(adj)\n                    stack.append(adj)\n\n    def rerooting(self, func, merge, ti, ei):\n        dp = [ti for _ in range(self.n)]\n        lt = [ei for _ in range(self.n)]\n        rt = [ei for _ in range(self.n)]\n        inv = [ei for _ in range(self.n)]\n        self.setroot(0)\n        for node in self.order[::-1]:\n            if len(self.tree[node]) == 1 and node != 0:\n                continue\n            tmp = ti\n            for adj in self.tree[node]:\n                if self.parent[adj] == node:\n                    lt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            tmp = ti\n            for adj in self.tree[node][::-1]:\n                if self.parent[adj] == node:\n                    rt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            dp[node] = tmp / (len(self.tree[node]) - 1) if node != 0 else tmp / len(self.tree[node])\n        for node in self.order:\n            if node == 0:\n                continue\n            merged = merge(lt[node], rt[node])\n            par = self.parent[node]\n            inv[node] = func(merged, inv[par]) / (len(self.tree[par]) - 1) if len(self.tree[par]) != 1 else 0\n            dp[node] = func(dp[node] * (len(self.tree[node]) - 1), inv[node]) / len(self.tree[node])\n        return dp\n'''\n    def rerooting(self, func, merge, ti, ei):\n        dp = [ti for _ in range(self.n)]\n        lt = [ei for _ in range(self.n)]\n        rt = [ei for _ in range(self.n)]\n        inv = [ei for _ in range(self.n)]\n        self.setroot(0)\n        for node in self.order[::-1]:\n            tmp = ti\n            for adj in self.tree[node]:\n                if self.parent[adj] == node:\n                    lt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            tmp = ti\n            for adj in self.tree[node][::-1]:\n                if self.parent[adj] == node:\n                    rt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            dp[node] = tmp\n        for node in self.order:\n            if node == 0:\n                continue\n            merged = merge(lt[node], rt[node])\n            par = self.parent[node]\n            inv[node] = func(merged, inv[par])\n            dp[node] = func(dp[node], inv[node])\n        return dp\n'''\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nE = [tuple(map(int,input().split())) for _ in range(N - 1)]\n\nT = Tree(N, E)\n\nti = 0.0\nei = -1.0\nfunc = lambda x, y: x + y + 1.0\nmerge = lambda x, y: x + y\n\nD = T.rerooting(func, merge, ti, ei)\n\nres = []\n\nfor i in range(N):\n    res.append(D[i])\n\nprint('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x,sx,ex):\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                dfs(y,nsy,ney)\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    dfs(0,s[0],e[0])\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x,sx,ex):\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                dfs(y,nsy,ney)\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = deque([0])\n    q2 = deque([])\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.popleft()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    dfs(0,s[0],e[0])\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n#https://atcoder.jp/contests/s8pc-4/tasks/s8pc_4_d?lang=ja\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n4\n1 2\n2 4\n4 3\n'''[1:]\n\ninput3 ='''\n4\n2 1\n2 4\n4 3\n'''[1:]\n\n\n\ndef file_intake():\n    try:\n        f = open('in32.txt')\n    except:\n        return None\n    nl ='''\n    '''\n    ret = ''.join( f.readlines()  )\n    f.close()\n    return ret\n\ninput1a = file_intake()\n\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n2.0\n1.0\n2.0\n2.0\n\n3.0\n1.5\n3.0\n1.5\n'''\n\ninputXs = [input1, input2, input3, None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except: \n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\n\n\ndef reroot(root0,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n    \n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v, noe_vwise\n        \n        ret_return = e_init\n        ret_return = None\n        stack = [(v, v_par, 0, e_init)]\n        while stack:\n            (v, v_par, i, ret_onloop ) = stack.pop()\n            \n            if ( i == len(es_vwise[v]) ):\n                ret_return = ret_onloop\n                continue\n            \n            e_local = es_vwise[v][i]\n            if ( e_local[0] == v_par):\n                print('v_par, not-to-see?')\n                vpar_v[v] = i\n                stack.append((v, v_par, i+1, ret_onloop))\n                continue\n            \n            if ret_return is None:\n                stack.append( (v, v_par, i, ret_onloop) )\n                stack.append( (e_local[0], v, 0, e_init) )\n                continue\n            \n            elif ret_return is not None:\n                dp_es_vwise[v][i] = lift(ret_return, e_local[1])\n                ret_return = None\n                ret_onloop = merge(ret_onloop, dp_es_vwise[v][i])\n                \n                stack.append((v, v_par, i+1, ret_onloop ) )\n        \n        return ret_return\n\n    def dfs2(v, t):\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init, noe_vwise\n        nonlocal pe_vwise\n        \n        stack = [(v,t,None,None,None,-INF)]\n        \n        while (stack):\n            v,t, dpl, dpr, i, imax = stack.pop()\n            \n            if (vpar_v[v] is not None):\n                dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n                \n            if ( i == None):                 \n                l = len(es_vwise[v])\n                dpl = [e_init for i in range(l+1) ]\n                dpr = [e_init for i in range(l+1) ]\n                \n                if (pe_vwise[v] is not None):\n                    v0, v1, w = pe_vwise[v]            \n                    dpr[l] = lift(t,w)                    \n                \n                \n                for i in range(l):\n                    dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n                for i in range(l-1,-1,-1):\n                    dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n                    #l: 0->1, l-1->l\n                    #r: l->l-1, 1->0\n                stack.append((v, t, dpl, dpr, 0, l-1))\n                ans[v] = dpr[0]\n            else:\n                if (imax < i):\n                    continue\n                if ( i == vpar_v[v]):\n                    stack.append((v, t, dpl, dpr, i+1, imax ))\n                    continue\n                u = es_vwise[v][i][0]\n                stack.append((v, t, dpl, dpr, i+1, imax  ))\n                stack.append((u, merge(dpl[i], dpr[i+1]), None, None, None, -INF ))\n                \n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return ((a[0] + b[0], a[1]+b[1]) )\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n    \n    ans = [Edge(0,0) for i in range(nov)]\n    \n\n    dfs1(root0,None)   #print(ans)\n\n    \n    dfs2(root0,None)\n    \n    for i in range(n):\n        #print(f\"i:{i}\",ans[i])\n        pass\n    \n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n        #print((ans[i][0] , ans[i][1]))\n    \n    return ans\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n    #print('arg:',n,st_list)\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            #print('s,t',s,t)\n            st_list1.append((s,t))\n    return vmin,st_list1\n    \n\n\ndef main():\n    \n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    vmin, st_list1 = virtual_undirected(n,st_list)\n    st_list2 = st_list1 \n    #st_list2 = st_list\n    #print(vmin, st_list1 )\n    \n    for st in st_list2:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n    reroot(vmin,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "\ndef resolve():\n    def dfs1(topo, par):\n        for idx in reversed(topo):\n            ret = 0\n            child = 0\n            for to in G[idx]:\n                if to == par[idx]:\n                    continue\n                ret += EV[to] + 1.0\n                child += 1\n            #EV[idx] = 0\n            if child >= 1:\n                EV[idx] += ret / child\n\n\n    def dfs2(idx, d_par, par):\n        stack = [(idx, d_par, par)]\n        while stack:\n            idx, d_par, par = stack.pop()\n            ret = 0\n            for to in G[idx]:\n                if to == par:\n                    ret += d_par + 1.0\n                else:\n                    ret += EV[to] + 1.0\n            ans[idx] = ret / len(G[idx])\n            for to in G[idx]:\n                if to == par:\n                    continue\n                max_l = max(1, len(G[idx]) - 1)\n                nx_d_par = (ret - EV[to] - 1.0) / max_l\n                stack.append((to, nx_d_par, idx))\n\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G[b].append(a)\n\n    topo = []\n    P = [-1] * N\n    node = [0]\n    while node:\n        v = node.pop()\n        topo.append(v)\n        for to in G[v]:\n            if to == P[v]:\n                continue\n            P[to] = v\n            node.append(to)\n\n    EV = [0] * N\n    ans = [0] * N\n    dfs1(topo, P)\n    dfs2(0, 0, -1)\n    for i in range(N):\n        print(ans[i])\n\nif __name__ == \"__main__\":\n    resolve()"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  def ReRooting(n, e, identify):\n    edges = [[] for _ in range(n)]\n    indexedges = [[] for _ in range(n)]\n    for u, v in e:\n      indexedges[v].append(len(edges[u]))\n      indexedges[u].append(len(edges[v]))\n      edges[u].append(v)\n      edges[v].append(u)\n    dp = [identify]*n\n    subdp = [len(edges[i])*[identify] for i in range(n)]\n    parents = [-1]*n\n    order = [0]\n    for node in order:\n      for mode in edges[node]:\n        if mode == parents[node]:\n          continue\n        order.append(mode)\n        parents[mode] = node\n    for node in order[1::][::-1]:\n      parent = parents[node]\n      ans = identify\n      indexparent = -1\n      for j in range(len(edges[node])):\n        mode = edges[node][j]\n        if parent == mode:\n          indexparent = j\n          continue\n        ans += subdp[node][j]\n      if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n      else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n    for node in order:\n      b = [identify]*len(edges[node])\n      for i in range(len(edges[node])-1,0,-1):\n        b[i-1] = b[i]+subdp[node][i]\n      bb = identify\n      for i in range(len(edges[node])):\n        ans = bb+b[i]\n        if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n        else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n        bb += subdp[node][i]\n      dp[node]=bb/len(edges[node])\n    print(*dp)\n  n=int(input())\n  edges=[]*n\n  for _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    edges.append([a,b])\n  ReRooting(n,edges,0)\nif __name__ == \"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x):\n        sx = s[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                s[x] = nsx\n                e[x] = nex\n                s[y] = nsy\n                e[y] = ney\n                dfs(y)\n                s[x] = sx\n                e[x] = ex\n                s[y] = sy\n                e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = deque([0])\n    q2 = deque([])\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.popleft()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x):\n        sx = s[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                s[x] = nsx\n                e[x] = nex\n                s[y] = nsy\n                e[y] = ney\n                dfs(y)\n                s[x] = sx\n                e[x] = ex\n                s[y] = sy\n                e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n\n    connect = [len(g) for g in G]\n\n    #根を0として木を構築\n    root = 0\n    stack = [root]\n    order = []\n    lst = [0] * N\n    while len(stack) != 0:\n        tmp = stack.pop()\n        order.append(tmp)\n        for to in G[tmp]:\n            if to == lst[tmp]:\n                continue\n            lst[to] = tmp\n            stack.append(to)\n        \n    dp1 = [0] * N\n    for v in order[::-1]:\n        d = connect[v]\n        if v != root and d == 1:\n            continue\n        x = sum(dp1[c] for c in G[v])\n        if v == root:\n            dp1[v] = x/connect[v] + 1\n        else:\n            dp1[v] = x/(connect[v] - 1) + 1\n\n    dp2 = [0] * N\n    for v in order:\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        for c in G[v]:\n            if c == lst[v]:\n                continue\n            if d == 1:\n                dp2[c] = 0\n            else:\n                dp2[c] = (S - dp1[c] - 1)/(d - 1)\n\n    ans = []\n    for v in range(N):\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        ans.append(S/d)\n\n    print (*ans, sep = '\\n')\n\n    # print (dp1)\n    # print (dp2)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  n=int(input())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for _ in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  n=int(input())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for _ in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e_init\n        #ret = Edge(-INF,-INF)\n\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    #print('1->2',dp_es_vwise)\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            st_list1.append((s,t))\n    return st_list1\n\n\n\ndef main():\n\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    \n    st_list1 = virtual_undirected(n,st_list)\n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    \"\"\"ここから変更\"\"\"\n\n    # op: 普通に根を固定した木DPで子の情報を親に集めるときの演算\n    def op(a, b):\n        return a+b+1.\n\n    # cum_merge: 累積opどうしをマージするときの演算\n    def cum_merge(a, b):\n        return a+b\n\n    # たん位元(cum_merge(x, ident) = x)(「たん」を漢字にするとこどふぉでCEになる(なぜ？))\n    ident_cum_merge = 0.\n\n    # DP配列の初期化(opと合わせてうまく答えが求まるようにする)\n    dp = [0.] * (N+1)\n    from_par = [-1.] * (N+1)\n    \"\"\"ここまで変更\"\"\"\n\n    # root=1でまず普通に木DPをする\n    # 並行して各頂点につき、子の値の累積opを左右から求めておく\n    # その後根から順番に、親からの寄与を求めていく(from_par)\n    def Rerooting(adj):\n        N = len(adj) - 1\n        st = [1]\n        seen = [0] * (N + 1)\n        seen[1] = 1\n        par = [0] * (N + 1)\n        child = [[] for _ in range(N + 1)]\n        seq = []\n        while st:\n            v = st.pop()\n            seq.append(v)\n            for u in adj[v]:\n                if not seen[u]:\n                    seen[u] = 1\n                    par[u] = v\n                    child[v].append(u)\n                    st.append(u)\n        seq.reverse()\n        left = [ident_cum_merge] * (N + 1)\n        right = [ident_cum_merge] * (N + 1)\n        for v in seq:\n            L = len(child[v])\n            if L:\n                tmp = ident_cum_merge\n                for u in child[v]:\n                    left[u] = tmp\n                    tmp = op(tmp, dp[u])\n                tmp = ident_cum_merge\n                for u in reversed(child[v]):\n                    right[u] = tmp\n                    tmp = op(tmp, dp[u])\n                dp[v] = tmp / L\n\n        seq.reverse()\n        for v in seq:\n            if v == 1:\n                continue\n            if len(adj[par[v]]) > 1:\n                from_par[v] = op(cum_merge(left[v], right[v]), from_par[par[v]]) / (len(adj[par[v]]) - 1)\n            else:\n                from_par[v] = 0.\n            dp[v] = op(dp[v] * (len(adj[v]) - 1), from_par[v]) / len(adj[v])\n\n        return dp\n\n    ans = Rerooting(adj)\n    for v in range(1, N+1):\n        print(ans[v])\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        if len(edges[node])==1:\n          subdp[parent][indexedges[node][indexparent]]=1\n          break\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])!=1:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\n"
  },
  {
    "language": "Python",
    "code": "import sys,os,io\n# input = sys.stdin.readline\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nN = int(input())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\ndef dfs(start):\n  stack = [start]\n  parent = [N]*N\n  parent[start] = -1\n  while stack:\n    v = stack[-1]\n    marker = 0\n    for u in edge[v]:\n      if u==parent[v]:\n        continue\n      if parent[u]==N: #子へ降ろす\n        marker = 1\n        parent[u]=v\n        stack.append(u)\n      else: #子から吸い上げる\n        pass\n        #吸い上げる際の個々の処理\n        ans[v] += ans[u]+1\n    if marker==0:\n      stack.pop()\n      if v==start:\n        #根へ吸い上げる時のまとめ処理\n        ans[v] /= len(edge[v])\n      elif ans[v]>0:\n        ans[v] /= len(edge[v])-1\n  return\n\ndef dfs2(start):\n  stack = [start]\n  parent = [N]*N\n  parent[start] = -1\n  p_value = [0]*N\n  while stack:\n    v = stack.pop()\n    for i,u in enumerate(edge[v]):\n      if u==parent[v]:\n        continue\n      parent[u] = v\n      if len(edge[v])==1:\n        p_value[u] = 0\n      else:\n        p_value[u] = (ans[v]*len(edge[v])-(ans[u]+1))/(len(edge[v])-1)\n      ans[u] *= len(edge[u])-1\n      ans[u] += p_value[u]+1\n      ans[u] /= len(edge[u]) \n      stack.append(u)\n  return\n\nans = [0]*N\ndfs(0)\ndfs2(0)\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nN = int(input())\nX = [[] for i in range(N)]\nL = [0]*N\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n    L[x-1] += 1\n    L[y-1] += 1\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nC = Counter(P)\n##### Settings\nunit = 0\nmerge = lambda a, b: a + b\nadj_bu = lambda a, i: (a+1)/C[P[i]]\nadj_td = lambda a, i, p: ((XX[p]*L[p]-XX[i]*C[p])/max(1,L[p]-1)+1)/max(1,C[i])\nadj_fin = lambda a, i: a*max(1,C[i])/L[i]\n#####\n\nME = [unit] * N\nXX = [0] * N\nTD = [unit] * N\nfor i in R[1:][::-1]:\n    XX[i] = adj_bu(ME[i], i)\n    p = P[i]\n    ME[p] = merge(ME[p], XX[i])\nXX[R[0]] = adj_fin(ME[R[0]], R[0])\n\nfor i in R:\n    ac = TD[i]\n    for j in X[i]:\n        TD[j] = ac\n        ac = merge(ac, XX[j])\n\n    ac = unit\n    for j in reversed(X[i]):\n        TD[j] = adj_td(merge(TD[j], ac), j, i)\n        ac = merge(ac, XX[j])\n        XX[j] = adj_fin(merge(ME[j], TD[j]), j)\n\nprint(*XX, sep = \"\\n\")"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, decrement=1):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.root = None\n        self.size = [1]*n       # number of nodes in subtree\n        self.decrement = decrement\n\n    def add_edge(self, u, v):\n        u, v = u-self.decrement, v-self.decrement\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def add_edges(self, edges):\n        for u, v in edges:\n            u, v = u-self.decrement, v-self.decrement\n            self.edges[u].append(v)\n            self.edges[v].append(u)\n\n    def set_root(self, root):\n        root -= self.decrement\n        self.depth = [-1]*self.n\n        self.root = root\n        self.par = [-1]*self.n\n        self.depth[root] = 0\n        self.order = [root]\n        next_set = [root]\n        while next_set:\n            p = next_set.pop()\n            for q in self.edges[p]:\n                if self.depth[q] != -1: continue\n                self.par[q] = p\n                self.depth[q] = self.depth[p]+1\n                self.order.append(q)\n                next_set.append(q)\n        for p in self.order[::-1]:\n            for q in self.edges[p]:\n                if self.par[p] == q: continue\n                self.size[p] += self.size[q]\n\n    def rerooting(self, op, merge, id):\n        # assert self.root is not None\n        dp1 = [id] * self.n\n        dp2 = [id] * self.n\n        for p in self.order[::-1]:\n            t = id\n            for q in self.edges[p]:\n                if self.par[p] == q: continue\n                dp2[q] = t\n                t = merge(t, op(dp1[q], p, q))\n            t = id\n            for q in self.edges[p][::-1]:\n                if self.par[p] == q: continue\n                dp2[q] = merge(t, dp2[q])\n                t = merge(t, op(dp1[q], p, q))\n            dp1[p] = t\n        for q in self.order[1:]:\n            pq = self.par[q]\n            dp2[q] = op(merge(dp2[q], dp2[pq]), q, pq)\n            dp1[q] = merge(dp1[q], dp2[q])\n        return dp1\n\n#########################################################################################################\nimport sys\ninput = sys.stdin.readline\n\n\n# edges = make_tree(10,show=True)\n# N = len(edges)+1\n\n# example()\n\nN = int(input())\nT = Tree(N)\nfor _ in range(N-1):\n    x, y = map(int, input().split())\n    T.add_edge(x,y)\nT.set_root(1)\n\n##########################################################\ndef op(a, p, q):\n    # define how the dp[q] is determined by children of q if setting (p, q) = (parent, child)\n    # Cation: p, q are now defined by 0-indexed\n    return a/(len(T.edges[q])-1) + 1 if a != 0 else 1\n\ndef merge(a, b):\n    # define how the O(N) info. {r in ch(q)} in op({r in ch(q)}, p, q) の {r in ch(q)} is reduced to O(1) info.\n    return a + b\n\n# identity elem. of merge\nid = 0\n##########################################################\n\ndp = T.rerooting(op, merge, id)\nres = [\"\"]*N\nfor i in range(N):\n    res[i] = str(dp[i]/len(T.edges[i]))\nprint(\"\\n\".join(res))"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  n=int(input())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for _ in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      if parent == edges[node][j]:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    l=len(edges[node])\n    b = [identify]*l\n    for i in range(l-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(l):\n      ans = bb+b[i]\n      if l==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(l-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/l\n  print(*dp)\nif __name__ == \"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.buffer.readline().split()]\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x):\n        sx = s[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y] is None:\n                sy,ey = s[y],e[y]\n                nex = ((ex-1)*sx-ey)/nsx+1 if nsx else 1\n                nsy = sy+1\n                ans[y] = ney = ((ey-1)*sy+nex)/nsy+1\n                s[x] = nsx\n                e[x] = nex\n                s[y] = nsy\n                e[y] = ney\n                dfs(y)\n                s[x] = sx\n                e[x] = ex\n                s[y] = sy\n                e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [None]*n\n    ans[0] = e[0]\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nm = map(int,read().split())\nUV = zip(m,m)\n\nif N == 1:\n    print(0)\n    exit()\n\ngraph = [[] for _ in range(N+1)]\nfor u,v in UV:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndeg = [len(x) for x in graph]\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nparent,order\n\n# dp1：その頂点に上から辿り着いてきたとする。残り回数期待値\ndp1 = [0.0]*(N+1)\nfor v in order[::-1]:\n    d = deg[v]\n    if v != root and d == 1:\n        continue\n    x = sum(dp1[c] for c in graph[v])\n    if v == root:\n        dp1[v] = x/deg[v] + 1\n    else:\n        dp1[v] = x/(deg[v]-1) + 1\n\n# dp2：その頂点から上に進んだとする。残り回数期待値。上移動を含まない。\ndp2 = [0.0] * (N+1)\nfor v in order:\n    d = deg[v]\n    n_child = d if v == root else d-1\n    S = dp1[v] * n_child # 子に進んだ場合の値の総和\n    if v != root:\n        S += dp2[v]+1# あらゆる移動の値の総和\n    for c in graph[v]:\n        if c == parent[v]:\n            continue\n        if d == 1:\n            dp2[c] = 0\n        else:\n            dp2[c] = (S-dp1[c]-1) / (d-1)\n\nanswer = []\nfor v in range(1,N+1):\n    d = deg[v]\n    n_child = d if v == root else d-1\n    S = dp1[v] * n_child\n    if v != root:\n        S += dp2[v]+1# あらゆる移動の値の総和\n    answer.append(S/d)\n\nprint('\\n'.join(map(str,answer)))\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for i in range(n-1,0,-1):\n    node = order[i]\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x):\n        sx = s[x]\n        fx = f[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y]:continue\n            sy,fy,ey = s[y],f[y],e[y]\n            nfx = fx-e[y]\n            nex = nfx/nsx+1 if nsx else 1\n            nsy = sy+1\n            nfy = fy+nex\n            ney = nfy/nsy+1\n            ans[y] = ney\n            s[x] = nsx\n            f[x] = nfx\n            e[x] = nex\n            s[y] = nsy\n            f[y] = nfy\n            e[y] = ney\n            dfs(y)\n            s[x] = sx\n            f[x] = fx\n            e[x] = ex\n            s[y] = sy\n            f[y] = fy\n            e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    f = [0]*n\n    e = [1]*n\n    bfs = [0]*n\n    bfs[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not bfs[y]:\n                bfs[y] = 1\n                s[x] += 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[y] = f[y]/s[y]+1 if s[y] else 1\n        f[x] += e[y]\n    ans = [0]*n\n    ans[0] = e[0] = f[0]/s[0]+1\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  def ReRooting(n, e, identify):\n    edges = [[] for _ in range(n)]\n    indexedges = [[] for _ in range(n)]\n    for u, v in e:\n      indexedges[v].append(len(edges[u]))\n      indexedges[u].append(len(edges[v]))\n      edges[u].append(v)\n      edges[v].append(u)\n    dp = [identify]*n\n    subdp = [len(edges[i])*[identify] for i in range(n)]\n    parents = [-1]*n\n    order = [0]\n    for node in order:\n      for mode in edges[node]:\n        if mode == parents[node]:\n          continue\n        order.append(mode)\n        parents[mode] = node\n    def merge1(a, b):\n      return a+b\n    def addnode1(a, id):\n      if id == 0:\n        return a/len(edges[id])+1\n      elif len(edges[id])==1:\n        return 1\n      else:\n        return a/(len(edges[id])-1)+1\n    for node in order[1::][::-1]:\n      parent = parents[node]\n      ans = identify\n      indexparent = -1\n      for j in range(len(edges[node])):\n        mode = edges[node][j]\n        if parent == mode:\n          indexparent = j\n          continue\n        ans = merge1(ans, subdp[node][j])\n      subdp[parent][indexedges[node][indexparent]] = addnode1(ans, node)\n    def merge2(a,b):\n      return a+b\n    def addnode2(a, id, flag):\n      if flag:return a/len(edges[id])\n      if len(edges[id])==1:return a+1\n      return a/(len(edges[id])-1)+1\n    for node in order:\n      b = [identify]*len(edges[node])\n      for i in range(len(edges[node])-1,0,-1):\n        b[i-1] = merge2(b[i], subdp[node][i])\n      bb = identify\n      for i in range(len(edges[node])):\n        ans = merge2(bb, b[i])\n        subdp[edges[node][i]][indexedges[node][i]] = addnode2(ans, node, 0)\n        bb = merge2(bb, subdp[node][i])\n      dp[node] = addnode2(bb, node, 1)\n    return dp\n  n=int(input())\n  edges=[]*n\n  for _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    edges.append([a,b])\n  print(*ReRooting(n,edges,0))\nif __name__ == \"__main__\":\n  main()"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def dfs(x):\n        sx = s[x]\n        ex = e[x]\n        nsx = sx-1\n        for y in v[x]:\n            if ans[y]:continue\n            sy,ey = s[y],e[y]\n            if nsx:\n                nex = ((ex-1)*sx-ey)/nsx+1\n            else:\n                nex = 1\n            nsy = sy+1\n            ney = ((ey-1)*sy+nex)/nsy+1\n            ans[y] = ney\n            s[x] = nsx\n            e[x] = nex\n            s[y] = nsy\n            e[y] = ney\n            dfs(y)\n            s[x] = sx\n            e[x] = ex\n            s[y] = sy\n            e[y] = ey\n\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    q = [0]\n    q2 = []\n    s = [0]*n\n    e = [0]*n\n    e[0] = 1\n    while q:\n        x = q.pop()\n        for y in v[x]:\n            if not e[y]:\n                s[x] += 1\n                e[y] = 1\n                q.append(y)\n                q2.append((y,x))\n\n    while q2:\n        y,x = q2.pop()\n        e[x] += e[y]/s[x]\n    ans = [0]*n\n    ans[0] = e[0]\n    dfs(0)\n\n    for i in ans:\n        print(i-1)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef resolve():\n    def dfs1(idx, par):\n        ret = 0\n        child = 0\n        for to in G[idx]:\n            if to == par:\n                continue\n            dfs1(to, idx)\n            ret += EV[to] + 1.0\n            child += 1\n        EV[idx] = 0\n        if child >= 1:\n            EV[idx] += ret / child\n\n    def dfs2(idx, d_par, par):\n        ret = 0\n        for to in G[idx]:\n            if to == par:\n                ret += d_par + 1.0\n            else:\n                ret += EV[to] + 1.0\n        ans[idx] = ret / len(G[idx])\n        for to in G[idx]:\n            if to == par:\n                continue\n            max_l = max(1, len(G[idx]) - 1)\n            nx_d_par = (ret - EV[to] - 1.0) / max_l\n            dfs2(to, nx_d_par, idx)\n\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G[b].append(a)\n\n    EV = [0] * N\n    ans = [0] * N\n    dfs1(0, -1)\n    dfs2(0, 0, -1)\n    for i in range(N):\n        print(ans[i])\n\n\nif __name__ == '__main__':\n    resolve()"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, edge):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - 1].append(e[1] - 1)\n            self.tree[e[1] - 1].append(e[0] - 1)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        self.order = []\n        self.order.append(root)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node] + 1\n                    self.order.append(adj)\n                    stack.append(adj)\n\n    def rerooting(self, func, merge, ti, ei):\n        dp = [ti for _ in range(self.n)]\n        lt = [ei for _ in range(self.n)]\n        rt = [ei for _ in range(self.n)]\n        inv = [ei for _ in range(self.n)]\n        self.setroot(0)\n        for node in self.order[::-1]:\n            if len(self.tree[node]) == 1 and node != 0:\n                continue\n            tmp = ti\n            for adj in self.tree[node]:\n                if self.parent[adj] == node:\n                    lt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            tmp = ti\n            for adj in self.tree[node][::-1]:\n                if self.parent[adj] == node:\n                    rt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            dp[node] = tmp / (len(self.tree[node]) - 1) if node != 0 else tmp / len(self.tree[node])\n        for node in self.order:\n            if node == 0:\n                continue\n            merged = merge(lt[node], rt[node])\n            par = self.parent[node]\n            inv[node] = func(merged, inv[par])\n            inv[node] = inv[node] / (len(self.tree[par]) - 1) if len(self.tree[par]) != 1 else 0\n            dp[node] = func(dp[node] * (len(self.tree[node]) - 1), inv[node])\n            dp[node] /= len(self.tree[node])\n        return dp\n'''\n    def rerooting(self, func, merge, ti, ei):\n        dp = [ti for _ in range(self.n)]\n        lt = [ei for _ in range(self.n)]\n        rt = [ei for _ in range(self.n)]\n        inv = [ei for _ in range(self.n)]\n        self.setroot(0)\n        for node in self.order[::-1]:\n            tmp = ti\n            for adj in self.tree[node]:\n                if self.parent[adj] == node:\n                    lt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            tmp = ti\n            for adj in self.tree[node][::-1]:\n                if self.parent[adj] == node:\n                    rt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            dp[node] = tmp\n        for node in self.order:\n            if node == 0:\n                continue\n            merged = merge(lt[node], rt[node])\n            par = self.parent[node]\n            inv[node] = func(merged, inv[par])\n            dp[node] = func(dp[node], inv[node])\n        return dp\n'''\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nE = [tuple(map(int,input().split())) for _ in range(N - 1)]\n\nT = Tree(N, E)\n\nti = 0\nei = -1\nfunc = lambda x, y: x + y + 1\nmerge = lambda x, y: x + y\n\nD = T.rerooting(func, merge, ti, ei)\n\nres = []\n\nfor i in range(N):\n    res.append(D[i])\n\nprint('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n \n    N = int(input())\n \n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n \n    connect = [len(g) for g in G]\n \n    #根を0として木を構築\n    root = 0\n    stack = [root]\n    order = []\n    lst = [0] * N\n    while len(stack) != 0:\n        tmp = stack.pop()\n        order.append(tmp)\n        for to in G[tmp]:\n            if to == lst[tmp]:\n                continue\n            lst[to] = tmp\n            stack.append(to)\n        \n    dp1 = [0] * N\n    for v in order[::-1]:\n        d = connect[v]\n        if v != root and d == 1:\n            continue\n        x = sum(dp1[c] for c in G[v])\n        if v == root:\n            dp1[v] = x/connect[v] + 1\n        else:\n            dp1[v] = x/(connect[v] - 1) + 1\n \n    dp2 = [0] * N\n    for v in order:\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        for c in G[v]:\n            if c == lst[v]:\n                continue\n            if d == 1:\n                dp2[c] = 0\n            else:\n                dp2[c] = (S - dp1[c] - 1)/(d - 1)\n \n    ans = []\n    for v in range(N):\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        ans.append(S/d)\n \n    print (*ans, sep = '\\n')\n \n    # print (dp1)\n    # print (dp2)\n \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n#https://atcoder.jp/contests/s8pc-4/tasks/s8pc_4_d?lang=ja\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n4\n1 2\n2 4\n4 3\n'''[1:]\n\ninput3 ='''\n4\n2 1\n2 4\n4 3\n'''[1:]\n\n\n\ndef file_intake():\n    try:\n        f = open('in32.txt')\n    except:\n        return None\n    nl ='''\n    '''\n    ret = ''.join( f.readlines()  )\n    f.close()\n    return ret\n\n#input1a = file_intake()\n\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n2.0\n1.0\n2.0\n2.0\n\n3.0\n1.5\n3.0\n1.5\n'''\n\ninputXs = [input1, input2, input3, None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except: \n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\n\n\ndef reroot(root0,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n    \n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v, noe_vwise\n        \n        ret_return = e_init\n        ret_return = None\n        stack = [(v, v_par, 0, e_init)]\n        while stack:\n            (v, v_par, i, ret_onloop ) = stack.pop()\n            \n            if ( i == len(es_vwise[v]) ):\n                ret_return = ret_onloop\n                continue\n            \n            e_local = es_vwise[v][i]\n            if ( e_local[0] == v_par):\n                print('v_par, not-to-see?')\n                vpar_v[v] = i\n                stack.append((v, v_par, i+1, ret_onloop))\n                continue\n            \n            if ret_return is None:\n                stack.append( (v, v_par, i, ret_onloop) )\n                stack.append( (e_local[0], v, 0, e_init) )\n                continue\n            \n            elif ret_return is not None:\n                dp_es_vwise[v][i] = lift(ret_return, e_local[1])\n                ret_return = None\n                ret_onloop = merge(ret_onloop, dp_es_vwise[v][i])\n                \n                stack.append((v, v_par, i+1, ret_onloop ) )\n        \n        return ret_return\n\n    def dfs2(v, t):\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init, noe_vwise\n        nonlocal pe_vwise\n        \n        stack = [(v,t,None,None,None,-INF)]\n        \n        while (stack):\n            v,t, dpl, dpr, i, imax = stack.pop()\n            \n            if (vpar_v[v] is not None):\n                dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n                \n            if ( i == None):                 \n                l = len(es_vwise[v])\n                dpl = [e_init for i in range(l+1) ]\n                dpr = [e_init for i in range(l+1) ]\n                \n                if (pe_vwise[v] is not None):\n                    v0, v1, w = pe_vwise[v]            \n                    dpr[l] = lift(t,w)                    \n                \n                \n                for i in range(l):\n                    dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n                for i in range(l-1,-1,-1):\n                    dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n                    #l: 0->1, l-1->l\n                    #r: l->l-1, 1->0\n                stack.append((v, t, dpl, dpr, 0, l-1))\n                ans[v] = dpr[0]\n            else:\n                if (imax < i):\n                    continue\n                if ( i == vpar_v[v]):\n                    stack.append((v, t, dpl, dpr, i+1, imax ))\n                    continue\n                u = es_vwise[v][i][0]\n                stack.append((v, t, dpl, dpr, i+1, imax  ))\n                stack.append((u, merge(dpl[i], dpr[i+1]), None, None, None, -INF ))\n                \n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return ((a[0] + b[0], a[1]+b[1]) )\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n    \n    ans = [Edge(0,0) for i in range(nov)]\n    \n\n    dfs1(root0,None)   #print(ans)\n\n    \n    dfs2(root0,None)\n    \n    for i in range(n):\n        #print(f\"i:{i}\",ans[i])\n        pass\n    \n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n        #print((ans[i][0] , ans[i][1]))\n    \n    return ans\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n    #print('arg:',n,st_list)\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            #print('s,t',s,t)\n            st_list1.append((s,t))\n    return vmin,st_list1\n    \n\n\ndef main():\n    \n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    vmin, st_list1 = virtual_undirected(n,st_list)\n    st_list2 = st_list1 \n    #st_list2 = st_list\n    #print(vmin, st_list1 )\n    \n    for st in st_list2:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n    reroot(vmin,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nN = int(input())\ne = dd(list)\nfor _ in range(N - 1):\n  u, v = map(int, input().split())\n  e[u].append(v)\n  e[v].append(u)\n\ns = [1]\norder = []\nparent = [-1] * (N + 1)\nvis = [0] * (N + 1)\nwhile len(s):\n  x = s.pop()\n  vis[x] = 1\n  order.append(x)\n  for y in e[x]:\n    if vis[y]: continue\n    s.append(y)\n    parent[y] = x\n\ndp = [0] * (N + 1)\nesize = [0] * (N + 1)\nfor x in order[N - 1: 0: -1]: esize[parent[x]] += 1\n#print(esize)\n#print(order)\nfor x in order[N - 1: 0: -1]:\n  y = parent[x]\n  dp[y] += (dp[x] + 1) / esize[y]\n#print(dp)\nres = [0] * (N + 1)\nres[1] = dp[1]\nfor x in order[1: ]:\n  y = parent[x]\n  t = 0\n  if y != 1 or (esize[y] > 1): t = (res[y] * (esize[y] + (y != 1)) - (dp[x] + 1)) / (esize[y] - (y == 1))\n  #print(x, t)\n  res[x] = ((t + 1) / (esize[x] + 1)) + (dp[x] * esize[x] / (esize[x] + 1))\nfor r in res[1: ]: print(r)"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n \n    N = int(input())\n \n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n \n    connect = [len(g) for g in G]\n \n    #根を0として木を構築\n    root = 0\n    stack = [root]\n    order = []\n    lst = [0] * N\n    while len(stack) != 0:\n        tmp = stack.pop()\n        order.append(tmp)\n        for to in G[tmp]:\n            if to == lst[tmp]:\n                continue\n            lst[to] = tmp\n            stack.append(to)\n        \n    dp1 = [0] * N\n    for v in order[::-1]:\n        d = connect[v]\n        if v != root and d == 1:\n            continue\n        x = sum(dp1[c] for c in G[v])\n        if v == root:\n            dp1[v] = x/connect[v] + 1\n        else:\n            dp1[v] = x/(connect[v] - 1) + 1\n \n    dp2 = [0] * N\n    for v in order:\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        for c in G[v]:\n            if c == lst[v]:\n                continue\n            if d == 1:\n                dp2[c] = 0\n            else:\n                dp2[c] = (S - dp1[c] - 1)/(d - 1)\n \n    ans = []\n    for v in range(N):\n        d = connect[v]\n        n_child = d if v == root else d - 1\n        S = dp1[v] * n_child\n        if v != root:\n            S += dp2[v] + 1\n        ans.append(S/d)\n \n    print (*ans, sep = '\\n')\n \n    # print (dp1)\n    # print (dp2)\n \nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nN = int(input())\nX = [[] for i in range(N)]\nL = [0]*N\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n    L[x-1] += 1\n    L[y-1] += 1\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nC = Counter(P)\n##### Settings\nunit = 0\nmerge = lambda a, b: a + b\nadj_bu = lambda a, i: (a+1)/C[P[i]]\nadj_td = lambda a, i, p: ((XX[P[i]]*L[P[i]]-XX[i]*C[P[i]])/max(1,L[P[i]]-1)+1)/max(1,C[i])\nadj_fin = lambda a, i: a*max(1,C[i])/L[i]\n#####\n\nME = [unit] * N\nXX = [0] * N\nTD = [unit] * N\nfor i in R[1:][::-1]:\n    XX[i] = adj_bu(ME[i], i)\n    p = P[i]\n    ME[p] = merge(ME[p], XX[i])\nXX[R[0]] = adj_fin(ME[R[0]], R[0])\n\nfor i in R:\n    ac = TD[i]\n    for j in X[i]:\n        TD[j] = ac\n        ac = merge(ac, XX[j])\n\n    ac = unit\n    for j in reversed(X[i]):\n        TD[j] = adj_td(merge(TD[j], ac), j, i)\n        ac = merge(ac, XX[j])\n        XX[j] = adj_fin(merge(ME[j], TD[j]), j)\n\nprint(*XX, sep = \"\\n\")"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n4\n1 2\n2 4\n4 3\n'''[1:]\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v, noe_vwise\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init, noe_vwise\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n        #w is 1, though...\n        #return Edge(max(0,a[0]) +w, -INF)\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n    \n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]\n    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        \n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n#https://atcoder.jp/contests/s8pc-4/tasks/s8pc_4_d?lang=ja\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n4\n1 2\n2 4\n4 3\n'''[1:]\n\n\n\ndef file_intake():\n    try:\n        f = open('in32.txt')\n    except:\n        return None\n    nl ='''\n    '''\n    ret = ''.join( f.readlines()  )\n    f.close()\n    return ret\n\ninput1a = file_intake()\n\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n2.0\n1.0\n2.0\n2.0\n\n3.0\n1.5\n3.0\n1.5\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except: \n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\n\n\ndef reroot(root0,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n    \n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v, noe_vwise\n        \n        ret_return = e_init\n        ret_return = None\n        stack = [(v, v_par, 0, e_init)]\n        while stack:\n            (v, v_par, i, ret_onloop ) = stack.pop()\n            \n            if ( i == len(es_vwise[v]) ):\n                ret_return = ret_onloop\n                continue\n            \n            e_local = es_vwise[v][i]\n            if ( e_local[0] == v_par):\n                print('v_par, not-to-see?')\n                vpar_v[v] = i\n                stack.append((v, v_par, i+1, ret_onloop))\n                continue\n            \n            if ret_return is None:\n                stack.append( (v, v_par, i, ret_onloop) )\n                stack.append( (e_local[0], v, 0, e_init) )\n                continue\n            \n            elif ret_return is not None:\n                dp_es_vwise[v][i] = lift(ret_return, e_local[1])\n                ret_return = None\n                ret_onloop = merge(ret_onloop, dp_es_vwise[v][i])\n                \n                stack.append((v, v_par, i+1, ret_onloop ) )\n        \n        return ret_return\n\n    def dfs2(v, t):\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init, noe_vwise\n        nonlocal pe_vwise\n        \n        stack = [(v,t,None,None,None,-INF)]\n        \n        while (stack):\n            v,t, dpl, dpr, i, imax = stack.pop()\n            \n            if (vpar_v[v] is not None):\n                dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n                \n            if ( i == None):                 \n                l = len(es_vwise[v])\n                dpl = [e_init for i in range(l+1) ]\n                dpr = [e_init for i in range(l+1) ]\n                \n                if (pe_vwise[v] is not None):\n                    v0, v1, w = pe_vwise[v]            \n                    dpr[l] = lift(t,w)                    \n                \n                \n                for i in range(l):\n                    dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n                for i in range(l-1,-1,-1):\n                    dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n                    #l: 0->1, l-1->l\n                    #r: l->l-1, 1->0\n                stack.append((v, t, dpl, dpr, 0, l-1))\n                ans[v] = dpr[0]\n            else:\n                if (imax < i):\n                    continue\n                if ( i == vpar_v[v]):\n                    stack.append((v, t, dpl, dpr, i+1, imax ))\n                    continue\n                u = es_vwise[v][i][0]\n                stack.append((v, t, dpl, dpr, i+1, imax  ))\n                stack.append((u, merge(dpl[i], dpr[i+1]), None, None, None, -INF ))\n                \n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return ((a[0] + b[0], a[1]+b[1]) )\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n    \n    ans = [Edge(0,0) for i in range(nov)]\n    \n\n    dfs1(root0,None)   #print(ans)\n\n    \n    dfs2(root0,None)\n    \n    for i in range(n):\n        #print(f\"i:{i}\",ans[i])\n        pass\n    \n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n        #print((ans[i][0] , ans[i][1]))\n    \n    return ans\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n    #print('arg:',n,st_list)\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            #print('s,t',s,t)\n            st_list1.append((s,t))\n    return vmin,st_list1\n    \n\n\ndef main():\n    \n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    vmin, st_list1 = virtual_undirected(n,st_list)\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n    reroot(vmin,n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nN = int(input())\nX = [[] for i in range(N)]\nL = [0]*N\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n    L[x-1] += 1\n    L[y-1] += 1\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nC = Counter(P)\n##### Settings\nunit = 0\nmerge = lambda a, b: a + b\nadj_bu = lambda a, i: (a+1)/C[P[i]]\nadj_td = lambda a, i, p: ((XX[p]*L[p]-XX[i]*C[p])/max(1,L[p]-1)+1)/max(1,C[i])\nadj_fin = lambda a, i: a*max(1,C[i])/L[i]\n#####\n\nME = [unit] * N\nXX = [0] * N\nTD = [unit] * N\nfor i in R[1:][::-1]:\n    XX[i] = adj_bu(ME[i], i)\n    p = P[i]\n    ME[p] = merge(ME[p], XX[i])\nXX[R[0]] = adj_fin(ME[R[0]], R[0])\n\nfor i in R:\n    ac = unit\n    for j in reversed(X[i]):\n        TD[j] = adj_td(merge(TD[j], ac), j, i)\n        ac = merge(ac, XX[j])\n        XX[j] = adj_fin(merge(ME[j], TD[j]), j)\n\nprint(*XX, sep = \"\\n\")"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n    else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput3 ='''\n4\n2 1\n2 3\n2 4\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2, input3, None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(root0, n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e_init\n        #ret = Edge(-INF,-INF)\n\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n\n    dfs1(root0,None)   \n    #0 must be root?\n\n    dfs2(root0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n    #print('arg:',n,st_list)\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            #print('s,t',s,t)\n            st_list1.append((s,t))\n    return vmin,st_list1\n\n\n\ndef main():\n\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    \n    vmin, st_list1 = virtual_undirected(n,st_list)\n    #st_list2 = st_list\n    st_list2 = st_list1\n    \n    for st in st_list2:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(vmin, n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nline = []\nfor n in range(N - 1):\n\ta,b = map(int,input().split())\n\ta = a - 1\n\tb = b - 1\n\tline.append((a,b))\nglaf = [[0] * N for i in range(N)]\nkitaiti = [[0] * N for i in range(N)]\nfor l in line:\n\ta = l[0]\n\tb = l[1]\n\tglaf[a][b] = 1\n\tglaf[b][a] = 1\ndef K(p,cp):\n\teda = 0\n\tc = 0\n\tfor i in range(N):\n\t\tif glaf[p][i] == 1 and i != cp:\n\t\t\teda = eda + 1\n\t\t\tif kitaiti[p][i] == 0:\n\t\t\t\tc = c + K(i,p) + 1\n\t\t\telse:\n\t\t\t\tc = c + kitaiti[p][i] + 1\n\tif eda == 0:\n\t\treturn 0\n\tc = c / eda\n\tkitaiti[cp][p] = c\n\treturn c\n\t\n\t\nfor m in range(N):\n\tif sum(glaf[m]) > 2:\n\t\tfor mi,m2 in enumerate(glaf[m]):\n\t\t\tif m2 == 1:\n\t\t\t\tK(mi,m)\nfor m in range(N):\n\tans = 0\n\te = 0\n\tfor i,mj in enumerate(glaf[m]):\n\t\tif mj == 1:\n\t\t\te = e + 1\n\t\t\tans = ans + K(i,m) + 1\n\tprint(ans / e)"
  },
  {
    "language": "Python",
    "code": "class ReRooting(object):\n    \"\"\" 全方位木DP \"\"\"\n    def processing(self, in_:list, v:int):\n        \"\"\"\n        単項演算(加工) f \n        \n        v: 頂点\n        \"\"\"\n        res = in_[0] + 1\n        cnt = 1\n        return [res, cnt]\n    \n    def merge(self, in1:list, in2:list):\n        \"\"\" 二項演算(マージ) ・ \"\"\"\n        res = in1[0] + in2[0]\n        cnt = in1[1] + in2[1]\n        return [res, cnt]\n\n    def adjustment(self, in_:list, v:int):\n        \"\"\"\n        単項演算(調整) g\n        \n        v: 頂点\n        \"\"\"\n        res = 0 if (in_[1] == 0) else in_[0] / in_[1]\n        cnt = in_[1]\n        return  [res, cnt]\n    \n    def solve(self):\n        \"\"\"\n        計算結果を返す\n        \n        Ex. [cnt for cnt, _ in self.calc()]\n        \"\"\"\n        return [res for res,_ in self.calc()]\n\n    def __init__(self, V:int, e:list):\n        \"\"\"\n        V: 頂点数\n        e: 単位元\n        \"\"\"\n        self.V, self.e = V, e\n        self.edge = [[] for _ in range(V)]\n        self.par = [-1] * V\n        self.order = []\n    \n    def add_edge(self, u:int, v:int):\n        \"\"\" 辺(u,v)をグラフに追加する \"\"\"\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    \n    def topological_sort(self, root:int = 0):\n        \"\"\" トポロジカルソート \"\"\"\n        from collections import deque\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            self.order.append(v)\n            for w in self.edge[v]:\n                if w != self.par[v]:\n                    self.par[w] = v\n                    self.edge[w].remove(v)\n                    que.append(w)\n    \n    def bottom_up(self):\n        \"\"\" Bottom-Up DP \"\"\"\n        accBU = [self.e for _ in range(self.V)]\n        resBU = [None] * self.V\n        for v in reversed(self.order):\n            for c in self.edge[v]:\n                accBU[v] = self.merge(accBU[v], self.processing(resBU[c], c))\n            resBU[v] = self.adjustment(accBU[v], v)\n        return accBU, resBU\n    \n    def top_down(self, resBU:list):\n        \"\"\" Top-Down DP \"\"\"\n        accTD = [self.e for _ in range(self.V)]\n        resTD = [self.e for _ in range(self.V)]\n\n        for p in self.order:\n            ac = self.e if (p == self.order[0]) else self.processing(resTD[p], p)\n            for v in self.edge[p]:\n                accTD[v] = ac[:]\n                ac = self.merge(ac, self.processing(resBU[v], v))\n            \n            ac = self.e\n            for v in reversed(self.edge[p]):\n                accTD[v] = self.merge(accTD[v], ac)\n                resTD[v] = self.adjustment(accTD[v], v)\n                ac = self.merge(ac, self.processing(resBU[v], v))\n        return resTD\n    \n    def calc(self):\n        \"\"\" 計算結果を返す \"\"\"\n        self.topological_sort()\n        accBU, resBU = self.bottom_up()\n        resTD = self.top_down(resBU)\n\n        res = [None] * self.V\n        for v in self.order:\n            res[v] = self.e if (v == self.order[0]) else self.processing(resTD[v], v)\n            res[v] = self.merge(accBU[v], res[v])\n            res[v] = self.adjustment(res[v], v)\n        return res\n\n##############################################\nN = int(input())\n\nRR = ReRooting(N, [0, 0])\n\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    RR.add_edge(u - 1, v - 1)\n\nprint(*RR.solve(), sep=\"\\n\")"
  },
  {
    "language": "Python",
    "code": "class ReRooting(object):\n    \"\"\" 全方位木DP \"\"\"\n    def processing(self, in_:list, v:int):\n        \"\"\"\n        単項演算(加工) f \n        \n        v: 頂点\n        \"\"\"\n        res = in_[0] + 1\n        cnt = 1\n        return [res, cnt]\n    \n    def merge(self, in1:list, in2:list):\n        \"\"\" 二項演算(マージ) ・ \"\"\"\n        res = in1[0] + in2[0]\n        cnt = in1[1] + in2[1]\n        return [res, cnt]\n\n    def adjustment(self, in_:list, v:int):\n        \"\"\"\n        単項演算(調整) g\n        \n        v: 頂点\n        \"\"\"\n        res = 0 if (in_[1] == 0) else in_[0] / in_[1]\n        cnt = in_[1]\n        return  [res, cnt]\n    \n    def solve(self):\n        \"\"\"\n        計算結果を返す\n        \n        Ex. [cnt for cnt, _ in self.calc()]\n        \"\"\"\n        return [res for res,_ in self.calc()]\n\n    def __init__(self, V:int, e:list):\n        \"\"\"\n        V: 頂点数\n        e: 単位元\n        \"\"\"\n        self.V, self.e = V, e\n        self.edge = [[] for _ in range(V)]\n        self.par = [-1] * V\n        self.order = []\n    \n    def add_edge(self, u:int, v:int):\n        \"\"\" 辺(u,v)をグラフに追加する \"\"\"\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    \n    def topological_sort(self, root:int = 0):\n        \"\"\" トポロジカルソート \"\"\"\n        from collections import deque\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            self.order.append(v)\n            for w in self.edge[v]:\n                if w != self.par[v]:\n                    self.par[w] = v\n                    self.edge[w].remove(v)\n                    que.append(w)\n    \n    def bottom_up(self):\n        \"\"\" Bottom-Up DP \"\"\"\n        accBU = [self.e for _ in range(self.V)]\n        resBU = [None] * self.V\n        for v in reversed(self.order):\n            for c in self.edge[v]:\n                accBU[v] = self.merge(accBU[v], self.processing(resBU[c], c))\n            resBU[v] = self.adjustment(accBU[v], v)\n        return accBU, resBU\n    \n    def top_down(self, resBU:list):\n        \"\"\" Top-Down DP \"\"\"\n        accTD = [self.e for _ in range(self.V)]\n        resTD = [self.e for _ in range(self.V)]\n\n        for p in self.order:\n            ac = self.e if (p == self.order[0]) else self.processing(resTD[p], p)\n            for v in self.edge[p]:\n                accTD[v] = ac[:]\n                ac = self.merge(ac, self.processing(resBU[v], v))\n            \n            ac = self.e\n            for v in reversed(self.edge[p]):\n                accTD[v] = self.merge(accTD[v], ac)\n                resTD[v] = self.adjustment(accTD[v], v)\n                ac = self.merge(ac, self.processing(resBU[v], v))\n        return resTD\n    \n    def calc(self):\n        \"\"\" 計算結果を返す \"\"\"\n        self.topological_sort()\n        accBU, resBU = self.bottom_up()\n        resTD = self.top_down(resBU)\n\n        res = [None] * self.V\n        for v in self.order:\n            res[v] = self.e if (v == self.order[0]) else self.processing(resTD[v], v)\n            res[v] = self.merge(accBU[v], res[v])\n            res[v] = self.adjustment(res[v], v)\n        return res\n\ndef main():\n    N = int(input())\n\n    RR = ReRooting(N, [0, 0])\n\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        RR.add_edge(u - 1, v - 1)\n\n    print(*RR.solve(), sep=\"\\n\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput3 ='''\n4\n2 1\n2 3\n2 4\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2, input3, None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(root0, n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e_init\n        #ret = Edge(-INF,-INF)\n\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n\n    dfs1(root0,None)   \n    #0 must be root?\n\n    dfs2(root0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\n\ndef virtual_undirected(n,st_list): #　undirected, quasi-directed\n    #print('arg:',n,st_list)\n    edst_vwise0 =  edge_dst_s_vwise0 =  [ [] for i in range(n)]\n    edst_vwise1 =  [ [] for i in range(n)]\n    seen = [False for _ in range(n)]\n    vmin = INF\n    for st in st_list:\n        s,t = st\n        edst_vwise0[s].append(t)\n        edst_vwise0[t].append(s)\n        vmin = min(vmin,s,t)\n    \n    seen[vmin] = True\n    stack = [vmin]\n    \n    while(stack):\n        vcur = stack.pop()\n        for vnext in edst_vwise0[vcur]:\n            if (seen[vnext]):\n                continue\n            \n            stack.append(vnext)\n            edst_vwise1[vcur].append(vnext)\n            seen[vnext] = True\n    \n    #print('edst_vwise',edst_vwise0,edst_vwise1)\n    st_list1 = [ ]\n    for s in range(n):\n        for t in edst_vwise1[s]:\n            #print('s,t',s,t)\n            st_list1.append((s,t))\n    return vmin,st_list1\n\n\n\ndef main():\n\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    \n    vmin, st_list1 = virtual_undirected(n,st_list)\n    #st_list2 = st_list\n    st_list2 = st_list1\n    \n    for st in st_list2:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    reroot(vmin, n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nN = int(input())\nX = [[] for i in range(N)]\nL = [0]*N\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n    L[x-1] += 1\n    L[y-1] += 1\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nC = Counter(P)\n##### Settings\nunit = 0\nmerge = lambda a, b: a + b\nadj_bu = lambda a, i: (a+1)/C[P[i]]\nadj_td = lambda a, i, p: ((XX[p]*L[p]-XX[i]*C[p])/max(1,L[p]-1)+1)/max(1,C[i])\nadj_fin = lambda a, i: a*max(1,C[i])/L[i]\n#####\n\nME = [unit] * N\nXX = [0] * N\nTD = [unit] * N\nfor i in R[1:][::-1]:\n    XX[i] = adj_bu(ME[i], i)\n    p = P[i]\n    ME[p] = merge(ME[p], XX[i])\nXX[R[0]] = adj_fin(ME[R[0]], R[0])\n\nfor i in R:\n    ac = unit\n    for j in reversed(X[i]):\n        TD[j] = adj_td(merge(TD[j], ac), j, i)\n        ac = merge(ac, XX[j])\n        XX[j] = adj_fin(merge(ME[j], TD[j]), j)\n\nprint(*XX, sep = \"\\n\")"
  },
  {
    "language": "Python",
    "code": "print(float(3))"
  },
  {
    "language": "Python",
    "code": "def ReRooting(n, e, identify):\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for u, v in e:\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  def merge1(a, b):\n    return a+b\n  def addnode1(a, id):\n    if id == 0:\n      return a/len(edges[id])+1\n    elif len(edges[id])==1:\n      return 1\n    else:\n      return a/(len(edges[id])-1)+1\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans = merge1(ans, subdp[node][j])\n    subdp[parent][indexedges[node][indexparent]] = addnode1(ans, node)\n  def merge2(a,b):\n    return a+b\n  def addnode2(a, id, flag):\n    if flag:return a/len(edges[id])\n    if len(edges[id])==1:return a+1\n    return a/(len(edges[id])-1)+1\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = merge2(b[i], subdp[node][i])\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = merge2(bb, b[i])\n      subdp[edges[node][i]][indexedges[node][i]] = addnode2(ans, node, 0)\n      bb = merge2(bb, subdp[node][i])\n    dp[node] = addnode2(bb, node, 1)\n  return dp\nn=int(input())\nedges=[]*n\nfor _ in range(n-1):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  edges.append([a,b])\nfor i in ReRooting(n,edges,0):print(i)\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n12\n1 2\n2 3\n2 4\n4 5\n5 6\n5 7\n6 8\n8 9\n2 10\n10 11\n11 12\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  def ReRooting(n, e, identify):\n    edges = [[] for _ in range(n)]\n    indexedges = [[] for _ in range(n)]\n    for u, v in e:\n      indexedges[v].append(len(edges[u]))\n      indexedges[u].append(len(edges[v]))\n      edges[u].append(v)\n      edges[v].append(u)\n    dp = [identify]*n\n    subdp = [len(edges[i])*[identify] for i in range(n)]\n    parents = [-1]*n\n    order = [0]\n    for node in order:\n      for mode in edges[node]:\n        if mode == parents[node]:\n          continue\n        order.append(mode)\n        parents[mode] = node\n    for node in order[1::][::-1]:\n      parent = parents[node]\n      ans = identify\n      indexparent = -1\n      for j in range(len(edges[node])):\n        mode = edges[node][j]\n        if parent == mode:\n          indexparent = j\n          continue\n        ans += subdp[node][j]\n      if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n      else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n    for node in order:\n      b = [identify]*len(edges[node])\n      for i in range(len(edges[node])-1,0,-1):\n        b[i-1] = b[i]+subdp[node][i]\n      bb = identify\n      for i in range(len(edges[node])):\n        ans = bb+b[i]\n        if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n        else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n        bb += subdp[node][i]\n      dp[node]=bb/len(edges[node])\n    print(*dp)\n  n=int(input())\n  edges=[]*n\n  for _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    edges.append([a,b])\n  ReRooting(n,edges,0)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "#recursion-version\n\n#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A&lang=jp\n#http://penguinshunya.hatenablog.com/entry/2019/07/09/003006\n\nimport sys\nsys.setrecursionlimit(10000)\n\ninpPh = 0\ndebug = True\n#debug = False\nif not debug:\n    inpPh = 0\n\ninput1 ='''\n4\n1 2\n2 3\n2 4\n'''[1:]\n\ninput2 ='''\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n'''[1:]\n\ninput1bk ='''\n4\n0 1 2\n1 2 1\n1 3 3\n'''[1:]\n\n\n\n#input1 = input2\n\noutput1_2='''\n5 7\n'''\n\ninputXs = [input1, input2,None]\n\nif debug:\n    try:\n        inputXs.append(inputA0)\n    except:\n        pass\n    else:\n        pass\n\ninploc = inpPh - 1 #0,1,2\n\nif inpPh > 0:\n    #print('selected_input:\\n'+inputXs[inploc])\n    #print('')\n    pass\n\ninpX_lst = []\nif debug and inpPh > 0:\n    inpX_lst = inputXs[inploc].splitlines()\n\n\nif inpPh ==0:\n    n = int(input())\nelse:\n    n = int(inpX_lst.pop(0) )\n\nst_list = []\nnoe_vwise = [0 for _ in range(n)]\n\nfor i in range(n-1):\n    if inpPh ==0:\n        si,ti = tuple(map(lambda x: int(x), input().split() ) )\n    else:\n        si,ti = tuple(map(lambda x: int(x), inpX_lst.pop(0).split() ) )\n    \n    noe_vwise[si-1] += 1\n    #noe_vwise[ti-1] += 1\n    st_list.append((si-1,ti-1))\n\n#print(st_list)\n\nfrom collections import namedtuple\nINF = float('inf')\n\nEdge = namedtuple('Edge', ['to', 'value'])\ndef Edge(x,y):\n    return (x,y)\n\ndef reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise):\n\n    def dfs1(v,v_par):\n        nonlocal es_vwise, dp_es_vwise, e_init, vpar_v\n        stack = [(v,v_par)]\n        while stack:\n            (v,v_par) = stack.pop()\n        \n        #print('es_vwise[v]',v,es_vwise[v])\n        ret = e\n        #ret = Edge(-INF,-INF)\n        ret = (0, 0)\n        \n        for i in range(len(es_vwise[v]) ):\n            e_local = es_vwise[v][i]\n            if (e_local[0] == v_par):\n                print('this-part should not be printed')\n                vpar_v[v] = i\n                continue\n            \n            dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1]  )\n            #dp_es_vwise[v][i] = lift(dfs1(e_local[0], v), e_local[1] )\n            ret = merge(ret, dp_es_vwise[v][i] )\n        return ret\n\n    def dfs2(v, t):\n        # bundlable_parental_edge = t\n        nonlocal ans, es_vwise, dp_es_vwise, vpar_v, e_init\n        nonlocal pe_vwise\n        \n        if (vpar_v[v] is not None):\n            pass\n            #lift(parental_edge, gparental_edge)\n            #dp_es_vwise[v][vpar_v[v]] = lift(t,es_vwise[v][vpar_v[v]][1] )\n        \n        l = len(es_vwise[v])\n        dpl = [e_init for i in range(l+1) ]\n        dpr = [e_init for i in range(l+1) ]\n     \n        if (pe_vwise[v] is not None):\n            v0, v1, w = pe_vwise[v]            \n            dpr[l] = lift(t,w)    \n    \n        for i in range(l):\n            dpl[i+1] = merge(dpl[i], dp_es_vwise[v][i])\n        for i in range(l-1,-1,-1):\n            dpr[i] = merge(dpr[i+1], dp_es_vwise[v][i])\n            #l: 0->1, l-1->l\n            #r: l->l-1, 1->0\n\n        ans[v] = dpr[0]\n\n        for i in range(l):\n            if (i == vpar_v[v]):\n                print('continue, l',0)\n                continue\n            u = es_vwise[v][i][0]\n                \n            dfs2(u, merge(dpl[i], dpr[i+1]) )\n\n    def lift(a,w):\n        if a[1] == 0:\n            return (w,1)\n        \n        return ( (a[0] / a[1]) + w, 1)\n\n    \n    def merge(a,b):\n        # print(\"merge:\",a,b)\n        return (a[0] + b[0], a[1]+b[1])\n\n    nov = n\n    vpar_v = [None for i in range(nov)]\n    vpar_v0 = [None for i in range(nov)]\n\n    for i in range(len(es_vwise)):\n        for e in es_vwise[i]:\n            vpar_v0[e[0]] = i\n    \n    ans = [Edge(0,-INF) for i in range(nov)]    \n    dfs1(0,None)   \n    #0 must be root?\n    dfs2(0,None)\n    ret = 0\n    \n    for i in range(len(ans)):\n        #print(f'i:{i} ans:{ans[i]}')\n        print(float(ans[i][0] / ans[i][1]))\n\n    return ans\n\nclass reroot_init:\n    def __init__(self,n,noe_vwise):\n        self.n = n\n        self.es_vwise = [ [] for i in range(n)]\n        self.dp_es_vwise = [ [] for i in range(n)]\n        self.pe_vwise = [ None for i in range(n)]\n        parental_edge_vwise = self.pe_vwise\n    \n    def movemain(self):\n        reroot(n,self.es_vwise, self.dp_es_vwise, (-INF,-INF), noe_vwise, {})\n\ndef main():\n    rri = reroot_init(n, noe_vwise)\n    es_vwise = [ [] for i in range(n)]\n    dp_es_vwise = [ [] for i in range(n)]\n    pe_vwise = [ None for i in range(n)]    \n    \n    edges_vwise = es_vwise ; parental_edge_vwise = pe_vwise\n\n    def v_add_edge(v,u,w):\n        es_vwise[v].append((u,w))\n        dp_es_vwise[v].append((0, -INF))\n    \n    for st in st_list:\n        s,t = st\n        #print(stw)\n        v_add_edge(s,t,1)\n        pe_vwise[t] = (s,t,1)\n        \n    e_init = (0,0)\n\n    #reroot(n, es_vwise, dp_es_vwise, e_init, noe_vwise, pe_vwise)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def main():\n  import sys\n  input=sys.stdin.readline\n  def ReRooting(n, e, identify):\n    edges = [[] for _ in range(n)]\n    indexedges = [[] for _ in range(n)]\n    for u, v in e:\n      indexedges[v].append(len(edges[u]))\n      indexedges[u].append(len(edges[v]))\n      edges[u].append(v)\n      edges[v].append(u)\n    dp = [identify]*n\n    subdp = [len(edges[i])*[identify] for i in range(n)]\n    parents = [-1]*n\n    order = [n//2]\n    for node in order:\n      for mode in edges[node]:\n        if mode == parents[node]:\n          continue\n        order.append(mode)\n        parents[mode] = node\n    for node in order[1::][::-1]:\n      parent = parents[node]\n      ans = identify\n      indexparent = -1\n      for j in range(len(edges[node])):\n        mode = edges[node][j]\n        if parent == mode:\n          indexparent = j\n          continue\n        ans += subdp[node][j]\n      if len(edges[node])==1:subdp[parent][indexedges[node][indexparent]]=1\n      else:subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n    for node in order:\n      b = [identify]*len(edges[node])\n      for i in range(len(edges[node])-1,0,-1):\n        b[i-1] = b[i]+subdp[node][i]\n      bb = identify\n      for i in range(len(edges[node])):\n        ans = bb+b[i]\n        if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n        else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n        bb += subdp[node][i]\n      dp[node]=bb/len(edges[node])\n    print(*dp)\n  n=int(input())\n  edges=[]*n\n  for _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    edges.append([a,b])\n  ReRooting(n,edges,0)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  n,*uv=map(int,open(0).read().split())\n  identify=0\n  edges = [[] for _ in range(n)]\n  indexedges = [[] for _ in range(n)]\n  for i in range(n-1):\n    u,v=uv[i*2],uv[i*2+1]\n    u-=1\n    v-=1\n    indexedges[v].append(len(edges[u]))\n    indexedges[u].append(len(edges[v]))\n    edges[u].append(v)\n    edges[v].append(u)\n  dp = [identify]*n\n  subdp = [len(edges[i])*[identify] for i in range(n)]\n  parents = [-1]*n\n  order = [0]\n  for node in order:\n    for mode in edges[node]:\n      if mode == parents[node]:\n        continue\n      order.append(mode)\n      parents[mode] = node\n  for node in order[1::][::-1]:\n    parent = parents[node]\n    ans = identify\n    indexparent = -1\n    if len(edges[node])==1:\n      subdp[parent][indexedges[node][edges[node].index(parent)]]=1\n      continue\n    for j in range(len(edges[node])):\n      mode = edges[node][j]\n      if parent == mode:\n        indexparent = j\n        continue\n      ans += subdp[node][j]\n    subdp[parent][indexedges[node][indexparent]]=1+ans/(len(edges[node])-1)\n  for node in order:\n    b = [identify]*len(edges[node])\n    for i in range(len(edges[node])-1,0,-1):\n      b[i-1] = b[i]+subdp[node][i]\n    bb = identify\n    for i in range(len(edges[node])):\n      ans = bb+b[i]\n      if len(edges[node])==1:subdp[edges[node][i]][indexedges[node][i]]=ans+1\n      else:subdp[edges[node][i]][indexedges[node][i]]=ans/(len(edges[node])-1)+1\n      bb += subdp[node][i]\n    dp[node]=bb/len(edges[node])\n  print(*dp)\nif __name__ == \"__main__\":\n  main()\n"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, edge):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - 1].append(e[1] - 1)\n            self.tree[e[1] - 1].append(e[0] - 1)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        self.order = []\n        self.order.append(root)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node] + 1\n                    self.order.append(adj)\n                    stack.append(adj)\n\n    def rerooting(self, func, merge, ti, ei):\n        dp = [ti for _ in range(self.n)]\n        lt = [ei for _ in range(self.n)]\n        rt = [ei for _ in range(self.n)]\n        inv = [ei for _ in range(self.n)]\n        self.setroot(0)\n        for node in self.order[::-1]:\n            tmp = ti\n            for adj in self.tree[node]:\n                if self.parent[adj] == node:\n                    lt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            tmp = ti\n            for adj in self.tree[node][::-1]:\n                if self.parent[adj] == node:\n                    rt[adj] = tmp\n                    tmp = func(tmp, dp[adj])\n            dp[node] = tmp\n        for node in self.order:\n            if node == 0:\n                continue\n            merged = merge(lt[node], rt[node])\n            par = self.parent[node]\n            inv[node] = func(merged, inv[par])\n            dp[node] = func(dp[node], inv[node])\n        return dp\n        \nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nE = [tuple(map(int,input().split())) for _ in range(N - 1)]\n\nT = Tree(N, E)\n\ndef func(node, adj):\n    size = node[1] + 1\n    exp = (node[0] * node[1] + adj[0] + 1) / size if size else 0\n    return exp, size\n\ndef merge(lt, rt):\n    size = lt[1] + rt[1]\n    exp = (lt[0] * lt[1] + rt[0] * rt[1]) / size if size else 0\n    return exp, size\n\nti = (0, 0)\nei = (-1, 0)\n\nD = T.rerooting(func, merge, ti, ei)\n\nres = []\n\nfor i in range(N):\n    res.append(D[i][0])\n\nprint('\\n'.join(map(str, res)))"
  },
  {
    "language": "Python",
    "code": "import sys,os,io\ninput = sys.stdin.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nN = int(input())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\ndef dfs(start):\n  stack = [start]\n  parent = [N]*N\n  parent[start] = -1\n  while stack:\n    v = stack[-1]\n    marker = 0\n    for u in edge[v]:\n      if u==parent[v]:\n        continue\n      if parent[u]==N: #子へ降ろす\n        marker = 1\n        parent[u]=v\n        stack.append(u)\n      else: #子から吸い上げる\n        pass\n        #吸い上げる際の個々の処理\n        ans[v] += ans[u]+1\n    if marker==0:\n      stack.pop()\n      if v==start:\n        #根へ吸い上げる時のまとめ処理\n        ans[v] /= len(edge[v])\n      elif ans[v]>0:\n        ans[v] /= len(edge[v])-1\n  return\n\ndef dfs2(start):\n  stack = [start]\n  parent = [N]*N\n  parent[start] = -1\n  p_value = [0]*N\n  while stack:\n    v = stack.pop()\n    for i,u in enumerate(edge[v]):\n      if u==parent[v]:\n        continue\n      parent[u] = v\n      if len(edge[v])==1:\n        p_value[u] = 0\n      else:\n        p_value[u] = (ans[v]*len(edge[v])-(ans[u]+1))/(len(edge[v])-1)\n      ans[u] *= len(edge[u])-1\n      ans[u] += p_value[u]+1\n      ans[u] /= len(edge[u]) \n      stack.append(u)\n  return\n\nans = [0]*N\ndfs(0)\ndfs2(0)\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\nN = int(input())\nX = [[] for i in range(N)]\nL = [0]*N\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n    L[x-1] += 1\n    L[y-1] += 1\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nC = Counter(P)\n##### Settings\nunit = 0\nmerge = lambda a, b: a + b\nadj_bu = lambda a, i: (a+1)/C[P[i]]\nadj_td = lambda a, i, p: ((XX[P[i]]*L[P[i]]-XX[i]*C[P[i]])/max(1,L[P[i]]-1)+1)/max(1,C[i])\nadj_fin = lambda a, i: a*max(1,C[i])/L[i]\n#####\n\nME = [unit] * N\nXX = [0] * N\nTD = [unit] * N\nfor i in R[1:][::-1]:\n    XX[i] = adj_bu(ME[i], i)\n    p = P[i]\n    ME[p] = merge(ME[p], XX[i])\nXX[R[0]] = adj_fin(ME[R[0]], R[0])\n\nfor i in R:\n    ac = TD[i]\n    for j in X[i]:\n        TD[j] = ac\n        ac = merge(ac, XX[j])\n\n    ac = unit\n    for j in reversed(X[i]):\n        TD[j] = adj_td(merge(TD[j], ac), j, i)\n        ac = merge(ac, XX[j])\n        XX[j] = adj_fin(merge(ME[j], TD[j]), j)\n\nprint(*XX, sep = \"\\n\")"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn calc(v: usize, par: Option<usize>, edges: &[Vec<usize>]) -> f64 {\n    let mut tot = 0.0;\n    let mut trail = 0.0;\n    for &w in edges[v].iter() {\n        if Some(w) == par { continue; }\n        tot += calc(w, Some(v), edges);\n        trail += 1.0;\n    }\n    if trail != 0.0 {\n        tot / trail + 1.0\n    } else {\n        0.0\n    }\n}\n\nfn solve() {\n    let n = get();\n    let mut edges = vec![Vec::new(); n];\n    for _ in 0 .. n - 1 {\n        let u = get::<usize>() - 1;\n        let v = get::<usize>() - 1;\n        edges[u].push(v);\n        edges[v].push(u);\n    }\n    assert!(n <= 2000);\n    for i in 0 .. n {\n        println!(\"{}\", calc(i, None, &edges));\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn dfs1(v: usize, par: Option<usize>, edges: &[Vec<usize>],\n        dp: &mut [Vec<f64>]) -> f64 {\n    let mut tot = 0.0;\n    let mut trail = 0.0;\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par { continue; }\n        let res = dfs1(w, Some(v), edges, dp);\n        tot += res;\n        dp[v][i] = res + 1.0;\n        trail += 1.0;\n    }\n    if trail != 0.0 {\n        tot / trail + 1.0\n    } else {\n        0.0\n    }\n}\nfn dfs2(v: usize, par: Option<usize>, edges: &[Vec<usize>],\n        dp: &mut [Vec<f64>], promise: f64) {\n    let mut tot = 0.0;\n    let mut trail = 0.0;\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par {\n            dp[v][i] = promise;\n            tot += promise;\n        } else {\n            tot += dp[v][i];\n        }\n        trail += 1.0;\n    }\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par { continue; }\n        let tmp = tot - dp[v][i];\n        dfs2(w, Some(v), edges, dp,\n             (if trail != 1.0 { tmp / (trail - 1.0) } else { 0.0 }) + 1.0);\n    }\n}\n\n\nfn solve() {\n    let n = get();\n    let mut edges = vec![Vec::new(); n];\n    for _ in 0 .. n - 1 {\n        let u = get::<usize>() - 1;\n        let v = get::<usize>() - 1;\n        edges[u].push(v);\n        edges[v].push(u);\n    }\n    let mut dp = vec![Vec::new(); n];\n    for i in 0 .. n {\n        dp[i] = vec![-1.0 / 0.0; edges[i].len()];\n    }\n    dfs1(0, None, &edges, &mut dp);\n    dfs2(0, None, &edges, &mut dp, 0.0 / 0.0);\n    //println!(\"dp = {:?}\", dp);\n    for i in 0 .. n {\n        let mut tot = 0.0;\n        for &val in dp[i].iter() {\n            tot += val;\n        }\n        println!(\"{}\", tot / edges[i].len() as f64);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn dfs1(v: usize, par: Option<usize>, edges: &[Vec<usize>],\n        dp: &mut [Vec<f64>]) -> f64 {\n    let mut tot = 0.0;\n    let mut trail = 0.0;\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par { continue; }\n        let res = dfs1(w, Some(v), edges, dp);\n        tot += res;\n        dp[v][i] = res + 1.0;\n        trail += 1.0;\n    }\n    if trail != 0.0 {\n        tot / trail + 1.0\n    } else {\n        0.0\n    }\n}\nfn dfs2(v: usize, par: Option<usize>, edges: &[Vec<usize>],\n        dp: &mut [Vec<f64>], promise: f64) {\n    let mut tot = 0.0;\n    let mut trail = 0.0;\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par {\n            dp[v][i] = promise;\n            tot += promise;\n        } else {\n            tot += dp[v][i];\n            trail += 1.0;\n        }\n    }\n    for i in 0 .. edges[v].len() {\n        let w = edges[v][i];\n        if Some(w) == par { continue; }\n        let tmp = tot - dp[v][i];\n        dfs2(w, Some(v), edges, dp, tmp / trail + 1.0);\n    }\n}\n\n\nfn solve() {\n    let n = get();\n    let mut edges = vec![Vec::new(); n];\n    for _ in 0 .. n - 1 {\n        let u = get::<usize>() - 1;\n        let v = get::<usize>() - 1;\n        edges[u].push(v);\n        edges[v].push(u);\n    }\n    let mut dp = vec![Vec::new(); n];\n    for i in 0 .. n {\n        dp[i] = vec![-1.0 / 0.0; edges[i].len()];\n    }\n    dfs1(0, None, &edges, &mut dp);\n    dfs2(0, None, &edges, &mut dp, 0.0 / 0.0);\n    for i in 0 .. n {\n        let mut tot = 0.0;\n        for &val in dp[i].iter() {\n            tot += val;\n        }\n        println!(\"{}\", tot / edges[i].len() as f64);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "struct Rerooting<Edge, Value, Func> {\n    size: usize,\n    edge: Vec<(usize, usize, Edge)>,\n    initial: Value,\n    merge: Func,\n}\n\nimpl<Edge, Value, Func> Rerooting<Edge, Value, Func>\nwhere Edge: Clone,\n      Value: Clone,\n      Func: Fn(&Value, &Value, &Edge) -> Value {\n    fn new(size: usize, initial: Value, func: Func) -> Self {\n        Rerooting {\n            size: size,\n            edge: vec![],\n            initial: initial,\n            merge: func,\n        }\n    }\n    fn add_edge(&mut self, a: usize, b: usize, cost: Edge) {\n        self.edge.push((a, b, cost));\n    }\n    fn solve(&self) -> Vec<Value> {\n        let mut graph = vec![vec![]; self.size];\n        for e in self.edge.iter() {\n            let a = e.0;\n            let b = e.1;\n            graph[a].push((b, e.2.clone()));\n            graph[b].push((a, e.2.clone()));\n        }\n        let root = 0;\n        let mut topo = vec![];\n        let mut stack = vec![(root, root)];\n        while let Some((v, p)) = stack.pop() {\n            topo.push(v);\n            if let Some(k) = graph[v].iter().position(|e| e.0 == p) {\n                graph[v].remove(k);\n            }\n            for e in graph[v].iter() {\n                stack.push((e.0, v));\n            }\n        }\n        assert!(topo.len() == self.size);\n        let mut down = vec![self.initial.clone(); self.size];\n        for &v in topo.iter().rev() {\n            for e in graph[v].iter() {\n                down[v] = (self.merge)(&down[v], &down[e.0], &e.1);\n            }\n        }\n        let mut up = vec![self.initial.clone(); self.size];\n        let mut ans = up.clone();\n        for &v in topo.iter() {\n            ans[v] = up[v].clone();\n            for e in graph[v].iter() {\n                ans[v] = (self.merge)(&ans[v], &down[e.0], &e.1);\n            }\n            if graph[v].is_empty() {\n                continue;\n            }\n            let mut stack = vec![(graph[v].as_slice(), up[v].clone())];\n            while let Some((g, val)) = stack.pop() {\n                if g.len() == 1 {\n                    up[g[0].0] = (self.merge)(&self.initial, &val, &g[0].1);\n                } else {\n                    let m = g.len() / 2;\n                    let (a, b) = g.split_at(m);\n                    let mut p = val.clone();\n                    for e in a.iter() {\n                        p = (self.merge)(&p, &down[e.0], &e.1);\n                    }\n                    let mut q = val;\n                    for e in b.iter() {\n                        q = (self.merge)(&q, &down[e.0], &e.1);\n                    }\n                    stack.push((b, p));\n                    stack.push((a, q));\n                }\n            }\n        }\n        ans\n    }\n}\n\nuse std::io::Read;\nuse std::io::Write;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    type Value = (f64, f64);\n    let ini: Value = (0f64, 0f64);\n    let f = |a: &Value, b: &Value, _c: &()| -> Value {\n        let p = a.1;\n        (1.0 + ((a.0 - 1.0) * p + b.0) / (p + 1.0), a.1 + 1.0)\n    };\n    let mut solver = Rerooting::new(n, ini, f);\n    for _ in 1..n {\n        let x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        solver.add_edge(x, y, ());\n    }\n    let ans = solver.solve();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for a in ans {\n        writeln!(out, \"{:.7}\", a.0).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case, unused)]\nuse std::collections::*;\n\n////////// missing functions in 1.15.1 //////////\nmacro_rules! eprint {\n\t($($t:tt)*) => {{\n\t\tuse ::std::io::Write;\n\t\tlet _ = write!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! eprintln {\n\t() => { eprintln!(\"\"); };\n\t($($t:tt)*) => {{\n\t\tuse ::std::io::Write;\n\t\tlet _ = writeln!(::std::io::stderr(), $($t)*);\n\t}};\n}\nmacro_rules! dbg {\n\t($v:expr) => {{\n\t\tlet val = $v;\n\t\teprintln!(\"[{}:{}] {} = {:?}\", file!(), line!(), stringify!($v), val);\n\t\tval\n\t}}\n}\n/////////////////////////////////////////////////\npub trait SetMinMax {\n\tfn setmin(&mut self, v: Self) -> bool;\n\tfn setmax(&mut self, v: Self) -> bool;\n}\nimpl<T> SetMinMax for T where T: PartialOrd {\n\tfn setmin(&mut self, v: T) -> bool {\n\t\t*self > v && { *self = v; true }\n\t}\n\tfn setmax(&mut self, v: T) -> bool {\n\t\t*self < v && { *self = v; true }\n\t}\n}\n\nmacro_rules! mat {\n\t($($e:expr),*) => { Vec::from(vec![$($e),*]) };\n\t($($e:expr,)*) => { Vec::from(vec![$($e),*]) };\n\t($e:expr; $d:expr) => { Vec::from(vec![$e; $d]) };\n\t($e:expr; $d:expr $(; $ds:expr)+) => { Vec::from(vec![mat![$e $(; $ds)*]; $d]) };\n}\n\nmacro_rules! ok {\n\t($a:ident$([$i:expr])*.$f:ident()$(@$t:ident)*) => {\n\t\t$a$([$i])*.$f($($t),*)\n\t};\n\t($a:ident$([$i:expr])*.$f:ident($e:expr$(,$es:expr)*)$(@$t:ident)*) => { {\n\t\tlet t = $e;\n\t\tok!($a$([$i])*.$f($($es),*)$(@$t)*@t)\n\t} };\n}\n\npub fn readln() -> String {\n\tlet mut line = String::new();\n\t::std::io::stdin().read_line(&mut line).unwrap_or_else(|e| panic!(\"{}\", e));\n\tline\n}\n\nmacro_rules! read {\n\t($($t:tt),*; $n:expr) => {{\n\t\tlet stdin = ::std::io::stdin();\n\t\tlet ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n\t\t\tlet line = line.unwrap();\n\t\t\tlet mut it = line.split_whitespace();\n\t\t\t_read!(it; $($t),*)\n\t\t}).collect::<Vec<_>>();\n\t\tret\n\t}};\n\t($($t:tt),*) => {{\n\t\tlet line = readln();\n\t\tlet mut it = line.split_whitespace();\n\t\t_read!(it; $($t),*)\n\t}};\n}\n\nmacro_rules! _read {\n\t($it:ident; [char]) => {\n\t\t_read!($it; String).chars().collect::<Vec<_>>()\n\t};\n\t($it:ident; [u8]) => {\n\t\tVec::from(_read!($it; String).into_bytes())\n\t};\n\t($it:ident; usize1) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<usize>().unwrap_or_else(|e| panic!(\"{}\", e)) - 1\n\t};\n\t($it:ident; [usize1]) => {\n\t\t$it.map(|s| s.parse::<usize>().unwrap_or_else(|e| panic!(\"{}\", e)) - 1).collect::<Vec<_>>()\n\t};\n\t($it:ident; [$t:ty]) => {\n\t\t$it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n\t};\n\t($it:ident; $t:ty) => {\n\t\t$it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n\t};\n\t($it:ident; $($t:tt),+) => {\n\t\t($(_read!($it; $t)),*)\n\t};\n}\n\npub fn main() {\n\tlet _ = ::std::thread::Builder::new().name(\"run\".to_string()).stack_size(32 * 1024 * 1024).spawn(run).unwrap().join();\n}\n\n// dp[u] = h(f(e(dp[v1], w1), e(dp[v2], w2), ...), u)\n// f must be associative.\n// (rooted, subtree)\nfn tree_dp<T: Clone + Default, W: Clone, E: Fn(T, W) -> T, F: Fn(T, T) -> T, H: Fn(T, usize) -> T>(g: &Vec<Vec<(usize, W)>>, e: E, f: F, h: H, zero: T) -> (Vec<T>, Vec<Vec<T>>) {\n\tlet n = g.len();\n\tlet mut parent = vec![!0; n];\n\tlet mut parent_i = vec![!0; n];\n\tlet mut order = vec![0];\n\tfor i in 0..n {\n\t\tlet u = order[i];\n\t\tfor (j, &(v, _)) in g[u].iter().enumerate() {\n\t\t\tif v != parent[u] {\n\t\t\t\tparent[v] = u;\n\t\t\t\torder.push(v);\n\t\t\t\tparent_i[v] = j;\n\t\t\t}\n\t\t}\n\t}\n\tlet mut cs = vec![zero.clone(); n];\n\tfor &u in order.iter().rev() {\n\t\tfor &(v, ref w) in &g[u] {\n\t\t\tif v != parent[u] {\n\t\t\t\tcs[u] = f(cs[u].clone(), e(cs[v].clone(), w.clone()));\n\t\t\t}\n\t\t}\n\t\tcs[u] = h(cs[u].clone(), u);\n\t}\n\tlet mut rooted = vec![zero.clone(); n];\n\tlet mut subtree = vec![vec![]; n];\n\tfor &u in &order {\n\t\tsubtree[u] = vec![zero.clone(); g[u].len()];\n\t\tlet mut pre = vec![zero.clone(); g[u].len()];\n\t\tlet mut a = zero.clone();\n\t\tfor (j, &(v, ref w)) in g[u].iter().enumerate() {\n\t\t\tpre[j] = a.clone();\n\t\t\tif v == parent[u] {\n\t\t\t\ta = f(a, e(subtree[v][parent_i[u]].clone(), w.clone()));\n\t\t\t} else {\n\t\t\t\ta = f(a, e(cs[v].clone(), w.clone()));\n\t\t\t}\n\t\t}\n\t\trooted[u] = h(a, u);\n\t\ta = zero.clone();\n\t\tfor (j, &(v, ref w)) in g[u].iter().enumerate().rev() {\n\t\t\tsubtree[u][j] = h(f(pre[j].clone(), a.clone()), u);\n\t\t\tif v == parent[u] {\n\t\t\t\ta = f(e(subtree[v][parent_i[u]].clone(), w.clone()), a);\n\t\t\t} else {\n\t\t\t\ta = f(e(cs[v].clone(), w.clone()), a);\n\t\t\t}\n\t\t}\n\t}\n\t(rooted, subtree)\n}\n\nfn run() {\n\tlet N = read!(usize);\n\tlet mut g = vec![vec![]; N];\n\tfor (a, b) in read!(usize1, usize1; N - 1) {\n\t\tg[a].push((b, ()));\n\t\tg[b].push((a, ()));\n\t}\n\tlet (rooted, _) = tree_dp(&g, |a, _| (a.0 + 1.0, 1.0), |a, b| (a.0 + b.0, a.1 + b.1), |a, _| (if a.1 == 0.0 { 0.0 } else { a.0 / a.1 }, a.1), (0.0, 0.0));\n\tfor i in 0..N {\n\t\tprintln!(\"{}\", rooted[i].0);\n\t}\n}\n"
  }
]