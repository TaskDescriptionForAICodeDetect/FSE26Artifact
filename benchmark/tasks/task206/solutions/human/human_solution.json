[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    bool first = true;\n\n    for(;;){\n        int p, s;\n        cin >> p >> s;\n        if(p == 0)\n            return 0;\n        ++ p;\n        ++ s;\n\n        vector<vector<int> > num(p, vector<int>(s, 0));\n        vector<vector<bool> > missing(p, vector<bool>(s, false));\n        vector<int> missingNum(p+s, 0);\n        for(int i=0; i<p; ++i){\n            for(int j=0; j<s; ++j){\n                if(!(cin >> num[i][j])){\n                    cin.clear();\n                    cin.ignore();\n                    missing[i][j] = true;\n                    ++ missingNum[i];\n                    ++ missingNum[p+j];\n                }\n                if((i == p-1) ^ (j == s-1))\n                    num[i][j] *= -1;\n            }\n        }\n\n        vector<vector<bool> > check = missing;\n        queue<int> q;\n        for(int i=0; i<p+s; ++i){\n            if(missingNum[i] == 1)\n                q.push(i);\n        }\n        while(!q.empty()){\n            int y = q.front();\n            int x = -1;\n            q.pop();\n\n            int tmp = 0;\n            if(y < p){\n                for(int i=0; i<s; ++i){\n                    tmp -= num[y][i];\n                    if(check[y][i])\n                        x = i;\n                }\n            }else{\n                x = y - p;\n                y = -1;\n                for(int i=0; i<p; ++i){\n                    tmp -= num[i][x];\n                    if(check[i][x])\n                        y = i;\n                }\n            }\n            if(y == -1 || x == -1)\n                continue;\n\n            num[y][x] = tmp;\n            check[y][x] = false;\n            -- missingNum[y];\n            -- missingNum[p+x];\n            if(missingNum[y] == 1)\n                q.push(y);\n            if(missingNum[p+x] == 1)\n                q.push(p+x);\n        }\n\n        if(first)\n            first = false;\n        else\n            cout << endl;\n\n        if(*max_element(missingNum.begin(), missingNum.end()) > 0){\n            cout << \"NO\" << endl;\n        }else{\n            for(int i=0; i<p; ++i){\n                for(int j=0; j<s; ++j){\n                    if(missing[i][j])\n                        cout << num[i][j] << endl;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int R,C;\n  bool f = false;\n  while(cin>>R>>C){\n    if(f) cout<<endl;\n    else f = true;\n    int data[101][101];\n    int cntx[101]={};\n    int cnty[101]={};\n    vector<P> fout;\n    REP(y,R+1)REP(x,C+1){\n      string s; cin>>s;\n      if(s == \"?\") {\n        data[y][x] = -1;\n        fout.push_back(P(x,y));\n        cntx[x]++;\n        cnty[y]++;\n      } else {\n        data[y][x] = atoi(s.c_str());\n      }\n    }\n    while(true){\n      bool updata = false;\n      REP(y,R+1){\n        if(cnty[y] == 1){\n          cnty[y] = 0;\n          updata = true;\n          int sum = 0;\n          REP(x,C+1)if(data[y][x]!=-1)sum += ((x==C)?1:-1) * data[y][x];\n          REP(x,C+1)if(data[y][x]==-1){\n            data[y][x] = ((x==C)?-1:1) * sum;\n            cntx[x]--;\n          }\n        }\n      }\n      REP(x,C+1){\n        if(cntx[x] == 1){\n          cntx[x] = 0;\n          updata = true;\n          int sum = 0;\n          REP(y,R+1)if(data[y][x]!=-1)sum += ((y==R)?1:-1) * data[y][x];\n          REP(y,R+1)if(data[y][x]==-1){\n            data[y][x] = ((y==R)?-1:1) * sum;\n            cnty[y]--;\n          }\n        }\n      }\n      if(!updata) break;\n    }\n    int cnt = 0;\n    REP(y,R+1)REP(x,C+1)if(data[y][x]==-1) cnt++;\n    if(cnt > 0) cout<<\"NO\"<<endl;\n    else {\n      REP(i, fout.size()){\n        cout<<data[fout[i].second][fout[i].first]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<sstream>\n#include<cstdlib>\n#include<cassert>\n#define MAX 1000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint G[MAX][MAX];\nint A[MAX][2];// 0->r, 1->c\nP B[MAX][2];\nint C[MAX][2];\nint D[MAX][2];\n\nvoid printA()\n{\n  cout << \"printA---\" << endl;\n  rep(i,w)cout << A[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << A[i][1] << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printB()\n{\n  cout << \"printB---\" << endl;\n  rep(i,w)cout << B[i][0].first << \",\" << B[i][0].second << \" \"; cout << endl;\n  rep(i,h)cout << B[i][1].first << \",\" << B[1][i].second << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printC()\n{\n  cout << \"printC---\" << endl;\n  rep(i,w)cout << C[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << C[i][1] << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printD()\n{\n  cout << \"printD---\" << endl;\n  rep(i,w)cout << D[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << D[i][1] << \" \"; cout << endl;\n}\n\nP Bsearch(int a,int b)\n{\n  int Size = (b == 0?h:w);\n  for(int i=0;i<Size;i++)\n    {\n      if(b == 0)\n\t{\n\t  if(G[i][a] == -inf)return P(a,i);\n\t}\n      else\n\t{\n\t  if(G[a][i] == -inf)return P(i,a);\n\t}\n    }\n}\n\nint main()\n{\n  int blank = false;\n  while(true)\n    {\n      cin >> h;\n      if(!h)break;\n      cin >> w;\n      rep(i,MAX)rep(j,2)A[i][j] = C[i][j] = 0,B[i][j] = P(-inf,-inf);\n\n      vector<P> ans;\n      int hatena = 0;\n      rep(i,h)\n\t{\n\t  rep(j,w)\n\t    {\n\t      string input;\n\t      cin >> input;\n\t      if(input[0] == '?')\n\t\t{\n\t\t  G[i][j] = -inf;   \n\t\t  A[j][0]++;\n\t\t  B[j][0] = P(j,i);\n\t\t  A[i][1]++;\n\t\t  B[i][1] = P(j,i);\n\t\t  ans.push_back(P(j,i));\n\t\t}\n\t      else \n\t\t{\n\t\t  G[i][j] = (atoi)(input.c_str());\n\t\t  C[j][0] += G[i][j];\n\t\t  C[i][1] += G[i][j];\n\t\t}\n\t    }\n\t  cin >> D[i][1];\n\t}\n      rep(i,w+1)\n\tcin >> D[i][0];\n\t\n      //printA();\n      //printB();\n      //printC();\n      //printD();\n      //return 0;\n      bool Fin = true;\n      bool found = false;\n\n      while(true)\n\t{\n\t  //cout << \"phase !\" << endl;\n\t  //printA();\n\t  //printB();\n\t  //printC();\n\t  //printD();\n\t  Fin = true;\n\t  found = false;\n\t  rep(i,w)\n\t    {\n\t      if(A[i][0] >= 1)Fin = false;\n\t      if(A[i][0] == 1)\n\t\t{\n\t\t  //cout << \"erase! \" << B[i][0].first << \",\" << B[i][0].second << endl;\n\t\t  found = true;\t\n\t\t  int value = D[i][0]-C[i][0];\n\t\t  P p = Bsearch(i,0);\n\t\t   C[p.first][0]+=value;\n\t\t  C[p.second][1]+=value;\n\t\t   A[p.first][0]--;\n\t\t  A[p.second][1]--;\n\t\t  assert( G[p.second][p.first] == -inf);\n\t\t  G[p.second][p.first] = value;\n\t\t}\n\t    }\n\t  rep(i,h)\n\t    {\n\t      if(A[i][1] >= 1)Fin = false;\n\t      if(A[i][1] == 1)\n\t\t{\n\t\t  //cout << \"erase! \" << B[i][1].first << \",\" << B[i][1].second << endl;\n\t\t  found = true;\t\n\t\t  int value = D[i][1]-C[i][1];\n\t\t  P p = Bsearch(i,1);\n\t\t   C[p.first][0]+=value;\n\t\t  C[p.second][1]+=value;\n\t\t   A[p.first][0]--;\n\t\t  A[p.second][1]--;\n\t\t  assert(G[p.second][p.first] == -inf);\n\t\t  G[p.second][p.first] = value;\n\t\t}\n\t    }\n\n\t  if(!Fin && !found)\n\t    break;\n\t  if(Fin)break;\n\n\t}\n      if(!blank)blank = true;\n      else cout << endl;\n\t  if(!Fin && !found)\n\t    cout << \"NO\" << endl;\n\t  else\n\t    {\n\t      rep(i,ans.size())\n\t\tcout << G[ans[i].second][ans[i].first] << endl;\n\n\t\t\n\t    }\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nvoid solve(int R, int C){\n  vector<PI> U;\n  vector<int> SR(R), SC(C);\n  \n  REP(i, R + 1) REP(j, C + 1){\n    string str;\n    cin >> str;\n    if (str == \"?\"){\n      U.push_back(PI(i, j));\n    } else if (i < R || j < C){\n      int value = atoi(str.c_str());\n      SR[i] += (j == C ? value : -value);\n      SC[j] += (i == R ? value : -value);\n    }\n  }\n\n  if (U.size() > SR.size() + SC.size()) {\n    cout << \"NO\" << endl;\n  } else {\n    int n = U.size();\n    vector<vector<double> > M(R + C, vector<double>(n + 1, 0));\n    REP(i, R) M[i + 0][n] = SR[i];\n    REP(i, C) M[i + R][n] = SC[i];\n    REP(i, n) M[U[i].first][i] = M[U[i].second + R][i] = 1;\n\n    REP(i, n){\n      int pivot = i;\n      REP2(j, i, R + C) if (abs(M[j][i]) > abs(M[pivot][i])) pivot = j;\n      \n      if (abs(M[pivot][i]) < eps) {\n        cout << \"NO\" << endl;\n        return;\n      }\n\n      swap(M[pivot], M[i]);\n      REP(j, R + C) REP2(k, i + 1, n + 1) if (j != i){\n        M[j][k] -= M[j][i] / M[i][i] * M[i][k];\n      }\n      REP2(k, i + 1, n + 1) M[i][k] /= M[i][i];\n      REP(j, R + C) M[j][i] = j == i;\n    }\n    \n    REP(i, n) cout << (int)(M[i][n] > 0 ? M[i][n] + 0.5 : M[i][n] - 0.5) << endl;\n  }\n}\n\n\nint main(){\n  int R, C, T = 0;\n  while (cin >> R >> C){\n    if (T > 0) cout << endl;\n    solve(R, C);\n    T++;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\tint newline=0;\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tif(newline)cout<<endl;\n\t\tnewline=1;\n\t\tfill(sumV,sumV+s,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(isdigit(c[0])){\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint sumH2=0,sumV2=0;\n\t\trep(i,p)sumH2+=sumH[i];\n\t\trep(i,s)sumV2+=sumV[i];\n\t\tif(sumH2!=sumV[s] || sumV2!=sumV[s]){\n\t\t\tcout<<\"NO\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint ans[1011]={},na=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tna=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(na)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nint b[200][20];\nconst int unknown = 1000000;\n\nint main(){\n  int p, s;\n  int m = 0;\n  while(~scanf(\"%d%d \", &p, &s) && p != 0){\n    vector<pair<int,int> > up;\n\n    if(m++ != 0) puts(\"\");\n\n    REP(i, p+1) REP(j, s+1){\n      char buff[32];\n      scanf(\"%s \", buff);\n      if(buff[0] == '?'){\n        b[i][j] = unknown;\n        up.push_back(mp(i, j));\n      }else{\n        b[i][j] = atoi(buff);\n      }\n    }\n\n    bool ok = true;\n    bool change = true;\n\n    while(change){\n      int cc = 0;\n      change = false;\n\n      REP(i,p){\n        int cnt = 0;\n        int sum = 0;\n        pair<int,int> pos;\n\n        REP(j,s){\n          if(b[i][j] == unknown){\n            cnt++;\n            pos = mp(i,j);\n          }else{\n            sum += b[i][j];\n          }\n        }\n        cc += cnt;\n\n        if(cnt == 1){\n          int y = pos.f;\n          int x = pos.s;\n\n          change = true;\n          b[y][x] = b[i][s] - sum;\n\n          sum = 0;\n          REP(j, p){\n            if(b[j][x] == unknown)\n              goto end;\n            else\n              sum += b[j][x];\n          }\n\n          if(sum != b[p][x]){\n            ok = false;\n            goto end2;\n          }\n\n        end:;\n        }\n\n      }\n      REP(j,s){\n        int cnt = 0;\n        int sum = 0;\n        pair<int,int> pos;\n\n        REP(i,p){\n          if(b[i][j] == unknown){\n            cnt++;\n            pos = mp(i,j);\n          }else{\n            sum += b[i][j];\n          }\n        }\n\n        if(cnt == 1){\n          int y = pos.f;\n          int x = pos.s;\n\n          change = true;\n          b[y][x] = b[p][j] - sum;\n\n          sum = 0;\n          REP(i, s){\n            if(b[y][i] == unknown)\n              goto end3;\n            else\n              sum += b[y][i];\n          }\n\n          if(sum != b[y][s]){\n            ok = false;\n            goto end2;\n          }\n\n        end3:;\n        }\n\n      }\n\n      if(cc != 0 && change == false)\n        ok = false;\n    }\n  end2:;\n\n    if(ok){\n      FOR(it, up){\n        int y = it->f;\n        int x = it->s;\n\n        printf(\"%d\\n\", b[y][x]);\n      }\n    }else{\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nint b[200][20];\nconst int unknown = 1000000;\n\nint main(){\n  int p, s;\n  int m = 0;\n  while(~scanf(\"%d%d \", &p, &s)){\n    vector<pair<int,int> > up;\n\n    if(m++ != 0) puts(\"\");\n\n    REP(i, p+1) REP(j, s+1){\n      char buff[32];\n      scanf(\"%s \", buff);\n      if(buff[0] == '?'){\n\tb[i][j] = unknown;\n\tup.push_back(mp(i, j));\n      }else{\n\tb[i][j] = atoi(buff);\n      }\n    }\n\n    bool ok = true;\n    bool change = true;\n\n    while(change){\n      int cc = 0;\n      change = false;\n\n      REP(i,p){\n\tint cnt = 0;\n\tint sum = 0;\n\tpair<int,int> pos;\n\t\n\tREP(j,s){\n\t  if(b[i][j] == unknown){\n\t    cnt++;\n\t    pos = mp(i,j);\n\t  }else{\n\t    sum += b[i][j];\n\t  }\n\t}\n\tcc += cnt;\n\n\tif(cnt == 1){\n\t  int y = pos.f;\n\t  int x = pos.s;\n\n\t  change = true;\n\t  b[y][x] = b[i][s] - sum;\n\n\t  sum = 0;\n\t  REP(j, p){\n\t    if(b[j][x] == unknown)\n\t      goto end;\n\t    else\n\t      sum += b[j][x];\n\t  }\n\n\t  if(sum != b[p][x]){\n\t    ok = false;\n\t    goto end2;\n\t  }\n \n\tend:;\n\t}\n\n      }\n      REP(j,s){\n\tint cnt = 0;\n\tint sum = 0;\n\tpair<int,int> pos;\n\t\n\tREP(i,p){\n\t  if(b[i][j] == unknown){\n\t    cnt++;\n\t    pos = mp(i,j);\n\t  }else{\n\t    sum += b[i][j];\n\t  }\n\t}\n\n\tif(cnt == 1){\n\t  int y = pos.f;\n\t  int x = pos.s;\n\n\t  change = true;\n\t  b[y][x] = b[p][j] - sum;\n\n\t  sum = 0;\n\t  REP(i, s){\n\t    if(b[y][i] == unknown)\n\t      goto end3;\n\t    else\n\t      sum += b[y][i];\n\t  }\n\n\t  if(sum != b[y][s]){\n\t    ok = false;\n\t    goto end2;\n\t  }\n \n\tend3:;\n\t}\n\n      }\n\n      if(cc != 0 && change == false)\n\tok = false;\n    }\n  end2:;\n\n    if(ok){\n      FOR(it, up){\n\tint y = it->f;\n\tint x = it->s;\n\n\tprintf(\"%d\\n\", b[y][x]);\n      }\n    }else{\n      puts(\"NO\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define N 1000000\nusing namespace std;\n\nmain(){\n  int p, s;\n  char num[10];\n  int data[100][10];\n  bool kai=false;\n  while(1){\n    cin >> p;\n    if(p==0) break;\n    if(kai) cout << endl;\n    cin >> s;\n    int tm=0;\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tscanf(\"%s\", num);\n\tif(num[0]=='?'){\n\t  tm++;\n\t  data[i][j]=N;\n\t}\n\telse data[i][j]=atoi(num);\n      }\n    }\n\n    bool flag=true;\n    bool t[100][10];\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tt[i][j]=false;\n      }\n    }\n    while(tm!=0){\n      bool end=true;\n      for(int i=0;i<=p;i++){\n\tint sum=0;\n\tint a;\n\tfor(int j=0;j<=s;j++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=j;\n\t  }\n\t}\n\tif(sum==1){\n\t  if(a==s){\n\t    int tmp=0;\n\t    for(int j=0;j<s;j++){\n\t      tmp+=data[i][j];\n\t    }\n\t    data[i][a]=tmp;\n\t    t[i][a]=true;\n\t  }\n\t  else{\n\t    flag=false;\n\t    end=false;\n\t    int tmp=0;\n\t    for(int j=0;j<s;j++){\n\t      if(j==a) continue;\n\t      tmp+=data[i][j];\n\t    }\n\t    data[i][a]=data[i][s]-tmp;\n\t    t[i][a]=true;\n\t    tm--;\n\t  }\n\t}\n      }\n\n      for(int j=0;j<=s;j++){\n\tint sum=0;\n\tint a;\n\tfor(int i=0;i<=p;i++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=i;\n\t  }\n\t}\n\tif(sum==1){\n\t  if(a==p){\n\t    int tmp=0;\n\t    for(int i=0;i<p;i++){\n\t      tmp+=data[i][j];\n\t    }\n\t    data[a][j]=tmp;\n\t  }\n\t  else{\n\t    flag=false;\n\t    end=false;\n\t    int tmp=0;\n\t    for(int i=0;i<p;i++){\n\t      if(i==a) continue;\n\t      tmp+=data[i][j];\n\t    }\n\t    data[a][j]=data[p][j]-tmp;\n\t    t[a][j]=true;\n\t    tm--;\n\t  }\n\t}\n      }\n      if(end) break;\n    }\n    if(flag) cout << \"NO\" << endl;\n    else{\n      for(int i=0;i<=p;i++){\n\tfor(int j=0;j<=s;j++){\n\t  if(t[i][j]) cout << data[i][j] << endl;\n\t}\n      }\n    }\n    kai=true;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int INF = 1e9;\n\nint H, W;\nbool f;\n\nvoid check(int y, int x, int py, int px, int total, vector< vector<int> > &v, vector<int> &h, vector<int> &w){\n  int sum = 0, ty, tx;\n  while(y < H - 1 && x < W - 1){\n    if(v[y][x] == INF) { ty = y; tx = x; }\n    else sum += v[y][x];\n    y += py; x += px;\n  }\n  v[ty][tx] = total - sum;\n  h[ty]--; w[tx]--;\n}\n\nvector< vector<int> > solve(vector< vector<int> > v, vector<int> &h, vector<int> &w){\n  int cnt = 0;\n  REP(i, H) REP(j, W) if(v[i][j] == INF) ++cnt;\n  while(cnt != 0){\n    bool flg = false;\n    REP(i, H) if(h[i] == 1) { check(i, 0, 0, 1, v[i][W - 1], v, h, w); --cnt; flg = true; }\n    REP(i, W) if(w[i] == 1) { check(0, i, 1, 0, v[H - 1][i], v, h, w); --cnt; flg = true; }\n    if(!flg) { return vector< vector<int> >(); }\n  }\n  f = true;\n  return v;\n}\n\nint main() {\n  while(cin >>H && H){\n    cin >>W;\n    ++H; ++W;\n    f = false;\n    vector< vector<int> > v(H, vector<int>(W));\n    vector<int> w(W, 0), h(H, 0);\n    REP(i, H){\n      REP(j, W){\n        string s; cin >>s;\n        if(s != \"?\") v[i][j] = atoi(s.c_str());\n        else { v[i][j] = INF; h[i]++; w[j]++; }\n      }\n    }\n    vector< vector<int> > ans = solve(v, h, w);\n    if(f) { REP(i, H) REP(j, W) if(v[i][j] == INF) cout <<ans[i][j] <<endl; }\n    else cout <<\"NO\" <<endl;\n    cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct dat {\n\tint px, py; string s;\n};\nbool operator<(const dat& d1, const dat& d2) {\n\tif (d1.px != d2.px) return d1.px < d2.px;\n\treturn d1.py < d2.py;\n}\nint H, W, z; string s[109][109];\nint main() {\n\twhile (cin >> H, H) {\n\t\tcin >> W; H++; W++;\n\t\tif (z++) cout << endl;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<dat> ret;\n\t\tfor (int i = 0; i <= 1000; i++) {\n\t\t\tfor (int j = 0; j < H - 1; j++) {\n\t\t\t\tint a = stoi(s[j][W - 1]), cnt = 0;\n\t\t\t\tfor (int k = 0; k < W - 1; k++) {\n\t\t\t\t\tif (s[j][k] != \"?\") a -= stoi(s[j][k]);\n\t\t\t\t\telse cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt == 1) {\n\t\t\t\t\tfor (int k = 0; k < W - 1; k++) {\n\t\t\t\t\t\tif (s[j][k] == \"?\") {\n\t\t\t\t\t\t\ts[j][k] = to_string(a);\n\t\t\t\t\t\t\tret.push_back(dat{ j, k, s[j][k] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < W - 1; j++) {\n\t\t\t\tint a = stoi(s[H - 1][j]), cnt = 0;\n\t\t\t\tfor (int k = 0; k < H - 1; k++) {\n\t\t\t\t\tif (s[k][j] != \"?\") a -= stoi(s[k][j]);\n\t\t\t\t\telse cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt == 1) {\n\t\t\t\t\tfor (int k = 0; k < H - 1; k++) {\n\t\t\t\t\t\tif (s[k][j] == \"?\") {\n\t\t\t\t\t\t\ts[k][j] = to_string(a);\n\t\t\t\t\t\t\tret.push_back(dat{ k, j, s[k][j] });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == \"?\") flag = false;\n\t\t\t}\n\t\t}\n\t\tif (!flag) cout << \"NO\" << endl;\n\t\telse {\n\t\t\tsort(ret.begin(), ret.end());\n\t\t\tfor (int i = 0; i < ret.size(); i++) cout << ret[i].s << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)v[C[i][j]];\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }\n  return true;\n}\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<P+1;i++){\n      for(int j=0;j<S+1;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    int k = 0;\n    for(int i=0;i<P+1;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f ) k++;\n    }\n\n    for(int j=0;j<S+1;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f ) k++;\n    }\n    \n\n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)v << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\tint cc=0;\n\twhile(cin>>p,p){\n\t\tif(cc){\n\t\t\tcout<<endl<<endl;\n\t\t}\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\nng_s:;\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tif(i==ans.size()-1){\n\t\t\t\t\tcout<<ans[i];\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\";\n\t\t}\n\t\tcc++;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconstexpr int UNKNOWN = (1 << 25);\n\nvoid solve(vector<vector<int>> &matrix) {\n  const int h = matrix.size();\n  const int w = matrix[0].size();\n\n  vector<vector<bool>> is_question(h - 1, vector<bool>(w - 1));\n  vector<pair<int, int>> questions; // r, c\n  vector<int> num_qr(h - 1, 0), num_qc(w - 1, 0);\n  vector<int> sum_r(h - 1, 0), sum_c(w - 1, 0);\n\n  for(int i = 0; i < h - 1; ++i) {\n    sum_r[i] += matrix[i][w - 1];\n  }\n\n  for(int i = 0; i < w - 1; ++i) {\n    sum_c[i] += matrix[h - 1][i];\n  }\n\n  for(int i = 0; i < h - 1; ++i) {\n    for(int j = 0; j < w - 1; ++j) {\n      if(matrix[i][j] == UNKNOWN) {\n\tquestions.emplace_back(i, j);\n\t++num_qr[i];\n\t++num_qc[j];\n\tis_question[i][j] = true;\n      }\n      else {\n\tsum_r[i] -= matrix[i][j];\n\tsum_c[j] -= matrix[i][j];\n      }\n    }\n  }\n\n  while(!questions.empty()) {\n    bool unloop = true;\n    int i = 0;\n\n    while(i < questions.size()) {\n      const int r = questions[i].first;\n      const int c = questions[i].second;\n\n      int value = UNKNOWN;\n      if(num_qr[r] == 1) {\n\tvalue = sum_r[r];\n      }\n      else if(num_qc[c] == 1) {\n\tvalue = sum_c[c];\n      }\n\n      if(value == UNKNOWN) {\n\t++i;\n\tcontinue;\n      }\n\n      matrix[r][c] = value;\n      sum_r[r] -= value;\n      sum_c[c] -= value;\n      --num_qr[r];\n      --num_qc[c];\n      unloop = false;\n      questions.erase(questions.begin() + i);\n    }\n\n    if(unloop) break;\n  }\n\n  if(questions.empty()) { // unique answer\n    for(int i = 0; i < h - 1; ++i) {\n      for(int j = 0; j < w - 1; ++j) {\n\tif(is_question[i][j]) {\n\t  cout << matrix[i][j] << endl;\n\t}\n      }\n    }\n  }\n  else {\n    cout << \"NO\" << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  for(int p, s; cin >> p >> s && p;) {\n    vector<vector<int>> matrix(p + 1, vector<int>(s + 1));\n    for(auto &row : matrix) {\n      for(auto &e : row) {\n\tstring input;\n\tcin >> input;\n\te = (input == \"?\" ? UNKNOWN : stoi(input));\n      }\n    }\n\n    solve(matrix);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tbool flag = false;\n\twhile (1) {\n\t\t\n\t\tint H, W;\n\t\tcin >> H;\n\t\tif (!H)break;\n\t\tcin >> W;\n\t\tif (!flag) {\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\tcout << endl;\n\t\t}\n\t\tvector<int>rs(H+1), cs(W+1);\n\t\tint unknown = 0;\n\t\tmap<pair<int, int>, int>mp;\n\t\tvector<vector<int>>field(H + 1, vector<int>(W + 1));\n\t\tfor (int i = 0; i < H + 1; ++i) {\n\t\t\tfor (int j = 0; j < W + 1; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tint num;\n\t\t\t\tif (st == \"?\") {\n\t\t\t\t\tnum = 1e8;\n\t\t\t\t\tmp[make_pair(i, j)] = unknown++;\n\t\t\t\t\trs[i]++;\n\t\t\t\t\tcs[j]++;\n\t\t\t\t}\n\t\t\t\telse num = stoi(st);\n\t\t\t\tfield[i][j] = num;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>que;\n\t\tfor (int y = 0; y <= H; ++y) {\n\t\t\tif (rs[y] == 1) {\n\t\t\t\tque.push(make_pair(1, y));\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tif (cs[x] == 1) {\n\t\t\t\tque.push(make_pair(0, x));\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tif (p.first) {\n\t\t\t\tconst int y = p.second;\n\t\t\t\tif (rs[y] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\t\t\t\tif (field[y][i] != 1e8) {\n\t\t\t\t\t\t\tsum += i!=W?field[y][i]:-field[y][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != W) {\n\t\t\t\t\t\tfield[y][place] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[y][place] = sum;\n\t\t\t\t\t}\n\t\t\t\t\trs[y]--;\n\t\t\t\t\tcs[place]--;\n\t\t\t\t\tif (cs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(0, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int x = p.second;\n\t\t\t\tif (cs[x] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\t\t\t\tif (field[i][x] != 1e8) {\n\t\t\t\t\t\t\tsum += i != H ? field[i][x] : -field[i][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != H) {\n\t\t\t\t\t\tfield[place][x] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[place][x] = sum;\n\t\t\t\t\t}\n\t\t\t\t\tcs[x]--;\n\t\t\t\t\trs[place]--;\n\t\t\t\t\tif (rs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(1, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tsum += field[i][j];\n\t\t\t}\n\t\t\tif (sum != field[i][W])ok = false;\n\t\t}\n\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < H; ++j)sum += field[j][i];\n\t\t\tif (sum != field[H][i])ok = false;\n\t\t}\n\t\tif (!ok)cout << \"NO\" << endl;\n\t\telse {\n\t\t\tfor (auto m : mp) {\n\t\t\t\tcout << field[m.first.first][m.first.second] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n\n  int num_of_rows,num_of_cols;\n  bool is_first = true;\n  while(~scanf(\"%d\",&num_of_rows)){\n    if(num_of_rows == 0) break;\n\n    scanf(\"%d\",&num_of_cols);\n    int table[101][101];\n    vector<P> masks;\n    for(int row = 0; row < num_of_rows + 1; row++){\n      for(int col = 0; col < num_of_cols + 1; col++){\n        char val[32];\n        scanf(\"%s\",val);\n        if(val[0] == '?'){\n          table[row][col] = 5000000;\n          masks.push_back(P(row,col));\n        }\n        else{\n          table[row][col] = atoi(val);\n        }\n      }\n    }\n\n    bool visited[101] = {};\n    for(int round = 0; round < 100; round++){\n      for(int mask_i = 0; mask_i < masks.size(); mask_i++){\n        if(visited[mask_i]) continue;\n\n        int masked_row = masks[mask_i].first;\n        int masked_col = masks[mask_i].second;\n        \n        int sum = 0;\n        for(int row = 0; row < num_of_rows; row++){\n          if(row == masked_row) continue;\n          sum += table[row][masked_col];\n        }\n        if(-10000 <= sum && sum <= 10000){\n          table[masked_row][masked_col] = table[num_of_rows][masked_col] - sum;\n          visited[mask_i] = true;\n          continue;\n        }\n        \n        sum = 0;\n        for(int col = 0; col < num_of_cols; col++){\n          if(col == masked_col) continue;\n          sum += table[masked_row][col];\n        }\n        if(-10000 <= sum && sum <= 10000){\n          table[masked_row][masked_col] = table[masked_row][num_of_cols] - sum;\n          visited[mask_i] = true;\n          continue;\n        }\n      }\n    }\n\n    bool isok = true;\n    for(int mask_i = 0; mask_i < masks.size(); mask_i++){\n      if(!visited[mask_i]){\n        isok = false;\n      }\n    }\n\n    if(!is_first){\n      printf(\"\\n\");\n    }\n\n    if(isok){\n      for(int mask_i = 0; mask_i < masks.size(); mask_i++){\n        int row = masks[mask_i].first;\n        int col = masks[mask_i].second;\n        printf(\"%d\\n\",table[row][col]);\n      }\n    }\n    else{\n      printf(\"NO\\n\");      \n    }\n    is_first = false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,q,ans[1000],na;\nint d[100][100],qn[100][100];\n\nint main()\n{\n\twhile(scanf(\"%d\",&h),h)\n\t{\n\t\tscanf(\"%d\",&w); w++; h++;\n\t\tna=q=0;\n\t\trep(i,h)rep(j,w)\n\t\t{\n\t\t\tchar in[9]; scanf(\"%s\",in);\n\t\t\tif(in[0]=='?')d[i][j]=inf,qn[i][j]=q++;\n\t\t\telse d[i][j]=atoi(in);\n\t\t}\n\t\t\n\t\tbool f=0;\n\t\twhile(na<q&&!f)\n\t\t{\n\t\t\tf=1;\n\t\t\trep(i,h-1)rep(j,w-1)if(d[i][j]==inf)\n\t\t\t{\n\t\t\t\tint s=0;\n\t\t\t\trep(k,h-1)if(i!=k)\n\t\t\t\t{\n\t\t\t\t\tif(d[k][j]==inf)goto FAIL1;\n\t\t\t\t\telse s+=d[k][j];\n\t\t\t\t}\n\t\t\t\td[i][j]=ans[qn[i][j]]=d[h-1][j]-s; na++;\n\t\t\t\tf=0;  continue; FAIL1:;\n\t\t\t\t\n\t\t\t\trep(k,w-1)if(j!=k)\n\t\t\t\t{\n\t\t\t\t\tif(d[i][k]==inf)goto FAIL2;\n\t\t\t\t\telse s+=d[i][k];\n\t\t\t\t}\n\t\t\t\td[i][j]=ans[qn[i][j]]=d[i][w-1]-s; na++;\n\t\t\t\tf=0; FAIL2:;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(na<q)puts(\"NO\");\n\t\telse rep(i,q)printf(\"%d\\n\",ans[i]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint toInt(string s){\n  stringstream ss;\n  ss << s;\n  int a;\n  ss >> a;\n  return a;\n}\n\nint main(){\n  int s,p;\n  bool flag = false;\n  while(cin >> p && p){\n    //    if(flag) cout << endl;\n    flag = true;\n    cin >> s;\n    s++,p++;\n    vector<vector<int> >v;\n    v.resize(p,vector<int>(s));\n    cin.ignore();\n\n    string str;\n    vector<pair<int,int> >pos;\n    int total = 0;\n    int r_hatena[p];\n    int c_hatena[s];\n    int r[p];\n    int c[s];\n\n    fill(r_hatena,r_hatena+p,0);\n    fill(c_hatena,c_hatena+s,0);\n    fill(r,r+p,0);\n    fill(c,c+s,0);\n\n    for(int i=0; i<p; i++){\n      for(int j=0; j<s; j++){\n\tcin >> str;\n\tif(str == \"?\"){\n\t  total++;\n\t  v[i][j] = INF;\n\t  pos.push_back(pair<int,int>(j,i));\n\t}\n\telse v[i][j] = toInt(str);\n      }\n    }\n\n\n    for(int i=0; i<p; i++){\n      int sum = 0;\n      for(int j=0; j<s; j++){\n\tif(v[i][j] == INF) c_hatena[j]++;\n\telse if(j != s-1) sum += v[i][j];\n      }\n      r[i] = sum;\n    }\n\n\n    for(int i=0; i<s; i++){\n      int sum = 0;\n      for(int j=0; j<p; j++){\n\tif(v[j][i] == INF) r_hatena[j]++;\n\telse if(j != p-1) sum += v[j][i];\n      }\n      c[i] = sum;\n    }\n\n\n    priority_queue<pair<bool,int>,vector<pair<bool,int> >,\n      greater<pair<bool,int> > >que;\n\n    for(int i=0; i<p; i++){\n      if(c_hatena[i] == 1){\n\tque.push(pair<bool,int>(true,i));\n      }\n\n    }\n\n    for(int i=0; i<s; i++){\n      if(r_hatena[i] == 1){\n\tque.push(pair<bool,int>(false,i));\n      }\n    }\n\n    for(int i=0; i<v.size(); i++){\n      for(int j=0; j<v[i].size(); j++){\n\t//\tcout << v[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n    //p tate s yoko\n    //0 is row 1 is column\n    while(!que.empty()){\n      pair<bool,int> tmp = que.top();\n      que.pop();\n\n      if(tmp.first == 0){\n\tif(r_hatena[tmp.second] <= 0)continue;\n\n\tfor(int i=0; i<s; i++){\n\t  if(v[tmp.second][i] == INF){\n\t    v[tmp.second][i] = v[tmp.second][s-1]-r[tmp.second];\n\t    //\t    cout << v[tmp.second][s-1] << endl;\n\t    //\t    cout << r[tmp.second] << endl;\n\t    r_hatena[tmp.second]--;\n\t    c_hatena[i]--;\n\t    //\t    cout << tmp.second << \" \" << i << endl;\n\t    total--;\n\t    c[i] += v[tmp.second][i];\n\t    if(c_hatena[i] == 1)\n\t      que.push(pair<bool,int>(1,i));\n\t  }\n\t}\n\n\n\n\n\n      } else {\n\tif(c_hatena[tmp.second] <= 0)continue;\n\tfor(int i=0; i<p; i++){\n\t  if(v[i][tmp.second] == INF){\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    v[i][tmp.second] = v[p-1][tmp.second]-c[tmp.second];\n\t    c_hatena[tmp.second]--;\n\t    r_hatena[i]--;\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    //\t    cout << c_hatena[tmp.second] << endl;\n\t    //\t    cout << r_hatena[i] << endl;\n\t    r[i] += v[i][tmp.second];\n\t    total--;\n\t    if(r_hatena[i] == 1)\n\t      que.push(pair<bool,int>(0,i));\n\t    //\t    cout << v[i][tmp.second] << endl;\n\t  }\n\t}\n\n      }\n\n\n\n\n\n\n    }\n\n    \n\n    if(total <= 0){\n      for(int i=0; i<pos.size(); i++){\n\tint x = pos[i].first;\n\tint y = pos[i].second;\n\tcout << v[y][x] << endl;\n      }\n    } else cout << \"NO\" << endl;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define COL 101\n#define ROW 11\n#define UNK (1<<23)\n\nusing namespace std;\n\nstruct unknown_val{\n\tint val;\n\tpair<int,int> place;\n\tbool operator<(const unknown_val &t)const{\n\t\tif( place.first < t.place.first )\n\t\t\treturn true;\n\t\telse if( place.first == t.place.first ){\n\t\t\treturn place.second < t.place.second;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\tbool bFirst=true;\n\n\twhile(true){\n\t\tint p,s;\n\t\tint val[COL][ROW] = {{0,},};\n\t\tint unknown_cnt = 0;\n\t\tvector<unknown_val> vans;\n\t\tcin>>p;\n\t\tif(p==0)break;\n\t\tcin>>s;\n\n\t\tif( !bFirst )\n\t\t\tcout << endl;\n\t\telse\n\t\t\tbFirst = false;\n\t\t\n\t\tcin.ignore();\n\t\tfor(int i = 0; i < p + 1; ++i){\n\t\t\tfor(int j = 0; j < s + 1; ++j){\n\t\t\t\t//cout << i << \" P: \" << p << endl;\n\t\t\t\tint c = cin.peek();\n\t\t\t\t//cout << c << endl;\n\t\t\t\tif( c == '?' ){\n\t\t\t\t\t//cout << \"true\"<<endl;\n\t\t\t\t\tcin.ignore();cin.ignore();\n\t\t\t\t\tval[i][j]=UNK;\n\t\t\t\t\t++unknown_cnt;\n\t\t\t\t}else{\n\t\t\t\t\tcin>>val[i][j];\n\t\t\t\t\tcin.ignore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bDecreased=false;\n\n\t\t\tfor(int i = 0; i < p; ++i){\n\t\t\t\tint unk_cnt = 0;\n\t\t\t\tint sum_row = 0;\n\t\t\t\tint unk_row = -1;\n\t\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\t\tif( val[i][j] == UNK ){\n\t\t\t\t\t\t++unk_cnt;\n\t\t\t\t\t\tunk_row = j;\n\t\t\t\t\t}else\n\t\t\t\t\t\tsum_row += val[i][j];\n\t\t\t\t}\n\t\t\t\tif( unk_cnt == 1 ){\n\t\t\t\t\tval[i][ unk_row ] = val[i][s] - sum_row;\n\t\t\t\t\tunknown_val t;\n\t\t\t\t\tt.place = make_pair( i, unk_row );\n\t\t\t\t\tt.val = val[i][unk_row];\n\t\t\t\t\tvans.push_back( t );\n\t\t\t\t\tbDecreased=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < s; ++i){\n\t\t\t\tint unk_cnt = 0;\n\t\t\t\tint sum_col = 0;\n\t\t\t\tint unk_col = -1;\n\t\t\t\tfor(int j = 0; j < p; ++j){\n\t\t\t\t\tif( val[j][i] == UNK ){\n\t\t\t\t\t\t++unk_cnt;\n\t\t\t\t\t\tunk_col = j;\n\t\t\t\t\t}else\n\t\t\t\t\t\tsum_col += val[j][i];\n\t\t\t\t}\n\t\t\t\tif( unk_cnt == 1 ){\n\t\t\t\t\tval[ unk_col ][ i ] = val[p][i] - sum_col;\n\t\t\t\t\tunknown_val t;\n\t\t\t\t\tt.place = make_pair( unk_col, i );\n\t\t\t\t\tt.val = val[unk_col][i];\n\t\t\t\t\tvans.push_back( t );\n\t\t\t\t\tbDecreased=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( !bDecreased )\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif( vans.size() == unknown_cnt ){\n\t\t\tsort( vans.begin(), vans.end() );\n\t\t\tfor(unsigned int i = 0; i < vans.size(); ++i){\n\t\t\t\tcout << vans[i].val << endl;\n\t\t\t}\n\t\t}else\n\t\t\tcout << \"NO\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 105\n#define INF (1e9)\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\n\nint a[MAX][MAX];\nvector<int> vx,vy;\nint H,W;\nstring str;\n\nbool solve(int id){\n  int y=vy[id],x=vx[id];\n  int ch=0,cw=0,sh=0,sw=0;\n  for(int i=0;i<H;i++){\n    if(a[i][x]==INF)continue;\n    ch++;\n    sh+=a[i][x];\n  }\n  if(ch==H-1){\n    a[y][x]=a[H][x]-sh;\n    return true;\n  }\n\n  for(int i=0;i<W;i++){\n    if(a[y][i]==INF)continue;\n    cw++;\n    sw+=a[y][i];\n  }\n  if(cw==W-1){\n    a[y][x]=a[y][W]-sw;\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  int Tc=0;\n  while(1){\n    \n    cin>>H;\n    if(H==0)break;\n    if(Tc!=0)cout<<endl;\n    Tc++;\n\n    cin>>W;\n    vx.clear();\n    vy.clear();\n    for(int i=0;i<=H;i++){\n      for(int j=0;j<=W;j++){\n        cin>>str;\n        if(str==\"?\"){\n          a[i][j]=INF;\n          vy.push_back(i);\n          vx.push_back(j);\n        }else a[i][j]=s2i(str);\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=0;i<(int)vx.size();i++){\n        if(a[vy[i]][vx[i]]==INF)\n          update|=solve(i);\n      }\n    }\n    vector<int> ans;\n    for(int i=0;i<(int)vx.size();i++)\n      if(a[vy[i]][vx[i]]!=INF)\n        ans.push_back(a[vy[i]][vx[i]]);\n    if(ans.size()!=vx.size())cout<<\"NO\"<<endl;\n    else{\n      for(int i=0;i<(int)ans.size();i++)cout<<ans[i]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n  \n  bitset<111> ss1,ss2;\n  for(int i=0;i<=P;i++){\n    for(int j=0;j<=S;j++){\n      if( C[i][j] != -1 ) {\n        X[i][j] = (int)round(v[C[i][j]]);\n        ss1[i] = ss2[j] = 1;\n      }\n    }\n  }\n  for(int i=0;i<=P;i++){\n    if( !ss1[i] ) continue;\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    if( !ss2[j] ) continue;\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[i][S];\n      //assert( !(!f && !V[k]) );\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[P][j];\n\n      //assert( !(!f && !V[k]) );\n      \n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\tint newline=0;\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tif(newline)cout<<endl;\n\t\tnewline=1;\n\t\tfill(sumV,sumV+s+1,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(c[0]=='?'){\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint ans[1011]={},no=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\ttable[i][j]=0;\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\ttable[i][j]=0;\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tno=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(no)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int f=0,g,i,j;\n  int w,h;\n  while(cin>>h&&h){\n    cin>>w;\n    string s[101][101];\n    int a[101][101];\n    int n=0;\n    for(i=0;i<h+1;i++){\n      for(j=0;j<w+1;j++){\n\tcin>>s[j][i];\n\tif(s[j][i]==\"?\")\n\t  n++;\n      }\n    }\n    \n\n    do{\n      g=0;\n      for(i=0;i<h;i++){\n\tint sm=0;\n\tint ct=0;\n\tfor(j=0;j<w;j++){\n\t  if(0){\n\t  }else if(s[j][i]==\"!\"){\n\t    sm+=a[j][i];\n\t  }else if(s[j][i]==\"?\"){\n\t    ct++;\n\t  }else{\n\t    sm+=atoi(s[j][i].c_str());\n\t  }\n\t}\n\tif(ct==1){\n\t  for(j=0;s[j][i]!=\"?\";j++);\n\t  a[j][i]=atoi(s[w][i].c_str())-sm;\n\t  s[j][i]=\"!\";\n\t  n--;\n\t  g=1;\n\t}\n      }\n      for(i=0;i<w;i++){\n\tint sm=0;\n\tint ct=0;\n\tfor(j=0;j<h;j++){\n\t  if(0){\n\t  }else if(s[i][j]==\"!\"){\n\t    sm+=a[i][j];\n\t  }else if(s[i][j]==\"?\"){\n\t    ct++;\n\t  }else{\n\t    sm+=atoi(s[i][j].c_str());\n\t  }\n\t}\n\tif(ct==1){\n\t  for(j=0;s[i][j]!=\"?\";j++);\n\t  a[i][j]=atoi(s[i][h].c_str())-sm;\n\t  s[i][j]=\"!\";\n\t  n--;\n\t  g=1;\n\t}\n      }  \n    }while(n&&g);\n    if(f)\n      cout<<endl;\n    else\n      f=1;\n    if(n){\n      cout<<\"NO\"<<endl;\n    }else{\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(s[j][i]==\"!\")\n\t    cout<<a[j][i]<<endl;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int R,C;\n  while(cin>>R>>C){\n    int data[101][101];\n    vector<P> fout;\n    REP(y,R+1)REP(x,C+1){\n      string s; cin>>s;\n      if(s == \"?\") {\n        data[y][x] = -1;\n        fout.push_back(P(x,y));\n      } else {\n        data[y][x] = atoi(s.c_str());\n      }\n    }\n    while(true){\n      bool updata = false;\n      int ndata[101][101];\n      memcpy(ndata,data,sizeof(data));\n      REP(y,R+1){\n        int cnt = 0;\n        REP(x,C+1)if(data[y][x]==-1)cnt++;\n        if(cnt == 1){\n          updata = true;\n          int sum = 0;\n          REP(x,C+1)if(data[y][x]!=-1)sum += ((x==C)?1:-1) * data[y][x];\n          REP(x,C+1)if(data[y][x]==-1)ndata[y][x] = ((x==C)?-1:1) * sum;\n        }\n      }\n      REP(x,C+1){\n        int cnt = 0;\n        REP(y,R+1)if(data[y][x]==-1)cnt++;\n        if(cnt == 1){\n          updata = true;\n          int sum = 0;\n          REP(y,R+1)if(data[y][x]!=-1)sum += ((y==R)?1:-1) * data[y][x];\n          REP(y,R+1)if(data[y][x]==-1)ndata[y][x] = ((y==R)?-1:1) * sum;\n        }\n      }\n      memcpy(data, ndata, sizeof(data));\n      if(!updata) break;\n    }\n    int cnt = 0;\n    REP(y,R+1)REP(x,C+1)if(data[y][x]==-1) cnt++;\n    if(cnt > 0) cout<<\"NO\"<<endl;\n    else {\n      REP(i, fout.size()){\n        cout<<data[fout[i].second][fout[i].first]<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){  \n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 )\n        X[i][j] = (int)round(v[C[i][j]]);  \n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){    \n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    if( k < cnt ){\n      for(int i=0;i<P;i++)\n        for(int j=0;j<S;j++){\n          if( C[i][j] != -1 ) M[k][C[i][j]] = 1;\n          else V[k] -= X[i][j];\n        }\n      V[k] += X[P][S];\n      k++;\n    }\n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n\nusing namespace std;\n\nint p,s;\nconst int QST=1000000000;\nint table[201][21];\nint origTable[201][21];\n\nint main(){\n  while(cin>>p&&p){\n    int cnt=0;\n    cin>>s;\n    string str;\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tcin>>str;\n\tif(str[0]=='?'){\n\t  table[i][j]=QST;\n\t  origTable[i][j]=table[i][j];\n\t  cnt++;\n\t}\n\telse{\n\t  int num=atoi(str.c_str());\n\t  table[i][j]=num;\n\t  origTable[i][j]=table[i][j];\n\t}\n      }\n    }\n    bool update=true,isFail=false;\n    while(update){\n      update=false;\n      for(int i=0;i<=p;i++){\n\tint c=0;\n\tint last=-1;\n\tfor(int j=0;j<=s;j++){\n\t  if(table[i][j]==QST){\n\t    c++;\n\t    last=j;\n\t  }\n\t}\n\tif(c==1){\n\t  int sum=0;\n\t  if(last==s){\n\t    for(int j=0;j<s;j++)sum+=table[i][j];\n\t    table[i][last]=sum;\n\t  }\n\t  else{\n\t    sum=table[i][s];\n\t    for(int j=0;j<s;j++)if(table[i][j]!=QST)sum-=table[i][j];\n\t    table[i][last]=sum;\n\t  }\n\t  cnt--;\n\t  update=true;\n\t  break;\n\t}\n      }\n      for(int j=0;j<=s;j++){\n\tint c=0;\n\tint last=-1;\n\tfor(int i=0;i<=p;i++){\n\t  if(table[i][j]==QST){\n\t    c++;\n\t    last=i;\n\t  }\n\t}\n\tif(c==1){\n\t  int sum=0;\n\t  if(last==p){\n\t    for(int i=0;i<p;i++)sum+=table[i][j];\n\t    table[last][j]=sum;\n\t  }\n\t  else{\n\t    sum=table[p][j];\n\t    for(int i=0;i<p;i++)if(table[i][j]!=QST)sum-=table[i][j];\n\t    table[last][j]=sum;\n\t  }\n\t  cnt--;\n\t  update=true;\n\t  break;\n\t}\n      }\n      if(cnt>0&&!update){\n\tisFail=true;\n\tbreak;\n      }\n      // 矛盾が起きてるかどうかを調べる\n      for(int i=0;i<=p;i++){\n\tint sum=0;\n\tbool ok=true;\n\tfor(int j=0;j<=s;j++){\n\t  if(table[i][j]==QST){\n\t    ok=false;break;\n\t  }\n\t  else if(j!=s)sum+=table[i][j];\n\t}\n\t// fail\n\tif(!ok)continue;\n\t// 全部埋まってる\n\tif(sum!=table[i][s]){\n\t  update=false;\n\t  isFail=true;\n\t  break;\n\t}\n      }\n      for(int j=0;j<=s;j++){\n\tint sum=0;\n\tbool ok=true;\n\tfor(int i=0;i<=p;i++){\n\t  if(table[i][j]==QST){\n\t    ok=false;break;\n\t  }\n\t  else if(i!=p)sum+=table[i][j];\n\t}\n\t// fail\n\tif(!ok)continue;\n\tif(!(sum==table[p][j])){\n\t  update=false;\n\t  isFail=true;\n\t  break;\n\t}\n      }\n    }\n    if(isFail)cout<<\"NO\"<<endl;\n    else{\n      for(int i=0;i<=p;i++)\n\tfor(int j=0;j<=s;j++)\n\t  if(origTable[i][j]==QST)\n\t    cout<<table[i][j]<<endl;\n    }\n    cout<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint P,S,outPut_count = 0;\nint hatena_num_row[101],hatena_num_col[11];\n\nstruct Info{\n\tint row,col;\n\tbool isProved;\n\tll value;\n};\n\nInfo info[1111];\n\nll getNUM(char buf[10]){\n\tif(buf[0] == '?')return BIG_NUM;\n\n\tbool negFLG = false;\n\tint start;\n\n\tif(buf[0] == '-'){\n\t\tnegFLG = true;\n\t\tstart = 1;\n\t}else{\n\t\tstart = 0;\n\t}\n\n\tint ret = 0;\n\n\tfor(int i = start; buf[i] != '\\0'; i++){\n\t\tret = 10*ret + (buf[i]-'0');\n\t}\n\n\tif(negFLG) return -1*ret;\n\telse{\n\t\treturn ret;\n\t}\n}\n\nvoid func(){\n\n\tll table[P+1][S+1];\n\tll tmp;\n\tint hatena_count = 0;\n\n\tfor(int i = 0; i <= S; i++)hatena_num_col[i] = 0;\n\tfor(int i = 0; i <= P; i++)hatena_num_row[i] = 0;\n\n\tfor(int i = 0; i < 1111; i++){\n\t\tinfo[i].isProved = false;\n\t}\n\n\tchar buf[10];\n\n\tfor(int row = 0; row <= P; row++){\n\t\tfor(int col = 0; col <= S; col++){\n\n\t\t\tscanf(\"%s\",buf);\n\t\t\ttmp = getNUM(buf);\n\n\t\t\tif(tmp == BIG_NUM){\n\t\t\t\tinfo[hatena_count].row = row;\n\t\t\t\tinfo[hatena_count].col = col;\n\t\t\t\thatena_num_row[row]++;\n\t\t\t\thatena_num_col[col]++;\n\n\t\t\t\thatena_count++;\n\t\t\t}\n\t\t\ttable[row][col] = tmp;\n\t\t}\n\t}\n\n\tbool FLG;\n\n\tint total,sum,ans_count = hatena_count;\n\n\twhile(hatena_count > 0){\n\n\t\tFLG = false;\n\n\t\tfor(int i = 0; i < ans_count; i++){\n\t\t\tif(info[i].isProved)continue;\n\n\t\t\tif(hatena_num_row[info[i].row] == 1){\n\t\t\t\ttotal = table[info[i].row][S];\n\t\t\t\tsum = 0;\n\t\t\t\tfor(int col = 0; col <= S-1; col++){\n\t\t\t\t\tif(col == info[i].col)continue;\n\n\t\t\t\t\tsum += table[info[i].row][col];\n\t\t\t\t}\n\t\t\t\ttable[info[i].row][info[i].col] = total-sum;\n\n\t\t\t\tinfo[i].value = table[info[i].row][info[i].col];\n\t\t\t\tinfo[i].isProved = true;\n\t\t\t\thatena_num_row[info[i].row]--;\n\t\t\t\thatena_num_col[info[i].col]--;\n\t\t\t\thatena_count--;\n\t\t\t\tFLG = true;\n\t\t\t}else if(hatena_num_col[info[i].col] == 1){\n\t\t\t\ttotal = table[P][info[i].col];\n\t\t\t\tsum = 0;\n\t\t\t\tfor(int row = 0; row <= P-1; row++){\n\t\t\t\t\tif(row == info[i].row)continue;\n\n\t\t\t\t\tsum += table[row][info[i].col];\n\t\t\t\t}\n\t\t\t\ttable[info[i].row][info[i].col] = total-sum;\n\n\t\t\t\tinfo[i].value = table[info[i].row][info[i].col];\n\t\t\t\tinfo[i].isProved = true;\n\t\t\t\thatena_num_row[info[i].row]--;\n\t\t\t\thatena_num_col[info[i].col]--;\n\t\t\t\thatena_count--;\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t}\n\n\tif(outPut_count > 0)printf(\"\\n\");\n\n\tif(hatena_count > 0){\n\t\tprintf(\"NO\\n\");\n\t}else{\n\t\tfor(int i = 0; i < ans_count; i++){\n\t\t\tprintf(\"%lld\\n\",info[i].value);\n\t\t}\n\t}\n\toutPut_count++;\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&P,&S);\n\t\tif(P == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint toInt(string s){\n  stringstream ss;\n  ss << s;\n  int a;\n  ss >> a;\n  return a;\n}\n\nint main(){\n  int s,p;\n  bool flag = false;\n  while(cin >> p && p){\n    if(flag) cout << endl;\n    flag = true;\n    cin >> s;\n    s++,p++;\n    vector<vector<int> >v;\n    v.resize(p,vector<int>(s));\n    cin.ignore();\n\n    string str;\n    vector<pair<int,int> >pos;\n    int total = 0;\n    int r_hatena[s];\n    int c_hatena[p];\n    int r[s];\n    int c[p];\n\n    fill(r_hatena,r_hatena+p,0);\n    fill(c_hatena,c_hatena+s,0);\n    fill(r,r+p,0);\n    fill(c,c+s,0);\n\n    for(int i=0; i<p; i++){\n      for(int j=0; j<s; j++){\n\tcin >> str;\n\tif(str == \"?\"){\n\t  total++;\n\t  v[i][j] = INF;\n\t  pos.push_back(pair<int,int>(j,i));\n\t}\n\telse v[i][j] = toInt(str);\n      }\n    }\n\n\n    for(int i=0; i<p; i++){\n      int sum = 0;\n      for(int j=0; j<s; j++){\n\tif(v[i][j] == INF) c_hatena[j]++;\n\telse if(j != s-1) sum += v[i][j];\n      }\n      r[i] = sum;\n    }\n\n\n    for(int i=0; i<s; i++){\n      int sum = 0;\n      for(int j=0; j<p; j++){\n\tif(v[j][i] == INF) r_hatena[j]++;\n\telse if(j != p-1) sum += v[j][i];\n      }\n      c[i] = sum;\n    }\n\n\n    priority_queue<pair<bool,int>,vector<pair<bool,int> >,\n      greater<pair<bool,int> > >que;\n\n    for(int i=0; i<p; i++){\n      if(c_hatena[i] == 1){\n\tque.push(pair<bool,int>(true,i));\n      }\n\n    }\n\n    for(int i=0; i<s; i++){\n      if(r_hatena[i] == 1){\n\tque.push(pair<bool,int>(false,i));\n      }\n    }\n\n    for(int i=0; i<v.size(); i++){\n      for(int j=0; j<v[i].size(); j++){\n\t//\tcout << v[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n    //p tate s yoko\n    //0 is row 1 is column\n    while(!que.empty()){\n      pair<bool,int> tmp = que.top();\n      que.pop();\n\n      if(tmp.first == 0){\n\tif(r_hatena[tmp.second] <= 0)continue;\n\n\tfor(int i=0; i<s; i++){\n\t  if(v[tmp.second][i] == INF){\n\t    v[tmp.second][i] = v[tmp.second][s-1]-r[tmp.second];\n\t    //\t    cout << v[tmp.second][s-1] << endl;\n\t    //\t    cout << r[tmp.second] << endl;\n\t    r_hatena[tmp.second]--;\n\t    c_hatena[i]--;\n\t    //\t    cout << tmp.second << \" \" << i << endl;\n\t    total--;\n\t    c[i] += v[tmp.second][i];\n\t    if(c_hatena[i] == 1)\n\t      que.push(pair<bool,int>(1,i));\n\t  }\n\t}\n\n\n\n\n\n      } else {\n\tif(c_hatena[tmp.second] <= 0)continue;\n\tfor(int i=0; i<p; i++){\n\t  if(v[i][tmp.second] == INF){\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    v[i][tmp.second] = v[p-1][tmp.second]-c[tmp.second];\n\t    c_hatena[tmp.second]--;\n\t    r_hatena[i]--;\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    //\t    cout << c_hatena[tmp.second] << endl;\n\t    //\t    cout << r_hatena[i] << endl;\n\t    r[i] += v[i][tmp.second];\n\t    total--;\n\t    if(r_hatena[i] == 1)\n\t      que.push(pair<bool,int>(0,i));\n\t    //\t    cout << v[i][tmp.second] << endl;\n\t  }\n\t}\n\n      }\n\n\n\n\n\n\n    }\n\n    \n\n    if(total <= 0){\n      for(int i=0; i<pos.size(); i++){\n\tint x = pos[i].first;\n\tint y = pos[i].second;\n\tcout << v[y][x] << endl;\n      }\n    } else cout << \"NO\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n#define INF 1 << 28\n\nstring to_s(int n) {\n    ostringstream oss;\n    oss << n;\n    return oss.str();\n}\n\nint to_i(string s) {\n    int n;\n    istringstream is;\n    is.str(s);\n    is >> n;\n    return n;\n}\n\nint main() {\n    int h, w;\n    bool nikaime = false;\n    while (cin >> h >> w) {\n        int field[h+1][w+1];\n        string s;\n        vector<pair<int, int> > unknown; \n        for (int i = 0; i < h+1; i++) {\n            for (int j = 0; j < w+1; j++) {\n                cin >> s;\n                if (s == \"?\") {\n                    field[i][j] = INF;\n                    unknown.push_back(pair<int,int>(i, j));\n                } else {\n                    field[i][j] = to_i(s);\n                }\n            }\n        }\n\n        for (int k = 0; k < 100; k++) {\n        int unknown_x;\n        for (int i = 0; i < h; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == INF) {\n                    unknown_count++;\n                    unknown_x = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < w; j++) {\n                    if (j != unknown_x) {\n                        sum += field[i][j];\n                    }\n                }\n                field[i][unknown_x] = field[i][w] - sum;\n            }\n        }\n                    \n        int unknown_y;\n        for (int i = 0; i < w; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < h; j++) {\n                if (field[j][i] == INF) {\n                    unknown_count++;\n                    unknown_y = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < h; j++) {\n                    if (j != unknown_y) {\n                        sum += field[j][i];\n                    }\n                }\n                field[unknown_y][i] = field[h][i] - sum;\n            }\n        }\n        }\n\n//        int unknown_x;\n//        for (int i = 0; i < h; i++) {\n//            int unknown_count = 0;\n//            for (int j = 0; j < w; j++) {\n//                if (field[i][j] == INF) {\n//                    unknown_count++;\n//                    unknown_x = j;\n//                }\n//            }\n//            if (unknown_count == 1) {\n//                int sum = 0;\n//                for (int j = 0; j < w; j++) {\n//                    if (j != unknown_x) {\n//                        sum += field[i][j];\n//                    }\n//                }\n//                field[i][unknown_x] = field[i][w] - sum;\n//            }\n//        }\n\n        string ans;\n        for (int i = 0; i < unknown.size(); i++) {\n            if (field[unknown[i].first][unknown[i].second] == INF) {\n                ans = \"NO\\n\";\n            } else {\n                ans += to_s(field[unknown[i].first][unknown[i].second]);\n                ans += \"\\n\";\n            }\n        }\n\n        if (nikaime) {\n            cout << endl;\n        }\n\n        cout << ans;\n\n        nikaime = true;\n \n//        for (int i = 0; i < h+1; i++) {\n//            for (int j = 0; j < w+1; j++) {\n//                if (field[i][j] == INF) {\n//                    cout << \"x \";\n//                } else {\n//                    cout << field[i][j] << ' ';\n//                }\n//            }\n//            cout << endl;\n//        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nconst int INF = (1<<29);\nint main(){\n  int P,S;\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    int cnt = 0;\n    for(int i=0;i<P+1;i++){\n      for(int j=0;j<S+1;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    int k = 0;\n    for(int i=0;i<P+1;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f ) k++;\n    }\n\n    for(int j=0;j<S+1;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f ) k++;\n    }\n\n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      for( double v : res ){      \n        cout << (int)v << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint p, s;\nchar row[10];\nint a[128][128], b[128][128];\n\nint main(){\n  bool outf = 0;\n  while(scanf(\"%d\", &p) && p){\n    scanf(\"%d\", &s);\n    rep(i, 128) rep(j, 128) a[i][j] = INF;\n    memset(b, 0, sizeof(b));\n    rep(i, p+1) rep(j, s+1){\n      scanf(\"%s\", row);\n      if(row[0] == '?'){\n\tb[i][j] = -1;\n\tcontinue;\n      }\n      a[i][j] = atoi(row);\n    }\n\n   int c, sum, point;\n    bool f = true;\n    while(f){\n      f = false;\n      rep(i, p){\n\tc = 0;\n\trep(j, s) if(a[i][j] == INF){ c++; point = j;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(j, s) if(a[i][j] != INF) sum += a[i][j];\n\ta[i][point] = a[i][s] - sum;\n\t//\tprintf(\"%d %d\\n\", i, point);\n      }\n      rep(j, s){\n\tc = 0;\n\trep(i, p) if(a[i][j] == INF){ c++; point = i;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(i, p) if(a[i][j] != INF) sum += a[i][j];\n\ta[point][j] = a[p][j] - sum;\n\t//\tprintf(\"%d %d\\n\",  point, j);\n      }\n    }\n    //    fprintf(stderr, \"end\\n\");\n    if(outf){\n      puts(\"\");\n    }\n    outf = 1;\n    rep(i, p) rep(j, s) if(a[i][j] == INF) f = 1;\n    if(f){\n      puts(\"NO\");\n    }else{\n      rep(i, p) rep(j, s) if(b[i][j] == -1) printf(\"%d\\n\", a[i][j]);\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\tint cc=0;\n\twhile(cin>>p,p){\n\t\tif(cc){\n\t\t\tcout<<endl<<endl;\n\t\t}\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\t{\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\t\t\t\tgoto ng_p;\n\t\t\t\t}\nng_s:;\n\t {\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\t }\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tif(i==ans.size()-1){\n\t\t\t\t\tcout<<ans[i];\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\";\n\t\t}\n\t\tcc++;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,d[100][100];\nint nq,q[100][100];\n\nint main()\n{\n\twhile(scanf(\"%d\",&h),h)\n\t{\n\t\tscanf(\"%d\",&w); w++; h++;\n\t\tnq=0;\n\t\trep(i,h)rep(j,w)\n\t\t{\n\t\t\tchar in[9]; scanf(\"%s\",in);\n\t\t\tif(in[0]=='?')d[i][j]=inf,q[i][j]=1,nq++;\n\t\t\telse d[i][j]=atoi(in),q[i][j]=0;\n\t\t}\n\t\t\n\t\tbool f=0;\n\t\twhile(nq&&!f)\n\t\t{\n\t\t\tf=1;\n\t\t\trep(i,h-1)\n\t\t\t{\n\t\t\t\tint p=-1,sum=0;\n\t\t\t\trep(j,w-1)\n\t\t\t\t{\n\t\t\t\t\tif(d[i][j]==inf)p=p==-1?j:-2;\n\t\t\t\t\telse sum+=d[i][j];\n\t\t\t\t}\n\t\t\t\tif(p>=0)\n\t\t\t\t{\n\t\t\t\t\td[i][p]=d[i][w-1]-sum;\n\t\t\t\t\tnq--; f=0; goto NEXT;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w-1)\n\t\t\t{\n\t\t\t\tint p=-1,sum=0;\n\t\t\t\trep(i,h-1)\n\t\t\t\t{\n\t\t\t\t\tif(d[i][j]==inf)p=p==-1?i:-2;\n\t\t\t\t\telse sum+=d[i][j];\n\t\t\t\t}\n\t\t\t\tif(p>=0)\n\t\t\t\t{\n\t\t\t\t\td[p][j]=d[h-1][j]-sum;\n\t\t\t\t\tnq--; f=0; goto NEXT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNEXT:;\n\t\t}\n\t\t\n\t\tif(nq)puts(\"NO\");\n\t\telse rep(i,h)rep(j,w)if(q[i][j])printf(\"%d\\n\",d[i][j]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int MISSING = 0x7fffffff;\n\nint main(){\n\tbool first = true;\n\twhile(true){\n\t\tint p, s;\n\t\tcin >> p;\n\t\tif(p == 0){ break; }\n\t\tif(!first){ cout << endl; }\n\t\tfirst = false;\n\t\tcin >> s;\n\t\tvector< vector<int> > table(p + 1, vector<int>(s + 1));\n\t\tvector< vector<bool> > missing(p, vector<bool>(s));\n\t\tfor(int i = 0; i <= p; ++i){\n\t\t\tfor(int j = 0; j <= s; ++j){\n\t\t\t\tstring item;\n\t\t\t\tcin >> item;\n\t\t\t\tif(item == \"?\"){\n\t\t\t\t\ttable[i][j] = MISSING;\n\t\t\t\t\tmissing[i][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttable[i][j] = atoi(item.c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pii> q;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){ table[i][pos] = table[i][s] - sum; }\n\t\t}\n\t\tfor(int i = 0; i < s; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < p; ++j){\n\t\t\t\tif(table[j][i] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){\n\t\t\t\ttable[pos][i] = table[p][i] - sum;\n\t\t\t\tq.push(pii(0, pos));\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tpii e = q.front();\n\t\t\tq.pop();\n\t\t\tif(e.first == 0){\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < s; ++i){\n\t\t\t\t\tif(table[e.second][i] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[e.second][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[e.second][pos] = table[e.second][s] - sum;\n\t\t\t\t\tq.push(pii(1, pos));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < p; ++i){\n\t\t\t\t\tif(table[i][e.second] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[i][e.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[pos][e.second] = table[p][e.second] - sum;\n\t\t\t\t\tq.push(pii(0, pos));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool valid = true;\n\t\tvector<int> answer;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\tvalid = false;\n\t\t\t\t}else if(missing[i][j]){\n\t\t\t\t\tanswer.push_back(table[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!valid){\n\t\t\tcout << \"NO\" << endl;\n\t\t}else{\n\t\t\tfor(int i = 0; i < answer.size(); ++i){\n\t\t\t\tcout << answer[i] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int R,C;\n  bool f = false;\n  while(cin>>R>>C){\n    if(f) cout<<endl;\n    else f = true;\n    int data[101][101];\n    int cntx[101]={};\n    int cnty[101]={};\n    vector<P> fout;\n    REP(y,R+1)REP(x,C+1){\n      string s; cin>>s;\n      if(s == \"?\") {\n        data[y][x] = -INF;\n        fout.push_back(P(x,y));\n        cntx[x]++;\n        cnty[y]++;\n      } else {\n        data[y][x] = atoi(s.c_str());\n      }\n    }\n    while(true){\n      bool updata = false;\n      REP(y,R+1){\n        if(cnty[y] == 1){\n          updata = true;\n          int sum = 0;\n          REP(x,C+1)if(data[y][x]!=-INF)sum += ((x==C)?1:-1) * data[y][x];\n          REP(x,C+1)if(data[y][x]==-INF){\n            data[y][x] = ((x==C)?-1:1) * sum;\n            cntx[x]--;\n            cnty[y]--;\n          }\n        }\n      }\n      REP(x,C+1){\n        if(cntx[x] == 1){\n          cntx[x] = 0;\n          updata = true;\n          int sum = 0;\n          REP(y,R+1)if(data[y][x]!=-INF)sum += ((y==R)?1:-1) * data[y][x];\n          REP(y,R+1)if(data[y][x]==-INF){\n            data[y][x] = ((y==R)?-1:1) * sum;\n            cntx[x]--;\n            cnty[y]--;\n          }\n        }\n      }\n      if(!updata) break;\n    }\n    int cnt = 0;\n    REP(y,R+1)REP(x,C+1)if(data[y][x]==-INF) cnt++;\n    if(cnt > 0) cout<<\"NO\"<<endl;\n    else {\n      REP(i, fout.size()){\n        cout<<data[fout[i].second][fout[i].first]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    const int INF = 10000000;\n    int table[102][12], questionsInRow[100], questionsInColumn[10];\n    bool insertSpace = false;\n    while (true) {\n        int p, s;\n        cin >> p >> s;\n        if (p == 0) {\n            break;\n        }\n        int questionNum = 0;\n        vector<pair<int, int> > res;\n        memset(table, 0, sizeof(table));\n        memset(questionsInRow, 0, sizeof(questionsInRow));\n        memset(questionsInColumn, 0, sizeof(questionsInColumn));\n        for (int y = 0; y <= p; y++) {\n            for (int x = 0; x <= s; x++) {\n                string input;\n                cin >> input;\n                if (input == \"?\") {\n                    table[y][x] = INF;\n                    questionsInRow[y]++;\n                    questionsInColumn[x]++;\n                    questionNum++;\n                    res.push_back(make_pair(y, x));\n                } else {\n                    stringstream sstream;\n                    sstream << input;\n                    sstream >> table[y][x];\n                    if (x < s) {\n                        table[y][s + 1] += table[y][x];\n                    }\n                    if (y < p) {\n                        table[p + 1][x] += table[y][x];\n                    }\n                }\n            }\n        }\n        queue<pair<int, int> > solves;\n        while (questionNum > 0) {\n            for (int x = 0; x < s; x++) {\n                  if (questionsInColumn[x] == 1) {\n                    for (int y = 0; y < p; y++) {\n                        if (table[y][x] == INF) {\n                            solves.push(make_pair(y, x));\n                        }\n                    }\n                }\n            }\n              for (int y = 0; y < p; y++) {\n                  if (questionsInRow[y] == 1) {\n                    for (int x = 0; x < s; x++) {\n                        if (table[y][x] == INF) {\n                            solves.push(make_pair(y, x));\n                        }\n                    }\n                }\n            }\n              if (solves.empty()) {\n                break;\n            }\n            while (solves.empty() == false) {\n                int cy = solves.front().first, cx = solves.front().second;\n                solves.pop();\n                if (table[cy][cx] != INF) {\n                    continue;\n                }\n                if (questionsInColumn[cx] == 1) {\n                    table[cy][cx] = table[p][cx] - table[p + 1][cx];\n                } else if (questionsInRow[cy] == 1) {\n                    table[cy][cx] = table[cy][s] - table[cy][s + 1];\n                }\n                table[p + 1][cx] += table[cy][cx];\n                table[cy][s + 1] += table[cy][cx];\n                questionsInColumn[cx]--;\n                questionsInRow[cy]--;\n                questionNum--;\n            }\n        }\n        if (insertSpace) {\n            cout << endl;\n        } else {\n            insertSpace = true;\n        }\n        if (questionNum > 0) {\n            cout << \"NO\" << endl;\n        } else {\n            for (vector<pair<int, int> >::iterator it = res.begin(); it != res.end(); it++) {\n                cout << table[it->first][it->second] << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int QUESTION = (1 << 25);\n\nvoid solve(vector<vector<int>> &matrix) {\n\tconst int h = matrix.size();\n\tconst int w = matrix[0].size();\n\n\tvector<vector<bool>> is_question(h - 1, vector<bool>(w - 1, false));\n\tvector<pair<int, int>> questions; // r, c\n\tvector<int> num_qr(h - 1, 0), num_qc(w - 1, 0);\n\tvector<int> sum_r(h - 1, 0), sum_c(w - 1, 0);\n\n\tfor(int i = 0; i < h - 1; ++i) {\n\t\tsum_r[i] += matrix[i][w - 1];\n\t}\n\n\tfor(int i = 0; i < w - 1; ++i) {\n\t\tsum_c[i] += matrix[h - 1][i];\n\t}\n\n\tfor(int i = 0; i < h - 1; ++i) {\n\t\tfor(int j = 0; j < w - 1; ++j) {\n\t\t\tif(matrix[i][j] == QUESTION) {\n\t\t\t\tquestions.emplace_back(i, j);\n\t\t\t\t++num_qr[i];\n\t\t\t\t++num_qc[j];\n\t\t\t\tis_question[i][j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum_r[i] -= matrix[i][j];\n\t\t\t\tsum_c[j] -= matrix[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!questions.empty()) {\n\t\tbool unloop = true;\n\t\tint i = 0;\n\n\t\twhile(i < questions.size()) {\n\t\t\tconst int r = questions[i].first;\n\t\t\tconst int c = questions[i].second;\n\n\t\t\tint value = QUESTION;\n\t\t\tif(num_qr[r] == 1) {\n\t\t\t\tvalue = sum_r[r];\n\t\t\t}\n\t\t\telse if(num_qc[c] == 1) {\n\t\t\t\tvalue = sum_c[c];\n\t\t\t}\n\n\t\t\tif(value == QUESTION) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatrix[r][c] = value;\n\t\t\tsum_r[r] -= value;\n\t\t\tsum_c[c] -= value;\n\t\t\t--num_qr[r];\n\t\t\t--num_qc[c];\n\t\t\tunloop = false;\n\t\t\tquestions.erase(questions.begin() + i);\n\t\t}\n\n\t\tif(unloop) break;\n\t}\n\n\tif(questions.empty()) { // unique answer\n\t\tfor(int i = 0; i < h - 1; ++i) {\n\t\t\tfor(int j = 0; j < w - 1; ++j) {\n\t\t\t\tif(is_question[i][j]) {\n\t\t\t\t\tcout << matrix[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tcout << \"NO\" << endl;\n\t}\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tbool first = true;\n\tfor(int p, s; cin >> p >> s && p;) {\n\t\tif(!first) cout << endl;\n\t\tfirst = false;\n\n\t\tvector<vector<int>> matrix(p + 1, vector<int>(s + 1));\n\t\tfor(auto &row : matrix) {\n\t\t\tfor(auto &e : row) {\n\t\t\t\tstring input;\n\t\t\t\tcin >> input;\n\t\t\t\te = (input == \"?\" ? QUESTION : stoi(input));\n\t\t\t}\n\t\t}\n\n\t\tsolve(matrix);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint H, W, a[101][11], c;\nint main() {\n\twhile (true) {\n\t\tcin >> H; if (H == 0)break; if (c)cout << endl; cin >> W;\n\t\tvector<pair<int, int>>v;\n\t\tfor (int i = 0; i <= H; i++) {\n\t\t\tfor (int j = 0; j <= W; j++) {\n\t\t\t\tstring S; cin >> S; if (S == \"?\") { a[i][j] = -(1 << 30); v.push_back(make_pair(i, j)); }\n\t\t\t\telse a[i][j] = stoi(S);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= H*W; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tint f = 0, g = 0, h = 0;\n\t\t\t\tfor (int k = 0; k < H; k++) { if (a[k][j] == -(1 << 30)) { g++; h = k; } else { f += a[k][j]; } }\n\t\t\t\tif (g == 1) { a[h][j] = a[H][j] - f; }\n\t\t\t}\n\t\t\tfor (int j = 0; j < H; j++) {\n\t\t\t\tint f = 0, g = 0, h = 0;\n\t\t\t\tfor (int k = 0; k < W; k++) { if (a[j][k] == -(1 << 30)) { g++; h = k; } else { f += a[j][k]; } }\n\t\t\t\tif (g == 1) { a[j][h] = a[j][W] - f; }\n\t\t\t}\n\t\t}\n\t\tbool flag = true; for (int i = 0; i <= H; i++) { for (int j = 0; j <= W; j++) { if (a[i][j] == -(1 << 30))flag = false; } }\n\t\tif (flag == false) cout << \"NO\" << endl;\n\t\telse { for (pair<int, int> i : v)cout << a[i.first][i.second] << endl; }\n\t\tc++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst double EPS=1e-8;\ntypedef vector<double>vec;\ntypedef vector<vec>mat;\ninline double ABS(double a){return max(a,-a);}\nvec gauss_jordan(const mat &A,const vec &b){\n\tint n=A.size();\n\tint m=A[0].size();\n\tmat B(n,vec(m+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)B[i][j]=A[i][j];\n\tfor(int i=0;i<n;i++)B[i][m]=b[i];\n\tfor(int i=0;i<m;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(ABS(B[j][i])>ABS(B[pivot][i]))pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(ABS(B[i][i])<EPS){\n\t\t\treturn vec();\n\t\t}\n\t\tfor(int j=i+1;j<=m;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=m;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m;i<n;i++)if(ABS(B[i][m])>EPS)return vec();\n\tvec x(m);\n\tfor(int i=0;i<m;i++)x[i]=B[i][m];\n\treturn x;\n}\nchar in[1000];\nint q[110][20];\nint p[110][20];\nint r[110];\nint c[110];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d\",&a),a){\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i=0;i<a;i++)r[i]=0;\n\t\tfor(int i=0;i<b;i++)c[i]=0;\n\t\tint t=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)q[i][j]=-1;\n\t\tfor(int i=0;i<a+1;i++)for(int j=0;j<b+1;j++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='?'){\n\t\t\t\tq[i][j]=t++;\n\t\t\t\tr[i]=1;\n\t\t\t\tc[j]=1;\n\t\t\t}else{\n\t\t\t\tsscanf(in,\"%d\",&p[i][j]);\n\t\t\t}\n\t\t}\n\t\tif(t>a+b){\n\t\t\tprintf(\"NO\\n\\n\");continue;\n\t\t}\n\t\tint sk=0;\n\t\tfor(int i=0;i<a;i++)sk+=r[i];\n\t\tfor(int i=0;i<b;i++)sk+=c[i];\n\t\tmat A(sk,vec(t));\n\t\tvec B(sk);\n\t\tint ind=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(!r[i])continue;\n\t\t\tB[ind]=p[i][b];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(~q[i][j])A[ind][q[i][j]]=1;\n\t\t\t\telse B[ind]-=p[i][j];\n\t\t\t}\n\t\t\tind++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(!c[i])continue;\n\t\t\tB[ind]=p[a][i];\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(~q[j][i])A[ind][q[j][i]]=1;\n\t\t\t\telse B[ind]-=p[j][i];\n\t\t\t}\n\t\t\tind++;\n\t\t}\n\t\tvec x=gauss_jordan(A,B);\n\t\tif(x.size()==0){\n\t\t\tprintf(\"NO\\n\\n\");continue;\n\t\t}\n\t\tfor(int i=0;i<x.size();i++)printf(\"%.0f\\n\",x[i]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n\nusing namespace std;\n\n\nint main(){\n  bool ns=false;\n  for(int p,s;cin>>p>>s,p;){\n    int t[101][11];\n    bool q[101][11]={{}};\n    int nq=0;\n    for(int i=0;i<p+1;i++){\n      for(int j=0;j<s+1;j++){\n\tcin>>t[i][j];\n\tif(!cin){\n\t  t[i][j]=nq++;\n\t  q[i][j]=true;\n\t  cin.clear();\n\t  cin.ignore();\n\t}\n      }\n    }\n    int r=nq;\n    int a[1000];\n    for(int i=0;i<nq;i++){\n      for(int j=0;j<p;j++){\n\tint cq=0,x;\n\tint sm=0;\n\tfor(int k=0;k<s;k++){\n\t  if(q[j][k]){\n\t    cq++;\n\t    x=k;\n\t  }else{\n\t    sm+=t[j][k];\n\t  }\n\t}\n\tif(cq==1){\n\t  int an=t[j][s]-sm;\n\t  a[t[j][x]]=an;\n\t  t[j][x]=an;\n\t  q[j][x]=false;\n\t  r--;\n\t}\n      }\n      for(int j=0;j<s;j++){\n\tint cq=0,x;\n\tint sm=0;\n\tfor(int k=0;k<p;k++){\n\t  if(q[k][j]){\n\t    cq++;\n\t    x=k;\n\t  }else{\n\t    sm+=t[k][j];\n\t  }\n\t}\n\tif(cq==1){\n\t  int an=t[p][j]-sm;\n\t  a[t[x][j]]=an;\n\t  t[x][j]=an;\n\t  q[x][j]=false;\n\t  r--;\n\t}\n      }\n    }\n    if(ns){\n      cout<<endl;\n    }\n    ns=true;\n    if(r){\n      cout<<\"NO\"<<endl;\n    }else{\n      for(int i=0;i<nq;i++){\n\tcout<<a[i]<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint p, s;\nchar row[10];\nint a[128][128], b[128][128];\n\nint main(){\n  while(scanf(\"%d\", &p) && p){\n    scanf(\"%d\", &s);\n    memset(a, -1, sizeof(a));\n    memset(b, 0, sizeof(b));\n    rep(i, p+1) rep(j, s+1){\n      scanf(\"%s\", row);\n      if(row[0] == '?'){\n\tb[i][j] = -1;\n\tcontinue;\n      }\n      a[i][j] = atoi(row);\n    }\n\n   int c, sum, point;\n    bool f = true;\n    while(f){\n      f = false;\n      rep(i, p){\n\tc = 0;\n\trep(j, s) if(a[i][j] == -1){ c++; point = j;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(j, s) if(a[i][j] != -1) sum += a[i][j];\n\ta[i][point] = a[i][s] - sum;\n\t//\tprintf(\"%d %d\\n\", i, point);\n      }\n      rep(j, s){\n\tc = 0;\n\trep(i, p) if(a[i][j] == -1){ c++; point = i;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(i, p) if(a[i][j] != -1) sum += a[i][j];\n\ta[point][j] = a[p][j] - sum;\n\t//\tprintf(\"%d %d\\n\",  point, j);\n      }\n    }\n    //    fprintf(stderr, \"end\\n\");\n    rep(i, p) rep(j, s) if(a[i][j] == -1) f = 1;\n    if(f){\n      puts(\"NO\");\n    }else{\n      rep(i, p) rep(j, s) if(b[i][j] == -1) printf(\"%d\\n\", a[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint h,w,d[100][100];\nint nq,q[100][100];\n\nint main()\n{\n\tbool fst=1;\n\twhile(scanf(\"%d\",&h),h)\n\t{\n\t\tscanf(\"%d\",&w); w++; h++;\n\t\tnq=0;\n\t\trep(i,h)rep(j,w)\n\t\t{\n\t\t\tchar in[9]; scanf(\"%s\",in);\n\t\t\tif(in[0]=='?')d[i][j]=inf,q[i][j]=1,nq++;\n\t\t\telse d[i][j]=atoi(in),q[i][j]=0;\n\t\t}\n\t\t\n\t\tbool f=0;\n\t\twhile(nq&&!f)\n\t\t{\n\t\t\tf=1;\n\t\t\trep(i,h-1)\n\t\t\t{\n\t\t\t\tint p=-1,sum=0;\n\t\t\t\trep(j,w-1)\n\t\t\t\t{\n\t\t\t\t\tif(d[i][j]==inf)p=p==-1?j:-2;\n\t\t\t\t\telse sum+=d[i][j];\n\t\t\t\t}\n\t\t\t\tif(p>=0)\n\t\t\t\t{\n\t\t\t\t\td[i][p]=d[i][w-1]-sum;\n\t\t\t\t\tnq--; f=0; goto NEXT;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w-1)\n\t\t\t{\n\t\t\t\tint p=-1,sum=0;\n\t\t\t\trep(i,h-1)\n\t\t\t\t{\n\t\t\t\t\tif(d[i][j]==inf)p=p==-1?i:-2;\n\t\t\t\t\telse sum+=d[i][j];\n\t\t\t\t}\n\t\t\t\tif(p>=0)\n\t\t\t\t{\n\t\t\t\t\td[p][j]=d[h-1][j]-sum;\n\t\t\t\t\tnq--; f=0; goto NEXT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNEXT:;\n\t\t}\n\t\t\n\t\tif(!fst)puts(\"\"); else fst=0;\n\t\tif(nq)puts(\"NO\");\n\t\telse rep(i,h)rep(j,w)if(q[i][j])printf(\"%d\\n\",d[i][j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\tint cc=0;\n\twhile(cin>>p,p){\n\t\tif(cc){\n\t\t\tcout<<endl<<endl;\n\t\t}\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\nng_s:;\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tif(i==ans.size()-1){\n\t\t\t\t\tcout<<ans[i];\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\";\n\t\t}\n\t\tcc++;\n\t}\n\tcout<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int p,s;\n  int ffff = 0;\n  while(cin>>p,p) {\n    cin >> s;\n    if (ffff) cout << endl;\n    else ffff = 1;\n    int a[s+1][p+1];\n    vector<int> vx;\n    vector<int> vy;\n    REP(i,p+1) {\n      REP(j,s+1) {\n        string str;\n        cin >> str;\n        if (str == \"?\") {\n          a[j][i] = INF;\n          vx.push_back(j);\n          vy.push_back(i);\n        } else a[j][i] = atoi(str.c_str());\n      }\n    }\n\n    bool update = 1;\n    while(update) {\n      update = 0;\n      REP(x, s) {\n        int cnt = 0;\n        int xx, yy;\n        int sum = 0;\n        REP(y, p) {\n          if (a[x][y] == INF) {\n            cnt++;\n            xx = x; yy = y;\n          } else\n            sum += a[x][y];\n        }\n        if (cnt == 1) {\n          //cout << xx << \" \" << yy << \" \" << sum << endl;\n          a[xx][yy] = a[x][p] - sum;\n          update = 1;\n        }\n      }\n      REP(y, p) {\n        int cnt = 0;\n        int xx, yy;\n        int sum = 0;\n        REP(x, s) {\n          if (a[x][y] == INF) {\n            cnt++;\n            xx = x; yy = y;\n          } else\n            sum += a[x][y];\n        }\n        //    cout << sum << endl;\n        if (cnt == 1) {\n          //cout << xx << \" \" << yy << endl;\n          a[xx][yy] = a[s][y] - sum;\n          update = 1;\n        }\n      }\n    }\n    vector<int> res;\n    REP(i,vx.size()) {\n      if (a[vx[i]][vy[i]] != INF) {\n        res.push_back(a[vx[i]][vy[i]]);\n      }\n    }\n    if (res.size() != vx.size())\n      cout << \"NO\" << endl;\n    else\n      FOR(it,res)\n        cout << *it << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n#define INF 1 << 28\n\nstring to_s(int n) {\n    ostringstream oss;\n    oss << n;\n    return oss.str();\n}\n\nint to_i(string s) {\n    int n;\n    istringstream is;\n    is.str(s);\n    is >> n;\n    return n;\n}\n\nint main() {\n    int h, w;\n    bool nikaime = false;\n    while (cin >> h >> w) {\n        int field[h+1][w+1];\n        string s;\n        vector<pair<int, int> > unknown; \n        for (int i = 0; i < h+1; i++) {\n            for (int j = 0; j < w+1; j++) {\n                cin >> s;\n                if (s == \"?\") {\n                    field[i][j] = INF;\n                    unknown.push_back(pair<int,int>(i, j));\n                } else {\n                    field[i][j] = to_i(s);\n                }\n            }\n        }\n\n        int unknown_x;\n        for (int i = 0; i < h; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == INF) {\n                    unknown_count++;\n                    unknown_x = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < w; j++) {\n                    if (j != unknown_x) {\n                        sum += field[i][j];\n                    }\n                }\n                field[i][unknown_x] = field[i][w] - sum;\n            }\n        }\n                    \n        int unknown_y;\n        for (int i = 0; i < w; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < h; j++) {\n                if (field[j][i] == INF) {\n                    unknown_count++;\n                    unknown_y = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < h; j++) {\n                    if (j != unknown_y) {\n                        sum += field[j][i];\n                    }\n                }\n                field[unknown_y][i] = field[h][i] - sum;\n            }\n        }\n\n//        int unknown_x;\n        for (int i = 0; i < h; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == INF) {\n                    unknown_count++;\n                    unknown_x = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < w; j++) {\n                    if (j != unknown_x) {\n                        sum += field[i][j];\n                    }\n                }\n                field[i][unknown_x] = field[i][w] - sum;\n            }\n        }\n\n        string ans;\n        for (int i = 0; i < unknown.size(); i++) {\n            if (field[unknown[i].first][unknown[i].second] == INF) {\n                ans = \"NO\\n\";\n            } else {\n                ans += to_s(field[unknown[i].first][unknown[i].second]);\n                ans += \"\\n\";\n            }\n        }\n\n        if (nikaime) {\n            cout << endl;\n        }\n\n        cout << ans;\n\n        nikaime = true;\n \n//        for (int i = 0; i < h+1; i++) {\n//            for (int j = 0; j < w+1; j++) {\n//                if (field[i][j] == INF) {\n//                    cout << \"x \";\n//                } else {\n//                    cout << field[i][j] << ' ';\n//                }\n//            }\n//            cout << endl;\n//        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-5;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tbool q=false;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tn++;m++;\n\t\tif(q)cout<<endl;\n\t\tvvi in(n,vi(m,inf));\n\t\tvp ha;\n\t\trep(i,n)rep(j,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(s==\"?\")ha.pb(pii(i,j));\n\t\t\telse in[i][j]=stoi(s);\n\t\t}\n\t\tint co=ha.size();\n\t\twhile(co){\n\t\t\tint cnt=0;\n\t\t\trep(i,n){\n\t\t\t\tint c=0;\n\t\t\t\trep(j,m)if(in[i][j]==inf)c++;\n\t\t\t\tif(c==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\trep(j,m-1)if(in[i][j]!=inf)sum+=in[i][j];\n\t\t\t\t\trep(j,m-1)if(in[i][j]==inf)in[i][j]=in[i][m-1]-sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,m){\n\t\t\t\tint c=0;\n\t\t\t\trep(j,n)if(in[j][i]==inf)c++;\n\t\t\t\tif(c==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\trep(j,n-1)if(in[j][i]!=inf)sum+=in[j][i];\n\t\t\t\t\trep(j,n-1)if(in[j][i]==inf)in[j][i]=in[n-1][i]-sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==0)break;\n\t\t\tco-=cnt;\n\t\t}\n\t\tif(co)cout<<\"NO\"<<endl;\n\t\telse{\n\t\t\trep(i,ha.size())cout<<in[ha[i].first][ha[i].second]<<endl;\n\t\t}\n\t\tq=true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int MAXR = 102;\nconst int MAXC = 12;\nconst lli INF = 1LL<<60;\n\nint R, C;\nlli G[MAXR][MAXC];\nint numR[MAXR], numC[MAXC];\n\nint main() {\n  bool first = true;\n  while(cin >> R && R) {\n    cin >> C;\n    vector<pair<int,int> > v;\n    for(int i = 0; i < R+1; ++i) {\n      for(int j = 0; j < C+1; ++j) {\n        string s;\n        cin >> s;\n        if(s == \"?\") {\n          G[i][j] = INF;\n          v.push_back(make_pair(i,j));\n        } else {\n          G[i][j] = atoi(s.c_str());\n        }\n      }\n    }\n\n    fill(numR, numR+MAXR, 0);\n    fill(numC, numC+MAXC, 0);\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) {\n          ++numR[i];\n          ++numC[j];\n        }\n      }\n    }\n\n    queue<pair<int,int> > que;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) {\n          if(numR[i] == 1 || numC[j] == 1) {\n            que.push(make_pair(i,j));\n          }\n        }\n      }\n    }\n\n    while(!que.empty()) {\n      pair<int,int> p = que.front();\n      que.pop();\n      if(G[p.first][p.second] != INF) continue;\n\n      lli sum;\n      bool flag = false;\n      if(!flag) {\n        flag = true;\n        sum = G[p.first][C];\n        for(int j = 0; j < C; ++j) {\n          if(j == p.second) continue;\n          if(G[p.first][j] == INF) {\n            flag = false;\n            break;\n          }\n          sum -= G[p.first][j];\n        }\n      }\n      if(!flag) {\n        flag = true;\n        sum = G[R][p.second];\n        for(int i = 0; i < R; ++i) {\n          if(i == p.first) continue;\n          if(G[i][p.second] == INF) {\n            flag = false;\n            break;\n          }\n          sum -= G[i][p.second];\n        }\n      }\n\n      if(flag) {\n        G[p.first][p.second] = sum;\n        if(--numR[p.first] == 1) {\n          for(int j = 0; j < C; ++j) {\n            if(G[p.first][j] == INF) {\n              que.push(make_pair(p.first, j));\n              break;\n            }\n          }\n        }\n        if(--numC[p.second] == 1) {\n          for(int i = 0; i < R; ++i) {\n            if(G[i][p.second] == INF) {\n              que.push(make_pair(i, p.second));\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    vector<lli> ans;\n    for(int i = 0; i < v.size(); ++i) {\n      if(G[v[i].first][v[i].second] == INF) {\n        ans.clear();\n        break;\n      }\n      ans.push_back(G[v[i].first][v[i].second]);\n    }\n\n    if(first) {\n      first = false;\n    } else {\n      cout << endl;\n    }\n    if(ans.size()) {\n      for(int i = 0; i < ans.size(); ++i) {\n        cout << ans[i] << endl;\n      }\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tfill(sumV,sumV+s,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(isdigit(c[0])){\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint ans[1011]={},na=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tna=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(na)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int R,C;\n  while(cin>>R>>C){\n    int data[101][101];\n    int cntx[101]={};\n    int cnty[101]={};\n    vector<P> fout;\n    REP(y,R+1)REP(x,C+1){\n      string s; cin>>s;\n      if(s == \"?\") {\n        data[y][x] = -1;\n        fout.push_back(P(x,y));\n        cntx[x]++;\n        cnty[y]++;\n      } else {\n        data[y][x] = atoi(s.c_str());\n      }\n    }\n    while(true){\n      bool updata = false;\n      REP(y,R+1){\n        if(cnty[y] == 1){\n          cnty[y] = 0;\n          updata = true;\n          int sum = 0;\n          REP(x,C+1)if(data[y][x]!=-1)sum += ((x==C)?1:-1) * data[y][x];\n          REP(x,C+1)if(data[y][x]==-1){\n            data[y][x] = ((x==C)?-1:1) * sum;\n            cntx[x]--;\n          }\n        }\n      }\n      REP(x,C+1){\n        if(cntx[x] == 1){\n          cntx[x] = 0;\n          updata = true;\n          int sum = 0;\n          REP(y,R+1)if(data[y][x]!=-1)sum += ((y==R)?1:-1) * data[y][x];\n          REP(y,R+1)if(data[y][x]==-1){\n            data[y][x] = ((y==R)?-1:1) * sum;\n            cnty[y]--;\n          }\n        }\n      }\n      if(!updata) break;\n    }\n    int cnt = 0;\n    REP(y,R+1)REP(x,C+1)if(data[y][x]==-1) cnt++;\n    if(cnt > 0) cout<<\"NO\"<<endl;\n    else {\n      REP(i, fout.size()){\n        cout<<data[fout[i].second][fout[i].first]<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint main() {\n    const int INF = 10000000;\n    int table[102][12], questionsInRow[100], questionsInColumn[10];\n    bool insertSpace = false;\n    while (true) {\n        int p, s;\n        cin >> p >> s;\n        if (p == 0) {\n            break;\n        }\n        int questionNum = 0;\n        vector<pair<int, int> > res;\n        memset(table, 0, sizeof(table));\n        memset(questionsInRow, 0, sizeof(questionsInRow));\n        memset(questionsInColumn, 0, sizeof(questionsInColumn));\n        for (int y = 0; y <= p; y++) {\n            for (int x = 0; x <= s; x++) {\n                string input;\n                cin >> input;\n                if (input == \"?\") {\n                    table[y][x] = INF;\n                    questionsInRow[y]++;\n                    questionsInColumn[x]++;\n                    questionNum++;\n                    res.push_back(make_pair(y, x));\n                } else {\n                    stringstream sstream;\n                    sstream << input;\n                    sstream >> table[y][x];\n                    if (x < s) {\n                        table[y][s + 1] += table[y][x];\n                    }\n                    if (y < p) {\n                        table[p + 1][x] += table[y][x];\n                    }\n                }\n            }\n        }\n        queue<pair<int, int> > solves;\n        while (questionNum > 0) {\n            for (int x = 0; x < s; x++) {\n                if (questionsInColumn[x] == 1) {\n                    for (int y = 0; y < p; y++) {\n                        if (table[y][x] == INF) {\n                            solves.push(make_pair(y, x));\n                        }\n                    }\n                }\n            }\n            for (int y = 0; y < p; y++) {\n                if (questionsInRow[y] == 1) {\n                    for (int x = 0; x < s; x++) {\n                        if (table[y][x] == INF) {\n                            solves.push(make_pair(y, x));\n                        }\n                    }\n                }\n            }\n            if (solves.empty()) {\n                break;\n            }\n            while (solves.empty() == false) {\n                int cy = solves.front().first, cx = solves.front().second;\n                solves.pop();\n                if (questionsInColumn[cx] == 1) {\n                    table[cy][cx] = table[p][cx] - table[p + 1][cx];\n                } else if (questionsInRow[cy] == 1) {\n                    table[cy][cx] = table[cy][s] - table[cy][s + 1];\n                }\n                table[p + 1][cx] += table[cy][cx];\n                table[cy][s + 1] += table[cy][cx];\n                questionsInColumn[cx]--;\n                questionsInRow[cy]--;\n                questionNum--;\n            }\n        }\n        if (insertSpace) {\n            cout << endl;\n        } else {\n            insertSpace = true;\n        }\n        if (questionNum > 0) {\n            cout << \"NO\" << endl;\n        } else {\n            for (vector<pair<int, int> >::iterator it = res.begin(); it != res.end(); it++) {\n                cout << table[it->first][it->second] << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int T=0,h,w;scanf(\"%d%d\",&h,&w),h;T++){\n\t\tif(T>0) puts(\"\");\n\n\t\tint a[100][10],type[100][10],rsum[10],csum[100];\n\t\tint rcnt[10]={},ccnt[100]={};\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tchar s[8]; scanf(\"%s\",s);\n\t\t\t\tif(s[0]=='?'){\n\t\t\t\t\ttype[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tsscanf(s,\"%d\",a[i]+j);\n\t\t\t\t\ttype[i][j]=1;\n\t\t\t\t\trcnt[j]++;\n\t\t\t\t\tccnt[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%d\",csum+i);\n\t\t}\n\t\trep(j,w) scanf(\"%d\",rsum+j);\n\t\tscanf(\"%*d\");\n\n\t\twhile(1){\n\t\t\tbool change=false;\n\t\t\trep(i,h) if(ccnt[i]==w-1) {\n\t\t\t\tint val=csum[i],jq;\n\t\t\t\trep(j,w){\n\t\t\t\t\tif(type[i][j]==0) jq=j;\n\t\t\t\t\telse              val-=a[i][j];\n\t\t\t\t}\n\t\t\t\ta[i][jq]=val;\n\t\t\t\ttype[i][jq]=2;\n\t\t\t\trcnt[jq]++;\n\t\t\t\tccnt[i]++;\n\t\t\t\tchange=true;\n\t\t\t}\n\n\t\t\trep(j,w) if(rcnt[j]==h-1) {\n\t\t\t\tint val=rsum[j],iq;\n\t\t\t\trep(i,h){\n\t\t\t\t\tif(type[i][j]==0) iq=i;\n\t\t\t\t\telse              val-=a[i][j];\n\t\t\t\t}\n\t\t\t\ta[iq][j]=val;\n\t\t\t\ttype[iq][j]=2;\n\t\t\t\trcnt[j]++;\n\t\t\t\tccnt[iq]++;\n\t\t\t\tchange=true;\n\t\t\t}\n\n\t\t\tif(!change) break;\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(i,h) rep(j,w) if(type[i][j]==0) ok=false;\n\t\tif(!ok) puts(\"NO\");\n\t\telse{\n\t\t\trep(i,h) rep(j,w) if(type[i][j]==2) printf(\"%d\\n\",a[i][j]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint p, s;\nchar row[10];\nint a[128][128], b[128][128];\n\nint main(){\n  while(scanf(\"%d\", &p) && p){\n    scanf(\"%d\", &s);\n    rep(i, 128) rep(j, 128) a[i][j] = INF;\n    memset(b, 0, sizeof(b));\n    rep(i, p+1) rep(j, s+1){\n      scanf(\"%s\", row);\n      if(row[0] == '?'){\n\tb[i][j] = -1;\n\tcontinue;\n      }\n      a[i][j] = atoi(row);\n    }\n\n   int c, sum, point;\n    bool f = true;\n    while(f){\n      f = false;\n      rep(i, p){\n\tc = 0;\n\trep(j, s) if(a[i][j] == INF){ c++; point = j;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(j, s) if(a[i][j] != INF) sum += a[i][j];\n\ta[i][point] = a[i][s] - sum;\n\t//\tprintf(\"%d %d\\n\", i, point);\n      }\n      rep(j, s){\n\tc = 0;\n\trep(i, p) if(a[i][j] == INF){ c++; point = i;}\n\tif(c != 1) continue;\n\tf = 1;\n\tsum = 0;\n\trep(i, p) if(a[i][j] != INF) sum += a[i][j];\n\ta[point][j] = a[p][j] - sum;\n\t//\tprintf(\"%d %d\\n\",  point, j);\n      }\n    }\n    //    fprintf(stderr, \"end\\n\");\n    rep(i, p) rep(j, s) if(a[i][j] == INF) f = 1;\n    if(f){\n      puts(\"NO\");\n    }else{\n      rep(i, p) rep(j, s) if(b[i][j] == -1) printf(\"%d\\n\", a[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)v[C[i][j]];\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }\n  return true;\n}\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n    \n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)v << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nconst int MAXN = 105;\nint R, C;\nint G[MAXN][MAXN];\n\nint getValue(int i, int j, int di, int dj) {\n  int sum = 0;\n  for(int d = -1; d <= 1; d += 2) {\n    int ni = i;\n    int nj = j;\n    for(ni = i, nj = j;\n        0 <= ni && ni < R && 0 <= nj && nj < C;\n        ni += d*di, nj += d*dj) {\n      if(ni == i && nj == j) continue;\n      if(G[ni][nj] == INF) return INF;\n      sum -= G[ni][nj];\n    }\n    if(ni >= 0 && nj >= 0) sum += G[ni][nj];\n  }\n  return sum;\n}\n\nint main() {\n  while(cin >> R && R) {\n    cin >> C;\n    for(int i = 0; i < R+1; ++i) {\n      for(int j = 0; j < C+1; ++j) {\n        string s;\n        cin >> s;\n        if(s == \"?\") {\n          G[i][j] = INF;\n        } else {\n          G[i][j] = atoi(s.c_str());\n\n        }\n      }\n    }\n    queue<pair<int,int> > que;\n    int n = 0;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) {\n          que.push(make_pair(i,j));\n          ++n;\n        }\n      }\n    }\n    vector<pair<pair<int,int>, int> > res;\n    while(!que.empty()) {\n      int i = que.front().first;\n      int j = que.front().second;\n      que.pop();\n      if(G[i][j] != INF) continue;\n      int u = getValue(i,j,1,0);\n      int v = getValue(i,j,0,1);\n      if(u != INF || v != INF) {\n        G[i][j] = min(u,v);\n        res.push_back(make_pair(make_pair(i,j),G[i][j]));\n        for(int k = 0; k < C; ++k) {\n          if(G[i][k] == INF) que.push(make_pair(i,k));\n        }\n        for(int k = 0; k < R; ++k) {\n          if(G[k][j] == INF) que.push(make_pair(k,j));\n        }\n      }\n    }\n\n    static bool first = true;\n    if(first) first = false;\n    else cout << endl;\n    if(res.size() != n) {\n      cout << \"NO\" << endl;\n    } else {\n      sort(res.begin(), res.end());\n      for(int i = 0; i < res.size(); ++i) {\n        cout << res[i].second << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tbool flag = false;\n\twhile (1) {\n\t\tif (!flag) {\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\tcout << endl;\n\t\t}\n\t\tint H, W;\n\t\tcin >> H;\n\t\tif (!H)break;\n\t\tcin >> W;\n\t\tvector<int>rs(H+1), cs(W+1);\n\t\tint unknown = 0;\n\t\tmap<pair<int, int>, int>mp;\n\t\tvector<vector<int>>field(H + 1, vector<int>(W + 1));\n\t\tfor (int i = 0; i < H + 1; ++i) {\n\t\t\tfor (int j = 0; j < W + 1; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tint num;\n\t\t\t\tif (st == \"?\") {\n\t\t\t\t\tnum = 1e8;\n\t\t\t\t\tmp[make_pair(i, j)] = unknown++;\n\t\t\t\t\trs[i]++;\n\t\t\t\t\tcs[j]++;\n\t\t\t\t}\n\t\t\t\telse num = stoi(st);\n\t\t\t\tfield[i][j] = num;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>que;\n\t\tfor (int y = 0; y <= H; ++y) {\n\t\t\tif (rs[y] == 1) {\n\t\t\t\tque.push(make_pair(1, y));\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tif (cs[x] == 1) {\n\t\t\t\tque.push(make_pair(0, x));\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tif (p.first) {\n\t\t\t\tconst int y = p.second;\n\t\t\t\tif (rs[y] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\t\t\t\tif (field[y][i] != 1e8) {\n\t\t\t\t\t\t\tsum += i!=W?field[y][i]:-field[y][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != W) {\n\t\t\t\t\t\tfield[y][place] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[y][place] = sum;\n\t\t\t\t\t}\n\t\t\t\t\trs[y]--;\n\t\t\t\t\tcs[place]--;\n\t\t\t\t\tif (cs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(0, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int x = p.second;\n\t\t\t\tif (cs[x] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\t\t\t\tif (field[i][x] != 1e8) {\n\t\t\t\t\t\t\tsum += i != H ? field[i][x] : -field[i][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != H) {\n\t\t\t\t\t\tfield[place][x] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[place][x] = sum;\n\t\t\t\t\t}\n\t\t\t\t\tcs[x]--;\n\t\t\t\t\trs[place]--;\n\t\t\t\t\tif (rs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(1, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tsum += field[i][j];\n\t\t\t}\n\t\t\tif (sum != field[i][W])ok = false;\n\t\t}\n\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < H; ++j)sum += field[j][i];\n\t\t\tif (sum != field[H][i])ok = false;\n\t\t}\n\t\tif (!ok)cout << \"NO\" << endl;\n\t\telse {\n\t\t\tfor (auto m : mp) {\n\t\t\t\tcout << field[m.first.first][m.first.second] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint toInt(string s){\n  stringstream ss;\n  ss << s;\n  int a;\n  ss >> a;\n  return a;\n}\n\nint main(){\n  int p,s;\n  bool flag = false;\n  while(cin >> p && p){\n    //    if(flag) cout << endl;\n    flag = true;\n    cin >> s;\n    s++,p++;\n    vector<vector<int> >v;\n    v.resize(p,vector<int>(s));\n    //    cin.ignore();\n\n    string str;\n    vector<pair<int,int> >pos;\n    int total = 0;\n    int r_hatena[p];\n    int c_hatena[s];\n    int r[p];\n    int c[s];\n\n    fill(r_hatena,r_hatena+p,0);\n    fill(c_hatena,c_hatena+s,0);\n    fill(r,r+p,0);\n    fill(c,c+s,0);\n\n    for(int i=0; i<p; i++){\n      for(int j=0; j<s; j++){\n\tcin >> str;\n\tif(str == \"?\"){\n\t  total++;\n\t  v[i][j] = INF;\n\t  pos.push_back(pair<int,int>(j,i));\n\t}\n\telse v[i][j] = toInt(str);\n      }\n    }\n\n\n    for(int i=0; i<p; i++){\n      int sum = 0;\n      for(int j=0; j<s; j++){\n\tif(v[i][j] == INF) c_hatena[j]++;\n\telse if(j != s-1) sum += v[i][j];\n      }\n      r[i] = sum;\n    }\n\n\n    for(int i=0; i<s; i++){\n      int sum = 0;\n      for(int j=0; j<p; j++){\n\tif(v[j][i] == INF) r_hatena[j]++;\n\telse if(j != p-1) sum += v[j][i];\n      }\n      c[i] = sum;\n    }\n\n\n    priority_queue<pair<bool,int>,vector<pair<bool,int> >,\n      greater<pair<bool,int> > >que;\n\n    for(int i=0; i<s; i++){\n      if(c_hatena[i] == 1){\n\tque.push(pair<bool,int>(true,i));\n      }\n\n    }\n\n    for(int i=0; i<p; i++){\n      if(r_hatena[i] == 1){\n\tque.push(pair<bool,int>(false,i));\n      }\n    }\n\n    //p tate s yoko\n    //0 is row 1 is column\n    while(!que.empty()){\n      pair<bool,int> tmp = que.top();\n      que.pop();\n\n      if(tmp.first == 0){\n\tif(r_hatena[tmp.second] <= 0)continue;\n\n\tfor(int i=0; i<s; i++){\n\t  if(v[tmp.second][i] == INF){\n\t    v[tmp.second][i] = v[tmp.second][s-1]-r[tmp.second];\n\t    //\t    cout << v[tmp.second][s-1] << endl;\n\t    //\t    cout << r[tmp.second] << endl;\n\t    r_hatena[tmp.second]--;\n\t    c_hatena[i]--;\n\t    //\t    cout << tmp.second << \" \" << i << endl;\n\t    total--;\n\t    c[i] += v[tmp.second][i];\n\t    if(c_hatena[i] == 1)\n\t      que.push(pair<bool,int>(1,i));\n\t  }\n\t}\n\n\n\n\n\n      } else {\n\tif(c_hatena[tmp.second] <= 0)continue;\n\tfor(int i=0; i<p; i++){\n\t  if(v[i][tmp.second] == INF){\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    v[i][tmp.second] = v[p-1][tmp.second]-c[tmp.second];\n\t    c_hatena[tmp.second]--;\n\t    r_hatena[i]--;\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    //\t    cout << c_hatena[tmp.second] << endl;\n\t    //\t    cout << r_hatena[i] << endl;\n\t    r[i] += v[i][tmp.second];\n\t    total--;\n\t    if(r_hatena[i] == 1)\n\t      que.push(pair<bool,int>(0,i));\n\t    //\t    cout << v[i][tmp.second] << endl;\n\t  }\n\t}\n\n      }\n\n\n\n\n\n\n    }\n\n    \n\n    if(total <= 0){\n      for(int i=0; i<pos.size(); i++){\n\tint x = pos[i].first;\n\tint y = pos[i].second;\n\tcout << v[y][x] << endl;\n      }\n    } else cout << \"NO\" << endl;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint toInt(string s){\n  stringstream ss;\n  ss << s;\n  int a;\n  ss >> a;\n  return a;\n}\n\nint main(){\n  int p,s;\n  bool flag = false;\n  while(cin >> p && p){\n    if(flag) cout << endl;\n    flag = true;\n    cin >> s;\n    s++,p++;\n    vector<vector<int> >v;\n    v.resize(p,vector<int>(s));\n    //    cin.ignore();\n\n    string str;\n    vector<pair<int,int> >pos;\n    int total = 0;\n    int r_hatena[p];\n    int c_hatena[s];\n    int r[p];\n    int c[s];\n\n    fill(r_hatena,r_hatena+p,0);\n    fill(c_hatena,c_hatena+s,0);\n    fill(r,r+p,0);\n    fill(c,c+s,0);\n\n    for(int i=0; i<p; i++){\n      for(int j=0; j<s; j++){\n\tcin >> str;\n\tif(str == \"?\"){\n\t  total++;\n\t  v[i][j] = INF;\n\t  pos.push_back(pair<int,int>(j,i));\n\t}\n\telse v[i][j] = toInt(str);\n      }\n    }\n\n\n    for(int i=0; i<p; i++){\n      int sum = 0;\n      for(int j=0; j<s; j++){\n\tif(v[i][j] == INF) c_hatena[j]++;\n\telse if(j != s-1) sum += v[i][j];\n      }\n      r[i] = sum;\n    }\n\n\n    for(int i=0; i<s; i++){\n      int sum = 0;\n      for(int j=0; j<p; j++){\n\tif(v[j][i] == INF) r_hatena[j]++;\n\telse if(j != p-1) sum += v[j][i];\n      }\n      c[i] = sum;\n    }\n\n\n    priority_queue<pair<bool,int>,vector<pair<bool,int> >,\n      greater<pair<bool,int> > >que;\n\n    for(int i=0; i<s; i++){\n      if(c_hatena[i] == 1){\n\tque.push(pair<bool,int>(true,i));\n      }\n\n    }\n\n    for(int i=0; i<p; i++){\n      if(r_hatena[i] == 1){\n\tque.push(pair<bool,int>(false,i));\n      }\n    }\n\n    //p tate s yoko\n    //0 is row 1 is column\n    while(!que.empty()){\n      pair<bool,int> tmp = que.top();\n      que.pop();\n\n      if(tmp.first == 0){\n\tif(r_hatena[tmp.second] <= 0)continue;\n\n\tfor(int i=0; i<s; i++){\n\t  if(v[tmp.second][i] == INF){\n\t    v[tmp.second][i] = v[tmp.second][s-1]-r[tmp.second];\n\t    //\t    cout << v[tmp.second][s-1] << endl;\n\t    //\t    cout << r[tmp.second] << endl;\n\t    r_hatena[tmp.second]--;\n\t    c_hatena[i]--;\n\t    //\t    cout << tmp.second << \" \" << i << endl;\n\t    total--;\n\t    c[i] += v[tmp.second][i];\n\t    if(c_hatena[i] == 1)\n\t      que.push(pair<bool,int>(1,i));\n\t  }\n\t}\n\n\n\n\n\n      } else {\n\tif(c_hatena[tmp.second] <= 0)continue;\n\tfor(int i=0; i<p; i++){\n\t  if(v[i][tmp.second] == INF){\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    v[i][tmp.second] = v[p-1][tmp.second]-c[tmp.second];\n\t    c_hatena[tmp.second]--;\n\t    r_hatena[i]--;\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    //\t    cout << c_hatena[tmp.second] << endl;\n\t    //\t    cout << r_hatena[i] << endl;\n\t    r[i] += v[i][tmp.second];\n\t    total--;\n\t    if(r_hatena[i] == 1)\n\t      que.push(pair<bool,int>(0,i));\n\t    //\t    cout << v[i][tmp.second] << endl;\n\t  }\n\t}\n\n      }\n\n\n\n\n\n\n    }\n\n    \n\n    if(total <= 0){\n      for(int i=0; i<pos.size(); i++){\n\tint x = pos[i].first;\n\tint y = pos[i].second;\n\tcout << v[y][x] << endl;\n      }\n    } else cout << \"NO\" << endl;\n    //    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint H, W;\nstring field[1010][1010];\nstring diff[1010][1010];\nint totals[2][1010];\nint total;\n\nint toInt(string s){\n  istringstream iss(s);\n  int n;\n  iss >> n;\n  return n;\n}\n\nstring toString(int n){\n  ostringstream oss;\n  oss << n;\n  return oss.str();\n}\n\nvoid Wcalc(int h, int x){\n  int sum = 0;\n  for(int j = 0 ; j < W ; j++){\n    if(field[h][j] == \"?\") continue;\n    else sum += toInt(field[h][j]);\n  }\n  /*\n  cout << \"x = \" << x << \", y = \" << h << endl;\n  cout << \"sum = \" << sum << endl;\n  cout << totals[0][h] << endl;\n  */\n  field[h][x] = toString(totals[0][h] - sum);\n}\n\nvoid Hcalc(int w, int y){\n  int sum = 0;\n  for(int i = 0 ; i < H ; i++){\n    if(field[i][w] == \"?\") continue;\n    else sum += toInt(field[i][w]);\n  }\n  /*\n  cout << \"x = \" << w << \", y = \" << y << endl;\n  cout << totals[1][w] << endl;\n  */\n  field[y][w] = toString(totals[1][w] - sum);\n}\n\n\nint main(){\n  bool flag = false;\n  while(cin >> H){\n    if(H == 0) break;\n    if(flag) cout << endl;\n    if(!flag) flag = true;\n    \n    cin >> W;\n    \n    \n    int q = 0;\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tdiff[i][j] = field[i][j];\n\tif(field[i][j] == \"?\") q++;\n      }\n      cin >> totals[0][i];\n    }\n    \n    for(int i = 0 ; i < W ; i++){\n      cin >> totals[1][i];\n    }\n    cin >> total;\n    \n    int tmp = q;\n    \n    bool cansolve = true;\n    while(1){\n      for(int i = 0 ; i < H ; i++){\n\tint qcnt = 0;\n\tint w;\n\tfor(int j = 0 ; j < W ; j++){\n\t  if(field[i][j] == \"?\") w = j, qcnt++;\n\t}\n\tif(qcnt == 1){\n\t  Wcalc(i, w);\n\t  tmp--;\n\t}\n      }\n      \n      for(int j = 0 ; j < W ; j++){\n\tint qcnt = 0;\n\tint h;\n\tfor(int i = 0 ; i < H ; i++){\n\t  if(field[i][j] == \"?\") h = i, qcnt++;\n\t}\n\tif(qcnt == 1){\n\t  Hcalc(j, h);\n\t  tmp--;\n\t}\n      }\n      \n      if(tmp == 0) break;\n      \n      if(q == tmp){\n\tcansolve = false;\n\tbreak;\n      }\n    }\n    \n    if(!cansolve){\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    vector<string> ans;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(diff[i][j] == \"?\"){\n\t  ans.push_back(field[i][j]);\n\t}\n      }\n    }\n    \n    for(int i = 0 ; i < q ; i++){\n      cout << ans[i] << endl;\n    }\n    /*\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcout << field[i][j] <<  ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst double EPS=1e-8;\ntypedef vector<double>vec;\ntypedef vector<vec>mat;\ninline double ABS(double a){return max(a,-a);}\nvec gauss_jordan(const mat &A,const vec &b){\n\tint n=A.size();\n\tint m=A[0].size();\n\tmat B(n,vec(m+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<m;j++)B[i][j]=A[i][j];\n\tfor(int i=0;i<n;i++)B[i][m]=b[i];\n\tfor(int i=0;i<m;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(ABS(B[j][i])>ABS(B[pivot][i]))pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(ABS(B[i][i])<EPS){\n\t\t\treturn vec();\n\t\t}\n\t\tfor(int j=i+1;j<=m;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=m;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m;i<n;i++)if(ABS(B[i][m])>EPS)return vec();\n\tvec x(m);\n\tfor(int i=0;i<m;i++)x[i]=B[i][m];\n\treturn x;\n}\nchar in[1000];\nint q[110][20];\nint p[110][20];\nint r[110];\nint c[110];\nint main(){\n\tint a,b;\n\tbool fi=false;\n\twhile(scanf(\"%d\",&a),a){\n\t\tif(fi)printf(\"\\n\");\n\t\tfi=true;\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i=0;i<a;i++)r[i]=0;\n\t\tfor(int i=0;i<b;i++)c[i]=0;\n\t\tint t=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)q[i][j]=-1;\n\t\tfor(int i=0;i<a+1;i++)for(int j=0;j<b+1;j++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='?'){\n\t\t\t\tq[i][j]=t++;\n\t\t\t\tr[i]=1;\n\t\t\t\tc[j]=1;\n\t\t\t}else{\n\t\t\t\tsscanf(in,\"%d\",&p[i][j]);\n\t\t\t}\n\t\t}\n\t\tif(t>a+b){\n\t\t\tprintf(\"NO\\n\");continue;\n\t\t}\n\t\tint sk=0;\n\t\tfor(int i=0;i<a;i++)sk+=r[i];\n\t\tfor(int i=0;i<b;i++)sk+=c[i];\n\t\tmat A(sk,vec(t));\n\t\tvec B(sk);\n\t\tint ind=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(!r[i])continue;\n\t\t\tB[ind]=p[i][b];\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(~q[i][j])A[ind][q[i][j]]=1;\n\t\t\t\telse B[ind]-=p[i][j];\n\t\t\t}\n\t\t\tind++;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(!c[i])continue;\n\t\t\tB[ind]=p[a][i];\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(~q[j][i])A[ind][q[j][i]]=1;\n\t\t\t\telse B[ind]-=p[j][i];\n\t\t\t}\n\t\t\tind++;\n\t\t}\n\t\tvec x=gauss_jordan(A,B);\n\t\tif(x.size()==0){\n\t\t\tprintf(\"NO\\n\");continue;\n\t\t}\n\t\tfor(int i=0;i<x.size();i++)printf(\"%.0f\\n\",x[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)round(v[C[i][j]]);\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      assert( C[i][S] == -1 );\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      //assert( !(!f && !V[k]) );\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      assert( C[P][j] == -1 );\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n\n      //assert( !(!f && !V[k]) );\n      \n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\tint cc=0;\n\twhile(cin>>p,p){\n\t\tif(cc){\n\t\t\tcout<<endl<<endl;\n\t\t}\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\t{\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\t\t\t\tgoto ng_p;\n\t\t\t\t}\nng_s:;\n\t {\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\t }\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tif(i==ans.size()-1){\n\t\t\t\t\tcout<<ans[i];\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\";\n\t\t}\n\t\tcc++;\n\t}\n\tcout<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<sstream>\n#include<cstdlib>\n#include<cassert>\n#define MAX 1000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint G[MAX][MAX];\nint A[MAX][2];// 0->r, 1->c\nP B[MAX][2];\nint C[MAX][2];\nint D[MAX][2];\n\nvoid printA()\n{\n  cout << \"printA---\" << endl;\n  rep(i,w)cout << A[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << A[i][1] << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printB()\n{\n  cout << \"printB---\" << endl;\n  rep(i,w)cout << B[i][0].first << \",\" << B[i][0].second << \" \"; cout << endl;\n  rep(i,h)cout << B[i][1].first << \",\" << B[1][i].second << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printC()\n{\n  cout << \"printC---\" << endl;\n  rep(i,w)cout << C[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << C[i][1] << \" \"; cout << endl;\n  cout << endl;\n}\n\nvoid printD()\n{\n  cout << \"printD---\" << endl;\n  rep(i,w)cout << D[i][0] << \" \"; cout << endl;\n  rep(i,h)cout << D[i][1] << \" \"; cout << endl;\n}\n\nP Bsearch(int a,int b)\n{\n  int Size = (b == 0?w:h);\n  for(int i=0;i<Size;i++)\n    {\n      if(b == 0)\n\t{\n\t  if(G[i][a] == -inf)return P(a,i);\n\t}\n      else\n\t{\n\t  if(G[a][i] == -inf)return P(i,a);\n\t}\n    }\n}\n\nint main()\n{\n  int blank = false;\n  while(true)\n    {\n      cin >> h;\n      if(!h)break;\n      cin >> w;\n      rep(i,MAX)rep(j,2)A[i][j] = C[i][j] = 0,B[i][j] = P(-inf,-inf);\n\n      vector<P> ans;\n      int hatena = 0;\n      rep(i,h)\n\t{\n\t  rep(j,w)\n\t    {\n\t      string input;\n\t      cin >> input;\n\t      if(input[0] == '?')\n\t\t{\n\t\t  G[i][j] = -inf;   \n\t\t  A[j][0]++;\n\t\t  B[j][0] = P(j,i);\n\t\t  A[i][1]++;\n\t\t  B[i][1] = P(j,i);\n\t\t  ans.push_back(P(j,i));\n\t\t}\n\t      else \n\t\t{\n\t\t  G[i][j] = (atoi)(input.c_str());\n\t\t  C[j][0] += G[i][j];\n\t\t  C[i][1] += G[i][j];\n\t\t}\n\t    }\n\t  cin >> D[i][1];\n\t}\n      rep(i,w+1)\n\tcin >> D[i][0];\n\t\n      //printA();\n      //printB();\n      //printC();\n      //printD();\n      //return 0;\n      bool Fin = true;\n      bool found = false;\n\n      while(true)\n\t{\n\t  //cout << \"phase !\" << endl;\n\t  //printA();\n\t  //printB();\n\t  //printC();\n\t  //printD();\n\t  Fin = true;\n\t  found = false;\n\t  rep(i,w)\n\t    {\n\t      if(A[i][0] >= 1)Fin = false;\n\t      if(A[i][0] == 1)\n\t\t{\n\t\t  //cout << \"erase! \" << B[i][0].first << \",\" << B[i][0].second << endl;\n\t\t  found = true;\t\n\t\t  int value = D[i][0]-C[i][0];\n\t\t  P p = Bsearch(i,0);\n\t\t   C[p.first][0]+=value;\n\t\t  C[p.second][1]+=value;\n\t\t   A[p.first][0]--;\n\t\t  A[p.second][1]--;\n\t\t  assert( G[p.second][p.first] == -inf);\n\t\t  G[p.second][p.first] = value;\n\t\t}\n\t    }\n\t  rep(i,h)\n\t    {\n\t      if(A[i][1] >= 1)Fin = false;\n\t      if(A[i][1] == 1)\n\t\t{\n\t\t  //cout << \"erase! \" << B[i][1].first << \",\" << B[i][1].second << endl;\n\t\t  found = true;\t\n\t\t  int value = D[i][1]-C[i][1];\n\t\t  P p = Bsearch(i,1);\n\t\t   C[p.first][0]+=value;\n\t\t  C[p.second][1]+=value;\n\t\t   A[p.first][0]--;\n\t\t  A[p.second][1]--;\n\t\t  assert(G[p.second][p.first] == -inf);\n\t\t  G[p.second][p.first] = value;\n\t\t}\n\t    }\n\n\t  if(!Fin && !found)\n\t    break;\n\t  if(Fin)break;\n\n\t}\n      if(!blank)blank = true;\n      else cout << endl;\n\t  if(!Fin && !found)\n\t    cout << \"NO\" << endl;\n\t  else\n\t    {\n\t      rep(i,ans.size())\n\t\tcout << G[ans[i].second][ans[i].first] << endl;\n\n\t\t\n\t    }\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nint H, W;\nstring field[1010][1010];\nstring diff[1010][1010];\nint totals[2][1010];\nint total;\n\nint toInt(string s){\n  istringstream iss(s);\n  int n;\n  iss >> n;\n  return n;\n}\n\nstring toString(int n){\n  ostringstream oss;\n  oss << n;\n  return oss.str();\n}\n\nvoid Wcalc(int h, int x){\n  int sum = 0;\n  for(int j = 0 ; j < W ; j++){\n    if(field[h][j] == \"?\") continue;\n    else sum += toInt(field[h][j]);\n  }\n  /*\n  cout << \"x = \" << x << \", y = \" << h << endl;\n  cout << \"sum = \" << sum << endl;\n  cout << totals[0][h] << endl;\n  */\n  field[h][x] = toString(totals[0][h] - sum);\n}\n\nvoid Hcalc(int w, int y){\n  int sum = 0;\n  for(int i = 0 ; i < H ; i++){\n    if(field[i][w] == \"?\") continue;\n    else sum += toInt(field[i][w]);\n  }\n  /*\n  cout << \"x = \" << w << \", y = \" << y << endl;\n  cout << totals[1][w] << endl;\n  */\n  field[y][w] = toString(totals[1][w] - sum);\n}\n\n\nint main(){\n  bool flag = false;\n  while(cin >> H){\n    if(H == 0) break;\n    if(flag) cout << endl;\n    if(!flag) flag = true;\n    \n    cin >> W;\n    \n    \n    int q = 0;\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tdiff[i][j] = field[i][j];\n\tif(field[i][j] == \"?\") q++;\n      }\n      cin >> totals[0][i];\n    }\n    \n    for(int i = 0 ; i < W ; i++){\n      cin >> totals[1][i];\n    }\n    cin >> total;\n        \n    bool cansolve = true;\n    while(1){\n      int tmp = q;\n      for(int i = 0 ; i < H ; i++){\n\tint qcnt = 0;\n\tint w;\n\tfor(int j = 0 ; j < W ; j++){\n\t  if(field[i][j] == \"?\") w = j, qcnt++;\n\t}\n\tif(qcnt == 1){\n\t  Wcalc(i, w);\n\t  q--;\n\t}\n      }\n      \n      for(int j = 0 ; j < W ; j++){\n\tint qcnt = 0;\n\tint h;\n\tfor(int i = 0 ; i < H ; i++){\n\t  if(field[i][j] == \"?\") h = i, qcnt++;\n\t}\n\tif(qcnt == 1){\n\t  Hcalc(j, h);\n\t  q--;\n\t}\n      }\n      \n      if(q == 0) break;\n      \n      if(q == tmp){\n\tcansolve = false;\n\tbreak;\n      }\n    }\n    \n    if(!cansolve){\n      cout << \"NO\" << endl;\n      continue;\n    }\n    \n    vector<string> ans;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(diff[i][j] == \"?\"){\n\t  ans.push_back(field[i][j]);\n\t}\n      }\n    }\n    \n    for(int i = 0 ; i < ans.size() ; i++){\n      cout << ans[i] << endl;\n    }\n    /*\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcout << field[i][j] <<  ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n\nconst int MAXR = 102;\nconst int MAXC = 12;\nconst int INF = 1<<28;\n\nint R, C;\nint G[MAXR][MAXC];\nint numR[MAXR], numC[MAXC];\n\nint main() {\n  bool first = true;\n  while(cin >> R && R) {\n    cin >> C;\n    vector<pair<int,int> > v;\n    for(int i = 0; i < R+1; ++i) {\n      for(int j = 0; j < C+1; ++j) {\n        string s;\n        cin >> s;\n        if(s == \"?\") {\n          G[i][j] = INF;\n          v.push_back(make_pair(i,j));\n        } else {\n          G[i][j] = atoi(s.c_str());\n        }\n      }\n    }\n    fill(numR, numR+MAXR, 0);\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) ++numR[i];\n      }\n    }\n\n    fill(numC, numC+MAXC, 0);\n    for(int j = 0; j < C; ++j) {\n      for(int i = 0; i < R+1; ++i) {\n        if(G[i][j] == INF) ++numC[j];\n      }\n    }\n\n    queue<pair<int,int> > que;\n    int num = 0;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) {\n          ++num;\n          if(numR[i] == 1 || numC[i] == 1) {\n            que.push(make_pair(i,j));\n          }\n        }\n      }\n    }\n\n    while(!que.empty()) {\n      pair<int,int> p = que.front();\n      que.pop();\n      if(G[p.first][p.second] != INF) continue;\n\n      int sum;\n      bool flag = false;\n      if(!flag) {\n        flag = true;\n        sum = G[p.first][C];\n        for(int j = 0; j < C; ++j) {\n          if(j == p.second) continue;\n          if(G[p.first][j] == INF) {\n            flag = false;\n            break;\n          }\n          sum -= G[p.first][j];\n        }\n      }\n      if(!flag) {\n        flag = true;\n        sum = G[R][p.second];\n        for(int i = 0; i < R; ++i) {\n          if(i == p.first) continue;\n          if(G[i][p.second] == INF) {\n            flag = false;\n            break;\n          }\n          sum -= G[i][p.second];\n        }\n      }\n\n      if(flag) {\n        G[p.first][p.second] = sum;\n        if(--numR[p.first] == 1) {\n          for(int j = 0; j < C; ++j) {\n            if(G[p.first][j] == INF) {\n              que.push(make_pair(p.first, j));\n              break;\n            }\n          }\n        }\n        if(--numC[p.second] == 1) {\n          for(int i = 0; i < R; ++i) {\n            if(G[i][p.second] == INF) {\n              que.push(make_pair(i, p.second));\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> ans;\n    for(int i = 0; i < v.size(); ++i) {\n      if(G[v[i].first][v[i].second] == INF) {\n        ans.clear();\n        break;\n      }\n      ans.push_back(G[v[i].first][v[i].second]);\n    }\n\n    if(first) {\n      first = false;\n    } else {\n      cout << endl;\n    }\n    if(ans.size()) {\n      for(int i = 0; i < ans.size(); ++i) {\n        cout << ans[i] << endl;\n      }\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)round(v[C[i][j]]);\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n\n    }\n    \n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int MISSING = 0x7fffffff;\n\nint main(){\n\twhile(true){\n\t\tint p, s;\n\t\tcin >> p;\n\t\tif(p == 0){ break; }\n\t\tcin >> s;\n\t\tvector< vector<int> > table(p + 1, vector<int>(s + 1));\n\t\tvector< vector<bool> > missing(p, vector<bool>(s));\n\t\tfor(int i = 0; i <= p; ++i){\n\t\t\tfor(int j = 0; j <= s; ++j){\n\t\t\t\tstring item;\n\t\t\t\tcin >> item;\n\t\t\t\tif(item == \"?\"){\n\t\t\t\t\ttable[i][j] = MISSING;\n\t\t\t\t\tmissing[i][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttable[i][j] = atoi(item.c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pii> q;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){ table[i][pos] = table[i][s] - sum; }\n\t\t}\n\t\tfor(int i = 0; i < s; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < p; ++j){\n\t\t\t\tif(table[j][i] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){\n\t\t\t\ttable[pos][i] = table[p][i] - sum;\n\t\t\t\tq.push(pii(0, pos));\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tpii e = q.front();\n\t\t\tq.pop();\n\t\t\tif(e.first == 0){\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < s; ++i){\n\t\t\t\t\tif(table[e.second][i] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[e.second][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[e.second][pos] = table[e.second][s] - sum;\n\t\t\t\t\tq.push(pii(1, pos));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < p; ++i){\n\t\t\t\t\tif(table[i][e.second] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[i][e.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[pos][e.second] = table[p][e.second] - sum;\n\t\t\t\t\tq.push(pii(0, pos));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool valid = true;\n\t\tvector<int> answer;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\tvalid = false;\n\t\t\t\t}else if(missing[i][j]){\n\t\t\t\t\tanswer.push_back(table[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!valid){\n\t\t\tcout << \"NO\" << endl;\n\t\t}else{\n\t\t\tfor(int i = 0; i < answer.size(); ++i){\n\t\t\t\tcout << answer[i] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int INF = 1e9;\n\nint H, W;\nbool f;\n\nvoid check(int y, int x, int py, int px, int total, vector< vector<int> > &v, vector<int> &h, vector<int> &w){\n  int sum = 0, ty, tx;\n  while(y < H - 1 && x < W - 1){\n    if(v[y][x] == INF) { ty = y; tx = x; }\n    else sum += v[y][x];\n    y += py; x += px;\n  }\n  v[ty][tx] = total - sum;\n  h[ty]--; w[tx]--;\n}\n\nvector< vector<int> > solve(vector< vector<int> > v, vector<int> &h, vector<int> &w){\n  int cnt = 0;\n  REP(i, H) REP(j, W) if(v[i][j] == INF) ++cnt;\n  while(cnt != 0){\n    bool flg = false;\n    REP(i, H) if(h[i] == 1) { check(i, 0, 0, 1, v[i][W - 1], v, h, w); --cnt; flg = true; }\n    REP(i, W) if(w[i] == 1) { check(0, i, 1, 0, v[H - 1][i], v, h, w); --cnt; flg = true; }\n    if(!flg) { return vector< vector<int> >(); }\n  }\n  f = true;\n  return v;\n}\n\nint main() {\n  bool t = false;\n  while(cin >>H && H){\n    cin >>W;\n    ++H; ++W;\n    f = false;\n    vector< vector<int> > v(H, vector<int>(W));\n    vector<int> w(W, 0), h(H, 0);\n    REP(i, H){\n      REP(j, W){\n        string s; cin >>s;\n        if(s != \"?\") v[i][j] = atoi(s.c_str());\n        else { v[i][j] = INF; h[i]++; w[j]++; }\n      }\n    }\n    if(t) cout <<endl;\n    t = true;\n    vector< vector<int> > ans = solve(v, h, w);\n    if(f) { REP(i, H) REP(j, W) if(v[i][j] == INF) cout <<ans[i][j] <<endl; }\n    else cout <<\"NO\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint toInt(string s){\n  stringstream ss;\n  ss << s;\n  int a;\n  ss >> a;\n  return a;\n}\n\nint main(){\n  int s,p;\n  bool flag = false;\n  while(cin >> p && p){\n    if(flag) cout << endl;\n    flag = true;\n    cin >> s;\n    s++,p++;\n    vector<vector<int> >v;\n    v.resize(p,vector<int>(s));\n    cin.ignore();\n\n    string str;\n    vector<pair<int,int> >pos;\n    int total = 0;\n    int r_hatena[p];\n    int c_hatena[s];\n    int r[p];\n    int c[s];\n\n    fill(r_hatena,r_hatena+p,0);\n    fill(c_hatena,c_hatena+s,0);\n    fill(r,r+p,0);\n    fill(c,c+s,0);\n\n    for(int i=0; i<p; i++){\n      for(int j=0; j<s; j++){\n\tcin >> str;\n\tif(str == \"?\"){\n\t  total++;\n\t  v[i][j] = INF;\n\t  pos.push_back(pair<int,int>(j,i));\n\t}\n\telse v[i][j] = toInt(str);\n      }\n    }\n\n\n    for(int i=0; i<p; i++){\n      int sum = 0;\n      for(int j=0; j<s; j++){\n\tif(v[i][j] == INF) c_hatena[j]++;\n\telse if(j != s-1) sum += v[i][j];\n      }\n      r[i] = sum;\n    }\n\n\n    for(int i=0; i<s; i++){\n      int sum = 0;\n      for(int j=0; j<p; j++){\n\tif(v[j][i] == INF) r_hatena[j]++;\n\telse if(j != p-1) sum += v[j][i];\n      }\n      c[i] = sum;\n    }\n\n\n    priority_queue<pair<bool,int>,vector<pair<bool,int> >,\n      greater<pair<bool,int> > >que;\n\n    for(int i=0; i<p; i++){\n      if(c_hatena[i] == 1){\n\tque.push(pair<bool,int>(true,i));\n      }\n\n    }\n\n    for(int i=0; i<s; i++){\n      if(r_hatena[i] == 1){\n\tque.push(pair<bool,int>(false,i));\n      }\n    }\n\n    for(int i=0; i<v.size(); i++){\n      for(int j=0; j<v[i].size(); j++){\n\t//\tcout << v[i][j] << \" \";\n      }\n      //      cout << endl;\n    }\n\n    //p tate s yoko\n    //0 is row 1 is column\n    while(!que.empty()){\n      pair<bool,int> tmp = que.top();\n      que.pop();\n\n      if(tmp.first == 0){\n\tif(r_hatena[tmp.second] <= 0)continue;\n\n\tfor(int i=0; i<s; i++){\n\t  if(v[tmp.second][i] == INF){\n\t    v[tmp.second][i] = v[tmp.second][s-1]-r[tmp.second];\n\t    //\t    cout << v[tmp.second][s-1] << endl;\n\t    //\t    cout << r[tmp.second] << endl;\n\t    r_hatena[tmp.second]--;\n\t    c_hatena[i]--;\n\t    //\t    cout << tmp.second << \" \" << i << endl;\n\t    total--;\n\t    c[i] += v[tmp.second][i];\n\t    if(c_hatena[i] == 1)\n\t      que.push(pair<bool,int>(1,i));\n\t  }\n\t}\n\n\n\n\n\n      } else {\n\tif(c_hatena[tmp.second] <= 0)continue;\n\tfor(int i=0; i<p; i++){\n\t  if(v[i][tmp.second] == INF){\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    v[i][tmp.second] = v[p-1][tmp.second]-c[tmp.second];\n\t    c_hatena[tmp.second]--;\n\t    r_hatena[i]--;\n\t    //\t    cout << i << \" \" << tmp.second << endl;\n\t    //\t    cout << c_hatena[tmp.second] << endl;\n\t    //\t    cout << r_hatena[i] << endl;\n\t    r[i] += v[i][tmp.second];\n\t    total--;\n\t    if(r_hatena[i] == 1)\n\t      que.push(pair<bool,int>(0,i));\n\t    //\t    cout << v[i][tmp.second] << endl;\n\t  }\n\t}\n\n      }\n\n\n\n\n\n\n    }\n\n    \n\n    if(total <= 0){\n      for(int i=0; i<pos.size(); i++){\n\tint x = pos[i].first;\n\tint y = pos[i].second;\n\tcout << v[y][x] << endl;\n      }\n    } else cout << \"NO\" << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\tint newline=0;\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tif(newline)cout<<endl;\n\t\tnewline=1;\n\t\tfill(sumV,sumV+s,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(isdigit(c[0])){\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint ans[1011]={},na=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tna=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(na)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\nusing namespace std;\n\nbool q[110][110],v[110][110],f;\nint num[110][110],sum,pos;\nint p,s,tp[110],ts[110],cq[110],rq[110];\nstring tmp;\n\nint stoi(string x){\n  stringstream ss(x);\n  int n;\n  ss >> n;\n  return n;\n}\n\n\nint main(){\n  f = true;\n  while(cin >> p,p){\n    if(!f)cout << endl;\n    f = false;\n    cin >> s; cin.ignore();\n    \n    for(int i=0;i<p;i++)rq[i] = 0;\n    for(int i=0;i<s;i++)cq[i] = 0;\n\n    for(int i=0;i<p;i++){\n      for(int j=0;j<s;j++){\n\tcin >> tmp;\n\tif(tmp == \"?\"){\n\t  q[i][j] = v[i][j] = false;\n\t  rq[i]++; cq[j]++;\n\t}else{\n\t  q[i][j] = v[i][j] = true;\n\t  num[i][j] = stoi(tmp);\n\t}\n      }\n      cin >> tp[i]; cin.ignore();\n    }\n    for(int i=0;i<s;i++)cin >> ts[i];\n    cin >> tmp;\n\n    bool update = true;\n    while(update){\n      update = false;\n      for(int i=0;i<p;i++){\n\tif(rq[i] == 1){\n\t  sum = 0;\n\t  for(int j=0;j<s;j++){\n\t    if(!v[i][j])pos = j;\n\t    else sum += num[i][j];\n\t  }\n\t  num[i][pos] = tp[i] - sum;\n\t  v[i][pos] = true;\n\t  rq[i]--; cq[pos]--;\n\t  update = true;\n\t}\n      }\n      for(int i=0;i<s;i++){\n\tif(cq[i] == 1){\n\t  sum = 0;\n\t  for(int j=0;j<p;j++){\n\t    if(!v[j][i])pos = j;\n\t    else sum += num[j][i];\n\t  }\n\t  num[pos][i] = ts[i] - sum;\n\t  v[pos][i] = true;\n\t  rq[pos]--; cq[i]--;\n\t  update = true;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<p;i++)ans |= rq[i];\n    for(int i=0;i<s;i++)ans |= cq[i];\n    \n\n    if(ans)cout << \"NO\\n\";\n    else{\n      for(int i=0;i<p;i++){\n\tfor(int j=0;j<s;j++){\n\t  if(!q[i][j])cout << num[i][j] << endl;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<sstream>\n#include<cstdlib>\n#include<cassert>\n#define MAX 1000\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint G[MAX][MAX];\nint A[MAX][2];// 0->r, 1->c\nP B[MAX][2];\nint C[MAX][2];\nint D[MAX][2];\n \nP Bsearch(int a,int b)\n{\n  int Size = (b == 0?h:w);\n  for(int i=0;i<Size;i++)\n    {\n      if(b == 0)\n    {\n      if(G[i][a] == -inf)return P(a,i);\n    }\n      else\n    {\n      if(G[a][i] == -inf)return P(i,a);\n    }\n    }\n}\n \nint main()\n{\n  int blank = false;\n  while(true)\n    {\n      cin >> h;\n      if(!h)break;\n      cin >> w;\n      rep(i,MAX)rep(j,2)A[i][j] = C[i][j] = 0,B[i][j] = P(-inf,-inf);\n \n      vector<P> ans;\n      int hatena = 0;\n      rep(i,h)\n    {\n      rep(j,w)\n        {\n          string input;\n          cin >> input;\n          if(input[0] == '?')\n        {\n          G[i][j] = -inf;   \n          A[j][0]++;\n          B[j][0] = P(j,i);\n          A[i][1]++;\n          B[i][1] = P(j,i);\n          ans.push_back(P(j,i));\n        }\n          else\n        {\n          G[i][j] = (atoi)(input.c_str());\n          C[j][0] += G[i][j];\n          C[i][1] += G[i][j];\n        }\n        }\n      cin >> D[i][1];\n    }\n      rep(i,w+1)\n    cin >> D[i][0];\n     \n\n      bool Fin = true;\n      bool found = false;\n \n      while(true)\n    {\n      Fin = true;\n      found = false;\n      rep(i,w)\n        {\n          if(A[i][0] >= 1)Fin = false;\n          if(A[i][0] == 1)\n        {\n          //cout << \"erase! \" << B[i][0].first << \",\" << B[i][0].second << endl;\n          found = true; \n          int value = D[i][0]-C[i][0];\n          P p = Bsearch(i,0);\n           C[p.first][0]+=value;\n          C[p.second][1]+=value;\n           A[p.first][0]--;\n          A[p.second][1]--;\n          assert( G[p.second][p.first] == -inf);\n          G[p.second][p.first] = value;\n        }\n        }\n      rep(i,h)\n        {\n          if(A[i][1] >= 1)Fin = false;\n          if(A[i][1] == 1)\n        {\n          //cout << \"erase! \" << B[i][1].first << \",\" << B[i][1].second << endl;\n          found = true; \n          int value = D[i][1]-C[i][1];\n          P p = Bsearch(i,1);\n           C[p.first][0]+=value;\n          C[p.second][1]+=value;\n           A[p.first][0]--;\n          A[p.second][1]--;\n          assert(G[p.second][p.first] == -inf);\n          G[p.second][p.first] = value;\n        }\n        }\n \n      if(!Fin && !found)\n        break;\n      if(Fin)break;\n \n    }\n      if(!blank)blank = true;\n      else cout << endl;\n      if(!Fin && !found)\n        cout << \"NO\" << endl;\n      else\n        {\n          rep(i,ans.size())\n        cout << G[ans[i].second][ans[i].first] << endl;\n \n         \n        }\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\n#define EPS (1e-8)\n\nconst int q = -999999999;\n\ntypedef long long ll;\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(mat& A, vec& b) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  rep(i, n) rep(j, n) B[i][j] = A[i][j];\n  rep(i, n) B[i][n] = b[i];\n\n  rep(i, n) {\n    int pivot = i;\n    REP(j, i, n) {\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) return vec();\n\n    REP(j, i+1, n+1) B[i][j] /= B[i][i];\n    rep(j, n) {\n      if(i != j) {\n        REP(k, i+1, n+1) B[j][k] -= B[j][i] * B[i][k];\n      }\n    }\n  }\n\n  vec x(n);\n  rep(i, n) x[i] = B[i][n];\n  return x;\n}\n\nint N, M;\nmat in;\nvector<pair<int, int>> qpos;\n\n#define fail { cout << \"NO\\n\"; goto next; }\n\nint main() {\n\n  bool first = 0;\n  while(cin >> N >> M && N) {\n    if(first) cout << endl;\n    first = 1;\n    bool remain = 0;\n    in.clear(); in.resize(N + 1); rep(i, N + 1) in[i].resize(M + 1);\n    qpos.clear();\n    rep(i, N + 1) rep(j, M + 1) {\n      string s; cin >> s;\n      if(s == \"?\") in[i][j] = q, qpos.emplace_back(i, j);\n      else in[i][j] = stoi(s);\n    }\n\n    rep(_, (N + 1) * (M + 1) + 10) {\n    {\n      rep(i, N + 1) {\n        int xcnt = 0;\n        ll sum = 0;\n        int lastq = -1;\n        rep(j, M) {\n          if(in[i][j] == q) xcnt ++, lastq = j;\n          else sum += in[i][j];\n        }\n        if(xcnt == 0) {\n          if(in[i][M] == q) in[i][M] = sum;\n          else if(in[i][M] != sum) fail;\n        }\n        else if(xcnt == 1) {\n          if(in[i][M] == q) {}\n          else in[i][lastq] = in[i][M] - sum;\n        }\n        else {}\n      }\n    }\n\n    {\n      rep(j, M + 1) {\n        int xcnt = 0;\n        ll sum = 0;\n        int lastq = -1;\n        rep(i, N) {\n          if(in[i][j] == q) xcnt ++, lastq = i;\n          else sum += in[i][j];\n        }\n        if(xcnt == 0) {\n          if(in[N][j] == q) in[N][j] = sum;\n          else if(in[N][j] != sum) fail;\n        }\n        else if(xcnt == 1) {\n          if(in[N][j] == q) {}\n          else in[lastq][j] = in[N][j] - sum;\n        }\n        else {}\n      }\n    }}\n\n    rep(i, N + 1) rep(j, M + 1) {\n      remain |= in[i][j] == q;\n    }\n\n    if(remain) fail;\n\n    for(auto e: qpos) {\n      cout << in[e.first][e.second] << endl;\n    }\n\n  next:;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)round(v[C[i][j]]);\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nconst int MAXN = 105;\nint R, C;\nint G[MAXN][MAXN];\n\nint getValue(int i, int j, int di, int dj) {\n  int sum = 0;\n  for(int d = -1; d <= 1; d += 2) {\n    int ni = i;\n    int nj = j;\n    for(ni = i, nj = j;\n        0 <= ni && ni < R && 0 <= nj && nj < C;\n        ni += d*di, nj += d*dj) {\n      if(ni == i && nj == j) continue;\n      if(G[ni][nj] == INF) return INF;\n      sum -= G[ni][nj];\n    }\n    if(ni >= 0 && nj >= 0) sum += G[ni][nj];\n  }\n  return sum;\n}\n\nint main() {\n  while(cin >> R && R) {\n    cin >> C;\n    for(int i = 0; i < R+1; ++i) {\n      for(int j = 0; j < C+1; ++j) {\n        string s;\n        cin >> s;\n        if(s == \"?\") {\n          G[i][j] = INF;\n        } else {\n          G[i][j] = atoi(s.c_str());\n\n        }\n      }\n    }\n    queue<pair<int,int> > que;\n    int n = 0;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n        if(G[i][j] == INF) {\n          que.push(make_pair(i,j));\n          ++n;\n        }\n      }\n    }\n    vector<pair<pair<int,int>, int> > res;\n    while(!que.empty()) {\n      int i = que.front().first;\n      int j = que.front().second;\n      que.pop();\n      if(G[i][j] != INF) continue;\n      int u = getValue(i,j,1,0);\n      int v = getValue(i,j,0,1);\n      if(u != INF || v != INF) {\n        G[i][j] = min(u,v);\n        res.push_back(make_pair(make_pair(i,j),G[i][j]));\n        for(int k = 0; k < C; ++k) {\n          if(G[i][k] == INF) que.push(make_pair(i,k));\n        }\n        for(int k = 0; k < R; ++k) {\n          if(G[k][j] == INF) que.push(make_pair(k,j));\n        }\n      }\n    }\n    if(res.size() != n) {\n      cout << \"NO\" << endl;\n    } else {\n      sort(res.begin(), res.end());\n      for(int i = 0; i < res.size(); ++i) {\n        cout << res[i].second << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define N 1000000\nusing namespace std;\n\nmain(){\n  int p, s;\n  char num[10];\n  int data[100][10];\n  bool kai=false;\n  while(1){\n    cin >> p;\n    if(p==0) break;\n    if(kai) cout << endl;\n    cin >> s;\n    int tm=0;\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tscanf(\"%s\", num);\n\tif(num[0]=='?'){\n\t  tm++;\n\t  data[i][j]=N;\n\t}\n\telse data[i][j]=atoi(num);\n      }\n    }\n\n    bool flag=true;\n    bool t[100][10];\n    for(int i=0;i<p;i++){\n      for(int j=0;j<s;j++){\n\tt[i][j]=false;\n      }\n    }\n    while(tm!=0){\n      bool end=true;\n      for(int i=0;i<=p;i++){\n\tint sum=0;\n\tint a;\n\tfor(int j=0;j<=s;j++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=j;\n\t  }\n\t}\n\tif(sum==1){\n\t  flag=false;\n\t  end=false;\n\t  int tmp=0;\n\t  for(int j=0;j<s;j++){\n\t    if(j==a) continue;\n\t    tmp+=data[i][j];\n\t  }\n\t  data[i][a]=data[i][s]-tmp;\n\t  t[i][a]=true;\n\t}\n      }\n\n      for(int j=0;j<=s;j++){\n\tint sum=0;\n\tint a;\n\tfor(int i=0;i<=p;i++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=i;\n\t  }\n\t}\n\tif(sum==1){\n\t  flag=false;\n\t  end=false;\n\t  int tmp=0;\n\t  for(int i=0;i<p;i++){\n\t    if(i==a) continue;\n\t    tmp+=data[i][j];\n\t  }\n\t  data[a][j]=data[p][j]-tmp;\n\t  t[a][j]=true;\n\t}\n      }\n      if(end) break;\n    }\n    if(flag) cout << \"NO\" << endl;\n    else{\n      for(int i=0;i<p;i++){\n\tfor(int j=0;j<s;j++){\n\t  if(t[i][j]) cout << data[i][j] << endl;\n\t}\n      }\n    }\n    kai=true;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\nusing namespace std;\n\nbool q[110][110],v[110][110];\nint num[110][110],sum,pos;\nint p,s,tp[110],ts[110],cq[110],rq[110];\nstring tmp;\n\nint stoi(string x){\n  stringstream ss(x);\n  int n;\n  ss >> n;\n  return n;\n}\n\nint main(){\n  while(cin >> p,p){\n    cin >> s; cin.ignore();\n    \n    for(int i=0;i<p;i++)rq[i] = 0;\n    for(int i=0;i<s;i++)cq[i] = 0;\n\n    for(int i=0;i<p;i++){\n      for(int j=0;j<s;j++){\n\tcin >> tmp;\n\tif(tmp == \"?\"){\n\t  q[i][j] = v[i][j] = false;\n\t  rq[i]++; cq[j]++;\n\t}else{\n\t  q[i][j] = v[i][j] = true;\n\t  num[i][j] = stoi(tmp);\n\t}\n      }\n      cin >> tp[i]; cin.ignore();\n    }\n    for(int i=0;i<s;i++)cin >> ts[i];\n    cin >> tmp;\n\n    bool update = true;\n    while(update){\n      update = false;\n      for(int i=0;i<p;i++){\n\tif(rq[i] == 1){\n\t  sum = 0;\n\t  for(int j=0;j<s;j++){\n\t    if(!v[i][j])pos = j;\n\t    else sum += num[i][j];\n\t  }\n\t  num[i][pos] = tp[i] - sum;\n\t  v[i][pos] = true;\n\t  rq[i]--; cq[pos]--;\n\t  update = true;\n\t}\n      }\n      for(int i=0;i<s;i++){\n\tif(cq[i] == 1){\n\t  sum = 0;\n\t  for(int j=0;j<p;j++){\n\t    if(!v[j][i])pos = j;\n\t    else sum += num[j][i];\n\t  }\n\t  num[pos][i] = ts[i] - sum;\n\t  v[pos][i] = true;\n\t  rq[pos]--; cq[i]--;\n\t  update = true;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<p;i++)ans |= rq[i];\n    for(int i=0;i<s;i++)ans |= cq[i];\n    \n\n    if(ans)cout << \"NO\\n\";\n    else{\n      for(int i=0;i<p;i++){\n\tfor(int j=0;j<s;j++){\n\t  if(!q[i][j])cout << num[i][j] << endl;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)v[C[i][j]];\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }\n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n    \n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)v << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\tint newline=0;\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tif(newline)cout<<endl;\n\t\tnewline=1;\n\t\tfill(sumV,sumV+s+1,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(isdigit(c[0])){\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint ans[1011]={},na=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tna=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(na)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){\n\n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 ) X[i][j] = (int)round(v[C[i][j]]);\n\n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){\n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<=P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[i][S] != -1 ) M[k][C[i][S]] = f = -1;\n      else V[k] += X[i][S];\n      assert( !(!f && !V[k]) );\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<=S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      if( C[P][j] != -1 ) M[k][C[P][j]] = f = -1;\n      else V[k] += X[P][j];\n\n      assert( !(!f && !V[k]) );\n      \n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-9;\n\nvec gauss_jordan(const mat &A, const vec &b){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){  \n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 )\n        X[i][j] = (int)round(v[C[i][j]]);  \n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){    \n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n\n    mat M = mat(cnt,vec(cnt));\n    vec V = vec(cnt);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<P;i++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[i][S];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    for(int j=0;j<S;j++){\n      if( k == cnt ) break;\n      bool f = false;\n      V[k] = 0;\n      M[k] = vec(cnt,0);\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = f = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[P][j];\n      if( f && F.count( M[k] ) == 0 )\n        F.insert( M[k++] );\n    }\n\n    if( k < cnt ){\n      for(int i=0;i<P;i++)\n        for(int j=0;j<S;j++){\n          if( C[i][j] != -1 ) M[k][C[i][j]] = 1;\n          else V[k] -= X[i][j];\n        }\n      V[k] += X[P][S];\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n    vec res;\n    if( k == cnt ) res = gauss_jordan(M,V);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for( double v : res ){      \n          cout << (int)round(v) << endl;\n        }\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\twhile(cin>>p,p){\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\nng_s:;\n\t\t\t\tif(find(ALL(used),0)==used.end())break;\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-5;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tbool q=false;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tn++;m++;\n\t\tif(q)cout<<endl;\n\t\tvvi in(n,vi(m,inf));\n\t\tvp ha;\n\t\trep(i,n)rep(j,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tif(s==\"?\")ha.pb(pii(i,j));\n\t\t\telse in[i][j]=stoi(s);\n\t\t}\n\t\tint co=ha.size();\n\t\twhile(co){\n\t\t\tint cnt=0;\n\t\t\trep(i,n){\n\t\t\t\tint c=0;\n\t\t\t\trep(j,m)if(in[i][j]==inf)c++;\n\t\t\t\tif(c==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\trep(j,m-1)if(in[i][j]!=inf)sum+=in[i][j];\n\t\t\t\t\trep(j,m-1)if(in[i][j]==inf)in[i][j]=in[i][m-1]-sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,m){\n\t\t\t\tint c=0;\n\t\t\t\trep(j,n)if(in[j][i]==inf)c++;\n\t\t\t\tif(c==1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint sum=0;\n\t\t\t\t\trep(j,n-1)if(in[j][i]!=inf)sum+=in[j][i];\n\t\t\t\t\trep(j,n-1)if(in[j][i]==inf)in[j][i]=in[n-1][i]-sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt==0)break;\n\t\t\tco-=cnt;\n\t\t}\n\t\tif(co)cout<<\"NO\"<<endl;\n\t\telse{\n\t\t\trep(i,ha.size())cout<<in[ha[i].first][ha[i].second]<<endl;\n\t\t}\n\t\tq=true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n#define INF 1 << 28\n\nstring to_s(int n) {\n    ostringstream oss;\n    oss << n;\n    return oss.str();\n}\n\nint to_i(string s) {\n    int n;\n    istringstream is;\n    is.str(s);\n    is >> n;\n    return n;\n}\n\nint main() {\n    int h, w;\n    bool nikaime = false;\n    while (cin >> h >> w) {\n        int field[h+1][w+1];\n        string s;\n        vector<pair<int, int> > unknown; \n        for (int i = 0; i < h+1; i++) {\n            for (int j = 0; j < w+1; j++) {\n                cin >> s;\n                if (s == \"?\") {\n                    field[i][j] = INF;\n                    unknown.push_back(pair<int,int>(i, j));\n                } else {\n                    field[i][j] = to_i(s);\n                }\n            }\n        }\n\n        for (int k = 0; k < 100; k++) {\n        int unknown_x;\n        for (int i = 0; i < h; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == INF) {\n                    unknown_count++;\n                    unknown_x = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < w; j++) {\n                    if (j != unknown_x) {\n                        sum += field[i][j];\n                    }\n                }\n                field[i][unknown_x] = field[i][w] - sum;\n            }\n        }\n                    \n        int unknown_y;\n        for (int i = 0; i < w; i++) {\n            int unknown_count = 0;\n            for (int j = 0; j < h; j++) {\n                if (field[j][i] == INF) {\n                    unknown_count++;\n                    unknown_y = j;\n                }\n            }\n            if (unknown_count == 1) {\n                int sum = 0;\n                for (int j = 0; j < h; j++) {\n                    if (j != unknown_y) {\n                        sum += field[j][i];\n                    }\n                }\n                field[unknown_y][i] = field[h][i] - sum;\n            }\n        }\n        }\n\n//        int unknown_x;\n//        for (int i = 0; i < h; i++) {\n//            int unknown_count = 0;\n//            for (int j = 0; j < w; j++) {\n//                if (field[i][j] == INF) {\n//                    unknown_count++;\n//                    unknown_x = j;\n//                }\n//            }\n//            if (unknown_count == 1) {\n//                int sum = 0;\n//                for (int j = 0; j < w; j++) {\n//                    if (j != unknown_x) {\n//                        sum += field[i][j];\n//                    }\n//                }\n//                field[i][unknown_x] = field[i][w] - sum;\n//            }\n//        }\n\n        string ans;\n        for (int i = 0; i < unknown.size(); i++) {\n            if (field[unknown[i].first][unknown[i].second] == INF) {\n                ans = \"NO\\n\";\n                break;\n            } else {\n                ans += to_s(field[unknown[i].first][unknown[i].second]);\n                ans += \"\\n\";\n            }\n        }\n\n        if (nikaime) {\n            cout << endl;\n        }\n\n        cout << ans;\n\n        nikaime = true;\n \n//        for (int i = 0; i < h+1; i++) {\n//            for (int j = 0; j < w+1; j++) {\n//                if (field[i][j] == INF) {\n//                    cout << \"x \";\n//                } else {\n//                    cout << field[i][j] << ' ';\n//                }\n//            }\n//            cout << endl;\n//        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1<<30;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nint main() {\n  int n,m;\n  bool ff=0;\n  while(cin >> n && n) {\n    cin >> m;\n    if(ff) cout << endl;\n    ff=1;\n    int a[n+1][m+1],cnt=0;\n    for(int i=0; i<=n; i++) {\n      for(int j=0; j<=m; j++) {\n        string s;\n        cin >> s;\n        if(s[0]=='?') {\n          a[i][j]=INF;\n          cnt++;\n        } else {\n          stringstream ss;\n          ss << s;\n          ss >> a[i][j];\n        }\n      }\n    }\n    vector<PP> ans;\n    while(1) {\n      bool ck=0;\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<m; j++) {\n          if(a[i][j]==INF) {\n            bool f=1;\n            for(int k=0; k<m; k++) {\n              if(j!=k&&a[i][k]==INF) f=0;\n            }\n            if(f) {\n              int sum=a[i][m];\n              for(int k=0; k<m; k++) {\n                if(j!=k) sum-=a[i][k];\n              }\n              a[i][j]=sum;\n              ans.push_back(PP(P(i,j),a[i][j]));\n              ck=1;\n              continue;\n            }\n            f=1;\n            for(int k=0; k<n; k++) {\n              if(i!=k&&a[k][j]==INF) f=0;\n            }\n            if(f) {\n              int sum=a[n][j];\n              for(int k=0; k<n; k++) {\n                if(i!=k) sum-=a[k][j];\n              }\n              a[i][j]=sum;\n              ans.push_back(PP(P(i,j),a[i][j]));\n              ck=1;\n            }\n          }\n        }\n      }\n      if(!ck) break;\n    }\n    if(ans.size()!=cnt) cout << \"NO\" << endl;\n    else {\n      sort(ans.begin(),ans.end());\n      for(int i=0; i<ans.size(); i++) cout << ans[i].second << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nvoid solve(int R, int C){\n  vector<PI> U;\n  vector<int> SR(R), SC(C);\n  \n  REP(i, R + 1) REP(j, C + 1){\n    string str;\n    cin >> str;\n    if (str == \"?\"){\n      U.push_back(PI(i, j));\n    } else {\n      int value = atoi(str.c_str());\n      if (i < R) SR[i] += (j == C ? value : -value);\n      if (j < C) SC[j] += (i == R ? value : -value);\n    }\n  }\n\n  if (U.size() > SR.size() + SC.size()) {\n    cout << \"NO\" << endl;\n  } else {\n    int n = U.size();\n    vector<vector<double> > M(R + C, vector<double>(n + 1, 0));\n    REP(i, R) M[i + 0][n] = SR[i];\n    REP(i, C) M[i + R][n] = SC[i];\n    REP(i, n) M[U[i].first][i] = M[U[i].second + R][i] = 1;\n\n    REP(i, n){\n      int pivot = i;\n      REP2(j, i, R + C) if (abs(M[j][i]) > abs(M[pivot][i])) pivot = j;\n      \n      if (abs(M[pivot][i]) < eps) {\n        cout << \"NO\" << endl;\n        return;\n      }\n\n      swap(M[pivot], M[i]);\n      REP(j, R + C) REP2(k, i + 1, n + 1) if (j != i){\n        M[j][k] -= M[j][i] / M[i][i] * M[i][k];\n      }\n      REP2(k, i + 1, n + 1) M[i][k] /= M[i][i];\n      REP(j, R + C) M[j][i] = j == i;\n    }\n    \n    REP(i, n) cout << (int)(M[i][n] > 0 ? M[i][n] + 0.5 : M[i][n] - 0.5) << endl;\n  }\n}\n\n\nint main(){\n  int R, C, T = 0;\n  while (cin >> R >> C){\n    if (T > 0) cout << endl;\n    solve(R, C);\n    T++;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n\nusing namespace std;\n\nint p,s;\nconst int QST=1000000000;\nint table[201][21];\nint origTable[201][21];\n\nint main(){\n  bool fst=true;\n  while(cin>>p&&p){\n    if(!fst)cout<<endl;\n    fst=false;\n    int cnt=0;\n    cin>>s;\n    string str;\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tcin>>str;\n\tif(str[0]=='?'){\n\t  table[i][j]=QST;\n\t  origTable[i][j]=table[i][j];\n\t  cnt++;\n\t}\n\telse{\n\t  int num=atoi(str.c_str());\n\t  table[i][j]=num;\n\t  origTable[i][j]=table[i][j];\n\t}\n      }\n    }\n    bool update=true,isFail=false;\n    while(update){\n      update=false;\n      for(int i=0;i<=p;i++){\n\tint c=0;\n\tint last=-1;\n\tfor(int j=0;j<=s;j++){\n\t  if(table[i][j]==QST){\n\t    c++;\n\t    last=j;\n\t  }\n\t}\n\tif(c==1){\n\t  int sum=0;\n\t  if(last==s){\n\t    for(int j=0;j<s;j++)sum+=table[i][j];\n\t    table[i][last]=sum;\n\t  }\n\t  else{\n\t    sum=table[i][s];\n\t    for(int j=0;j<s;j++)if(table[i][j]!=QST)sum-=table[i][j];\n\t    table[i][last]=sum;\n\t  }\n\t  cnt--;\n\t  update=true;\n\t  break;\n\t}\n      }\n      for(int j=0;j<=s;j++){\n\tint c=0;\n\tint last=-1;\n\tfor(int i=0;i<=p;i++){\n\t  if(table[i][j]==QST){\n\t    c++;\n\t    last=i;\n\t  }\n\t}\n\tif(c==1){\n\t  int sum=0;\n\t  if(last==p){\n\t    for(int i=0;i<p;i++)sum+=table[i][j];\n\t    table[last][j]=sum;\n\t  }\n\t  else{\n\t    sum=table[p][j];\n\t    for(int i=0;i<p;i++)if(table[i][j]!=QST)sum-=table[i][j];\n\t    table[last][j]=sum;\n\t  }\n\t  cnt--;\n\t  update=true;\n\t  break;\n\t}\n      }\n      if(cnt>0&&!update){\n\tisFail=true;\n\tbreak;\n      }\n      // 矛盾が起きてるかどうかを調べる\n      for(int i=0;i<=p;i++){\n\tint sum=0;\n\tbool ok=true;\n\tfor(int j=0;j<=s;j++){\n\t  if(table[i][j]==QST){\n\t    ok=false;break;\n\t  }\n\t  else if(j!=s)sum+=table[i][j];\n\t}\n\t// fail\n\tif(!ok)continue;\n\t// 全部埋まってる\n\tif(sum!=table[i][s]){\n\t  update=false;\n\t  isFail=true;\n\t  break;\n\t}\n      }\n      for(int j=0;j<=s;j++){\n\tint sum=0;\n\tbool ok=true;\n\tfor(int i=0;i<=p;i++){\n\t  if(table[i][j]==QST){\n\t    ok=false;break;\n\t  }\n\t  else if(i!=p)sum+=table[i][j];\n\t}\n\t// fail\n\tif(!ok)continue;\n\tif(!(sum==table[p][j])){\n\t  update=false;\n\t  isFail=true;\n\t  break;\n\t}\n      }\n    }\n    if(isFail)cout<<\"NO\"<<endl;\n    else{\n      for(int i=0;i<=p;i++)\n\tfor(int j=0;j<=s;j++)\n\t  if(origTable[i][j]==QST)\n\t    cout<<table[i][j]<<endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt (string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin();i!=(c).end();++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS=1e-10;\nconst double PI=acos(-1.0);\n\n\nconst int UNDEF=INT_MAX;\nint main(){\n\tint p,s;\n\tint cc=0;\n\twhile(cin>>p,p){\n\t\tif(cc){\n\t\t\tcout<<endl<<endl;\n\t\t}\n\t\tcin>>s;\n\t\tvvi cells(p+1,vi(s+1,UNDEF));\n\t\tvector<pii> undefs;\n\t\tREP(i,p+1){\n\t\t\tREP(j,s+1){\n\t\t\t\tstring s;\n\t\t\t\tcin>>s;\n\t\t\t\tif(s==\"?\"){\n\t\t\t\t\tcells[i][j]=UNDEF;\n\t\t\t\t\tundefs.push_back(make_pair(i,j));\n\t\t\t\t}else{\n\t\t\t\t\tcells[i][j]=toInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi ans(undefs.size());\n\n\t\tbool flag=true;\n\t\tvi used(undefs.size(),0);\n\t\twhile(flag){\n\t\t\tflag=false;\n\t\t\tREP(kk,undefs.size()){\n\t\t\t\tif(used[kk])continue;\n\t\t\t\tpii u=undefs[kk];\n\n\t\t\t\tint sum2=0;\n\t\t\t\tREP(i,s){\n\t\t\t\t\tif(cells[u.first][i]==UNDEF){\n\t\t\t\t\t\tif(i!=u.second){\n\t\t\t\t\t\t\tgoto ng_s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum2+=cells[u.first][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[u.first][s]-sum2);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\t\t\t\tgoto ng_p;\nng_s:;\n\t\t\t\tint sum1=0;\n\t\t\t\tREP(i,p){\n\t\t\t\t\tif(cells[i][u.second]==UNDEF){\n\t\t\t\t\t\tif(i!=u.first){\n\t\t\t\t\t\t\tgoto ng_p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum1+=cells[i][u.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[kk]=(cells[p][u.second]-sum1);\n\t\t\t\tcells[u.first][u.second]=ans[kk];\n\t\t\t\tused[kk]=1;\n\t\t\t\tflag=true;\n\tng_p:;\n\t\t\t}\n\t\t}\n\n\t\tif(find(ALL(used),0)==used.end()){\n\t\t\tREP(i,ans.size()){\n\t\t\t\tif(i==ans.size()-1){\n\t\t\t\t\tcout<<ans[i];\n\t\t\t\t}else{\n\t\t\t\t\tcout<<ans[i]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tcout<<\"NO\";\n\t\t}\n\t\tcc++;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nconst double EPS = 1e-8;\n\nvec gauss_jordan(const mat &A, const vec &b,int k){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n\n  for(int i=0;i<k;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if(fabs(B[j][i]) > fabs(B[pivot][i])) pivot = j;\n    swap(B[i],B[pivot]);\n\n    //ティツァツ」テ」ツ?古」ツ?ェテ」ツ??」ツ?凝」ツ??」ツ?づ」ツ?」テ」ツ?ヲテ」ツつづ、ツクツ?ヲツ?湘」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ??」ツ??\n    if(fabs(B[i][i]) < EPS) return vec();\n    \n    for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n    for(int j=0;j<n;j++)\n      if(i != j)\n\tfor(int k=i+1;k<=n;k++)\n\t  B[j][k] -= B[j][i] * B[i][k];\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n  return x;\n}\n\n\nint X[111][111];\nint C[111][111];\nint P,S;\n\nbool check(const vec &v){  \n  for(int i=0;i<=P;i++)\n    for(int j=0;j<=S;j++)\n      if( C[i][j] != -1 )\n        X[i][j] = (int)round(v[C[i][j]]);  \n  for(int i=0;i<=P;i++){\n    int sum = 0;\n    for(int j=0;j<S;j++) sum += X[i][j];\n    if( sum != X[i][S] ) return false;\n  }\n  for(int j=0;j<=S;j++){    \n    int sum = 0;\n    for(int i=0;i<P;i++) sum += X[i][j];\n    if( sum != X[P][j] ) return false;\n  }  \n  return true;\n}\n\nvoid view(vec& v){\n  for( auto a : v )\n    cout << a << \" \";\n  cout << endl;\n}\n\nconst int INF = (1<<29);\nint main(){\n\n  while( cin >> P && P ){\n    cin >> S;\n    memset( C,-1,sizeof(C) );\n    memset( X,0,sizeof(X));\n    int cnt = 0;\n    for(int i=0;i<=P;i++){\n      for(int j=0;j<=S;j++){\n        string s; cin >> s;\n        if( s == \"?\" ) C[i][j] = cnt++;\n        else X[i][j] = stoi(s);\n      }\n    }\n    \n    static int ttt=0;\n    if( ttt++ ) cout << endl;\n\n    int n = P+S+1;\n\n    if( cnt >  n ) {\n      cout <<\"NO\" << endl;\n      continue;\n    }\n    \n    mat M = mat(n,vec(n));\n    vec V = vec(n);\n    set<vec> F;\n    int k = 0;\n    for(int i=0;i<P;i++){\n      V[k] = 0;\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[i][S];\n      k++;\n    }\n\n    for(int j=0;j<S;j++){\n      V[k] = 0;\n      for(int i=0;i<P;i++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = 1;\n        else V[k] -= X[i][j];\n      }\n      V[k] += X[P][j];\n      k++;\n    }\n\n    for(int i=0;i<P;i++)\n      for(int j=0;j<S;j++){\n        if( C[i][j] != -1 ) M[k][C[i][j]] = 1;\n        else V[k] -= X[i][j];\n      }\n    V[k] += X[P][S];\n    k++;\n    \n    \n    vec res = gauss_jordan(M,V,cnt);\n    if( res.empty() ) cout << \"NO\" << endl;\n    else {\n      if( check(res) ){\n        for(int i=0;i<cnt;i++)\n          cout << (int)round(res[i]) << endl;\n      } else\n        cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nint b[200][20];\nconst int unknown = 1000000;\n\nint main(){\n  int p, s;\n  while(~scanf(\"%d%d \", &p, &s)){\n    vector<pair<int,int> > up;\n    REP(i, p+1) REP(j, s+1){\n      char buff[32];\n      scanf(\"%s \", buff);\n      if(buff[0] == '?'){\n\tb[i][j] = unknown;\n\tup.push_back(mp(i, j));\n      }else{\n\tb[i][j] = atoi(buff);\n      }\n    }\n\n    bool ok = true;\n    bool change = true;\n\n    while(change){\n      int cc = 0;\n      change = false;\n\n      REP(i,p){\n\tint cnt = 0;\n\tint sum = 0;\n\tpair<int,int> pos;\n\t\n\tREP(j,s){\n\t  if(b[i][j] == unknown){\n\t    cnt++;\n\t    pos = mp(i,j);\n\t  }else{\n\t    sum += b[i][j];\n\t  }\n\t}\n\tcc += cnt;\n\n\tif(cnt == 1){\n\t  int y = pos.f;\n\t  int x = pos.s;\n\n\t  change = true;\n\t  b[y][x] = b[i][s] - sum;\n\n\t  sum = 0;\n\t  REP(j, p){\n\t    if(b[j][x] == unknown)\n\t      goto end;\n\t    else\n\t      sum += b[j][x];\n\t  }\n\n\t  if(sum != b[p][x]){\n\t    ok = false;\n\t    goto end2;\n\t  }\n \n\tend:;\n\t}\n\n      }\n      REP(j,s){\n\tint cnt = 0;\n\tint sum = 0;\n\tpair<int,int> pos;\n\t\n\tREP(i,p){\n\t  if(b[i][j] == unknown){\n\t    cnt++;\n\t    pos = mp(i,j);\n\t  }else{\n\t    sum += b[i][j];\n\t  }\n\t}\n\n\tif(cnt == 1){\n\t  int y = pos.f;\n\t  int x = pos.s;\n\n\t  change = true;\n\t  b[y][x] = b[p][j] - sum;\n\n\t  sum = 0;\n\t  REP(i, s){\n\t    if(b[y][i] == unknown)\n\t      goto end3;\n\t    else\n\t      sum += b[y][i];\n\t  }\n\n\t  if(sum != b[y][s]){\n\t    ok = false;\n\t    goto end2;\n\t  }\n \n\tend3:;\n\t}\n\n      }\n\n      if(cc != 0 && change == false)\n\tok = false;\n    }\n  end2:;\n\n    if(ok){\n      FOR(it, up){\n\tint y = it->f;\n\tint x = it->s;\n\n\tprintf(\"%d\\n\", b[y][x]);\n      }\n    }else{\n      puts(\"NO\");\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint p,s,table[111][11],sumV[111],sumH[111];\n\nint main(){\n\tint newline=0;\n\twhile(cin>>p && p){\n\t\tcin>>s;\n\t\tif(newline)cout<<endl;\n\t\tnewline=1;\n\t\tfill(sumV,sumV+s+1,0);\n\t\tfill(sumH,sumH+p,0);\n\t\tint var=0,varV[111]={},varH[111]={};\n\t\trep(i,p){\n\t\t\trep(j,s){\n\t\t\t\tchar c[9];\n\t\t\t\tcin>>c;\n\t\t\t\tif(c[0]=='?'){\n\t\t\t\t\ttable[i][j]=INF+(var++);\n\t\t\t\t\tvarV[j]++;\n\t\t\t\t\tvarH[i]++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttable[i][j]=atoi(c);\n\t\t\t\t\tsumV[j]-=table[i][j];\n\t\t\t\t\tsumH[i]-=table[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x;cin>>x;\n\t\t\tsumH[i]+=x;\n\t\t}\n\t\trep(i,s+1){\n\t\t\tint x;cin>>x;\n\t\t\tsumV[i]+=x;\n\t\t}\n\t\tint ans[1011]={},no=0,found=0;\n\t\twhile(1){\n\t\t\tint flag=0;\n\t\t\trep(i,p)if(varH[i]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarH[i]--;\n\t\t\t\trep(j,s)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumH[i];\n\t\t\t\t\ttable[i][j]=0;\n\t\t\t\t\tsumV[j]-=sumH[i];\n\t\t\t\t\tvarV[j]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,s)if(varV[j]==1){\n\t\t\t\tflag=1;\n\t\t\t\tfound++;\n\t\t\t\tvarV[j]--;\n\t\t\t\trep(i,p)if(table[i][j]>=INF){\n\t\t\t\t\tans[table[i][j]-INF]=sumV[j];\n\t\t\t\t\ttable[i][j]=0;\n\t\t\t\t\tsumH[i]-=sumV[j];\n\t\t\t\t\tvarH[i]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found==var)break;\n\t\t\tif(!flag){\n\t\t\t\tcout<<found<<endl;\n\t\t\t\tno=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(no)cout<<\"NO\\n\";\n\t\telse{\n\t\t\trep(i,var)cout<<ans[i]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdlib>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int MISSING = 0x7fffffff;\n\nint main(){\n\twhile(true){\n\t\tint p, s;\n\t\tcin >> p >> s;\n\t\tif(p == 0 && s == 0){ continue; }\n\t\tvector< vector<int> > table(p + 1, vector<int>(s + 1));\n\t\tvector< vector<bool> > missing(p, vector<bool>(s));\n\t\tfor(int i = 0; i <= p; ++i){\n\t\t\tfor(int j = 0; j <= s; ++j){\n\t\t\t\tstring item;\n\t\t\t\tcin >> item;\n\t\t\t\tif(item == \"?\"){\n\t\t\t\t\ttable[i][j] = MISSING;\n\t\t\t\t\tmissing[i][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttable[i][j] = atoi(item.c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pii> q;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){ table[i][pos] = table[i][s] - sum; }\n\t\t}\n\t\tfor(int i = 0; i < s; ++i){\n\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\tfor(int j = 0; j < p; ++j){\n\t\t\t\tif(table[j][i] == MISSING){\n\t\t\t\t\t++count;\n\t\t\t\t\tpos = j;\n\t\t\t\t}else{\n\t\t\t\t\tsum += table[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){\n\t\t\t\ttable[pos][i] = table[p][i] - sum;\n\t\t\t\tq.push(pii(0, pos));\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tpii e = q.front();\n\t\t\tq.pop();\n\t\t\tif(e.first == 0){\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < s; ++i){\n\t\t\t\t\tif(table[e.second][i] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[e.second][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[e.second][pos] = table[e.second][s] - sum;\n\t\t\t\t\tq.push(pii(1, pos));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint count = 0, pos = 0, sum = 0;\n\t\t\t\tfor(int i = 0; i < p; ++i){\n\t\t\t\t\tif(table[i][e.second] == MISSING){\n\t\t\t\t\t\t++count;\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += table[i][e.second];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == 1){\n\t\t\t\t\ttable[pos][e.second] = table[p][e.second] - sum;\n\t\t\t\t\tq.push(pii(0, pos));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool valid = true;\n\t\tvector<int> answer;\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tfor(int j = 0; j < s; ++j){\n\t\t\t\tif(table[i][j] == MISSING){\n\t\t\t\t\tvalid = false;\n\t\t\t\t}else if(missing[i][j]){\n\t\t\t\t\tanswer.push_back(table[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!valid){\n\t\t\tcout << \"NO\" << endl;\n\t\t}else{\n\t\t\tfor(int i = 0; i < answer.size(); ++i){\n\t\t\t\tcout << answer[i] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\tbool flag = false;\n\twhile (1) {\n\t\tif (!flag) {\n\t\t\tflag = true;\n\t\t}\n\t\telse {\n\t\t\tcout << endl;\n\t\t}\n\t\tint H, W;\n\t\tcin >> H;\n\t\tif (!H)break;\n\t\tcin >> W;\n\t\tvector<int>rs(H), cs(W);\n\t\tint unknown = 0;\n\t\tmap<pair<int, int>, int>mp;\n\t\tvector<vector<int>>field(H + 1, vector<int>(W + 1));\n\t\tfor (int i = 0; i < H + 1; ++i) {\n\t\t\tfor (int j = 0; j < W + 1; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tint num;\n\t\t\t\tif (st == \"?\") {\n\t\t\t\t\tnum = 1e8;\n\t\t\t\t\tmp[make_pair(i, j)] = unknown++;\n\t\t\t\t\trs[i]++;\n\t\t\t\t\tcs[j]++;\n\t\t\t\t}\n\t\t\t\telse num = stoi(st);\n\t\t\t\tfield[i][j] = num;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>que;\n\t\tfor (int y = 0; y <= H; ++y) {\n\t\t\tif (rs[y] == 1) {\n\t\t\t\tque.push(make_pair(1, y));\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x <= W; ++x) {\n\t\t\tif (cs[x] == 1) {\n\t\t\t\tque.push(make_pair(0, x));\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tauto p(que.front());\n\t\t\tque.pop();\n\t\t\tif (p.first) {\n\t\t\t\tconst int y = p.second;\n\t\t\t\tif (rs[y] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\t\t\t\tif (field[y][i] != 1e8) {\n\t\t\t\t\t\t\tsum += i!=W?field[y][i]:-field[y][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != W) {\n\t\t\t\t\t\tfield[y][place] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[y][place] = sum;\n\t\t\t\t\t}\n\t\t\t\t\trs[y]--;\n\t\t\t\t\tcs[place]--;\n\t\t\t\t\tif (cs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(0, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst int x = p.second;\n\t\t\t\tif (cs[x] == 1) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tint place = -1;\n\t\t\t\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\t\t\t\tif (field[i][x] != 1e8) {\n\t\t\t\t\t\t\tsum += i != H ? field[i][x] : -field[i][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplace = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (place != H) {\n\t\t\t\t\t\tfield[place][x] = -sum;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[place][x] = sum;\n\t\t\t\t\t}\n\t\t\t\t\tcs[x]--;\n\t\t\t\t\trs[place]--;\n\t\t\t\t\tif (rs[place] == 1) {\n\t\t\t\t\t\tque.push(make_pair(1, place));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i <= H; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tsum += field[i][j];\n\t\t\t}\n\t\t\tif (sum != field[i][W])ok = false;\n\t\t}\n\t\tfor (int i = 0; i <= W; ++i) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < H; ++j)sum += field[j][i];\n\t\t\tif (sum != field[H][i])ok = false;\n\t\t}\n\t\tif (!ok)cout << \"NO\" << endl;\n\t\telse {\n\t\t\tfor (auto m : mp) {\n\t\t\t\tcout << field[m.first.first][m.first.second] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 1000000\nusing namespace std;\n\nmain(){\n  int p, s;\n  char num[10];\n  int data[100][10];\n  bool kai=false;\n  while(1){\n    cin >> p;\n    if(p==0) break;\n    if(kai) cout << endl;\n    cin >> s;\n    int tm=0;\n    for(int i=0;i<=p;i++){\n      for(int j=0;j<=s;j++){\n\tscanf(\"%s\", num);\n\tif(num[0]=='?'){\n\t  tm++;\n\t  data[i][j]=N;\n\t}\n\telse data[i][j]=atoi(num);\n      }\n    }\n\n    bool flag=true;\n    bool t[100][10];\n    for(int i=0;i<p;i++){\n      for(int j=0;j<s;j++){\n\tt[i][j]=false;\n      }\n    }\n    while(tm!=0){\n      bool end=true;\n      for(int i=0;i<=p;i++){\n\tint sum=0;\n\tint a;\n\tfor(int j=0;j<=s;j++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=j;\n\t  }\n\t}\n\tif(sum==1){\n\t  flag=false;\n\t  end=false;\n\t  int tmp=0;\n\t  for(int j=0;j<s;j++){\n\t    if(j==a) continue;\n\t    tmp+=data[i][j];\n\t  }\n\t  data[i][a]=data[i][s]-tmp;\n\t  t[i][a]=true;\n\t}\n      }\n\n      for(int j=0;j<=s;j++){\n\tint sum=0;\n\tint a;\n\tfor(int i=0;i<=p;i++){\n\t  if(data[i][j]==N){\n\t    sum++;\n\t    a=i;\n\t  }\n\t}\n\tif(sum==1){\n\t  flag=false;\n\t  end=false;\n\t  int tmp=0;\n\t  for(int i=0;i<p;i++){\n\t    if(i==a) continue;\n\t    tmp+=data[i][j];\n\t  }\n\t  data[a][j]=data[p][j]-tmp;\n\t  t[a][j]=true;\n\t}\n      }\n      if(end) break;\n    }\n    if(flag) cout << \"NO\" << endl;\n    else{\n      for(int i=0;i<p;i++){\n\tfor(int j=0;j<s;j++){\n\t  if(t[i][j]) cout << data[i][j] << endl;\n\t}\n      }\n    }\n    kai=true;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconstexpr int UNKNOWN = (1 << 25);\n\nvoid solve(vector<vector<int>> &matrix) {\n  const int h = matrix.size();\n  const int w = matrix[0].size();\n\n  vector<vector<bool>> is_question(h - 1, vector<bool>(w - 1));\n  vector<pair<int, int>> questions; // r, c\n  vector<int> num_qr(h - 1, 0), num_qc(w - 1, 0);\n  vector<int> sum_r(h - 1, 0), sum_c(w - 1, 0);\n\n  for(int i = 0; i < h - 1; ++i) {\n    sum_r[i] += matrix[i][w - 1];\n  }\n\n  for(int i = 0; i < w - 1; ++i) {\n    sum_c[i] += matrix[h - 1][i];\n  }\n\n  for(int i = 0; i < h - 1; ++i) {\n    for(int j = 0; j < w - 1; ++j) {\n      if(matrix[i][j] == UNKNOWN) {\n\tquestions.emplace_back(i, j);\n\t++num_qr[i];\n\t++num_qc[j];\n\tis_question[i][j] = true;\n      }\n      else {\n\tsum_r[i] -= matrix[i][j];\n\tsum_c[j] -= matrix[i][j];\n      }\n    }\n  }\n\n  while(!questions.empty()) {\n    bool unloop = true;\n    int i = 0;\n\n    while(i < questions.size()) {\n      const int r = questions[i].first;\n      const int c = questions[i].second;\n\n      int value = UNKNOWN;\n      if(num_qr[r] == 1) {\n\tvalue = sum_r[r];\n      }\n      else if(num_qc[c] == 1) {\n\tvalue = sum_c[c];\n      }\n\n      if(value == UNKNOWN) {\n\t++i;\n\tcontinue;\n      }\n\n      matrix[r][c] = value;\n      sum_r[r] -= value;\n      sum_c[c] -= value;\n      --num_qr[r];\n      --num_qc[c];\n      unloop = false;\n      questions.erase(questions.begin() + i);\n    }\n\n    if(unloop) break;\n  }\n\n  if(questions.empty()) { // unique answer\n    for(int i = 0; i < h - 1; ++i) {\n      for(int j = 0; j < w - 1; ++j) {\n\tif(is_question[i][j]) {\n\t  cout << matrix[i][j] << endl;\n\t}\n      }\n    }\n  }\n  else {\n    cout << \"NO\" << endl;\n  }\n  //cout << endl;\n}\n\nint main(){\n  bool first = true;\n  for(int p, s; cin >> p >> s && p;) {\n    if(!first) cout << endl;\n    first = false;\n\n    vector<vector<int>> matrix(p + 1, vector<int>(s + 1));\n    for(auto &row : matrix) {\n      for(auto &e : row) {\n\tstring input;\n\tcin >> input;\n\te = (input == \"?\" ? UNKNOWN : stoi(input));\n      }\n    }\n\n    solve(matrix);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w=-1,h,f[110][110],d[110][110],i,j,k,p,b,c;\n  char s[15];\n  while(scanf(\"%d\",&h),h){\n    int t[110]={0};\n    int y[110]={0};\n    if(w+1)printf(\"\\n\");\n    scanf(\"%d\",&w);\n    for(i=c=0;i<=h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%s\",s);\n\td[i][j]=f[i][j]=0;\n\tif(s[0]=='?'){\n\t  y[i]++;\n\t  t[j]++;\n\t  f[i][j]=1;\n\t  c++;\n\t}\n\telse{\n\t  for(k=0;s[k];k++)d[i][j]=d[i][j]*10+s[k]-'0';\n\t}\n      }\n    }\n    while(c){\n      b=1;\n      for(j=0;j<w;j++){\n\tif(t[j]-1)continue;\n\tfor(i=b=t[j]=0;i<h;i++){\n\t  if(f[i][j]==1)p=i;\n\t  d[h][j]-=d[i][j];\n\t}\n\td[p][j]=d[h][j];\n\ty[p]--;\n\tf[p][j]=2;\n\tc--;\n      }\n      for(i=0;i<h;i++){\n\tif(y[i]-1)continue;\n\tfor(j=b=y[i]=0;j<w;j++){\n\t  if(f[i][j]==1)p=j;\n\t  d[i][w]-=d[i][j];\n\t}\n\td[i][p]=d[i][w];\n\tt[p]--;\n\tf[i][p]=2;\n\tc--;\n      }\n      if(b)break;\n    }\n    if(c)printf(\"NO\\n\");\n    else{\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(f[i][j])printf(\"%d\\n\",d[i][j]);\n\t}//printf(\"\\n\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 999999999\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid printTable(int h,int w,int t[102][102],int *sales,int *totals){\n\tint i,j;\n\trep(i,h){\n\t\trep(j,w) printf(\"%10d\",t[i][j]);\n\t\tprintf(\"%10d\\n\",totals[i]);\n\t}\n\trep(i,w+1) printf(\"%10d\",sales[i]);\n\tprintf(\"\\n\\n\");\n}\n\nint main(void){\n\tint i,j;\n\tint h,w,tmp,startFlg,contFlg,count;\n\tint flg[102][102],t[102][102],totals[102],sales[102],ct[102],cs[102];\n\n\tstartFlg = 1;\n\twhile(scanf(\"%d\",&h) && h){\n\t\tif(startFlg) startFlg = 0;\n\t\telse printf(\"\\n\");\n\t\tscanf(\"%d\",&w);\n\n\t\trep(i,h+1) totals[i] = ct[i] = 0;\n\t\trep(i,w+1) sales[i] = cs[i] = 0;\n\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\ttmp = scanf(\"%d\",&t[i][j]);\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tct[i]++;\n\t\t\t\t\tcs[j]++;\n\t\t\t\t\tflg[i][j] = 1;\n\t\t\t\t\tt[i][j] = INF;\n\t\t\t\t\tgetchar();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflg[i][j] = 0;\n\t\t\t\t\ttotals[i] -= t[i][j];\n\t\t\t\t\tsales[j] -= t[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\ttotals[i] += tmp;\n\t\t}\n\t\trep(i,w+1){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tsales[i] += tmp;\n\t\t}\n\n\t\tcontFlg = 1;\n\t\twhile(contFlg){\n\t\t\tcontFlg = count = 0;\n\t\t\trep(i,h){\n\t\t\t\trep(j,w){\n\t\t\t\t\tif(t[i][j] == INF){\n\t\t\t\t\t\tif(ct[i] == 1){\n\t\t\t\t\t\t\tt[i][j] = totals[i];\n\t\t\t\t\t\t\tsales[j] -= totals[i];\n\t\t\t\t\t\t\ttotals[i] = 0;\n\t\t\t\t\t\t\tct[i] = 0;\n\t\t\t\t\t\t\tcs[j]--;\n\n\t\t\t\t\t\t\tcontFlg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(cs[j] == 1){\n\t\t\t\t\t\t\tt[i][j] = sales[j];\n\t\t\t\t\t\t\ttotals[i] -= sales[j];\n\t\t\t\t\t\t\tsales[j] = 0;\n\t\t\t\t\t\t\tct[i]--;\n\t\t\t\t\t\t\tcs[j] = 0;\n\n\t\t\t\t\t\t\tcontFlg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(count == 0){\n\t\t\trep(i,h) rep(j,w) if(flg[i][j] && t[i][j] != INF) {\n\t\t\t\tprintf(\"%d\\n\",t[i][j]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w=-1,h,f[110][110],d[110][110],i,j,k,p,b,c,m=1;\n  char s[15];\n  while(scanf(\"%d\",&h),h){\n    int t[110]={0};\n    int y[110]={0};\n    if(w+1)printf(\"\\n\");\n    scanf(\"%d\",&w);\n    for(i=c=0;i<=h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%s\",s);\n\td[i][j]=f[i][j]=0;\n\tif(s[0]=='?'){\n\t  y[i]++;\n\t  t[j]++;\n\t  f[i][j]=1;\n\t  c++;\n\t}\n\telse{\n\t  m=1;\n\t  if(s[k=0]=='-'){\n\t    m=-1;\n\t    k++;\n\t  }\n\t  for(;s[k];k++)d[i][j]=d[i][j]*10+s[k]-'0';\n\t  d[i][j]*=m;\n\t}\n      }\n    }\n    while(c){\n      b=1;\n      for(j=0;j<w;j++){\n\tif(t[j]-1)continue;\n\tfor(i=b=t[j]=0;i<h;i++){\n\t  if(f[i][j]==1)p=i;\n\t  d[h][j]-=d[i][j];\n\t}\n\td[p][j]=d[h][j];\n\ty[p]--;\n\tf[p][j]=2;\n\tc--;\n      }\n      for(i=0;i<h;i++){\n\tif(y[i]-1)continue;\n\tfor(j=b=y[i]=0;j<w;j++){\n\t  if(f[i][j]==1)p=j;\n\t  d[i][w]-=d[i][j];\n\t}\n\td[i][p]=d[i][w];\n\tt[p]--;\n\tf[i][p]=2;\n\tc--;\n      }\n      if(b)break;\n    }\n    if(c)printf(\"NO\\n\");\n    else{\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(f[i][j])printf(\"%d\\n\",d[i][j]);\n\t}//printf(\"\\n\");\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1117: Missing Numbers\n// 2017.9.15 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\ntypedef struct { int r, c, f; } T;\nT q[MAX+5]; int len;\nlong long a[105][15]; char b[105][15]; int h, w;\nlong long sr[105], sc[15];\nint kr[105], kc[15];\n\n///=======================\n// for topologicalSort\nint  Q[MAX+5], top, end;\nint  count[MAX+5];\nchar tbl[MAX+5][MAX+5];\nvoid topologicalSort(int size)\n{\n\tint i, j, r, c;\n\n\tmemset(count, 0, sizeof(count));\n\ttop = end = 0;\n\tfor (i = 0; i < size; i++) for (j = 0; j < size; j++) if (tbl[i][j]) count[j]++;\n\tfor (i = 0; i < size; i++) if (count[i] == 1) Q[end++] = i;\n\twhile (top < end) {\n\t\ti = Q[top++];\n\t\tr = q[i].r, c = q[i].c;\n\t\tif (kc[r] == 1) {\n\t\t\ta[r][c] = a[r][w] - sc[r], b[r][c] = 0, sc[r] += a[r][c], sr[c] += a[r][c];\n\t\t\tkc[r] = 0, kr[c]--;\n\t\t} else {\n\t\t\ta[r][c] = a[h][c] - sr[c], b[r][c] = 0, sr[c] += a[r][c], sc[r] += a[r][c];\n\t\t\tkr[c] = 0, kc[r]--;\n\t\t}\n\t\tfor (j = 0; j < size; j++) {\n\t\t\tif (tbl[i][j]) if (--count[j] == 1) Q[end++] = j;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint r, c, i, j, k;\n\tchar buf[20];\n\tint cno = 0;\n\n\twhile (scanf(\"%d\", &h) && h) {\n\t\tscanf(\"%d\", &w); cno++;\n\t\tfor (len = 0, r = 0; r <= h; r++) for (c = 0; c <= w; c++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tif (*buf == '?') a[r][c] = 0, b[r][c] = 1, q[len].r = r, q[len].c = c, q[len++].f = 1;\n\t\t\telse             a[r][c] = atoi(buf), b[r][c] = 0;\n\t\t}\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (j == 0 || j == 3) for (r = 0; r < h; r++) {\n\t\t\t\tfor (sc[r] = k = 0, c = 0; c < w; c++) {\n\t\t\t\t\tsc[r] += a[r][c], k += b[r][c]; if (b[r][c]) i = c;\n\t\t\t\t}\n\t\t\t\tif (k == 1)\n\t\t\t\t\tc = i, a[r][c] = a[r][w] - sc[r], b[r][c] = 0, sc[r] += a[r][c], sr[c] += a[r][c];\n\t\t\t}\n\t\t\tif (j == 1 || j == 2) for (c = 0; c < w; c++) {\n\t\t\t\tfor (sr[c] = k = 0, r = 0; r < h; r++) {\n\t\t\t\t\tsr[c] += a[r][c], k += b[r][c]; if (b[r][c]) i = r;\n\t\t\t\t}\n\t\t\t\tif (k == 1)\n\t\t\t\t\tr = i, a[r][c] = a[h][c] - sr[c], b[r][c] = 0, sr[c] += a[r][c], sc[r] += a[r][c];\n\t\t\t}\n\t\t}\n\t\tfor (k = 0, i = 0; i < len; i++) if (b[q[i].r][q[i].c]) k = 1; else q[i].f = 0;\n\t\tif (k) {\n\t\t\tfor (r = 0; r < h; r++) { for (k = c = 0; c < w; c++) k += b[r][c]; kc[r] = k; }\n\t\t\tfor (c = 0; c < w; c++) { for (k = r = 0; r < h; r++) k += b[r][c]; kr[c] = k; }\n\t\t\tmemset(tbl, 0, sizeof(tbl));\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (!q[i].f) continue;\n\t\t\t\tfor (j = i+1; j < len; j++) {\n\t\t\t\t\tif (!q[j].f) continue;\n\t\t\t\t\ttbl[i][j] = tbl[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttopologicalSort(len);\n\t\t\tfor (k = 0, i = 0; i < len; i++) { if (b[q[i].r][q[i].c]) k = 1; break; }\n\t\t}\n\t\tif (cno > 1) putchar('\\n');\n\t\tif (k == 0) for (i = 0; i < len; i++) printf(\"%lld\\n\", a[q[i].r][q[i].c]);\n\t\telse puts(\"NO\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_PN\t(100)\n#define MAX_SN\t(10)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  int x, y;\n} pt_t;\n\n/* global variables */\n\nstatic int tbl[MAX_PN][MAX_SN];\nstatic pt_t vars[MAX_PN * MAX_SN];\nstatic char fixed[MAX_PN * MAX_SN];\nstatic int hnvs[MAX_PN], vnvs[MAX_SN];\n\n/* subroutines */\n\n/* main */\n\nint main(int argc, char **argv) {\n  int changed, i, j, k, nv, nvars, pn, sn, sum, x, x0, y, y0;\n  char line[1024];\n\n  for (;;) {\n    scanf(\"%d\", &pn);\n    if (pn == 0) break;\n\n    scanf(\"%d\", &sn);\n\n    bzero(hnvs, sizeof(hnvs));\n    bzero(vnvs, sizeof(vnvs));\n    nvars = 0;\n\n    for (y = 0; y <= pn; y++)\n      for (x = 0; x <= sn; x++) {\n\tscanf(\"%s\", line);\n\tif (line[0] == '?') {\n\t  tbl[y][x] = 0;\n\t  vars[nvars].x = x;\n\t  vars[nvars].y = y;\n\t  fixed[nvars] = 0;\n\t  nvars++;\n\t  hnvs[y]++;\n\t  vnvs[x]++;\n\t}\n\telse\n\t  tbl[y][x] = atoi(line);\n      }\n\n    nv = nvars;\n    changed = 1;\n\n    while (nv > 0 && changed) {\n      changed = 0;\n\n      for (i = 0; i < nvars; i++) {\n\tx = vars[i].x;\n\ty = vars[i].y;\n\n\tif (fixed[i]) continue;\n\n\tif (hnvs[y] == 1) {\n\t  if (x == sn) {\n\t    sum = 0;\n\t    for (j = 0; j < sn; j++) sum += tbl[y][j];\n\t    tbl[y][x] = sum;\n\t  }\n\t  else {\n\t    sum = 0;\n\t    for (j = 0; j < sn; j++)\n\t      if (j != x) sum += tbl[y][j];\n\t    tbl[y][x] = tbl[y][sn] - sum;\n\t  }\n\n\t  nv--;\n\t  hnvs[y]--;\n\t  vnvs[x]--;\n\t  fixed[i] = 1;\n\t  changed = 1;\n\t}\n\n\tif (fixed[i]) continue;\n\n\tif (vnvs[x] == 1) {\n\t  if (y == pn) {\n\t    sum = 0;\n\t    for (j = 0; j < pn; j++) sum += tbl[j][x];\n\t    tbl[y][x] = sum;\n\t  }\n\t  else {\n\t    sum = 0;\n\t    for (j = 0; j < sn; j++)\n\t      if (j != y) sum += tbl[j][x];\n\t    tbl[y][x] = tbl[pn][x] - sum;\n\t  }\n\n\t  nv--;\n\t  hnvs[y]--;\n\t  vnvs[x]--;\n\t  fixed[i] = 1;\n\t  changed = 1;\n\t}\n      }\n    }\n\n    if (nv > 0)\n      puts(\"NO\");\n    else {\n      for (i = 0; i < nvars; i++) {\n\tx = vars[i].x;\n\ty = vars[i].y;\n\tprintf(\"%d\\n\", tbl[y][x]);\n      }\n    }\n\n    putchar('\\n');\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void) {\n\tint did=0;\n\tint p,s;\n\tint price[100][10];\n\tint price_unknown[100][10];\n\tint price_unknown_raw[100][10];\n\tchar buffer[20];\n\tint i,j;\n\tint updated;\n\tint error;\n\tint missing_exist;\n\tint missing_id;\n\tint missing_number;\n\tint sum;\n\twhile(1) {\n\t\tscanf(\"%d\",&p);\n\t\tif(p==0)break;\n\t\tscanf(\"%d\",&s);\n\t\tif(did)putchar('\\n');\n\t\tmemset(price,0,sizeof(price));\n\t\tmemset(price_unknown,0,sizeof(price_unknown));\n\t\tmemset(price_unknown_raw,0,sizeof(price_unknown_raw));\n\t\tfor(i=0;i<=p;i++) {\n\t\t\tfor(j=0;j<=s;j++) {\n\t\t\t\tscanf(\"%s\",buffer);\n\t\t\t\tif(buffer[0]=='?' && buffer[1]==0) {\n\t\t\t\t\tprice_unknown[i][j]=1;\n\t\t\t\t\tprice_unknown_raw[i][j]=1;\n\t\t\t\t} else {\n\t\t\t\t\tprice[i][j]=atoi(buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tupdated=1;\n\t\terror=missing_exist=0;\n\t\twhile(updated && !error) {\n\t\t\tupdated=0;\n\t\t\tmissing_exist=0;\n\t\t\tfor(i=0;i<p;i++) {\n\t\t\t\tmissing_number=missing_id=0;\n\t\t\t\tsum=0;\n\t\t\t\tfor(j=0;j<s;j++) {\n\t\t\t\t\tif(price_unknown[i][j]) {\n\t\t\t\t\t\tmissing_number++;\n\t\t\t\t\t\tmissing_id=j;\n\t\t\t\t\t\tmissing_exist=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum+=price[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(missing_number==1) {\n\t\t\t\t\tprice[i][missing_id]=price[i][s]-sum;\n\t\t\t\t\tprice_unknown[i][missing_id]=0;\n\t\t\t\t\tupdated=1;\n\t\t\t\t} else if(missing_number==0) {\n\t\t\t\t\tif(sum!=price[i][s])error=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<s;j++) {\n\t\t\t\tmissing_number=missing_id=0;\n\t\t\t\tsum=0;\n\t\t\t\tfor(i=0;i<p;i++) {\n\t\t\t\t\tif(price_unknown[i][j]) {\n\t\t\t\t\t\tmissing_number++;\n\t\t\t\t\t\tmissing_id=i;\n\t\t\t\t\t\tmissing_exist=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum+=price[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(missing_number==1) {\n\t\t\t\t\tprice[missing_id][j]=price[p][j]-sum;\n\t\t\t\t\tprice_unknown[missing_id][j]=0;\n\t\t\t\t\tupdated=1;\n\t\t\t\t} else if(missing_number==0) {\n\t\t\t\t\tif(sum!=price[p][j])error=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(error || missing_exist) {\n\t\t\tputs(\"NO\");\n\t\t} else {\n\t\t\tfor(i=0;i<p;i++) {\n\t\t\t\tfor(j=0;j<s;j++) {\n\t\t\t\t\tif(price_unknown_raw[i][j])printf(\"%d\\n\",price[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdid=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 999999999\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid printTable(int h,int w,int t[102][102],int *sales,int *totals){\n\tint i,j;\n\trep(i,h){\n\t\trep(j,w) printf(\"%10d\",t[i][j]);\n\t\tprintf(\"%10d\\n\",totals[i]);\n\t}\n\trep(i,w+1) printf(\"%10d\",sales[i]);\n\tprintf(\"\\n\\n\");\n}\n\nint main(void){\n\tint i,j;\n\tint h,w,tmp,contFlg,count;\n\tint flg[102][102],t[102][102],totals[102],sales[102],ct[102],cs[102];\n\n\twhile(scanf(\"%d\",&h) && h){\n\t\tscanf(\"%d\",&w);\n\n\t\trep(i,h+1) totals[i] = ct[i] = 0;\n\t\trep(i,w+1) sales[i] = cs[i] = 0;\n\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\ttmp = scanf(\"%d\",&t[i][j]);\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\tct[i]++;\n\t\t\t\t\tcs[j]++;\n\t\t\t\t\tflg[i][j] = 1;\n\t\t\t\t\tt[i][j] = INF;\n\t\t\t\t\tgetchar();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tflg[i][j] = 0;\n\t\t\t\t\ttotals[i] -= t[i][j];\n\t\t\t\t\tsales[j] -= t[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\ttotals[i] += tmp;\n\t\t}\n\t\trep(i,w+1){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\tsales[i] += tmp;\n\t\t}\n\n\t\tcontFlg = 1;\n\t\twhile(contFlg){\n\t\t\tcontFlg = count = 0;\n\t\t\trep(i,h){\n\t\t\t\trep(j,w){\n\t\t\t\t\tif(t[i][j] == INF){\n\t\t\t\t\t\tif(ct[i] == 1){\n\t\t\t\t\t\t\tt[i][j] = totals[i];\n\t\t\t\t\t\t\tsales[j] -= totals[i];\n\t\t\t\t\t\t\ttotals[i] = 0;\n\t\t\t\t\t\t\tct[i] = 0;\n\t\t\t\t\t\t\tcs[j]--;\n\n\t\t\t\t\t\t\tcontFlg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(cs[j] == 1){\n\t\t\t\t\t\t\tt[i][j] = sales[j];\n\t\t\t\t\t\t\ttotals[i] -= sales[j];\n\t\t\t\t\t\t\tsales[j] = 0;\n\t\t\t\t\t\t\tct[i]--;\n\t\t\t\t\t\t\tcs[j] = 0;\n\n\t\t\t\t\t\t\tcontFlg = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(count == 0){\n\t\t\trep(i,h) rep(j,w) if(flg[i][j] && t[i][j] != INF) {\n\t\t\t\tprintf(\"%d\\n\",t[i][j]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1117: Missing Numbers\n// 2017.9.15 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int r, c, f; } T;\nT q[1005]; int len;\nlong long a[105][15]; char b[105][15]; int h, w;\nlong long sr[105], sc[15];\nint kr[105], kc[15];\n\nint main()\n{\n\tint r, c, i, k, f;\n\tchar buf[20];\n\tint cno = 0;\n\n\twhile (scanf(\"%d\", &h) && h) {\n\t\tscanf(\"%d\", &w); cno++;\n\t\tfor (len = 0, r = 0; r <= h; r++) for (c = 0; c <= w; c++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tif (*buf == '?') a[r][c] = 0, b[r][c] = 1, q[len].r = r, q[len].c = c, q[len++].f = 1;\n\t\t\telse             a[r][c] = atoi(buf), b[r][c] = 0;\n\t\t}\n\t\tf = 1; while (f) {\n\t\t\tf = 0;\n\t\t\tfor (r = 0; r < h; r++) {\n\t\t\t\tfor (sc[r] = k = 0, c = 0; c < w; c++) {\n\t\t\t\t\tsc[r] += a[r][c], k += b[r][c]; if (b[r][c]) i = c;\n\t\t\t\t}\n\t\t\t\tif (k == 1) {\n\t\t\t\t\tc = i, a[r][c] = a[r][w] - sc[r], b[r][c] = 0, sc[r] += a[r][c], sr[c] += a[r][c];\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tfor (sr[c] = k = 0, r = 0; r < h; r++) {\n\t\t\t\t\tsr[c] += a[r][c], k += b[r][c]; if (b[r][c]) i = r;\n\t\t\t\t}\n\t\t\t\tif (k == 1) {\n\t\t\t\t\tr = i, a[r][c] = a[h][c] - sr[c], b[r][c] = 0, sr[c] += a[r][c], sc[r] += a[r][c];\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (k = 0, i = 0; i < len; i++) if (b[q[i].r][q[i].c]) k = 1; else q[i].f = 0;\n\t\tif (cno > 1) putchar('\\n');\n\t\tif (k == 0) for (i = 0; i < len; i++) printf(\"%lld\\n\", a[q[i].r][q[i].c]);\n\t\telse puts(\"NO\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main {\n     \n\tpublic static final int P_MAX = 100;\n\tpublic static final int S_MAX = 10;\n\t\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] unknown_product = new int[P_MAX];\n        int[] unknown_store   = new int[S_MAX];\n        \n        int[] known_product_sum = new int[P_MAX];\n        int[] known_store_sum   = new int[S_MAX];\n        \n        int[] all_product_sum = new int[P_MAX];\n        int[] all_store_sum   = new int[S_MAX];\n        \n        int[][] table = new int[P_MAX][S_MAX];\n        boolean[][] unknown = new boolean[P_MAX][S_MAX];\n        \n        boolean first = true;\n        while(true){\n        \tfinal int p = sc.nextInt();\n        \t\n        \tif(p == 0){\n        \t\tbreak;\n        \t}\n        \t\n        \tif(!first){\n        \t\tSystem.out.println();\n        \t}\n        \t\n        \tfinal int s = sc.nextInt();\n        \t\n        \tArrays.fill(unknown_product, 0);\n        \tArrays.fill(unknown_store  , 0);\n        \tArrays.fill(known_product_sum, 0);\n        \tArrays.fill(known_store_sum  , 0);\n        \tArrays.fill(all_product_sum, 0);\n        \tArrays.fill(all_store_sum  , 0);\n        \t\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tString input = sc.next();\n        \t\t\t\n        \t\t\tif(\"?\".equals(input)){\n        \t\t\t\tunknown_product[i]++;\n        \t\t\t\tunknown_store[j]++;\n        \t\t\t\t\n        \t\t\t\ttable[i][j] = Integer.MIN_VALUE;\n        \t\t\t\tunknown[i][j] = true;\n        \t\t\t}else{\n        \t\t\t\tfinal int number = Integer.parseInt(input);\n        \t\t\t\t\n        \t\t\t\tknown_product_sum[i] += number;\n        \t\t\t\tknown_store_sum[j]   += number;\n        \t\t\t\ttable[i][j] = number;\n        \t\t\t\tunknown[i][j] = false;\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tall_product_sum[i] = sc.nextInt();\n        \t}\n        \t\n        \tfor(int i = 0; i <= s; i++){\n        \t\tfinal int sum = sc.nextInt();\n        \t\t\n        \t\tif(i == s){\n        \t\t\tcontinue;\n        \t\t}\n        \t\t\n        \t\tall_store_sum[i] = sum;\n        \t}\n        \t\n        \twhile(true){\n        \t\tboolean updated = false;\n        \t\t\n        \t\t//System.out.println(Arrays.toString(unknown_product));\n        \t\t//System.out.println(Arrays.toString(unknown_store));\n        \t\t\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tif(unknown_product[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\t\tif(table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[i][j] = all_product_sum[i] - known_product_sum[i];\n        \t\t\t\t\t\tunknown_product[i]--;\n        \t\t\t\t\t\tunknown_store[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_product_sum[i] += table[i][j];\n        \t\t\t\t\t\tknown_store_sum[j] += table[i][j];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tfor(int i = 0; i < s; i++){\n        \t\t\tif(unknown_store[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < p; j++){\n        \t\t\t\t\tif(table[j][i] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[j][i] = all_store_sum[i] - known_store_sum[i];\n        \t\t\t\t\t\tunknown_store[i]--;\n        \t\t\t\t\t\tunknown_product[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_store_sum[i] += table[j][i];\n        \t\t\t\t\t\tknown_product_sum[j] += table[j][i];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tif(!updated){\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \t\n        \tboolean flag = true;\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tif(unknown[i][j] && table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\tflag = false;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tif(!flag){\n        \t\tSystem.out.println(\"NO\");\n        \t}else{\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\tif(unknown[i][j]){\n        \t\t\t\t\tSystem.out.println(table[i][j]);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tif(first){\n        \t\tfirst = false;\n        \t}\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint n, m;\n\tint[][] a;\n\tboolean[][] q;\n\tArrayList<P> list;\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tboolean first=true;\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=sc.nextInt();\n\t\t\ta=new int[n+1][m+1];\n\t\t\tq=new boolean[n+1][m+1];\n\t\t\tlist=new ArrayList<P>();\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int i=0; i<=m; i++){\n\t\t\t\t\tString s=sc.next();\n\t\t\t\t\tif(s.equals(\"?\")){\n\t\t\t\t\t\tq[j][i]=true;\n\t\t\t\t\t\tlist.add(new P(i, j));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[j][i]=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(first){\n\t\t\t\tfirst=false;\n\t\t\t}else{\n\t\t\t\tprintln(\"\");\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(;;){\n\t\t\tint[] sumM=new int[m];\n\t\t\tint[] sumN=new int[n];\n\t\t\tint[] qM=new int[m];\n\t\t\tint[] qN=new int[n];\n\t\t\tboolean[] oneM=new boolean[m];\n\t\t\tboolean[] oneN=new boolean[n];\n\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint count=0;\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(q[j][i]){\n\t\t\t\t\t\tqM[i]=j;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsumM[i]+=a[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toneM[i]=count==1;\n\t\t\t}\n\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tint count=0;\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tif(q[j][i]){\n\t\t\t\t\t\tqN[j]=i;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsumN[j]+=a[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toneN[j]=count==1;\n\t\t\t}\n\n\t\t\tboolean update=false;\n\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(oneM[i]){\n\t\t\t\t\toneN[qM[i]]=false;// ツつ「ツづァツづア\n\t\t\t\t\tq[qM[i]][i]=false;\n\t\t\t\t\ta[qM[i]][i]=a[n][i]-sumM[i];\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(oneN[j]){\n\t\t\t\t\tq[j][qN[j]]=false;\n\t\t\t\t\ta[j][qN[j]]=a[j][m]-sumN[j];\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tboolean all=true;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tall&=!q[j][i];\n\t\t\t}\n\t\t}\n\t\tif(all){\n\t\t\tfor(P p : list){\n\t\t\t\tprintln(\"\"+a[p.y][p.x]);\n\t\t\t}\n\t\t}else{\n\t\t\tprintln(\"NO\");\n\t\t}\n\t}\n\n\tvoid dfs(){\n\t\tboolean[] oneM=new boolean[m];\n\t\tboolean[] oneN=new boolean[n];\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint count=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(q[j][i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toneM[i]=count==1;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint count=0;\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(q[j][i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toneN[j]=count==1;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\t// 1ツづ按づ個つェツつ?づェツづ篠個按津ィ\n\t\t\tif(oneN[j]){\n\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int h, w;\n    int[][] s;\n    int[] ans;\n    int next;\n    HashMap<Integer, Integer>  Answers;\n    int max = Integer.MAX_VALUE;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    h = sc.nextInt();\n\t    if(h!=0){\n\t\tput();\n\t\t//show();\t\n\t\tsolve();\n\t\tSystem.out.println();\n\t    }\n\t}\n    }\n\n    void put(){\n\tw = sc.nextInt();\n\ts = new int[h+2][w+2];\n\tfor(int i=1; i<(h+2); i++){\n\t    for(int k=1; k<(w+2); k++){\n\t\tString t = sc.next();\n\t\tif(t.equals(\"?\")){\n\t\t    s[i][k] = max;\n\t\t    s[i][0]++; s[0][k]++;\n\t\t    s[0][0]++;\n\t\t}\n\t\telse s[i][k] = Integer.parseInt(t);\n\t    }\n\t    //System.out.println();\n\t}\n\tans = new int[s[0][0]];\n\tnext = 0;\n\tAnswers = new HashMap<Integer, Integer>();\n    }\n\n    void solve(){\n\tboolean con = check();\n\tboolean did = false;\n\n\twhile(con && s[0][0]>0){\n\t    for(int i=1; i<s.length; i++)\n\t\tif(s[i][0]==1){\n\t\t    int k = 1;\n\t\t    while(s[i][k]!=max)k++;\n\t\t    calc(i, k, \"x\"); \n\t\t    did = true;\n\t\t}\n\t    for(int k=1; k<s[h].length; k++)\n\t\tif(s[0][k]==1){\n\t\t    int i = 1;\n\t\t    while(s[i][k]!=max)i++;\n\t\t    calc(i, k, \"y\"); \n\t\t    did = true;\n\t\t}\n\t    con = check();\n\t    if(!did) con = false;\n\t}\n\tArrays.sort(ans);\n\tif(s[0][0]==0)\n\t    for(int i=0; i<ans.length; i++)\n\t\tSystem.out.println(Answers.get(ans[i]));\n\telse\n\t    System.out.println(\"NO\");\n    }\n\n    void calc(int h, int w, String t){\n\tint a = 0;\n\tif(t.equals(\"y\")){\n\t    for(int i=1; i<s.length; i++){\n\t\tif(i==s.length-1) a += s[i][w];\n\t\telse if(i!=h) a -= s[i][w];\n\t    }\n\t}\n\telse {\n\t    for(int k=1; k<s[h].length; k++){\n\t\tif(k==s[h].length-1) a += s[h][k];\n\t\telse if(k!=w) a -= s[h][k];\n\t    }\n\t}\n\tans[next++] = (h-1)*s[h].length+w;\n\tAnswers.put((h-1)*s[h].length+w, a);\n\ts[h][w] = a;\n\ts[0][w]--; s[h][0]--; s[0][0]--;\n\t//System.out.println(\"*\"+h+\" \"+w+\" \"+t);\n    }\n\n    boolean check(){\n\tint count = 0;\n\tfor(int i=1; i<s.length; i++)\n\t    if(s[i][0]==1) count++;\n\tfor(int k=1; k<s[h].length; k++)\n\t    if(s[0][k]==1) count++;\n\treturn count>0 ? true : false;\n    }\n\n    void show(){\n\tfor(int i=0; i<s.length; i++){\n\t    for(int k=0; k<s[i].length; k++)\n\t\tSystem.out.print(s[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}\n\n\n\t\t\t    "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int h, w;\n    int[][] s;\n    int[] ans;\n    int next;\n    HashMap<Integer, Integer>  Answers;\n    int max = Integer.MAX_VALUE;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    h = sc.nextInt();\n\t    if(h!=0){\n\t\tput();\t\n\t\tsolve();\n\t\tSystem.out.println();\n\t    }\n\t}\n    }\n\n    void put(){\n\tw = sc.nextInt();\n\ts = new int[h+2][w+2];\n\tfor(int i=1; i<(h+2); i++){\n\t    for(int k=1; k<(w+2); k++){\n\t\tString t = sc.next();\n\t\tif(t.equals(\"?\")){\n\t\t    s[i][k] = max;\n\t\t    s[i][0]++; s[0][k]++;\n\t\t    s[0][0]++;\n\t\t}\n\t\telse s[i][k] = Integer.parseInt(t);\n\t    }\n\t    //System.out.println();\n\t}\n\tans = new int[s[0][0]];\n\tnext = 0;\n\tAnswers = new HashMap<Integer, Integer>();\n    }\n\n    void solve(){\n\tboolean con = true;\n\tboolean did = false;\n\twhile(con && s[0][0]>0){\n\t    for(int i=1; i<s.length; i++)\n\t\tfor(int k=1; k<s[i].length; k++)\n\t\t    if(s[i][k]==max)\n\t\t\tif(s[0][k]==1){ calc(i, k, \"i\"); did = true; }\n\t\t\telse if(s[i][0]==1){ calc(i, k, \"k\"); did = true; }\n\t    if(!did) con = false;\n\t}\n\tArrays.sort(ans);\n\tif(con)\n\t    for(int i=0; i<ans.length; i++)\n\t\tSystem.out.println(Answers.get(ans[i]));\n\telse\n\t    System.out.println(\"NO\");\n    }\n\n    void calc(int h, int w, String t){\n\tint a = 0;\n\tif(t.equals(\"i\")){\n\t    for(int i=1; i<s.length; i++){\n\t\tif(i==s.length-1) a += s[i][w];\n\t\telse if(i!=h) a -= s[i][w];\n\t    }\n\t}\n\telse {\n\t    for(int k=1; k<s[h].length; k++){\n\t\tif(k==s[h].length-1) a += s[h][k];\n\t\telse if(k!=w) a -= s[h][k];\n\t    }\n\t}\n\tans[next++] = (h-1)*s[h].length+w;\n\tAnswers.put((h-1)*s[h].length+w, a);\n\ts[h][w] = a;\n\ts[0][w]--; s[h][0]--; s[0][0]--;\n\t//System.out.println(\"*\"+h+\" \"+w+\" \"+a);\n    }\n}\n\n\n\t\t\t    "
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int h, w;\n    int[][] s;\n    int[] ans;\n    int next;\n    HashMap<Integer, Integer>  Answers;\n    int max = Integer.MAX_VALUE;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    h = sc.nextInt();\n\t    if(h!=0){\n\t\tput();\n\t\t//show();\t\n\t\tsolve();\n\t\tSystem.out.println();\n\t    }\n\t}\n    }\n\n    void put(){\n\tw = sc.nextInt();\n\ts = new int[h+2][w+2];\n\tfor(int i=1; i<(h+2); i++){\n\t    for(int k=1; k<(w+2); k++){\n\t\tString t = sc.next();\n\t\tif(t.equals(\"?\")){\n\t\t    s[i][k] = max;\n\t\t    s[i][0]++; s[0][k]++;\n\t\t    s[0][0]++;\n\t\t}\n\t\telse s[i][k] = Integer.parseInt(t);\n\t    }\n\t    //System.out.println();\n\t}\n\tans = new int[s[0][0]];\n\tnext = 0;\n\tAnswers = new HashMap<Integer, Integer>();\n    }\n\n    void solve(){\n\tboolean con = check();\n\tboolean did = false;\n\n\twhile(con && s[0][0]>0){\n\t    for(int i=1; i<s.length; i++)\n\t\tif(s[i][0]==1){\n\t\t    int k = 1;\n\t\t    while(s[i][k]!=max)k++;\n\t\t    calc(i, k, \"x\"); \n\t\t    did = true;\n\t\t}\n\t    for(int k=1; k<s[h].length; k++)\n\t\tif(s[0][k]==1){\n\t\t    int i = 1;\n\t\t    while(s[i][k]!=max)i++;\n\t\t    calc(i, k, \"y\"); \n\t\t    did = true;\n\t\t}\n\t    con = check();\n\t    if(!did) con = false;\n\t}\n\tArrays.sort(ans);\n\tif(s[0][0]==0)\n\t    for(int i=0; i<ans.length; i++)\n\t\tSystem.out.println(Answers.get(ans[i]));\n\telse\n\t    System.out.println(\"NO\");\n    }\n\n    void calc(int h, int w, String t){\n\tint a = 0;\n\tif(t.equals(\"y\")){\n\t    for(int i=1; i<s.length; i++){\n\t\tif(i==s.length-1) a += s[i][w];\n\t\telse if(i!=h) a -= s[i][w];\n\t    }\n\t}\n\telse {\n\t    for(int k=1; k<s[h].length; k++){\n\t\tif(k==s[h].length-1) a += s[h][k];\n\t\telse if(k!=w) a -= s[h][k];\n\t    }\n\t}\n\tans[next++] = (h-1)*s[h].length+w;\n\tAnswers.put((h-1)*s[h].length+w, a);\n\ts[h][w] = a;\n\ts[0][w]--; s[h][0]--; s[0][0]--;\n\t//System.out.println(\"*\"+h+\" \"+w+\" \"+t);\n    }\n\n    boolean check(){\n\tint count = 0;\n\tfor(int i=1; i<s.length; i++)\n\t    if(s[i][0]==1) count++;\n\tfor(int k=1; k<s[h].length; k++)\n\t    if(s[0][k]==1) count++;\n\treturn count>0 ? true : false;\n    }\n\n    void show(){\n\tfor(int i=0; i<s.length; i++){\n\t    for(int k=0; k<s[i].length; k++)\n\t\tSystem.out.print(s[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}\n\n\n\t\t\t    "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int h, w;\n    int[][] s;\n    int[] ans;\n    int next;\n    HashMap<Integer, Integer>  Answers;\n    int max = Integer.MAX_VALUE;\n\n    void run(){\n\tint ca = 0;\n\twhile(sc.hasNext()){\n\t    h = sc.nextInt();\n\t    if(h!=0){\n\t\tif(ca>0)System.out.println();\n\t\tput();\n\t\t//show();\t\n\t\tsolve();\n\t\tca++;\n\t    }\n\t}\n    }\n\n    void put(){\n\tw = sc.nextInt();\n\ts = new int[h+2][w+2];\n\tfor(int i=1; i<(h+2); i++){\n\t    for(int k=1; k<(w+2); k++){\n\t\tString t = sc.next();\n\t\tif(t.equals(\"?\")){\n\t\t    s[i][k] = max;\n\t\t    s[i][0]++; s[0][k]++;\n\t\t    s[0][0]++;\n\t\t}\n\t\telse s[i][k] = Integer.parseInt(t);\n\t    }\n\t    //System.out.println();\n\t}\n\tans = new int[s[0][0]];\n\tnext = 0;\n\tAnswers = new HashMap<Integer, Integer>();\n    }\n\n    void solve(){\n\tboolean con = check();\n\tboolean did = false;\n\n\twhile(con && s[0][0]>0){\n\t    for(int i=1; i<s.length; i++)\n\t\tif(s[i][0]==1){\n\t\t    int k = 1;\n\t\t    while(s[i][k]!=max)k++;\n\t\t    calc(i, k, \"x\"); \n\t\t    did = true;\n\t\t}\n\t    for(int k=1; k<s[h].length; k++)\n\t\tif(s[0][k]==1){\n\t\t    int i = 1;\n\t\t    while(s[i][k]!=max)i++;\n\t\t    calc(i, k, \"y\"); \n\t\t    did = true;\n\t\t}\n\t    con = check();\n\t    if(!did) con = false;\n\t}\n\tArrays.sort(ans);\n\tif(s[0][0]==0)\n\t    for(int i=0; i<ans.length; i++)\n\t\tSystem.out.println(Answers.get(ans[i]));\n\telse\n\t    System.out.println(\"NO\");\n    }\n\n    void calc(int h, int w, String t){\n\tint a = 0;\n\tif(t.equals(\"y\")){\n\t    for(int i=1; i<s.length; i++){\n\t\tif(i==s.length-1) a += s[i][w];\n\t\telse if(i!=h) a -= s[i][w];\n\t    }\n\t}\n\telse {\n\t    for(int k=1; k<s[h].length; k++){\n\t\tif(k==s[h].length-1) a += s[h][k];\n\t\telse if(k!=w) a -= s[h][k];\n\t    }\n\t}\n\tans[next++] = (h-1)*s[h].length+w;\n\tAnswers.put((h-1)*s[h].length+w, a);\n\ts[h][w] = a;\n\ts[0][w]--; s[h][0]--; s[0][0]--;\n\t//System.out.println(\"*\"+h+\" \"+w+\" \"+t);\n    }\n\n    boolean check(){\n\tint count = 0;\n\tfor(int i=1; i<s.length; i++)\n\t    if(s[i][0]==1) count++;\n\tfor(int k=1; k<s[h].length; k++)\n\t    if(s[0][k]==1) count++;\n\treturn count>0 ? true : false;\n    }\n\n    void show(){\n\tfor(int i=0; i<s.length; i++){\n\t    for(int k=0; k<s[i].length; k++)\n\t\tSystem.out.print(s[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}\n\n\n\t\t\t    "
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n    public static void main(final String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        boolean b = true;\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        while (b) {\n            b = runOnce(reader);\n            if (b) {\n                System.out.println();\n            }\n        }\n\n        reader.close();\n    }\n\n    private boolean runOnce(final BufferedReader reader) throws IOException {\n        final String[] params = reader.readLine().split(\" \");\n        final int x = Integer.parseInt(params[0]);\n        if (x == 0) return false;\n        final int y = Integer.parseInt(params[1]);\n        final List<String> lines = new ArrayList<>();\n        for (int i = 0; i < x + 1; i++) {\n            lines.add(reader.readLine());\n        }\n        reader.readLine();\n\n        final List<Func> funcs = buildFunctions(lines);\n        final List<Variable> vars = findVariables(funcs);\n        boolean changed = true;\n        while (changed && vars.stream().anyMatch(variable -> !variable.defined)) {\n            changed = false;\n            final ArrayList<Func> tmp = new ArrayList<>(funcs);\n            for (final Func func : tmp) {\n                if (func.variables.stream().allMatch(variable -> variable.defined)) {\n                    funcs.remove(func);\n                    continue;\n                }\n                final List<Variable> collect = func.variables.stream()\n                        .filter(variable -> !variable.defined)\n                        .collect(Collectors.toList());\n                if (collect.size() == 1) {\n                    collect.forEach(variable -> {\n                        variable.value = func.result - func.variables.stream()\n                                .filter(variable1 -> variable1.defined)\n                                .map(variable1 -> variable1.value)\n                                .reduce(0, (i1, i2) -> i1 + i2);\n                        variable.defined = true;\n                    });\n                    changed = true;\n                }\n            }\n        }\n        if (!changed) {\n            System.out.println(\"NO\");\n            return true;\n        }\n        vars.forEach(variable -> System.out.println(String.valueOf(variable.value)));\n        return true;\n    }\n\n    private List<Variable> findVariables(final List<Func> funcs) {\n        final List<Variable> set = new ArrayList<>();\n        for (final Func func : funcs) {\n            for (final Variable variable : func.variables) {\n                if (!variable.defined && !set.contains(variable)) {\n                    set.add(variable);\n                }\n            }\n        }\n        return set;\n    }\n\n    private List<Func> buildFunctions(final List<String> lines) {\n        final List<Func> funcs = new ArrayList<>();\n\n        for (int i = 0; i < lines.size() - 1; i++) {\n            funcs.add(new Func.Builder().fromLine(lines.get(i)));\n        }\n\n        final int size = funcs.get(0).variables.size();\n        final int funcSize = funcs.size();\n\n        final String[] sums = lines.get(lines.size() - 1).split(\" \");\n\n        for (int i = 0; i < size; i++) {\n            final Func.Builder builder = new Func.Builder();\n            for (int j = 0; j < funcSize; j++) {\n                builder.add(funcs.get(j).variables.get(i));\n            }\n            funcs.add(builder.build(Integer.parseInt(sums[i])));\n        }\n        return funcs;\n    }\n\n}\n\nclass Variable {\n    Variable(final boolean defined, final int value) {\n        this.defined = defined;\n        this.value = value;\n    }\n\n    boolean defined;\n    int value;\n}\n\nclass Func {\n    final int result;\n    final List<Variable> variables;\n\n    Func(final List<Variable> variables, final int result) {\n        this.result = result;\n        this.variables = variables;\n    }\n\n    public static class Builder {\n        List<Variable> tmp = new ArrayList<>();\n\n        Func fromLine(final String line) {\n            final Builder builder = new Builder();\n            final List<String> split = new ArrayList<>(Arrays.asList(line.split(\" \")));\n            final int result = Integer.parseInt(split.remove(split.size() - 1));\n            for (final String s : split) {\n                if (s.equals(\"?\")) {\n                    builder.add(new Variable(false, 0));\n                } else {\n                    builder.add(new Variable(true, Integer.parseInt(s)));\n                }\n            }\n            return builder.build(result);\n        }\n\n        void add(final Variable v) {\n            tmp.add(v);\n        }\n\n        Func build(final int result) {\n            return new Func(tmp, result);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [][] data;\n\tboolean [][] check;\n\tArrayList<C> list;\n\tfinal int MAX = Integer.MAX_VALUE;\n\tint p,s;\n\n\tclass C implements Comparable<C>{\n\t\tint x,y,value;\n\n\t\tpublic C(int x, int y, int value) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(y < o.y)return -1;\n\t\t\tif(y > o.y)return 1;\n\t\t\tif(x < o.x)return -1;\n\t\t\tif(x > o.x)return 1;\n\t\t\treturn 0;\n\t\t}\n\t}//c end\n\n\tprivate void calc(int x, int y){\n\t\tboolean flg = false;\n\t\tint sum = 0;\n\t\tfor(int i=0; i < s; i++){\n\t\t\tif(i == x)\tcontinue;\n\t\t\tif(data[y][i] == MAX) break;\n\t\t\tsum += data[y][i];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[y][s] - sum;\n\t\t\t\tflg = true;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t\tif(flg) return;\n\t\tsum = 0;\n\t\tfor(int i=0; i < p; i++){\n\t\t\tif(i == y)\tcontinue;\n\t\t\tif(data[i][x] == MAX) break;\n\t\t\tsum += data[i][x];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[p][x] - sum;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tp = sc.nextInt();\n\t\t\tif(p == 0)\n\t\t\t\tbreak;\n\t\t\ts = sc.nextInt();\n\t\t\tdata = new int[p + 1][s + 1];\n\t\t\tcheck = new boolean[p + 1][s + 1];\n\t\t\tlist = new ArrayList<C>();\n\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\tString temp = sc.next();\n\t\t\t\t\tif(temp.equals(\"?\")){\n\t\t\t\t\t\tdata[i][j] = MAX;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcheck[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdata[i][j] = Integer.parseInt(temp);\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flg = false;\n\t\t\tint count2 = 0;\n\t\t\twhile(count2 < count){\n\t\t\t\tboolean flg2 = false;\n\t\t\t\tfor(int i = 0; i <p; i++){\n\t\t\t\t\tfor(int j = 0; j < s; j++){\n\t\t\t\t\t\tif(data[i][j] == MAX){\n\t\t\t\t\t\t\tcalc(j,i);\n\t\t\t\t\t\t\tif(data[i][j] != MAX){\n\t\t\t\t\t\t\t\tflg2 = true;\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg2){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif(! flg){\n\t\t\t\tfor(int i=0; i < p;i++){\n\t\t\t\t\tfor(int j=0; j < s; j++){\n\t\t\t\t\t\tif(check[i][j] == false){\n\t\t\t\t\t\t\tSystem.out.println(data[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\n//\t\t\tCollections.sort(list);\n//\n//\t\t\tif(count == list.size()){\n//\t\t\t\tfor(C now: list) System.out.println(now.value);\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tSystem.out.println(\"NO\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    public static void main(final String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        boolean b = true;\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        boolean first = true;\n        while (b) {\n            b = runOnce(reader, first);\n            first = false;\n        }\n\n        reader.close();\n    }\n\n    private boolean runOnce(final BufferedReader reader, final boolean first) throws IOException {\n        final String[] params = reader.readLine().split(\" \");\n        final int x = Integer.parseInt(params[0]);\n        if (x == 0) return false;\n        if(!first) System.out.println();\n        final List<String> lines = new ArrayList<>();\n        for (int i = 0; i < x + 1; i++) {\n            lines.add(reader.readLine());\n        }\n        reader.readLine();\n\n        final List<Func> funcs = buildFunctions(lines);\n        final List<Variable> vars = findVariables(funcs);\n        boolean changed = true;\n        while (changed && vars.stream().anyMatch(variable -> !variable.defined)) {\n            changed = false;\n            final ArrayList<Func> tmp = new ArrayList<>(funcs);\n            for (final Func func : tmp) {\n                if (func.variables.stream().allMatch(variable -> variable.defined)) {\n                    funcs.remove(func);\n                    continue;\n                }\n                final List<Variable> collect = func.variables.stream()\n                        .filter(variable -> !variable.defined)\n                        .collect(Collectors.toList());\n                if (collect.size() == 1) {\n                    collect.forEach(variable -> {\n                        variable.value = func.result - func.variables.stream()\n                                .filter(variable1 -> variable1.defined)\n                                .map(variable1 -> variable1.value)\n                                .reduce(0, (i1, i2) -> i1 + i2);\n                        variable.defined = true;\n                    });\n                    changed = true;\n                }\n            }\n        }\n        if (!changed) {\n            System.out.println(\"NO\");\n            return true;\n        }\n        vars.forEach(variable -> System.out.println(String.valueOf(variable.value)));\n        return true;\n    }\n\n    private List<Variable> findVariables(final List<Func> funcs) {\n        final List<Variable> set = new ArrayList<>();\n        for (final Func func : funcs) {\n            for (final Variable variable : func.variables) {\n                if (!variable.defined && !set.contains(variable)) {\n                    set.add(variable);\n                }\n            }\n        }\n        return set;\n    }\n\n    private List<Func> buildFunctions(final List<String> lines) {\n        final List<Func> funcs = new ArrayList<>();\n\n        for (int i = 0; i < lines.size() - 1; i++) {\n            funcs.add(new Func.Builder().fromLine(lines.get(i)));\n        }\n\n        final int size = funcs.get(0).variables.size();\n        final int funcSize = funcs.size();\n\n        final String[] sums = lines.get(lines.size() - 1).split(\" \");\n\n        for (int i = 0; i < size; i++) {\n            final Func.Builder builder = new Func.Builder();\n            for (int j = 0; j < funcSize; j++) {\n                builder.add(funcs.get(j).variables.get(i));\n            }\n            funcs.add(builder.build(Integer.parseInt(sums[i])));\n        }\n        return funcs;\n    }\n\n}\n\nclass Variable {\n    Variable(final boolean defined, final int value) {\n        this.defined = defined;\n        this.value = value;\n    }\n\n    boolean defined;\n    int value;\n}\n\nclass Func {\n    final int result;\n    final List<Variable> variables;\n\n    Func(final List<Variable> variables, final int result) {\n        this.result = result;\n        this.variables = variables;\n    }\n\n    public static class Builder {\n        List<Variable> tmp = new ArrayList<>();\n\n        Func fromLine(final String line) {\n            final Builder builder = new Builder();\n            final List<String> split = new ArrayList<>(Arrays.asList(line.split(\" \")));\n            final int result = Integer.parseInt(split.remove(split.size() - 1));\n            for (final String s : split) {\n                if (s.equals(\"?\")) {\n                    builder.add(new Variable(false, 0));\n                } else {\n                    builder.add(new Variable(true, Integer.parseInt(s)));\n                }\n            }\n            return builder.build(result);\n        }\n\n        void add(final Variable v) {\n            tmp.add(v);\n        }\n\n        Func build(final int result) {\n            return new Func(tmp, result);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int h, w;\n    int[][] s;\n    int[] ans;\n    int next;\n    HashMap<Integer, Integer>  Answers;\n    int max = Integer.MAX_VALUE;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    h = sc.nextInt();\n\t    if(h!=0){\n\t\tput();\n\t\t//show();\t\n\t\tsolve();\n\t\tSystem.out.println();\n\t    }\n\t}\n    }\n\n    void put(){\n\tw = sc.nextInt();\n\ts = new int[h+2][w+2];\n\tfor(int i=1; i<(h+2); i++){\n\t    for(int k=1; k<(w+2); k++){\n\t\tString t = sc.next();\n\t\tif(t.equals(\"?\")){\n\t\t    s[i][k] = max;\n\t\t    s[i][0]++; s[0][k]++;\n\t\t    s[0][0]++;\n\t\t}\n\t\telse s[i][k] = Integer.parseInt(t);\n\t    }\n\t    //System.out.println();\n\t}\n\tans = new int[s[0][0]];\n\tnext = 0;\n\tAnswers = new HashMap<Integer, Integer>();\n    }\n\n    void solve(){\n\tboolean con = true;\n\tboolean did = false;\n\n\tif(s[0][0]==h+w) con = false;\n\n\twhile(con && s[0][0]>0){\n\t    for(int i=1; i<s.length; i++)\n\t\tif(s[i][0]==1){\n\t\t    int k = 1;\n\t\t    while(s[i][k]!=max)k++;\n\t\t    calc(i, k, \"x\"); \n\t\t    did = true;\n\t\t}\n\t    for(int k=1; k<s[h].length; k++)\n\t\tif(s[0][k]==1){\n\t\t    int i = 1;\n\t\t    while(s[i][k]!=max)i++;\n\t\t    calc(i, k, \"y\"); \n\t\t    did = true;\n\t\t}\n\t    if(!did) con = false;\n\t}\n\tArrays.sort(ans);\n\tif(con)\n\t    for(int i=0; i<ans.length; i++)\n\t\tSystem.out.println(Answers.get(ans[i]));\n\telse\n\t    System.out.println(\"NO\");\n    }\n\n    void calc(int h, int w, String t){\n\tint a = 0;\n\tif(t.equals(\"y\")){\n\t    for(int i=1; i<s.length; i++){\n\t\tif(i==s.length-1) a += s[i][w];\n\t\telse if(i!=h) a -= s[i][w];\n\t    }\n\t}\n\telse {\n\t    for(int k=1; k<s[h].length; k++){\n\t\tif(k==s[h].length-1) a += s[h][k];\n\t\telse if(k!=w) a -= s[h][k];\n\t    }\n\t}\n\tans[next++] = (h-1)*s[h].length+w;\n\tAnswers.put((h-1)*s[h].length+w, a);\n\ts[h][w] = a;\n\ts[0][w]--; s[h][0]--; s[0][0]--;\n\t//System.out.println(\"*\"+h+\" \"+w+\" \"+t);\n    }\n\n    void show(){\n\tfor(int i=0; i<s.length; i++){\n\t    for(int k=0; k<s[i].length; k++)\n\t\tSystem.out.print(s[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}\n\n\n\t\t\t    "
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    public static void main(final String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        boolean b = true;\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        boolean first = true;\n        while (b) {\n            if (!first) System.out.println();\n            first = false;\n            b = runOnce(reader);\n        }\n\n        reader.close();\n    }\n\n    private boolean runOnce(final BufferedReader reader) throws IOException {\n        final String[] params = reader.readLine().split(\" \");\n        final int x = Integer.parseInt(params[0]);\n        if (x == 0) return false;\n        final int y = Integer.parseInt(params[1]);\n        final List<String> lines = new ArrayList<>();\n        for (int i = 0; i < x + 1; i++) {\n            lines.add(reader.readLine());\n        }\n        reader.readLine();\n\n        final List<Func> funcs = buildFunctions(lines);\n        final List<Variable> vars = findVariables(funcs);\n        boolean changed = true;\n        while (changed && vars.stream().anyMatch(variable -> !variable.defined)) {\n            changed = false;\n            final ArrayList<Func> tmp = new ArrayList<>(funcs);\n            for (final Func func : tmp) {\n                if (func.variables.stream().allMatch(variable -> variable.defined)) {\n                    funcs.remove(func);\n                    continue;\n                }\n                final List<Variable> collect = func.variables.stream()\n                        .filter(variable -> !variable.defined)\n                        .collect(Collectors.toList());\n                if (collect.size() == 1) {\n                    collect.forEach(variable -> {\n                        variable.value = func.result - func.variables.stream()\n                                .filter(variable1 -> variable1.defined)\n                                .map(variable1 -> variable1.value)\n                                .reduce(0, (i1, i2) -> i1 + i2);\n                        variable.defined = true;\n                    });\n                    changed = true;\n                }\n            }\n        }\n        if (!changed) {\n            System.out.println(\"NO\");\n            return true;\n        }\n        vars.forEach(variable -> System.out.println(String.valueOf(variable.value)));\n        return true;\n    }\n\n    private List<Variable> findVariables(final List<Func> funcs) {\n        final List<Variable> set = new ArrayList<>();\n        for (final Func func : funcs) {\n            for (final Variable variable : func.variables) {\n                if (!variable.defined && !set.contains(variable)) {\n                    set.add(variable);\n                }\n            }\n        }\n        return set;\n    }\n\n    private List<Func> buildFunctions(final List<String> lines) {\n        final List<Func> funcs = new ArrayList<>();\n\n        for (int i = 0; i < lines.size() - 1; i++) {\n            funcs.add(new Func.Builder().fromLine(lines.get(i)));\n        }\n\n        final int size = funcs.get(0).variables.size();\n        final int funcSize = funcs.size();\n\n        final String[] sums = lines.get(lines.size() - 1).split(\" \");\n\n        for (int i = 0; i < size; i++) {\n            final Func.Builder builder = new Func.Builder();\n            for (int j = 0; j < funcSize; j++) {\n                builder.add(funcs.get(j).variables.get(i));\n            }\n            funcs.add(builder.build(Integer.parseInt(sums[i])));\n        }\n        return funcs;\n    }\n\n}\n\nclass Variable {\n    Variable(final boolean defined, final int value) {\n        this.defined = defined;\n        this.value = value;\n    }\n\n    boolean defined;\n    int value;\n}\n\nclass Func {\n    final int result;\n    final List<Variable> variables;\n\n    Func(final List<Variable> variables, final int result) {\n        this.result = result;\n        this.variables = variables;\n    }\n\n    public static class Builder {\n        List<Variable> tmp = new ArrayList<>();\n\n        Func fromLine(final String line) {\n            final Builder builder = new Builder();\n            final List<String> split = new ArrayList<>(Arrays.asList(line.split(\" \")));\n            final int result = Integer.parseInt(split.remove(split.size() - 1));\n            for (final String s : split) {\n                if (s.equals(\"?\")) {\n                    builder.add(new Variable(false, 0));\n                } else {\n                    builder.add(new Variable(true, Integer.parseInt(s)));\n                }\n            }\n            return builder.build(result);\n        }\n\n        void add(final Variable v) {\n            tmp.add(v);\n        }\n\n        Func build(final int result) {\n            return new Func(tmp, result);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [][] data;\n\tboolean [][] check;\n\tfinal int MAX = Integer.MAX_VALUE;\n\tint p,s;\n\n\tprivate void calc(int x, int y){\n\t\tboolean flg = false;\n\t\tint sum = 0;\n\t\tfor(int i=0; i < s; i++){\n\t\t\tif(i != x){\n\t\t\t\tif(data[y][i] == MAX){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += data[y][i];\n\t\t\t}\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[y][s] - sum;\n\t\t\t\tflg = true;\n\t\t\t}\n\t\t}\n\t\tif(flg) return;\n\t\tsum = 0;\n\t\tfor(int i=0; i < p; i++){\n\t\t\tif(i != y){\n\t\t\t\tif(data[i][x] == MAX) break;\n\t\t\t\tsum += data[i][x];\n\t\t\t}\n\t\t\tif(i == (p - 1)){\n\t\t\t\tdata[y][x] = data[p][x] - sum;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tp = sc.nextInt();\n\t\t\tif(p == 0)\n\t\t\t\tbreak;\n\t\t\ts = sc.nextInt();\n\t\t\tdata = new int[p + 1][s + 1];\n\t\t\tcheck = new boolean[p + 1][s + 1];\n\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\tString temp = sc.next();\n\t\t\t\t\tif(temp.equals(\"?\")){\n\t\t\t\t\t\tdata[i][j] = MAX;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcheck[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdata[i][j] = Integer.parseInt(temp);\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flg = false;\n\t\t\tint count2 = 0;\n\t\t\twhile(count2 < count){\n\t\t\t\tboolean flg2 = false;\n\t\t\t\tfor(int i = 0; i <p; i++){\n\t\t\t\t\tfor(int j = 0; j < s; j++){\n\t\t\t\t\t\tif(data[i][j] == MAX){\n\t\t\t\t\t\t\tcalc(j,i);\n\t\t\t\t\t\t\tif(data[i][j] != MAX){\n\t\t\t\t\t\t\t\tflg2 = true;\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg2){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(! flg){\n\t\t\t\tfor(int i=0; i < p;i++){\n\t\t\t\t\tfor(int j=0; j < s; j++){\n\t\t\t\t\t\tif(check[i][j] == false){\n\t\t\t\t\t\t\tSystem.out.println(data[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main {\n     \n\tpublic static final int P_MAX = 100;\n\tpublic static final int S_MAX = 10;\n\t\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] unknown_product = new int[P_MAX];\n        int[] unknown_store   = new int[S_MAX];\n        \n        int[] known_product_sum = new int[P_MAX];\n        int[] known_store_sum   = new int[S_MAX];\n        \n        int[] all_product_sum = new int[P_MAX];\n        int[] all_store_sum   = new int[S_MAX];\n        \n        int[][] table = new int[P_MAX][S_MAX];\n        boolean[][] unknown = new boolean[P_MAX][S_MAX];\n        \n        while(true){\n        \tfinal int p = sc.nextInt();\n        \t\n        \tif(p == 0){\n        \t\tbreak;\n        \t}\n        \t\n        \tSystem.out.println();\n        \t\n        \tfinal int s = sc.nextInt();\n        \t\n        \tArrays.fill(unknown_product, 0);\n        \tArrays.fill(unknown_store  , 0);\n        \tArrays.fill(known_product_sum, 0);\n        \tArrays.fill(known_store_sum  , 0);\n        \tArrays.fill(all_product_sum, 0);\n        \tArrays.fill(all_store_sum  , 0);\n        \t\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tString input = sc.next();\n        \t\t\t\n        \t\t\tif(\"?\".equals(input)){\n        \t\t\t\tunknown_product[i]++;\n        \t\t\t\tunknown_store[j]++;\n        \t\t\t\t\n        \t\t\t\ttable[i][j] = Integer.MIN_VALUE;\n        \t\t\t\tunknown[i][j] = true;\n        \t\t\t}else{\n        \t\t\t\tfinal int number = Integer.parseInt(input);\n        \t\t\t\t\n        \t\t\t\tknown_product_sum[i] += number;\n        \t\t\t\tknown_store_sum[j]   += number;\n        \t\t\t\ttable[i][j] = number;\n        \t\t\t\tunknown[i][j] = false;\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tall_product_sum[i] = sc.nextInt();\n        \t}\n        \t\n        \tfor(int i = 0; i <= s; i++){\n        \t\tfinal int sum = sc.nextInt();\n        \t\t\n        \t\tif(i == s){\n        \t\t\tcontinue;\n        \t\t}\n        \t\t\n        \t\tall_store_sum[i] = sum;\n        \t}\n        \t\n        \twhile(true){\n        \t\tboolean updated = false;\n        \t\t\n        \t\t//System.out.println(Arrays.toString(unknown_product));\n        \t\t//System.out.println(Arrays.toString(unknown_store));\n        \t\t\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tif(unknown_product[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\t\tif(table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[i][j] = all_product_sum[i] - known_product_sum[i];\n        \t\t\t\t\t\tunknown_product[i]--;\n        \t\t\t\t\t\tunknown_store[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_product_sum[i] += table[i][j];\n        \t\t\t\t\t\tknown_store_sum[j] += table[i][j];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tfor(int i = 0; i < s; i++){\n        \t\t\tif(unknown_store[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < p; j++){\n        \t\t\t\t\tif(table[j][i] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[j][i] = all_store_sum[i] - known_store_sum[i];\n        \t\t\t\t\t\tunknown_store[i]--;\n        \t\t\t\t\t\tunknown_product[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_store_sum[i] += table[j][i];\n        \t\t\t\t\t\tknown_product_sum[j] += table[j][i];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tif(!updated){\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \t\n        \tboolean flag = true;\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tif(unknown[i][j] && table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\tflag = false;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tif(!flag){\n        \t\tSystem.out.println(\"NO\");\n        \t}else{\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\tif(unknown[i][j]){\n        \t\t\t\t\tSystem.out.println(table[i][j]);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tint [][] data;\n\tArrayList<C> list;\n\tfinal int MAX = Integer.MAX_VALUE;\n\tint p,s;\n\n\tclass C implements Comparable<C>{\n\t\tint x,y,value;\n\n\t\tpublic C(int x, int y, int value) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(y < o.y)return -1;\n\t\t\tif(y > o.y)return 1;\n\t\t\tif(x < o.x)return -1;\n\t\t\tif(x > o.x)return 1;\n\t\t\treturn 0;\n\t\t}\n\t}//c end\n\n\tprivate void calc(int x, int y){\n\t\tboolean flg = false;\n\t\tint sum = 0;\n\t\tfor(int i=0; i < s; i++){\n\t\t\tif(i == x)\tcontinue;\n\t\t\tif(data[y][i] == MAX) break;\n\t\t\tsum += data[y][i];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[y][s] - sum;\n\t\t\t\tflg = true;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t\tif(flg) return;\n\t\tsum = 0;\n\t\tfor(int i=0; i < p; i++){\n\t\t\tif(i == y)\tcontinue;\n\t\t\tif(data[i][x] == MAX) break;\n\t\t\tsum += data[i][x];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[p][x] - sum;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tp = sc.nextInt();\n\t\t\tif(p == 0)\n\t\t\t\tbreak;\n\t\t\ts = sc.nextInt();\n\t\t\tdata = new int[p + 1][s + 1];\n\t\t\tlist = new ArrayList<C>();\n\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\tString temp = sc.next();\n\t\t\t\t\tif(temp.equals(\"?\")){\n\t\t\t\t\t\tdata[i][j] = MAX;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdata[i][j] = Integer.parseInt(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = p * s;\n\t\t\twhile(len-- > 0){\n\t\t\t\tfor(int i = 0; i <p; i++){\n\t\t\t\t\tfor(int j = 0; j < s; j++){\n\t\t\t\t\t\tif(data[i][j] == MAX) calc(j,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(list);\n\n\t\t\tif(count == list.size()){\n\t\t\t\tfor(C now: list) System.out.println(now.value);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic boolean[][] unk;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tboolean first=true;\n\t\twhile(true){\n\n\n\t\t\tint h=cin.nextInt();\n\t\t\tif(h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(first)\n\t\t\t\tfirst=false;\n\t\t\telse{\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tint w=cin.nextInt();\n\t\t\tfield=new int[h+1][w+1];\n\t\t\tunk=new boolean[h][w];\n\t\t\tboolean[][] unk2=new boolean[h][w];\n\t\t\tint cnt=0;\n\t\t\tint cnt2=0;\n\t\t\tfor(int i = 0;i<h+1;i++){\n\t\t\t\tfor(int j = 0;j<w+1;j++){\n\t\t\t\t\tString s =cin.next();\n\t\t\t\t\tif(s.equals(\"?\")){\n\t\t\t\t\t\tunk[i][j]=true;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tunk2[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h+1;i++){\n\t\t\t\tfor(int j = 0;j<w+1;j++){\n\t\t\t\t\t//System.out.print(field[i][j]+\" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tcnt2=cnt;\n\t\t\tlabel:for(int aaa=0;aaa<cnt;aaa++){\n\t\t\t\tfor(int i  =0;i<h;i++){\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tint unkCnt=0;\n\t\t\t\t\tint xx=0;\n\t\t\t\t\tint yy=0;\n\t\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t\tsum+=field[i][j];\n\t\t\t\t\t\tif(unk[i][j]){\n\t\t\t\t\t\t\tunkCnt++;\n\t\t\t\t\t\t\txx=i;\n\t\t\t\t\t\t\tyy=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(unkCnt==1){\n\t\t\t\t\t\tunk[xx][yy]=false;\n\t\t\t\t\t\tfield[xx][yy]=field[i][w]-sum;\n\t\t\t\t\t\t//System.out.println(field[xx][yy]);\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j  =0;j<w;j++){\n\t\t\t\t\tint sum=0;\n\t\t\t\t\tint unkCnt=0;\n\t\t\t\t\tint xx=0;\n\t\t\t\t\tint yy=0;\n\t\t\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\t\t\tsum+=field[i][j];\n\t\t\t\t\t\tif(unk[i][j]){\n\t\t\t\t\t\t\tunkCnt++;\n\t\t\t\t\t\t\txx=i;\n\t\t\t\t\t\t\tyy=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(unkCnt==1){\n\t\t\t\t\t\tunk[xx][yy]=false;\n\t\t\t\t\t\tfield[xx][yy]=field[h][j]-sum;\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t\t//System.out.println(field[xx][yy]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cnt2==0){\n\t\t\t\tfor(int i =0;i<h;i++){\n\t\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\t\tif(unk2[i][j]){\n\t\t\t\t\t\t\tSystem.out.println(field[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\n\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint n, m;\n\tint[][] a;\n\tboolean[][] q;\n\tArrayList<P> list;\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=sc.nextInt();\n\t\t\ta=new int[n+1][m+1];\n\t\t\tq=new boolean[n+1][m+1];\n\t\t\tlist=new ArrayList<P>();\n\t\t\tfor(int j=0; j<=n; j++){\n\t\t\t\tfor(int i=0; i<=m; i++){\n\t\t\t\t\tString s=sc.next();\n\t\t\t\t\tif(s.equals(\"?\")){\n\t\t\t\t\t\tq[j][i]=true;\n\t\t\t\t\t\tlist.add(new P(i, j));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[j][i]=Integer.parseInt(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tfor(;;){\n\t\t\tint[] sumM=new int[m];\n\t\t\tint[] sumN=new int[n];\n\t\t\tint[] qM=new int[m];\n\t\t\tint[] qN=new int[n];\n\t\t\tboolean[] oneM=new boolean[m];\n\t\t\tboolean[] oneN=new boolean[n];\n\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint count=0;\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(q[j][i]){\n\t\t\t\t\t\tqM[i]=j;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsumM[i]+=a[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toneM[i]=count==1;\n\t\t\t}\n\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tint count=0;\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tif(q[j][i]){\n\t\t\t\t\t\tqN[j]=i;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsumN[j]+=a[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toneN[j]=count==1;\n\t\t\t}\n\n\t\t\tboolean update=false;\n\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(oneM[i]){\n\t\t\t\t\toneN[qM[i]]=false;// ツつ「ツづァツづア\n\t\t\t\t\tq[qM[i]][i]=false;\n\t\t\t\t\ta[qM[i]][i]=a[n][i]-sumM[i];\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(oneN[j]){\n\t\t\t\t\tq[j][qN[j]]=false;\n\t\t\t\t\ta[j][qN[j]]=a[j][m]-sumN[j];\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!update){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tboolean all=true;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tall&=!q[j][i];\n\t\t\t}\n\t\t}\n\t\tif(all){\n\t\t\tfor(P p : list){\n\t\t\t\tprintln(\"\"+a[p.y][p.x]);\n\t\t\t}\n\t\t}else{\n\t\t\tprintln(\"NO\");\n\t\t}\n\t\tprintln(\"\");\n\t}\n\n\tvoid dfs(){\n\t\tboolean[] oneM=new boolean[m];\n\t\tboolean[] oneN=new boolean[n];\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint count=0;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(q[j][i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toneM[i]=count==1;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint count=0;\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(q[j][i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toneN[j]=count==1;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\t// 1ツづ按づ個つェツつ?づェツづ篠個按津ィ\n\t\t\tif(oneN[j]){\n\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main {\n     \n\tpublic static final int P_MAX = 100;\n\tpublic static final int S_MAX = 10;\n\t\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int[] unknown_product = new int[P_MAX];\n        int[] unknown_store   = new int[S_MAX];\n        \n        int[] known_product_sum = new int[P_MAX];\n        int[] known_store_sum   = new int[S_MAX];\n        \n        int[] all_product_sum = new int[P_MAX];\n        int[] all_store_sum   = new int[S_MAX];\n        \n        int[][] table = new int[P_MAX][S_MAX];\n        boolean[][] unknown = new boolean[P_MAX][S_MAX];\n        \n        while(true){\n        \tfinal int p = sc.nextInt();\n        \t\n        \tif(p == 0){\n        \t\tbreak;\n        \t}\n        \t\n        \tfinal int s = sc.nextInt();\n        \t\n        \tArrays.fill(unknown_product, 0);\n        \tArrays.fill(unknown_store  , 0);\n        \tArrays.fill(known_product_sum, 0);\n        \tArrays.fill(known_store_sum  , 0);\n        \tArrays.fill(all_product_sum, 0);\n        \tArrays.fill(all_store_sum  , 0);\n        \t\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tString input = sc.next();\n        \t\t\t\n        \t\t\tif(\"?\".equals(input)){\n        \t\t\t\tunknown_product[i]++;\n        \t\t\t\tunknown_store[j]++;\n        \t\t\t\t\n        \t\t\t\ttable[i][j] = Integer.MIN_VALUE;\n        \t\t\t\tunknown[i][j] = true;\n        \t\t\t}else{\n        \t\t\t\tfinal int number = Integer.parseInt(input);\n        \t\t\t\t\n        \t\t\t\tknown_product_sum[i] += number;\n        \t\t\t\tknown_store_sum[j]   += number;\n        \t\t\t\ttable[i][j] = number;\n        \t\t\t\tunknown[i][j] = false;\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tall_product_sum[i] = sc.nextInt();\n        \t}\n        \t\n        \tfor(int i = 0; i <= s; i++){\n        \t\tfinal int sum = sc.nextInt();\n        \t\t\n        \t\tif(i == s){\n        \t\t\tcontinue;\n        \t\t}\n        \t\t\n        \t\tall_store_sum[i] = sum;\n        \t}\n        \t\n        \twhile(true){\n        \t\tboolean updated = false;\n        \t\t\n        \t\t//System.out.println(Arrays.toString(unknown_product));\n        \t\t//System.out.println(Arrays.toString(unknown_store));\n        \t\t\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tif(unknown_product[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\t\tif(table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[i][j] = all_product_sum[i] - known_product_sum[i];\n        \t\t\t\t\t\tunknown_product[i]--;\n        \t\t\t\t\t\tunknown_store[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_product_sum[i] += table[i][j];\n        \t\t\t\t\t\tknown_store_sum[j] += table[i][j];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tfor(int i = 0; i < s; i++){\n        \t\t\tif(unknown_store[i] == 1){\n        \t\t\t\t\n        \t\t\t\tfor(int j = 0; j < p; j++){\n        \t\t\t\t\tif(table[j][i] == Integer.MIN_VALUE){\n        \t\t\t\t\t\ttable[j][i] = all_store_sum[i] - known_store_sum[i];\n        \t\t\t\t\t\tunknown_store[i]--;\n        \t\t\t\t\t\tunknown_product[j]--;\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tknown_store_sum[i] += table[j][i];\n        \t\t\t\t\t\tknown_product_sum[j] += table[j][i];\n        \t\t\t\t\t\t\n        \t\t\t\t\t\tupdated = true;\n        \t\t\t\t\t\tbreak;\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tif(!updated){\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        \t\n        \tboolean flag = true;\n        \tfor(int i = 0; i < p; i++){\n        \t\tfor(int j = 0; j < s; j++){\n        \t\t\tif(unknown[i][j] && table[i][j] == Integer.MIN_VALUE){\n        \t\t\t\tflag = false;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tif(!flag){\n        \t\tSystem.out.println(\"NO\");\n        \t}else{\n        \t\tfor(int i = 0; i < p; i++){\n        \t\t\tfor(int j = 0; j < s; j++){\n        \t\t\t\tif(unknown[i][j]){\n        \t\t\t\t\tSystem.out.println(table[i][j]);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println();\n        }\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tint [][] data;\n\tArrayList<C> list;\n\tfinal int MAX = 10000;\n\tint p,s;\n\n\tclass C implements Comparable<C>{\n\t\tint x,y,value;\n\n\n\t\tpublic C(int x, int y, int value) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic int compareTo(C o) {\n\t\t\tif(y < o.y)return -1;\n\t\t\tif(y > o.y)return 1;\n\t\t\tif(x < o.x)return -1;\n\t\t\tif(x > o.x)return 1;\n\t\t\treturn 0;\n\t\t}\n\t}//c end\n\n\tprivate void calc(int x, int y){\n\t\tboolean flg = false;\n\t\tint sum = 0;\n\t\tfor(int i=0; i < s; i++){\n\t\t\tif(i == x){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(data[y][i] == MAX){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum += data[y][i];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[y][s] - sum;\n\t\t\t\tflg = true;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t\tif(flg) return;\n\t\tsum = 0;\n\t\tfor(int i=0; i < p; i++){\n\t\t\tif(i == y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(data[i][x] == MAX){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum += data[i][x];\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[p][x] - sum;\n\t\t\t\tlist.add(new C(x, y, data[y][x]));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tp = sc.nextInt();\n\t\t\tif(p == 0)\n\t\t\t\tbreak;\n\t\t\ts = sc.nextInt();\n\t\t\tdata = new int[p + 1][s + 1];\n\t\t\tlist = new ArrayList<C>();\n\n\n\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\tString temp = sc.next();\n\t\t\t\t\tif(temp.equals(\"?\")){\n\t\t\t\t\t\tdata[i][j] = MAX;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdata[i][j] = Integer.parseInt(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint count = 0;\n\t\t\tint len = p * s;\n\t\t\twhile(len-- > 0){\n\t\t\t\tint nowcount = 0;\n\t\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\t\tif(data[i][j] == MAX){\n\t\t\t\t\t\t\tcalc(j,i);\n\t\t\t\t\t\t\tnowcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = Math.max(nowcount, count);\n\t\t\t}\n\n\t\t\tCollections.sort(list);\n\n\t\t\tif(count == list.size()){\n\t\t\t\tfor(C now: list){\n\t\t\t\t\tSystem.out.println(now.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Missing Numbers\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tboolean row;\n\t\tint p, c;\n\t\tpublic R(boolean row, int p, int c) {\n\t\t\tthis.row = row;\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn c-o.c;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint NOT = 1<<29;\n\t\tfor(boolean head=true;;head=false){\n\t\t\tint h = sc.nextInt();\n\t\t\tif(h==0)break;\n\t\t\tint w = sc.nextInt();\n\t\t\tif(!head)System.out.println();\n\t\t\tint[][] a = new int[h+1][w+1];\n\t\t\tboolean[][] m = new boolean[h+1][w+1];\n\t\t\tfor(int i=0;i<=h;i++)for(int j=0;j<=w;j++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tm[i][j] = \"?\".equals(s);\n\t\t\t\tif(m[i][j])a[i][j]=NOT;\n\t\t\t\telse a[i][j]=Integer.parseInt(s);\n\t\t\t}\n\t\t\tboolean ok = false;\n\t\t\tfor(;;){\n\t\t\t\tPriorityQueue<R> q = new PriorityQueue<R>();\n\t\t\t\tint[] rc = new int[h], cc = new int[w];\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\t\tif(a[i][j]==NOT){\n\t\t\t\t\t\trc[i]++; cc[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<h;i++)if(0<rc[i])q.add(new R(true, i, rc[i]));\n\t\t\t\tfor(int j=0;j<w;j++)if(0<cc[j])q.add(new R(false, j, cc[j]));\n\t\t\t\tif(q.isEmpty()){\n\t\t\t\t\tok = true; break;\n\t\t\t\t}\n\t\t\t\tR r = q.poll();\n\t\t\t\tif(2<=r.c)break;\n\t\t\t\tif(r.row){\n\t\t\t\t\tint pj = -1, v = a[r.p][w];\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(a[r.p][j]==NOT)pj = j;\n\t\t\t\t\t\telse v-=a[r.p][j];\n\t\t\t\t\t}\n\t\t\t\t\ta[r.p][pj] = v;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint pi = -1, v = a[h][r.p];\n\t\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\t\tif(a[i][r.p]==NOT)pi = i;\n\t\t\t\t\t\telse v-=a[i][r.p];\n\t\t\t\t\t}\n\t\t\t\t\ta[pi][r.p] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(m[i][j])System.out.println(a[i][j]);\n\t\t\t}\n\t\t\telse System.out.println(\"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint [][] data;\n\tboolean [][] check;\n\tfinal int MAX = Integer.MAX_VALUE;\n\tint p,s;\n\n\tprivate void calc(int x, int y){\n\t\tboolean flg = false;\n\t\tint sum = 0;\n\t\tfor(int i=0; i < s; i++){\n\t\t\tif(i != x){\n\t\t\t\tif(data[y][i] == MAX){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsum += data[y][i];\n\t\t\t}\n\t\t\tif(i == (s - 1)){\n\t\t\t\tdata[y][x] = data[y][s] - sum;\n\t\t\t\tflg = true;\n\t\t\t}\n\t\t}\n\t\tif(flg) return;\n\t\tsum = 0;\n\t\tfor(int i=0; i < p; i++){\n\t\t\tif(i != y){\n\t\t\t\tif(data[i][x] == MAX) break;\n\t\t\t\tsum += data[i][x];\n\t\t\t}\n\t\t\tif(i == (p - 1)){\n\t\t\t\tdata[y][x] = data[p][x] - sum;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tp = sc.nextInt();\n\t\twhile(p != 0){\n\t\t\ts = sc.nextInt();\n\t\t\tdata = new int[p + 1][s + 1];\n\t\t\tcheck = new boolean[p + 1][s + 1];\n\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i <p + 1; i++){\n\t\t\t\tfor(int j = 0; j < s + 1; j++){\n\t\t\t\t\tString temp = sc.next();\n\t\t\t\t\tif(temp.equals(\"?\")){\n\t\t\t\t\t\tdata[i][j] = MAX;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tcheck[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdata[i][j] = Integer.parseInt(temp);\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean flg = false;\n\t\t\tint count2 = 0;\n\t\t\twhile(count2 < count){\n\t\t\t\tboolean flg2 = false;\n\t\t\t\tfor(int i = 0; i <p; i++){\n\t\t\t\t\tfor(int j = 0; j < s; j++){\n\t\t\t\t\t\tif(data[i][j] == MAX){\n\t\t\t\t\t\t\tcalc(j,i);\n\t\t\t\t\t\t\tif(data[i][j] != MAX){\n\t\t\t\t\t\t\t\tflg2 = true;\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! flg2){\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(! flg){\n\t\t\t\tfor(int i=0; i < p;i++){\n\t\t\t\t\tfor(int j=0; j < s; j++){\n\t\t\t\t\t\tif(check[i][j] == false){\n\t\t\t\t\t\t\tSystem.out.println(data[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tp = sc.nextInt();\n\t\t\tif(p != 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\tboolean b = false;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tif(!b){b=true;}else{System.out.println(\"\");}\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    public static void main(final String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        boolean b = true;\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        boolean first = true;\n        while (b) {\n            if (!first) System.out.println();\n            first = false;\n            b = runOnce(reader);\n        }\n\n        reader.close();\n    }\n\n    private boolean runOnce(final BufferedReader reader) throws IOException {\n        final String[] params = reader.readLine().split(\" \");\n        final int x = Integer.parseInt(params[0]);\n        if (x == 0) return false;\n        final int y = Integer.parseInt(params[1]);\n        final List<String> lines = new ArrayList<>();\n        for (int i = 0; i < x + 1; i++) {\n            lines.add(reader.readLine());\n        }\n        reader.readLine();\n\n        final List<Func> funcs = buildFunctions(lines);\n        final List<Variable> vars = findVariables(funcs);\n        boolean changed = true;\n        while (changed && vars.stream().anyMatch(variable -> !variable.defined)) {\n            changed = false;\n            final ArrayList<Func> tmp = new ArrayList<>(funcs);\n            for (final Func func : tmp) {\n                if (func.variables.stream().allMatch(variable -> variable.defined)) {\n                    funcs.remove(func);\n                    continue;\n                }\n                final List<Variable> collect = func.variables.stream()\n                        .filter(variable -> !variable.defined)\n                        .collect(Collectors.toList());\n                if (collect.size() == 1) {\n                    collect.forEach(variable -> {\n                        variable.value = func.result - func.variables.stream()\n                                .filter(variable1 -> variable1.defined)\n                                .map(variable1 -> variable1.value)\n                                .reduce(0, (i1, i2) -> i1 + i2);\n                        variable.defined = true;\n                    });\n                    changed = true;\n                }\n            }\n        }\n        if (!changed) {\n            System.out.println(\"NO\");\n            return true;\n        }\n        vars.forEach(variable -> System.out.println(String.valueOf(variable.value)));\n        return true;\n    }\n\n    private List<Variable> findVariables(final List<Func> funcs) {\n        final List<Variable> set = new ArrayList<>();\n        for (final Func func : funcs) {\n            for (final Variable variable : func.variables) {\n                if (!variable.defined && !set.contains(variable)) {\n                    set.add(variable);\n                }\n            }\n        }\n        return set;\n    }\n\n    private List<Func> buildFunctions(final List<String> lines) {\n        final List<Func> funcs = new ArrayList<>();\n\n        for (int i = 0; i < lines.size() - 1; i++) {\n            funcs.add(new Func.Builder().fromLine(lines.get(i)));\n        }\n\n        final int size = funcs.get(0).variables.size();\n        final int funcSize = funcs.size();\n\n        final String[] sums = lines.get(lines.size() - 1).split(\" \");\n\n        for (int i = 0; i < size; i++) {\n            final Func.Builder builder = new Func.Builder();\n            for (int j = 0; j < funcSize; j++) {\n                builder.add(funcs.get(j).variables.get(i));\n            }\n            funcs.add(builder.build(Integer.parseInt(sums[i])));\n        }\n        return funcs;\n    }\n\n}\n\nclass Variable {\n    Variable(final boolean defined, final int value) {\n        this.defined = defined;\n        this.value = value;\n    }\n\n    boolean defined;\n    int value;\n}\n\nclass Func {\n    final int result;\n    final List<Variable> variables;\n\n    Func(final List<Variable> variables, final int result) {\n        this.result = result;\n        this.variables = variables;\n    }\n\n    public static class Builder {\n        List<Variable> tmp = new ArrayList<>();\n\n        Func fromLine(final String line) {\n            final Builder builder = new Builder();\n            final List<String> split = new ArrayList<>(Arrays.asList(line.split(\" \")));\n            final int result = Integer.parseInt(split.remove(split.size() - 1));\n            for (final String s : split) {\n                if (s.equals(\"?\")) {\n                    builder.add(new Variable(false, 0));\n                } else {\n                    builder.add(new Variable(true, Integer.parseInt(s)));\n                }\n            }\n            return builder.build(result);\n        }\n\n        void add(final Variable v) {\n            tmp.add(v);\n        }\n\n        Func build(final int result) {\n            return new Func(tmp, result);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.out.println(\" \");\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\t\n\t\tboolean b = false;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\theight = scan.nextInt();\n\t\t\t\n\t\t\tif(height == 0) {break;}\n\t\t\twidth = scan.nextInt();\n\t\t\t\n\t\t\tif(!b) {System.out.println(\"\");}else { b = true;}\n\t\t\tnew DataSet(height+1, width+1);\n\t\t}\n\t}\n\n\tstatic class DataSet\n\t{\n\t\tint height; //products\n\t\tint width; //stores\n\t\tString[][] value;\n\t\tList<Integer> qmEntriesX = new ArrayList<Integer>();\n\t\tList<Integer> qmEntriesY = new ArrayList<Integer>();\n\t\tint solved = 0;\n\t\t\n\t\tpublic DataSet(int h, int w)\n\t\t{\n//\t\t\tSystem.out.println(\"New DataSet\");\n\t\t\theight = h;\n\t\t\twidth = w;\n\t\t\t\n\t\t\tvalue = new String[w][h];\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tvalue[x][y] = scan.next();\n\t\t\t\t\t\n\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tqmEntriesX.add(x);\n\t\t\t\t\t\tqmEntriesY.add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"anything\");\n//\t\t\tscan.next();\n\t\t\t\n\t\t\tboolean stillWorking = true;\n\t\t\t\n\t\t\twhile(stillWorking == true)\n\t\t\t{\n\t\t\t\tstillWorking = false;\n\t\t\t\t\n\t\t\t\t//go for rows first\n\t\t\t\t\n\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkX = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n\t\t\t\t\t\t\tunkX = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[w-1][y].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[w-1][y] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[w-1][y]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[unkX][y] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p1]\" + unkX + \" \" + y + \" SET TO \" + value[unkX][y]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//go for the columns\n\t\t\t\t//COPY PASTE\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tint unknowns = 0; //number of ?s for thisrow\n\t\t\t\t\tint unkY = 0;\n\t\t\t\t\tint restSum = 0;\n\t\t\t\t\tint actualSum = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Checking \" + x + \" \" + y);\n\t\t\t\t\t\tif(value[x][y].equals(\"?\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunknowns += 1;\n//\t\t\t\t\t\t\tSystem.out.println(\"? found at \" + x + \" \" + y + \", now \" + unknowns);\n\t\t\t\t\t\t\tunkY = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trestSum += Integer.parseInt(value[x][y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(unknowns == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsolved += 1;\n\t\t\t\t\t\tstillWorking = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//actualSum\n\t\t\t\t\t\tif(value[x][h-1].equals(\"?\"))\n\t\t\t\t\t\t{ //only unknown one is sum\n\t\t\t\t\t\t\tvalue[x][h-1] = Integer.toString(restSum);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //only unknown one is some not-sum entry\n\t\t\t\t\t\t\tactualSum = Integer.parseInt(value[x][h-1]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvalue[x][unkY] = Integer.toString(actualSum - restSum);\n//\t\t\t\t\t\t\tSystem.out.println(\"[p2]\" + x + \" \" + unkY + \" SET TO \" + value[x][unkY]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//COPY PASTE\n\t\t\t}\n\t\t\t\n\t\t\tif(solved == qmEntriesX.size())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < qmEntriesX.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(value[qmEntriesX.get(i)][qmEntriesY.get(i)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w;\n    public static int[,] map, map2;\n    public static bool[,] nodata;\n    public static int[] rsum, csum;\n    public static List<int>[] rnd, cnd;\n    public static void Main()\n    {\n        var first = true;\n        while (true)\n        {\n            var ps = new List<P>();\n            var s = Console.ReadLine().Trim();\n            if (s == \"\") continue;\n            else if (s == \"0\") break;\n            string[] line = s.Split(' ');\n            h = int.Parse(line[0]);\n            w = int.Parse(line[1]);\n            map = new int[h, w];\n            map2 = new int[h, w];\n            var p = 0;\n            rnd = new List<int>[h];\n            cnd = new List<int>[w];\n            for (int i = 0; i < h; i++)\n            {\n                rnd[i] = new List<int>();\n                for (int j = 0; j < w; j++) map2[i, j] = p++;\n            }\n            for (int i = 0; i < w; i++) cnd[i] = new List<int>();\n            nodata = new bool[h, w];\n            rsum = new int[h];\n            csum = new int[w];\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++)\n                {\n                    if (line[j] == \"?\")\n                    {\n                        nodata[i, j] = true;\n                        rnd[i].Add(map2[i, j]);\n                        cnd[j].Add(map2[i, j]);\n                        ps.Add(new P { x = i, y = j });\n                    }\n                    else map[i, j] = int.Parse(line[j]);\n                }\n                rsum[i] = int.Parse(line[w]);\n            }\n            line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < w; i++) csum[i] = int.Parse(line[i]);\n            if (!check0())\n            {\n                if (first) first = false;\n                else Console.WriteLine();\n                Console.WriteLine(\"NO\");\n                goto exit;\n            }\n            getAns();\n            if (first) first = false;\n            else Console.WriteLine();\n            putAns(ps);\n            exit:;\n        }\n    }\n    static bool check0()\n    {\n        var count = 0;\n        foreach (var x in rnd)\n            if (x.Count() == 1) count++;\n        foreach (var x in cnd)\n            if (x.Count() == 1) count++;\n        return (count >= 1);\n    }\n    static void putAns(List<P> ps)\n    {\n        foreach (var x in ps)\n            Console.WriteLine(map[x.x, x.y]);\n    }\n    static void getAns()\n    {\n        var find = true;\n        while (find)\n        {\n            find = false;\n            if (rcheck()) find = true;\n            if (ccheck()) find = true;\n        }\n    }\n    static bool ccheck()\n    {\n        var tt = 0;\n        for (int i = 0; i < w; i++)\n        {\n            if (cnd[i].Count() == 1)\n            {\n                tt = cnd[i][0];\n                cnd[i].Clear();\n                var tsum = 0;\n                var nodatah = 0;\n                for (int j = 0; j < h; j++)\n                {\n                    if (!nodata[j, i]) tsum += map[j, i];\n                    else nodatah = j;\n                }\n                var ntt = csum[i] - tsum;\n                map[nodatah, i] = ntt;\n                nodata[nodatah, i] = false;\n                rnd[nodatah].Remove(tt);\n                return true;\n            }\n        }\n        return false;\n    }\n    static bool rcheck()\n    {\n        var tt = 0;\n        for (int i = 0; i < h; i++)\n        {\n            if (rnd[i].Count() == 1)\n            {\n                tt = rnd[i][0];\n                rnd[i].Clear();\n                var tsum = 0;\n                var nodataw = 0;\n                for (int j = 0; j < w; j++)\n                {\n                    if (!nodata[i, j]) tsum += map[i, j];\n                    else nodataw = j;\n                }\n                var ntt = rsum[i] - tsum;\n                map[i, nodataw] = ntt;\n                nodata[i, nodataw] = false;\n                cnd[nodataw].Remove(tt);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w;\n    public static int[,] map, map2;\n    public static bool[,] nodata;\n    public static int[] rsum, csum;\n    public static List<int>[] rnd, cnd;\n    public static void Main()\n    {\n        var first = true;\n        while (true)\n        {\n            var ps = new List<P>();\n            var s = Console.ReadLine().Trim();\n            if (s == \"\") continue;\n            else if (s == \"0\") break;\n            string[] line = s.Split(' ');\n            h = int.Parse(line[0]);\n            w = int.Parse(line[1]);\n            map = new int[h, w];\n            map2 = new int[h, w];\n            var p = 0;\n            rnd = new List<int>[h];\n            cnd = new List<int>[w];\n            for (int i = 0; i < h; i++)\n            {\n                rnd[i] = new List<int>();\n                for (int j = 0; j < w; j++) map2[i, j] = p++;\n            }\n            for (int i = 0; i < w; i++) cnd[i] = new List<int>();\n            nodata = new bool[h, w];\n            rsum = new int[h];\n            csum = new int[w];\n            for (int i = 0; i < h; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < w; j++)\n                {\n                    if (line[j] == \"?\")\n                    {\n                        nodata[i, j] = true;\n                        rnd[i].Add(map2[i, j]);\n                        cnd[j].Add(map2[i, j]);\n                        ps.Add(new P { x = i, y = j });\n                    }\n                    else map[i, j] = int.Parse(line[j]);\n                }\n                rsum[i] = int.Parse(line[w]);\n            }\n            line = Console.ReadLine().Trim().Split(' ');\n            for (int i = 0; i < w; i++) csum[i] = int.Parse(line[i]);\n            getAns();\n            if (first) first = false;\n            else Console.WriteLine();\n            if (!check0()) Console.WriteLine(\"NO\");\n            else  putAns(ps);\n        }\n    }\n    static bool check0()\n    {\n        foreach (var x in nodata)\n            if (x) return false;\n        return true;\n    }\n    static void putAns(List<P> ps)\n    {\n        foreach (var x in ps)\n            Console.WriteLine(map[x.x, x.y]);\n    }\n    static void getAns()\n    {\n        var find = true;\n        while (find)\n        {\n            find = false;\n            if (rcheck()) find = true;\n            if (ccheck()) find = true;\n        }\n    }\n    static bool ccheck()\n    {\n        var tt = 0;\n        for (int i = 0; i < w; i++)\n        {\n            if (cnd[i].Count() == 1)\n            {\n                tt = cnd[i][0];\n                cnd[i].Clear();\n                var tsum = 0;\n                var nodatah = 0;\n                for (int j = 0; j < h; j++)\n                {\n                    if (!nodata[j, i]) tsum += map[j, i];\n                    else nodatah = j;\n                }\n                var ntt = csum[i] - tsum;\n                map[nodatah, i] = ntt;\n                nodata[nodatah, i] = false;\n                rnd[nodatah].Remove(tt);\n                return true;\n            }\n        }\n        return false;\n    }\n    static bool rcheck()\n    {\n        var tt = 0;\n        for (int i = 0; i < h; i++)\n        {\n            if (rnd[i].Count() == 1)\n            {\n                tt = rnd[i][0];\n                rnd[i].Clear();\n                var tsum = 0;\n                var nodataw = 0;\n                for (int j = 0; j < w; j++)\n                {\n                    if (!nodata[i, j]) tsum += map[i, j];\n                    else nodataw = j;\n                }\n                var ntt = rsum[i] - tsum;\n                map[i, nodataw] = ntt;\n                nodata[i, nodataw] = false;\n                cnd[nodataw].Remove(tt);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nfirst = true\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for var in vars\n      x, y = var\n\n      if hnvs[y] == 1 && tbl[y][x].nil?\n        sum = 0\n        for x0 in (0...sn)\n          if x0 != x\n            sum += tbl[y][x0]\n          end\n        end\n\n        if x == sn\n          tbl[y][x] = sum\n        else\n          tbl[y][x] = tbl[y][sn] - sum\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n\n      if vnvs[x] == 1 && tbl[y][x].nil?\n        sum = 0\n        for y0 in (0...pn)\n          if y0 != y\n            sum += tbl[y0][x]\n          end\n        end\n\n        if y == pn\n          tbl[y][x] = sum\n        else\n          tbl[y][x] = tbl[pn][x] - sum\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  puts \"\" if ! first\n  first = false\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for var in vars\n      x, y = var\n\n      if hnvs[y] == 1 && tbl[y][x].nil?\n        sum = 0\n        for x0 in (0...sn)\n          if x0 != x\n            sum += tbl[y][x0]\n          end\n        end\n\n        if x == sn\n          tbl[y][x] = sum\n        else\n          tbl[y][x] = tbl[y][sn] - sum\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n\n      if vnvs[x] == 1 && tbl[y][x].nil?\n        sum = 0\n        for y0 in (0...pn)\n          if y0 != y\n            sum += tbl[y0][x]\n          end\n        end\n\n        if y == pn\n          tbl[y][x] = sum\n        else\n          tbl[y][x] = tbl[pn][x] - sum\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(p, s, list)\n  result = Array.new\n  while r=fill!(p, s, list) do\n    result += r\n  end\n  list.each do |l|\n    l.each do |v|\n      return [\"NO\"] unless v\n    end\n  end\n  result.sort{|a, b| a[0]!=b[0] ? a[0]<=>b[0] : (a[1]!=b[1] ? a[1]<=>b[1] : a[2]<=>b[2])}.collect{|v| v.last}\nend\n\ndef fill!(p, s, list)\n  result = Array.new\n  p.times do |i|\n    question = Array.new\n    sum = 0\n    s.times do |j|\n      sum += list[i][j] if list[i][j]\n      question.push(j) unless list[i][j]\n    end\n    next if question.size != 1\n    list[i][question.first] = list[i].last - sum\n    result.push([i, question.first, list[i][question.first]])\n  end\n  s.times do |j|\n    question = Array.new\n    sum = 0\n    p.times do |i|\n      sum += list[i][j] if list[i][j]\n      question.push(i) unless list[i][j]\n    end\n    next if question.size != 1\n    list [question.first][j] = list.last[j] - sum\n    result.push([question.first, j, list [question.first][j]])\n  end\n  result.size.zero? ? nil : result\nend\n\nfirst = true\nuntil (p,s=gets.split.map(&:to_i)).all?(&:zero?) do\n  puts \"\" if !first\n  first = false\n  list = Array.new\n  (p+1).times{list.push(gets.split.map{|v| v==\"?\" ? nil : v.to_i})}\n  gets\n  solve(p,s,list).each{|v| puts v}\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for var in vars\n      x0, y0 = var\n      next if ! tbl[y0][x0].nil?\n\n      if hnvs[y0] == 1\n        y = y0\n        tl = tbl[y]\n        x = tl.index(nil)\n\n        if x == sn\n          tbl[y][x] = tl[0...sn].inject(:+)\n        else\n          tbl[y][x] = tl[sn] - tl[0...sn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n\n      if vnvs[x0] == 1\n        x = x0\n        tl = (0..pn).map{|y| tbl[y][x]}\n        y = tl.index(nil)\n\n        if y == pn\n          tbl[y][x] = tl[0...pn].inject(:+)\n        else\n          tbl[y][x] = tl[pn] - tl[0...pn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "\ndef solve(p, s, list)\n  result = Array.new\n  while r=fill!(p, s, list) do\n    result += r\n  end\n  list.each do |l|\n    l.each do |v|\n      return [\"NO\"] unless v\n    end\n  end\n  result.sort{|a, b| a[0]!=b[0] ? a[0]<=>b[0] : (a[1]!=b[1] ? a[1]<=>b[1] : a[2]<=>b[2])}.collect{|v| v.last}\nend\n\ndef fill!(p, s, list)\n  result = Array.new\n  p.times do |i|\n    question = Array.new\n    sum = 0\n    s.times do |j|\n      sum += list[i][j] if list[i][j]\n      question.push(j) unless list[i][j]\n    end\n    next if question.size != 1\n    list[i][question.first] = list[i].last - sum\n    result.push([i, question.first, list[i][question.first]])\n  end\n  s.times do |j|\n    question = Array.new\n    sum = 0\n    p.times do |i|\n      sum += list[i][j] if list[i][j]\n      question.push(i) unless list[i][j]\n    end\n    next if question.size != 1\n    list [question.first][j] = list.last[j] - sum\n    result.push([question.first, j, list [question.first][j]])\n  end\n  result.size.zero? ? nil : result\nend\n\nuntil (p,s=gets.split.map(&:to_i)).all?(&:zero?) do\n  list = Array.new\n  (p+1).times{list.push(gets.split.map{|v| v==\"?\" ? nil : v.to_i})}\n  gets\n  solve(p,s,list).each{|v| puts v}\n  puts \"\"\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for var in vars\n      x0, y0 = var\n\n      if hnvs[y0] == 1\n        y = y0\n        tl = tbl[y]\n        x = tl.index(nil)\n\n        if x == sn\n          tbl[y][x] = tl[0...sn].inject(:+)\n        else\n          tbl[y][x] = tl[sn] - tl[0...sn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n\n      if vnvs[x0] == 1\n        x = x0\n        tl = (0..pn).map{|y| tbl[y][x]}\n        y = tl.index(nil)\n\n        if y == pn\n          tbl[y][x] = tl[0...pn].inject(:+)\n        else\n          tbl[y][x] = tl[pn] - tl[0...pn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  line = gets.strip\n  line = gets.strip if line.empty?\n  pn, sn = line.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for y in (0..pn)\n      if hnvs[y] == 1\n        tl = tbl[y]\n        x = tl.index(nil)\n\n        if x == sn\n          tbl[y][x] = tl[0...sn].inject(:+)\n        else\n          tbl[y][x] = tl[sn] - tl[0...sn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n\n    for x in (0..sn)\n      if vnvs[x] == 1\n        tl = (0..pn).map{|y| tbl[y][x]}\n        y = tl.index(nil)\n\n        if y == pn\n          tbl[y][x] = tl[0...pn].inject(:+)\n        else\n          tbl[y][x] = tl[pn] - tl[0...pn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "def contain_nil?(matrix)\n    matrix.each do |array|\n        array.each {|e| return true if e == nil }\n    end\n    return false\nend\n\ndef contain_one_nil?(array)\n    count = 0\n    index = nil\n    array.each_with_index do |e, i|\n        if e == nil\n            count += 1 if e == nil\n            index = i\n        end\n    end\n    index if count == 1\nend\n\ndef solveArray(array)\n    sum = array.last * 2\n    array.each do |e|\n        sum -= e if e != nil\n    end\n    sum\nend\n\ndef solve(pp, ss, matrix)\n    while contain_nil?(matrix) do\n        flag = false\n        # row\n        (0..(pp-1)).each do |i|\n            array = matrix[i]\n            index = contain_one_nil?(array)\n            if index\n                array[index] = solveArray(array)\n                flag = true\n                break\n            end\n        end\n        \n        # column\n        (0..(ss-1)).each do |i|\n            array = []\n            matrix.each {|e| array << e[i]}\n            index = contain_one_nil?(array)\n            if index\n                matrix[index][i] = solveArray(array)\n                flag = true\n                break\n            end\n        end\n        \n        # not solve\n        return unless flag\n    end\nend\n\nfirst_flg = true\nwhile true do\n    pp, ss = gets.split(' ').map(&:to_i)\n    break if pp == 0 && ss == nil\n    \n    if first_flg\n        first_flg = false\n    else\n        puts\n    end\n    \n    base_matrix = []\n    matrix = []\n    (pp+1).times do\n        array = gets.split(' ').map do |e|\n            if e == '?'\n                nil\n            else\n                e.to_i\n            end\n        end\n        matrix << array\n        base_matrix << array.dup\n    end\n    solve(pp, ss, matrix)\n    if contain_nil?(matrix)\n        puts 'NO'\n    else\n        base_matrix.each_with_index do |array, i|\n            array.each_with_index do |e, j|\n                puts matrix[i][j] if e == nil\n            end\n        end\n    end\n    gets\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for y in (0..pn)\n      if hnvs[y] == 1\n        tl = tbl[y]\n        x = tl.index(nil)\n\n        if x == sn\n          tbl[y][x] = tl[0...sn].inject(:+)\n        else\n          tbl[y][x] = tl[sn] - tl[0...sn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n\n    for x in (0..sn)\n      if vnvs[x] == 1\n        tl = (0..pn).map{|y| tbl[y][x]}\n        y = tl.index(nil)\n\n        if y == pn\n          tbl[y][x] = tl[0...pn].inject(:+)\n        else\n          tbl[y][x] = tl[pn] - tl[0...pn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  pn, sn = gets.split.map(&:to_i)\n  break if pn == 0\n\n  tbl = (pn + 1).times.map{[]}\n  vars = []\n\n  hnvs = [0] * (pn + 1)\n  vnvs = [0] * (sn + 1)\n\n  for y in (0..pn)\n    vals = gets.strip.split\n    for x in (0..sn)\n      if vals[x] == '?'\n        tbl[y][x] = nil\n        vars << [x, y]\n        hnvs[y] += 1\n        vnvs[x] += 1\n      else\n        tbl[y][x] = vals[x].to_i\n      end\n    end\n  end\n  #p tbl\n  #p vars\n  #p hnvs\n  #p vnvs\n\n  gets\n\n  nv = vars.length\n  changed = true\n\n  while nv > 0 && changed\n    changed = false\n\n    for var in vars\n      x, y = var\n\n      if hnvs[y] == 1 && tbl[y][x].nil?\n        tl = tbl[y]\n\n        if x == sn\n          tbl[y][x] = tl[0...sn].inject(:+)\n        else\n          tbl[y][x] = tl[sn] - tl[0...sn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n\n      if vnvs[x] == 1 && tbl[y][x].nil?\n        tl = (0..pn).map{|y0| tbl[y0][x]}\n\n        if y == pn\n          tbl[y][x] = tl[0...pn].inject(:+)\n        else\n          tbl[y][x] = tl[pn] - tl[0...pn].select{|v| ! v.nil?}.inject(:+)\n        end\n\n        nv -= 1\n        hnvs[y] -= 1\n        vnvs[x] -= 1\n        changed = true\n      end\n    end\n  end\n\n  if nv > 0\n    puts 'NO'\n  else\n    for var in vars\n      x, y = var\n      puts tbl[y][x]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom copy import deepcopy\ndef check(data):\n    return reduce(lambda a, b: a+b, data).count(\"?\")\n\ndef calc(seq):\n    if \"?\" not in seq or not(0 <= seq.count(\"?\") <= 1) :\n        return seq\n    if seq[-1] == \"?\":\n        return seq[:-1] + sum(seq[:-1])\n    a = seq[-1] - sum(s for s in seq[:-1] if s != \"?\")\n    return [s if s != \"?\" else a for s in seq]\n\ndef update(data):\n    data = deepcopy(data)\n    for i in xrange(len(data)):\n        for j, d in enumerate(calc(data[i])):\n            data[i][j] = d\n    t_data = zip(*data)\n    for i in xrange(len(t_data)):\n        for j, d in enumerate(calc(t_data[i])):\n            data[j][i] = d\n    return data\n\nanswer = \"\"\nwhile True:\n    line = raw_input()\n    while line.isspace() or not line: #!?!?!!!\n        line = raw_input()\n    if line == \"0\":\n        break\n    P, S = map(int, line.split())\n    data = [map(lambda x: int(x) if x.replace(\"-\", \"\").isdigit() else x, raw_input().split())\n            for _ in xrange(P+1)]\n    cdata = deepcopy(data)\n    for _ in xrange(check(cdata)):\n        cdata = update(cdata)\n    ans = \"\"\n    if check(cdata) == 0:\n        for d in zip(data, cdata):\n            for e1, e2 in zip(*d):\n                if e1 == \"?\":\n                    ans += \"{}\\n\".format(e2)\n    else:\n        ans += \"NO\\n\"\n    answer += ans + \"\\n\"\nprint answer.strip(\"\\n\")"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import namedtuple\nfrom pprint import pprint\n\n\nQuestion = namedtuple(\"Question\", ['all_sum', 'row_sums', 'col_sums', 'cells', 'row_count', 'col_count'])\n\ndef pp_q(q):\n    print(q.row_count, q.col_count)\n    for irow in range(q.row_count):\n        for icol in range(q.col_count):\n            print(q.cells[irow, icol], end=\"\\t\")\n        print(q.row_sums[irow])\n    for icol in range(q.col_count):\n        print(q.col_sums[icol], end=\"\\t\")\n    print(q.all_sum)\n\n\ndef solve(q):\n    determined = {}\n    while True:\n        good = False\n        # print(equations(q))\n        eqns = equations(q)\n        if not eqns:\n            break\n        for e in equations(q):\n            if len(e.vars) == 1:\n                determined[e.vars[0]] = e.sum\n                # print(e.vars, e.sum)\n                q.cells[e.vars[0]] = e.sum\n                good = True\n                break\n        if not good:\n            return None\n    return [v for _, v in sorted(determined.items())]\n\ndef equations(q):\n    Equation = namedtuple(\"Equation\", [\"vars\", \"sum\"])\n    equations = []\n    for irow in range(q.row_count):\n        s = int(q.row_sums[irow])\n        eq_vars = []\n        for icol in range(q.col_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n\n    for icol in range(q.col_count):\n        s = int(q.col_sums[icol])\n        eq_vars = []\n        for irow in range(q.row_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n    return equations\n\n\n# def solve_equation(variables, ):\n\n\n\ndef main():\n    while True:\n        line = input()\n        if line.strip() == '0':\n            break\n        product_count, store_count = map(int, line.split())\n\n        cells = {}\n        row_sums = {}\n        col_sums = {}\n        for i in range(product_count):\n            row = [(None if x == '?' else int(x)) for x in input().split()]\n            row_sums[i] = row[-1]\n            for k in range(store_count):\n                cells[i, k] = row[k]\n\n        row = [(None if x == '?' else int(x)) for x in input().split()]\n        for k in range(store_count):\n            col_sums[k] = row[k]\n        all_sum = row[-1]\n\n        q = Question(all_sum, row_sums, col_sums, cells, product_count, store_count)\n        a = solve(q)\n        if a is None:\n            print(\"No\")\n        else:\n            for x in a:\n                print(x)\n        print()\n        input() # ???????£???°???\nmain()"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import namedtuple\nfrom pprint import pprint\n\n\nQuestion = namedtuple(\"Question\", ['all_sum', 'row_sums', 'col_sums', 'cells', 'row_count', 'col_count'])\n\ndef pp_q(q):\n    print(q.row_count, q.col_count)\n    for irow in range(q.row_count):\n        for icol in range(q.col_count):\n            print(q.cells[irow, icol], end=\"\\t\")\n        print(q.row_sums[irow])\n    for icol in range(q.col_count):\n        print(q.col_sums[icol], end=\"\\t\")\n    print(q.all_sum)\n\n\ndef solve(q):\n    determined = {}\n    while True:\n        good = False\n        # print(equations(q))\n        eqns = equations(q)\n        if not eqns:\n            break\n        for e in equations(q):\n            if len(e.vars) == 1:\n                determined[e.vars[0]] = e.sum\n                # print(e.vars, e.sum)\n                q.cells[e.vars[0]] = e.sum\n                good = True\n                break\n        if not good:\n            return None\n    return [v for _, v in sorted(determined.items())]\n\ndef equations(q):\n    Equation = namedtuple(\"Equation\", [\"vars\", \"sum\"])\n    equations = []\n    for irow in range(q.row_count):\n        s = int(q.row_sums[irow])\n        eq_vars = []\n        for icol in range(q.col_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n\n    for icol in range(q.col_count):\n        s = int(q.col_sums[icol])\n        eq_vars = []\n        for irow in range(q.row_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n    return equations\n\n\n# def solve_equation(variables, ):\n\n\n\ndef main():\n    first = True\n    while True:\n        line = input()\n        if line.strip() == '0':\n            break\n        product_count, store_count = map(int, line.split())\n\n        cells = {}\n        row_sums = {}\n        col_sums = {}\n        for i in range(product_count):\n            row = [(None if x == '?' else int(x)) for x in input().split()]\n            row_sums[i] = row[-1]\n            for k in range(store_count):\n                cells[i, k] = row[k]\n\n        row = [(None if x == '?' else int(x)) for x in input().split()]\n        for k in range(store_count):\n            col_sums[k] = row[k]\n        all_sum = row[-1]\n\n        q = Question(all_sum, row_sums, col_sums, cells, product_count, store_count)\n        a = solve(q)\n\n        if not first:\n            print()\n        first = False\n\n        if a is None:\n            print(\"No\")\n        else:\n            for x in a:\n                print(x)\n        \n        input() # ???????£???°???\nmain()"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import namedtuple\nfrom pprint import pprint\n\n\nQuestion = namedtuple(\"Question\", ['all_sum', 'row_sums', 'col_sums', 'cells', 'row_count', 'col_count'])\n\ndef pp_q(q):\n    print(q.row_count, q.col_count)\n    for irow in range(q.row_count):\n        for icol in range(q.col_count):\n            print(q.cells[irow, icol], end=\"\\t\")\n        print(q.row_sums[irow])\n    for icol in range(q.col_count):\n        print(q.col_sums[icol], end=\"\\t\")\n    print(q.all_sum)\n\n\ndef solve(q):\n    determined = {}\n    while True:\n        good = False\n        # print(equations(q))\n        eqns = equations(q)\n        if not eqns:\n            break\n        for e in equations(q):\n            if len(e.vars) == 1:\n                determined[e.vars[0]] = e.sum\n                # print(e.vars, e.sum)\n                q.cells[e.vars[0]] = e.sum\n                good = True\n                break\n        if not good:\n            return None\n    return [v for _, v in sorted(determined.items())]\n\ndef equations(q):\n    Equation = namedtuple(\"Equation\", [\"vars\", \"sum\"])\n    equations = []\n    for irow in range(q.row_count):\n        s = int(q.row_sums[irow])\n        eq_vars = []\n        for icol in range(q.col_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n\n    for icol in range(q.col_count):\n        s = int(q.col_sums[icol])\n        eq_vars = []\n        for irow in range(q.row_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n    return equations\n\n\n# def solve_equation(variables, ):\n\n\n\ndef main():\n    first = True\n    while True:\n        line = input()\n        if line.strip() == '0':\n            break\n        product_count, store_count = map(int, line.split())\n\n        cells = {}\n        row_sums = {}\n        col_sums = {}\n        for i in range(product_count):\n            row = [(None if x == '?' else int(x)) for x in input().split()]\n            row_sums[i] = row[-1]\n            for k in range(store_count):\n                cells[i, k] = row[k]\n\n        row = [(None if x == '?' else int(x)) for x in input().split()]\n        for k in range(store_count):\n            col_sums[k] = row[k]\n        all_sum = row[-1]\n\n        q = Question(all_sum, row_sums, col_sums, cells, product_count, store_count)\n        a = solve(q)\n\n        if not first:\n            print()\n        first = False\n        \n        if a is None:\n            print(\"No\")\n        else:\n            for x in a:\n                print(x)\n        \n        input() # ???????£???°???\nmain()"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\nanswer = \"\"\nwhile True:\n    line = raw_input()\n    while line.isspace() or not line: #!?!?!!!\n        line = raw_input()\n    if line == \"0\":\n        break\n    P, S = map(int, line.split())\n    def check(data):\n        return reduce(lambda a, b: a+b, data).count(\"?\")\n    def calc(seq):\n        if \"?\" not in seq or not(0 <= seq.count(\"?\") <= 1) :\n            return seq\n        if seq[-1] == \"?\":\n            return seq[:-1] + sum(seq[:-1])\n        a = seq[-1] - sum(s for s in seq[:-1] if s != \"?\")\n        return [s if s != \"?\" else a for s in seq]\n    def update(data):\n        data = deepcopy(data)\n        t_data = zip(*data)\n        for i in xrange(P):\n            for j, d in enumerate(calc(data[i])):\n                data[i][j] = d\n            for j, d in enumerate(calc(t_data[i])):\n                data[j][i] = d\n        return data\n    data = [map(lambda x: int(x) if x.isdigit() else x, raw_input().split())\n            for _ in xrange(P+1)]\n    cdata = deepcopy(data)\n    for _ in xrange(check(cdata)):\n        cdata = update(cdata)\n    ans = \"\"\n    if check(cdata) == 0:\n        for d in zip(data, cdata):\n            for e1, e2 in zip(*d):\n                if e1 == \"?\":\n                    ans += \"{}\\n\".format(e2)\n    else:\n        ans += \"NO\\n\"\n    answer += ans + \"\\n\"\nprint answer.strip(\"\\n\")"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import namedtuple\nfrom pprint import pprint\n\n\nQuestion = namedtuple(\"Question\", ['all_sum', 'row_sums', 'col_sums', 'cells', 'row_count', 'col_count'])\n\ndef pp_q(q):\n    print(q.row_count, q.col_count)\n    for irow in range(q.row_count):\n        for icol in range(q.col_count):\n            print(q.cells[irow, icol], end=\"\\t\")\n        print(q.row_sums[irow])\n    for icol in range(q.col_count):\n        print(q.col_sums[icol], end=\"\\t\")\n    print(q.all_sum)\n\n\ndef solve(q):\n    determined = {}\n    while True:\n        good = False\n        # print(equations(q))\n        eqns = equations(q)\n        if not eqns:\n            break\n        for e in equations(q):\n            if len(e.vars) == 1:\n                determined[e.vars[0]] = e.sum\n                # print(e.vars, e.sum)\n                q.cells[e.vars[0]] = e.sum\n                good = True\n                break\n        if not good:\n            return None\n    return [v for _, v in sorted(determined.items())]\n\ndef equations(q):\n    Equation = namedtuple(\"Equation\", [\"vars\", \"sum\"])\n    equations = []\n    for irow in range(q.row_count):\n        s = int(q.row_sums[irow])\n        eq_vars = []\n        for icol in range(q.col_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n\n    for icol in range(q.col_count):\n        s = int(q.col_sums[icol])\n        eq_vars = []\n        for irow in range(q.row_count):\n            x = q.cells[irow, icol]\n            if x is not None:\n                s -= int(x)\n            else:\n                eq_vars.append((irow, icol))\n        if not eq_vars: continue\n        equations.append(Equation(eq_vars, s))\n    return equations\n\n\n# def solve_equation(variables, ):\n\n\n\ndef main():\n    first = True\n    while True:\n        line = input()\n        if line.strip() == '0':\n            break\n        product_count, store_count = map(int, line.split())\n\n        cells = {}\n        row_sums = {}\n        col_sums = {}\n        for i in range(product_count):\n            row = [(None if x == '?' else int(x)) for x in input().split()]\n            row_sums[i] = row[-1]\n            for k in range(store_count):\n                cells[i, k] = row[k]\n\n        row = [(None if x == '?' else int(x)) for x in input().split()]\n        for k in range(store_count):\n            col_sums[k] = row[k]\n        all_sum = row[-1]\n\n        q = Question(all_sum, row_sums, col_sums, cells, product_count, store_count)\n        a = solve(q)\n        if a is None:\n            print(\"No\")\n        else:\n            for x in a:\n                print(x)\n        if not first:\n            print()\n        first = False\n        \n        input() # ???????£???°???\nmain()"
  },
  {
    "language": "Rust",
    "code": "use std::ascii::AsciiExt;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone)]\nenum Cell {\n    Blank, Value(i32)\n}\nimpl Cell {\n    fn is_blank(&self) -> bool {\n        match self {\n            &Cell::Blank => true,\n            _ => false\n        }\n    }\n}\nimpl FromStr for Cell {\n    type Err = ();\n    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> { \n        if s == \"?\" {\n            Ok(Cell::Blank)\n        }else {\n            match i32::from_str(s) {\n                Ok(value) => Ok(Cell::Value(value)),\n                _ => Err(())\n            }\n        }\n     }\n}\n\n\nfn main() {\n    let mut first = true;\n    loop {\n        read!(values: [usize]);\n        if values[0] == 0 {break;}\n        if !first {\n            println!(\"\");\n        }\n        let row_count = values[0];\n        let column_count = values[1];\n        read!(mut graph: [[Cell]; row_count + 1]);\n        let mut count_by_row = vec![0usize; row_count];\n        let mut count_by_column = vec![0usize; column_count];\n        let mut blank_count = 0;\n        let mut blank_cell = Vec::new();\n        for r in 0 .. row_count {\n            for c in 0 .. column_count {\n                match graph[r][c] {\n                    Cell::Blank => {\n                        count_by_row[r] += 1;\n                        count_by_column[c] += 1;\n                        blank_count += 1;\n                        blank_cell.push((r, c));\n                    },\n                    _ => (),\n                }\n            }\n        }\n        while blank_count > 0 && (count_by_row.iter().any(|&c| c == 1) || count_by_column.iter().any(|&c| c == 1)) {\n            if let Some(r) = (0 .. row_count).find(|&i| count_by_row[i] == 1) {\n                let c = (0 .. column_count).find(|&i| graph[r][i].is_blank()).unwrap();\n                let others = (0 .. column_count).map(|i| {\n                    match graph[r][i] {\n                        Cell::Value(value) => value,\n                        _ => 0\n                    }\n                }).sum::<i32>();\n                let sum = match graph[r][column_count] {\n                    Cell::Value(value) => value,\n                    _ => panic!()\n                };\n                graph[r][c] = Cell::Value(sum - others);\n                count_by_row[r] -= 1;\n                count_by_column[c] -= 1;\n            }else if let Some(c) = (0 .. column_count).find(|&i| count_by_column[i] == 1) {\n                let r = (0 .. row_count).find(|&i| graph[i][c].is_blank()).unwrap();\n                let others = (0 .. row_count).map(|i| {\n                    match graph[i][c] {\n                        Cell::Value(value) => value,\n                        _ => 0\n                    }\n                }).sum::<i32>();\n                let sum = match graph[row_count][c] {\n                    Cell::Value(value) => value,\n                    _ => panic!()\n                };\n                graph[r][c] = Cell::Value(sum - others);\n                count_by_row[r] -= 1;\n                count_by_column[c] -= 1;\n            }\n        }\n        if graph.iter().any(|line| line.iter().any(|cell| cell.is_blank())) {\n            println!(\"NO\");\n        }else {\n            for (r, c) in blank_cell {\n                match graph[r][c] {\n                    Cell::Value(value) => println!(\"{}\", value),\n                    _ => panic!()\n                }\n            }\n        }\n        read!(blank: String);\n        first = false;\n    }\n}\n"
  }
]