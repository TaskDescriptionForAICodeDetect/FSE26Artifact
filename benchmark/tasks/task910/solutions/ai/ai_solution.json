[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int n, i, j, k;\n    scanf(\"%d\", &n);\n    \n    int arr[n+1];\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int freq[n+1];\n    memset(freq, 0, sizeof(freq));\n    \n    for (i = 1; i <= n; i++) {\n        freq[arr[i]]++;\n    }\n    \n    long long dp[n+2][n+2];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;\n            }\n        }\n    }\n    \n    long long result[n+2];\n    memset(result, 0, sizeof(result));\n    \n    for (k = 1; k <= n+1; k++) {\n        for (i = 1; i <= n; i++) {\n            if (freq[i] > 0) {\n                result[k] = (result[k] + dp[n][k-1]) % MOD;\n            }\n        }\n    }\n    \n    for (k = 1; k <= n+1; k++) {\n        printf(\"%lld\\n\", result[k]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 100010\n\nint fact[MAXN], inv_fact[MAXN];\nint freq[MAXN];\n\nint power(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = (long long)res * a % MOD;\n        }\n        a = (long long)a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = (long long)fact[i-1] * i % MOD;\n    }\n    inv_fact[MAXN-1] = power(fact[MAXN-1], MOD-2);\n    for (int i = MAXN-2; i >= 0; i--) {\n        inv_fact[i] = (long long)inv_fact[i+1] * (i+1) % MOD;\n    }\n}\n\nint comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (long long)fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD;\n}\n\nint main() {\n    precompute();\n    int n;\n    scanf(\"%d\", &n);\n    int m = n + 1;\n    int *a = (int *)malloc(m * sizeof(int));\n    memset(freq, 0, sizeof(freq));\n    int dup = -1;\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &a[i]);\n        freq[a[i]]++;\n        if (freq[a[i]] == 2) {\n            dup = a[i];\n        }\n    }\n    int l = -1, r = -1;\n    for (int i = 0; i < m; i++) {\n        if (a[i] == dup) {\n            if (l == -1) {\n                l = i;\n            } else {\n                r = i;\n            }\n        }\n    }\n    int d = r - l - 1;\n    for (int k = 1; k <= n + 1; k++) {\n        int total = comb(m, k);\n        int sub = comb(m - (r - l + 1), k - 1);\n        int ans = (total - sub + MOD) % MOD;\n        printf(\"%d\\n\", ans);\n    }\n    free(a);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<int> fact, inv_fact;\n\nint power(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b & 1) res = (1LL * res * a) % MOD;\n        a = (1LL * a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute(int n) {\n    fact.resize(n + 1);\n    inv_fact.resize(n + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    inv_fact[n] = power(fact[n], MOD - 2);\n    for (int i = n - 1; i >= 0; --i) {\n        inv_fact[i] = (1LL * inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (1LL * fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    for (int i = 0; i < n + 1; ++i) {\n        cin >> a[i];\n    }\n    \n    map<int, int> last_pos;\n    int dup1 = -1, dup2 = -1;\n    for (int i = 0; i < n + 1; ++i) {\n        if (last_pos.count(a[i])) {\n            dup1 = last_pos[a[i]];\n            dup2 = i;\n            break;\n        }\n        last_pos[a[i]] = i;\n    }\n    \n    int m = dup1 + (n - dup2);\n    precompute(n + 1);\n    \n    for (int k = 1; k <= n + 1; ++k) {\n        int total = comb(n + 1, k);\n        int sub = comb(m, k - 1);\n        int ans = (total - sub + MOD) % MOD;\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SubsequenceCount {\n\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] sequence = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n\n        // Find the duplicate number\n        int duplicate = -1;\n        Map<Integer, Integer> map = new HashMap<>();\n        int left = -1, right = -1;\n        for (int i = 0; i <= n; i++) {\n            if (map.containsKey(sequence[i])) {\n                left = map.get(sequence[i]);\n                right = i;\n                duplicate = sequence[i];\n                break;\n            }\n            map.put(sequence[i], i);\n        }\n\n        int totalLength = n + 1;\n        int m = totalLength - (right - left + 1);\n\n        // Precompute factorial, inverse factorial\n        int maxN = totalLength;\n        long[] fact = new long[maxN + 1];\n        long[] invFact = new long[maxN + 1];\n        fact[0] = invFact[0] = 1;\n        for (int i = 1; i <= maxN; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n            invFact[i] = invFact[i - 1] * modInverse(i, MOD) % MOD;\n        }\n\n        for (int k = 1; k <= n + 1; k++) {\n            long total = comb(fact, invFact, totalLength, k);\n            long invalid = comb(fact, invFact, m, k - 1);\n            long res = (total - invalid + MOD) % MOD;\n            System.out.println(res);\n        }\n    }\n\n    static long comb(long[] fact, long[] invFact, int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    static long modInverse(int a, int mod) {\n        return power(a, mod - 2, mod);\n    }\n\n    static long power(long a, long b, int mod) {\n        long res = 1;\n        a = a % mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % mod;\n            }\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:19:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public static long[] countSubsequences(int[] arr) {\n        int n = arr.length - 1;\n        long[] result = new long[n + 1];\n        Set<Long> uniqueSubsequences = new HashSet<>();\n\n        for (int k = 1; k <= n + 1; k++) {\n            uniqueSubsequences.clear();\n            generateSubsequences(arr, k, 0, 0L, uniqueSubsequences);\n            result[k - 1] = uniqueSubsequences.size() % MOD;\n        }\n\n        return result;\n    }\n\n    private static void generateSubsequences(int[] arr, int k, int index, long current, Set<Long> uniqueSubsequences) {\n        if (Long.bitCount(current) == k) {\n            uniqueSubsequences.add(sortSubsequence(current, arr));\n            return;\n        }\n\n        if (index == arr.length) return;\n\n        generateSubsequences(arr, k, index + 1, current, uniqueSubsequences);\n        generateSubsequences(arr, k, index + 1, current | (1L << index), uniqueSubsequences);\n    }\n\n    private static long sortSubsequence(long bitmask, int[] arr) {\n        List<Integer> subsequence = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if ((bitmask & (1L << i)) != 0) {\n                subsequence.add(arr[i]);\n            }\n        }\n        Collections.sort(subsequence);\n\n        long hash = 0;\n        for (int val : subsequence) {\n            hash = hash * 31 + val;\n        }\n        return hash;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] arr = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            arr[i] = scanner.nextInt();\n        }\n        scanner.close();\n\n        long[] result = countSubsequences(arr);\n        for (long count : result) {\n            System.out.println(count);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:19:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    vector<int> countSubsequences(vector<int>& nums) {\n        int n = nums.size() - 1;\n        vector<vector<int>> freq(n + 1);\n        \n        // Track positions of each number\n        for (int i = 0; i < nums.size(); i++) {\n            freq[nums[i]].push_back(i);\n        }\n        \n        vector<int> result(n + 1, 0);\n        \n        // Iterate through possible subsequence lengths\n        for (int k = 1; k <= n + 1; k++) {\n            set<vector<int>> unique_subsequences;\n            \n            // Generate all possible subsequences of length k\n            vector<int> current_subseq(k, 0);\n            \n            function<void(int, int)> backtrack = [&](int idx, int start) {\n                if (idx == k) {\n                    unique_subsequences.insert(current_subseq);\n                    return;\n                }\n                \n                for (int num = 1; num <= n; num++) {\n                    auto& positions = freq[num];\n                    auto it = lower_bound(positions.begin(), positions.end(), start);\n                    \n                    if (it != positions.end()) {\n                        current_subseq[idx] = num;\n                        backtrack(idx + 1, *it + 1);\n                    }\n                }\n            };\n            \n            backtrack(0, 0);\n            result[k - 1] = unique_subsequences.size() % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 23:19:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef find_subsequences(seq, n):\n    import collections\n    count = collections.Counter(seq)\n\n    # Precompute factorials and inverse factorials\n    max_count = max(count.values())\n    \n    fact = [1] * (max_count + 1)\n    inv_fact = [1] * (max_count + 1)\n    \n    def modinv(x):\n        return pow(x, MOD - 2, MOD)\n\n    for i in range(2, max_count + 1):\n        fact[i] = fact[i-1] * i % MOD\n\n    inv_fact[max_count] = modinv(fact[max_count])\n    for i in range(max_count - 1, 1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    def binomial_coefficient(n, k):\n        if k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD\n\n    # Calculate number of unique subsequences for each length\n    result = []\n    for k in range(1, n + 2):\n        total = 1\n        for c in count:\n            total *= binomial_coefficient(count[c] + k - 1, count[c])\n            total %= MOD\n        result.append(total)\n\n    return result\n\n# Input\nn = 5\nsequence = [1, 2, 3, 4, 5, 1]\n\n# Get result\nresult = find_subsequences(sequence, n)\n\n# Output result\nfor val in result:\n    print(val)",
    "timestamp": "2025-08-13 14:44:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SubsequenceCounter {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] sequence = new int[n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n\n        long[] factorial = new long[n + 2];\n        long[] inverseFactorial = new long[n + 2];\n        \n        factorial[0] = 1;\n        for (int i = 1; i <= n + 1; i++) {\n            factorial[i] = factorial[i - 1] * i % MOD;\n        }\n        \n        inverseFactorial[n + 1] = modularExponentiation(factorial[n + 1], MOD - 2);\n        for (int i = n; i >= 0; i--) {\n            inverseFactorial[i] = inverseFactorial[i + 1] * (i + 1) % MOD;\n        }\n\n        for (int k = 1; k <= n + 1; k++) {\n            long result = (factorial[n + 1] * inverseFactorial[k] % MOD) * inverseFactorial[n + 1 - k] % MOD;\n            System.out.println(result);\n        }\n    }\n\n    private static long modularExponentiation(long base, long exp) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = result * base % MOD;\n            }\n            base = base * base % MOD;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 14:44:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\n\nint freq[100002];\nlong long factorial[100002];\nlong long invFactorial[100002];\n\nlong long mod_exp(long long base, long long exp, long long mod) {\n    long long res = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) res = (res * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials(int n) {\n    factorial[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorial[i] = (factorial[i-1] * i) % MOD;\n    }\n    invFactorial[n] = mod_exp(factorial[n], MOD-2, MOD);\n    for (int i = n-1; i >= 0; i--) {\n        invFactorial[i] = (invFactorial[i+1] * (i+1)) % MOD;\n    }\n}\n\nlong long nCk(int n, int k) {\n    if (k > n) return 0;\n    long long res = factorial[n];\n    res = (res * invFactorial[k]) % MOD;\n    res = (res * invFactorial[n-k]) % MOD;\n    return res;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int sequence[n+1];\n    memset(freq, 0, sizeof(freq));\n    for (int i = 0; i < n+1; i++) {\n        scanf(\"%d\", &sequence[i]);\n        freq[sequence[i]]++;\n    }\n\n    precompute_factorials(n+1);\n\n    long long dp[n+2];\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n\n    for (int num = 1; num <= n; num++) {\n        for (int k = num; k > 0; k--) {\n            dp[k] = (dp[k] + (dp[k-1] * freq[num]) % MOD) % MOD;\n        }\n    }\n\n    for (int k = 1; k <= n+1; k++) {\n        printf(\"%lld\\n\", dp[k]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:44:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nconst int MOD = 1000000007;\n\nstd::vector<int> countSubsequences(int n, const std::vector<int>& sequence) {\n    std::map<int, int> freq;\n    for (int x : sequence) {\n        freq[x]++;\n    }\n\n    std::vector<int> factorial(n + 2, 1), invFactorial(n + 2, 1);\n    for (int i = 2; i <= n + 1; ++i) {\n        factorial[i] = static_cast<long long>(factorial[i - 1]) * i % MOD;\n    }\n\n    invFactorial[n + 1] = 1;\n    int base = factorial[n + 1];\n    for (int exp = MOD - 2; exp > 0; exp >>= 1) {\n        if (exp & 1) {\n            invFactorial[n + 1] = static_cast<long long>(invFactorial[n + 1]) * base % MOD;\n        }\n        base = static_cast<long long>(base) * base % MOD;\n    }\n\n    for (int i = n; i >= 1; --i) {\n        invFactorial[i] = static_cast<long long>(invFactorial[i + 1]) * (i + 1) % MOD;\n    }\n\n    std::vector<int> answer(n + 1, 0);\n    for (int k = 1; k <= n + 1; ++k) {\n        long long count = 1;\n        for (const auto& [_, f] : freq) {\n            count = count * (factorial[f] * invFactorial[k - 1] % MOD) % MOD * invFactorial[f - (k - 1)] % MOD;\n        }\n        answer[k - 1] = count;\n    }\n    return answer;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> sequence(n + 1);\n    for (int& x : sequence) {\n        std::cin >> x;\n    }\n\n    std::vector<int> result = countSubsequences(n, sequence);\n    for (int x : result) {\n        std::cout << x << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:44:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_subsequences(arr):\n    n = len(arr) - 1\n    MOD = 10**9 + 7\n    \n    # Count frequency of each number\n    freq = [0] * (n + 1)\n    for num in arr:\n        freq[num] += 1\n    \n    # DP to count unique subsequences\n    dp = [[0] * (n + 1) for _ in range(n + 2)]\n    dp[0][0] = 1\n    \n    for k in range(1, n + 2):\n        for j in range(1, n + 1):\n            # Not including current number\n            dp[k][j] = dp[k][j-1]\n            \n            # Including current number\n            if freq[j] > 0:\n                dp[k][j] = (dp[k][j] + dp[k-1][j-1]) % MOD\n    \n    # Return subsequence counts for 1 to n+1 lengths\n    return [dp[k][n] for k in range(1, n + 2)]\n\n# Input processing\nn = int(input())\narr = list(map(int, input().split()))\nresult = count_subsequences(arr)\nprint(*result)",
    "timestamp": "2025-08-13 14:45:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    n = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    pos = [-1] * (n + 2)\n    dup_x = -1\n    for idx, num in enumerate(A):\n        if pos[num] != -1:\n            dup_x = num\n            left = pos[num]\n            right = idx\n            break\n        pos[num] = idx\n    \n    max_k = n + 1\n    fact = [1] * (max_k + 1)\n    inv_fact = [1] * (max_k + 1)\n    for i in range(1, max_k + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_k] = pow(fact[max_k], MOD-2, MOD)\n    for i in range(max_k - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    m = n + 1\n    l = left + (m - 1 - right)\n    for k in range(1, n + 2):\n        total = comb(m, k)\n        same = comb(l, k - 1)\n        res = (total - same) % MOD\n        print(res)\n\nsolve()",
    "timestamp": "2025-08-13 14:45:11"
  }
]