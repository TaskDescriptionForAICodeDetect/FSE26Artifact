[
  {
    "language": "C++",
    "code": "//Name: Clock Hands\n//Level: 4\n//Category: 数学,Math\n//Note:\n\n/**\n * 時計回りにみたとき、短針—秒針—長針のパターンか、長針—秒針—短針のパターンかを調べる。\n * 前者のとき、この向きで見て0.5∠短長より短針側に秒針がいるときは、方程式を計算することで解が求められる。\n * そうでない場合、いったん長針を追い越してから後者のパターンで計算する。\n * 後者の時も同様。\n *\n * オーダーは O(1)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a, LL b) {\n    if(a < b) swap(a, b);\n    while(b != 0) {\n        LL tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nLL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\nstruct Fraction {\n    LL num, den;\n    explicit Fraction(LL num) : num(num), den(1) { normalize(); }\n    Fraction(LL num, LL den) : num(num), den(den) { normalize(); }\n\n    Fraction& operator +=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num += f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator -=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num -= f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator *=(const Fraction &f) {\n        num *= f.num;\n        den *= f.den;\n        normalize();\n        return *this;\n    }\n\n    bool operator ==(const Fraction &f) const {\n        return (num == 0 && f.num == 0) || (num == f.num && den == f.den);\n    }\n\n    bool operator <(const Fraction &f) const {\n        return num * f.den < den * f.num;\n    }\n\n    bool operator >(const Fraction &f) const {\n        return num * f.den > den * f.num;\n    }\n\n    bool operator <=(const Fraction &f) const {\n        return *this < f || *this == f;\n    }\n\n    void normalize() {\n        LL g = abs(gcd(num, den));\n        num /= g;\n        den /= g;\n        if(den < 0) {\n            num = -num;\n            den = -den;\n        }\n    }\n\n    Fraction strict() const {\n        return Fraction(num % den, den);\n    }\n};\n\nFraction operator +(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret += g;\n    return ret;\n}\n\nFraction operator -(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret -= g;\n    return ret;\n}\n\nFraction operator /(const Fraction &f, LL d) {\n    Fraction ret = f;\n    ret *= Fraction(1, d);\n    return ret;\n}\n\nFraction operator /(const Fraction &f, const Fraction &d) {\n    Fraction ret = f;\n    ret *= Fraction(d.den, d.num);\n    return ret;\n}\n\nostream& operator <<(ostream &os, const Fraction &f) {\n    return os << '(' << f.num << '/' << f.den << ')';\n}\n\nFraction calc_hour_sec_min(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < ah) as += Fraction(1);\n    while(am < as) am += Fraction(1);\n    while(as > ah + Fraction(1)) as -= Fraction(1);\n    while(am > as + Fraction(1)) am -= Fraction(1);\n    assert(ah <= as && as <= am);\n    // calc (as-ah)+x*(1/60-1/3600H) == (am-as)+x*(1/3600-1/60)\n    // is (1/60-1/3600H-1/3600+1/60)x = am-as-as+ah\n    const Fraction rhs = am - as - as + ah;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600*H) - Fraction(1,3600) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc_min_sec_hour(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < am) as += Fraction(1);\n    while(ah < as) ah += Fraction(1);\n    while(as > am + Fraction(1)) as -= Fraction(1);\n    while(ah > as + Fraction(1)) ah -= Fraction(1);\n    assert(am <= as && as <= ah);\n    // calc (as-am)+x*(1/60-1/3600) == (ah-as)+x*(1/3600H-1/60)\n    // is (1/60-1/3600-1/3600H+1/60)x == ah-as-as+am\n    const Fraction rhs = ah - as - as + am;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600) - Fraction(1,3600*H) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc(int H, int h, int m, int s) {\n    Fraction ah = Fraction(h*3600 + m*60 + s, H*3600);\n    Fraction am = Fraction(m*60 + s, 3600);\n    Fraction as = Fraction(s, 60);\n    Fraction dmh = am - ah;\n    Fraction dsh = as - ah;\n    if(dmh.num < 0) dmh += Fraction(1);\n    if(dsh.num < 0) dsh += Fraction(1);\n    if(dmh > dsh) { // hour-sec-min\n        if(as < ah) as += Fraction(1);\n        if(am < as) am += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_hour_sec_min(H, ah, am, as);\n        } else {\n            // calc as+x/60 == am+x/3600\n            // is (1/60-1/3600)x == am-as\n            const Fraction tmp = (am - as) / (Fraction(1,60) - Fraction(1,3600));\n            return tmp + calc_min_sec_hour(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    } else if(dmh <= dsh) { // min-sec-hour\n        if(as < am) as += Fraction(1);\n        if(ah <= as) ah += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_min_sec_hour(H, ah, am, as);\n        } else {\n            // calc as+x/60 == ah+x/3600H\n            // is (1/60-1/3600H)x == ah-as\n            const Fraction tmp = (ah - as) / (Fraction(1,60) - Fraction(1,3600*H));\n            return tmp + calc_hour_sec_min(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    }\n    assert(false);\n}\n\nbool solve() {\n    int H, h, m, s;\n    if(!(cin >> H >> h >> m >> s)) return false;\n    if(!H && !h && !m && !s) return false;\n\n    Fraction pass = calc(H, h, m, s);\n    //cout << pass << endl;\n    s += pass.num / pass.den;\n    pass -= Fraction(pass.num / pass.den);\n    m += s / 60;\n    s %= 60;\n    h += m / 60;\n    m %= 60;\n    h %= H;\n    if(h == 0 && m == 0 && s == 0 && pass == Fraction(0,1)) {\n        pass = calc(H, h, m, s);\n        s += pass.num / pass.den;\n        pass -= Fraction(pass.num / pass.den);\n        m += s / 60;\n        s %= 60;\n        h += m / 60;\n        m %= 60;\n        h %= H;\n    }\n    pass += Fraction(s);\n    cout << h << ' ' << m << ' ' << pass.num << ' ' << pass.den << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n// #include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint gcd(int a, int b){\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n  int H, h, m, s, a;\n  while(cin >> H >> h >> m >> s, H | h | m | s) {\n    a = -1;\n    while(true) {\n      int d = 119 * H - 1;\n      int n = 60 * m * (H + 1) + 60 * 60 * (h + a * H);\n      // LOG(\"n :%d d:%d\\n\", n, d);\n      if(s * d <= n && n < 60 * d && n != m * d) {\n        int g = gcd(n, d);\n        // LOG(\"g %d\\n\", g);\n        n /= g;\n        d /= g;\n        printf(\"%d %d %d %d\\n\", h, m, n, d);\n        break;\n      }\n\n      a++;\n      if(a > 1) {\n        a = -1;\n        s = 0;\n        m++;\n        if(m >= 60) {\n          m = 0;\n          h++;\n          if(h >= H) {\n            h = 0;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> Q;\n\npair<Q,Q> calcSec(int H, int h, int m){\n  pair<Q,Q> res;\n  bool f = false;\n  if( (h*3600 + m*60 + m*60*H ) < 20*H*180) f = true;\n\n  res.first = make_pair(h*3600 + m*60*(H+1), -H + 120*H - 1);\n  res.second = make_pair(h*3600 + m*60*(H+1) + (f?180:-180)*20*H, -H + 120*H - 1);\n \n  return res;\n}\n\nbool comp(Q a, Q b){\n  return a.first * b.second < a.second * b.first;\n}\n\nint main(){\n  int H,h,m,s;\n\n  while(cin >> H >> h >> m >> s, H){\n    for(;;){\n      pair<Q,Q> tmp = calcSec(H,h,m);\n      \n      Q res = make_pair(60,1);\n\n      if( (s*tmp.first.second <= tmp.first.first) && comp(tmp.first,res)\n\t  && (60*tmp.first.first != m*60*tmp.first.second + tmp.first.first) )res = tmp.first;\n      if( (s*tmp.second.second <= tmp.second.first) && comp(tmp.second,res)\n\t  && (60*tmp.second.first != m*60*tmp.second.second + tmp.second.first) )res = tmp.second;\n\n      if(res != Q(60,1)){\n\tif(res.first == 0){\n\t  cout << h << \" \" << m << \" \" << 0 << \" \" << 1 << endl;\n\t}else{ \n\t  assert(res.first>=0);\n\t  int g = __gcd(res.first, res.second);\n\t  res.first /= g; res.second /= g;\n\t  cout << h << \" \" << m << \" \" << res.first << \" \" << res.second << endl;\n\t}\n\tbreak;\n      }\n      s = 0;\n      m++;\n      if(m==60)m = 0,h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define int long long\nusing namespace std;\nint gcd(int x,int y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nsigned main(){\n\twhile(true){\n\t\tint H,h0,m0,s0;\n\t\tcin>>H>>h0>>m0>>s0;\n\t\tif(H==0) break;\n\t\tint h_=h0,m=m0;\n\t\tbool fst=1;\n\t\twhile(true){\n\t\t\tbool en=0;\n\t\t\tfor(int h=h_-H;h<=h_+H;h+=H){\n\t\t\t\tint sa=119*H-1;\n\t\t\t\tint sb=3600*h+60*(H+1)*m;\n\t\t\t\tif(sb<0||sb>=sa*60){\n\t\t\t\t}else if(fst&&sb<sa*s0){\n\t\t\t\t}else if( (60*sb*H-3600*h*sa+60*m*sa+sb)%(3600*H*sa)==0 ){\n\t\t\t\t}else{\n\t\t\t\t\tint g=gcd(sa,sb);\n\t\t\t\t\tcout<<h_<<\" \"<<m<<\" \"<<sb/g<<\" \"<<sa/g<<endl;\n\t\t\t\t\ten=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(en) break;\n\t\t\tfst=0;\n\t\t\tm++;\n\t\t\tif(m==60) m=0,h_++;\n\t\t\tif(h_==H) h_=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nstruct fraction {\n\ttypedef long long frac_t;\n\tfrac_t nume, deno;\n\n\tvoid reduce() {\n\t\tfrac_t g = __gcd(nume, deno);\n\t\tnume /= g; deno /= g;\n\t}\n\n\tfraction(frac_t n = 1, frac_t d = 1):nume(n), deno(d) { reduce(); }\n\tfraction(const fraction& f):nume(f.nume), deno(f.deno) {}\n\n\tfraction operator+(const fraction& o) const {\n\t\tfrac_t rdeno = deno / __gcd(deno, o.deno) * o.deno;\n\t\tfrac_t rnume = rdeno / deno * nume + rdeno / o.deno * o.nume;\n\t\treturn fraction(rnume, rdeno);\n\t}\n\n\tfraction operator-(const fraction& o) const {\n\t\tfrac_t rdeno = deno / __gcd(deno, o.deno) * o.deno;\n\t\tfrac_t rnume = rdeno / deno * nume - rdeno / o.deno * o.nume;\n\t\treturn fraction(rnume, rdeno);\n\t}\n\n\tfraction operator/(const fraction& o) const {\n\t\tfrac_t g1 = __gcd(nume, o.nume);\n\t\tfrac_t g2 = __gcd(o.deno, deno);\n\t\tfrac_t rnume = (nume / g1) * (o.deno / g2);\n\t\tfrac_t rdeno = (deno / g2) * (o.nume / g1);\n\t\treturn fraction(rnume, rdeno);\n\t}\n\n\tfraction &operator+=(const fraction& o) {\n\t\tfrac_t rdeno = deno / __gcd(deno, o.deno) * o.deno;\n\t\tnume = rdeno / deno * nume + rdeno / o.deno * o.nume;\n\t\tdeno = rdeno;\n\t\treduce();\n\t\treturn *this;\n\n\t}\n\n\tfraction operator+(int d) {\n\t\treturn *this + fraction(d, 1);\n\t}\n\n\tfraction operator/(int d) {\n\t\treturn fraction(nume, deno * d);\n\t}\n\n\tbool operator==(const fraction& o) const {\n\t\treturn nume == o.nume && deno == o.deno;\n\t}\n\n\tbool operator<(const fraction& o) const {\n\t\tfrac_t lcm_deno = deno / __gcd(deno, o.deno) * o.deno;\n\t\treturn lcm_deno / deno * nume < lcm_deno / o.deno * o.nume;\n\t}\n\n\tdouble toDouble() const {\n\t\treturn (double)nume / deno;\n\t}\n};\n\nint H;\n\nconstexpr double EPS = 1e-10;\nconst fraction one(1, 1);\n\nvoid normalize(int &h, int &m, fraction &fs) {\n\tif(fs.toDouble() >= 60) {\n\t\tfs += fraction(-60, 1);\n\t\tif(++m >= 60) {\n\t\t\tm = 0;\n\t\t\tif(++h >= H) {\n\t\t\t\th = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class T>\nT get_angle(T a, T b) {\n\tif(b < a) swap(a, b);\n\treturn min(b - a, a - b + 1);\n}\n\nbool equal(double a, double b) {\n\treturn abs(a - b) < EPS;\n}\n\nbool strict_ok(int h, int m, const fraction &fs) {\n\tfraction theta_s = fs / 60;\n\tfraction theta_m = fraction(m, 60) + theta_s / 60;\n\tfraction theta_h = fraction(h, H) + theta_m / H;\n\treturn !(theta_m == theta_h)\n\t\t&& get_angle(theta_s, move(theta_m)) == get_angle(move(theta_s), move(theta_h));\n}\n\nbool ok(int h, int m, const fraction &fs) {\n\tconst double theta_s = fs.toDouble() / 60.0;\n\tconst double theta_m = (m + theta_s) / 60.0;\n\tconst double theta_h = (h + theta_m) / H;\n\treturn equal(get_angle(theta_s, theta_m), get_angle(theta_s, theta_h))\n\t\t&& !equal(theta_m, theta_h) && strict_ok(h, m, fs);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, m, s; cin >> H >> h >> m >> s && H;) {\n\t\tconst fraction d(1, 119 * H - 1);\n\t\tfor(fraction fs(s, 1);; normalize(h, m, (fs += d))) {\n\t\t\tif(ok(h, m, fs)) {\n\t\t\t\tcout << h << \" \" << m << \" \" << fs.nume << \" \" << fs.deno << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct frac{\n  int num,dom;\n  frac(){}\n  frac(int num,int dom):num(num),dom(dom){}\n  frac norm(){\n    if(num==0) return frac(0,1);\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac norm2(){\n    if(num==0) return frac(0,1);\n    while(num<0) num+=dom;\n    while(num>=dom) num-=dom;\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac operator+(frac a){return frac(num*a.dom+a.num*dom,dom*a.dom).norm();}\n  frac operator-(frac a){return frac(num*a.dom-a.num*dom,dom*a.dom).norm();}\n  frac operator*(frac a){return frac(num*a.num,dom*a.dom).norm();}\n  frac operator*(int k){return frac(num*k,dom).norm();}\n  frac operator/(frac a){return frac(num*a.dom,dom*a.num).norm();}\n  bool operator<(const frac a)const{\n    return num*a.dom<a.num*dom;\n  }\n  bool operator>(const frac a)const{\n    return num*a.dom>a.num*dom;\n  }\n  bool operator==(const frac a)const{\n    return num*a.dom==a.num*dom;\n  }\n  bool operator!=(const frac a)const{\n    return num*a.dom!=a.num*dom;\n  }\n  bool operator<=(const frac a)const{\n    return num*a.dom<=a.num*dom;\n  }\n  bool operator>=(const frac a)const{\n    return num*a.dom>=a.num*dom;\n  }\n};\n\nint H,h,m,s;\nvoid print(frac f){\n  //cout<<f.num<<\":\"<<f.dom<<endl;\n  \n  int t=f.num/(f.dom*60);\n  \n  cout<<(t%(60*H))/60<<\" \";\n  cout<<(t%60)<<\" \";\n  cout<<(f.num)%(f.dom*60)<<\" \"<<f.dom<<endl;\n}\nsigned main(){\n  while(cin>>H>>h>>m>>s,H){\n    frac t(h*3600+m*60+s,1);\n    frac x,y,z;\n    frac vh(1,3600*H),vm(1,3600),vs(1,60);\n    while(1){\n      x=(t*vh).norm2();\n      y=(t*vm).norm2();\n      z=(t*vs).norm2();\n      if(y<x) y=y+frac(1,1);\n      if(z<x) z=z+frac(1,1);\n      frac ans(10000000,1),t1,t2;\n      if(1){\n\tt1=frac(1,1)-(z-x);\n\tt2=z-y;\n\tif(t1>=t2){\n\t  frac tmp=t+(t1-t2)/(vs*2-(vh+vm));\n\t  if(t<=tmp){\n\t    frac a,b,c;\n\t    a=(tmp*vh).norm2();\n\t    b=(tmp*vm).norm2();\n\t    c=(tmp*vs).norm2();\n\t    if(b<a) b=b+frac(1,1);\n\t    if(c<a) c=c+frac(1,1);\n\t    if(b<c){\n\t      t1=frac(1,1)-(c-a);\n\t      t2=c-b;\n\t      if(a!=b&&b!=c&&c!=a&&t1==t2)\n\t\tans=min(ans,tmp);\n\t    }\n\t  }\n\t}\n      }\n      if(1){\n\tt1=z-x;\n\tt2=y-z;\n\tif(t1<=t2){\n\t  frac tmp=t+(t2-t1)/(vs*2-(vh+vm));\n\t  if(t<=tmp){\n\t    frac a,b,c;\n\t    a=(tmp*vh).norm2();\n\t    b=(tmp*vm).norm2();\n\t    c=(tmp*vs).norm2();\n\t    if(b<a) b=b+frac(1,1);\n\t    if(c<a) c=c+frac(1,1);\n\t    if(b>c){\n\t      t1=c-a;\n\t      t2=b-c;\n\t      if(a!=b&&b!=c&&c!=a&&t1==t2)\n\t\tans=min(ans,tmp);\n\t    }\n\t  }\n\t}\n      }\n      //assert(ans!=frac(10000000,1));\n      if(ans!=frac(10000000,1)){\n\tprint(ans);\n\tbreak;\n      }\n      t=t+frac(1,1);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nlong long gcd(long long x, long long y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nlong long a, b, c, d;\nint main() {\n\twhile (cin >> a >> b >> c >> d, a) {\n\t\tlong long r = 119 * a - 1;\n\t\tfor (int i = 0; ; i++) {\n\t\t\tlong long cp = (d * r + i) * 60 * a, cq = 3600 * a * r;\n\t\t\tlong long bp = (c * 60 * r + cp / (60 * a)) * a, bq = 3600 * a * r;\n\t\t\tlong long ap = b * 3600 * r + bp / a, aq = 3600 * a * r;\n\t\t\tap %= aq; bp %= bq; cp %= cq;\n\t\t\twhile (cp < ap) cp += cq;\n\t\t\twhile (bp < cp) bp += bq;\n\t\t\tif (ap == bp) continue;\n\t\t\tif (cp - ap == bp - cp) {\n\t\t\t\tlong long cr = d * r + i, br = c, ar = b;\n\t\t\t\tbr += cr / (60 * r); cr %= 60 * r;\n\t\t\t\tar += br / 60; br %= 60;\n\t\t\t\tar %= a;\n\t\t\t\tlong long f = gcd(cr, r);\n\t\t\t\tcr /= f; r /= f;\n\t\t\t\tcout << ar << ' ' << br << ' ' << cr << ' ' << r << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll H,h,m,s;\nstruct bun{\n  ll n,d;//n/d\n  bool operator<(const bun& b){\n    return n * b.d < b.n * d;\n  }\n  bool operator>(const bun& b){\n    return n * b.d > b.n * d;\n  }\n\n  bool operator==(const bun& b){\n    return n * b.d == b.n * d;\n  }\n  void yaku(){\n    if( n == 0 ) {\n      d = 1;\n      return;\n    }\n    if( n % d == 0 ){\n      n = n/d; d = 1;\n      return;\n    }\n    bool f = false;\n    do{\n      f = false;\n      for(ll i=2;i*i<=d;i++){\n\tif( d % i == 0 ){\n\t  if( n % i == 0 ){\n\t    n = n/i; d = d/i;\n\t    f = true;\n\t    break;\n\t  }\n\t}\n\tll t = d/i;\n\tif( d % t == 0 ){\n\t  if( n % t == 0 ){\n\t    n = n / t; d = d / i;\n\t    f = true; break;\t    \n\t  }\n\t}\n      }\n    } while( f );\n  }\n  void view(){\n    cout << n << \" / \" << d << endl;\n  }\n};\nint main(){\n  \n  while( cin >> H >> h >> m >> s && (H||h||m||s) ){\n\n    bun s1 = (bun){ (60 * h + m - m * H) * (120 * H * 60 ),\n\t\t    120 * H * ( 121 * H - 1) };\n    bun s2 = (bun){ (-60 * h - m + m * H ) * (120 * H * 60 ),\n\t\t    120 * H * ( 119 * H - 1) };\n\n    bun res = (bun){120,1};\n    if( (bun){0,1} < s1 ) \n      if( (bun){s,1} < s1 ) res = s1;    \n    if( (bun){0,1} < s2 )\n      if( (bun){s,1} < s2 )\n\tif( res > s2 ) res = s2;\n\n    s1.view(); s2.view();\n    res.yaku();\n\n    if( res == (bun){120,1} ){\n\n      m++;\n      if( m == 60 ) {\n\tm = 0;\n\th++;\n\tif( h == H ) h = 0;\n      }\n      s1 = (bun){ (60 * h + m - m * H) * (120 * H * 60 ),\n\t\t    120 * H * ( 121 * H - 1) };\n      s2 = (bun){ (-60 * h - m + m * H ) * (120 * H * 60 ),\n\t\t    120 * H * ( 119 * H - 1) };\n\n      res = (bun){120,1};\n      if( (bun){0,1} < s1 ) \n\tres = s1;    \n      if( (bun){0,1} < s2 )\n\tif( res > s2 )\n\t  res = s2;\n      res.yaku();\n      cout << \"next min\" << endl;\n      s1.view(); s2.view();\n      cout << h << \" \" << m << \" \"<< res.n << \" \"<< res.d << endl;\n    } else\n      cout << h << \" \" << m << \" \"<< res.n << \" \"<< res.d << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\n\nll H, h, m, n, d;\n// s=n/d\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  ll tt = 60*60*H*d;\n  ll srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  ll mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  ll hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  ll tt = 60*60*H*d;\n  ll srad = 60*H*n;\n  ll mrad = 60*H*m*d+H*n;\n  ll hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  ll s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    ll prem = m, preh = h;\n    ll ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (ll i = 0; i < (H-1)*60; i++) {\n      \tn = i;\n      \tif (prem == m && d*s > n) continue;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = n; ansd = d;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (ll i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tif (ansn == 0) {\n\t  ansd = 1;\n\t}else {\n\t  ll t = gcd(ansn, ansd);\n\t  ansn /= t; ansd /= t;\n\t}\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nll H,h0,m0,s0;\nint main(){\n  while( cin >> H >> h0 >> m0 >> s0 && (H||h0||m0||s0) ){\n    ll d = 119*H - 1, n = s0 * d;\n    //    cout << d << endl;\n    while(1){\n      ll h = 3600 * h0 * d + 60 * m0 * d + n;\n      ll m = 60 * H * d * m0 + n * H;\n      ll s = 60*H*n;\n      ll one = 3600 * H * d;\n      if( h == m && m == s ) {}\n      else {\n        ll x1 = (h+m)/2;\n        ll x2 = (h+m+one)/2;\n        if( x2 >= one ) x2 -= one;\n        //if( n == 0 )        cout <<h << \" \"<< m << \" \"<< s << \" \" << x1 << \" \"<< x2 << endl;\n        \n        if( x1 == s || x2 == s ){\n          ll gcd = __gcd(n,d);\n          cout << h0 << \" \" << m0 << \" \" << n/gcd << \" \"<< d/gcd <<endl;\n          break;\n        }\n      }\n      n++;\n      //      cout << n << \" \" << d*60 << endl;\n      if( n == d*60 ){ n = 0; m0++; }\n      if( m0 == 60 ){ m0=0; h0++; }\n      if( h0 == H ) { h0 = 0; }\n    }\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pl = pair<ll,ll>;\n\nstruct TIME{\n    ll h,m;\n    pl s;\n};\n\nvoid PRINT_T(TIME t){\n    printf(\"%lld %lld %lld %lld\\n\", t.h, t.m, t.s.fi, t.s.se);\n}\n\nconst ll INF = 60*60*100*10;\n\nbool big(pl a, pl b){\n    return a.fi*b.se < b.fi*a.se;\n}\n\npl norm(pl a){\n    ll G = __gcd(a.fi, a.se);\n    a.fi /= G;\n    a.se /= G;\n    return a;\n}\n\nint H,x,y,z;\n\n// a から b\npl sub(TIME a, TIME b){\n    pl p = a.s;\n    p.fi += p.se*60*(60*a.h+a.m);\n\n    pl q = b.s;\n    q.fi += q.se*60*(60*b.h+b.m);\n\n    while(big(q,p)) q.fi += H*3600*q.se;\n    p = norm(p);\n    q = norm(q);\n\n    ll X = q.fi*p.se - p.fi*q.se;\n    ll Y = q.se*p.se;\n    pl res(X,Y);\n    res = norm(res);\n\n    // printf(\" DIFF:\\n\");\n    // PRINT_T(a);\n    // PRINT_T(b);\n    // dbg(res);\n    return res;\n}\n\nint main(){\n    while(cin >>H >>x >>y >>z,H){\n        ll T = 60*H;\n\n        TIME base = {x,y,{z,1}};\n\n        pl diff(INF,1);\n        TIME ans;\n\n        auto upd = [&](ll p, ll q, int i, int j){\n            ll t = 60*i+j;\n            if(p>=0 && p/q<60){\n                pl s = norm({p,q});\n                // printf(\" CAND %d %d %lld/%lld :\", i,j,s.fi,s.se);\n\n                pl th(60*t*s.se+s.fi, 60*T*s.se);\n                pl tm(60*j*s.se+s.fi, 3600*s.se);\n                pl ts(s.fi, s.se*60);\n                th = norm(th);\n                tm = norm(tm);\n                ts = norm(ts);\n\n                if( th!=tm && th!=ts && tm!=ts ){\n                    TIME tmp = {i,j,s};\n                    pl td = sub(base, tmp);\n                    if(big(td,diff)){\n                        diff = td;\n                        ans = tmp;\n                    }\n                    // printf(\"OK\");\n                }\n                // printf(\"\\n\");\n            }\n        };\n\n        rep(i,H)rep(j,60){\n            ll t = 60*i+j;\n\n            // 1つめ\n            ll p = 3600*t - 60*T*j;\n            ll q = T - 60;\n            upd(p,q,i,j);\n\n            // 2つめ\n            p = 3600*t + 60*T*j;\n            q = 119*T - 60;\n            upd(p,q,i,j);\n\n            // 3つめ\n            p = 3600*(T+t) + 60*T*j;\n            q = 119*T - 60;\n            upd(p,q,i,j);\n\n            // 4つめ\n            p = 3600*(t-T) + 60*T*j;\n            q = 119*T - 60;\n            upd(p,q,i,j);\n        }\n\n        PRINT_T(ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint H, ha, ma, sa;\n\nint gcd(int a, int b) {\n    if(a == 0) return b;\n    if(b == 0) return a;\n    if(a < b) swap(a, b);\n    if(a % b == 0) return b;\n    return gcd(b, a % b);\n}\n\nstruct Clock {\n    int h, m, n, d;\n    Clock(int _h, int _m, int _n, int _d) {\n        h = _h;\n        m = _m;\n        n = _n;\n        d = _d;\n        int g = gcd(n, d);\n        n /= g;\n        d /= g;\n    }\n};\n\nbool operator <(Clock a, Clock b) {\n    if(a.h != b.h) return a.h < b.h;\n    if(a.m != b.m) return a.m < b.m;\n    return a.n * b.d < b.n * a.d;\n}\n\nbool operator <=(Clock a, Clock b) {\n    if(a.h != b.h) return a.h < b.h;\n    if(a.m != b.m) return a.m < b.m;\n    return a.n * b.d <= b.n * a.d;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> H >> ha >> ma >> sa;\n        if(H == 0 && ha == 0 && ma == 0 && sa == 0) break;\n        Clock a(ha, ma, sa, 1);\n        Clock ans(-1, -1, 0, 1);\n        for(int h = 0; h < H; h++) {\n            for(int m = 0; m < 60; m++) {\n                for(int delta = -1; delta <= 1; delta++) {\n                    int Left = delta * 3600 * H + 60 * 60 * h + 60 * m * (H + 1);\n                    if(Left < 0) continue;\n                    if(Left >= 60 * (H * 120 - H - 1)) continue;\n                    Clock now(h, m, Left, H * 120 - H - 1);\n                    if(60 * now.m * now.d == 59 * now.n) continue;\n                    if(ans.h == -1) {\n                        ans = now;\n                    } else if(ans < a && a <= now) {\n                        ans = now;\n                    } else if(a <= now && now < ans) {\n                        ans = now;\n                    } else if(now <= ans && ans < a) {\n                        ans = now;\n                    }\n                }\n            }\n        }\n        cout << ans.h << \" \" << ans.m << \" \" << ans.n << \" \" << ans.d << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nll gcd(ll a, ll b)\n{\n\tassert(a > 0 && b > 0);\n\tif (a < b) swap(a, b);\n\treturn (a%b ? gcd(a%b, b) : b);\n}\n\nll lcm(ll a, ll b)\n{\n\treturn a / gcd(a, b)*b;\n}\n\nstruct Fraction\n{\n\tll s, d; // s/d\n\tFraction() :s(0), d(1) {};\n\tFraction(ll n) :s(n), d(1) {};\n\tFraction(ll s_, ll d_) :s(s_), d(d_) { reduct(); };\n\tvoid reduct()\n\t{\n\t\tif (s == 0)\n\t\t{\n\t\t\td = 1;\n\t\t\treturn;\n\t\t}\n\t\tint sig = 1;\n\t\tif (s < 0)\n\t\t{\n\t\t\tsig *= -1;\n\t\t}\n\t\tif (d < 0)\n\t\t{\n\t\t\tsig *= -1;\n\t\t\td *= -1;\n\t\t\ts *= -1;\n\t\t}\n\t\tll g;\n\t\tif (sig == -1) g = gcd(-s, d);\n\t\telse g = gcd(s, d);\n\t\ts /= g; d /= g;\n\t}\n\tFraction operator+(const Fraction& rhs)\n\t{\n\t\tld nd = lcm(d, rhs.d);\n\t\tld ns = nd / d * s + nd / rhs.d * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator-(const Fraction& rhs)\n\t{\n\t\tld nd = lcm(d, rhs.d);\n\t\tld ns = nd / d * s - nd / rhs.d * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator*(const Fraction& rhs)\n\t{\n\t\tld nd = d * rhs.d;\n\t\tld ns = s * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator/(const Fraction& rhs)\n\t{\n\t\tld nd = d * rhs.s;\n\t\tld ns = s * rhs.d;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tbool operator==(const Fraction& rhs)\n\t{\n\t\treturn (d == rhs.d) && (s == rhs.s);\n\t}\n\tbool operator<(const Fraction& rhs)\n\t{\n\t\treturn s * rhs.d < rhs.s * d;\n\t}\n};\n\nint H;\n\ntypedef tuple<int, int, Fraction> Time;\nFraction vs, vm, vh;\n\ntuple<Fraction, Fraction, Fraction> angle(Time time)\n{\n\tint h, m;\n\tFraction s;\n\ttie(h, m, s) = time;\n\tFraction ang_s(s * vs);\n\tFraction ang_m((Fraction(m*60) + s) * vm);\n\tFraction ang_h((Fraction(h * 3600 + m*60) + s) * vh);\n\treturn make_tuple(ang_s, ang_m, ang_h);\n}\n\nTime opt(Time now, Fraction add)\n{\n\tint h, m;\n\tFraction s;\n\ttie(h, m, s) = now;\n\ts = s + add;\n\tif (s.s >= 60 * s.d)\n\t{\n\t\ts = s - Fraction(60);\n\t\tm++;\n\t}\n\tif (m == 60)\n\t{\n\t\tm = 0;\n\t\th++;\n\t}\n\tif (h == H)\n\t{\n\t\th = 0;\n\t}\n\treturn Time(h, m, s);\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> H, H)\n\t{\n\t\tint h, m, s_;\n\t\tcin >> h >> m >> s_;\n\t\tFraction s(s_, 1);\n\t\tvs = Fraction(360, 60);\n\t\tvm = Fraction(360 , 3600);\n\t\tvh = Fraction(360, 3600 * H);\n\t\tFraction ang_s, ang_m, ang_h;\n\t\tTime start(h, m, s);\n\t\ttie(ang_s, ang_m, ang_h) = angle(start);\n\t\tFraction theta[2];\n\t\ttheta[0] = (ang_h + ang_m) / Fraction(2);\n\t\ttheta[1] = theta[0] < Fraction(180)  ? theta[0] + Fraction(180) : theta[0] - Fraction(180);\n\t\tvector<Fraction> add;\n\t\tREP(i, 2)\n\t\t{\n\t\t\tif (theta[i] == ang_s)\n\t\t\t{\n\t\t\t\tadd.push_back(Fraction(0));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (theta[i] < ang_s) theta[i] = theta[i] + Fraction(360);\n\t\t\tFraction t = (Fraction(2) * (theta[i] - ang_s)) / (Fraction(2) * vs - vm - vh);\n\t\t\tadd.push_back(t);\n\t\t}\n\t\tsort(ALL(add));\n\t\tfor (auto t : add)\n\t\t{\n\t\t\tTime time = opt(start, t);\n\t\t\tFraction as, am, ah;\n\t\t\ttie(as, am, ah) = angle(time);\n\t\t\tif (as == am || am == ah || ah == as) continue;\n\t\t\tcout << get<0>(time) << \" \" << get<1>(time) << \" \" << get<2>(time).s << \" \" << get<2>(time).d << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint H, h, m, s;\n\nint main () {\n\twhile (scanf (\"%d%d%d%d\", &H, &h, &m, &s) == 4) {\n\t\tif (H == 0 && h == 0 && m == 0 && s == 0) break;\n\t\twhile (true) {\n\t\t\tint p = 60 * (m * H - 60 * H + 60 * h + m), q = 119 * H - 1;\n\t\t\tif (p >= 0 && p >= s * q && p < 60 * q && 60 * m * q != 59 * p) {\n\t\t\t\tint tmp = std::__gcd (p, q);\n\t\t\t\tp /= tmp;\n\t\t\t\tq /= tmp;\n\t\t\t\tprintf (\"%d %d %d %d\\n\", h, m, p, q);\n\t\t\t\tgoto nextCase;\n\t\t\t}\n\t\t\tp = 60 * (m * H + 60 * h + m), q = 119 * H - 1;\n\t\t\tif (p >= s * q && p < 60 * q && 60 * m * q != 59 * p) {\n\t\t\t\tint tmp = std::__gcd (p, q);\n\t\t\t\tp /= tmp;\n\t\t\t\tq /= tmp;\n\t\t\t\tprintf (\"%d %d %d %d\\n\", h, m, p, q);\n\t\t\t\tgoto nextCase;\n\t\t\t}\n\t\t\tp = 60 * (m * H + 60 * H + 60 * h + m), q = 119 * H - 1;\n\t\t\tif (p >= 0 && p >= s * q && p < 60 * q && 60 * m * q != 59 * p) {\n\t\t\t\tint tmp = std::__gcd (p, q);\n\t\t\t\tp /= tmp;\n\t\t\t\tq /= tmp;\n\t\t\t\tprintf (\"%d %d %d %d\\n\", h, m, p, q);\n\t\t\t\tgoto nextCase;\n\t\t\t}\n\t\t\ts = 0;\n\t\t\t++m;\n\t\t\tif (m == 60) {\n\t\t\t\tm = 0;\n\t\t\t\th = (h + 1) % H;\n\t\t\t}\n\t\t}\nnextCase:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\n\nll gcd(ll a, ll b) {\n\ta = abs(a), b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\nLP plu(LP a, LP b) {\n\tll d = a.second*b.second;\n\tll r = a.first*b.second + a.second*b.first;\n\tll g = gcd(d, r);\n\td /= g; r /= g;\n\treturn { r,d };\n}\nLP minu(LP a, LP b) {\n\tll d = a.second*b.second;\n\tll r = a.first*b.second - a.second*b.first;\n\tll g = gcd(d, r);\n\td /= g; r /= g;\n\treturn { r,d };\n}\nLP normal(ll a, ll b) {\n\tll g = gcd(a, b);\n\ta /= g; b /= g;\n\treturn { a,b };\n}\nbool great(LP a, LP b) {\n\treturn a.first*b.second >= a.second*b.first;\n}\nLP cc = { 360,1 };\nLP zz = { 60,1 };\nint n, h, m, s;\nvoid solve() {\n\tint b = 119 * n - 1;\n\tint cur = 0;\n\tLP ma = { mod,1 };\n\tfor (int k = -2; k <= 2; k++) {\n\t\tLP r = normal(-12 * s, 1);\n\t\tr = plu(r, normal(6 * m, 1));\n\t\tr = plu(r, normal(s, 10));\n\t\tr = plu(r, normal(360 * h, n));\n\t\tr = plu(r, normal(6 * m, n));\n\t\tr = plu(r, normal(s, 10 * n));\n\t\tr = plu(r, normal(360 * k, 1));\n\t\tr.first *= 10 * n;\n\t\tr.second *= 119 * n - 1;\n\t\tr = normal(r.first, r.second);\n\t\tif (r.first < 0)continue;\n\t\tLP cm = normal(6 * m, 1);\n\t\tcm = plu(cm, normal(s, 10));\n\t\tcm = plu(cm, normal(r.first, r.second * 10));\n\t\twhile (great(cm, cc))cm = minu(cm, cc);\n\t\tLP ch = normal(360 * h, n);\n\t\tch = plu(ch, normal(6 * m, n));\n\t\tch = plu(ch, normal(s, 10 * n));\n\t\tch = plu(ch, normal(r.first, r.second * 10 * n));\n\t\twhile (great(ch, cc))ch = minu(ch, cc);\n\t\tif (ch == cm)continue;\n\t\tif (great(ma, r)) {\n\t\t\t//cout << k << endl;\n\t\t\t//cout << r.first << \" \" << r.second << endl;\n\t\t\tma = r;\n\t\t}\n\t}\n\tll d = b / ma.second;\n\tcur = ma.first*d;\n\n\tint ns = s + cur / b;\n\tLP xs = normal(s*b + cur,b);\n\twhile (great(xs, zz))xs = minu(xs, zz);\n\tint nm = m + ns / 60;\n\tint nh = h + nm / 60;\n\tnm %= 60;\n\tnh %= n;\n\tcout << nh << \" \" << nm << \" \" << xs.first << \" \" << xs.second << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\twhile (cin >> n>>h>>m>>s,n)solve();\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,h,m,s;\n\nstruct data{\n  int h,m,n,d;\n  bool operator < (const data &p)const{\n    if(h!=p.h)return h<p.h;\n    if(m!=p.m)return m<p.m;\n    return (double)n/(double)d < (double)p.n/(double)p.d;\n  }\n};\n\nint main(){\n  while(1){\n    cin>>H>>h>>m>>s;\n    if(H==0&&h==0&&m==0&&s==0)break;\n\n    vector<data> t;\n    \n    int I=h,J=m,cnt=0;\n    while(1){\n      cnt++;\n      int i=I,j=J;\n      int a=(60*i+j+H*j+60*H)*60;\n      int b=120*H-1-H;\n      int ab=__gcd(a,b);\n      a/=ab,b/=ab;\n      if(a==0)b=1;\n      \n      int c=(60*i+j+H*j)*60;\n      int d=120*H-1-H;\n      int cd=__gcd(c,d);\n      c/=cd,d/=cd;\n      if(c==0)d=1;\n\n\n      if(a>=b*60){\n        j++;\n        if(j==60)j=0,i++;\n        if(i==H)i=0;\n        a%=(b*60);\n      }\n      if(a<60*b &&a*(H-1)!=(3600*i+60*j-60*j*H)*b ){\n        t.push_back( (data){i,j,a,b});\n      }\n      i=I,j=J;\n      if(c<60*d && c*(H-1)!=(3600*i+60*j-60*j*H)*d ){\n        t.push_back( (data){i,j,c,d});\n      }\n\n      J++;\n      if(J==60)J=0,I++;\n      if(I==H)I=0;\n      if(I==h&&J==m)break;\n    }\n    sort(t.begin(),t.end());\n    int k=lower_bound(t.begin(),t.end(),(data){h,m,s,1})-t.begin();\n    data ans;\n    if(k<(int)t.size())ans=t[k];\n    else ans=t[0];\n    cout<<ans.h<<' '<<ans.m<<' '<<ans.n<<' '<<ans.d<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int __int128\nstruct frac{\n  int num,dom;\n  frac(){}\n  frac(int num,int dom):num(num),dom(dom){}\n  frac norm(){\n    if(num==0) return frac(0,1);\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac norm2(){\n    if(num==0) return frac(0,1);\n    while(num<0) num+=dom;\n    while(num>=dom) num-=dom;\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac operator+(frac a){return frac(num*a.dom+a.num*dom,dom*a.dom);}\n  frac operator-(frac a){return frac(num*a.dom-a.num*dom,dom*a.dom);}\n  frac operator*(frac a){return frac(num*a.num,dom*a.dom);}\n  frac operator/(frac a){return frac(num*a.dom,dom*a.num);}\n  bool operator<(const frac a)const{\n    return num*a.dom<a.num*dom;\n  }\n  bool operator>(const frac a)const{\n    return num*a.dom>a.num*dom;\n  }\n  bool operator==(const frac a)const{\n    return num*a.dom==a.num*dom;\n  }\n  bool operator!=(const frac a)const{\n    return num*a.dom!=a.num*dom;\n  }\n  bool operator<=(const frac a)const{\n    return num*a.dom<=a.num*dom;\n  }\n  bool operator>=(const frac a)const{\n    return num*a.dom>=a.num*dom;\n  }\n};\n\nistream& operator>>(istream& is,int& x){\n  long long tmp;\n  is>>tmp;\n  x=tmp;\n  return is;\n}\nostream& operator<<(ostream& os,int x){\n  long long tmp=x;\n  os<<tmp;\n  return os;\n}\n\nostream& operator<<(ostream& os,frac x){\n  os<<x.num<<\" \"<<x.dom;\n  return os;\n}\n\nint H,h,m,s;\nvoid print(frac f){\n  //cout<<f.num<<\":\"<<f.dom<<endl;\n  \n  int t=f.num/(f.dom*60);\n  \n  cout<<(t%(60*H))/60<<\" \";\n  cout<<(t%60)<<\" \";\n  cout<<(f.num)%(f.dom*60)<<\" \"<<f.dom<<endl;\n}\nint MAX=1500;\nsigned main(){\n  vector<frac> v;\n  v.push_back(frac(0,1));\n  for(int i=1;i<MAX;i++){\n    for(int j=1;j<i;j++){\n      if(__gcd(i,j)!=1) continue;\n      v.push_back(frac(j,i));\n    }\n  }\n  //cout<<v.size()<<endl;\n  sort(v.begin(),v.end());\n  \n  while(cin>>H>>h>>m>>s,H){\n    frac t(h*3600+m*60+s,1);\n    frac x,y,z;\n    bool flg=0;\n    //int cnt=0;\n    //t=t+frac(30,1);\n    //cnt=30;\n    while(1){\n      if(1){\n\tx=(t*frac(1,3600*H)).norm2();\n\ty=(t*frac(1,3600)).norm2();\n\tz=(t*frac(1,60)).norm2();\n\tif(y<x) y=y+frac(1,1);\n\tif(z<x) z=z+frac(1,1);\n\tif(y<z){\n\t  frac k=((y-x).norm()+((z-y).norm()*frac(2,1)).norm());\n\t  if(k==frac(1,1)){\n\t    print(t);\n\t    flg=1;\n\t  }\n\t}\n\tif(y>z){\n\t  if((z-x)*frac(2,1)==(y-x)){\n\t    print(t);\n\t    flg=1;\n\t  }\n\t}\n\tif(flg) break;\n\t\n\tx=(t*frac(1,3600*H)).norm2();\n\ty=(t*frac(1,3600)).norm2();\n\tfrac p=t+frac(1,1),a,b;\n\ta=(p*frac(1,3600*H)).norm2();\n\tb=(p*frac(1,3600)).norm2();\n\t\n\tif((x<y&&a<b)||(x>y&&a>b)){\n\t  int l=0,r=v.size()+1;\n\t  //cout<<l<<\" \"<<r<<endl;\n\t  while(l+1<r){\n\t    int m=(l+r)/2;\n\t    //cout<<\"v[m] \"<<v[m]<<endl;\n\t    //cout<<\"x \"<<((t+v[m]).norm()*frac(1,3600*H))<<endl;\n\t    //cout<<\"y \"<<((t+v[m]).norm()*frac(1,3600))<<endl;\n\t    //cout<<\"z \"<<((t+v[m]).norm()*frac(1,60))<<endl;\n\t    x=((t+v[m]).norm()*frac(1,3600*H)).norm2();\n\t    y=((t+v[m]).norm()*frac(1,3600)).norm2();\n\t    z=((t+v[m]).norm()*frac(1,60)).norm2();\n\t    if(y<x) y=y+frac(1,1);\n\t    if(z<x) z=z+frac(1,1);\n\t    if(z<=y){\n\t      l=m;\n\t      continue;\n\t    }\n\t    frac k=((y-x).norm()+((z-y).norm()*frac(2,1)).norm());\n\t    //cout<<m<<\":\"<<(k<frac(1,1))<<endl;\n\t    //cout<<k.num<<\" \"<<k.dom<<endl;\n\t    if(k<frac(1,1)) l=m;\n\t    else r=m;\n\t  }\n\t  if(r!=(int)v.size()+1){\n\t    //cout<<r<<endl;\n\t    //cout<<v[r].num<<\" \"<<v[r].dom<<endl;\n\t    x=((t+v[r]).norm()*frac(1,3600*H)).norm2();\n\t    y=((t+v[r]).norm()*frac(1,3600)).norm2();\n\t    z=((t+v[r]).norm()*frac(1,60)).norm2();\n\t    if(y<x) y=y+frac(1,1);\n\t    if(z<x) z=z+frac(1,1);\n\t    frac k=((y-x).norm()+((z-y).norm()*frac(2,1)).norm());\n\t    //cout<<k.num<<\" \"<<k.dom<<endl;\n\t    if(x!=y&&y!=z&&z!=x&&k==frac(1,1)){\n\t      print(t+v[r]);\n\t      flg=1;\n\t    }\n\t  }\n\n\t  \n\t  l=0,r=v.size()+1;\n\t  while(l+1<r){\n\t    int m=(l+r)/2;\n\t    x=((t+v[m]).norm()*frac(1,3600*H)).norm2();\n\t    y=((t+v[m]).norm()*frac(1,3600)).norm2();\n\t    z=((t+v[m]).norm()*frac(1,60)).norm2();\n\t    if(y<x) y=y+frac(1,1);\n\t    if(z<x) z=z+frac(1,1);\n\t    if(y<=z){\n\t      r=m;\n\t      continue;\n\t    }\n\t    if(((z-x)*frac(2,1)).norm()<=(y-x).norm()) l=m;\n\t    else r=m;\n\t  }\n\t  if(l!=0){\n\t    x=((t+v[l]).norm()*frac(1,3600*H)).norm2();\n\t    y=((t+v[l]).norm()*frac(1,3600)).norm2();\n\t    z=((t+v[l]).norm()*frac(1,60)).norm2();\n\t    if(y<x) y=y+frac(1,1);\n\t    if(z<x) z=z+frac(1,1);\n\t    if(x!=y&&y!=z&&z!=x&&((z-x)*frac(2,1)).norm()==(y-x).norm()){\n\t      print(t+v[l]);\n\t      flg=1;\n\t    }\n\t  }\n\t  \n\t  if(flg) break;\n\t  t=t+frac(1,1);\n\t  //cout<<++cnt<<endl;\n\t  continue;\n\t}\n\tt=t+frac(1,1);\n      }\n      /*\n      for(int i=0;i<(int)v.size();i++){\n\tx=((t+v[i]).norm()*frac(1,3600*H)).norm2();\n\ty=((t+v[i]).norm()*frac(1,3600)).norm2();\n\tz=((t+v[i]).norm()*frac(1,60)).norm2();\n\t//x<=y,x<=z\n\tif(y<x) y=y+frac(1,1);\n\tif(z<x) z=z+frac(1,1);\n\t\n\tif(x==y||y==z||z==x) continue;\n\tif(y<z){\n\t  frac k=((y-x).norm()+((z-y).norm()*frac(2,1)).norm());\n\t  if(k==frac(1,1)){\n\t    print(t+v[i]);\n\t    flg=1;\n\t  }\n\t}\n\tif(y>z){\n\t  if(((z-x)*frac(2,1)).norm()==(y-x).norm()){\n\t    print(t+v[i]);\n\t    flg=1;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) break;\n      \n\n      t=t+frac(1,1);\n      //cout<<++cnt<<endl;\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\n\nvi v[110];\nvector<P> res[110];\n\n\n\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  FOR(H,2,101){\n    int bunshi=3600*H;\n    int bunbo=120*H-(H+1);\n    int g=__gcd(bunshi,bunbo);\n    bunshi/=g;\n    bunbo/=g;\n    int ori_bunshi=bunshi;\n    while(bunshi<3600*H*bunbo){\n      v[H].PB(bunshi/bunbo);\n      res[H].PB(P(bunshi,bunbo));\n      bunshi+=ori_bunshi;\n    }\n  }\n\n  int H,h,m,s;\n  while(true){\n    cin>>H>>h>>m>>s;\n    if(H==0) break;\n    int t=3600*h+60*m+s;\n    int i=-1;\n    auto it = lower_bound(all(v[H]),t);\n    if(it==v[H].end()) i=0;\n    else i=it-v[H].begin();\n\n    P ans=res[H][i];\n    int hour=(ans.F/ans.S)/3600;\n    int minits=((ans.F/ans.S)/60)%60;\n    int second=((ans.F/ans.S)%60)*ans.S+ans.F%ans.S;\n    int bunbo=ans.S;\n    cout<<hour<<' '<<minits<<' ';\n    \n    cout<<second/__gcd(second,bunbo)<<' '<<bunbo/__gcd(second,bunbo)<<endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll H,h,m,s,d;\nbool check(void){\n  ll x = 60*H*s, y = (60*m*d+s)*H, z = 3600*h*d + 60*m*d + s;\n  if(y==z)return false;\n  ll dify = y-x, difz = x-z;\n  if(dify<0)dify += 3600*H*d;\n  if(difz<0)difz += 3600*H*d;\n  return dify == difz;\n}\n\nll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\n\nint main(){\n  while(cin >> H >> h >> m >> s, H){\n    d = 119*H - 1; s *= d;\n\n    for(;;){\n      if(check()){\n\tll g = gcd(s,d);\n\tcout << h << \" \" << m << \" \" << s/g << \" \" << d/g << endl;\n\tbreak;\n      }\n      s++;\n      if(s/d==60)s = 0, m++;\n      if(m==60)m = 0, h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,h,m,s;\n\nint main(){\n  while(1){\n    cin>>H>>h>>m>>s;\n    if(H==0&&h==0&&m==0&&s==0)break;\n    int ans0=-1,ans1,ans2,ans3,tmp2,tmp3;\n    int I=h,J=m,cnt=0;\n    while(1){\n      cnt++;\n      int i=I,j=J;\n      int a=(60*i+j+H*j+60*H)*60;\n      int b=120*H-1-H;\n      int ab=__gcd(a,b);\n      if(a>b*60)a=(60*i+j+H*j-60*H)*60;\n      a/=ab,b/=ab;\n      if(a==0)b=1;\n      \n      int c=(60*i+j+H*j)*60;\n      int d=120*H-1-H;\n      int cd=__gcd(c,d);\n      c/=cd,d/=cd;\n      if(c==0)d=1;\n      \n      if(cnt>1&&i==h&&j==m){\n      }else{\n        if(a*d>c*b){\n          swap(a,c);swap(b,d);\n        }\n      }\n\n      if(ans0==-1&&a<b*60 && a*(H-1)!=(3600*i+60*j-60*j*H)*b ){\n        if(cnt>1 || !(i==h&&j==m&&a<s*b)){\n          ans0=i,ans1=j,ans2=a,ans3=b; \n        }\n      }\n      \n      if(ans0==-1&&c<d*60 && c*(H-1)!=(3600*i+60*j-60*j*H)*d ){\n        if(cnt>1 || !(i==h&&j==m&&c<s*d)){\n          ans0=i,ans1=j,ans2=c,ans3=d;\n        }\n      }\n      \n      if(ans0!=-1)break;\n      J++;\n      if(J==60){\n        J=0;\n        I++;\n        if(I==H)I=0;\n      }\n      if(I==h&&J==m&&cnt>1)break;\n    }\n\n    if(ans0==-1)ans0=h,ans1=m,ans2=tmp2,ans3=tmp3;\n    cout<<ans0<<' '<<ans1<<' '<<ans2<<' '<<ans3<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 60;\nconst int S = 60;\nint H, h, m, s;\n\n/*\n  (?§???????degree)\n  ?§?????§???? = 6s\n  ???????§???? = 1/10 * (60m + s)\n  ???????§???? = 1/(10H) * (3600h + 60m + s)\n\n  ???????§???? - ?§?????§???? == ?§?????§???? - ???????§???? ?????????\n  s = (3600h + (1+H)60m) / (119H - 1)\n  ?????£???????????????119H-1 ??\n\n  ?????°???????????????????????¢????????????????????§???????????§???????????????????????????????????£??¨?????????????????£???????°?????????????\n */\n\nbool is_same_deg(const int &sa, const int &sb){\n  //s??§??????sa????????§????????????sb??????????????????\n  int h_s = 3600*h*sb + 60*m*sb + sa - 60*H*sa; //?????°?????????????????????10*H??????????????????\n  int s_m = 60*H*sa - 60*H*m*sb - H*sa; //?????°?????????????????????10*H??????????????????\n  if(h_s < 0) h_s += 360 * 10*H*sb;\n  if(s_m < 0) s_m += 360 * 10*H*sb;\n  return h_s == s_m;\n}\n\nbool is_overlap(const int &sa, const int &sb){\n  int h_deg_mul10h = 3600*h*sb + 60*m*sb + sa;\n  int s_deg = 6*h*sb;\n  int m_deg_mul10 = 60*m*sb + sa;\n  return (s_deg*10*H == h_deg_mul10h || s_deg*10 == m_deg_mul10);\n}\n\nvoid solve(){\n  int sa, sb = 119 * H - 1;\n  sa = s * sb;\n  // 1 / (119H-1) ?§??????????????????¨??¢?´¢\n  for(int i=0;i<H*M*S*sb;i++){\n    if(is_same_deg(sa, sb) && !is_overlap(sa, sb)){\n      int g = __gcd(sa, sb);\n      cout << h << ' ' << m << ' ' << sa/g << ' ' << sb/g << endl;\n      return;\n    }\n    \n    // failed\n    sa++;\n    if(sa >= S * sb){\n      sa -= S * sb;\n      m++;\n      if(m >= M){\n        m -= M;\n        h++;\n        if(h >= H){\n          h = m = sa = 0;\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n  assert(false);\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s && (H|h|m|s)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,h,m,s,d;\nbool check(void){\n  int x = 60*H*s, y = (60*m*d+s)*H, z = 3600*h*d + 60*m*d + s;\n  if(y==z)return false;\n  int dify = y-x, difz = x-z;\n  if(dify<0)dify += 3600*H*d;\n  if(difz<0)difz += 3600*H*d;\n  return dify == difz;\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s, H){\n    d = 119*H - 1; s *= d;\n\n    for(;;){\n      if(check()){\n\tint gcd = __gcd(s,d);\n\tcout << h << \" \" << m << \" \" << s/gcd << \" \" << d/gcd << endl;\n\tbreak;\n      }\n      s++;\n      if(s/d==60)s = 0, m++;\n      if(m==60)m = 0, h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// by team2\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <math.h>\n#include <stack>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nint gcd(int a,int b) {\n\tfor(int t; b; t=a,a=b,b=t%a);\n\treturn a;\n}\n\nint Div, H, h, m, s;\n\nbool check(int A,int B) {\n\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\tint w1 = 1, w2 = H, w3 = H*60;\n\tLL X = (LL)t1 * B + (LL)w1 * A;\n\tLL Y = (LL)t2 * B + (LL)w2 * A;\n\tLL Z = (LL)t3 * B + (LL)w3 * A;\n\treturn (X != Y && Y != Z && Z != X);\n}\n\nint main() {\n\twhile(~scanf(\"%d%d%d%d\", &H, &h, &m, &s)) {\n\t\tif(!H&&!h&&!m&&!s) break;\n\t\tDiv = 3600 * H;\n\t\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\t\tint w1 = 1, w2 = H, w3 = H*60;\n\t\tint A = 2 * t3 - t1 - t2;\n\t\tint B = w1 + w2 - 2 * w3;\n\t\tif(B < 0) B = -B, A = -A;\n\t\tA = (A % Div + Div) % Div;\n\t\twhile(!check(A, B)) A += Div;\n\t\tint g = gcd(A, B); A/=g, B/=g;\n\t\t\n\t\tlong long T = A + h * (B*3600) + m * (B*60) + s*B;\n\t\tint _h = T / (B * 3600) % H;\n\t\tint _m = T % (B * 3600) / (B * 60);\n\t\tint _s = T % (B * 60);\n\t\tprintf(\"%d %d %d %d\\n\", _h, _m, _s, B);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n#include <cassert>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\nstruct FFF\n{\n    LL n,d;\n}f[10];\nbool cmp(FFF a,FFF b)\n{\n    return a.n*b.d<b.n*a.d;\n}\nbool equ(FFF a,FFF b)\n{\n    return a.n*b.d==b.n*a.d;\n}\nvoid norm(FFF &a)\n{\n    if(a.n<=0&&a.d<=0)\n    {\n        a.n*=-1;\n        a.d*=-1;\n    }\n    int g=__gcd(a.n,a.d);\n    a.n/=g;\n    a.d/=g;\n}\nbool check(FFF a)\n{\n    return a.n>=0&&a.d>0&&a.n<a.d*60;\n}\nint solve(LL H,LL h,LL m)\n{\n    int cnt=0;\n    FFF s,ns,nn;\n    ns.n=3600*h+60*m-60*m*H;\n    ns.d=H-1;\n    norm(ns);\n\n    s.d=119*H-1;\n    s.n=3600*h+60*m+60*m*H;\n    norm(s);\n  //  print(s);\n    if(check(s)&&!equ(ns,s))\n        f[cnt++]=s;\n\n    s.d=119*H-1;\n    s.n=3600*h+60*m+60*m*H-3600*H;\n    norm(s);\n  //  print(s);\n    if(check(s)&&!equ(ns,s)&&s.n<s.d*30)\n        f[cnt++]=s;\n\n    s.d=119*H-1;\n    s.n=3600*h+60*m+60*m*H+3600*H;\n    norm(s);\n  //  print(s);\n    if(check(s)&&!equ(ns,s)&&s.n>=s.d*30)\n        f[cnt++]=s;\n    sort(f,f+cnt,cmp);\n   // printf(\"#####\\n\");\n    return cnt;\n}\nvoid inc(LL &H,LL &h,LL &m)\n{\n    m++;\n    if(m>=60)\n    {\n        m%=60;\n        h++;\n        if(h>=H)\n        {\n            h%=H;\n        }\n    }\n}\nint main()\n{\n    LL H,h,m,s;\n   // freopen(\"input.txt\",\"r\",stdin);\n   //freopen(\"output.txt\",\"w\",stdout);\n    while(scanf(\"%lld%lld%lld%lld\",&H,&h,&m,&s)&&(H||h||m||s))\n    {\n        int cnt=solve(H,h,m);\n        FFF in;\n        in.n=s; in.d=1;\n        int flag=0;\n      //  printf(\"cnt = %d\\n\",cnt);\n        for(int i=0;i<cnt;i++)\n        {\n          //  print(f[i]);\n            if(!cmp(f[i],in))\n            {\n                flag=1;\n                printf(\"%lld %lld %lld %lld\\n\",h,m,f[i].n,f[i].d);\n                break;\n            }\n        }\n        while(!flag)\n        {\n            inc(H,h,m);\n            int cnt=solve(H,h,m);\n            if(cnt!=0)\n            {\n                printf(\"%lld %lld %lld %lld\\n\",h,m,f[0].n,f[0].d);\n                flag=1;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint gcd(int a, int b){\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n  int H, h, m, s, a;\n  while(cin >> H >> h >> m >> s, H | h | m | s) {\n    a = -1;\n    while(true) {\n      int d = 119 * H - 1;\n      int n = 60 * m * (H + 1) + 60 * 60 * (h + a * H);\n      // LOG(\"n :%d d:%d\\n\", n, d);\n      if(s * d <= n && n < 60 * d && n != m * d) {\n        int g = gcd(n, d);\n        // LOG(\"g %d\\n\", g);\n        n /= g;\n        d /= g;\n        printf(\"%d %d %d %d\\n\", h, m, n, d);\n        break;\n      }\n\n      a++;\n      if(a > 1) {\n        a = -1;\n        s = 0;\n        m++;\n        if(m >= 60) {\n          m = 0;\n          h++;\n          if(h >= H) {\n            h = 0;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli M = 60;\nconst lli S = 60;\nlli H, h, m, s;\n\n/*\n  (?§???????degree)\n  ?§?????§???? = 6s\n  ???????§???? = 1/10 * (60m + s)\n  ???????§???? = 1/(10H) * (3600h + 60m + s)\n\n  ???????§???? - ?§?????§???? == ?§?????§???? - ???????§???? ?????????\n  s = (3600h + (1+H)60m) / (119H - 1)\n  ?????£???????????????119H-1 ??\n\n  ?????°???????????????????????¢????????????????????§???????????§???????????????????????????????????£??¨?????????????????£???????°?????????????\n */\n\nbool is_same_deg(const lli &sa, const lli &sb){\n  // s??§??????sa????????§????????????sb??????????????????\n  // ?????°?????????????????????10*H??????????????????\n  lli h_s = 3600*h*sb + 60*m*sb + sa - 60*H*sa; \n  lli s_m = 60*H*sa - 60*H*m*sb - H*sa;\n\n  // ?§??????\\?????????????????????????§?????????????\n  for(lli i=0;i<=1;i++){\n    for(lli j=0;j<=1;j++){\n      if (h_s + 360*10*H*sb*i == s_m + 360*10*H*sb*j) return true;\n    }\n  }\n  return false;\n}\n\nbool is_overlap(const lli &sa, const lli &sb){\n  lli h_deg_mul10h = 3600*h*sb + 60*m*sb + sa;\n  lli s_deg = 6*sa;\n  lli m_deg_mul10 = 60*m*sb + sa;\n  return (s_deg*10*H == h_deg_mul10h || s_deg*10 == m_deg_mul10);\n}\n\nvoid solve(){\n  lli sa, sb = 119 * H - 1;\n  sa = s * sb;\n  // 1 / (119H-1) ?§??????????????????¨??¢?´¢\n  for(int i=0;i<=H*M*S*sb;i++){\n    if(is_same_deg(sa, sb) && !is_overlap(sa, sb)){\n      lli g = __gcd(sa, sb);\n      cout << h << ' ' << m << ' ' << sa/g << ' ' << sb/g << endl;\n      return;\n    }\n    \n    // failed\n    sa++;\n    if(sa >= S * sb){\n      sa -= S * sb;\n      m++;\n      if(m >= M){\n        m -= M;\n        h++;\n        if(h >= H){\n          h = m = sa = 0;\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s && (H|h|m|s)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 1000000+7;\n\nint main() {\n\n#ifdef HotWhite\n    freopen(\"in.txt\", \"r\", stdin);\n#endif // HotWhite\n    int H, h, m, s;\n    while (scanf(\"%d%d%d%d\", &H, &h, &m, &s), H || h || m || s) {\n        int hh = 3600*h + 60*m + s;\n        int mm = 60*m*H + s*H;\n        int ss = 60*s*H;\n        int K = 3600*H;\n        int fz = hh + mm - 2*ss;\n        fz = (fz%K + K)%K;\n        int fm = 119*H - 1;\n        while (1) {\n            int fzz = fz;\n            int fmm = fm;\n            int tem = __gcd(fzz, fmm);\n            fzz /= tem;\n            fmm /= tem;\n            int h2 = (h+(m+(fzz+s*fmm)/(60*fmm))/60) % H;\n            int m2 = (m+(fzz+s*fmm)/(60*fmm)) % 60;\n            int s2 = (fzz+s*fmm) % (fmm*60);\n            if ((h2*3600+m2*60)*fmm+s2 != 0) {\n                printf(\"%d %d %d %d\\n\", h2, m2, s2, fmm);\n                break;\n            }\n            fz += K;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Frac {\n    LL a, b;\n    Frac() : a(0), b(1) {}\n    Frac(LL _a, LL _b) : a(_a), b(_b) {\n        fix();\n    }\n    void fix() {\n        LL g = __gcd(abs(a), abs(b));\n        a /= g; b /= g;\n        if (b < 0) a = -a, b = -b;\n        assert(b > 0);\n    }\n    bool operator == (const Frac &rhs) const {\n        return a == rhs.a && b == rhs.b;\n    }\n    bool operator < (const Frac &rhs) const {\n        return a * rhs.b < b * rhs.a;\n    }\n    bool operator >= (const Frac &rhs) const {\n        return a * rhs.b >= b * rhs.a;\n    }\n    Frac operator + (const Frac &rhs) const {\n        return Frac(a * rhs.b + b * rhs.a, b * rhs.b);\n    }\n    Frac operator + (const int x) const {\n        return *this + Frac(x, 1);\n    }\n    Frac operator - (const Frac &rhs) const {\n        return Frac(a * rhs.b - b * rhs.a, b * rhs.b);\n    }\n    Frac operator - (const int x) const {\n        return *this - Frac(x, 1);\n    }\n    Frac operator * (const Frac &rhs) const {\n        return Frac(a * rhs.a, b * rhs.b);\n    }\n    Frac operator * (const int x) const {\n        return *this * Frac(x, 1);\n    }\n    Frac operator / (const Frac &rhs) const {\n        return Frac(a * rhs.b, b * rhs.a);\n    }\n    Frac operator / (const int x) const {\n        return *this / Frac(x, 1);\n    }\n    Frac operator % (const int M) const {\n        LL x = a / b;\n        return *this - x + (x % M);\n    }\n};\n\nint main() {\n    int H, h, m, s;\n    while (scanf(\"%d%d%d%d\", &H, &h, &m, &s) == 4 && H) {\n        LL S = h * 3600 + m * 60 + s;\n        Frac vHour(1, H * 10), vMin(1, 10), vSec(6, 1), vMid = (vHour + vMin) / 2;\n        Frac pMid = (vMid * S) % 360;\n        Frac pSec = (vSec * S) % 360;\n        Frac dis = min((pMid + 360 - pSec) % 360, (pMid + 540 - pSec) % 360);\n        Frac need = (dis / (vSec - vMid) + S) % (H * 3600);\n        if (vSec * need % 360 == vMin * need % 360 && vMin * need % 360 == vHour * need % 360) {\n            need = need + Frac(180, 1) / (vSec - vMid);\n        }\n        need = need % (H * 3600);\n        long long hour = 0, minu = 0;\n        while (need >= Frac(3600 ,1)) ++ hour, need = need - 3600;\n        while (need >= Frac(60, 1)) ++ minu, need = need - 60;\n        printf(\"%lld %lld %lld %lld\\n\", hour, minu, need.a, need.b);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,h,m,s;\n\nint main(){\n  while(1){\n    cin>>H>>h>>m>>s;\n    if(H==0&&h==0&&m==0&&s==0)break;\n    int ans0=-1,ans1,ans2,ans3,tmp2,tmp3;\n    int I=h,J=m,cnt=0;\n    while(1){\n      cnt++;\n      int i=I,j=J;\n      int a=(60*i+j+H*j+60*H)*60;\n      int b=120*H-1-H;\n      int ab=__gcd(a,b);\n      if(a>b*60)a=(60*i+j+H*j-60*H)*60;\n      a/=ab,b/=ab;\n      if(a==0)b=1;\n      \n      int c=(60*i+j+H*j)*60;\n      int d=120*H-1-H;\n      int cd=__gcd(c,d);\n      c/=cd,d/=cd;\n      if(c==0)d=1;\n      \n      if(cnt>1&&i==h&&j==m){\n        if(a*d<c*b){\n          swap(a,c);swap(b,d);\n        }\n      }else{\n        if(a*d>c*b){\n          swap(a,c);swap(b,d);\n        }\n      }\n\n      if(ans0==-1&&a<b*60 && a*(H-1)!=(3600*i+60*j-60*j*H)*b ){\n        if(cnt>1 || !(i==h&&j==m&&a<s*b)){\n          ans0=i,ans1=j,ans2=a,ans3=b; \n        }\n      }\n      \n      if(ans0==-1&&c<d*60 && c*(H-1)!=(3600*i+60*j-60*j*H)*d ){\n        if(cnt>1 || !(i==h&&j==m&&c<s*d)){\n          ans0=i,ans1=j,ans2=c,ans3=d;\n        }\n      }\n      \n      if(ans0!=-1)break;\n      J++;\n      if(J==60){\n        J=0;\n        I++;\n        if(I==H)I=0;\n      }\n      if(I==h&&J==m&&cnt>1)break;\n    }\n\n    if(ans0==-1)ans0=h,ans1=m,ans2=tmp2,ans3=tmp3;\n    cout<<ans0<<' '<<ans1<<' '<<ans2<<' '<<ans3<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\nll H, h, m, s, p;\n\nbool check() {\n\tll byou = 60 * H * s, hun = 60 * m * p * H + s * H, ji = 3600 * p * h + 60 * p * m + s;\n\tif (hun == ji) return false;\n\tll diff1 = hun - byou, diff2 = byou - ji;\n\tif (diff1 < 0) diff1 += 3600 * p * H;\n\tif (diff2 < 0) diff2 += 3600 * p * H;\n\treturn diff1 == diff2;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> H >> h >> m >> s , H) {\n\t\tp = 119 * H - 1;\n\t\ts *= p;\n\n\t\twhile (1) {\n\t\t\t//cout << h << \" \" << m << \" \" << s << endl;\n\t\t\tif (check()) {\n\t\t\t\tll g = gcd(s, p);\n\t\t\t\tcout << h << \" \" << m << \" \" << s / g << \" \" << p / g << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts++;\n\t\t\tif (s / p == 60) s = 0 , m++;\n\t\t\tif (m == 60) m = 0 , h++;\n\t\t\tif (h == H) h = 0 ;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a, ll b){\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll H, h, m, s;\n\nint main(){\n\twhile(cin >> H >> h >> m >> s, H || h || m || s){\n\t\tbool flg = true;\n\t\twhile(flg){\n\t\t\tll begin = h * 60 * 60 + m * 60 + s;\n\t\t\tll end = h * 60 * 60 + (m + 1) * 60;\n\t\t\t\n\t\t\tll nn = H * (120 * (h * 60 * 60 + m * 60) - h * 60 * 60);\n\t\t\tll dd = 119 * H - 1;\n\t\t\t//int nn = -120 * H * (h * 60 * 60 + m * 60) + H * (h * 60 * 60);\n\t\t\t//int dd = 1 - 119 * H;\n\t\t\tbool ff = false;\n\t\t\tll aann, aadd;\n\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\tll nnn = nn - i * H * 60 * 60;\n\t\t\t\tif(( H * 60  - 1) * nnn == H * 60 * (h * 60 * 60 + m * 60) * dd) continue;\n\t\t\t\tif((H - 1) * nnn == H * (h * 60 * 60) * dd) continue;\n\t\t\t\tif(begin * dd <= nnn && nnn < end * dd){\n\t\t\t\t\tif(!ff || (double)aann / aadd > (double) nnn / dd){\n\t\t\t\t\t\tff = true;\n\t\t\t\t\t\taann = nnn;\n\t\t\t\t\t\taadd = dd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ff){\n\t\t\t\tll am = aann / aadd / 60;\n\t\t\t\tll ah = am / 60;\n\t\t\t\taann -= am * aadd * 60;\n\t\t\t\tll g = gcd(aann, aadd);\n\t\t\t\tcout << ah << \" \" << am % 60 << \" \" << (aann / g)  << \" \" << aadd / g << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = 0;\n\t\t\tm += 1;\n\t\t\tif(m == 60){\n\t\t\t\th = (h + 1) % H;\n\t\t\t\tm = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nstring memo[110][110][2];\n\nstring rec(int o, int z, int num){\n  if (o == 0 && z == 0) return num == 1 ? \"\" : \"2\";\n  if (memo[o][z][num] != \"\") return memo[o][z][num];\n  string &res = memo[o][z][num] = \"2\";\n  if (num == 0 && z > 0 && rec(o, z - 1, 1) != \"2\"){\n    res = '0' + rec(o, z - 1, 1);\n  }\n  if (num == 1){\n    if (o > 0 && rec(o - 1, z, 0) != \"2\") res = min(res, '1' + rec(o - 1, z, 0));\n    if (o > 0 && rec(o - 1, z, 1) != \"2\") res = min(res, '1' + rec(o - 1, z, 1));\n    if (z > 0 && rec(o, z - 1, 0) != \"2\") res = min(res, '0' + rec(o, z - 1, 0));\n  }\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  vector<int> B, O, Z;\n  \n  REP(i, N) {\n    int num;\n    cin >> num;\n    if (num == 0){\n      Z.push_back(num);\n    } else if (num == 1){\n      O.push_back(num);\n    } else {\n      B.push_back(num);\n    }\n  }\n  \n  sort(ALL(B));\n  if (Z.size() % 2 != 0 && O.size() == 0 && B.size() != 0){\n    O.push_back(B[0]);\n    reverse(ALL(B));\n    B.pop_back();\n    sort(ALL(B));\n  }\n  if ((int)B.size() > 1 && B[0] == 2 && B[1] == 3) swap(B[0], B[1]);\n  \n  REP(i, B.size()) cout << B[i] << endl;\n  string str = rec(O.size(), Z.size(), 1);\n  \n  if (str == \"2\"){\n    reverse(ALL(O));\n    REP(i, Z.size()) cout << Z[i] << endl;\n    REP(i, O.size()) cout << O[i] << endl;\n  } else {\n    REP(i, str.size()) cout << (str[i] == '0' ? 0 : O[0]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct frac{\n  int num,dom;\n  frac(){}\n  frac(int num,int dom):num(num),dom(dom){}\n  frac norm(){\n    if(num==0) return frac(0,1);\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac norm2(){\n    if(num==0) return frac(0,1);\n    while(num<0) num+=dom;\n    while(num>=dom) num-=dom;\n    int tmp=__gcd(num,dom);\n    return frac(num/tmp,dom/tmp);\n  }\n  frac operator+(frac a){return frac(num*a.dom+a.num*dom,dom*a.dom).norm();}\n  frac operator-(frac a){return frac(num*a.dom-a.num*dom,dom*a.dom).norm();}\n  frac operator*(frac a){return frac(num*a.num,dom*a.dom).norm();}\n  frac operator*(int k){return frac(num*k,dom).norm();}\n  frac operator/(frac a){return frac(num*a.dom,dom*a.num).norm();}\n  bool operator<(const frac a)const{\n    return num*a.dom<a.num*dom;\n  }\n  bool operator>(const frac a)const{\n    return num*a.dom>a.num*dom;\n  }\n  bool operator==(const frac a)const{\n    return num*a.dom==a.num*dom;\n  }\n  bool operator!=(const frac a)const{\n    return num*a.dom!=a.num*dom;\n  }\n  bool operator<=(const frac a)const{\n    return num*a.dom<=a.num*dom;\n  }\n  bool operator>=(const frac a)const{\n    return num*a.dom>=a.num*dom;\n  }\n};\n\nint H,h,m,s;\nvoid print(frac f){\n  //cout<<f.num<<\":\"<<f.dom<<endl;\n  int t=f.num/(f.dom*60);\n  cout<<(t%(60*H))/60<<\" \";\n  cout<<(t%60)<<\" \";\n  cout<<(f.num)%(f.dom*60)<<\" \"<<f.dom<<endl;\n}\nsigned main(){\n  while(cin>>H>>h>>m>>s,H){\n    frac base(h*3600+m*60+s,1),t(max(h*3600+m*60+s-100,0LL),1);\n    frac x,y,z;\n    frac vh(1,3600*H),vm(1,3600),vs(1,60);\n    while(1){\n      x=(t*vh).norm2();\n      y=(t*vm).norm2();\n      z=(t*vs).norm2();\n      if(y<x) y=y+frac(1,1);\n      if(z<x) z=z+frac(1,1);\n      frac ans(10000000,1),t1,t2;\n      if(1){\n\tt1=frac(1,1)-(z-x);\n\tt2=z-y;\n\tif(1){\n\t  frac tmp=t+(t1-t2)/(vs*2-(vh+vm));\n\t  if(base<=tmp){\n\t    frac a,b,c;\n\t    a=(tmp*vh).norm2();\n\t    b=(tmp*vm).norm2();\n\t    c=(tmp*vs).norm2();\n\t    if(b<a) b=b+frac(1,1);\n\t    if(c<a) c=c+frac(1,1);\n\t    if(b<c){\n\t      t1=frac(1,1)-(c-a);\n\t      t2=c-b;\n\t      if(a!=b&&b!=c&&c!=a&&t1==t2)\n\t\tans=min(ans,tmp);\n\t    }\n\t  }\n\t}\n      }\n      if(1){\n\tt1=z-x;\n\tt2=y-z;\n\tif(1){\n\t  frac tmp=t+(t2-t1)/(vs*2-(vh+vm));\n\t  if(base<=tmp){\n\t    frac a,b,c;\n\t    a=(tmp*vh).norm2();\n\t    b=(tmp*vm).norm2();\n\t    c=(tmp*vs).norm2();\n\t    if(b<a) b=b+frac(1,1);\n\t    if(c<a) c=c+frac(1,1);\n\t    if(b>c){\n\t      t1=c-a;\n\t      t2=b-c;\n\t      if(a!=b&&b!=c&&c!=a&&t1==t2)\n\t\tans=min(ans,tmp);\n\t    }\n\t  }\n\t}\n      }\n      //assert(ans!=frac(10000000,1));\n      if(ans!=frac(10000000,1)){\n\tprint(ans);\n\tbreak;\n      }\n      t=t+frac(1,1);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint H, h, m, n, d;\n// s=n/d\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  int mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  int hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  int mrad = 60*H*m*d+H*n;\n  int hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  int s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    int prem = m, preh = h;\n    int ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (int i = 0; i < (H-1)*60; i++) {\n      \tif (prem == m && d*s > n) continue;\n      \tn = i;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = i; ansd = H-1;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (int i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tint t = gcd(n, d);\n\tansn /= t; ansd /= t;\n\tif (ansn == 0) ansd = 1;\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nll gcd(ll a, ll b)\n{\n\tassert(a > 0 && b > 0);\n\tif (a < b) swap(a, b);\n\treturn (a%b ? gcd(a%b, b) : b);\n}\n\nll lcm(ll a, ll b)\n{\n\treturn a / gcd(a, b)*b;\n}\n\nstruct Fraction\n{\n\tll s, d; // s/d\n\tFraction() :s(0), d(1) {};\n\tFraction(ll n) :s(n), d(1) {};\n\tFraction(ll s_, ll d_) :s(s_), d(d_) { reduct(); };\n\tvoid reduct()\n\t{\n\t\tif (s == 0)\n\t\t{\n\t\t\td = 1;\n\t\t\treturn;\n\t\t}\n\t\tint sig = 1;\n\t\tif (s < 0)\n\t\t{\n\t\t\tsig *= -1;\n\t\t}\n\t\tif (d < 0)\n\t\t{\n\t\t\tsig *= -1;\n\t\t\td *= -1;\n\t\t\ts *= -1;\n\t\t}\n\t\tll g;\n\t\tif (sig == -1) g = gcd(-s, d);\n\t\telse g = gcd(s, d);\n\t\ts /= g; d /= g;\n\t}\n\tFraction operator+(const Fraction& rhs)\n\t{\n\t\tld nd = lcm(d, rhs.d);\n\t\tld ns = nd / d * s + nd / rhs.d * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator-(const Fraction& rhs)\n\t{\n\t\tld nd = lcm(d, rhs.d);\n\t\tld ns = nd / d * s - nd / rhs.d * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator*(const Fraction& rhs)\n\t{\n\t\tld nd = d * rhs.d;\n\t\tld ns = s * rhs.s;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tFraction operator/(const Fraction& rhs)\n\t{\n\t\tld nd = d * rhs.s;\n\t\tld ns = s * rhs.d;\n\t\tFraction res(ns, nd);\n\t\tres.reduct();\n\t\treturn res;\n\t}\n\tbool operator==(const Fraction& rhs)\n\t{\n\t\treturn (d == rhs.d) && (s == rhs.s);\n\t}\n\tbool operator<(const Fraction& rhs)\n\t{\n\t\treturn s * rhs.d < rhs.s * d;\n\t}\n};\n\nint H;\n\ntypedef tuple<int, int, Fraction> Time;\nFraction vs, vm, vh;\n\ntuple<Fraction, Fraction, Fraction> angle(Time time)\n{\n\tint h, m;\n\tFraction s;\n\ttie(h, m, s) = time;\n\tFraction ang_s(s * vs);\n\tFraction ang_m((Fraction(m*60) + s) * vm);\n\tFraction ang_h((Fraction(h * 3600 + m*60) + s) * vh);\n\treturn make_tuple(ang_s, ang_m, ang_h);\n}\n\nTime opt(Time now, Fraction add)\n{\n\tint h, m;\n\tFraction s;\n\ttie(h, m, s) = now;\n\ts = s + add;\n\tif (s.s >= 60 * s.d)\n\t{\n\t\ts = s - Fraction(60);\n\t\tm++;\n\t}\n\tif (m == 60)\n\t{\n\t\tm = 0;\n\t\th++;\n\t}\n\tif (h == H)\n\t{\n\t\th = 0;\n\t}\n\treturn Time(h, m, s);\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> H, H)\n\t{\n\t\tint h, m, s_;\n\t\tcin >> h >> m >> s_;\n\t\tFraction s(s_, 1);\n\t\tvs = Fraction(360, 60);\n\t\tvm = Fraction(360 , 3600);\n\t\tvh = Fraction(360, 3600 * H);\n\t\tFraction ang_s, ang_m, ang_h;\n\t\tTime start(h, m, s);\n\t\ttie(ang_s, ang_m, ang_h) = angle(start);\n\t\tFraction theta[2];\n\t\ttheta[0] = (ang_h + ang_m) / Fraction(2);\n\t\ttheta[1] = theta[0] < Fraction(180)  ? theta[0] + Fraction(180) : theta[0] - Fraction(180);\n\t\tvector<Fraction> add;\n\t\tREP(i, 2)\n\t\t{\n\t\t\tif (theta[i] == ang_s) continue;\n\t\t\tif (theta[i] < ang_s) theta[i] = theta[i] + Fraction(360);\n\t\t\tFraction t = (Fraction(2) * (theta[i] - ang_s)) / (Fraction(2) * vs - vm - vh);\n\t\t\tadd.push_back(t);\n\t\t}\n\t\tsort(ALL(add));\n\t\tfor (auto t : add)\n\t\t{\n\t\t\tTime time = opt(start, t);\n\t\t\tFraction as, am, ah;\n\t\t\ttie(as, am, ah) = angle(time);\n\t\t\tif (as == am || am == ah || ah == as) continue;\n\t\t\tcout << get<0>(time) << \" \" << get<1>(time) << \" \" << get<2>(time).s << \" \" << get<2>(time).d << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nll t;\nll H,h0,m0,s0;\n\nint main(){\n  while(1){\n    cin>>H>>h0>>m0>>s0;\n    if(H==0)break;\n    ll d=119*H-1;\n    ll n=s0*d;\n    ll h=h0,m=m0;\n    ll mod=360*10*H*d;\n    while(1){\n      ll ang_h=(3600*h*d+60*m*d+n)%mod;\n      ll ang_m=(60*H*m*d+H*n)%mod;\n      ll ang_s=(60*H*n)%mod;\n      ang_h=(ang_h-ang_s+mod)%mod;\n      ang_m=(ang_m-ang_s+mod)%mod;\n      if(ang_m!=ang_h&&min(ang_m,ang_h)==mod-max(ang_m,ang_h))break;\n      n++;\n      if(n==60*d)n=0,m++;\n      if(m==60)m=0,h++;\n      if(h==H)h=0;\n    }\n    ll g=__gcd(n,d);\n    cout<<h<<\" \"<<m<<\" \"<<n/g<<\" \"<<d/g<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll calc(ll x,ll y){\n\n\tif(x < y)swap(x,y);\n\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn calc(y,x%y);\n\t}\n}\n\n\nint main(){\n\n\tint H,h,m,s;\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&H,&h,&m,&s);\n\t\tif(H == 0 && h == 0 && m == 0 && s == 0)break;\n\n\t\tll bunbo = 119*H-1;\n\t\tll bunshi = s*bunbo;\n\t\tll h0 = h;\n\t\tll m0 = m;\n\t\tll deg_h,deg_m,deg_s,diff_1,diff_2;\n\t\tll base;\n\n\t\twhile(true){\n\n\t\t\tbase = 3600*H*bunbo;\n\n\t\t\tdeg_h = (3600*h0*bunbo+60*m0*bunbo+bunshi)%base;\n\t\t\tdeg_m = (60*H*m0*bunbo+bunshi*H)%base;\n\t\t\tdeg_s = (60*H*bunshi)%base;\n\n\t\t\tif(deg_h != deg_m){\n\t\t\t\tdiff_1 = (deg_s-deg_h+base)%base;\n\t\t\t\tdiff_2 = (deg_m-deg_s+base)%base;\n\t\t\t\tif(diff_1 == diff_2)break;\n\t\t\t}\n\n\t\t\tbunshi++;\n\t\t\tif(bunshi/60 == bunbo) {\n\t\t\t\tbunshi = 0;\n\t\t\t\tm0++;\n\t\t\t}\n\t\t\tif(m0 == 60) {\n\t\t\t\tm0 = 0;\n\t\t\t\th0++;\n\t\t\t}\n\t\t\tif(h0 == H) {\n\t\t\t\th0 = 0;\n\t\t\t}\n\t\t}\n\t\tll common = calc(bunshi,bunbo);\n\t\tbunshi /= common;\n\t\tbunbo /= common;\n\n\t\tprintf(\"%lld %lld %lld %lld\\n\",h0,m0,bunshi,bunbo);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n#include <sstream>\n\nint64_t N, L;\nchar direc[100][10];\nint64_t posion[100];\nint64_t posionnow[201];\nint64_t H, h, m, s;\nstd::stringstream sssss;\n\nint64_t gcd(int64_t a, int64_t b)\n{\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n}\n\nvoid solve() {\n\n\tconst int64_t MULMUL = 20 * H * 360;\n\t//int64_t hdeg = 2 * h;\n\t//int64_t mdeg = 2 * H * m;\n\t//int64_t sdeg = 20 * H * 6 * s;\n\tint64_t hdeg = 20 * 360 * h + 2 * 60 * m + 2 * s;\n\tint64_t mdeg = 20 * H * 6 * m + 2 * H * s;\n\tint64_t sdeg = 20 * H * 6 * s;\n\n\tint64_t rotate_sum = 0;\n\twhile (true)\n\t{\n\n\t\tsdeg -= hdeg;\n\t\tif (sdeg < 0) {\n\t\t\tsdeg += MULMUL;\n\t\t}\n\t\tmdeg -= hdeg;\n\t\tif (mdeg < 0) {\n\t\t\tmdeg += MULMUL;\n\t\t}\n\t\trotate_sum += hdeg;\n\t\thdeg = 0;\n\n\t\tint64_t mid1 = mdeg / 2;\n\t\tint64_t mid2 = mid1 + MULMUL / 2;\n\t\tint64_t mid = mid1;\n\t\tint64_t midsend = mid2;\n\t\tif (mid1 < sdeg && sdeg <= mid2) {\n\t\t\tmid = mid2;\n\t\t\tmidsend = mid1;\n\t\t}\n\n\t\tif (mid < sdeg) {\n\t\t\tmid += MULMUL;\n\t\t}\n\t\tif (midsend < sdeg) {\n\t\t\tmidsend += MULMUL;\n\t\t}\n\t\tint64_t timedown = (20 * H * 6 - (H + 1));\n\t\tint64_t time20H = (mid - sdeg);\n\t\tif ((mdeg* timedown + 2 * H * time20H)% (MULMUL* timedown) == (2 * time20H) % (MULMUL * timedown)){\n\n\t\t\ttimedown = (20 * H * 6 - (H + 1));\n\t\t\ttime20H = (midsend - sdeg);\n\t\t\tif ((mdeg * timedown + 2 * H * time20H) % (MULMUL * timedown) == (2 * time20H) % (MULMUL * timedown)) {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\n\t\thdeg += 2 * time20H / timedown;\n\t\thdeg += rotate_sum; hdeg %= MULMUL;\n\t\tmdeg += 2 * H * time20H / timedown;\n\t\tmdeg += rotate_sum; mdeg %= MULMUL;\n\t\tsdeg += rotate_sum; sdeg %= MULMUL;\n\n\t\tusing namespace std;\n\t\t//assert(hdeg % (20 * 360) == 0);\n\t\t//assert(mdeg % (20 * H * 6) == 0);\n\t\tint64_t sup = (sdeg * timedown + 6*20*H* time20H) % (MULMUL * timedown);\n\t\tint64_t sdown = 20 * H * 6 * timedown;\n\t\tint64_t ggg = gcd(sup, sdown);\n\n\t\tsssss\n\t\t\t<< hdeg / (20 * 360) << ' '\n\t\t\t<< mdeg / (20 * H * 6) << ' '\n\t\t\t<< sup / ggg\t\t << ' '\n\t\t\t<< sdown / ggg\t\t\n\t\t\t<< '\\n';\n\n\t\tbreak;\n\t}\n}\nint main()\n{\n\tusing namespace std;\n\n\twhile (true)\n\t{\n\t\tcin >> H >> h >> m >> s;\n\n\t\tif (H == 0 && h == 0 && m == 0 && s == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n\tcout << sssss.str();\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\n//  nd/de\nclass Fruction\n{\npublic:\n\tlong long int nd;\n\tlong long int de;\n\tvoid reduct() {\n\t\tif (nd) {\n\t\t\tbool ndminus = false;\n\t\t\tif (nd < 0) {\n\t\t\t\tndminus = true;\n\t\t\t\tnd = -nd;\n\t\t\t}\n\n\t\t\tconst long long int agcd(gcd(nd, de));\n\t\t\tde /= agcd;\n\t\t\tnd /= agcd;\n\t\t\tif (ndminus)nd = -nd;\n\t\t}\n\t\telse {\n\t\t\tde = 1;\n\t\t}\n\t}\n\tFruction() :nd(0), de(1) {\n\n\t}\n\tvoid initialize() {\n\t\tif (de < 0) {\n\t\t\tde = -de;\n\t\t\tnd = -nd;\n\t\t}\n\t\treduct();\n\t\t\n\t}\n\tFruction(const long long int nd_,const long long int de_) \n\t\t:nd(nd_), de(de_) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int nd_, const Fruction de_) :\n\t\tnd(nd_*de_.de), de(de_.nd) {\n\t\tinitialize();\n\t}\n\tFruction(const Fruction nd_, const long long int de_) :\n\t\tnd(nd_.nd), de(nd_.de*de) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int num):nd(num),de(1) {\n\t}\n\tFruction(const Fruction& f) :de(f.de), nd(f.nd) {\n\n\t}\n\tpair<long long int, Fruction>mixed() {\n\t\tlong long int num = nd / de;\n\t\treturn make_pair(num, Fruction(nd - de*num, de));\n\t}\n};\nFruction operator-(const Fruction&f) {\n\treturn Fruction(-f.nd, f.de);\n}\nFruction operator+(const Fruction&l, const Fruction&r) {\n\tlong long int nede = lca(l.de, r.de);\n\tlong long int nend = l.nd*(nede / l.de) + r.nd*(nede / r.de);\n\treturn Fruction(nend, nede);\n}\nFruction operator-(const Fruction&l, const Fruction&r) {\n\treturn l+(-r);\n}\nFruction operator*(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.nd;\n\tlong long int nede = l.de*r.de;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator*(const Fruction&l, const long long int&r) {\n\treturn l*Fruction(r, 1);\n}\nFruction operator*(const long long int &l, const Fruction&r) {\n\treturn Fruction(l, 1)*r;\n}\nFruction operator/(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.de;\n\tlong long int nede = l.de*r.nd;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator/(const Fruction&l, const long long int&r) {\n\treturn l / Fruction(r, 1);\n}\nFruction operator/(const long long int&l, const Fruction&r) {\n\treturn Fruction(l,1) / r;\n}\n\nbool operator<(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de < r.nd*l.de;\n}\nbool operator<(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de <= r.nd*l.de;\n}\nbool operator==(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de == r.nd*l.de;\n}\nbool operator>(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de > r.nd*l.de;\n}\nbool operator>(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de >= r.nd*l.de;\n}\n\nint main() {\n\twhile (1) {\n\t\tint T, H, M, S; cin >> T >> H >> M >> S;\n\t\tif (!T)break;\n\t\tint total = T*60*60;\n\t\tint ntime = H * 3600 + M * 60 + S;\n\t\tif (!T)break;\n\t\tFruction speeds[3];\n\t\tspeeds[0] = Fruction(1, T * 60 * 60);\n\t\tspeeds[1] = Fruction(1, 60 * 60);\n\t\tspeeds[2] = Fruction(1, 60);\n\t\tFruction now[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tnow[i] = Fruction(speeds[i] * ntime);\n\t\t\tnow[i] = now[i].mixed().second;\n\t\t}\n\t\tFruction ans(1e9,1);\n\t\tfor (int i = 0; i < 1; ++i) {\n\t\t\tFruction dspeed = -(speeds[i] + speeds[(i + 1) % 3]) / 2 + speeds[(i + 2) % 3];\n\t\t\tFruction dkaku = (now[i] + now[(i + 1) % 3]) / 2 - now[(i + 2) % 3];\n\t\t\tif (dspeed < 0) {\n\t\t\t\tdkaku = -dkaku;\n\t\t\t\tdspeed = -dspeed;\n\t\t\t}\n\t\t\tfor (int j = -49; j < 50; ++j) {\n\t\t\t\tFruction nans = (dkaku +  j* Fruction(1, 2)) / dspeed;\n\t\t\t\tFruction next[3];\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tnext[k] = now[k] + nans*speeds[k];\n\t\t\t\t\tnext[k] = next[k].mixed().second;\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (next[k] == next[(k + 1) % 3])ok = false;\n\t\t\t\t}\n\t\t\t\tif (nans >= Fruction(0,1)) {\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tans = min(ans, nans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<long long int, Fruction>p(ans.mixed());\n\t\tlong long int fintime = ntime + p.first;\n\t\tfintime %= T * 60 * 60;\n\t\tconst int nh = fintime / 3600;\n\t\tfintime -= nh * 3600;\n\t\tconst int nm = fintime / 60;\n\t\tfintime -= nm * 60;\n\t\tFruction ns(fintime*p.second.de + p.second.nd, p.second.de);\n\t\tcout << nh << \" \" << nm << \" \" << ns.nd << \" \" << ns.de << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    int H, h0, m0, s0;\n    while(cin >> H >> h0 >> m0 >> s0, H) {\n        const ll d = 119 * H - 1;\n        ll n = s0 * d;\n        ll ho = h0, mo = m0;\n        while(true) {\n            ll ang_h = 3600 * ho * d + 60 * mo * d + n;\n            ll ang_m = 60 * H * mo * d + n * H;\n            ll ang_s = 60 * H * n;\n            ang_m = (ang_m - ang_h) % (360 * 10 * H * d);\n            ang_s = (ang_s - ang_h) % (360 * 10 * H * d);\n            if(ang_m < 0) {\n                ang_m += 360 * 10 * H * d;\n            }\n            if(ang_s < 0) {\n                ang_s += 360 * 10 * H * d;\n            }\n            ang_h = 0;\n\n            if(ang_h != ang_m) {\n                ll ang1, ang2;\n                if(ang_m < ang_s) {\n                    ang1 = 360 * 10 * H * d - ang_s;\n                    ang2 = ang_s - ang_m;\n                } else {\n                    ang1 = ang_s;\n                    ang2 = ang_m - ang_s;\n                }\n                if(ang1 == ang2) {\n                    break;\n                }\n            }\n\n            n++;\n            if(n == 60 * d) {\n                n = 0;\n                mo++;\n            }\n            if(mo == 60) {\n                mo = 0;\n                ho++;\n            }\n            if(ho == H) {\n                ho = 0;\n            }\n        }\n        ll g = __gcd(n, d);\n        cout << ho << ' ' << mo << ' ' << n / g << ' ' << d / g << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nlli gcd(lli a, lli b){\n    if(b == 0) return a;\n    return gcd(b, a%b);\n}\n\nstruct Clock60{\n    lli H,d;\n    lli h,m,sn,sd;\n    lli harg,marg,sarg;\n    Clock60(lli H, lli h, lli m, lli sn, lli sd):H(H),h(h),m(m),sn(sn),sd(sd){\n        calcArgs();\n    }\n    void addSeconds(lli n, lli d){\n        sn = d*sn + sd*n;\n        sd = sd*d;\n        lli g = gcd(sn, sd);\n        sn /= g;\n        sd /= g;\n        m += sn/(60*sd);\n        sn %= (60*sd);\n        h += m/60;\n        m %= 60;\n        h %= H;\n        calcArgs();\n    }\n    void calcArgs(){\n        d = 120*H*sd;\n        sarg = d*sn/sd;\n        marg = d*m + sarg/60;\n        harg = d*h*60/H + marg/H;\n    }\n    bool isValid(){\n        return harg != marg and ((harg+marg)/2 -sarg)%(30*d) == 0;\n    }\n};\nint main(){\n    while(1){\n        lli H,h,m,s;\n        cin >> H >> h >> m >> s;\n        if(H == 0) break;\n\n        Clock60 ini(H, h, m, s, 1);\n        lli midarg = (ini.marg + ini.harg) / 2;\n        lli diff = abs(ini.sarg - midarg) %(30*ini.d);\n        lli cand[4] = {diff, 30*ini.d + diff, 30*ini.d - diff, 60*ini.d - diff};\n        sort(cand, cand+4);\n        for(int i=0; i<4; i++){\n            Clock60 a = ini;\n            a.addSeconds(cand[i], 119*H - 1);\n            if(a.isValid()){\n                cout << a.h << \" \" << a.m << \" \" << a.sn << \" \" << a.sd << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// by team2\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <math.h>\n#include <stack>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nint gcd(int a,int b) {\n\tfor(int t; b; t=a,a=b,b=t%a);\n\treturn a;\n}\n\nint Div, H, h, m, s;\n\nbool check(int A,int B) {\n\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\tint w1 = 1, w2 = H, w3 = H*60;\n\tLL X = (LL)t1 * B + (LL)w1 * A;\n\tLL Y = (LL)t2 * B + (LL)w2 * A;\n\treturn X%((LL)B*Div) != Y%((LL)B*Div);\n}\n\nint main() {\n\twhile(~scanf(\"%d%d%d%d\", &H, &h, &m, &s)) {\n\t\tif(!H&&!h&&!m&&!s) break;\n\t\tDiv = 3600 * H;\n\t\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\t\tint w1 = 1, w2 = H, w3 = H*60;\n\t\tint A = 2 * t3 - t1 - t2;\n\t\tint B = w1 + w2 - 2 * w3;\n\t\tif(B < 0) B = -B, A = -A;\n\t\tA = (A % Div + Div) % Div;\n\t\twhile(!check(A, B)) A += Div;\n\t\tint g = gcd(A, B); A/=g, B/=g;\n\t\t\n\t\tlong long T = A + h * (B*3600) + m * (B*60) + s*B;\n\t\tint _h = T / (B * 3600) % H;\n\t\tint _m = T % (B * 3600) / (B * 60);\n\t\tint _s = T % (B * 60);\n\t\tprintf(\"%d %d %d %d\\n\", _h, _m, _s, B);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll ,ll> Q;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  else gcd(b, a%b);\n}\n\nQ qplus(Q a, Q b) {\n  ll nume = a.first * b.second + b.first * a.second;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume , deno);\n  return Q(nume/g, deno/g);\n}\n\nQ mult(Q a, Q b) {\n  ll nume= a.first * b.first;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume, deno);\n  return Q(nume/g, deno/g);\n}\n\nint sig(Q a, Q b) {\n  ll l = a.first * b.second, r = b.first * a.second;\n  if (l == r) return 0;\n  if (l < r) return -1;\n  return 1;\n}\n\nvoid gain(ll H, ll ih, ll im, ll is, Q t) {\n  Q s = qplus(Q(is, 1), t);\n  if (s.first / s.second >= 60) {\n\ts = qplus(s, Q(-60, 1));\n\tim++;\n\tif (im == 60) {\n\t  im = 0;\n\t  ih++;\n\t  if (ih == H) ih = 0;\n\t}\n  }\n  printf(\"%ld %ld %ld %ld\\n\", ih, im, s.first, s.second);\n}\n\nQ t[3];\n\nvoid normalize(Q &a) {\n  if (a.first >= a.second)\n\ta.first -= a.second;\n}\n\nQ qmin(Q rs, Q rm, Q rh, ll H) {\n  for (int i = 2; i > 0; i--) {\n\tfor (int j = 0; j < i; j++) {\n\t  if (sig(t[j], t[j+1]) > 0) {\n\t\tswap(t[j], t[j+1]);\n\t  }\n\t}\n  }\n  for (int i = 0; i < 3; i++) {\n\tQ s = qplus(rs, mult(t[i], Q(1, 60)));\n\tQ m = qplus(rm, mult(t[i], Q(1, 3600)));\n\tQ h = qplus(rh, mult(t[i], Q(1,3600*H)));\n\tnormalize(s); normalize(m); normalize(h);\n\tif (t[i].first >= 0 && t[i].second > 0 && sig(s, m) != 0 && sig(s, h) != 0 && sig(m, h) != 0)\n\t  return t[i];\n  }\n  return Q(-1, -1);\n}\n\nQ calc(ll H, ll ih, ll im, ll is) {\n  \tQ rs = Q(is, 60), rm = qplus(Q(im, 60), Q(is, 3600)), rh = qplus(Q(ih, H), mult(Q(1, H), rm));\n\tQ p = qplus(rh, rm);\n\tQ f = Q(3600*H, 119*H-1);\n\tQ mrs = mult(rs, Q(-2, 1));\n\tt[0] = mult(f, qplus(p, mrs));\n\tt[1] = mult(f, qplus(qplus(p, Q(1,1)), mrs));\n\tt[2] = mult(f, qplus(qplus(p, mrs), Q(-1,1)));\n\treturn qmin(rs, rm ,rh, H);\n}\n\nint main() {\n  while (true) {\n\tll H, ih, im, is;\n\tcin >> H >> ih >> im >> is;\n\tif (H == 0 && ih == 0 && im == 0 && is == 0) break;\n\t//\tt[3] = mult(f, qplus(qplus(rh, mrm), mrs));\n\tQ res = calc(H, ih, im, is);\n\tif (res.first == -1 && res.second == -1) {\n\t  is = 0;\n\t  im++;\n\t  if (im == 60) {\n\t\tim = 0;\n\t\tih++;\n\t\tif (ih == H) ih = 0;\n\t  }\n\t  res = calc(H, ih, im, is);\n\t}\n\t//\tfor (int i = 0; i < 3; i++)\n\t//\t\t  printf(\"enu:%ld %ld\\n\", t[i].first, t[i].second);\n\t//\tprintf(\"min:%ld %ld\\n\", res.first, res.second);\n\n\tgain(H, ih, im , is, res);\n\t//\tprintf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\n//  nd/de\nclass Fruction\n{\npublic:\n\tlong long int nd;\n\tlong long int de;\n\tvoid reduct() {\n\t\tif (nd) {\n\t\t\tbool ndminus = false;\n\t\t\tif (nd < 0) {\n\t\t\t\tndminus = true;\n\t\t\t\tnd = -nd;\n\t\t\t}\n\n\t\t\tconst long long int agcd(gcd(nd, de));\n\t\t\tde /= agcd;\n\t\t\tnd /= agcd;\n\t\t\tif (ndminus)nd = -nd;\n\t\t}\n\t\telse {\n\t\t\tde = 1;\n\t\t}\n\t}\n\tFruction() :nd(0), de(1) {\n\n\t}\n\tvoid initialize() {\n\t\tif (de < 0) {\n\t\t\tde = -de;\n\t\t\tnd = -nd;\n\t\t}\n\t\treduct();\n\t\t\n\t}\n\tFruction(const long long int nd_,const long long int de_) \n\t\t:nd(nd_), de(de_) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int nd_, const Fruction de_) :\n\t\tnd(nd_*de_.de), de(de_.nd) {\n\t\tinitialize();\n\t}\n\tFruction(const Fruction nd_, const long long int de_) :\n\t\tnd(nd_.nd), de(nd_.de*de) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int num):nd(num),de(1) {\n\t}\n\tFruction(const Fruction& f) :de(f.de), nd(f.nd) {\n\n\t}\n\tpair<long long int, Fruction>mixed() {\n\t\tlong long int num = nd / de;\n\t\treturn make_pair(num, Fruction(nd - de*num, de));\n\t}\n};\nFruction operator-(const Fruction&f) {\n\treturn Fruction(-f.nd, f.de);\n}\nFruction operator+(const Fruction&l, const Fruction&r) {\n\tlong long int nede = lca(l.de, r.de);\n\tlong long int nend = l.nd*(nede / l.de) + r.nd*(nede / r.de);\n\treturn Fruction(nend, nede);\n}\nFruction operator-(const Fruction&l, const Fruction&r) {\n\treturn l+(-r);\n}\nFruction operator*(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.nd;\n\tlong long int nede = l.de*r.de;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator*(const Fruction&l, const long long int&r) {\n\treturn l*Fruction(r, 1);\n}\nFruction operator*(const long long int &l, const Fruction&r) {\n\treturn Fruction(l, 1)*r;\n}\nFruction operator/(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.de;\n\tlong long int nede = l.de*r.nd;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator/(const Fruction&l, const long long int&r) {\n\treturn l / Fruction(r, 1);\n}\nFruction operator/(const long long int&l, const Fruction&r) {\n\treturn Fruction(l,1) / r;\n}\n\nbool operator<(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de < r.nd*l.de;\n}\nbool operator==(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de == r.nd*l.de;\n}\nbool operator>(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de > r.nd*l.de;\n}\n\nint main() {\n\twhile (1) {\n\t\tint T, H, M, S; cin >> T >> H >> M >> S;\n\t\tif (!T)break;\n\t\tint total = T*60*60;\n\t\tint ntime = H * 3600 + M * 60 + S;\n\t\tif (!T)break;\n\t\tFruction speeds[3];\n\t\tspeeds[0] = Fruction(1, T * 60 * 60);\n\t\tspeeds[1] = Fruction(1, 60 * 60);\n\t\tspeeds[2] = Fruction(1, 60);\n\t\tFruction now[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tnow[i] = Fruction(speeds[i] * ntime);\n\t\t\tnow[i] = now[i].mixed().second;\n\t\t}\n\t\tFruction ans(1e9,1);\n\t\tfor (int i = 0; i < 1; ++i) {\n\t\t\tFruction dspeed = -(speeds[i] + speeds[(i + 1) % 3]) / 2 + speeds[(i + 2) % 3];\n\t\t\tFruction dkaku = (now[i] + now[(i + 1) % 3]) / 2 - now[(i + 2) % 3];\n\t\t\tif (dspeed < 0) {\n\t\t\t\tdkaku = -dkaku;\n\t\t\t\tdspeed = -dspeed;\n\t\t\t}\n\t\t\tfor (int j = -49; j < 50; ++j) {\n\t\t\t\tFruction nans = (dkaku +  j* Fruction(1, 2)) / dspeed;\n\t\t\t\tFruction next[3];\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tnext[k] = now[k] + nans*speeds[k];\n\t\t\t\t\tnext[k] = next[k].mixed().second;\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (next[k] == next[(k + 1) % 3])ok = false;\n\t\t\t\t}\n\t\t\t\tif (nans >= 0) {\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tans = min(ans, nans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<long long int, Fruction>p(ans.mixed());\n\t\tlong long int fintime = ntime + p.first;\n\t\tfintime %= T * 60 * 60;\n\t\tconst int nh = fintime / 3600;\n\t\tfintime -= nh * 3600;\n\t\tconst int nm = fintime / 60;\n\t\tfintime -= nm * 60;\n\t\tFruction ns(fintime*p.second.de + p.second.nd, p.second.de);\n\t\tcout << nh << \" \" << nm << \" \" << ns.nd << \" \" << ns.de << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Real{\n\n\tlong long top, bot;\n\n\tReal(long long top, long long bot) : top(top), bot(bot) {\n\t\tnormalize();\n\t}\n\n\tlong long gcd(long long a, long long b){\n\t\tif(!a || !b) return a+b;\n\t\tif(a < b) return gcd(b, a);\n\t\treturn gcd(b, a%b);\n\t}\n\n\tvoid normalize(){\n\t\tif(bot<0){\n\t\t\tbot = -bot;\n\t\t\ttop = -top;\n\t\t}\n\t\tint divisor = gcd(top<0 ? -top : top, bot);\n\t\ttop /= divisor;\n\t\tbot /= divisor;\n\t}\n\n\tReal operator+(const Real& rhs){\n\t\treturn Real(top*rhs.bot+rhs.top*bot, bot*rhs.bot);\n\t}\n\n\tReal operator+(long long x){\n\t\treturn Real(top + x*bot, bot);\n\t}\n\n\tReal operator-(const Real& rhs){\n\t\treturn Real(top*rhs.bot-rhs.top*bot, bot*rhs.bot);\n\t}\n\n\tReal operator*(const Real& rhs){\n\t\treturn Real(top*rhs.top, bot*rhs.bot);\n\t}\n\n\tReal operator*(long long x){\n\t\treturn Real(top*x, bot);\n\t}\n\n\tReal operator/(const Real& rhs){\n\t\treturn Real(top*rhs.bot, bot*rhs.top);\n\t}\n\n\tReal operator/(long long x){\n\t\treturn Real(top, bot*x);\n\t}\n\n\tReal operator%(long long x){\n\t\treturn Real(top % (x*bot), bot);\n\t}\n\n\tbool operator==(Real rhs){\n\t\treturn top*rhs.bot == rhs.top*bot;\n\t}\n\n\tbool operator<(const Real& rhs) const{\n\t\treturn top*rhs.bot < rhs.top*bot;\n\t}\n\n\tlong long toInt(){\n\t\treturn top / bot;\n\t}\n\n\tdouble toDouble(){\n\t\treturn (double)top / bot;\n\t}\n\n};\n\nint main() {\n\twhile(true){\n\t\tint H, h, m, s;\n\t\tscanf(\"%d %d %d %d\", &H, &h, &m, &s);\n\t\tif(!H && !h && !m && !s) break;\n\t\tReal speedH = Real(1, 10*H);\n\t\tReal speedM = Real(1, 10);\n\t\tReal speedAvg = (speedH + speedM) / 2;\n\t\tReal speedS = Real(6, 1);\n\t\tlong long past = 3600*h + 60*m + s;\n\t\tReal positionAvg = speedAvg * past % 360;\n\t\tReal positionS = speedS * past % 360;\n\t\tReal distance = min((positionAvg+540-positionS)%360, (positionAvg+360-positionS)%360);\n\t\tReal final = distance / (speedS - speedAvg) + past;\n\t\tif(speedH*final%360 == speedM*final%360 && speedM*final%360 == speedS*final%360){\n\t\t\tdistance = (distance+180)%360;\n\t\t\tfinal = distance / (speedS - speedAvg) + past;\n\t\t}\n\t\tfinal = final % (H * 3600);\n\t\tlong long Hour = final.toInt() / 3600;\n\t\tfinal = final + Hour*-3600;\n\t\tlong long Minute = final.toInt() / 60;\n\t\tfinal = final + Minute*-60;\n\n\t\tprintf(\"%lld %lld %lld %lld\\n\", Hour, Minute, final.top, final.bot);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint H,h,m,s;\nvoid judge();\nvoid output(int n,int d);\nint main() {\n  while(true){\n    cin >> H >> h >> m >> s;\n    if(H==0&&h==0&&m==0&&s==0) return 0;\n    judge();\n  }\n  return 0;\n}\n\nvoid judge(){\n  int dn,dd;\n  double ds,nh,nm,ns;\n  while(true){\n    dn = s*(119*H-1)-60*m*(H+1)-3600*h+3600*H;\n    dd = 1-119*H;\n    rep(i,3){\n      ds = (double)dn/(double)dd;\n      nh = (double)h/(double)H+(double)m/(60*(double)H)+((double)s+ds)/(3600*(double)H);\n      nm = (double)m/60+((double)s+ds)/3600;\n      ns = ((double)s+ds)/60;\n      if(ns>=1) break;\n      if(ds>=0&&ns<1&&nh!=nm&&nh!=ns&&nm!=ns){\n        output(dn+dd*s,dd);\n        return;\n      }\n      dn -= 3600*H;\n    }\n    s=0;\n    m++;\n    if(m==60){\n      m=0;\n      h++;\n      if(h==H) h=0;\n    }\n  }\n}\n\nvoid output(int n,int d){\n  if(n==0){\n    cout << h << \" \" << m << \" \" << 0 << \" \" << 1 << endl;\n    return;\n  }\n  int a,b;\n  a=n;\n  b=d;\n  while(true){\n    a = a%b;\n    if(a==0){\n      n = n/b;\n      d = d/b;\n      break;\n    }\n    b = b%a;\n    if(b==0){\n      n = n/a;\n      d = d/a;\n      break;\n    }\n  }\n  cout << h << \" \" << m << \" \" << n << \" \" << d << endl;\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\ntypedef long long LL;\nusing namespace std;\n\nstruct Rational{\n    // p : 分子 q : 分母\n    LL p, q;\n    void normalize(){\n        if(q < 0) {\n            p *= -1;\n            q *= -1;\n        }\n        LL d = __gcd(abs(p), q);\n        if(d == 0){\n            p = 0;\n            q = 1;\n        }else{\n            p /= d;\n            q /= d;\n        }\n    }\n    Rational(LL p, LL q) : p(p), q(q) {\n        normalize();\n    }\n\n};\n\nRational operator + (const Rational& a, const Rational& b){\n    return Rational(a.p * b.q + b.p * a.q, a.q * b.q);\n}\n\nRational operator - (const Rational& a, const Rational& b){\n    return Rational(a.p * b.q - b.p * a.q, a.q * b.q);\n}\n\nRational operator * (const Rational& a, const Rational& b){\n    return Rational(a.p * b.p, a.q * b.q);\n}\n\nRational operator / (const Rational& a, const Rational& b){\n    return Rational(a.p * b.q, a.q * b.p);\n}\n\nbool operator == (const Rational& a, const Rational& b){\n    return (a.p == b.p) && (a.q == b.q);\n}\n\nbool operator < (const Rational& a, const Rational& b){\n    // overflowを避けるためにlong doubleを用いる\n    return (long double) a.p * b.q < (long double) b.p * a.q;\n}\nbool operator >= (const Rational& a, const Rational& b){\n    return a == b || (b < a);\n}\n\nint main(){\n    int H, fh, fm, fs;\n    while(cin >> H >> fh >> fm >> fs && H > 0) {\n        Rational begin(fh * 3600 + fm * 60 + fs, 1);\n        // cout << \"begin: \" << begin.p << \" \" << begin.q << endl;\n        bool exist = false;\n        Rational answer(1, 1);\n        int ah, am;\n        Rational as(1, 0);\n        for(int h = 0; h < H; h++) {\n            for(int m = 0; m < 60; m++) {\n                for(int i = -1; i <= 1; i++) {\n                    Rational s(3600 * h + 60 * (1 + H) * m + i * 3600 * H, 119 * H - 1);\n\n                    if(s >= Rational(60, 1)) continue;\n                    if(s < Rational(0, 1)) continue;\n                    if(Rational(59, 1) * s == Rational(60 * m, 1)) continue;\n\n                    // if(h == 0 && m == 0) {\n                    //     cout << s.p << \" \" << s.q << endl;\n                    // }\n\n                    Rational now(h * 3600 + m * 60, 1);\n                    now = now + s;\n                    // cout << \"hm: \" << h << \" \" << m << endl;\n                    // cout << \"now: \" << now.p << \" \" << now.q << endl;\n                    if(now < begin) {\n                        now = now + Rational(H * 3600, 1);\n                    }\n                    // cout << \"now2: \" << now.p << \" \" << now.q << endl;\n                    if(!exist || now < answer) {\n                        exist = true;\n                        answer = now;\n                        ah = h, am = m, as = s;\n                    }\n                    // cout << \"answer: \" << answer.p << \" \" << answer.q << endl;\n                    // cout << \"ah: \" << ah << \" \" << am << \" \" << as.p << \" \" << as.q << endl;\n                }\n            }\n        }\n        cout << ah << \" \" << am << \" \" << as.p << \" \" << as.q << endl;\n        // cout << \"---\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\nusing namespace std;\n\nvoid solve(ll H,ll h,ll m,ll s){\n    ll x=119*H-1;\n    ll ss=h*3600+m*60+s;\n    ll i=((ss*x-1)/(3600*H))+1;\n    //cout<<i<<endl;\n    if(i==x)i=1;\n    ll ans=3600*H*i;//(119*H-1);\n    //cout<<ts<<endl;//%(3600*12*60)<<endl;\n    //ts%=x*60;\n    //ll ts=ans  \n    //ll tm=((ans-1)/x+1)/60%60;\n    ll tm=(ans/x)/60%60;\n    ll th=(ans/x)/3600%H;\n    ans%=(x*60);\n    for(int i=2;i<=x;i++){\n        while(ans%i==0&&x%i==0){\n            ans/=i;x/=i;\n        }\n    }\n    cout<<th<<\" \"<<tm<<\" \"<<ans<<\" \"<<x<<endl;\n}\n\n\nint main(void){\n    ll a,b,c,d;\n    while(cin>>a>>b>>c>>d,a){\n        solve(a,b,c,d);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 60;\nconst int S = 60;\nint H, h, m, s;\n\n/*\n  (?§???????degree)\n  ?§?????§???? = 6s\n  ???????§???? = 1/10 * (60m + s)\n  ???????§???? = 1/(10H) * (3600h + 60m + s)\n\n  ???????§???? - ?§?????§???? == ?§?????§???? - ???????§???? ?????????\n  s = (3600h + (1+H)60m) / (119H - 1)\n  ?????£???????????????119H-1 ??\n\n  ?????°???????????????????????¢????????????????????§???????????§???????????????????????????????????£??¨?????????????????£???????°?????????????\n */\n\nbool is_same_deg(const int &sa, const int &sb){\n  //s??§??????sa????????§????????????sb??????????????????\n  int h_s = 3600*h*sb + 60*m*sb + sa - 60*H*sa; //?????°?????????????????????10*H??????????????????\n  int s_m = 60*H*sa - 60*H*m*sb - H*sa; //?????°?????????????????????10*H??????????????????\n  for(int i=0;i<=1;i++){\n    for(int j=0;j<=1;j++){\n      if (h_s + 360*10*H*sb*i == s_m + 360*10*H*sb*j) return true;\n    }\n  }\n  return false;\n}\n\nbool is_overlap(const int &sa, const int &sb){\n  int h_deg_mul10h = 3600*h*sb + 60*m*sb + sa;\n  int s_deg = 6*h*sb;\n  int m_deg_mul10 = 60*m*sb + sa;\n  return (s_deg*10*H == h_deg_mul10h || s_deg*10 == m_deg_mul10);\n}\n\nvoid solve(){\n  int sa, sb = 119 * H - 1;\n  sa = s * sb;\n  // 1 / (119H-1) ?§??????????????????¨??¢?´¢\n  for(int i=0;i<=H*M*S*sb;i++){\n    if(is_same_deg(sa, sb) && !is_overlap(sa, sb)){\n      int g = __gcd(sa, sb);\n      cout << h << ' ' << m << ' ' << sa/g << ' ' << sb/g << endl;\n      return;\n    }\n    \n    // failed\n    sa++;\n    if(sa >= S * sb){\n      sa -= S * sb;\n      m++;\n      if(m >= M){\n        m -= M;\n        h++;\n        if(h >= H){\n          h = m = sa = 0;\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s && (H|h|m|s)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 60;\nconst int S = 60;\nint H, h, m, s;\n\n/*\n  (?§???????degree)\n  ?§?????§???? = 6s\n  ???????§???? = 1/10 * (60m + s)\n  ???????§???? = 1/(10H) * (3600h + 60m + s)\n\n  ???????§???? - ?§?????§???? == ?§?????§???? - ???????§???? ?????????\n  s = (3600h + (1+H)60m) / (119H - 1)\n  ?????£???????????????119H-1 ??\n\n  ?????°???????????????????????¢????????????????????§???????????§???????????????????????????????????£??¨?????????????????£???????°?????????????\n */\n\nbool is_same_deg(const int &sa, const int &sb){\n  //s??§??????sa????????§????????????sb??????????????????\n  int h_s = 3600*h*sb + 60*m*sb + sa - 60*H*sa; //?????°?????????????????????10*H??????????????????\n  int s_m = 60*H*sa - 60*H*m*sb - H*sa; //?????°?????????????????????10*H??????????????????\n  for(int i=0;i<=1;i++){\n    for(int j=0;j<=1;j++){\n      if (h_s + 360*10*H*sb*i == s_m + 360*10*H*sb*j) return true;\n    }\n  }\n  return false;\n}\n\nbool is_overlap(const int &sa, const int &sb){\n  int h_deg_mul10h = 3600*h*sb + 60*m*sb + sa;\n  int s_deg = 6*h*sb;\n  int m_deg_mul10 = 60*m*sb + sa;\n  return (s_deg*10*H == h_deg_mul10h || s_deg*10 == m_deg_mul10);\n}\n\nvoid solve(){\n  int sa, sb = 119 * H - 1;\n  sa = s * sb;\n  // 1 / (119H-1) ?§??????????????????¨??¢?´¢\n  for(int i=0;i<=H*M*S*sb;i++){\n    if(is_same_deg(sa, sb) && !is_overlap(sa, sb)){\n      int g = __gcd(sa, sb);\n      cout << h << ' ' << m << ' ' << sa/g << ' ' << sb/g << endl;\n      return;\n    }\n    \n    // failed\n    sa++;\n    if(sa >= S * sb){\n      sa -= S * sb;\n      m++;\n      if(m >= M){\n        m -= M;\n        h++;\n        if(h >= H){\n          h = m = sa = 0;\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n  assert(false);\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s && (H|h|m|s)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nlong long gcd(long long x, long long y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nlong long a, b, c, d;\nint main() {\n\twhile (cin >> a >> b >> c >> d, a) {\n\t\tlong long r = 119 * a - 1;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tlong long cp = (d * r + i) * 60 * a, cq = 3600 * a * r;\n\t\t\tlong long bp = (c * 60 * r + cp / (60 * a)) * a, bq = 3600 * a * r;\n\t\t\tlong long ap = b * 3600 * r + bp / a, aq = 3600 * a * r;\n\t\t\twhile (cp < ap) cp += cq;\n\t\t\twhile (bp < cp) bp += bq;\n\t\t\tif (ap == bp) continue;\n\t\t\tif (cp - ap == bp - cp) {\n\t\t\t\tlong long cr = d * r + i, br = c, ar = b;\n\t\t\t\tbr += cr / (60 * r); cr %= 60 * r;\n\t\t\t\tar += br / 60; br %= 60;\n\t\t\t\tar %= a;\n\t\t\t\tlong long f = gcd(cr, r);\n\t\t\t\tcr /= f; r /= f;\n\t\t\t\tcout << ar << ' ' << br << ' ' << cr << ' ' << r << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint H, h, m, n, d;\n// s=n/d\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  int mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  int hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  int mrad = 60*H*m*d+H*n;\n  int hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  int s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    int prem = m, preh = h;\n    int ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (int i = 0; i < (H-1)*60; i++) {\n      \tn = i;\n      \tif (prem == m && d*s > n) continue;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = i; ansd = H-1;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (int i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tint t = gcd(ansn, ansd);\n\tansn /= t; ansd /= t;\n\tif (ansn == 0) ansd = 1;\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll ,ll> Q;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  else gcd(b, a%b);\n}\n\nQ qplus(Q a, Q b) {\n  ll nume = a.first * b.second + b.first * a.second;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume , deno);\n  return Q(nume/g, deno/g);\n}\n\nQ mult(Q a, Q b) {\n  ll nume= a.first * b.first;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume, deno);\n  return Q(nume/g, deno/g);\n}\n\nint sig(Q a, Q b) {\n  ll l = a.first * b.second, r = b.first * a.second;\n  if (l == r) return 0;\n  if (l < r) return -1;\n  return 1;\n}\n\nvoid gain(ll H, ll ih, ll im, ll is, Q t) {\n  Q s = qplus(Q(is, 1), t);\n  if (s.first / s.second >= 60) {\n\ts = qplus(s, Q(-60, 1));\n\tim++;\n\tif (im == 60) {\n\t  im = 0;\n\t  ih++;\n\t  if (ih == H) ih = 0;\n\t}\n  }\n  printf(\"%ld %ld %ld %ld\\n\", ih, im, s.first, s.second);\n}\n\nQ t[3];\n\nvoid normalize(Q &a) {\n  if (a.first >= a.second)\n\ta.first -= a.second;\n}\n\nQ qmin(Q rs, Q rm, Q rh, ll H) {\n  for (int i = 2; i > 0; i--) {\n\tfor (int j = 0; j < i; j++) {\n\t  if (sig(t[j], t[j+1]) > 0) {\n\t\tswap(t[j], t[j+1]);\n\t  }\n\t}\n  }\n  for (int i = 0; i < 3; i++) {\n\tQ s = qplus(rs, mult(t[i], Q(1, 60)));\n\tQ m = qplus(rm, mult(t[i], Q(1, 3600)));\n\tQ h = qplus(rh, mult(t[i], Q(1,3600*H)));\n\tnormalize(s); normalize(m); normalize(h);\n\tif (t[i].first >= 0 && t[i].second > 0 && sig(s, m) != 0 && sig(s, h) != 0 && sig(m, h) != 0)\n\t  return t[i];\n  }\n  return Q(-1, -1);\n}\n\nQ calc(ll H, ll ih, ll im, ll is) {\n  \tQ rs = Q(is, 60), rm = qplus(Q(im, 60), Q(is, 3600)), rh = qplus(Q(ih, H), mult(Q(1, H), rm));\n\tQ p = qplus(rh, rm);\n\tQ f = Q(3600*H, 119*H-1);\n\tQ mrs = mult(rs, Q(-2, 1));\n\tt[0] = mult(f, qplus(p, mrs));\n\tt[1] = mult(f, qplus(qplus(p, Q(1,1)), mrs));\n\tt[2] = mult(f, qplus(qplus(p, mrs), Q(-1,1)));\n\treturn qmin(rs, rm ,rh, H);\n}\n\nint main() {\n  while (true) {\n\tll H, ih, im, is;\n\tcin >> H >> ih >> im >> is;\n\tif (H == 0 && ih == 0 && im == 0 && is == 0) break;\n\t//\tt[3] = mult(f, qplus(qplus(rh, mrm), mrs));\n\tQ res = calc(H, ih, im, is);\n\tif (res.first == -1 && res.second == -1) {\n\t  is = 0;\n\t  im++;\n\t  if (im == 60) {\n\t\tim = 0;\n\t\tih++;\n\t\tif (ih == H) ih = 0;\n\t  }\n\t  res = calc(H, ih, im, is);\n\t}\n\t//\tfor (int i = 0; i < 3; i++)\n\t//\t\t  printf(\"enu:%ld %ld\\n\", t[i].first, t[i].second);\n\t//\tprintf(\"min:%ld %ld\\n\", res.first, res.second);\n\n\tgain(H, ih, im , is, res);\n\t//\tprintf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll ,ll> Q;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  else gcd(b, a%b);\n}\n\nQ qplus(Q a, Q b) {\n  ll nume = a.first * b.second + b.first * a.second;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume , deno);\n  return Q(nume/g, deno/g);\n}\n\nQ mult(Q a, Q b) {\n  ll nume= a.first * b.first;\n  ll deno = a.second * b.second;\n  ll g = gcd(nume, deno);\n  return Q(nume/g, deno/g);\n}\n\nint sig(Q a, Q b) {\n  ll l = a.first * b.second, r = b.first * a.second;\n  if (l == r) return 0;\n  if (l < r) return -1;\n  return 1;\n}\n\nvoid gain(ll H, ll ih, ll im, ll is, Q t) {\n  Q s = qplus(Q(is, 1), t);\n  if (s.first / s.second >= 60) {\n\ts = qplus(s, Q(-60, 1));\n\tim++;\n\tif (im == 60) {\n\t  im = 0;\n\t  ih++;\n\t  if (ih == H) ih = 0;\n\t}\n  }\n  printf(\"%ld %ld %ld %ld\\n\", ih, im, s.first, s.second);\n}\n\nQ t[3];\n\nvoid normalize(Q &a) {\n  if (a.first >= a.second)\n\ta.first -= a.second;\n}\n\nQ qmin(Q rs, Q rm, Q rh, ll H) {\n  for (int i = 2; i > 0; i--) {\n\tfor (int j = 0; j < i; j++) {\n\t  if (sig(t[j], t[j+1]) > 0) {\n\t\tswap(t[j], t[j+1]);\n\t  }\n\t}\n  }\n  for (int i = 0; i < 3; i++) {\n\tQ s = qplus(rs, mult(t[i], Q(1, 60)));\n\tQ m = qplus(rm, mult(t[i], Q(1, 3600)));\n\tQ h = qplus(rh, mult(t[i], Q(1,3600*H)));\n\tnormalize(s); normalize(m); normalize(h);\n\tif (t[i].first >= 0 && t[i].second > 0 && sig(s, m) != 0 && sig(s, h) != 0 && sig(m, h) != 0)\n\t  return t[i];\n  }\n  return Q(-1, -1);\n}\n\nQ calc(ll H, ll ih, ll im, ll is) {\n  \tQ rs = Q(is, 60), rm = qplus(Q(im, 60), Q(is, 3600)), rh = qplus(Q(ih, H), mult(Q(1, H), rm));\n\tQ p = qplus(rh, rm);\n\tQ f = Q(3600*H, 119*H-1);\n\tQ mrs = mult(rs, Q(-2, 1));\n\tt[0] = mult(f, qplus(p, mrs));\n\tt[1] = mult(f, qplus(qplus(p, Q(1,1)), mrs));\n\tt[2] = mult(f, qplus(qplus(p, mrs), Q(-1,1)));\n\treturn qmin(rs, rm ,rh, H);\n}\n\nint main() {\n  while (true) {\n\tll H, ih, im, is;\n\tcin >> H >> ih >> im >> is;\n\tif (H == 0 && ih == 0 && im == 0 && is == 0) break;\n\t//\tt[3] = mult(f, qplus(qplus(rh, mrm), mrs));\n\tQ res = calc(H, ih, im, is);\n\tif (res.first == -1 && res.second == -1) {\n\t  is = 0;\n\t  im++;\n\t  if (im == 60) {\n\t\tim = 0;\n\t\tih++;\n\t\tif (ih == H) ih = 0;\n\t  }\n\t  res = calc(H, ih, im, is);\n\t}\n\t//\tfor (int i = 0; i < 3; i++)\n\t//\t\t  printf(\"enu:%ld %ld\\n\", t[i].first, t[i].second);\n\t//\tprintf(\"min:%ld %ld\\n\", res.first, res.second);\n\n\tgain(H, ih, im , is, res);\n\t//\tprintf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong gcd(long a,long b){return b?gcd(b,a%b):a;}\nint H,h,m,s;\nbool check(long H,long h,long m,long s)\n{\n    for(int r=-1;r<=1;r++)\n    {\n        long A=r*360*10*H+60*m*(H+1)+3600*h;\n        long B=119*H-1;\n        long d=gcd(A,B);\n        A/=d;\n        B/=d;\n        if(!(A>=60*B||s*B>A)&&!(h==0&&m==0&&A==0))\n        {\n            cout<<h<<\" \"<<m<<\" \"<<A<<\" \"<<B<<endl;\n            return true;\n        }\n    }\n    return false;\n}\nmain()\n{\n    while(cin>>H>>h>>m>>s,H)\n    {\n        while(!check(H,h,m,s))\n        {\n            s++;\n            if(s==60)m++,s=0;\n            if(m==60)h++,m=0;\n            if(h==H)h=0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> Q;\n\npair<Q,Q> calcSec(int H, int h, int m){\n  pair<Q,Q> res;\n  bool f = false;\n  if( (h*3600 + m*60 + m*60*H ) < 20*H*180) f = true;\n\n  res.first = make_pair(h*3600 + m*60*(H+1), -H + 120*H - 1);\n  res.second = make_pair(h*3600 + m*60*(H+1) + (f?180:-180)*20*H, -H + 120*H - 1);\n \n  return res;\n}\n\nbool comp(Q a, Q b){\n  return a.first * b.second < a.second * b.first;\n}\n\nint main(){\n  int H,h,m,s;\n\n  while(cin >> H >> h >> m >> s, H){\n    for(;;){\n      pair<Q,Q> tmp = calcSec(H,h,m);\n      \n      Q res = make_pair(60,1);\n\n      if( (s*tmp.first.second <= tmp.first.first) && comp(tmp.first,res)\n\t  && (60*tmp.first.first != m*60*tmp.first.second + tmp.first.first) )res = tmp.first;\n      if( (s*tmp.second.second <= tmp.second.first) && comp(tmp.second,res)\n\t  && (60*tmp.second.first != m*60*tmp.second.second + tmp.second.first) )res = tmp.second;\n\n      if(res != Q(60,1)){\n\tif(res.first == 0){\n\t  cout << h << \" \" << m << \" \" << 0 << \" \" << 1 << endl;\n\t}else{ \n\t  res.first = abs(res.first); res.second = abs(res.second);\n\t  int g = __gcd(res.first, res.second);\n\t  res.first /= g; res.second /= g;\n\t  cout << h << \" \" << m << \" \" << res.first << \" \" << res.second << endl;\n\t}\n\tbreak;\n      }\n      s = 0;\n      m++;\n      if(m==60)m = 0,h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint H, h, m, n, d;\n// s=n/d\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  int mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  int hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  int mrad = 60*H*m*d+H*n;\n  int hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  int s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    int prem = m, preh = h;\n    int ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (int i = 0; i < (H-1)*60; i++) {\n      \tn = i;\n      \tif (prem == m && d*s > n) continue;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = n; ansd = d;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (int i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tif (ansn == 0) {\n\t  ansd = 1;\n\t}else {\n\t  int t = gcd(ansn, ansd);\n\t  ansn /= t; ansd /= t;\n\t}\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\nusing namespace std;\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nint H,h,m,s,ansup,ansdown,x,jy,ansm,ansh;\nvoid gx(int up,int down)\n{\n    //cout<<h<<\" \"<<m<<\" \"<<up<<\" \"<<down<<\"cs\"<<endl;\n    if(up<0||up/down<s)return ;\n    if(up/down>=60)\n        return;\n    if(m*H!=h*60||(up/down)!=m%60)\n    {\n        if(up>0)\n        {\n            x=gcd(up,down);\n            ansup=up/x;\n            ansdown=down/x;\n        }\n        else\n        {\n            ansup=0;\n            ansdown=1;\n        }\n        ansm=m;\n        ansh=h;\n    }\n}\nint main()\n{\n    while(scanf(\"%d%d%d%d\",&H,&h,&m,&s)&&H)\n    {\n        //1  m>h  s>m\n        ansup=-1;\n            int ansdown1=119*H-1;\n            int ansup1=3600*(H+h)+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n            //2 m>h  s<m\n\n            ansup1=3600*h+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n\n            ansup1=3600*(h-H)+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n        if(ansup>=0)\n        printf(\"%d %d %d %d\\n\",ansh,ansm,ansup,ansdown);\n        else\n        {\n            m++;\n            s=0;\n            if(m==60)m=0,h=(h+1)%H;\n            ansdown1=119*H-1;\n            ansup1=3600*(H+h)+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n            //2 m>h  s<m\n            ansup1=3600*h+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n            ansup1=3600*(h-H)+60*m*H+60*m;\n            gx(ansup1,ansdown1);\n            printf(\"%d %d %d %d\\n\",ansh,ansm,ansup,ansdown);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Clock Hands\n//Level: 4\n//Category: 数学,Math\n//Note:\n\n/**\n * 時計回りにみたとき、短針—秒針—長針のパターンか、長針—秒針—短針のパターンかを調べる。\n * 前者のとき、この向きで見て0.5∠短長より短針側に秒針がいるときは、方程式を計算することで解が求められる。\n * そうでない場合、いったん長針を追い越してから後者のパターンで計算する。\n * 後者の時も同様。\n *\n * オーダーは O(1)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a, LL b) {\n    if(a < b) swap(a, b);\n    while(b != 0) {\n        LL tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nLL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\nstruct Fraction {\n    LL num, den;\n    explicit Fraction(LL num) : num(num), den(1) { normalize(); }\n    Fraction(LL num, LL den) : num(num), den(den) { normalize(); }\n\n    Fraction& operator +=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num += f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator -=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num -= f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator *=(const Fraction &f) {\n        num *= f.num;\n        den *= f.den;\n        normalize();\n        return *this;\n    }\n\n    bool operator ==(const Fraction &f) const {\n        return (num == 0 && f.num == 0) || (num == f.num && den == f.den);\n    }\n\n    bool operator <(const Fraction &f) const {\n        return num * f.den < den * f.num;\n    }\n\n    bool operator >(const Fraction &f) const {\n        return num * f.den > den * f.num;\n    }\n\n    bool operator <=(const Fraction &f) const {\n        return *this < f || *this == f;\n    }\n\n    bool operator >=(const Fraction &f) const {\n        return *this > f || *this == f;\n    }\n\n    void normalize() {\n        LL g = abs(gcd(num, den));\n        num /= g;\n        den /= g;\n        if(den < 0) {\n            num = -num;\n            den = -den;\n        }\n        if(num == 0) den = 1;\n    }\n\n    Fraction strict() const {\n        return Fraction(num % den, den);\n    }\n};\n\nFraction operator +(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret += g;\n    return ret;\n}\n\nFraction operator -(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret -= g;\n    return ret;\n}\n\nFraction operator /(const Fraction &f, LL d) {\n    Fraction ret = f;\n    ret *= Fraction(1, d);\n    return ret;\n}\n\nFraction operator /(const Fraction &f, const Fraction &d) {\n    Fraction ret = f;\n    ret *= Fraction(d.den, d.num);\n    return ret;\n}\n\nostream& operator <<(ostream &os, const Fraction &f) {\n    return os << '(' << f.num << '/' << f.den << ')';\n}\n\nFraction calc_hour_sec_min(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < ah) as += Fraction(1);\n    while(am < as) am += Fraction(1);\n    while(as >= ah + Fraction(1)) as -= Fraction(1);\n    while(am > as + Fraction(1)) am -= Fraction(1);\n    //cout << ah << as << am << endl;\n    assert(ah <= as && as <= am);\n    // calc (as-ah)+x*(1/60-1/3600H) == (am-as)+x*(1/3600-1/60)\n    // is (1/60-1/3600H-1/3600+1/60)x = am-as-as+ah\n    const Fraction rhs = am - as - as + ah;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600*H) - Fraction(1,3600) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc_min_sec_hour(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < am) as += Fraction(1);\n    while(ah < as) ah += Fraction(1);\n    while(as >= am + Fraction(1)) as -= Fraction(1);\n    while(ah > as + Fraction(1)) ah -= Fraction(1);\n    assert(am <= as && as <= ah);\n    // calc (as-am)+x*(1/60-1/3600) == (ah-as)+x*(1/3600H-1/60)\n    // is (1/60-1/3600-1/3600H+1/60)x == ah-as-as+am\n    const Fraction rhs = ah - as - as + am;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600) - Fraction(1,3600*H) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc(int H, int h, int m, int s) {\n    Fraction ah = Fraction(h*3600 + m*60 + s, H*3600);\n    Fraction am = Fraction(m*60 + s, 3600);\n    Fraction as = Fraction(s, 60);\n    Fraction dmh = am - ah;\n    Fraction dsh = as - ah;\n    if(dmh.num < 0) dmh += Fraction(1);\n    if(dsh.num < 0) dsh += Fraction(1);\n    if(dmh > dsh) { // hour-sec-min\n        if(as < ah) as += Fraction(1);\n        if(am < as) am += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_hour_sec_min(H, ah, am, as);\n        } else {\n            // calc as+x/60 == am+x/3600\n            // is (1/60-1/3600)x == am-as\n            const Fraction tmp = (am - as) / (Fraction(1,60) - Fraction(1,3600));\n            const Fraction tmp2 = (ah - as + Fraction(1)) / (Fraction(1,60) - Fraction(1,3600*H));\n            if(tmp < tmp2) {\n                return tmp + calc_min_sec_hour(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n            } else {\n                return tmp2 + calc_hour_sec_min(H, ah+tmp2/(H*3600), am+tmp2/3600, as+tmp2/60);\n            }\n        }\n    } else if(dmh <= dsh) { // min-sec-hour\n        if(as < am) as += Fraction(1);\n        if(ah <= as) ah += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_min_sec_hour(H, ah, am, as);\n        } else {\n            // calc as+x/60 == ah+x/3600H\n            // is (1/60-1/3600H)x == ah-as\n            const Fraction tmp = (ah - as) / (Fraction(1,60) - Fraction(1,3600*H));\n            const Fraction tmp2 = (am - as + Fraction(1)) / (Fraction(1,60) - Fraction(1,3600));\n            if(tmp < tmp2) {\n                return tmp + calc_hour_sec_min(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n            } else {\n                return tmp2 + calc_min_sec_hour(H, ah+tmp2/(H*3600), am+tmp2/3600, as+tmp2/60);\n            }\n        }\n    }\n    assert(false);\n}\n\nbool solve() {\n    int H, h, m, s;\n    if(!(cin >> H >> h >> m >> s)) return false;\n    if(!H && !h && !m && !s) return false;\n\n    Fraction pass = calc(H, h, m, s);\n    //cout << pass << endl;\n    s += pass.num / pass.den;\n    pass -= Fraction(pass.num / pass.den);\n    m += s / 60;\n    s %= 60;\n    h += m / 60;\n    m %= 60;\n    h %= H;\n    if(h == 0 && m == 0 && s == 0 && pass == Fraction(0,1)) {\n        pass = calc(H, h, m, s);\n        s += pass.num / pass.den;\n        pass -= Fraction(pass.num / pass.den);\n        m += s / 60;\n        s %= 60;\n        h += m / 60;\n        m %= 60;\n        h %= H;\n    }\n    pass += Fraction(s);\n    cout << h << ' ' << m << ' ' << pass.num << ' ' << pass.den << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> Q;\n\npair<Q,Q> calcSec(int H, int h, int m){\n  pair<Q,Q> res;\n  bool f = false;\n  if( (h*3600 + m*60 + m*60*H ) < 20*H*180) f = true;\n\n  res.first = make_pair(h*3600 + m*60*(H+1), -H + 120*H - 1);\n  res.second = make_pair(h*3600 + m*60*(H+1) + (f?180:-180)*20*H, -H + 120*H - 1);\n \n  return res;\n}\n\nbool comp(Q a, Q b){\n  return a.first * b.second < a.second * b.first;\n}\n\nint main(){\n  int H,h,m,s;\n\n  while(cin >> H >> h >> m >> s, H){\n    for(;;){\n      pair<Q,Q> tmp = calcSec(H,h,m);\n      \n      Q res = make_pair(60,1);\n\n      if( (s*tmp.first.second <= tmp.first.first) && comp(tmp.first,res)\n\t  && (60*tmp.first.first != m*60*tmp.first.second + tmp.first.first) )res = tmp.first;\n      if( (s*tmp.second.second <= tmp.second.first) && comp(tmp.second,res)\n\t  && (60*tmp.second.first != m*60*tmp.second.second + tmp.second.first) )res = tmp.second;\n\n      if(res != Q(60,1)){\n\tif(res.first == 0){\n\t  cout << h << \" \" << m << \" \" << 0 << \" \" << 1 << endl;\n\t}else{\n\t  \n\t  int g = __gcd(res.first, res.second);\n\t  if(g==0)cout << \"hoge\" << endl;\n\t  else{\n\t    res.first /= g; res.second /= g;\n\t    cout << h << \" \" << m << \" \" << res.first << \" \" << res.second << endl;\n\t  }\n\t}\n\tbreak;\n      }\n      s = 0;\n      m++;\n      if(m==60)m = 0,h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> Q;\n\npair<Q,Q> calcSec(int H, int h, int m){\n  pair<Q,Q> res;\n  bool f = false;\n  if( (h*3600 + m*60 + m*60*H ) < 20*H*180) f = true;\n\n  res.first = make_pair(h*3600 + m*60*(H+1), -H + 120*H - 1);\n  res.second = make_pair(h*3600 + m*60*(H+1) + (f?180:-180)*20*H, -H + 120*H - 1);\n \n  return res;\n}\n\nbool comp(Q a, Q b){\n  return a.first * b.second < a.second * b.first;\n}\n\nint main(){\n  int H,h,m,s;\n\n  while(cin >> H >> h >> m >> s, H){\n    for(;;){\n      pair<Q,Q> tmp = calcSec(H,h,m);\n      \n      Q res = make_pair(60,1);\n      cerr << m << endl;\n      cerr << tmp.first.first << \" \"  << tmp.first.second << endl;\n      cerr << \" \" << 60*tmp.first.first << \" \" << m*60*tmp.first.second + tmp.first.first << endl;\n      cerr << tmp.second.first << \" \"  << tmp.second.second << endl;\n      cerr << \" \" << 60*tmp.second.first << \" \" << m*60*tmp.second.second + tmp.second.first << endl;\n\n      if( (s*tmp.first.second <= tmp.first.first) && comp(tmp.first,res)\n\t  && (60*tmp.first.first != m*60*tmp.first.second + tmp.first.first) )res = tmp.first;\n      if( (s*tmp.second.second <= tmp.second.first) && comp(tmp.second,res)\n\t  && (60*tmp.second.first != m*60*tmp.second.second + tmp.second.first) )res = tmp.second;\n\n      if(res != Q(60,1)){\n\tif(res.first == 0){\n\t  cout << h << \" \" << m << \" \" << 0 << \" \" << 1 << endl;\n\t}else{\n\t  int g = __gcd(res.first, res.second);\n\t  res.first /= g; res.second /= g;\n\t  cout << h << \" \" << m << \" \" << res.first << \" \" << res.second << endl;\n\t}\n\tbreak;\n      }\n      s = 0;\n      m++;\n      if(m==60)m = 0,h++;\n      if(h==H)h = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint H, h, m, n, d;\n// s=n/d\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  int mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  int hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  int mrad = 60*H*m*d+H*n;\n  int hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  int s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    int prem = m, preh = h;\n    int ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (int i = 0; i < (H-1)*60; i++) {\n      \tif (prem == m && d*s > n) continue;\n      \tn = i;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = i; ansd = H-1;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (int i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tint t = gcd(ansn, ansd);\n\tansn /= t; ansd /= t;\n\tif (ansn == 0) ansd = 1;\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint H, h, m, s;\n\nint main(){\n\twhile(cin >> H >> h >> m >> s, H || h || m || s){\n\t\tbool flg = true;\n\t\twhile(flg){\n\t\t\tint begin = h * 60 * 60 + m * 60 + s;\n\t\t\tint end = h * 60 * 60 + (m + 1) * 60;\n\t\t\t\n\t\t\tint nn = H * (120 * (h * 60 * 60 + m * 60) - h * 60 * 60);\n\t\t\tint dd = 119 * H - 1;\n\t\t\t//int nn = -120 * H * (h * 60 * 60 + m * 60) + H * (h * 60 * 60);\n\t\t\t//int dd = 1 - 119 * H;\n\t\t\tint aann = 1000000000;\n\t\t\tint aadd = 1;\n\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\tint nnn = nn - i * H * 60 * 60;\n\t\t\t\tif(( H * 60  - 1) * nnn == H * 60 * (h * 60 * 60 + m * 60) * dd) continue;\n\t\t\t\tif((H - 1) * nnn == H * (h * 60) * dd) continue;\n\t\t\t\tif(begin * dd <= nnn && nnn < end * dd){\n\t\t\t\t\tif((long)aann * dd  > (long)nnn  * aadd){\n\t\t\t\t\t\taann = nnn;\n\t\t\t\t\t\taadd = dd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(aann != 1000000000){\n\t\t\t\tint am = aann / aadd / 60;\n\t\t\t\tint ah = am / 60;\n\t\t\t\taann -= am * aadd * 60;\n\t\t\t\tint g = gcd(aann, aadd);\n\t\t\t\tcout << ah << \" \" << am % 60 << \" \" << (aann / g)  << \" \" << aadd / g << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = 0;\n\t\t\tm += 1;\n\t\t\tif(m == 60){\n\t\t\t\th = (h + 1) % H;\n\t\t\t\tm = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nlong long x, b, c, d;\n\nlong long GCD(long long a1, long long a2) {\n\tif (a1 < a2) { swap(a1, a2); }\n\tif (a2 == 0) { return a1; }\n\treturn GCD(a2, a1 % a2);\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> x >> b >> c >> d;\n\t\tif (x == 0 && b == 0 && c == 0 && d == 0) { break; }\n\t\tlong long v = x * 360 - x * 3 - 3;\n\t\tif (v % 3 == 0) { v /= 3; }\n\t\tlong long w = 3600 * x;\n\t\tlong long a = (b * 3600 + c * 60 + d)*v;\n\t\tlong long H = 3600 * v;\n\t\tlong long M = 60 * v;\n\t\tlong long S = v;\n\t\tfor (long long  h= 0; h <= v * x * 3600 * 2; h += w) {\n\t\t\tlong long i = h % (v*x * 3600);\n\t\t\tlong long HI = i;\n\t\t\tlong long MI = (i%H) * 60;\n\t\t\tif (h >= a && HI != MI) {\n\t\t\t\tlong long H1 = i / H;\n\t\t\t\tlong long M1 = (i / M) % 60;\n\t\t\t\tlong long S1 = i - (H1*H + M1*M);\n\n\t\t\t\tcout << H1 << ' ' << M1 << ' ' << S1 / GCD(S1, v) << ' ' << v / GCD(S1, v) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp);\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \":\" << p.second << \")\";\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\nll gcd(ll a, ll b) {\n    if (a > b) swap(a, b);\n    if (a == 0) return b;\n    return gcd(a, b % a);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        ll H, h, m, s; cin >> H >> h >> m >> s;\n        if (H == 0) break;\n\n        ll M = 119 * H - 1;\n\n        ll x = ((h * 60 + m) * 60 + s) * M;\n        ll n = (x-1) / (3600 * H) + 1;\n\n        ll y = 3600 * H * n;\n        ll hour = (y / M / 3600) % H;\n        ll minute = (y / M / 60) % 60;\n        ll sec = y % (60 * M);\n\n        ll d = M;\n        ll g = gcd(d, sec);\n        sec /= g, d /= g;\n\n        if (hour == 0 and minute == 0 and sec == 0) {\n            ++n;\n            ll y = 3600 * H * n;\n            ll hour = (y / M / 3600) % H;\n            ll minute = (y / M / 60) % 60;\n            ll sec = y % (60 * M);\n\n            ll d = M;\n            ll g = gcd(d, sec);\n            sec /= g, d /= g;\n\n            cout << hour << \" \" << minute << \" \" << sec << \" \" << d << endl;\n            continue;\n        }\n\n        cout << hour << \" \" << minute << \" \" << sec << \" \" << d << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: Clock Hands\n//Level: 4\n//Category: 数学,Math\n//Note:\n\n/**\n * 時計回りにみたとき、短針—秒針—長針のパターンか、長針—秒針—短針のパターンかを調べる。\n * 前者のとき、この向きで見て0.5∠短長より短針側に秒針がいるときは、方程式を計算することで解が求められる。\n * そうでない場合、いったん長針を追い越してから後者のパターンで計算する。\n * 後者の時も同様。\n *\n * オーダーは O(1)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a, LL b) {\n    if(a < b) swap(a, b);\n    while(b != 0) {\n        LL tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nLL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\nstruct Fraction {\n    LL num, den;\n    explicit Fraction(LL num) : num(num), den(1) { normalize(); }\n    Fraction(LL num, LL den) : num(num), den(den) { normalize(); }\n\n    Fraction& operator +=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num += f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator -=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num -= f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator *=(const Fraction &f) {\n        num *= f.num;\n        den *= f.den;\n        normalize();\n        return *this;\n    }\n\n    bool operator ==(const Fraction &f) const {\n        return (num == 0 && f.num == 0) || (num == f.num && den == f.den);\n    }\n\n    bool operator <(const Fraction &f) const {\n        return num * f.den < den * f.num;\n    }\n\n    bool operator >(const Fraction &f) const {\n        return num * f.den > den * f.num;\n    }\n\n    bool operator <=(const Fraction &f) const {\n        return *this < f || *this == f;\n    }\n\n    void normalize() {\n        LL g = abs(gcd(num, den));\n        num /= g;\n        den /= g;\n        if(den < 0) {\n            num = -num;\n            den = -den;\n        }\n        if(num == 0) den = 1;\n    }\n\n    Fraction strict() const {\n        return Fraction(num % den, den);\n    }\n};\n\nFraction operator +(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret += g;\n    return ret;\n}\n\nFraction operator -(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret -= g;\n    return ret;\n}\n\nFraction operator /(const Fraction &f, LL d) {\n    Fraction ret = f;\n    ret *= Fraction(1, d);\n    return ret;\n}\n\nFraction operator /(const Fraction &f, const Fraction &d) {\n    Fraction ret = f;\n    ret *= Fraction(d.den, d.num);\n    return ret;\n}\n\nostream& operator <<(ostream &os, const Fraction &f) {\n    return os << '(' << f.num << '/' << f.den << ')';\n}\n\nFraction calc_hour_sec_min(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < ah) as += Fraction(1);\n    while(am < as) am += Fraction(1);\n    while(as > ah + Fraction(1)) as -= Fraction(1);\n    while(am > as + Fraction(1)) am -= Fraction(1);\n    assert(ah <= as && as <= am);\n    // calc (as-ah)+x*(1/60-1/3600H) == (am-as)+x*(1/3600-1/60)\n    // is (1/60-1/3600H-1/3600+1/60)x = am-as-as+ah\n    const Fraction rhs = am - as - as + ah;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600*H) - Fraction(1,3600) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc_min_sec_hour(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < am) as += Fraction(1);\n    while(ah < as) ah += Fraction(1);\n    while(as > am + Fraction(1)) as -= Fraction(1);\n    while(ah > as + Fraction(1)) ah -= Fraction(1);\n    assert(am <= as && as <= ah);\n    // calc (as-am)+x*(1/60-1/3600) == (ah-as)+x*(1/3600H-1/60)\n    // is (1/60-1/3600-1/3600H+1/60)x == ah-as-as+am\n    const Fraction rhs = ah - as - as + am;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600) - Fraction(1,3600*H) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc(int H, int h, int m, int s) {\n    Fraction ah = Fraction(h*3600 + m*60 + s, H*3600);\n    Fraction am = Fraction(m*60 + s, 3600);\n    Fraction as = Fraction(s, 60);\n    Fraction dmh = am - ah;\n    Fraction dsh = as - ah;\n    if(dmh.num < 0) dmh += Fraction(1);\n    if(dsh.num < 0) dsh += Fraction(1);\n    if(dmh > dsh) { // hour-sec-min\n        if(as < ah) as += Fraction(1);\n        if(am < as) am += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_hour_sec_min(H, ah, am, as);\n        } else {\n            // calc as+x/60 == am+x/3600\n            // is (1/60-1/3600)x == am-as\n            const Fraction tmp = (am - as) / (Fraction(1,60) - Fraction(1,3600));\n            return tmp + calc_min_sec_hour(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    } else if(dmh <= dsh) { // min-sec-hour\n        if(as < am) as += Fraction(1);\n        if(ah <= as) ah += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_min_sec_hour(H, ah, am, as);\n        } else {\n            // calc as+x/60 == ah+x/3600H\n            // is (1/60-1/3600H)x == ah-as\n            const Fraction tmp = (ah - as) / (Fraction(1,60) - Fraction(1,3600*H));\n            return tmp + calc_hour_sec_min(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    }\n    assert(false);\n}\n\nbool solve() {\n    int H, h, m, s;\n    if(!(cin >> H >> h >> m >> s)) return false;\n    if(!H && !h && !m && !s) return false;\n\n    Fraction pass = calc(H, h, m, s);\n    //cout << pass << endl;\n    s += pass.num / pass.den;\n    pass -= Fraction(pass.num / pass.den);\n    m += s / 60;\n    s %= 60;\n    h += m / 60;\n    m %= 60;\n    h %= H;\n    if(h == 0 && m == 0 && s == 0 && pass == Fraction(0,1)) {\n        pass = calc(H, h, m, s);\n        s += pass.num / pass.den;\n        pass -= Fraction(pass.num / pass.den);\n        m += s / 60;\n        s %= 60;\n        h += m / 60;\n        m %= 60;\n        h %= H;\n    }\n    pass += Fraction(s);\n    cout << h << ' ' << m << ' ' << pass.num << ' ' << pass.den << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\n//  nd/de\nclass Fruction\n{\npublic:\n\tlong long int nd;\n\tlong long int de;\n\tvoid reduct() {\n\t\tif (nd) {\n\t\t\tbool ndminus = false;\n\t\t\tif (nd < 0) {\n\t\t\t\tndminus = true;\n\t\t\t\tnd = -nd;\n\t\t\t}\n\n\t\t\tconst long long int agcd(gcd(nd, de));\n\t\t\tde /= agcd;\n\t\t\tnd /= agcd;\n\t\t\tif (ndminus)nd = -nd;\n\t\t}\n\t\telse {\n\t\t\tde = 1;\n\t\t}\n\t}\n\tFruction() :nd(0), de(1) {\n\n\t}\n\tvoid initialize() {\n\t\tif (de < 0) {\n\t\t\tde = -de;\n\t\t\tnd = -nd;\n\t\t}\n\t\treduct();\n\t\t\n\t}\n\tFruction(const long long int nd_,const long long int de_) \n\t\t:nd(nd_), de(de_) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int nd_, const Fruction de_) :\n\t\tnd(nd_*de_.de), de(de_.nd) {\n\t\tinitialize();\n\t}\n\tFruction(const Fruction nd_, const long long int de_) :\n\t\tnd(nd_.nd), de(nd_.de*de) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int num):nd(num),de(1) {\n\t}\n\tFruction(const Fruction& f) :de(f.de), nd(f.nd) {\n\n\t}\n\tpair<long long int, Fruction>mixed() {\n\t\tlong long int num = nd / de;\n\t\treturn make_pair(num, Fruction(nd - de*num, de));\n\t}\n};\nFruction operator-(const Fruction&f) {\n\treturn Fruction(-f.nd, f.de);\n}\nFruction operator+(const Fruction&l, const Fruction&r) {\n\tlong long int nede = lca(l.de, r.de);\n\tlong long int nend = l.nd*(nede / l.de) + r.nd*(nede / r.de);\n\treturn Fruction(nend, nede);\n}\nFruction operator-(const Fruction&l, const Fruction&r) {\n\treturn l+(-r);\n}\nFruction operator*(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.nd;\n\tlong long int nede = l.de*r.de;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator*(const Fruction&l, const long long int&r) {\n\treturn l*Fruction(r, 1);\n}\nFruction operator*(const long long int &l, const Fruction&r) {\n\treturn Fruction(l, 1)*r;\n}\nFruction operator/(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.de;\n\tlong long int nede = l.de*r.nd;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator/(const Fruction&l, const long long int&r) {\n\treturn l / Fruction(r, 1);\n}\nFruction operator/(const long long int&l, const Fruction&r) {\n\treturn Fruction(l,1) / r;\n}\n\nbool operator<(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de < r.nd*l.de;\n}\nbool operator<=(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de <= r.nd*l.de;\n}\nbool operator==(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de == r.nd*l.de;\n}\nbool operator>(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de > r.nd*l.de;\n}\nbool operator>=(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de >= r.nd*l.de;\n}\n\nint main() {\n\twhile (1) {\n\t\tint T, H, M, S; cin >> T >> H >> M >> S;\n\t\tif (!T)break;\n\t\tint total = T*60*60;\n\t\tint ntime = H * 3600 + M * 60 + S;\n\t\tif (!T)break;\n\t\tFruction speeds[3];\n\t\tspeeds[0] = Fruction(1, T * 60 * 60);\n\t\tspeeds[1] = Fruction(1, 60 * 60);\n\t\tspeeds[2] = Fruction(1, 60);\n\t\tFruction now[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tnow[i] = Fruction(speeds[i] * ntime);\n\t\t\tnow[i] = now[i].mixed().second;\n\t\t}\n\t\tFruction ans(1e9,1);\n\t\tfor (int i = 0; i < 1; ++i) {\n\t\t\tFruction dspeed = -(speeds[i] + speeds[(i + 1) % 3]) / 2 + speeds[(i + 2) % 3];\n\t\t\tFruction dkaku = (now[i] + now[(i + 1) % 3]) / 2 - now[(i + 2) % 3];\n\t\t\tif (dspeed < 0) {\n\t\t\t\tdkaku = -dkaku;\n\t\t\t\tdspeed = -dspeed;\n\t\t\t}\n\t\t\tfor (int j = -49; j < 50; ++j) {\n\t\t\t\tFruction nans = (dkaku +  j* Fruction(1, 2)) / dspeed;\n\t\t\t\tFruction next[3];\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tnext[k] = now[k] + nans*speeds[k];\n\t\t\t\t\tnext[k] = next[k].mixed().second;\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (next[k] == next[(k + 1) % 3])ok = false;\n\t\t\t\t}\n\t\t\t\tif (nans >= Fruction(0,1)) {\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tans = min(ans, nans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<long long int, Fruction>p(ans.mixed());\n\t\tlong long int fintime = ntime + p.first;\n\t\tfintime %= T * 60 * 60;\n\t\tconst int nh = fintime / 3600;\n\t\tfintime -= nh * 3600;\n\t\tconst int nm = fintime / 60;\n\t\tfintime -= nm * 60;\n\t\tFruction ns(fintime*p.second.de + p.second.nd, p.second.de);\n\t\tcout << nh << \" \" << nm << \" \" << ns.nd << \" \" << ns.de << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 60;\nconst int S = 60;\nint H, h, m, s;\n\n/*\n  (?§??????????)\n  ?§?????§???? = 6s\n  ???????§???? = 1/10 * (60m + s)\n  ???????§???? = 1/(10H) * (3600h + 60m + s)\n\n  ???????§???? - ?§?????§???? == ?§?????§???? - ???????§???? ?????????\n  s = (3600h + (1+H)60m) / (119H - 1)\n  ?????£???????????????119H-1 ??\n\n  ?????°???????????????????????¢????????????????????§???????????§???????????????????????????????????£??¨?????????????????£???????°?????????????\n */\n\nbool is_same_deg(const int &sa, const int &sb){\n  //s??§??????sa????????§????????????sb??????????????????\n  int h_s = 3600*h*sb + 60*m*sb + sa - 60*H*sa; //?????°?????????????????????10*H??????????????????\n  int s_m = 60*H*sa - 60*H*m*sb - H*sa; //?????°?????????????????????10*H??????????????????\n  if(h_s < 0) h_s += 360 * 10*H*sb;\n  if(s_m < 0) s_m += 360 * 10*H*sb;\n  return abs(h_s) == abs(s_m);\n}\n\nbool is_overlap(const int &sa, const int &sb){\n  int h_deg_mul10h = 3600*h*sb + 60*m*sb + sa;\n  int s_deg = 6*h*sb;\n  int m_deg_mul10 = 60*m*sb + sa;\n  return (s_deg*10*H == h_deg_mul10h || s_deg*10 == m_deg_mul10);\n}\n\nvoid solve(){\n  int sa, sb = 119 * H - 1;\n  sa = s * sb;\n  // 1 / (119H-1) ?§??????????????????¨??¢?´¢\n  for(int i=0;i<H*M*S*sb;i++){\n    if(is_same_deg(sa, sb) && !is_overlap(sa, sb)){\n      int g = __gcd(sa, sb);\n      cout << h << ' ' << m << ' ' << sa/g << ' ' << sb/g << endl;\n      return;\n    }\n    \n    // failed\n    sa++;\n    if(sa >= S * sb){\n      sa -= S * sb;\n      m++;\n      if(m >= M){\n        m -= M;\n        h++;\n        if(h >= H){\n          h = m = sa = 0;\n        }\n      }\n    }\n  }\n\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> H >> h >> m >> s && (H|h|m|s)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint H, h, m, s;\n\n//! x / y\nclass Frac{\npublic:\n  using LL = long long;\n  LL x, y;\n\n  Frac(LL x = 0, LL y = 1) : x(x), y(y) { red(); }\n\n  LL gcd(LL x, LL y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n  }\n  \n  void red(){\n\tif(x == 0){\n\t  y = 1;\n\t  return;\n\t}\n\tif(y < 0){\n\t  x *= -1;\n\t  y *= -1;\n\t}\n\t\n\tLL g = gcd(abs(x), y);\n\tx /= g;\n\ty /= g;\n  }\n\n  Frac& operator += (const Frac& p){ x = x * p.y + y * p.x; y *= p.y; red(); return *this;}\n  Frac operator + (const Frac& p) const{ Frac q = *this;return q += p;}\n  Frac operator - () const { Frac q = *this; q.x *= -1; return q; }\n  Frac& operator -= (const Frac& p){ Frac q = -p; *this += q; return *this;}\n  Frac operator - (const Frac& p) const{ Frac q = *this; return q -= p;}\n  Frac& operator *= (const Frac& a){ x *= a.x; y *= a.y; red(); return *this;}\n  Frac operator * (Frac a) const{ Frac q = *this; return q *= a;}\n  Frac& operator /= (const Frac& a){ x *= a.y; y *= a.x; red(); return *this;}\n  Frac operator / (Frac a) const{ Frac q = *this; return q /= a;}\n\n  bool operator < (const Frac &p) const{\n\treturn x * p.y < y * p.x;\n  }\n  bool operator <= (const Frac &p) const{\n\treturn *this < p || *this == p;\n  }\n  bool operator > (const Frac &p) const{\n\treturn p < *this;\n  }\n  bool operator >= (const Frac &p) const{\n\treturn *this > p || *this == p;\n  }\n  bool operator == (const Frac &p) const {\n\treturn x == p.x && y == p.y;\n  }\n  double getR() const { return x * 1. / y; }\n  friend ostream& operator <<(ostream& os, const Frac& p);\n};\nFrac abs(const Frac& q){ return Frac(abs(q.x), q.y); }\nostream& operator <<(ostream& os, const Frac& p){\n  return os << p.x << \"/\" << p.y;\n}\n\nvoid norm(Frac& t){\n  if(t.x < 0) t += 3600*H;\n  while(t >= 60 * 60 * H)\n\tt -= 60 * 60 * H;\n}\n\nvoid normR(Frac& t){\n  if(t.x < 0) t += 360;\n  while(t >= 360)\n\tt -= 360;\n}\n\nFrac dist(Frac& now, Frac& dst){\n  if(now <= dst) return dst - now;\n  return dst + 3600*H - now;\n}\n\nvoid print(Frac& ans){\n  LL ah = ans.x / ans.y / 60 / 60;\n  LL am = ans.x / ans.y / 60 % 60;\n  Frac as = ans - ah*3600 - am*60;\n  cout << ah << \" \" << am << \" \" << as.x << \" \" << as.y << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>h>>m>>s,H){\n\tFrac now(h*3600+m*60+s);\n\t\n\tFrac ans(1e9, 1), ans_dt(1e9, 1);\n\tREP(th,H) REP(tm,60){\n\t  for(int s1=-1;s1<=1;s1+=2){\n\t\tfor(int s2=-1;s2<=1;s2+=2){\n\t\t  Frac c1(3600*th + 60*tm, 10*H);\n\t\t  Frac a1 = Frac(1, 10*H) - 6;\n\t\t  Frac c2(6*tm);\n\t\t  Frac a2 = Frac(1, 10) - 6;\n\n\t\t  for(int ang=0;ang<=360;ang+=360){\n\t\t\tFrac ss = (c2 * s2 - c1 * s1 + ang) / (a1 * s1 - a2 * s2);\n\n\t\t\tFrac rh = c1 + ss / (10*H);\n\t\t\tnormR(rh);\n\t\t\tFrac rm = c2 + ss / 10;\n\t\t\tnormR(rm);\n\t\t\tFrac rs = ss * 6;\n\t\t\tnormR(rs);\n\t\t\tif(rh == rm || rh == rs || rm == rs) continue;\n\t\t\tFrac nxt = ss + 3600*th + 60*tm;\n\t\t\tnorm(nxt);\n\t\t\tFrac dd = dist(now, nxt);\n\t\t\tif(dd < ans_dt){\n\t\t\t  ans_dt = dd;\n\t\t\t  ans = nxt;\n\t\t\t}\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tprint(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Clock Hands\n//Level: 4\n//Category: 数学,Math\n//Note:\n\n/**\n * 時計回りにみたとき、短針—秒針—長針のパターンか、長針—秒針—短針のパターンかを調べる。\n * 前者のとき、この向きで見て0.5∠短長より短針側に秒針がいるときは、方程式を計算することで解が求められる。\n * そうでない場合、いったん長針を追い越してから後者のパターンで計算する。\n * 後者の時も同様。\n *\n * オーダーは O(1)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a, LL b) {\n    if(a < b) swap(a, b);\n    while(b != 0) {\n        LL tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nLL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\nstruct Fraction {\n    LL num, den;\n    explicit Fraction(LL num) : num(num), den(1) { normalize(); }\n    Fraction(LL num, LL den) : num(num), den(den) { normalize(); }\n\n    Fraction& operator +=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num += f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator -=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num -= f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator *=(const Fraction &f) {\n        num *= f.num;\n        den *= f.den;\n        normalize();\n        return *this;\n    }\n\n    bool operator ==(const Fraction &f) const {\n        return (num == 0 && f.num == 0) || (num == f.num && den == f.den);\n    }\n\n    bool operator <(const Fraction &f) const {\n        return num * f.den < den * f.num;\n    }\n\n    bool operator >(const Fraction &f) const {\n        return num * f.den > den * f.num;\n    }\n\n    bool operator <=(const Fraction &f) const {\n        return *this < f || *this == f;\n    }\n\n    void normalize() {\n        LL g = abs(gcd(num, den));\n        num /= g;\n        den /= g;\n        if(den < 0) {\n            num = -num;\n            den = -den;\n        }\n    }\n\n    Fraction strict() const {\n        return Fraction(num % den, den);\n    }\n};\n\nFraction operator +(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret += g;\n    return ret;\n}\n\nFraction operator -(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret -= g;\n    return ret;\n}\n\nFraction operator /(const Fraction &f, LL d) {\n    Fraction ret = f;\n    ret *= Fraction(1, d);\n    return ret;\n}\n\nFraction operator /(const Fraction &f, const Fraction &d) {\n    Fraction ret = f;\n    ret *= Fraction(d.den, d.num);\n    return ret;\n}\n\nostream& operator <<(ostream &os, const Fraction &f) {\n    return os << '(' << f.num << '/' << f.den << ')';\n}\n\nFraction calc_hour_sec_min(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < ah) as += Fraction(1);\n    while(am < as) am += Fraction(1);\n    assert(ah <= as && as <= am);\n    // calc (as-ah)+x*(1/60-1/3600H) == (am-as)+x*(1/3600-1/60)\n    // is (1/60-1/3600H-1/3600+1/60)x = am-as-as+ah\n    const Fraction rhs = am - as - as + ah;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600*H) - Fraction(1,3600) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc_min_sec_hour(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    while(as < am) as += Fraction(1);\n    while(ah < as) ah += Fraction(1);\n    assert(am <= as && as <= ah);\n    // calc (as-am)+x*(1/60-1/3600) == (ah-as)+x*(1/3600H-1/60)\n    // is (1/60-1/3600-1/3600H+1/60)x == ah-as-as+am\n    const Fraction rhs = ah - as - as + am;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600) - Fraction(1,3600*H) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc(int H, int h, int m, int s) {\n    Fraction ah = Fraction(h*3600 + m*60 + s, H*3600);\n    Fraction am = Fraction(m*60 + s, 3600);\n    Fraction as = Fraction(s, 60);\n    Fraction dmh = am - ah;\n    Fraction dsh = as - ah;\n    if(dmh.num < 0) dmh += Fraction(1);\n    if(dsh.num < 0) dsh += Fraction(1);\n    if(dmh > dsh) { // hour-sec-min\n        if(as < ah) as += Fraction(1);\n        if(am < as) am += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_hour_sec_min(H, ah, am, as);\n        } else {\n            // calc as+x/60 == am+x/3600\n            // is (1/60-1/3600)x == am-as\n            const Fraction tmp = (am - as) / (Fraction(1,60) - Fraction(1,3600));\n            return tmp + calc_min_sec_hour(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    } else if(dmh <= dsh) { // min-sec-hour\n        if(as < am) as += Fraction(1);\n        if(ah <= as) ah += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_min_sec_hour(H, ah, am, as);\n        } else {\n            // calc as+x/60 == ah+x/3600H\n            // is (1/60-1/3600H)x == ah-as\n            const Fraction tmp = (ah - as) / (Fraction(1,60) - Fraction(1,3600*H));\n            return tmp + calc_hour_sec_min(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    }\n    assert(false);\n}\n\nbool solve() {\n    int H, h, m, s;\n    if(!(cin >> H >> h >> m >> s)) return false;\n    if(!H && !h && !m && !s) return false;\n\n    Fraction pass = calc(H, h, m, s);\n    //cout << pass << endl;\n    s += pass.num / pass.den;\n    pass -= Fraction(pass.num / pass.den);\n    m += s / 60;\n    s %= 60;\n    h += m / 60;\n    m %= 60;\n    h %= H;\n    if(h == 0 && m == 0 && s == 0 && pass == Fraction(0,1)) {\n        pass = calc(H, h, m, s);\n        s += pass.num / pass.den;\n        pass -= Fraction(pass.num / pass.den);\n        m += s / 60;\n        s %= 60;\n        h += m / 60;\n        m %= 60;\n        h %= H;\n    }\n    pass += Fraction(s);\n    cout << h << ' ' << m << ' ' << pass.num << ' ' << pass.den << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// by team2\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <math.h>\n#include <stack>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (n); ++i)\n#define FOREACH(i,c) for (__typeof(c.begin()) i = c.begin(); i != c.end(); ++i)\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nint gcd(int a,int b) {\n\tfor(int t; b; t=a,a=b,b=t%a);\n\treturn a;\n}\n\nint Div, H, h, m, s;\n\nbool check(int A,int B) {\n\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\tint w1 = 1, w2 = H, w3 = H*60;\n\tLL X = ((LL)t1 * B + (LL)w1 * A)%((LL)B*Div);\n\tLL Y = ((LL)t2 * B + (LL)w2 * A)%((LL)B*Div);\n\tLL Z = ((LL)t3 * B + (LL)w3 * A)%((LL)B*Div);\n\treturn (X != Y && Y != Z && Z != X);\n}\n\nint main() {\n\twhile(~scanf(\"%d%d%d%d\", &H, &h, &m, &s)) {\n\t\tif(!H&&!h&&!m&&!s) break;\n\t\tDiv = 3600 * H;\n\t\tint t1 = h*3600+m*60+s, t2 = m*(60*H)+s*H, t3 = s*(60*H);\n\t\tint w1 = 1, w2 = H, w3 = H*60;\n\t\tint A = 2 * t3 - t1 - t2;\n\t\tint B = w1 + w2 - 2 * w3;\n\t\tif(B < 0) B = -B, A = -A;\n\t\tA = (A % Div + Div) % Div;\n\t\twhile(!check(A, B)) A += Div;\n\t\tint g = gcd(A, B); A/=g, B/=g;\n\t\t\n\t\tlong long T = A + h * (B*3600) + m * (B*60) + s*B;\n\t\tint _h = T / (B * 3600) % H;\n\t\tint _m = T % (B * 3600) / (B * 60);\n\t\tint _s = T % (B * 60);\n\t\tprintf(\"%d %d %d %d\\n\", _h, _m, _s, B);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint H, h, m, s;\n\n//! x / y\nclass Frac{\npublic:\n  using LL = long long;\n  LL x, y;\n\n  Frac(LL x = 0, LL y = 1) : x(x), y(y) { red(); }\n\n  LL gcd(LL x, LL y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n  }\n  \n  void red(){\n\tif(x == 0){\n\t  y = 1;\n\t  return;\n\t}\n\tif(y < 0){\n\t  x *= -1;\n\t  y *= -1;\n\t}\n\t\n\tLL g = gcd(abs(x), y);\n\tx /= g;\n\ty /= g;\n  }\n\n  Frac& operator += (const Frac& p){ x = x * p.y + y * p.x; y *= p.y; red(); return *this;}\n  Frac operator + (const Frac& p) const{ Frac q = *this;return q += p;}\n  Frac operator - () const { Frac q = *this; q.x *= -1; return q; }\n  Frac& operator -= (const Frac& p){ Frac q = -p; *this += q; return *this;}\n  Frac operator - (const Frac& p) const{ Frac q = *this; return q -= p;}\n  Frac& operator *= (const Frac& a){ x *= a.x; y *= a.y; red(); return *this;}\n  Frac operator * (Frac a) const{ Frac q = *this; return q *= a;}\n  Frac& operator /= (const Frac& a){ x *= a.y; y *= a.x; red(); return *this;}\n  Frac operator / (Frac a) const{ Frac q = *this; return q /= a;}\n\n  bool operator < (const Frac &p) const{\n\treturn x * p.y < y * p.x;\n  }\n  bool operator <= (const Frac &p) const{\n\treturn *this < p || *this == p;\n  }\n  bool operator > (const Frac &p) const{\n\treturn p < *this;\n  }\n  bool operator >= (const Frac &p) const{\n\treturn *this > p || *this == p;\n  }\n  bool operator == (const Frac &p) const {\n\treturn x == p.x && y == p.y;\n  }\n  double getR() const { return x * 1. / y; }\n  friend ostream& operator <<(ostream& os, const Frac& p);\n};\nFrac abs(const Frac& q){ return Frac(abs(q.x), q.y); }\nostream& operator <<(ostream& os, const Frac& p){\n  return os << p.x << \"/\" << p.y;\n}\n\nvoid norm(Frac& t){\n  if(t.x < 0) t += 3600*H;\n  while(t >= 60 * 60 * H)\n\tt -= 60 * 60 * H;\n}\n\nvoid normR(Frac& t){\n  if(t.x < 0) t += 360;\n  while(t >= 360)\n\tt -= 360;\n}\n\nFrac dist(Frac& now, Frac& dst){\n  if(now <= dst) return dst - now;\n  return dst + 3600*H - now;\n}\n\nvoid print(Frac& ans){\n  LL ah = ans.x / ans.y / 60 / 60;\n  LL am = ans.x / ans.y / 60 % 60;\n  Frac as = ans - ah*3600 - am*60;\n  cout << ah << \" \" << am << \" \" << as.x << \" \" << as.y << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>h>>m>>s,H){\n\tFrac now(h*3600+m*60+s);\n\t\n\tFrac ans(1e9, 1), ans_dt(1e9, 1);\n\tREP(th,H) REP(tm,60){\n\t  for(int s1=-1;s1<=1;s1+=2){\n\t\tfor(int s2=-1;s2<=1;s2+=2){\n\t\t  Frac c1(3600*th + 60*tm, 10*H);\n\t\t  Frac a1 = Frac(1, 10*H) - 6;\n\t\t  Frac c2(6*tm);\n\t\t  Frac a2 = Frac(1, 10) - 6;\n\n\t\t  for(int ang=0;ang<=360;ang+=360){\n\t\t\tFrac ss = (c2 * s2 - c1 * s1 + ang) / (a1 * s1 - a2 * s2);\n\n\t\t\tFrac rh = c1 + ss / (10*H);\n\t\t\tnormR(rh);\n\t\t\tFrac rm = c2 + ss / 10;\n\t\t\tnormR(rm);\n\t\t\tFrac rs = ss * 6;\n\t\t\tnormR(rs);\n\t\t\tif(rh == rm || rh == rs || rm == rs) continue;\n\t\t\tFrac nxt = ss + 3600*th + 60*tm;\n\t\t\tnorm(nxt);\n\t\t\tFrac dd = dist(now, nxt);\n\t\t\tif(dd < ans_dt){\n\t\t\t  ans_dt = dd;\n\t\t\t  ans = nxt;\n\t\t\t}\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tLL ah = ans.x / ans.y / 60 / 60;\n\tLL am = ans.x / ans.y / 60 % 60;\n\tFrac as = ans - ah*3600 - am*60;\n\tcout << ah << \" \" << am << \" \" << as.x << \" \" << as.y << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint H, h, m, n, d;\n// s=n/d\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\n// ?????????2?????????????????????\nbool sameWrong() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  // srad = min(srad, tt-srad);\n  int mrad = 60*H*m*d+H*n;\n  // mrad = min(mrad, tt-mrad);\n  int hrad = 60*60*h*d+60*m*d+n;\n  // hrad = min(hrad, tt-hrad);\n\n  return (srad == mrad) || (mrad == hrad) || (srad == hrad);\n}\n\n// ?§??????¨??????????§??????¨??????????§?????????????????????????\nbool same3() {\n  int tt = 60*60*H*d;\n  int srad = 60*H*n;\n  int mrad = 60*H*m*d+H*n;\n  int hrad = 60*60*h*d+60*m*d+n;\n  return min(abs(srad-mrad), tt-abs(srad-mrad)) == min(abs(hrad-srad), tt-abs(hrad-srad));\n}\n\nint main() {\n  int s;\n  while (true) {\n    cin >> H >> h >> m >> s;\n    if (H == 0 && h == 0 && m == 0 && s == 0) break;\n\n    int prem = m, preh = h;\n    int ansn, ansd;\n    while (true) {\n      ansn = ansd = -1;\n      n = 0;\n      d = H-1;\n      for (int i = 0; i < (H-1)*60; i++) {\n      \tif (prem == m && d*s > n) continue;\n      \tn = i;\n      \tif (!sameWrong() && same3()) {\n      \t  ansn = i; ansd = H-1;\n      \t  break;\n      \t}\n      }\n      n = 0;\n      d = 119*H-1;\n      for (int i = 0; i < (119*H-1)*60; i++) {\n\tn = i;\n\tif (prem == m && d*s > n) continue;\n\tif (!sameWrong() && same3() && (ansn == -1 || (ansn != -1 && ansn*d > n*ansd))) {\n\t  ansn = n; ansd = d;\n\t  break;\n\t}\n      }\n\n      if (ansn != -1) {\n\tint t = gcd(n, d);\n\tansn /= t; ansd /= t;\n\tif (ansn == 0) ansd = 1;\n\tcout << h << \" \" << m << \" \" << ansn << \" \" << ansd << endl;\n\tbreak;\n      }\n      m++;\n      if (m == 60) {\n\tm = 0;\n\th++;\n\tif (h == H) {\n\t  h = 0;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> f(int H,int h,int m){\n  int n=60*h+(1+H)*m;\n  int ad=60*H;\n  vector<int> cand;\n  if((n>=ad)){\n    cand.assign({n-ad,n});\n  }else{\n    cand.assign({n,n+ad});\n  }\n  vector<int> r;\n  for(auto e:cand){\n    int D=119*H-1;\n    if((H-1)*(D*m+e)==60*D*h)continue;\n    r.push_back(e);\n  }\n  return r;\n}\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nvoid output(int h,int m,int ns,int d,int H){\n  while(ns>=d){\n    ns-=d;\n    m++;\n    if(m==60){\n      m=0;\n      h++;\n      if(h==H){\n\th=0;\n      }\n    }\n  }\n  int s=ns*60;\n  if(s==0){\n    d=1;\n  }else{\n    int g=gcd(s,d);\n    s/=g;\n    d/=g;\n  }\n  cout<<h<<' '<<m<<' '<<s<<' '<<d<<endl;\n}\n \nint main(){\n  for(int H,h,m,s;cin>>H>>h>>m>>s,H|h|m|s;){\n    auto r=f(H,h,m);\n    int d=119*H-1;\n    for(auto e:r){\n      if(e*60>=s*d){\n\toutput(h,m,e,d,H);\n\tgoto next;\n      }\n    }\n    s=0;\n    m++;\n    if(m==60){\n      m=0;\n      h++;\n      if(h==H){\n\th=0;\n      }\n    }\n    output(h,m,f(H,h,m)[0],d,H);\n  next:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint H, h, m, s;\n\nint main(){\n\twhile(cin >> H >> h >> m >> s, H || h || m || s){\n\t\tbool flg = true;\n\t\twhile(flg){\n\t\t\tint begin = h * 60 * 60 + m * 60 + s;\n\t\t\tint end = h * 60 * 60 + (m + 1) * 60;\n\t\t\t\n\t\t\tint nn = H * (120 * (h * 60 * 60 + m * 60) - h * 60 * 60);\n\t\t\tint dd = 119 * H - 1;\n\t\t\t//int nn = -120 * H * (h * 60 * 60 + m * 60) + H * (h * 60 * 60);\n\t\t\t//int dd = 1 - 119 * H;\n\t\t\tint aann = 1000000000;\n\t\t\tint aadd = 1;\n\t\t\tfor(int i = -1; i <= 1; i++){\n\t\t\t\tint nnn = nn - i * H * 60 * 60;\n\t\t\t\tif(( H * 60  - 1) * nnn == H * 60 * (h * 60 * 60 + m * 60) * dd) continue;\n\t\t\t\tif((H - 1) * nnn == H * (h * 60 * 60) * dd) continue;\n\t\t\t\tif(begin * dd <= nnn && nnn < end * dd){\n\t\t\t\t\tif((long)aann * dd  > (long)nnn  * aadd){\n\t\t\t\t\t\taann = nnn;\n\t\t\t\t\t\taadd = dd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(aann != 1000000000){\n\t\t\t\tint am = aann / aadd / 60;\n\t\t\t\tint ah = am / 60;\n\t\t\t\taann -= am * aadd * 60;\n\t\t\t\tint g = gcd(aann, aadd);\n\t\t\t\tcout << ah << \" \" << am % 60 << \" \" << (aann / g)  << \" \" << aadd / g << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = 0;\n\t\t\tm += 1;\n\t\t\tif(m == 60){\n\t\t\t\th = (h + 1) % H;\n\t\t\t\tm = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Real{\n\n\tlong long top, bot;\n\n\tReal(long long top, long long bot) : top(top), bot(bot) {\n\t\tnormalize();\n\t}\n\n\tlong long gcd(long long a, long long b){\n\t\tif(!a || !b) return a+b;\n\t\tif(a < b) return gcd(b, a);\n\t\treturn gcd(b, a%b);\n\t}\n\n\tvoid normalize(){\n\t\tint divisor = gcd(top, bot);\n\t\ttop /= divisor;\n\t\tbot /= divisor;\n\t}\n\n\tReal operator+(const Real& rhs){\n\t\treturn Real(top*rhs.bot+rhs.top*bot, bot*rhs.bot);\n\t}\n\n\tReal operator+(long long x){\n\t\treturn Real(top + x*bot, bot);\n\t}\n\n\tReal operator-(const Real& rhs){\n\t\treturn Real(top*rhs.bot-rhs.top*bot, bot*rhs.bot);\n\t}\n\n\tReal operator*(const Real& rhs){\n\t\treturn Real(top*rhs.top, bot*rhs.bot);\n\t}\n\n\tReal operator*(long long x){\n\t\treturn Real(top*x, bot);\n\t}\n\n\tReal operator/(const Real& rhs){\n\t\treturn Real(top*rhs.bot, bot*rhs.top);\n\t}\n\n\tReal operator/(long long x){\n\t\treturn Real(top, bot*x);\n\t}\n\n\tReal operator%(long long x){\n\t\treturn Real(top % (x*bot), bot);\n\t}\n\n\tbool operator==(Real rhs){\n\t\treturn top*rhs.bot == rhs.top*bot;\n\t}\n\n\tbool operator<(const Real& rhs) const{\n\t\treturn top*rhs.bot < rhs.top*bot;\n\t}\n\n\tlong long toInt(){\n\t\treturn top / bot;\n\t}\n\n\tdouble toDouble(){\n\t\treturn (double)top / bot;\n\t}\n\n};\n\nint main() {\n\twhile(true){\n\t\tint H, h, m, s;\n\t\tscanf(\"%d %d %d %d\", &H, &h, &m, &s);\n\t\tif(!H && !h && !m && !s) break;\n\t\tReal speedH = Real(1, 10*H);\n\t\tReal speedM = Real(1, 10);\n\t\tReal speedAvg = (speedH + speedM) / 2;\n\t\tReal speedS = Real(6, 1);\n\t\tlong long past = 3600*h + 60*m + s;\n\t\tReal positionAvg = speedAvg * past % 360;\n\t\tReal positionS = speedS * past % 360;\n//\t\tprintf(\"posAvg : %f, posS : %f\\n\", positionAvg.toDouble(), positionS.toDouble());\n\t\tReal distance = min((positionAvg+540-positionS)%360, (positionAvg+360-positionS)%360);\n//\t\tprintf(\"dist : %f\\n\", distance.toDouble());\n\t\tReal final = distance / (speedS - speedAvg) + past;\n\t\tif(speedH*final%360 == speedM*final%360 && speedM*final%360 == speedS*final%360){\n\t\t\tdistance = (distance+180)%360;\n\t\t\tfinal = distance / (speedS - speedAvg) + past;\n\t\t}\n//\t\tprintf(\"past : %lld, final : %f\\n\", past, (double)final.top / final.bot);\n\t\tfinal = final % (H * 3600);\n\t\tlong long Hour = final.toInt() / 3600;\n\t\tfinal = final + Hour*-3600;\n\t\tlong long Minute = final.toInt() / 60;\n\t\tfinal = final + Minute*-60;\n\n\t\tprintf(\"%lld %lld %lld %lld\\n\", Hour, Minute, final.top, final.bot);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;\n\t\tint c=a;\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a){\n//\t\tif(b==0&&c==0&&d==0)d++;\n\t\tint C=c;\n\t\tint D=d;\n\t\tint B=b;\n\t\twhile(1){\n\t\tc=C;\n\t\td=D;\n\t\tb=B;\n\t\tint M=a*(60*c+d-60*d);\n\t\tint H=3600*b+60*c+d-a*60*d;\n\t\tint W=M+H;\n\t\twhile(W<0){\n\t\t\tW+=3600*a;\n\t\t}\n\t\twhile(W>=3600*a){\n\t\t\tW-=3600*a;\n\t\t}\n\t\t//printf(\"%d\\n\",W);\n\n\t\tint sb=119*a-1;\n\t\tint ss=W+sb*d;\n\t\t//printf(\"%d %d %d: %d %d\\n\",b,c,d,W,ss);\n\t\twhile(sb*60<=ss){\n\t\t\tss-=sb*60;\n\t\t\tc++;\n\t\t}\n\t\twhile(c>=60){\n\t\t\tc-=60;\n\t\t\tb++;\n\t\t}\n\t\tb%=a;\n\t\tif( 60*ss!=60*c*sb+ss\n\t\t&& 60*(ss-30*sb)!=60*c*sb+ss\n\t\t&& 60*(ss+30*sb)!=60*c*sb+ss){\n\t\t\t\tprintf(\"%d %d %d %d\\n\",b,c,ss/gcd(ss,sb),sb/gcd(ss,sb));\n\t\t\tbreak;\n\t\t}\n\t\tB=b;\n\t\tC=c;\n\t\tD=ss/sb+1;\n\t\t}\n\n\t//\tprintf(\"%d %d %d %d\\n\",);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Clock Hands\n//Level: 3\n//Category: 数学,Math\n//Note:\n\n/**\n * 時計回りにみたとき、短針—秒針—長針のパターンか、長針—秒針—短針のパターンかを調べる。\n * 前者のとき、この向きで見て0.5∠短長より短針側に秒針がいるときは、方程式を計算することで解が求められる。\n * そうでない場合、いったん長針を追い越してから後者のパターンで計算する。\n * 後者の時も同様。\n *\n * オーダーは O(1)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL gcd(LL a, LL b) {\n    if(a < b) swap(a, b);\n    while(b != 0) {\n        LL tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nLL lcm(LL a, LL b) {\n    return a / gcd(a, b) * b;\n}\n\nstruct Fraction {\n    LL num, den;\n    explicit Fraction(LL num) : num(num), den(1) { normalize(); }\n    Fraction(LL num, LL den) : num(num), den(den) { normalize(); }\n\n    Fraction& operator +=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num += f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator -=(const Fraction &f) {\n        const LL newd = lcm(den, f.den);\n        num *= newd / den;\n        num -= f.num * (newd / f.den);\n        den = newd;\n        normalize();\n        return *this;\n    }\n\n    Fraction& operator *=(const Fraction &f) {\n        num *= f.num;\n        den *= f.den;\n        normalize();\n        return *this;\n    }\n\n    bool operator ==(const Fraction &f) const {\n        return (num == 0 && f.num == 0) || (num == f.num && den == f.den);\n    }\n\n    bool operator <(const Fraction &f) const {\n        return num * f.den < den * f.num;\n    }\n\n    bool operator >(const Fraction &f) const {\n        return num * f.den > den * f.num;\n    }\n\n    bool operator <=(const Fraction &f) const {\n        return *this < f || *this == f;\n    }\n\n    void normalize() {\n        LL g = abs(gcd(num, den));\n        num /= g;\n        den /= g;\n        if(den < 0) {\n            num = -num;\n            den = -den;\n        }\n    }\n\n    Fraction strict() const {\n        return Fraction(num % den, den);\n    }\n};\n\nFraction operator +(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret += g;\n    return ret;\n}\n\nFraction operator -(const Fraction &f, const Fraction &g) {\n    Fraction ret = f;\n    ret -= g;\n    return ret;\n}\n\nFraction operator /(const Fraction &f, LL d) {\n    Fraction ret = f;\n    ret *= Fraction(1, d);\n    return ret;\n}\n\nFraction operator /(const Fraction &f, const Fraction &d) {\n    Fraction ret = f;\n    ret *= Fraction(d.den, d.num);\n    return ret;\n}\n\nostream& operator <<(ostream &os, const Fraction &f) {\n    return os << '(' << f.num << '/' << f.den << ')';\n}\n\nFraction calc_hour_sec_min(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    if(as < ah) as += Fraction(1);\n    if(am < as) am += Fraction(1);\n    assert(ah <= as && as <= am);\n    // calc (as-ah)+x*(1/60-1/3600H) == (am-as)+x*(1/3600-1/60)\n    // is (1/60-1/3600H-1/3600+1/60)x = am-as-as+ah\n    const Fraction rhs = am - as - as + ah;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600*H) - Fraction(1,3600) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc_min_sec_hour(int H, Fraction ah, Fraction am, Fraction as) {\n    if(ah == am && am == as) return Fraction(0);\n    if(as < am) as += Fraction(1);\n    if(ah < as) ah += Fraction(1);\n    assert(am <= as && as <= ah);\n    // calc (as-am)+x*(1/60-1/3600) == (ah-as)+x*(1/3600H-1/60)\n    // is (1/60-1/3600-1/3600H+1/60)x == ah-as-as+am\n    const Fraction rhs = ah - as - as + am;\n    const Fraction coef = Fraction(1,60) - Fraction(1,3600) - Fraction(1,3600*H) + Fraction(1,60);\n    return rhs / coef;\n}\n\nFraction calc(int H, int h, int m, int s) {\n    Fraction ah = Fraction(h*3600 + m*60 + s, H*3600);\n    Fraction am = Fraction(m*60 + s, 3600);\n    Fraction as = Fraction(s, 60);\n    Fraction dmh = am - ah;\n    Fraction dsh = as - ah;\n    if(dmh.num < 0) dmh += Fraction(1);\n    if(dsh.num < 0) dsh += Fraction(1);\n    if(dmh > dsh) { // hour-sec-min\n        if(as < ah) as += Fraction(1);\n        if(am < as) am += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_hour_sec_min(H, ah, am, as);\n        } else {\n            // calc as+x/60 == am+x/3600\n            // is (1/60-1/3600)x == am-as\n            const Fraction tmp = (am - as) / (Fraction(1,60) - Fraction(1,3600));\n            return tmp + calc_min_sec_hour(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    } else if(dmh <= dsh) { // min-sec-hour\n        if(as < am) as += Fraction(1);\n        if(ah <= as) ah += Fraction(1);\n        Fraction mid = (ah + am) / 2;\n        if(as <= mid) {\n            return calc_min_sec_hour(H, ah, am, as);\n        } else {\n            // calc as+x/60 == ah+x/3600H\n            // is (1/60-1/3600H)x == ah-as\n            const Fraction tmp = (ah - as) / (Fraction(1,60) - Fraction(1,3600*H));\n            return tmp + calc_hour_sec_min(H, ah+tmp/(H*3600), am+tmp/3600, as+tmp/60);\n        }\n    }\n    assert(false);\n}\n\nbool solve() {\n    int H, h, m, s;\n    if(!(cin >> H >> h >> m >> s)) return false;\n    if(!H && !h && !m && !s) return false;\n\n    Fraction pass = calc(H, h, m, s);\n    //cout << pass << endl;\n    s += pass.num / pass.den;\n    pass -= Fraction(pass.num / pass.den);\n    m += s / 60;\n    s %= 60;\n    h += m / 60;\n    m %= 60;\n    h %= H;\n    if(h == 0 && m == 0 && s == 0 && pass == Fraction(0,1)) {\n        pass = calc(H, h, m, s);\n        s += pass.num / pass.den;\n        pass -= Fraction(pass.num / pass.den);\n        m += s / 60;\n        s %= 60;\n        h += m / 60;\n        m %= 60;\n        h %= H;\n    }\n    pass += Fraction(s);\n    cout << h << ' ' << m << ' ' << pass.num << ' ' << pass.den << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong gcd(long a,long b){return b?gcd(b,a%b):a;}\nint H,h,m,s;\nbool check(long H,long h,long m,long s)\n{\n\tfor(int r=-1;r<=1;r++)\n\t{\n\t\tlong A=r*360*10*H+60*m*(H+1)+3600*h;\n\t\tlong B=119*H-1;\n\t\tlong d=gcd(A,B);\n\t\tA/=d;\n\t\tB/=d;\n\t\tif(!(A>=60*B||s*B>A)&&!(h==0&&m==0&&A==0))\n\t\t{\n\t\t\tcout<<h<<\" \"<<m<<\" \"<<A<<\" \"<<B<<endl;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nmain()\n{\n\twhile(cin>>H>>h>>m>>s,H)\n\t{\n\t\twhile(!check(H,h,m,s))\n\t\t{\n\t\t\ts++;\n\t\t\tif(s==60)m++,s=0;\n\t\t\tif(m==60)h++,m=0;\n\t\t\tif(h==H)h=0;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\n//  nd/de\nclass Fruction\n{\npublic:\n\tlong long int nd;\n\tlong long int de;\n\tvoid reduct() {\n\t\tif (nd) {\n\t\t\tbool ndminus = false;\n\t\t\tif (nd < 0) {\n\t\t\t\tndminus = true;\n\t\t\t\tnd = -nd;\n\t\t\t}\n\n\t\t\tconst long long int agcd(gcd(nd, de));\n\t\t\tde /= agcd;\n\t\t\tnd /= agcd;\n\t\t\tif (ndminus)nd = -nd;\n\t\t}\n\t\telse {\n\t\t\tde = 1;\n\t\t}\n\t}\n\tFruction() :nd(0), de(1) {\n\n\t}\n\tvoid initialize() {\n\t\tif (de < 0) {\n\t\t\tde = -de;\n\t\t\tnd = -nd;\n\t\t}\n\t\treduct();\n\t\t\n\t}\n\tFruction(const long long int nd_,const long long int de_) \n\t\t:nd(nd_), de(de_) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int nd_, const Fruction de_) :\n\t\tnd(nd_*de_.de), de(de_.nd) {\n\t\tinitialize();\n\t}\n\tFruction(const Fruction nd_, const long long int de_) :\n\t\tnd(nd_.nd), de(nd_.de*de) {\n\t\tinitialize();\n\t}\n\tFruction(const long long int num):nd(num),de(1) {\n\t}\n\tFruction(const Fruction& f) :de(f.de), nd(f.nd) {\n\n\t}\n\tpair<long long int, Fruction>mixed() {\n\t\tlong long int num = nd / de;\n\t\treturn make_pair(num, Fruction(nd - de*num, de));\n\t}\n};\nFruction operator-(const Fruction&f) {\n\treturn Fruction(-f.nd, f.de);\n}\nFruction operator+(const Fruction&l, const Fruction&r) {\n\tlong long int nede = lca(l.de, r.de);\n\tlong long int nend = l.nd*(nede / l.de) + r.nd*(nede / r.de);\n\treturn Fruction(nend, nede);\n}\nFruction operator-(const Fruction&l, const Fruction&r) {\n\treturn l+(-r);\n}\nFruction operator*(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.nd;\n\tlong long int nede = l.de*r.de;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator*(const Fruction&l, const long long int&r) {\n\treturn l*Fruction(r, 1);\n}\nFruction operator*(const long long int &l, const Fruction&r) {\n\treturn Fruction(l, 1)*r;\n}\nFruction operator/(const Fruction&l, const Fruction&r) {\n\tlong long int nend = l.nd*r.de;\n\tlong long int nede = l.de*r.nd;\n\tFruction nefr(nend, nede);\n\tnefr.initialize();\n\treturn nefr;\n}\nFruction operator/(const Fruction&l, const long long int&r) {\n\treturn l / Fruction(r, 1);\n}\nFruction operator/(const long long int&l, const Fruction&r) {\n\treturn Fruction(l,1) / r;\n}\n\nbool operator<(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de < r.nd*l.de;\n}\nbool operator==(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de == r.nd*l.de;\n}\nbool operator>(const Fruction&l, const Fruction&r) {\n\treturn l.nd*r.de > r.nd*l.de;\n}\n\nint main() {\n\twhile (1) {\n\t\tint T, H, M, S; cin >> T >> H >> M >> S;\n\t\tif (!T)break;\n\t\tint total = T*60*60;\n\t\tint ntime = H * 3600 + M * 60 + S;\n\t\tif (!T)break;\n\t\tFruction speeds[3];\n\t\tspeeds[0] = Fruction(1, T * 60 * 60);\n\t\tspeeds[1] = Fruction(1, 60 * 60);\n\t\tspeeds[2] = Fruction(1, 60);\n\t\tFruction now[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tnow[i] = Fruction(speeds[i] * ntime);\n\t\t\tnow[i] = now[i].mixed().second;\n\t\t}\n\t\tFruction ans(1e9,1);\n\t\tfor (int i = 0; i < 1; ++i) {\n\t\t\tFruction dspeed = -(speeds[i] + speeds[(i + 1) % 3]) / 2 + speeds[(i + 2) % 3];\n\t\t\tFruction dkaku = (now[i] + now[(i + 1) % 3]) / 2 - now[(i + 2) % 3];\n\t\t\tif (dspeed < 0) {\n\t\t\t\tdkaku = -dkaku;\n\t\t\t\tdspeed = -dspeed;\n\t\t\t}\n\t\t\tfor (int j = -49; j < 50; ++j) {\n\t\t\t\tFruction nans = (dkaku +  j* Fruction(1, 2)) / dspeed;\n\t\t\t\tFruction next[3];\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tnext[k] = now[k] + nans*speeds[k];\n\t\t\t\t\tnext[k] = next[k].mixed().second;\n\t\t\t\t}\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\t\tif (next[k] == next[(k + 1) % 3])ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif (nans > 0) {\n\t\t\t\t\t\tans = min(ans, nans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpair<long long int, Fruction>p(ans.mixed());\n\t\tlong long int fintime = ntime + p.first;\n\t\tfintime %= T * 60 * 60;\n\t\tconst int nh = fintime / 3600;\n\t\tfintime -= nh * 3600;\n\t\tconst int nm = fintime / 60;\n\t\tfintime -= nm * 60;\n\t\tFruction ns(fintime*p.second.de + p.second.nd, p.second.de);\n\t\tcout << nh << \" \" << nm << \" \" << ns.nd << \" \" << ns.de << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1338: Clock Hands\n// 2017.12.7 bal4u@uu\n\n#include <stdio.h>\n\nlong long gcd(long long a, long long b)\n{\n\tlong long r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint main()\n{\n    long long H, h, m, s, d, n;\n\tlong long c3600, ha, ma, sa, a1, a2, g;\n\n    while (scanf(\"%lld%lld%lld%lld\", &H, &h, &m, &s) && H > 0) {\n        d = 119*H - 1;\n\t\tc3600 = 3600*H*d;\n        n = s * d;\n        while (1) {\n            ha = (60 * h + m) * 60*d + n;\n            ma = 60 * H * m * d + n * H;\n            sa = 60 * H * n;\n            ma = (ma - ha) % c3600;\n            sa = (sa - ha) % c3600;\n            if (ma < 0) ma += c3600;\n            if (sa < 0) sa += c3600;\n            if (ma != 0) {\n                if (ma < sa) a1 = c3600 - sa, a2 = sa - ma;\n                else         a1 = sa, a2 = ma - sa;\n                if (a1 == a2) break;\n            }\n            n++;\n            if (n == 60 * d) m++, n = 0;\n            if (m == 60) m = 0, h++;\n            if (h == H) h = 0;\n        }\n        g = gcd(n, d);\n        printf(\"%lld %lld %lld %lld\\n\", h, m, n/g, d/g);\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1338: Clock Hands\n// 2017.12.7 bal4u@uu\n\n#include <stdio.h>\n\nlong long gcd(long long a, long long b)\n{\n\tlong long r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint main()\n{\n    int H, h, m, s;\n\tlong long c3600, ha, ma, sa, a1, a2, g, d, n;\n\n    while (scanf(\"%d%d%d%d\", &H, &h, &m, &s) && H > 0) {\n        d = 119*H - 1;\n\t\tc3600 = 3600*H*d;\n        n = s * d;\n        while (1) {\n            ha = (60 * h + m) * 60*d + n;\n            ma = 60 * H * m * d + n * H;\n            sa = 60 * H * n;\n            ma = (ma - ha) % c3600;\n            sa = (sa - ha) % c3600;\n            if (ma < 0) ma += c3600;\n            if (sa < 0) sa += c3600;\n            if (ma != 0) {\n                if (ma < sa) a1 = c3600 - sa, a2 = sa - ma;\n                else         a1 = sa, a2 = ma - sa;\n                if (a1 == a2) break;\n            }\n            n++;\n            if (n == 60 * d) m++, n = 0;\n            if (m == 60) m = 0, h++;\n            if (h == H) h = 0;\n        }\n        g = gcd(n, d);\n        printf(\"%d %d %d %d\\n\", h, m, (int)(n/g), (int)(d/g));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class GetClockHandsAngle {\n\n    private static final double MIN_PER_HOUR = 60;\n    private static final double FULL_DEGREE = 360;\n    private static final double DEGREE_PER_HOUR = FULL_DEGREE / 12;\n    private static final double DEGREE_PER_MINITE_HAND = FULL_DEGREE / 60;\n    private static final double DEGREE_PER_MINITE = DEGREE_PER_HOUR / MIN_PER_HOUR;\n\n    public double getAngle(double hour, double minute) {\n        double hourDegree = (hour%12) * DEGREE_PER_HOUR;\n        double hourOffset = (minute%60) * DEGREE_PER_MINITE;\n        hourDegree += hourOffset;\n\n        double miniteDegree = minute * DEGREE_PER_MINITE_HAND;\n\n        return Math.abs(miniteDegree - hourDegree);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "private static final double MIN_PER_HOUR = 60;\n    private static final double FULL_DEGREE = 360;\n    private static final double DEGREE_PER_HOUR = FULL_DEGREE / 12;\n    private static final double DEGREE_PER_MINITE_HAND = FULL_DEGREE / 60;\n    private static final double DEGREE_PER_MINITE = DEGREE_PER_HOUR / MIN_PER_HOUR;\n\n    public double getAngle(double hour, double minute) {\n        double hourDegree = (hour%12) * DEGREE_PER_HOUR;\n        double hourOffset = (minute%60) * DEGREE_PER_MINITE;\n        hourDegree += hourOffset;\n\n        double miniteDegree = minute * DEGREE_PER_MINITE_HAND;\n\n        return Math.abs(miniteDegree - hourDegree);\n    }"
  },
  {
    "language": "Java",
    "code": "class GetClockHandsAngle {\n\n    private static final double MIN_PER_HOUR = 60;\n    private static final double FULL_DEGREE = 360;\n    private static final double DEGREE_PER_HOUR = FULL_DEGREE / 12;\n    private static final double DEGREE_PER_MINITE_HAND = FULL_DEGREE / 60;\n    private static final double DEGREE_PER_MINITE = DEGREE_PER_HOUR / MIN_PER_HOUR;\n\n    public double getAngle(double hour, double minute) {\n        double hourDegree = (hour%12) * DEGREE_PER_HOUR;\n        double hourOffset = (minute%60) * DEGREE_PER_MINITE;\n        hourDegree += hourOffset;\n\n        double miniteDegree = minute * DEGREE_PER_MINITE_HAND;\n\n        return Math.abs(miniteDegree - hourDegree);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\n\nstring format(F S) {\n    F r = S % 3600;\n    F h = (S - r) * f(1, 3600); S = r; r = S % 60;\n    F m = (S - r) * f(1, 60); S = r; \n    F s = r;\n    h.reduce; m.reduce; s.reduce;\n    return text(h.longeger, \" \", m.longeger, \" \", s.toString.split(\"/\").join(\" \"));\n}\n\ntemplate lcm(T) {\n    T lcm(T a, T b) {\n        return a / gcd(a.abs, b.abs) * b;\n    }\n}\n\nclass F {\n    long a, b; // a / b;\n    this(long a, long b) {\n        if (b < 0) { a = -a; b = -b; }\n        this.a = a;\n        this.b = b;\n        reduce;\n    }\n    void reduce() {\n        long g = gcd(a.abs, b.abs);\n        a /= g;\n        b /= g;\n    }\n    F dup() {\n        return new F(a, b);\n    }\n    override string toString() {\n        return text(a, \"/\", b);\n    }\n    F opUnary(string op)() if (op == \"-\") {\n        return new F(-a, b);\n    }\n    F opBinary(string op)(F rhs) if (op == \"+\") {\n        F ret = this.dup;\n        long l = lcm(b, rhs.b);\n        ret.b = l;\n        ret.a = a * (l / b) + rhs.a * (l / rhs.b);\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(long rhs) if (op == \"+\") {\n        return this + new F(rhs, 1);\n    }\n    F opBinary(string op)(F rhs) if (op == \"-\") {\n        return this + (-rhs);\n    }\n    F opBinary(string op)(long rhs) if (op == \"-\") {\n        return this + (-rhs);\n    }\n    F opBinary(string op)(F rhs) if (op == \"*\") {\n        F ret = this.dup;\n        ret.a *= rhs.a;\n        ret.b *= rhs.b;\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(long rhs) if (op == \"*\") {\n        F ret = this.dup;\n        ret.a *= rhs;\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(F rhs) if (op == \"/\") {\n        return this * (new F(rhs.b, rhs.a));\n    }\n    override bool opEquals(Object o) {\n        F rhs = cast(F)o;\n        return a == rhs.a && b == rhs.b;\n    }\n    override int opCmp(Object o) {\n        F rhs = cast(F)o;\n        long l = lcm(b, rhs.b);\n        long x = a * (l / b),\n            y = rhs.a * (l / rhs.b);\n        return cast(int)( (x - y) / abs(x - y) );\n    }\n    long longeger() {\n        return a / b;\n    }\n    F frac() {\n        return this - a / b;\n    }\n    F opBinary(string op)(long M) if (op == \"%\") {\n        return frac + (longeger % M);\n    }\n}\n\nF f(long a, long b) {\n    return new F(a, b);\n}\n\nvoid main() {\n    long H, h, m, s;\n    while (readf(\"%d %d %d %d\\n\", &H, &h, &m, &s), H || h || m || s) {\n        long S = h * 3600 + m * 60 + s;\n        F vsec = f(6, 1);\n        F vmin = f(1, 10);\n        F vhour = f(1, 10 * H);\n        F vmid = (vmin + vhour) * f(1, 2);\n        F pmid = (vmid * S) % 360;\n        F psec = (vsec * S) % 360;\n        F dist = min((pmid + 360 - psec) % 360, (pmid + 540 - psec) % 360);\n        //[dist, vsec, vmid].writeln;\n        F cand = dist / (vsec - vmid) + S;\n        //writeln(\"vars: \", [dist, vsec, vmid, vsec - vmid]);\n        //writeln(\"cand: \", cand);\n        cand = cand % (H * 3600);\n        if (vsec * cand % 360 == vmin * cand % 360 &&\n                vmin * cand % 360 == vhour * cand % 360) {\n            cand = cand + f(180, 1) / (vsec - vmid);\n        }\n        cand = cand % (H * 3600);\n        //[vsec * cand % 360, vmin * cand % 360, vhour * cand % 360].writeln;\n        //cand.writeln;\n        format(cand).writeln;\n        //vmid.writeln;\n    }\n} "
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\n\nstring format(F S) {\n    F r = S % 3600;\n    F h = (S - r) * f(1, 3600); S = r; r = S % 60;\n    F m = (S - r) * f(1, 60); S = r; \n    F s = r;\n    h.reduce; m.reduce; s.reduce;\n    return text(h.integer, \" \", m.integer, \" \", s.toString.split(\"/\").join(\" \"));\n}\n\ntemplate lcm(T) {\n    T lcm(T a, T b) {\n        return a / gcd(a.abs, b.abs) * b;\n    }\n}\n\nclass F {\n    int a, b; // a / b;\n    this(int a, int b) {\n        this.a = a;\n        this.b = b;\n        reduce;\n    }\n    void reduce() {\n        int g = gcd(a.abs, b.abs);\n        a /= g;\n        b /= g;\n    }\n    F dup() {\n        return new F(a, b);\n    }\n    override string toString() {\n        return text(a, \"/\", b);\n    }\n    F opUnary(string op)() if (op == \"-\") {\n        return new F(-a, b);\n    }\n    F opBinary(string op)(F rhs) if (op == \"+\") {\n        F ret = this.dup;\n        int l = lcm(b, rhs.b);\n        ret.b = l;\n        ret.a = a * (l / b) + rhs.a * (l / rhs.b);\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(int rhs) if (op == \"+\") {\n        return this + new F(rhs, 1);\n    }\n    F opBinary(string op)(F rhs) if (op == \"-\") {\n        return this + (-rhs);\n    }\n    F opBinary(string op)(int rhs) if (op == \"-\") {\n        return this + (-rhs);\n    }\n    F opBinary(string op)(F rhs) if (op == \"*\") {\n        F ret = this.dup;\n        ret.a *= rhs.a;\n        ret.b *= rhs.b;\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(int rhs) if (op == \"*\") {\n        F ret = this.dup;\n        ret.a *= rhs;\n        ret.reduce;\n        return ret;\n    }\n    F opBinary(string op)(F rhs) if (op == \"/\") {\n        return this * (new F(rhs.b, rhs.a));\n    }\n    override bool opEquals(Object o) {\n        F rhs = cast(F)o;\n        return a == rhs.a && b == rhs.b;\n    }\n    override int opCmp(Object o) {\n        F rhs = cast(F)o;\n        int l = lcm(b, rhs.b);\n        int x = a * (l / b),\n            y = rhs.a * (l / rhs.b);\n        return x - y;\n    }\n    int integer() {\n        return a / b;\n    }\n    F frac() {\n        return this - a / b;\n    }\n    F opBinary(string op)(int M) if (op == \"%\") {\n        return frac + (integer % M);\n    }\n}\n\nF f(int a, int b) {\n    return new F(a, b);\n}\n\nvoid main() {\n    int H, h, m, s;\n    while (readf(\"%d %d %d %d\\n\", &H, &h, &m, &s), H || h || m || s) {\n        int S = h * 3600 + m * 60 + s;\n        F vsec = f(6, 1);\n        F vmin = f(1, 10);\n        F vhour = f(1, 10 * H);\n        F vmid = (vmin + vhour) * f(1, 2);\n        F pmid = (vmid * S) % 360;\n        F psec = (vsec * S) % 360;\n        F dist = min((pmid + 360 - psec) % 360, (pmid + 540 - psec) % 360);\n        //[dist, vsec, vmid].writeln;\n        F cand = dist / (vsec - vmid) + S;\n        cand = cand % (H * 3600);\n        if (vsec * cand % 360 == vmin * cand % 360 &&\n                vmin * cand % 360 == vhour * cand % 360) {\n            cand = cand + f(180, 1) / (vsec - vmid);\n        }\n        cand = cand % (H * 3600);\n        //[vsec * cand % 360, vmin * cand % 360, vhour * cand % 360].writeln;\n        //cand.writeln;\n        format(cand).writeln;\n        //vmid.writeln;\n    }\n} "
  },
  {
    "language": "Python",
    "code": "import sys\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    f = lambda h, m, s: 3600*h + 60*m + s\n    H, h, m, s = map(int, readline().split())\n    if H == 0:\n        return False\n    d0 = f(h, m, s)\n    M = f(H, 0, 0)\n    res = []\n    for h0 in range(H):\n        for m0 in range(60):\n            p = 3600*h0 + 60*m0 + 60*H*m0; q = 119*H-1\n            for d in [-3600*H, 0, 3600*H]:\n                p1 = p + d; q1 = q\n                g = gcd(p1, q); p1 //= g; q1 //= g\n                if 0 <= p1 < 60*q1:\n                    if H*(60*m0*q1 + p1) != q1*(3600*h0 + 60*m0) + p1:\n                        res.append((f(h0, m0, 0) + p1/q1, h0, m0, p1, q1))\n    res.sort(key = lambda x: (x[0] - d0) % M)\n    _, h, m, p, q = res[0]\n    write(\"%d %d %d %d\\n\" % (h, m, p, q))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nstruct Rational {\n    num: i64, den: i64\n}\nfn gcd(a: i64, b: i64) -> i64 {\n    match b {\n        0 => a,\n        _ => gcd(b, a % b)\n    }\n}\nimpl Rational {\n    fn new(n: i64, d: i64) -> Rational {\n        let sign = n.signum() * d.signum();\n        let g = gcd(n.abs(), d.abs());\n        Rational{num: n.abs() * sign / g, den: d.abs() / g}\n    }\n    fn from_int(value: i32) -> Rational {\n        Rational{num: value as i64, den: 1}\n    }\n    fn abs(&self) -> Rational {\n        Rational{num: self.num.abs(), den: self.den}\n    } \n}\nimpl Add for Rational {\n    type Output = Rational;\n    fn add(self, rhs: Rational) -> <Self as std::ops::Add<Rational>>::Output { \n        Rational::new(self.num * rhs.den + self.den * rhs.num, self.den * rhs.den)\n    }\n}\nimpl AddAssign for Rational {\n    fn add_assign(&mut self, rhs: Rational) {\n        *self = *self + rhs;\n    }\n}\nimpl Sub for Rational {\n    type Output = Rational;\n    fn sub(self, rhs: Self) -> Self::Output {\n        Rational::new(self.num * rhs.den - self.den * rhs.num, self.den * rhs.den)\n    }\n}\nimpl SubAssign for Rational {\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\nimpl Mul for Rational {\n    type Output = Rational;\n    fn mul(self, rhs: Self) -> Self::Output {\n        Rational::new(self.num * rhs.num, self.den * rhs.den)\n    }\n}\nimpl MulAssign for Rational {\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\nimpl Div for Rational {\n    type Output = Rational;\n    fn div(self, rhs: Self) -> Self::Output {\n        Rational::new(self.num * rhs.den, self.den * rhs.num)\n    }\n}\nimpl DivAssign for Rational {\n    fn div_assign(&mut self, rhs: Self) {\n        *self = *self / rhs;    \n    }\n}\nimpl Neg for Rational {\n    type Output = Rational;\n    fn neg(self) -> Self::Output {\n        Rational{num: -self.num, den: self.den}\n    }\n}\nimpl Ord for Rational {\n    fn cmp(&self, other: &Self) -> Ordering {\n        (*self - *other).num.cmp(&0)\n    }\n}\nimpl PartialOrd for Rational {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\nimpl Display for Rational {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{} / {}\", self.num, self.den)\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Time {\n    one_day_hour: usize, hour: usize, minute: usize, second: Rational\n}\nimpl Time {\n    fn new(one_day_hour: usize, mut hour: usize, mut minute: usize, mut second: Rational) -> Time {\n        minute += (second.num / second.den / 60) as usize;\n        second.num %= 60 * second.den;\n        hour += minute / 60;\n        minute %= 60;\n        hour %= one_day_hour;\n        Time{one_day_hour: one_day_hour, hour: hour, minute: minute, second: second}\n    }\n    fn needle_pos(&self) -> (Needle, Needle, Needle) {\n        let one_day_second = Rational::from_int(self.one_day_hour as i32 * 3600);\n        let current_second = Rational::from_int(self.hour as i32) * Rational::from_int(3600) + Rational::from_int(self.minute as i32) * Rational::from_int(60) + self.second;\n        let hour_pos = Position::new(current_second / one_day_second);\n        let minute_pos = Position::new((Rational::from_int(self.minute as i32) * Rational::from_int(60) + self.second) /  Rational::from_int(3600));\n        let second_pos = Position::new(self.second / Rational::from_int(60));\n        let hour_speed = Rational::new(1, 3600 * self.one_day_hour as i64);\n        let minute_speed = Rational::new(1, 3600);\n        let second_speed = Rational::new(1, 60);\n        (Needle{epoc_pos: hour_pos, speed: hour_speed}, Needle{epoc_pos: minute_pos, speed: minute_speed}, Needle{epoc_pos: second_pos, speed: second_speed})\n    }\n    fn succeeded(&self, second: Rational) -> Time {\n        Time::new(self.one_day_hour, self.hour, self.minute, self.second + second)\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nstruct Position {\n    ratio: Rational\n}\nimpl Position {\n    fn new(ratio: Rational) -> Position {\n        Position{ratio: ratio}.normalize()\n    }\n    fn diff_from(&self, other: &Position) -> Position {\n        Position::new(self.ratio - other.ratio)\n    }\n    fn normalize(&self) -> Position {\n        Position{ratio: if self.ratio.num < 0 {\n            Rational::new(self.ratio.den + self.ratio.num % self.ratio.den, self.ratio.den)\n        }else if self.ratio.num >= self.ratio.den {\n            Rational::new(self.ratio.num % self.ratio.den, self.ratio.den)\n        }else {\n            self.ratio\n        }}\n    }\n}\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\nstruct Needle {\n    epoc_pos: Position, speed: Rational\n}\nfn cal_mid_needle(epoc_time: Time) -> (Needle, Needle) {\n    let (hour, minute, _) = epoc_time.needle_pos();\n    let mid = (hour.epoc_pos.ratio + minute.epoc_pos.ratio) / Rational::from_int(2);\n    let mid2 = mid + Rational::new(1, 2);\n    let speed = (minute.speed + hour.speed) / Rational::from_int(2);\n    (Needle{epoc_pos: Position::new(mid), speed: speed}, Needle{epoc_pos: Position::new(mid2), speed: speed})\n}\n\nfn main() {\n    loop {\n        read!(one_day_hour: usize, hour: usize, minute: usize, second: usize);\n        if one_day_hour == 0 { break;}\n        let start_time = Time{one_day_hour: one_day_hour, hour: hour, minute: minute, second: Rational::from_int(second as i32)};\n        let (Needle{epoc_pos: pos_a, speed: mid_speed}, Needle{epoc_pos: pos_b, speed: _}) = cal_mid_needle(start_time);\n        let (hour, minute, second) = start_time.needle_pos();\n        if let Some(time) = vec![pos_a.diff_from(&second.epoc_pos).ratio / (second.speed - mid_speed), pos_b.diff_from(&second.epoc_pos).ratio / (second.speed- mid_speed)].into_iter().filter(|&diff| {\n            let (h, m, _) = start_time.succeeded(diff).needle_pos();\n            h.epoc_pos != m.epoc_pos\n        }).min() {\n            let min_time = start_time.succeeded(time);\n            println!(\"{} {} {} {}\", min_time.hour, min_time.minute, min_time.second.num, min_time.second.den);\n        }else {\n            panic!();\n        }\n    }\n}\n"
  }
]