[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nunsigned char memo[1<<20];\nint mask[5][5][6][6];\n\nvoid printS(int s){\n  int tmp[5][5];\n  fill(tmp[0], tmp[5], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      tmp[i][j] = s >> (i*5+j) & 1;\n    }\n  }\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      cout << tmp[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid init(){\n  fill(memo, memo + (1<<20), -1);\n  fill(mask[0][0][0], mask[5][0][0], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      for(int h=1;i+h<=5;h++){\n        for(int w=1;j+w<=5;w++){\n          int tmp = (1 << w) - 1 << j;\n          for(int k=0;k<h;k++){\n            mask[i][j][h][w] |= tmp << (i+k) * 5;\n          }\n        }\n      }\n    }\n  }\n  queue<int> q;\n  memo[0] = 0;\n  q.push(0);\n  while(!q.empty()){\n    int u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      for(int j=0;j<5;j++){\n        for(int h=1;i+h<=4;h++){\n          for(int w=1;j+w<=5;w++){\n            int v = u ^ mask[i][j][h][w];\n            if(memo[v] > memo[u] + 1){\n              memo[v] = memo[u] + 1;\n              /*if((int)memo[v] == 2 && 0){\n                cout << \"cost = \" << (int)memo[v] << endl;\n                printS(v);\n                }*/\n              q.push(v);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nconst int INF = 1 << 28;\n\nvoid rec(int t, int x, int cnt, int &res){\n  if((t >> 20) == 0){\n    //printS(t);\n    //cout << (int)memo[t&(1<<20)-1] << endl;\n    res = min(res, memo[t] + cnt);\n  }\n  if(x >= 5) return;\n  for(int i=0;i<5;i++){\n    for(int j=x;j<5;j++){\n      int nt = t ^ mask[i][x][5-i][j-x+1];\n      if(!(nt&1<<20+x)) rec(nt, x+1, cnt+1, res);\n    }\n  }\n  if(!(t&1<<20+x)) rec(t, x+1, cnt, res);\n}\n\nint solve(int s){\n  int cnt = 0;\n  for(int i=0;i<5;i++){\n    if(s >> (20 + i) & 1) cnt++;\n  }\n  int res = memo[s&(1<<20)-1] + min(cnt, 6-cnt);\n  //cout << res << ' ';\n  rec(s, 0, 0, res);\n  //cout << res << endl;\n  return res;\n}\n\nmain(){\n  init();\n  int n;\n  while(cin >> n && n){\n    int m = 0;\n    for(int i=0;i<n;i++){\n      int t = 0, c;\n      for(int j=0;j<n;j++){\n        cin >> c;\n        t |= c << j;\n      }\n      m |= t << i * 5;\n    }\n    int ans = n < 5 ? memo[m] : solve(m);\n    for(int i=0;i<ans;i++){\n      cout << \"myon\";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  static int close[(1<<(5*5))/32];\n  static int cls[1000000];\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n\n    //vector<vector<int> > pats(33);\n    static int pats[33][26];\n    int pats_cnt[33]={};\n    static int tmp[5][5];\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    int ix=__builtin_clz(bd);\n\t    pats[ix][pats_cnt[ix]++]=bd;\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n    /*\n    for (int i=0; i<33; i++)\n      cout<<i<<\": \"<<pats[i].size()<<endl;\n    */\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      //const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int ix=__builtin_clz(cbd);\n      int sz=pats_cnt[ix];\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^pats[ix][i];\n\tif (close[nbd>>5]&(1<<(nbd&31)))\n\t  continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    {\n      int i=0;\n      for (; i+3<cls_cnt; i+=4){\n\tclose[(cls[i+0]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+1]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+2]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+3]&0x1ffffff)>>5]=0;\n      }\n      for (; i<cls_cnt; i++)\n\tclose[(cls[i]&0x1ffffff)>>5]=0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef unsigned long long ull;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint n;\nstruct State{\n    ull S;\n    int cost, h_cost;\n    State(ull S, int cost, int h_cost) : S(S), cost(cost), h_cost(h_cost) {\n    }\n    bool operator < (const State& S) const{\n        if(cost + h_cost != S.cost + S.h_cost) return cost + h_cost > S.cost + S.h_cost;\n        return cost < S.cost;\n    }\n};\null encode( bool b[5][5]){\n    ull res = 0;\n    REP(y, n) REP(x, n){\n        res = (res << 1) + (b[y][x] ? 1 : 0);\n    }\n    return res;\n}\nvoid decode(ull S, bool b[5][5]){\n    for(int y = n - 1; y >= 0; y--){\n        for(int x = n - 1; x >= 0; x--){\n            b[y][x] = (S & 1);\n            S = S >> 1;\n        }\n    }\n}\nint h(bool b[5][5]){\n    bool used[5][5] = {};\n    int res = 0;\n    REP(y, n) REP(x, n) if(!used[y][x] && b[y][x]){\n        res++;\n        queue<int> qx, qy;\n        qx.push(x), qy.push(y);\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4){\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && ny >= 0 && nx < n && ny < n && !used[ny][nx] && b[ny][nx]){\n                    qx.push(nx); qy.push(ny);\n                    used[ny][nx] = true;\n                }\n            }\n        }\n    }\n    return res;\n}\nint answer;\nint dfs(ull S, int cost){\n    bool b[5][5];\n    decode(S, b);\n    int h_cost = h(b);\n    if(cost + h_cost >= answer) return INF;\n    if(h_cost == 0) return answer = cost;\n    int res = INF;\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        bool b[5][5];\n        REP(y, n) REP(x, n){\n            cin >> b[y][x];\n        }\n        vector<ull> operate;\n        for(int y0 = 0; y0 < n; y0++)\n        for(int y1 = y0; y1 < n; y1++)\n        for(int x0 = 0; x0 < n; x0++)\n        for(int x1 = x0; x1 < n; x1++){\n            bool c[5][5] = {};\n            for(int y = y0; y <= y1; y++)\n            for(int x = x0; x <= x1; x++){\n                c[y][x] = true;\n            }\n            operate.push_back(encode(c));\n        }\n        answer = 0;\n        priority_queue<State> que;\n        que.push(State(encode(b), 0, h(b)));\n        set<ull> used;\n        while(!que.empty()){\n            int S = que.top().S;\n            int cost = que.top().cost;\n            int h_cost = que.top().h_cost;\n            //printf(\"%d %d\\n\", cost, h_cost);\n            que.pop();\n            if(h_cost == 0){\n                REP(iter, cost) cout << \"myon\";\n                cout << endl;\n                break;\n            }\n            for(auto ope : operate){\n                ull NS = S ^ ope;\n                if(!used.count(NS)){\n                    bool c[5][5];\n                    decode(NS, c);\n                    used.insert(NS);\n                    que.push(State(NS, cost + 1, h(c)));\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\t\n\tfor(int n;cin>>n && n;){\n\t\tvi mask;\n\t\trep(t,n) repi(b,t,n) rep(l,n) repi(r,l,n){\n\t\t\tvvi grid(n,vi(n));\n\t\t\trepi(i,t,b+1) repi(j,l,r+1)\n\t\t\t\tgrid[i][j]=1;\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n) t|=grid[i][j]<<i*n+j;\n\t\t\tmask.push_back(t);\n\t\t}\n\t\t\n\t\tvector<bool> vis1(1<<n*n);\n\t\t{\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n){\n\t\t\t\tint x; cin>>x;\n\t\t\t\tt|=x<<i*n+j;\n\t\t\t}\n\t\t\tvis1[t]=1;\n\t\t}\n\t\tvector<bool> vis2(1<<n*n);\n\t\tvis2[0]=1;\n\t\t\n\t\tint res=0;\n\t\tfor(;;res++){\n\t\t\tbool ok=false;\n\t\t\trep(i,1<<n*n) ok|=vis1[i]&&vis2[i];\n\t\t\tif(ok) break;\n\t\t\t\n\t\t\tvector<bool>& vis=res%2==0?vis1:vis2;\n\t\t\tvector<bool> tmp(1<<n*n);\n\t\t\trep(i,1<<n*n) if(vis[i]) for(int m:mask) tmp[i^m]=1;\n\t\t\tswap(vis,tmp);\n\t\t}\n\t\trep(i,res) cout<<\"myon\"; cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n\nint n,g,bit,res;\nint dis[1<<20];\nvector<int> mask[5][5];\n\nint rec(int g, int t){\n  if(t == 5){\n    if( (g & 31) )return 1000000;\n    return dis[g>>5];\n  }\n  int res = rec(g,t+1);\n  for(int i=0;i<mask[0][t].size();i++)res = min(res,rec(g^mask[0][t][i],t+1)+1);\n  return res;\n}\n    \nint main(){\n  REP(i,0,5)REP(j,0,5)REP(k,i,5)REP(l,j,5){\n    int tmp = 0;\n    REP(y,i,k+1)REP(x,j,l+1)tmp |= 1<<(y*5+x);\n    mask[i][j].push_back(tmp);\n  }\n\n  for(int i=0;i<(1<<20);i++)dis[i] = -1;\n  dis[0] = 0;\n  queue<int> q; q.push(0);\n  while(q.size()){\n    int p = q.front(); q.pop();\n    REP(i,0,4)REP(j,0,5)REP(k,0,mask[i][j].size()){\n      if(mask[i][j][k]>=1<<20)continue;\n      int nxt = p^mask[i][j][k];\n      if(dis[nxt]<0){\n\tdis[nxt] = dis[p] + 1;\n\tq.push(nxt);\n      }\n    }\n  }\n\n  while(cin >> n,n){\n    g = 0;\n    REP(i,0,5)REP(j,0,5)\n      if(i<n && j<n){\n\tcin >> bit;\n\tg |= bit<<(i*5+j);\n      }\n    \n    if(n<5)res = dis[g];\n    else res = rec(g,0);\n    \n    for(int i=0;i<res;i++)cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//int minArrivingDepth[1<<25];\n\nint n;\nconst char INF=100;\n\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint n;\n// X[sy][sx][gy][gx] := 5*5 テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ (sx,sy) - (gx,gy)テ」ツ?ォmyonテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ、ツスツソテ」ツ??bit\nint X[5][5][5][5] = {0};\n// dp[bits] := 5*5 テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ テァツ環カテヲツ??bits テ」ツ?ョテヲツ慊?ァツ淞ュテヲツ可凝ヲツ閉ーテ」ツつ津ィツソツ氾」ツ??\nchar dp[1<<25];\n\n// \"myon\" ** n テ」ツつ津ィツソツ氾」ツ??\nstring ans_myon(int k){\n\tstring res;\n\tfor(int i=0 ; i < k ; i++ ){\n\t\tres += \"myon\";\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfor(int i=0 ; i < (1<<25) ; i++ ){\n\t\tdp[i] = -1;\n\t}\n\tdp[0] = 0;\n\tfor(int ly = 0 ; ly < 5 ; ly++ ){\n\t\tfor(int lx = 0 ; lx < 5 ; lx++ ){\n\t\t\tfor(int ry = ly ; ry < 5 ; ry++ ){\n\t\t\t\tfor(int rx = lx ; rx < 5 ; rx++ ){\n\t\t\t\t\tfor(int y = ly ; y <= ry ; y++ ){\n\t\t\t\t\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\t\t\t\t\tX[ly][lx][ry][rx] |= (1 << (y * 5 + x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int bits){\n\tif( dp[bits] != -1 ) return dp[bits];\n\t\n\t// 1 テ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツキツヲテ、ツクツ甘」ツ?ョテ・ツコツァテヲツィツ凖」ツつ津ヲツ篠「テ」ツ??\n\tint sx, sy;\n\tfor(int i=0 ; i < 25 ; i++ ){\n\t\tif( bits & (1 << i) ){\n\t\t\tsx = i % 5; sy = i / 5; break;\n\t\t}\n\t}\n\tint res = INF;\n\tfor(int y = sy ; y < 5 ; y++ ){\n\t\tfor(int x = sx ; x < 5 ; x++ ){\n\t\t\tint next = bits ^ X[sy][sx][y][x];\n\t\t\tres = min(res, solve(next)+1 );\n\t\t}\n\t}\n\treturn dp[bits] = res;\n}\n\nint main(){\n\tinit();\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\tfor(int i=0 ; i < 25 ; i++ ){\n\t\t\tint e = 0;\n\t\t\tif( i % 5 < n && i / 5 < n ){\n\t\t\t\tcin >> e;\n\t\t\t}\n\t\t\tbits = (bits << 1) + e;\n\t\t}\n\t\t/*for(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tcout << ((bits & (1 << (y*5+x)))? 1 : 0) << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;*/\n\t\tint ans = solve(bits);\n\t\tcout << ans_myon(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tif( dp_5.size() >= 50000 ) break;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\npair<int,int> up_left(int bits, int n){\n\tint mx = 5, my = 5;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tif( get(n,bits,x,y) ){\n\t\t\t\tmx = min( mx , x );\n\t\t\t\tmy = min( my , y );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<int,int> (mx,my);\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_N3(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 3 のすべての解を求めておく\nvoid solve(){\n\tfor(int i=1 ; i <= 4 ; i++ ){\n\t\tif( i == 1 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 3 ){\n\t\t\tdp[2] = vector<char>(512);\n\t\t\tsolve_N3( 3 );\n\t\t}else if( i == 4 ){\n\t\t\tdp[3] = vector<char>(65536);\n\t\t\tsolve_N3( 4 );\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 3 のすべての解を求めておく\n\tsolve();\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tcout << \"end;\" << endl;\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\tdebug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}else if( n == 5 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define calc __builtin_popcount\nusing namespace std;\nint n,G[5][5],ans;\nvector<int>move[30];\nint H(int sta,int k){\n\treturn (calc(sta)+k-1)/k;\t\n}\nint Q[50];\nvoid show(int sta){\n\tfor(int r=0;r<n;r++){\n\t\tfor(int c=0;c<n;c++)\n\t\t\tputchar((sta&(1<<(r*n+c)))?'1':'0');\n\t\tputs(\"\");\n\t}\n\tputs(\"----\");\n}\nvoid DFS(int dep,int k,int sta,int last){\n\tif(k==0)return;\n\tQ[dep]=sta;\n\tif(dep+H(sta,k)>=ans)return;\n\tif(sta==0){\n\t\tans=dep;\n\t\t/*printf(\"ans:%d\\n\",ans);\n\t\tfor(int i=0;i<dep;i++){\n\t\t\tshow(Q[i]);\n\t\t}*/\n\t\treturn;\n\t}\n\tfor(int i=last;i<move[k].size();i++){\n\t\tDFS(dep+1,k,sta^move[k][i],i);\n\t}\n\tDFS(dep,k-1,sta,0);\n}\nvoid init(){\n\tfor(int r=1;r<=n;r++)\n\tfor(int c=1;c<=n;c++){\n\t\tfor(int i=0;i+r-1<n;i++)\n\t\tfor(int j=0;j+c-1<n;j++){\n\t\t\tint sta=0;\n\t\t\tfor(int y=i;y<i+r;y++)\n\t\t\tfor(int x=j;x<j+c;x++)\n\t\t\t\tsta^=(1<<(y*n+x));\n\t\t\tmove[r*c].push_back(sta);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<=n*n;i++)move[i].clear();\n\t\tinit();\n\t\tint sta=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t\t\tif(G[i][j])sta^=(1<<(i*n+j));\n\t\t\t}\n\t\tans=calc(sta);\n\t\tDFS(0,n*n,sta,0);\n\t\tfor(int i=0;i<ans;i++)printf(\"myon\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 3)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  int bf = (field>>20);\n  int nfield = field & (1<<20)-1;\n  int ret = __builtin_popcount(bf) + mincost[nfield];\n\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nvoid p(int e)\n{\n    for (int y = 0; y < 5; ++y)\n    {\n        for (int x = 0; x < 5; ++x)\n            printf(\"%d \", e >> (5 * y + x) & 1);\n        puts(\"\");\n    }\n    puts(\"\");\n}\n\n\nbool enemy(int e, int x, int y)\n{\n    return e >> (5 * y + x) & 1;\n}\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nvoid dfs(int e, int x, int c, int& res)\n{\n    if (x >= 5 || c >= res)\n        return;\n    else if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    for (int yy = 0; yy < 5; ++yy)\n    {\n        for (int x1 = x; x1 < 5; ++x1)\n        {\n            for (int x2 = x1; x2 < 5; ++x2)\n            {\n                int ne = e ^ xor_mask[yy][x1][4][x2];\n                dfs(ne, x + 1, c + 1, res);\n            }\n        }\n    }\n    dfs(e, x + 1, c, res);\n}\nint main()\n{\n    fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        while (!(e & ~((1 << 5) - 1)))\n            e <<= 5;\n\n        int times = 25;\n        dfs(e, 0, 0, times);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\nint a[4][4];\n\nmap<int,char> memo[25];\n\nchar dfs(int p,int bit){\n\tif( p == N * N ){\n\t\t//cout << bit << endl;\n\t\tif( bit != 0 ) return 30;\n\t\telse return 0;\n\t}\n\tif( memo[p].count(bit) ) return memo[p][bit];\n\t\n\tchar ans = 30;\n\t\n\tif( bit >> p & 1 ){\n\t\tfor(int i = 0 ; i < item[p].size() ; i++)\n\t\tans = min(ans,(char)(1+dfs(p+1,bit^item[p][i])));\n\t}else{\n\t\tans = dfs(p+1,bit);\n\t}\n\treturn memo[p][bit] = ans;\n}\n\nint main(){\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\tint x = (int)dfs(0,init);\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\nint a[4][4];\nint memo[(1<<25)/6+10];\n\nchar dfs(int bit){\n\n\tif( bit == 0 ) return 0;\n\tint idx = bit/6;\n\tint pos = (bit%6)*5;\n\t//cout << pos << endl;\n\tchar val = memo[idx] >> pos & ((1<<5)-1);\n\t//cout << (int)val << endl;\n\tif( val != ((1<<5)-1) ) return val;\n\t\n\tchar ans = 30;\n\tfor(int p = 0 ; p < 25 ; p++){\n\t\tif( bit >> p & 1 ){\n\t\t\tfor(int i = 0 ; i < item[p].size() ; i++)\n\t\t\t\tans = min(ans,(char)(dfs(bit^item[p][i])+1));\n\t\t\tbreak;\n\t\t}\n\t}\n\tmemo[idx] &= ~(((1<<5)-1) << pos);\n\tmemo[idx] |= ((int)ans << pos );\n\treturn  ans;\n}\n\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\t//cout << init << endl;\n\t\tint x = (int)dfs(init);\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX_N (5)\nint n;\nchar memo[1<<25];\nint sq[6][6];\nint dfs(int bit){\n\tif(~memo[bit]) { return memo[bit];}\n\tint ans = (1<<25);\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( bit >> (i*MAX_N+j) & 1){\n\t\t\t\tfor(int s1 = 1 ; s1 <= n-i ; s1++)\n\t\t\t\t\tfor(int s2 = 1 ; s2 <= n-j ; s2++)\n\t\t\t\t\t\tans = min( ans , 1 + dfs( bit ^ (sq[s1][s2] << (i*MAX_N+j) ) ) );\n\t\t\t\tgoto endfunction;\n\t\t\t}\n\t\t}\n\t}\n\tendfunction: return memo[bit] = ans;\n}\nint gen(int x,int y){\n\tint ans = 0;\n\tfor(int i = 0 ; i < y ; i++)\n\t\tfor(int j = 0 ; j < x ; j++)\n\t\t\tans |= 1<< (i*MAX_N+j);\n\treturn ans;\n}\nint main(){\n\tfor(int i = 1 ; i <= 5 ; i++) for(int j = 1 ; j <= 5 ; j++) sq[i][j] = gen(j,i);\n\tmemset(memo,-1,sizeof(memo));\n\tmemo[0] = 0;\n\t\n\twhile(cin >> n , n){\n\t\tint bit = 0 , a;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tcin >> a , bit |= a << (i * MAX_N + j);\n\t\tint r = dfs(bit);\n\t\tfor(int i = 0 ; i < r ; i++)\n\t\t\tcout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\n#define SIZE (5)\n#define SET(t, x, y) (((t) |= (1 << ((y) * SIZE + (x)))))\n#define CHECK(t, x, y) (((t) & ((1 << ((y) * SIZE + (x))))) != 0)\n\nint ans;\nunsigned int hash[1 << 25];\n\nint numofbits5(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint dfs(unsigned int field, vector<unsigned int>& table, int depth)\n{\n\tif (field == 0){\n\t\tif (ans > depth){\n\t\t\tans = depth;\n\t\t}\n\t\treturn (0);\n\t}\n\tif (ans <= depth || hash[field] <= depth){\n\t\treturn (0);\n\t}\n\t\n\thash[field] = depth;\n\t\n\tfor (int i = table.size() - 1; i >= 0; i--){\n\t\tif (numofbits5(field) > numofbits5(field ^ table[i])){\n\t\t\tdfs(field ^ table[i], table, depth + 1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\n\nint main(void)\n{\n\tunsigned int field;\n\tint n;\n\tvector<unsigned int> table;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttable.clear();\n\t\tmemset(hash, -1, sizeof(hash));\n\t\tfor (int y = 0; y < n; y++){\n\t\t\tfor (int x = 0; x < n; x++){\n\t\t\t\tfor (int i = 1; i <= n - y; i++){\n\t\t\t\t\tfor (int j = 1; j <= n - x; j++){\n\t\t\t\t\ttable.push_back(0);\n\t\t\t\t\tfor (int dy = y; dy < y + i; dy++){\n\t\t\t\t\t\tfor (int dx = x; dx < x + j; dx++){\n\t\t\t\t\t\t\tSET(table.back(), dx, dy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfield = 0;\n\t\tans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1){\n\t\t\t\t\tSET(field, j, i);\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = n * n / 2 + 1;\n\t\t\n\t\tdfs(field, table, 0);\n\t\t\n\t\tfor (int i = 0; i < ans; i++){\n\t\t\tprintf(\"myon\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\t//if(((s>>(miny*n+minx))&1)==0)\n\t\t\t//\tcontinue;\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\t//int b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tint b=(s&(1<<(i*n+j)));\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=(~(1<<(i*n+j)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//// c\n\t\t\t//for(int height=1; height+miny-1<n; height++){\n\t\t\t//\t// ¡\n\t\t\t//\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t//\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t//\t\tint ns=s;\n\t\t\t//\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t//\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t//\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t//\t\t\t\tif(b==0)\n\t\t\t//\t\t\t\t\tb=1;\n\t\t\t//\t\t\t\telse\n\t\t\t//\t\t\t\t\tb=0;\n\t\t\t//\t\t\t\t// bÌrbgðãü\n\t\t\t//\t\t\t\tif(b==0)\n\t\t\t//\t\t\t\t\tns&=(~(1<<(i*n+j)));\n\t\t\t//\t\t\t\telse\n\t\t\t//\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t//\t\t\t}\n\t\t\t//\t\t}\n\t\t\t//\t\t// ÌóÔð\n\t\t\t//\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t//\t}\n\t\t\t//}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tif(bit==1)\n\t\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int t,v;\n  bool operator<(S a)const{\n    if(t!=a.t){\n      return t<a.t;\n    }else{\n      return v<a.v;\n    }\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    set<S> que;\n    S is={0,v};\n    que.insert(is);\n    set<int> s;\n    for(;;){\n      S c=*que.begin();\n      if(c.v==0)break;\n      que.erase(que.begin());\n      if(!s.insert(c.v).second)continue;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=j;l<n;l++){\n\t    for(int m=k;m<n;m++){\n\t      int nv=c.v;\n\t      for(int o=j;o<=l;o++){\n\t\tfor(int p=k;p<=m;p++){\n\t\t  nv^=1<<o*n+p;\n\t\t}\n\t      }\n\t      if(s.count(nv))continue;\n\t      S ns={c.t+1,nv};\n\t      que.insert(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<que.begin()->t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint rec[6][6][6][6];\nint n;\nint solve(int p,int q,int t,int c){\n\tif(t==0){\n\t\tif(c)return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t,c);\n\tif(!(c&(1<<(p*n+q))))return solve(p,q+1,t,c);\n\tfor(int h=q;h<n;h++){\n\t\tfor(int i=p;i<n;i++){\n\t\t\tif(solve(p,q+1,t-1,c^rec[p][q][i][h]))return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<6;i++)for(int j=0;j<6;j++)for(int k=0;k<6;k++)for(int l=0;l<6;l++)\n\t\t\trec[i][j][k][l]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tfor(int k=i;k<a;k++)for(int l=j;l<a;l++){\n\t\t\t\tfor(int x=i;x<=k;x++)for(int y=j;y<=l;y++)\n\t\t\t\t\trec[i][j][k][l]+=(1<<(x*a+y));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tint st=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(b[i][j])st+=(1<<(i*a+j));\n\t\tfor(int i=1;;i++){\n\t\t\tif(solve(0,0,i,st)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\t//if(depth!=0&&s==start){\n\t//\treturn INF;\n\t//}\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;p\n\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\t//if(res==STOP){\n\t\t\t\t\t\t//\treturn INF;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tfill(dp,dp+(1<<25),INF);\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t// c\n\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t// ¡\n\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\t\tint ns=0;\n\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[ns]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint mask[5][5][6][6];\nint main() {\n  REP(i, 5) REP(j, 5)\n    for (int h=1; h<=5-i; ++h)\n      for (int w=1; w<=5-j; ++w) {\n        int m = (1<<w)-1;\n        REP(k,h) mask[i][j][h][w] ^= m<<(i+k)*5+j;\n      }\n  unsigned char memo[1<<20];\n  memset(memo, -1, sizeof(memo));\n  queue<int> Q;\n  Q.push(0);\n  memo[0] = 0;\n  while(!Q.empty()) {\n    int S = Q.front();\n    Q.pop();\n    int c = memo[S] + 1;\n//    cout << c << endl;\n    REP(i, 4) {\n      REP(j, 5) {\n        for (int h=1; h<=4-i; ++h) {\n          for (int w=1; w<=5-j; ++w) {\n            // i+h, j+w\n            int tmp = S^mask[i][j][h][w];\n            if (memo[tmp] > c) {\n              memo[tmp] = c;\n              Q.push(tmp);\n            }\n          }\n        }\n      }\n    }\n  }\n  // cout << (int)memo[473536] << endl;\n  // cout << \"OK\" << endl;\n  \n  int n;\n  while(cin >> n, n) {\n    int SS = 0;\n    int cnt = 0;\n    REP(i,n*n) {\n      bool a;\n      cin >> a;\n      if (a)\n        SS |= 1<<cnt;\n      cnt++;\n      if (cnt%5==n) {\n        cnt += 5-n;\n      }\n    }\n//    cout << bitset<25>(SS) << endl;\n    if (n<5) {\n      REP(i,(int)memo[SS])\n        cout << \"myon\";\n      cout << endl;\n      continue;\n    }\n\n    int res = INF;\n    REP(i,5*5*5*5*5) {\n      int aa = i;\n      int height[5];\n      REP(j,5) {\n        height[j] = aa % 5 + 1;\n        aa /= 5;\n      }\n      REP(S,1<<5) {\n        int hoge = 0;\n        int tmp = SS;\n        int mae = -1;\n        REP(j,5) {\n          if ((S>>j)&1) {\n            if (mae != height[j]) hoge++;\n            REP(k, height[j]) {\n              tmp ^= 1 << ((4-k)*5 + j);\n            }\n            mae = height[j];\n          } else\n            mae = -1;\n        }\n        int kari = tmp & ((1<<20)-1);\n        if (i==5*5*5*5*5-1 && S==(1<<5)-1) {\n          // REP(k,5) {\n          //   cout << height[k] << \" \";\n          // }cout << endl;\n          // cout << bitset<25>(tmp) << endl;\n          // cout << hoge << \" \"  << (int)memo[kari] << endl;\n        }\n        if (kari==tmp)\n          res = min(res, hoge+memo[kari]);\n      }\n    }\n    \n    REP(i,res)\n      cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 5)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  rep(i,(1<<5))mincost5[i] = 100; \n  bitset<30> b(field),b2(field>>20);\n  //cout << \"b = \" << b << endl;\n  //cout << \"b2 = \" << b2 << endl;\n  mincost5[(field>>20)] = 0;\n  int ret = 5;\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nunion S{\n  struct{\n    int t,v;\n  }s;\n  long long p;\n  bool operator<(S a)const{\n    return p<a.p;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    set<S> que;\n    S is={0,v};\n    que.insert(is);\n    set<int> s;\n    for(;;){\n      S c=*que.begin();\n      if(c.s.v==0)break;\n      que.erase(que.begin());\n      if(!s.insert(c.s.v).second)continue;\n      int j,k;\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  if(c.s.v>>j*n+k&1)goto next;\n\t}\n      }\n    next:\n      for(int l=j;l<n;l++){\n\tfor(int m=k;m<n;m++){\n\t  int nv=c.s.v;\n\t  for(int o=j;o<=l;o++){\n\t    for(int p=k;p<=m;p++){\n\t      nv^=1<<o*n+p;\n\t    }\n\t  }\n\t  if(s.count(nv))continue;\n\t  S ns={c.s.t+1,nv};\n\t  que.insert(ns);\n\t}\n      }\n    }\n    for(int i=0;i<que.begin()->s.t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst int INF=100000000;\n\nint dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=min(res,25);\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint b[7][7];\nint conv[230];\nchar bfs[1<<25];\nint v;\nint main(){\n\tint a;\n\tfor(int i=0;i<(1<<25);i++)bfs[i]=-1;\n\tfor(int i=0;i<5;i++)for(int j=i;j<5;j++)for(int k=0;k<5;k++)for(int l=k;l<5;l++){\n\t\tfor(int m=i;m<=j;m++)for(int n=k;n<=l;n++){\n\t\t\tconv[v]+=1<<(m*5+n);\n\t\t}\n\t\tv++;\n\t}\n\tqueue<int>Q;\n\tQ.push(0);\n\tbfs[0]=0;\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<v;i++){\n\t\t\tif(!~bfs[at^conv[i]]){\n\t\t\t\tbfs[at^conv[i]]=bfs[at]+1;\n\t\t\t\tQ.push(at^conv[i]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)b[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tint at=0;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)\n\t\t\tat+=(b[i][j]<<(i*5+j));\n\t\tint ret=bfs[at];\n\t\tfor(int i=0;i<ret;i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\nmap<int,char> mem;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\t//if(depth!=0&&s==start){\n\t//\treturn INF;\n\t//}\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;p\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\t//if(res==STOP){\n\t\t\t\t\t\t//\treturn INF;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tfill(dp,dp+(1<<25),INF);\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t// c\n\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t// ¡\n\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\t\tint ns=0;\n\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[ns]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(map<int,char>::iterator it = mem.begin(); it!=mem.end(); it++){\n\t\t\tdp[it->first]=it->second;\n\t\t}\n\n\t\tchar cnt=minStep(init,0);\n\t\tmem[init]=cnt;\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n//bool passed[1<<25];\nset<int> passed;\n\nint field[10][10];\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ss=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j])ss|=(1<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tpassed.clear();\n\t\t//memset(passed,0,sizeof(passed));\n\t\tqueue<int> q[2];\n\t\tint cur=0;\n\t\tint nxt=1;\n\t\tq[cur].push(ss);\n\t\tint cnt=0;\n\t\t//passed[ss]=true;\n\t\tpassed.insert(ss);\n\t\tbool fin=false;\n\t\twhile(q[cur].size()){\n\t\t\twhile(q[cur].size()){\n\t\t\t\tint cs=q[cur].front();\n\t\t\t\tif(cs==0){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq[cur].pop();\n\t\t\t\t// csÌóÔ©çÚ®Å«éóÔðñ\n\t\t\t\tint minx,miny;\n\t\t\t\tminx=miny=-1;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif((cs>>(i*n+j))&1){\n\t\t\t\t\t\t\tminx=j;\n\t\t\t\t\t\t\tminy=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(minx!=-1)break;\n\t\t\t\t}\n\t\t\t\t// EºÌÀWðè\n\t\t\t\tfor(int i=miny;i<n;i++){\n\t\t\t\t\tfor(int j=minx;j<n;j++){\n\t\t\t\t\t\t// ½]\n\t\t\t\t\t\tint ns=cs;\n\t\t\t\t\t\tfor(int k=miny;k<=i;k++){\n\t\t\t\t\t\t\tfor(int l=minx;l<=j;l++){\n\t\t\t\t\t\t\t\tif((ns>>(k*n+l))&1)ns&=~(1<<(k*n+l));\n\t\t\t\t\t\t\t\telse ns|=(1<<(k*n+l));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(passed.find(ns)==passed.end()){\n\t\t\t\t\t\t\tq[nxt].push(ns);\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tpassed.insert(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)break;\n\t\t\tcnt++;\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tfor(int i=0;i<cnt;i++)cout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint n;\n\nstruct State {\n    int step, g;\n    State(int step, int g)\n        :step(step), g(g){}\n\n    void flip(int x, int y, int w, int h){\n        int t = (((1 << w) - 1) << x);\n        rep(i, h){\n            g ^= t << (n*(i + y));\n        }\n    }\n\n    void print(){\n        rep(i, n){\n            rep(j, n){\n                cout << ((g >> (i*n + j)) & 1);\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    while (cin >> n && n){\n        State init(0, 0);\n        rep(i, n)rep(j, n){\n            int x; cin >> x;\n            if (x)init.flip(j, i, 1, 1);\n        }\n        queue<State> q;\n        q.push(init);\n        static bool vis[1 << 25];\n        memset(vis, 0, sizeof(vis));\n        vis[init.g] = true;\n        int res = -1;\n        while (q.size()){\n            State s = q.front();\n            q.pop();\n            if (s.g == 0) {\n                res = s.step;\n                break;\n            }\n            vis[s.g] = true;\n            rep(i, n){\n                rep(j, n){\n                    if ((s.g >> (i*n + j)) & 1){\n                        rep(h, n - i){\n                            rep(w, n - j){\n                                s.flip(j, i, w + 1, h + 1);\n                                s.step++;\n                                if (!vis[s.g]) q.push(s);\n                                s.flip(j, i, w + 1, h + 1);\n                                s.step--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        rep(i, res)cout << \"myon\";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nunsigned char cost[1<<20];\nint mask[5][5][6][6];\nvoid gen(){\n\tmemset(cost,-1,sizeof(cost));\n\tcost[0]=0;\n\trep(i,5)rep(j,5)for(int h=1;h<=5-i;h++)for(int w=1;w<=5-j;w++){\n\t\tint m=(1<<w)-1;\n\t\trep(k,h)mask[i][j][h][w]^=m<<(i+k)*5+j;\n\t}\n\tqueue<int> Q; Q.push(0); int cnt=0;\n\twhile(!Q.empty()){\n\t\tint c=Q.front(),cc=cost[c]; Q.pop();\n\t\trep(i,4)rep(j,5)for(int h=1;h<=4-i;h++)for(int w=1;w<=5-j;w++){\n\t\t\tint nc=c^mask[i][j][h][w];\n\t\t\tif(cost[nc]>cc+1)cost[nc]=cc+1,Q.push(nc);\n\t\t}\n\t}\n}\nint lim;\nint getcost(int c){\n\tint ret=cost[c&(1<<20)-1],bit=0;\n\tfor(c>>=20;c;c&=c-1)bit++;\n\treturn ret+min(bit,6-bit);\n}\nvoid rec(int c,int x,int cnt){\n\tif(c>>20==0)lim=min(lim,cost[c]+cnt);\n\tif(x>=5)return;\n\t\n\trep(i,5)for(int j=x;j<5;j++){\n\t\tint nc=c^mask[i][x][5-i][j-x+1];\n\t\tif(!(nc&1<<20+x))rec(nc,x+1,cnt+1);\n\t}\n\tif(!(c&1<<20+x))rec(c,x+1,cnt);\n}\nint solve(int c){\n\tlim=getcost(c);\n\trec(c,0,0);\n\treturn lim;\n}\nint main(){\n\tgen();\n\t\n\tint n,ans;\n\twhile(cin>>n,n){\n\t\tint c=0,t;\n\t\trep(i,n)rep(j,n){\n\t\t\tcin>>t;\n\t\t\tif(t)c^=1<<i*5+j;\n\t\t}\n\t\tans=n<5?cost[c]:solve(c);\n\t\trep(i,ans)cout<<\"myon\"; cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\n#define data unsigned char\n\nint op[5][5][5][5][5], n;      \ndata dp[5][1<<25];\n\ndata solve(int mask) {\n    if(mask == 0) return 0;\n    data &ans = dp[n - 1][mask];\n    if(ans != 255) return ans;\n\n    int x, y;\n    for(x = 0; x < n; ++x){\n        for(y = 0; y < n; ++y)\n            if(mask & (1<<(n * x+ y )))\n                break;\n        if(y != n) break;\n    }\n    \n    FOR(i,x,n){\n        FOR(j,y,n){\n            int next = (mask ^ op[n-1][x][y][i][j]);\n            data tmp =  solve(next) + 1;\n            if (tmp < ans)\n                ans = tmp;\n        }\n    }\n    return ans;\n}\n\nint main(){\n  memset(op,0,sizeof(op));\n  FOR(m,1,6)\n    REP(li,m)\n      REP(lj,m)\n        FOR(hi,li,m)\n          FOR(hj,lj,m)\n            FOR(i,li,hi+1)\n              FOR(j,lj,hj+1)\n                op[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n\n  memset(dp, -1 ,sizeof(dp));\n  while(scanf(\"%d\", &n), n){\n      int mask = 0;\n      REP(i,n){\n          REP(j,n){\n              int tmp;\n              scanf(\"%d\", &tmp);\n              if(tmp == 1){\n                  mask |= (1<<(i*n+j));\n              }\n          }\n      }\n\n      int ans = solve(mask);\n      REP(i,ans)\n          printf(\"myon\");\n      puts(\"\"); \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<iterator>\nusing namespace std;\nint F(int x1,int x2,int y1,int y2,int n)\n{\n\tint r=0,y,x;\n\tfor(y=n-1;y>=0;--y)\n\t{\n\t\tfor(x=4;x>=0;--x)\n\t\t{\n\t\t\tr<<=1;\n\t\t\tif(y1<=y&&y<=y2&&x1<=x&&x<=x2)\n\t\t\t\t++r;\n\t\t}\n\t}\n\treturn r;\n}\n\n\ntypedef vector<int>V;\nvector<V>v(3);\nV t;\n\ntypedef map<int,int>M;\nvoid U(V&v)\n{\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n}\nint main()\n{\n\tint n,i,j,k,l;\n\tv[0].push_back(0);\n\tv[1].reserve(225);\n\tv[2].reserve(17700);\n\tt.reserve(25200);\n\tconst int H=5,W=5;\n\tfor(i=0;i<W;++i)for(j=i;j<W;++j)for(k=0;k<H;++k)for(l=k;l<H;++l)v[1].push_back(F(i,j,k,l,5));\n\tU(v[1]);\n\n\tfor(i=0;i<v[1].size();++i)for(j=i+1;j<v[1].size();++j)t.push_back(v[1][i]^v[1][j]);\n\tU(t);\n\tset_difference(t.begin(),t.end(),v[1].begin(),v[1].end(),back_inserter(v[2]));\n\tt.clear();\n\n\tM m;\n\tfor(i=0;i<3;++i)for(j=0;j<v[i].size();++j)\n\t{\n\t\tm[v[i][j]]=i;\n\t\tm[22041621^v[i][j]]=9-i;\n\t}\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint a[5][5]={},res,x=0;\n\t\tfor(i=0;i<n;++i)for(j=0;j<n;++j)scanf(\"%d\",&a[i][j]);\n\t\tfor(i=0;i<5;++i)for(j=0;j<5;++j)x|=(1<<(5*i+j))*a[i][j];\n\t\tfor(i=0;i<3;++i)for(j=0;j<v[i].size();++j)\n\t\t{\n\t\t\tM::iterator ite=m.find(x^v[i][j]);\n\t\t\tif(ite!=m.end())\n\t\t\t{\n\t\t\t\tif(ite->second<5)res=ite->second+i;\n\t\t\t\telse res=ite->second-i;\n\t\t\t\tgoto N;\n\t\t\t}\n\t\t}\n\t\tN:;\n\t\tfor(i=0;i<res;++i)printf(\"myon\");\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nbool enemy(int e, int x, int y)\n{\n    return e >> (5 * y + x) & 1;\n}\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nvoid dfs(int e, int y, int c, int& res)\n{\n    if (y >= 5 || c >= res)\n        return;\n\n    if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    // top-left: (x, y)\n    for (int x1 = 0; x1 < 5; ++x1)\n    {\n        for (int x2 = x1; x2 < 5; ++x2)\n        {\n            int ne = e ^ xor_mask[y][x1][4][x2];\n            dfs(ne, y + 1, c + 1, res);\n        }\n    }\n    dfs(e, y + 1, c, res);\n}\nint main()\n{\n    // fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        while (!(e & ~((1 << 5) - 1)))\n            e <<= 5;\n\n        int times = 13;\n        dfs(e, 0, 0, times);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef unsigned long long ull;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint n;\null encode( bool b[5][5]){\n    ull res = 0;\n    REP(y, n) REP(x, n){\n        res = (res << 1) + (b[y][x] ? 1 : 0);\n    }\n    return res;\n}\nvoid decode(ull S, bool b[5][5]){\n    for(int y = n - 1; y >= 0; y--){\n        for(int x = n - 1; x >= 0; x--){\n            b[y][x] = (S & 1);\n            S = S >> 1;\n        }\n    }\n}\nint h(bool b[5][5]){\n    bool used[5][5] = {};\n    int res = 0;\n    REP(y, n) REP(x, n) if(!used[y][x] && b[y][x]){\n        res++;\n        queue<int> qx, qy;\n        qx.push(x), qy.push(y);\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4){\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && ny >= 0 && nx < n && ny < n && !used[ny][nx] && b[ny][nx]){\n                    qx.push(nx); qy.push(ny);\n                    used[ny][nx] = true;\n                }\n            }\n        }\n    }\n    return res;\n}\nint answer;\nint dfs(ull S, int cost){\n    bool b[5][5];\n    decode(S, b);\n    int h_cost = h(b);\n    if(cost + h_cost >= answer) return INF;\n    if(h_cost == 0) return answer = cost;\n    int res = INF;\n    for(int y0 = 0; y0 < n; y0++)\n    for(int y1 = y0; y1 < n; y1++)\n    for(int x0 = 0; x0 < n; x0++)\n    for(int x1 = x0; x1 < n; x1++){\n        for(int y = y0; y <= y1; y++)\n        for(int x = x0; x <= x1; x++){\n            b[y][x] = (b[y][x] ? false : true);\n        }\n        res = min(res, dfs(encode(b), cost + 1));\n        for(int y = y0; y <= y1; y++)\n        for(int x = x0; x <= x1; x++){\n            b[y][x] = (b[y][x] ? false : true);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        bool b[5][5];\n        REP(y, n) REP(x, n){\n            cin >> b[y][x];\n        }\n        answer = 0;\n        while(true){\n            int res = dfs(encode(b), 0);\n            if(res < INF){\n                REP(iter, res) cout << \"myon\";\n                cout << endl;\n                break;\n            }\n            answer++;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <memory.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n#define MAX 999999999\nint xorMemo[5][5][5][5][5];\nshort n, f[1<<25];         \n\ninline short min(short a, short b){\n\treturn a < b ? a : b;\n}\ninline short solve(int bit){\n\tif (bit == 0) return 0;\n\tif (f[bit] != -1) return f[bit];\n\tshort li, lj;\n\tfor (li=0;li<n;li++){\n\t\tfor (lj=0;lj<n;lj++)\n\t\t\tif ((bit & (1<<(n*li+lj))) != 0) break;\t\n\t\tif (lj != n) break;\n\t}\n\tint res = MAX;\n\tfor (short hi=li;hi<n;hi++)\n\t\tfor (short hj=lj;hj<n;hj++){\n\t\t\tint next = (bit ^ xorMemo[n-1][li][lj][hi][hj]);\n\t\t\tres = min(res, solve(next)+1);\n\t\t}\n\treturn f[bit] = res;\n}\n\nshort main(){\n\tmemset(xorMemo,0,sizeof(xorMemo));\n\tmemset(f,-1,sizeof(f));\n\tfor (short m=1;m<6;m++)\n\t\tfor (short li=0;li<m;li++)\n\t\t\tfor (short lj=0;lj<m;lj++)\n\t\t\t\tfor (short hi=li;hi<m;hi++)\n\t\t\t\t\tfor (short hj=lj;hj<m;hj++)\n\t\t\t\t\t\tfor (short i=li;i<hi+1;i++)\n\t\t\t\t\t\t\tfor (short j=lj;j<hj+1;j++){\n\t\t\t\t\t\t\t\txorMemo[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n\t\t\t\t\t\t\t\t//cout << xorMemo[m-1][li][lj][hi][hj] << \" \";\n\t\t\t\t\t\t\t}\n\t\n\twhile (scanf(\"%d\",&n) && n != 0){\n\t\tint bit = 0;\n\t\tfor (short i=0;i<n;i++)\n\t\t\tfor (short j=0;j<n;j++){\n\t\t\t\tshort x;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif(x == 1) bit |= (1<<(i*n+j));\n\t\t\t}\n\t\tshort ans = solve(bit);\n\t\tfor (short i=1;i<=ans;i++) printf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 40000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\n// map<int, short> dp;\nshort dp[1 << 25];\nint recur(int e, int sum, int& min_res)\n{\n    if (e == 0)\n        return 0;\n    if (dp[e])\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = (n * n + 1) / 2;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  //vector<bool> close(1<<(5*5), false);\n  vector<int> close((1<<(5*5))/32, 0);\n  vector<int> cls(1000000);\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n\n    vector<vector<int> > pats(33);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[__builtin_clz(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n\tif (close[nbd>>5]&(1<<(nbd&31))) continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls_cnt; i++)\n      close[(cls[i]&0x1ffffff)>>5]=0;\n    cls_cnt=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\nint ss=0;\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst int INF=1000000000;\n\nint dfs(int s){\n    if(dp[s]!=-1){\n        return dp[s];\n    }\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=res;\n}\n\nint main(){\n\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < res; i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 8000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 8000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\tdfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint solve(int x,const vi& ms,unordered_map<int,int>& memo)\n{\n\tauto i=memo.find(x);\n\tif(i!=end(memo)) return i->second;\n\t\n\tif(x==0) return memo[x]=0;\n\tint res=INF;\n\tfor(int m:ms) if(__builtin_ctz(x)==__builtin_ctz(m))\n\t\tres=min(res,solve(x^m,ms,memo));\n\treturn memo[x]=res+1;\n}\n\nint main()\n{\n\tvi ms;\n\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\tint m=0;\n\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\tms.push_back(m);\n\t}\n\tunordered_map<int,int> memo;\n\t\n\tfor(int n;cin>>n && n;){\n\t\tint x=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx|=b<<(i*5+j);\n\t\t}\n\t\t\n\t\tint res=solve(x,ms,memo);\n\t\trep(i,res) cout<<string(\"myon\"); cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Mysterious Onslaught\n//Level: 4\n//Category: DP,ビット演算\n//Note:\n\n/*\n * 状態数は全部で 2^25 だが，これはちょうどメモリ制限の値と等しいため\n * 愚直な探索では解を求められない．\n * この手の問題だと上の行の状態を覚えておいて下の行に伝搬させるのが常套手段だが，\n * この問題でもその手法が使える．\n *\n * この問題で上の行から下の行へ伝搬する状態は，上の行でどのように矩形が置かれていたかである．\n * たとえばある行 r で 1〜3 列目を埋めるように矩形が置かれていた場合，その下の行 r+1 でも\n * 同じように 1〜3 列目を埋めるようにすると，これらはまとめて1個の矩形で表現できるため\n * コストが下がる．\n *\n * ある行について，列 x から右に矩形を伸ばしたとき，その幅は N-x 通り存在する．\n * これを各列について合計すると N=5 のときでも 15 通りであるから，1行を覆う矩形の取り方は\n * 高々 2^15 通り．\n * このうちその行を全滅させる置き方は更に少ないと予測できるので，そのような置き方だけを覚えて\n * 直前の状態として使うと計算量が抑えられる．\n * 実際には N=5 の時で 1024 通りになるので，1行の更新は 2^25 ループ程度で完了できる．\n *\n * 以下のコードではビット演算を使って，矩形の正当性(ちゃんと全てのビットを0にできるか)の判定を高速化している．\n * オーダーは O(2^(N^2)) ．\n */\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 30;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        vector<int> field(N);\n        for(int i = 0; i < N; ++i) {\n            int pat = 0;\n            for(int j = 0; j < N; ++j) {\n                int v;\n                cin >> v;\n                pat <<= 1;\n                pat |= v;\n            }\n            field[i] = pat;\n        }\n        // ビット演算で扱いやすくするため，右端を座標 0 として扱う．\n        vector<int> myons; // 行にかかるmyon\n        for(int c = 0; c < N; ++c) { // 右端の位置\n            for(int w = 1; w <= N-c; ++w) {\n                int mask = ((1<<w)-1) << c;\n                myons.push_back(mask);\n                //cout << mask << endl;\n            }\n        }\n        const int M = myons.size();\n        // 0: prev\n        // 1: cur\n        vector<int> valid_pats[2];\n        vector<int> dp[2];\n        dp[0].resize(1<<M, INF);\n        dp[1].resize(1<<M, INF);\n        for(int r = 0; r < N; ++r) {\n            valid_pats[1].clear();\n            fill(dp[1].begin(), dp[1].end(), INF);\n            for(int pat = 0; pat < (1<<M); ++pat) {\n                int mask = 0;\n                for(int i = 0, ord = 1; i < M; ++i, ord <<= 1) {\n                    if(pat & ord) mask ^= myons[i];\n                }\n                if(mask == field[r]) {\n                    // Valid pattern\n                    int cost = INF;\n                    const int bits = __builtin_popcount(pat);\n                    if(r != 0) {\n                        // コストは\n                        //   直前で有効な状態のコスト + 現在のパターンのコスト - 直前と合成する矩形のコスト\n                        for(vector<int>::iterator it = valid_pats[0].begin(); it != valid_pats[0].end(); ++it) {\n                            cost = min(cost, dp[0][*it] + bits - __builtin_popcount(pat & *it));\n                        }\n                    } else {\n                        cost = bits;\n                    }\n                    //cout << r << ' ' << pat << ' ' << cost << endl;\n                    dp[1][pat] = cost;\n                    valid_pats[1].push_back(pat);\n                }\n            }\n            valid_pats[0].swap(valid_pats[1]);\n            dp[0].swap(dp[1]);\n        }\n        int ans = INF;\n        for(vector<int>::iterator it = valid_pats[0].begin(); it != valid_pats[0].end(); ++it) {\n            ans = min(ans, dp[0][*it]);\n        }\n        for(int i = 0; i < ans; ++i) {\n            cout << \"myon\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\t//if( n <= 3 ){\n\t\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t\t//}else if( n == 4 ){\n\t\t\t//\tcout << s[2] << endl;\n\t\t\t//}\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst char INF=30;\n\nchar dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=(char)res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\nvoid pv(int bit,int h,int w){\n\trep(i,h)rep(j,w)cerr<<!!(bit&1<<i*w+j)<<(j==w-1?\"\\n\":\" \");\n}\n\nunsigned char cost[1<<20];\nint mask[5][5][6][6];\nvoid gen(){\n\tmemset(cost,-1,sizeof(cost));\n\tcost[0]=0;\n\trep(i,5)rep(j,5)for(int h=1;h<=5-i;h++)for(int w=1;w<=5-j;w++){\n\t\tint m=(1<<w)-1;\n\t\trep(k,h)mask[i][j][h][w]^=m<<(i+k)*5+j;\n\t}\n\tqueue<int> Q; Q.push(0); int cnt=0;\n\twhile(!Q.empty()){\n\t\tint c=Q.front(),cc=cost[c]; Q.pop();\n\t\trep(i,4)rep(j,5)for(int h=1;h<=4-i;h++)for(int w=1;w<=5-j;w++){\n\t\t\tint nc=c^mask[i][j][h][w];\n\t\t\tif(cost[nc]>cc+1)cost[nc]=cc+1,Q.push(nc);\n\t\t}\n\t}\n}\nint lim;\nint getcost(int c){\n\tint ret=cost[c&(1<<20)-1],bit=0;\n\tfor(c>>=20;c;c&=c-1)bit++;\n\treturn ret+min(bit,6-bit);\n}\nvoid rec(int c,int x,int cnt){\n\tif(c>>20==0)lim=min(lim,cost[c]+cnt);\n\tif(x>=5)return;\n\t\n\trep(i,5)for(int j=x;j<5;j++){\n\t\tint nc=c^mask[i][x][5-i][j-x+1];\n\t\tif(!(nc&1<<20+x))rec(nc,x+1,cnt+1);\n\t}\n\tif(!(c&1<<20+x))rec(c,x+1,cnt);\n}\nint solve(int c){\n\tlim=getcost(c);\n\trec(c,0,0);\n\treturn lim;\n}\nint main(){\n\tgen();\n\t\n\tint n,ans;\n\twhile(cin>>n,n){\n\t\tint c=0,t;\n\t\trep(i,n)rep(j,n){\n\t\t\tcin>>t;\n\t\t\tif(t)c^=1<<i*5+j;\n\t\t}\n\t\tans=n<5?cost[c]:solve(c);\n\t\trep(i,ans)cout<<\"myon\"; cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n        ret = min(ret, calc(y, x + 1) + 1);\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nvoid p(int e)\n{\n    for (int y = 0; y < 5; ++y)\n    {\n        for (int x = 0; x < 5; ++x)\n            printf(\"%d \", e >> (5 * y + x) & 1);\n        puts(\"\");\n    }\n    puts(\"\");\n}\n\n\nbool enemy(int e, int x, int y)\n{\n    return e >> (5 * y + x) & 1;\n}\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nvoid dfs(int e, int x, int c, int& res)\n{\n    if (x >= 5 || c >= res)\n        return;\n    else if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    for (int y = 0; y < 5; ++y)\n    {\n        for (int x1 = x; x1 < 5; ++x1)\n        {\n            for (int x2 = x1; x2 < 5; ++x2)\n            {\n                int ne = e ^ xor_mask[y][x1][4][x2];\n                dfs(ne, x + 1, c + 1, res);\n            }\n        }\n    }\n    dfs(e, x + 1, c, res);\n}\nint main()\n{\n    fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        while (!(e & ~((1 << 5) - 1)))\n            e <<= 5;\n\n        int times = 13;\n        dfs(e, 0, 0, times);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\nmap<int,char> mem;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\t//if(depth!=0&&s==start){\n\t//\treturn INF;\n\t//}\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;p\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nvoid initSit(){\n\tfill(dp,dp+(1<<25),INF);\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\tint ns=0;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[ns]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(map<int,char>::iterator it=mem.begin();it!=mem.end();it++)\n\t\tdp[it->first]=it->second;\n}\n\n\nvoid bfs(int s){\n\tqueue<int> *prv=new queue<int>();\n\tqueue<int> *nxt=new queue<int>();\n\tprv->push(0);\n\tfill(dp,dp+(1<<25),INF);\n\tint cnt=0;\n\twhile(prv->size()){\n\t\tcout<<cnt<<endl;\n\t\twhile(prv->size()){\n\t\t\tint cp=prv->front();\n\t\t\tprv->pop();\n\t\t\tif(dp[cp]!=INF)\n\t\t\t\tcontinue;\n\t\t\tdp[cp]=cnt;\n\t\t\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t\t\t// ¶ãÌÀW\n\t\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t\t// c\n\t\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t\t// ¡\n\t\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\t\t\tint ns=cp;\n\t\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(dp[ns]==INF)\n\t\t\t\t\t\t\t\tnxt->push(ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n}\n\nint main(){\n\tn=5;\n\tbfs(0);\n\tcout<<endl;\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tchar cnt;\n\t\t//initSit();\n\t\t//mC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=dp[init];\n\t\t//start=init;\n\t\t//cnt=minStep(init,0);\n\t\t//mem[init]=cnt;\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<unsigned> > change(25);\nvector<char> memo(1<<25, -1);\n\nint solve(unsigned enemy)\n{\n    if(enemy == 0)\n        return 0;\n    if(memo[enemy] != -1)\n        return memo[enemy];\n\n    int k = 0;\n    while(!(enemy & (1 << k)))\n        ++ k;\n\n    int ret = INT_MAX;\n    for(unsigned i=0; i<change[k].size(); ++i){\n        unsigned next = enemy ^ change[k][i];\n        ret = min(ret, solve(next) + 1);\n    }\n\n    return memo[enemy] = ret;\n}\n\nint main()\n{\n    for(int i=0; i<25; ++i){\n        for(int j=i/5; j<5; ++j){\n            for(int k=i%5; k<5; ++k){\n                bitset<25> bs;\n                for(int y=i/5; y<=j; ++y){\n                    for(int x=i%5; x<=k; ++x){\n                        bs[y*5+x] = true;\n                    }\n                }\n                change[i].push_back(bs.to_ulong());\n            }\n        }\n    }\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<25> enemy;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                char tmp;\n                cin >> tmp;\n                if(tmp == '1')\n                    enemy[i*5+j] = true;\n            }\n        }\n\n        int m = solve(enemy.to_ulong());\n        string ret;\n        while(--m >= 0)\n            ret += \"myon\";\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint n,m[5][5];\n\nint main(){\n  vector<int> dp[2];\n  vector<int> mask[6];\n\n  for(n=1;n<=5;n++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint t1 = 0;\n\tfor(int k=i;k<n;k++){\n\t  t1 += 1<<k;\n\t  int t2 = 0;\n\t  for(int l=j;l<n;l++){\n\t    t2 += (t1<<n*l);\n\t    mask[n].push_back(t2);\n\t  }\n\t}\n      }\n    }\n  }\n  \n  while(1){\n    cin >> n;\n    if(!n)break;\n    int N = (1<<(n*n));\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cin >> m[i][j];\n    }\n\n    int ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(m[i][j])ans += 1<<(i*n+j);\n      }\n    }\n\n    for(int k=0;k<2;k++){\n      dp[k].clear();\n      for(int i=0;i<N;i++)dp[k].push_back(-1);\n    }\n    dp[0][0] = 0;\n    dp[1][ans] = 0;\n\n    int c = 0;\n    bool f = false;\n    while(1){\n      for(int k=0;k<2;k++){\n\tfor(int i=0;i<N;i++){\n\t  if(dp[k][i] == c){\n\t    for(int j=0;j<(int)mask[n].size();j++){\n\t      int tmp = i ^ mask[n][j];\n\t      if(dp[k][tmp]<0)dp[k][tmp] = c+1;\n\t    }\n\t  }\n\t}\n      }\n      int cnt = N;\n      for(int i=0;i<N;i++){\n\tif(dp[0][i]>=0 && dp[1][i]>=0){\n\t  cnt = min(cnt,dp[0][i] + dp[1][i]);\n\t  f = true;\n\t}\n      }\n\n      if(f){\n\tfor(int j=0;j<cnt;j++)cout << \"myon\";\n\tcout << endl;\n\tbreak;\n      }\n      c++;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nint dp[1<<25];\nint n;\n\nconst int INF=(1<<30);\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nint minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tif(depth>=n*n){\n\t\treturn INF;\n\t}\n\n\tint minCnt=INF;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\t\t\t\t\t\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,minStep(ns,depth+1)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn dp[s];\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<26];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst char INF=30;\n\nchar dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=(char)res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint mask[5][5][6][6];\nunsigned char memo[1<<20];\n\nint rec(int S, int x, int cnt) {\n  if (S>>20==0) return cnt + memo[S];\n  if (x>=5) return INF;\n  int res = INF;\n  if ((S>>20+x)&1) {\n    REP(i,5) {\n      for (int w=1; w<=5-x; ++w) {\n        res = min(res, rec(S ^ mask[i][x][5-i][w], x+1, cnt+1));\n      }\n    }\n  } else {\n    res = rec(S, x+1, cnt);\n  }\n  return res;\n}\n\n\nint main() {\n  REP(i, 5) REP(j, 5)\n    for (int h=1; h<=5-i; ++h)\n      for (int w=1; w<=5-j; ++w) {\n        int m = (1<<w)-1;\n        REP(k,h) mask[i][j][h][w] ^= m<<(i+k)*5+j;\n      }\n  memset(memo, -1, sizeof(memo));\n  queue<int> Q;\n  Q.push(0);\n  memo[0] = 0;\n  while(!Q.empty()) {\n    int S = Q.front();\n    Q.pop();\n    int c = memo[S] + 1;\n//    cout << c << endl;\n    REP(i, 4) {\n      REP(j, 5) {\n        for (int h=1; h<=4-i; ++h) {\n          for (int w=1; w<=5-j; ++w) {\n            // i+h, j+w\n            int tmp = S^mask[i][j][h][w];\n            if (memo[tmp] > c) {\n              memo[tmp] = c;\n              Q.push(tmp);\n            }\n          }\n        }\n      }\n    }\n  }\n  // cout << (int)memo[473536] << endl;\n  // cout << \"OK\" << endl;\n  \n  int n;\n  while(cin >> n, n) {\n    int SS = 0;\n    REP(i,n) {\n      REP(j,n) {\n        bool a;\n        cin >> a;\n        if (a)\n          SS |= 1<<i*5+j;\n      }\n    }\n//    cout << bitset<25>(SS) << endl;\n    int res;\n    if (n<5) {\n      res = memo[SS];\n    } else\n      res = rec(SS, 0, 0);\n    \n    REP(i,res)\n      cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n#include<unordered_map>\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nunordered_map<vector<vector<int>>, int,HashVI>mp;\nint getans(const vector<vector<int>>&field) {\n\t\n\treturn mp[field];\n}\nstruct aa {\n\tvector<vector<int>>field;\n\tint time;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\nint main() {\n\tfor (int N = 1; N <= 5; ++N) {\n\t\tqueue<aa>que;\n\t\tvector<vector<int>>clean(N, vector<int>(N));\n\t\tque.push(aa{ clean,0 });\n\t\tint ans = 100;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\t\n\t\t\tauto field(atop.field);\n\t\t\tfor (int l = 0; l < field.size(); ++l) {\n\t\t\t\tfor (int r = l + 1; r <= field.size(); ++r) {\n\t\t\t\t\tfor (int u = 0; u < field.size(); ++u) {\n\t\t\t\t\t\tfor (int d = u + 1; d <= field.size(); ++d) {\n\t\t\t\t\t\t\tvector<vector<int>>nfield(field);\n\t\t\t\t\t\t\tfor (int x = l; x < r; ++x) {\n\t\t\t\t\t\t\t\tfor (int y = u; y < d; ++y) {\n\t\t\t\t\t\t\t\t\tnfield[y][x] = !nfield[y][x];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mp.find(nfield) == mp.end()) {\n\t\t\t\t\t\t\t\tmp[nfield] = atop.time + 1;\n\t\t\t\t\t\t\t\tque.push(aa{ nfield,atop.time + 1 });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<vector<int>>start(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j)cin >> start[i][j];\n\t\t}\n\t\tint ans = mp[start];\n\t\t\n\t\t\n\t\twhile (ans--)cout << \"myon\";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\nint a[4][4];\n\nchar memo[(1<<25)];\n\nchar dfs(int bit){\n\tif( bit == 0 ) return 0;\n\tif( ~memo[bit] ) return memo[bit];\n\t\n\tchar ans = 30;\n\t\n\tfor(int p = 0 ; p < 25 ; p++){\n\t\tif( bit >> p & 1 ){\n\t\t\tfor(int i = 0 ; i < item[p].size() ; i++)\n\t\t\t\tans = min(ans,(char)(dfs(bit^item[p][i])+1));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\n\nint main(){\n\tmemset(memo,-1,sizeof(memo));\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\t//cout << init << endl;\n\t\tint x = (int)dfs(init);\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    for (int i=0; i<(n*n); i++)\n      close[i]=false;\n\n    queue<pair<int, int> > mm;\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nunsigned char dp[1<<25];\nint n;\nconst unsigned char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nunsigned char minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tunsigned char minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\t//int b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tint b=(s&(1<<(i*n+j)));\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=(~(1<<(i*n+j)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(unsigned char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tif(bit==1)\n\t\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint n,g,bit;\nint dis[1<<20];\nvector<int> mask[5][5];\n\nint rec(int g, int t){\n  if(t == 5){\n    if( (g & 31) )return 1000000;\n    return dis[g>>5];\n  }\n\n  int res = rec(g,t+1);\n  for(int i=0;i<mask[0][t].size();i++){\n    res = min(res,rec(g^mask[0][t][i],t+1)+1);\n  }\n  return res;\n}\n    \nint main(){\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      for(int k=i;k<5;k++){\n\tfor(int l=j;l<5;l++){\n\t  int tmp = 0;\n\t  for(int y=i;y<=k;y++){\n\t    for(int x=j;x<=l;x++){\n\t      tmp |= 1<<(y*5+x);\n\t    }\n\t  }\n\t  mask[i][j].push_back(tmp);\n\t}\n      }\n    }\n  }\n\n  for(int i=0;i<(1<<20);i++)dis[i] = -1;\n  dis[0] = 0;\n  queue<int> q; q.push(0);\n  while(q.size()){\n    int p = q.front(); q.pop();\n    for(int i=0;i<4;i++)\n      for(int j=0;j<5;j++){\n\tfor(int k=0;k<mask[i][j].size();k++){\n\t  if(mask[i][j][k]>=1<<20)continue;\n\t  int nxt = p^mask[i][j][k];\n\t  if(dis[nxt]<0){\n\t    dis[nxt] = dis[p] + 1;\n\t    q.push(nxt);\n\t  }\n\t}\n      }\n  }\n\n  while(cin >> n,n){\n    g = 0;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n\tif(i<n && j<n){\n\t  cin >> bit;\n\t  g |= bit<<(i*5+j);\n\t}\n      }\n    }\n    if(n<5){\n      for(int i=0;i<dis[g];i++)cout << \"myon\";\n      cout << endl;\n    }else{\n      int tmp = rec(g,0);\n      for(int i=0;i<tmp;i++)cout << \"myon\";\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint solve(int x,const vi& ms,vector<int8_t>& memo)\n{\n\tif(memo[x]!=-1) return memo[x];\n\t\n\tif(x==0) return memo[x]=0;\n\tint res=INF;\n\tfor(int m:ms) if(__builtin_ctz(x)==__builtin_ctz(m))\n\t\tres=min(res,solve(x^m,ms,memo));\n\treturn memo[x]=res+1;\n}\n\nint main()\n{\n\tvi ms;\n\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\tint m=0;\n\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\tms.push_back(m);\n\t}\n\tvector<int8_t> memo(1<<25,-1);\n\t\n\tfor(int n;cin>>n && n;){\n\t\tint x=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx|=b<<(i*5+j);\n\t\t}\n\t\t\n\t\tint res=solve(x,ms,memo);\n\t\trep(i,res) cout<<string(\"myon\"); cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint n, m[5][5];\n\nint myon(int x,int h1,int w1,int h2,int w2){\n  int res;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if( x & (1<<(i*n+j)) )m[i][j] = 1;\n      else m[i][j] = 0;\n    }\n  }\n\n  for(int i=h1;i<=h2;i++){\n    for(int j=w1;j<=w2;j++)m[i][j] = 1-m[i][j];\n  }\n\n  res = 0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(m[i][j])res += 1<<(i*n+j);\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  vector<int> dp;\n  int ans;\n    \n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cin >> m[i][j];\n    }\n\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(m[i][j])ans += 1<<(i*n+j);\n      }\n    }\n\n    dp.clear();\n    for(int i=0;i<(1<<n*n);i++)dp.push_back(1<<30);\n    dp[ans] = 0;\n  \n    queue<int> q;\n    //queue< vector<bool> > u;\n    //vector<bool> hoge;\n\n    //for(int i=0;i<(n*n*n*n);i++)hoge.push_back(false);\n    q.push(ans);\n    //u.push(hoge);\n    \n    int c = 0;\n    bool f = false;\n    while(q.size()){\n      int tmp = q.front();\n      //vector<bool> use = u.front();\n      q.pop();\n      //u.pop();\n      if(!tmp)break;\n\n      c++;\n\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int k=i;k<n;k++){\n\t    for(int l=j;l<n;l++){\n\t      //if(!use[i*n*n*n + j*n*n + k*n + l]){\n\t\t//use[i*n*n*n + j*n*n + k*n + l] = true;\n\t\tint ans = myon(tmp,i,j,k,l);\n\t\tif(dp[ans] == (1<<30)){\n\t\t  dp[ans] = dp[tmp]+1;\n\t\t  q.push(ans);\n\t\t  //u.push(use);\n\t\t  if(!ans)f = true;\n\t\t}\n\t\t//use[i*n*n*n + j*n*n + k*n + l] = false;\n\t\t//}\n\t    }\n\t  }\n\t}\n      }\n      if(f)break;\n    }\n\n    //cout << c << endl;;\n    //cout << dp[0];\n    for(int i=0;i<dp[0];i++)cout << \"myon\";\n    cout << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\tif(s==start){\n\t\t\t\t\t\t\t\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\tif(s==start){\n\t\t\t\t\t\t\t\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\t//fill(dp,dp+(1<<25),-1);\n\tmemset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 8000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\t\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\n// hash\n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\nchar dp[1 << 25];\nint recur(int e, int sum, int& min_res)\n{\n    if (e == 0)\n        return 0;\n    else if (dp[e])\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = 8;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n  vector<int> cls;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    cls.push_back(bd);\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls.push_back(nbd);\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls.size(); i++)\n      close[cls[i]]=false;\n    cls.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  //vector<bool> close(1<<(5*5), false);\n  vector<int> close((1<<(5*5))/32, 0);\n  vector<int> cls(1000000);\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n\n    vector<vector<int> > pats(33);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[__builtin_clz(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (close[nbd>>5]&(1<<(nbd&31)))\n\t  continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n      }\n    }\n  _exit:;\n    {\n      int i=0;\n      for (; i+3<cls_cnt; i+=4){\n\tclose[(cls[i+0]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+1]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+2]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+3]&0x1ffffff)>>5]=0;\n      }\n      for (; i<cls_cnt; i++)\n\tclose[(cls[i]&0x1ffffff)>>5]=0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  //vector<bool> close(1<<(5*5), false);\n  bitset<1<<(5*5)> close;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    close.reset();\n    /*\n    for (int i=0; i<(n*n); i++)\n      close[i]=false;\n    */\n\n    queue<pair<int, int> > mm;\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 10000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nunsigned char memo[1<<20];\nint mask[5][5][6][6];\n\nvoid printS(int s){\n  int tmp[5][5];\n  fill(tmp[0], tmp[5], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      tmp[i][j] = s >> (i*5+j) & 1;\n    }\n  }\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      cout << tmp[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid init(){\n  fill(memo, memo + (1<<20), -1);\n  fill(mask[0][0][0], mask[5][0][0], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      for(int h=1;i+h<=5;h++){\n        for(int w=1;j+w<=5;w++){\n          int tmp = (1 << w) - 1 << j;\n          for(int k=0;k<h;k++){\n            mask[i][j][h][w] |= tmp << (i+k) * 5;\n          }\n        }\n      }\n    }\n  }\n  queue<int> q;\n  memo[0] = 0;\n  q.push(0);\n  while(!q.empty()){\n    int u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      for(int j=0;j<5;j++){\n        for(int h=1;i+h<=4;h++){\n          for(int w=1;j+w<=5;w++){\n            int v = u ^ mask[i][j][h][w];\n            if(memo[v] > memo[u] + 1){\n              memo[v] = memo[u] + 1;\n              /*if((int)memo[v] == 2 && 0){\n                cout << \"cost = \" << (int)memo[v] << endl;\n                printS(v);\n                }*/\n              q.push(v);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nconst int INF = 1 << 28;\n\nint rec(int s, int t, int x, int cnt){\n  if(x == 5) return s == t ? cnt : INF;\n  int res = rec(s, t, x+1, cnt);\n  for(int i=0;i<5;i++){\n    for(int j=x;j<5;j++){\n      int nt = t ^ mask[i][x][5-i][j-x+1];\n      res = min(res, rec(s, nt, x+1, cnt+1));\n    }\n  }\n  return res;\n}\n\nint solve(int s){\n  int res = memo[s&(1<<20)-1];\n  return res + rec(s, s, 0, 0);\n}\n\nmain(){\n  init();\n  int n;\n  while(cin >> n && n){\n    int m = 0;\n    for(int i=0;i<n;i++){\n      int t = 0, c;\n      for(int j=0;j<n;j++){\n        cin >> c;\n        t |= c << j;\n      }\n      m |= t << i * 5;\n    }\n    int ans = n < 5 ? memo[m] : solve(m);\n    for(int i=0;i<ans;i++){\n      cout << \"myon\";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint mask[5][5][6][6];\nint main() {\n  REP(i, 5) REP(j, 5)\n    for (int h=1; h<=5-i; ++h)\n      for (int w=1; w<=5-j; ++w) {\n        int m = (1<<w)-1;\n        REP(k,h) mask[i][j][h][w] ^= m<<(i+k)*5+j;\n      }\n  unsigned char memo[1<<20];\n  memset(memo, -1, sizeof(memo));\n  queue<int> Q;\n  Q.push(0);\n  memo[0] = 0;\n  while(!Q.empty()) {\n    int S = Q.front();\n    Q.pop();\n    int c = memo[S] + 1;\n//    cout << c << endl;\n    REP(i, 4) {\n      REP(j, 5) {\n        for (int h=1; h<=4-i; ++h) {\n          for (int w=1; w<=5-j; ++w) {\n            // i+h, j+w\n            int tmp = S^mask[i][j][h][w];\n            if (memo[tmp] > c) {\n              memo[tmp] = c;\n              Q.push(tmp);\n            }\n          }\n        }\n      }\n    }\n  }\n  // cout << (int)memo[473536] << endl;\n  // cout << \"OK\" << endl;\n  \n  int n;\n  while(cin >> n, n) {\n    int SS = 0;\n    int cnt = 0;\n    REP(i,n*n) {\n      bool a;\n      cin >> a;\n      if (a)\n        SS |= 1<<cnt;\n      cnt++;\n      if (cnt%5==n) {\n        cnt += 5-n;\n      }\n    }\n//    cout << bitset<25>(SS) << endl;\n    if (n<5) {\n      REP(i,(int)memo[SS])\n        cout << \"myon\";\n      cout << endl;\n      continue;\n    }\n\n    int res = INF;\n    REP(i,5*5*5*5*5) {\n      int aa = i;\n      int height[5];\n      REP(j,5) {\n        height[j] = aa % 5 + 1;\n        aa /= 5;\n      }\n      REP(S,1<<5) {\n        int hoge = 0;\n        int tmp = SS;\n        int mae = -1;\n        REP(j,5) {\n          if ((S>>j)&1) {\n            if (mae != height[j]) hoge++;\n            tmp ^= mask[5-height[j]][j][height[j]][1];\n            // REP(k, height[j]) {\n            //   tmp ^= 1 << ((4-k)*5 + j);\n            // }\n            mae = height[j];\n          } else\n            mae = -1;\n        }\n        int kari = tmp & ((1<<20)-1);\n        if (kari==tmp)\n          res = min(res, hoge+memo[kari]);\n      }\n    }\n    \n    REP(i,res)\n      cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(passed,passed+(1<<25),false);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nbool used[1 << 25];\ntypedef pair<int, int> P;\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    memset(used, 0, sizeof used);\n    int start = 0;\n    REP(i, N * N){\n      int t;\n      cin >> t;\n      start |= t << i;\n    }\n    queue<P> que;\n    que.push(P(start, 0));\n    used[start] = true;\n    int ans = -1;\n    while(!que.empty()){\n      int s = que.front().first;\n      int c = que.front().second;\n      que.pop();\n      if(s == 0){\n        ans = c;\n        break;\n      }\n      int next[6][6][6][6] = {};\n      REP(y, N) REP(x, N) next[y][y][x][x] = s;\n      // [y1][y2][x1][x2] = [y1][y2][x1][x2 - 1] ^ [y1][y2 - 1][x1][x2] - [y1][y2 - 1][x1][x2 - 1]\n      for(int y1 = 0; y1 < N; y1++){\n        for(int x1 = 0; x1 < N; x1++){\n          for(int y2 = y1 + 1; y2 <= N; y2++){\n            for(int x2 = x1 + 1; x2 <= N; x2++){\n              next[y1][y2][x1][x2] = next[y1][y2][x1][x2 - 1] ^ \n                                     next[y1][y2 - 1][x1][x2] ^\n                                     next[y1][y2 - 1][x1][x2 - 1] ^ \n                                     (1 << ((y2 - 1) * N + (x2 - 1)));\n              int ns = next[y1][y2][x1][x2];\n              if(!used[ns]){\n                used[ns] = true;\n                que.push(P(ns, c + 1));\n              }\n            }\n          }\n        }\n      }\n    }\n    string myon = \"myon\";\n    REP(i, ans) cout << myon;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\nmap<int,char> mem;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\t//if(depth>=2*n+3){\n\t//\treturn INF;\n\t//}\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\tif(!((s>>(miny*n+minx))&1))\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nvoid initSit(){\n\tfill(dp,dp+(1<<25),INF);\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\tint ns=0;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++)\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++)\n\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\tdp[ns]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(map<int,char>::iterator it=mem.begin();it!=mem.end();it++)\n\t\tdp[it->first]=it->second;\n}\n\n\nvoid bfs(int s){\n\tqueue<int> *prv=new queue<int>();\n\tqueue<int> *nxt=new queue<int>();\n\tprv->push(s);\n\tfill(dp,dp+(1<<25),INF);\n\tint cnt=0;\n\tdp[0]=0;\n\twhile(prv->size()){\n\t\tcout<<cnt<<endl;\n\t\twhile(prv->size()){\n\t\t\tint cp=prv->front();\n\t\t\tprv->pop();\n\t\t\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t\t\t// ¶ãÌÀW\n\t\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t\tif(((cp>>(miny*n+minx))&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// c\n\t\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t\t// ¡\n\t\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t\t// ¡ñß½êÌrbgð½]\n\t\t\t\t\t\t\tint ns=cp;\n\t\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(dp[ns]==INF){\n\t\t\t\t\t\t\t\tdp[ns]=cnt+1;\n\t\t\t\t\t\t\t\tnxt->push(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n}\n\nint main(){\n\t//n=5;\n\t//bfs(0);\n\t//cout<<endl;\n\tfill(dp,dp+(1<<25),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tchar cnt;\n\t\t//initSit();\n\t\t//mC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\t//cnt=dp[init];\n\t\t//start=init;\n\t\tcnt=minStep(init,0);\n\t\t//mem[init]=cnt;\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 25];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * 5) + x);\n  }\n  return ret;\n}\n\nvoid inv(int y, int x, int ey, int ex) {\n  FOREQ(ny, y, ey) FOREQ(nx, x, ex) {\n    field[ny][nx] ^= 1;\n  }\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1 && y != 0 && x != 0) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    FOR(ny, y, n) {\n      FOR(nx, x, n) {\n        inv(y, x, ny, nx);\n        ret = min(ret, calc(y, x + 1) + 1);\n        inv(y, x, ny, nx);\n      }\n    }\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  MEMSET(memo, -1);\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint n, f[5][5], s;\nint dp[1<<20];\n\nint rec(int at) {\n    if(at==5) return dp[s>>5];\n    if((s&(1<<at))==0) return rec(at+1);\n    int ans=1<<30;\n    for(int ye=at; ye<5; ye++) rep(xe, 5) {\n        for(int x=at; x<=xe; x++) for(int y=0; y<=ye; y++) s ^= 1<<(x*5+y);\n        ans = min(ans, rec(at+1)+1);\n        for(int x=at; x<=xe; x++) for(int y=0; y<=ye; y++) s ^= 1<<(x*5+y);\n    }\n    return ans;\n}\n\nint main() {\n    rep(i, 1<<20) dp[i]=1<<30;\n    dp[0] = 0;\n    rep(b, 1<<20) {\n        rep(xe, 4) rep(xs, xe+1) rep(ye, 5) rep(ys, ye+1) {\n            int nb=b;\n            for(int x=xs; x<=xe; x++) for(int y=ys; y<=ye; y++) {\n                nb ^= 1<<(x*5+y);\n            }\n            dp[nb] = min(dp[nb], dp[b]+1);\n        }\n    }\nfprintf(stderr, \"ready\\n\");\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        memset(f, 0, sizeof(f));\n        rep(i, n) rep(j, n) scanf(\"%d\", f[i]+j);\n        s = 0;\n        rep(i, n) rep(j, n) s|=f[i][j]<<(i*5+j);\n        int ans = n<5 ? dp[s] : rec(0);\n        rep(i, ans) printf(\"myon\");\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename I1,typename I2>\nbool is_intersection(I1 first1,I1 last1,I2 first2,I2 last2)\n{\n\twhile(first1!=last1 && first2!=last2){\n\t\tif(*first1==*first2) return true;\n\t\t(*first1<*first2?first1:first2)++;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi ms;\n\t\trep(t,n) repi(b,t,n) rep(l,n) repi(r,l,n){\n\t\t\tint m=0;\n\t\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*n+j);\n\t\t\tms.push_back(m);\n\t\t}\n\t\t\n\t\tset<int> s1,s2;\n\t\t{\n\t\t\tint x=0;\n\t\t\trep(i,n) rep(j,n){\n\t\t\t\tint b; cin>>b;\n\t\t\t\tx|=b<<(i*n+j);\n\t\t\t}\n\t\t\ts1.insert(x);\n\t\t\ts2.insert(0);\n\t\t}\n\t\t\n\t\tstring res;\n\t\tfor(int i=0;;i++){\n\t\t\tif(is_intersection(all(s1),all(s2))){\n\t\t\t\trep(j,i) res+=\"myon\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecltype(s1)& cur=(i%2==0?s1:s2);\n\t\t\tdecltype(s1) next;\n\t\t\tfor(int x:cur)\n\t\t\t\tfor(int m:ms)\n\t\t\t\t\tnext.insert(x^m);\n\t\t\tswap(cur,next);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    vector<bool> close(1<<(n*n), false);\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 500 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 3)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  int bf = (field>>20);\n  int nfield = field & (1<<20)-1;\n  int ret = __builtin_popcount(bf) + mincost[nfield];\n\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\n\nconst int size = 5;\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = 0; y < size; ++y)\n        for (int x = 0; x < size; ++x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\nmap<int, int> dp;\nint recur(const tab& f, int sum, int& min_res)\n{\n    const int e = enc(f);\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int left = size, top = size, max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if (f[y][x])\n            {\n                if (left == size)\n                {\n                    min_swap(left, x);\n                    min_swap(top, y);\n                }\n                if (x >= left)\n                {\n                    max_swap(max_x, x);\n                    max_swap(max_y, y);\n                }\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int yy = max_y; yy >= top; --yy)\n    {\n        for (int xx = max_x; xx >= left; --xx)\n        {\n            tab nf = f;\n            for (int y = top; y <= yy; ++y)\n                for (int x = left; x <= xx; ++x)\n                    nf[y][x] = !nf[y][x];\n            min_swap(res, recur(nf, sum + 1, min_res) + 1);\n        }\n    }\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n\n        int t = n * n;\n        int times = recur(f, 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nchar dp[1<<25];\n//int minArrivingDepth[1<<25];\n\nint n;\nconst char INF=100;\n\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\tif(minCnt==1){\n\t\t\t\t\t\tdp[s]=minCnt;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(cin>>n&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\ninline int upb(int n)\n{\n  /*\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n  */\n  return 32-__builtin_clz(n);\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n  vector<int> cls(1000000);\n  int cls_cnt=0;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<int> mm;\n    mm.push(bd);\n    close[bd]=true;\n    cls[cls_cnt++]=bd;\n    while(!mm.empty()){\n      int dep=mm.front()>>25;\n      int cbd=mm.front()&0x1ffffff;\n      mm.pop();\n      //int ub=upb(cbd);\n      int ub=32-__builtin_clz(cbd);\n      const vector<int> &ps=pats[ub];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls[cls_cnt++]=nbd;\n\tmm.push(((dep+1)<<25)|nbd);\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls_cnt; i++)\n      close[cls[i]]=false;\n    cls_cnt=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint n, m[5][5];\n\nint myon(int x,int h1,int w1,int h2,int w2){\n  for(int i=h1;i<=h2;i++){\n    for(int j=w1;j<=w2;j++)x ^= 1<<(i*n+j);\n  }\n  return x;\n}\n\nint main(){\n  vector<int> dp;\n  int ans;\n    \n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cin >> m[i][j];\n    }\n\n    ans = 0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(m[i][j])ans += 1<<(i*n+j);\n      }\n    }\n\n    dp.clear();\n    for(int i=0;i<(1<<n*n);i++)dp.push_back(1<<30);\n    dp[ans] = 0;\n  \n    queue<int> q;\n    //queue< vector<bool> > u;\n    //vector<bool> hoge;\n\n    //for(int i=0;i<(n*n*n*n);i++)hoge.push_back(false);\n    q.push(ans);\n    //u.push(hoge);\n    \n    int c = 0;\n    bool f = false;\n    while(q.size()){\n      int tmp = q.front();\n      //vector<bool> use = u.front();\n      q.pop();\n      //u.pop();\n      if(!tmp)break;\n\n      c++;\n\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int k=i;k<n;k++){\n\t    for(int l=j;l<n;l++){\n\t      //if(!use[i*n*n*n + j*n*n + k*n + l]){\n\t\t//use[i*n*n*n + j*n*n + k*n + l] = true;\n\t\tint ans = myon(tmp,i,j,k,l);\n\t\tif(dp[ans] == (1<<30)){\n\t\t  dp[ans] = dp[tmp]+1;\n\t\t  q.push(ans);\n\t\t  //u.push(use);\n\t\t  if(!ans)f = true;\n\t\t}\n\t\t//use[i*n*n*n + j*n*n + k*n + l] = false;\n\t\t//}\n\t    }\n\t  }\n\t}\n      }\n      if(f)break;\n    }\n\n    //cout << c << endl;;\n    //cout << dp[0];\n    for(int i=0;i<dp[0];i++)cout << \"myon\";\n    cout << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  static int close[(1<<(5*5))/32];\n  static int cls[1000000];\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n\n    vector<vector<int> > pats(33);\n    static int tmp[5][5];\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[__builtin_clz(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (close[nbd>>5]&(1<<(nbd&31)))\n\t  continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n      }\n    }\n  _exit:;\n    {\n      int i=0;\n      for (; i+3<cls_cnt; i+=4){\n\tclose[(cls[i+0]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+1]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+2]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+3]&0x1ffffff)>>5]=0;\n      }\n      for (; i<cls_cnt; i++)\n\tclose[(cls[i]&0x1ffffff)>>5]=0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\nint a[4][4];\n\nmap<int,char> memo;\n\nchar dfs(int bit){\n\tif( bit == 0 ) return 0;\n\t//if( ~memo[bit] ) return memo[bit];\n\tif( memo.count(bit) ) return memo[bit];\n\t\n\tchar ans = 30;\n\t\n\tfor(int p = 0 ; p < 25 ; p++){\n\t\tif( bit >> p & 1 ){\n\t\t\tfor(int i = 0 ; i < item[p].size() ; i++)\n\t\t\t\tans = min(ans,(char)(dfs(bit^item[p][i])+1));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\n\nint main(){\n\t//memset(memo,-1,sizeof(memo));\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\t//cout << init << endl;\n\t\tint x = (int)dfs(init);\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\tdfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n\nint n,g,bit,res;\nint dis[1<<20];\nvector<int> mask[5][5];\n\nint rec(int g, int t){\n  if(t == 5){\n    if( (g & 31) )return 1000000;\n    return dis[g>>5];\n  }\n  int res = rec(g,t+1);\n  for(int i=0;i<mask[0][t].size();i++)res = min(res,rec(g^mask[0][t][i],t+1)+1);\n  return res;\n}\n    \nint main(){\n  REP(i,0,5)REP(j,0,5)REP(k,i,5)REP(l,j,5){\n    int tmp = 0;\n    REP(y,i,k+1)REP(x,j,l+1)tmp |= 1<<(y*5+x);\n    mask[i][j].push_back(tmp);\n  }\n\n  for(int i=0;i<(1<<20);i++)dis[i] = -1;\n  dis[0] = 0;\n  queue<int> q; q.push(0);\n  while(q.size()){\n    int p = q.front(); q.pop();\n    REP(i,0,4)REP(j,0,5)REP(k,0,mask[i][j].size()){\n      if(mask[i][j][k]>=1<<20)continue;\n      int nxt = p^mask[i][j][k];\n      if(dis[nxt]<0){\n\tdis[nxt] = dis[p] + 1;\n\tq.push(nxt);\n      }\n    }\n  }\n\n  while(cin >> n,n){\n    g = 0;\n    REP(i,0,5)REP(j,0,5)\n      if(i<n && j<n){\n\tcin >> bit;\n\tg |= bit<<(i*5+j);\n      }\n    \n    if(n<5)res = dis[g];\n    else res = rec(g,0);\n    \n    for(int i=0;i<tmp;i++)cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<24];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(s<(1<<24)){\n\t\tif(dp[s]!=INF)\n\t\t\treturn dp[s];\n\t}\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif(((s>>(miny*n+minx))&1)==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tif(s<(1<<24)){\n\t\treturn dp[s]=minCnt;\n\t}\n\treturn minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<24),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = 0; y < size; ++y)\n        for (int x = 0; x < size; ++x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\nmap<int, int> dp;\nint recur(const tab& f, int sum, int& min_res)\n{\n    const int e = enc(f);\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int left = size, top = size, max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if (f[y][x])\n            {\n                if (left == size)\n                {\n                    min_swap(left, x);\n                    min_swap(top, y);\n                }\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int yy = max_y; yy >= top; --yy)\n    {\n        for (int xx = max_x; xx >= left; --xx)\n        {\n            tab nf = f;\n            for (int y = top; y <= yy; ++y)\n                for (int x = left; x <= xx; ++x)\n                    nf[y][x] = !nf[y][x];\n            min_swap(res, recur(nf, sum + 1, min_res) + 1);\n        }\n    }\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n\n        int t = n * n;\n        int times = recur(f, 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint n;\n// X[n][sy][sx][gy][gx] := n*n テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ (sx,sy) - (gx,gy)テ」ツ?ォmyonテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ、ツスツソテ」ツ??bit\nint X[5][5][5][5][5] = {0};\n// dp[n][bits] := n*n テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ テァツ環カテヲツ??bits テ」ツ?ョテヲツ慊?ァツ淞ュテヲツ可凝ヲツ閉ーテ」ツつ津ィツソツ氾」ツ??\nshort int dp[5][1<<25];\n\n// \"myon\" ** n テ」ツつ津ィツソツ氾」ツ??\nstring ans_myon(int k){\n\tstring res;\n\tfor(int i=0 ; i < k ; i++ ){\n\t\tres += \"myon\";\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tfor(int j=0 ; j < (1<<25) ; j++ ){\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tfor(int m=1 ; m <= 5 ; m++ ){\n\t\tdp[m-1][0] = 0;\n\t\tfor(int ly = 0 ; ly < m ; ly++ ){\n\t\t\tfor(int lx = 0 ; lx < m ; lx++ ){\n\t\t\t\tfor(int ry = ly ; ry < m ; ry++ ){\n\t\t\t\t\tfor(int rx = lx ; rx < m ; rx++ ){\n\t\t\t\t\t\tfor(int y = ly ; y <= ry ; y++ ){\n\t\t\t\t\t\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\t\t\t\t\t\tX[m-1][ly][lx][ry][rx] |= (1 << (y * m + x));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int bits){\n\tif( dp[n-1][bits] != -1 ) return dp[n-1][bits];\n\t\n\t// 1 テ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツキツヲテ、ツクツ甘」ツ?ョテ・ツコツァテヲツィツ凖」ツつ津ヲツ篠「テ」ツ??\n\tint sx, sy;\n\tfor(int i=0 ; i < n*n ; i++ ){\n\t\tif( bits & (1 << i) ){\n\t\t\tsx = i % n; sy = i / n; break;\n\t\t}\n\t}\n\tint res = INF;\n\tfor(int y = sy ; y < n ; y++ ){\n\t\tfor(int x = sx ; x < n ; x++ ){\n\t\t\tint next = bits ^ X[n-1][sy][sx][y][x];\n\t\t\tres = min(res, solve(next)+1 );\n\t\t}\n\t}\n\treturn dp[n-1][bits] = res;\n}\n\nint main(){\n\tinit();\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\tbits = (bits << 1) + e;\n\t\t}\n\t\tint ans = solve(bits);\n\t\tcout << ans_myon(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\ninline int upb(int n)\n{\n  /*\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n  */\n  return 32-__builtin_clz(n);\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n  vector<int> cls;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<int> mm;\n    mm.push(bd);\n    close[bd]=true;\n    cls.push_back(bd);\n    while(!mm.empty()){\n      int dep=mm.front()>>25;\n      int cbd=mm.front()&0x1ffffff;\n      mm.pop();\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls.push_back(nbd);\n\tmm.push(((dep+1)<<25)|nbd);\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls.size(); i++)\n      close[cls[i]]=false;\n    cls.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nshort dp[1<<25];\n\nint n;\nconst short INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nshort minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tshort minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\tint b=(s&(1<<(i*n+j)));\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns=(ns&(~(1<<(i*n+j))));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns=(ns|(1<<(i*n+j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(short)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tif(bit==1)\n\t\t\t\t\tinit|=(1<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\nmap<int,char> mem;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\t//if(depth!=0&&s==start){\n\t//\treturn INF;\n\t//}\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;p\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\t//if(res==STOP){\n\t\t\t\t\t\t//\treturn INF;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nvoid initSit(){\n\tfill(dp,dp+(1<<25),INF);\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\tint ns=0;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[ns]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(map<int,char>::iterator it=mem.begin();it!=mem.end();it++)\n\t\tdp[it->first]=it->second;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tinitSit();\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tmem[init]=cnt;\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nvoid p(int e)\n{\n    for (int y = 0; y < 5; ++y)\n    {\n        for (int x = 0; x < 5; ++x)\n            printf(\"%d \", e >> (5 * y + x) & 1);\n        puts(\"\");\n    }\n    puts(\"\");\n}\n\n\nbool enemy(int e, int x, int y)\n{\n    return e >> (5 * y + x) & 1;\n}\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nvoid dfs(int e, int y, int c, int& res)\n{\n    if (y >= 5)\n        return;\n        if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    for (int x1 = 0; x1 < 5; ++x1)\n    {\n        for (int x2 = x1; x2 < 5; ++x2)\n        {\n            int ne = e ^ xor_mask[y][x1][4][x2];\n            dfs(ne, y + 1, c + 1, res);\n        }\n    }\n    dfs(e, y + 1, c, res);\n}\nint main()\n{\n    fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        while (!(e & ~((1 << 5) - 1)))\n            e <<= 5;\n\n        int times = 25;\n        dfs(e, 0, 0, times);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\t\n\t\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tif( cnt >= 2 ){\n\t\treturn cnt;\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\treturn dfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst char INF=30;\n\nchar dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n            if(res==0)\n                return dp[s]=res;\n        }\n    }\n    return dp[s]=(char)res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 30000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool flag[1<<25];\n\nint main() {\n\n  while(true) {\n\n    int n,input;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    for ( int i = 0; i < ( 1<<(n*n) ); i++ ) {\n      flag[i] = false;\n    }\n\n    vector<long long int> next;\n    int line = 0;\n    for ( int x_r = 0; x_r < n; x_r++ ) {\n      line = (line<<1) + 1;\n      for ( int x_l = 0; x_l < (n-x_r); x_l++ ) {\n\tint x_line = ( line << x_l );\n\n\tlong long int y_line = 0;\n\tfor ( int y_u = 0; y_u < n; y_u++ ) {\n\t  y_line = (y_line<<n) + x_line;\n\t  for ( int y_d = 0; y_d < (n-y_u); y_d++ ) {\n\t    next.push_back( y_line<<(y_d*n) );\n\t  }\n\t}\n      }\n    }\n\n    long long int map = 0;\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = 0; j < n; j++ ) {\n\tcin >> input;\n\tmap = ( map<<1 ) + input;\n      }\n    }\n    flag[map] = true;\n    vector<long long int> map_old;\n    vector<long long int> map_new;\n    map_old.push_back(map);\n\n    int cnt = 0;\n\n    while(true) {\n      cnt++;\n\n      for ( int i = 0; i < map_old.size(); i++ ) {\n\tfor ( int j = 0; j < next.size(); j++ ) {\n\t  long long int m = map_old[i] ^ next[j];\n\t  if ( flag[ m ] == false ) {\n\t    map_new.push_back( m );\n\t    flag[ m ] = true;\n\t  }\n\t}\n      }\n\n      if ( flag[0] ) break;\n      if ( cnt > 50 ) {\n\tcout << \"error\" << endl;\n\tcnt = 0;\n\tbreak;\n      }\n\n      map_old.clear();\n      for ( int i = 0; i < map_new.size(); i++ ) {\n\tmap_old.push_back( map_new[i] );\n      }\n      map_new.clear();\n\n    }\n\n    for ( int i = 0; i < cnt; i++ ) {\n      cout << \"myon\";\n    }\n    cout << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <memory.h>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n#define MAX 999999999\nint xorMemo[5][5][5][5][5];\nshort n, f[1<<25];         \n\ninline short min(short a, short b){\n\treturn a < b ? a : b;\n}\ninline short solve(int bit){\n\tif (bit == 0) return 0;\n\tif (f[bit] != -1) return f[bit];\n\tshort li, lj;\n\tfor (li=0;li<n;li++){\n\t\tfor (lj=0;lj<n;lj++)\n\t\t\tif ((bit & (1<<(n*li+lj))) != 0) break;\t\n\t\tif (lj != n) break;\n\t}\n\tint res = MAX;\n\tfor (short hi=li;hi<n;hi++)\n\t\tfor (short hj=lj;hj<n;hj++){\n\t\t\tint next = (bit ^ xorMemo[n-1][li][lj][hi][hj]);\n\t\t\tres = min(res, solve(next)+1);\n\t\t}\n\treturn f[bit] = res;\n}\n\nint main(){\n\tmemset(xorMemo,0,sizeof(xorMemo));\n\tmemset(f,-1,sizeof(f));\n\tfor (short m=1;m<6;m++)\n\t\tfor (short li=0;li<m;li++)\n\t\t\tfor (short lj=0;lj<m;lj++)\n\t\t\t\tfor (short hi=li;hi<m;hi++)\n\t\t\t\t\tfor (short hj=lj;hj<m;hj++)\n\t\t\t\t\t\tfor (short i=li;i<hi+1;i++)\n\t\t\t\t\t\t\tfor (short j=lj;j<hj+1;j++){\n\t\t\t\t\t\t\t\txorMemo[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n\t\t\t\t\t\t\t\t//cout << xorMemo[m-1][li][lj][hi][hj] << \" \";\n\t\t\t\t\t\t\t}\n\t\n\twhile (scanf(\"%d\",&n) && n != 0){\n\t\tint bit = 0;\n\t\tfor (short i=0;i<n;i++)\n\t\t\tfor (short j=0;j<n;j++){\n\t\t\t\tshort x;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif(x == 1) bit |= (1<<(i*n+j));\n\t\t\t}\n\t\tshort ans = solve(bit);\n\t\tfor (short i=1;i<=ans;i++) printf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\t//if(((s>>(miny*n+minx))&1)==0)\n\t\t\t//\tcontinue;\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=(~(1<<(i*n+j)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nbool passed[1<<25];\nint field[10][10];\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n){\n\t\tint ss=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j])ss|=(1<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tmemset(passed,0,sizeof(passed));\n\t\tqueue<int> q[2];\n\t\tq[0].push(ss);\n\t\tint cur=0;\n\t\tint nxt=1;\n\t\tint cnt=0;\n\t\tpassed[ss]=true;\n\t\tbool fin=false;\n\t\twhile(q[cur].size()){\n\t\t\twhile(q[cur].size()){\n\t\t\t\tint cs=q[cur].front();\n\t\t\t\tif(cs==0){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq[cur].pop();\n\t\t\t\t// csÌóÔ©çÚ®Å«éóÔðñ\n\t\t\t\tint minx,miny;\n\t\t\t\tminx=miny=-1;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif((cs>>(i*n+j))&1){\n\t\t\t\t\t\t\tminx=j;\n\t\t\t\t\t\t\tminy=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(minx!=-1)break;\n\t\t\t\t}\n\t\t\t\t// EºÌÀWðè\n\t\t\t\tfor(int i=miny;i<n;i++){\n\t\t\t\t\tfor(int j=minx;j<n;j++){\n\t\t\t\t\t\t// ½]\n\t\t\t\t\t\tint ns=cs;\n\t\t\t\t\t\tfor(int k=miny;k<=i;k++){\n\t\t\t\t\t\t\tfor(int l=minx;l<=j;l++){\n\t\t\t\t\t\t\t\tif((ns>>(k*n+l))&1)ns&=~(1<<(k*n+l));\n\t\t\t\t\t\t\t\telse ns|=(1<<(k*n+l));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!passed[ns]){\n\t\t\t\t\t\t\tq[nxt].push(ns);\n\t\t\t\t\t\t\tpassed[ns]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)break;\n\t\t\tcnt++;\n\t\t\tswap(cur,nxt);\n\t\t}\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar memo[1<<25];\nint n;\n\nchar solve(int state){\n  if(state == 0) return 0;\n  if(memo[state]>0) return memo[state];\n  if(memo[state]<0) return 30;\n  memo[state] = -1;\n  printf(\"state:%x\\n\",state);\n\n  char ret = 30;\n  return memo[state] = ret;\n}\n\nint main(){\n  while(n = getInt()){\n    int init = 0;\n    memset(memo,0,1<<(n*n));\n    REP(i,n) REP(j,n){\n      int t = getInt();\n      init |= (t << (j + i*n));\n    }\n    queue<int> q;\n    int cost = 0;\n    q.push(init);\n    q.push(-1);\n\n    while(q.size()){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        continue;\n      }\n\n      if(state == 0){\n        while(cost --> 0)\n          printf(\"myon\");\n        puts(\"\");\n        break;\n      }\n\n      //printf(\"%d %x\\n\",cost,state);\n      //REP(i,n){REP(j,n) printf(\" %d\",(state & (1 << (i*n + j)))?1:0);puts(\"\");}\n\n      for(int xs = 0; xs < n; xs++){\n        for(int xe = xs+1; xe <= n; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys = 0; ys < n; ys++){\n            int next = state;\n            for(int ye = ys; ye < n; ye++){\n              next ^= mask << (ye * n);\n              if(!memo[next]) q.push(next);\n              memo[next] = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint n;\n// X[n][sy][sx][gy][gx] := n*n テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ (sx,sy) - (gx,gy)テ」ツ?ォmyonテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ、ツスツソテ」ツ??bit\nint X[5][5][5][5][5] = {0};\n// dp[n][bits] := n*n テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ テァツ環カテヲツ??bits テ」ツ?ョテヲツ慊?ァツ淞ュテヲツ可凝ヲツ閉ーテ」ツつ津ィツソツ氾」ツ??\nchar dp[5][1<<25];\n\n// \"myon\" ** n テ」ツつ津ィツソツ氾」ツ??\nstring ans_myon(int k){\n\tstring res;\n\tfor(int i=0 ; i < k ; i++ ){\n\t\tres += \"myon\";\n\t}\n\treturn res;\n}\n\nvoid init(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tfor(int j=0 ; j < (1<<25) ; j++ ){\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\tfor(int m=1 ; m <= 5 ; m++ ){\n\t\tdp[m-1][0] = 0;\n\t\tfor(int ly = 0 ; ly < m ; ly++ ){\n\t\t\tfor(int lx = 0 ; lx < m ; lx++ ){\n\t\t\t\tfor(int ry = ly ; ry < m ; ry++ ){\n\t\t\t\t\tfor(int rx = lx ; rx < m ; rx++ ){\n\t\t\t\t\t\tfor(int y = ly ; y <= ry ; y++ ){\n\t\t\t\t\t\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\t\t\t\t\t\tX[m-1][ly][lx][ry][rx] |= (1 << (y * m + x));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int bits){\n\tif( dp[n-1][bits] != -1 ) return dp[n-1][bits];\n\t\n\t// 1 テ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツキツヲテ、ツクツ甘」ツ?ョテ・ツコツァテヲツィツ凖」ツつ津ヲツ篠「テ」ツ??\n\tint sx, sy;\n\tfor(int i=0 ; i < n*n ; i++ ){\n\t\tif( bits & (1 << i) ){\n\t\t\tsx = i % n; sy = i / n; break;\n\t\t}\n\t}\n\tint res = INF;\n\tfor(int y = sy ; y < n ; y++ ){\n\t\tfor(int x = sx ; x < n ; x++ ){\n\t\t\tint next = bits ^ X[n-1][sy][sx][y][x];\n\t\t\tres = min(res, solve(next)+1 );\n\t\t}\n\t}\n\treturn dp[n-1][bits] = res;\n}\n\nint main(){\n\tinit();\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint e;\n\t\t\tcin >> e;\n\t\t\tbits = (bits << 1) + e;\n\t\t}\n\t\tint ans = solve(bits);\n\t\tcout << ans_myon(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 2)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  int bf = (field>>20);\n  int nfield = field & (1<<20)-1;\n  int ret = __builtin_popcount(bf) + mincost[nfield];\n\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    field[y][n] = 1;\n    field[n][x] = 1;\n    field[n][n] = 1;\n    FOR(ny, y + 1, n + 1) {\n      FOR(nx, x + 1, n + 1) {\n        if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n          field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n          ret = min(ret, calc(y, x + 1) + 1);\n          field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n        }\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nint op[5][5][5][5][5];\nint n;\n//short dp[5][1<<25];\nmap<int, int> dp;\n\n\nint solve(int mask) {\n    if (mask == 0) return 0;\n    //short &ans = dp[n - 1][mask];\n    if (dp.count(mask))\n        return dp[mask];\n    //if(ans != -1) return ans;\n    int x, y;\n    for(x = 0; x < n; ++x){\n        for(y = 0; y < n; ++y)\n            if(mask & (1<<(n * x+ y )))\n                break;\n        if(y != n) break;\n    }\n    int ans = INT_MAX >> 1;\n    FOR(i,x,n){\n        FOR(j,y,n){\n            int next = (mask ^ op[n-1][x][y][i][j]);\n            int tmp = solve(next) + 1;\n            checkmin(ans, tmp);\n        }\n    }\n    return dp[mask] = ans;\n}\n\nint main(){\n  memset(op,0,sizeof(op));\n  FOR(m,1,6)\n    REP(li,m)\n      REP(lj,m)\n        FOR(hi,li,m)\n          FOR(hj,lj,m)\n            FOR(i,li,hi+1)\n              FOR(j,lj,hj+1)\n                op[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n  //memset(dp,-1,sizeof(dp));\n  while(scanf(\"%d\", &n), n){\n      int mask = 0;\n      REP(i,n){\n          REP(j,n){\n              int tmp;\n              scanf(\"%d\", &tmp);\n              if(tmp == 1){\n                  mask |= (1 << (i * n + j));\n              }\n          }\n      }\n\n      int ans = solve(mask);\n      REP(i,ans)\n          printf(\"myon\");\n      puts(\"\"); \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint n,m[5][5];\nint dp[1<<(5*5)];\nvector<int> mask[6];\n\nint main(){\n  for(n=1;n<=5;n++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint t1 = 0;\n\tfor(int k=i;k<n;k++){\n\t  t1 += 1<<k;\n\t  int t2 = 0;\n\t  for(int l=j;l<n;l++){\n\t    t2 += (t1<<n*l);\n\t    mask[n].push_back(t2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n    int N = (1<<(n*n));\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)cin >> m[i][j];\n\n    int ans = 0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(m[i][j])ans += 1<<(i*n+j);\n\n    for(int i=0;i<N;i++)dp[i] = -1;\n    dp[ans] = 0;\n    queue<int> q;\n    q.push(ans);\n\n    while(q.size()){\n      int hoge = q.front();q.pop();\n      if(!hoge)break;\n\n      for(int i=0;i<(int)mask[n].size();i++){\n\tint tmp = hoge ^ mask[n][i];\n\tif(dp[tmp]<0){\n\t  dp[tmp] = dp[hoge]+1;\n\t  q.push(tmp);\n\t}\n      }\n    }\n    \n    for(int j=0;j<dp[0];j++)cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6][6];\nint n;\nint solve(int p,int q,int t){\n\tif(t==0){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(c[i][j])return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t);\n\tif(!c[p][q])return solve(p,q+1,t);\n\tint r=q;\n\tfor(int i=q;i<n;i++){\n\t\tif(c[p][i])r=i;\n\t\telse break;\n\t}\n\tr++;\n\tfor(int h=q;h<n;h++){\n\t\tfor(int i=p;i<n;i++){\n\t\t\tfor(int j=q;j<=h;j++)c[i][j]^=1;\n\t\t\tif(solve(p,q+1,t-1))return 1;\n\t\t}\n\t\tfor(int i=p;i<n;i++)for(int j=q;j<=h;j++)c[i][j]^=1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=1;;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++)c[j][k]=b[j][k];\n\t\t\tif(solve(0,0,i)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\nmap<int, short> dp;\nint recur(int e, int sum, int& min_res)\n{\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = (n * n + 1) / 2;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint solve(int x,const vi& ms,vi& memo)\n{\n\tif(memo[x]!=INF) return memo[x];\n\t\n\tif(x==0) return memo[x]=0;\n\tint res=INF;\n\tfor(int m:ms) if(__builtin_ctz(x)==__builtin_ctz(m))\n\t\tres=min(res,solve(x^m,ms,memo));\n\treturn memo[x]=res+1;\n}\n\nint main()\n{\n\tvi ms;\n\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\tint m=0;\n\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\tms.push_back(m);\n\t}\n\tvi memo(1<<25,INF);\n\t\n\tfor(int n;cin>>n && n;){\n\t\tint x=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx|=b<<(i*5+j);\n\t\t}\n\t\t\n\t\tint res=solve(x,ms,memo);\n\t\trep(i,res) cout<<string(\"myon\"); cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nint dp[1<<25];\n//int minArrivingDepth[1<<25];\n\nint n;\nconst int INF=(1<<30);\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nint minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tint minCnt=INF;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,minStep(ns,depth+1)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(cin>>n&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\nmap<int, short> dp;\nint recur(int e, int sum, int& min_res)\n{\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                for (int y2 = y1; y2 <= max_y; ++y2)\n                {\n                    for (int x2 = x1; x2 <= max_x; ++x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = n * n;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint b[5][5][5][5][5],n;\nshort c[5][1<<25];\nint fi(int p){\n  int i,j,k,l;\n  if(c[n-1][p]>=0)\n    return c[n-1][p];\n  int mn=1<<14;\n  for(i=0;i<n;++i){\n    for(j=0;j<n;++j){\n      if(p&(1<<(i*n+j)))\n\tbreak;\n    }\n    if(j<n)\n      break;\n  }\n  for(k=i;k<n;++k)\n    for(l=j;l<n;++l)\n      mn=min(mn,fi(p^b[n-1][i][j][k][l])+1);\n  return c[n-1][p]=mn;\n}\nint main(){\n  int g,h,i,j,k,l,m;\n  //int b[5][5][5][5][5];  \n  memset(b,0,sizeof(b));\n  for(i=0;i<5;++i)\n    for(j=0;j<=i;++j)\n      for(k=0;k<=i;++k)\n\tfor(l=j;l<=i;++l)\n\t  for(m=k;m<=i;++m)\n\t    for(g=j;g<=l;++g)\n\t      for(h=k;h<=m;++h)\n\t\tb[i][j][k][l][m]|=1<<(g*(i+1)+h);\n  memset(c,-1,sizeof(c));\n  for(i=0;i<5;++i)\n    c[i][0]=0;\n  //int n;\n  while(cin>>n,n){\n    int a=0;\n    for(i=0;i<n*n;++i){\n      bool p;\n      cin>>p;\n      a<<=1;\n      if(p)\n\ta|=1;\n    }\n    cout<<fi(a)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){\n\t\tx = x_;\n\t\ty = y_;\n\t};\n};\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<int> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,int> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,int> > q;\n\tq.push( pair<int,int>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,int> > q;\n\tq.push( pair<int,int>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( cnt >= 3 || dp_5.size() >= 8000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<int> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<int> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<int> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<int> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t\n\t// cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t// cout << \"input\" << endl;\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << dp[n-1][bits] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 20000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 20000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\tdfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 1000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ 4 ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ 5 ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint n;\nint xor_mask[5][5][5][5];\nchar dp[1 << 25];\nint recur(int e)\n{\n    if (~dp[e])\n        return dp[e];\n\n    for (int y = 0; y < n; ++y)\n    {\n        for (int x = 0; x < n; ++x)\n        {\n            if (e >> (y * size + x) & 1)\n            {\n                int res = 1 << 29;\n                for (int yy = y; yy < n; ++yy)\n                    for (int xx = x; xx < n; ++xx)\n                        min_swap(res, recur(e ^ xor_mask[y][x][yy][xx]) + 1);\n                return dp[e] = res;\n            }\n        }\n    }\n\n    puts(\"akan\");\n    exit(1);\n}\nint main()\n{\n    for (int y1 = 0; y1 < size; ++y1)\n    {\n        for (int x1 = 0; x1 < size; ++x1)\n        {\n            for (int y2 = y1; y2 < size; ++y2)\n            {\n                for (int x2 = x1; x2 < size; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = size - 1; y >= 0; --y)\n                        for (int x = size - 1; x >= 0; --x)\n                            mask = (mask << 1) | (x1 <= x && x <= x2 && y1 <= y && y <= y2);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    CL(dp, -1);\n    dp[0] = 0;\n\n    while (cin >> n, n)\n    {\n        bool f[5][5] = {};\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n        int e = 0;\n        for (int y = size - 1; y >= 0; --y)\n            for (int x = size - 1; x >= 0; --x)\n                e = (e << 1) | f[y][x];\n\n        int times = recur(e);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\npair<int,int> up_left(int bits, int n){\n\tint mx = 5, my = 5;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tif( get(n,bits,x,y) ){\n\t\t\t\tmx = min( mx , x );\n\t\t\t\tmy = min( my , y );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<int,int> (mx,my);\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_N3(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 3 のすべての解を求めておく\nvoid solve(){\n\tfor(int i=1 ; i <= 4 ; i++ ){\n\t\tif( i == 1 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 3 ){\n\t\t\tdp[2] = vector<char>(512);\n\t\t\tsolve_N3( 3 );\n\t\t}else if( i == 4 ){\n\t\t\tdp[3] = vector<char>(65536);\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 3 のすべての解を求めておく\n\tsolve();\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tcout << \"end;\" << endl;\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\tdebug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}else if( n == 5 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int t,v;\n  bool operator<(S a)const{\n    if(t!=a.t){\n      return t<a.t;\n    }else{\n      return v<a.v;\n    }\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    set<S> que;\n    S is={0,v};\n    que.insert(is);\n    set<int> s;\n    for(;;){\n      S c=*que.begin();\n      if(c.v==0)break;\n      que.erase(que.begin());\n      if(!s.insert(c.v).second)continue;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=j;l<n;l++){\n\t    for(int m=k;m<n;m++){\n\t      int nv=c.v;\n\t      for(int o=j;o<=l;o++){\n\t\tfor(int p=k;p<=m;p++){\n\t\t  nv^=1<<o*n+p;\n\t\t}\n\t      }\n\t      S ns={c.t+1,nv};\n\t      que.insert(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<que.begin()->t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ninline int ctz(uint x)\n{\n\tint i=0;\n\tif(!(x&0x0000ffff)) i+=16,x>>=16;\n\tif(!(x&0x000000ff)) i+=8,x>>=8;\n\tif(!(x&0x0000000f)) i+=4,x>>=4;\n\tif(!(x&0x00000003)) i+=2,x>>=2;\n\tif(!(x&0x00000001)) i+=1,x>>=1;\n\treturn i+!x;\n}\n\nint solve(int x0)\n{\n\tstatic array<int,225> ms;\n\t{\n\t\tint k=0;\n\t\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\t\tint m=0;\n\t\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\t\tms[k++]=m;\n\t\t}\n\t}\n\t\n\tqueue<tuple<int,int>> q; q.emplace(x0,0);\n\tunordered_set<int> vis;\n\twhile(q.size()){\n\t\tint x,c; tie(x,c)=q.front(); q.pop();\n\t\tif(x==0) return c;\n\t\tif(!vis.insert(x).second) continue;\n\t\tfor(int m:ms) if(ctz(x)==ctz(m))\n\t\t\tq.emplace(x^m,c+1);\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tint x0=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx0|=b<<(i*5+j);\n\t\t}\n\t\tstring res;\n\t\tper(_,solve(x0)) res+=\"myon\";\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint dd[6][6];\nstruct sy{\n\tint k[6];\n\tint d;\n};\ninline bool jud(sy a){\n\tif(a.k[5]+a.k[1]+a.k[2]+a.k[3]+a.k[4]==0)\n\t\treturn 1;\n\treturn 0;\n}\nint main()\n{\n\tdd[1][1]=1;\n\tdd[1][2]=3;\n\tdd[1][3]=7;\n\tdd[1][4]=15;\n\tdd[1][5]=31;\n\tdd[2][2]=2;\n\tdd[2][3]=6;\n\tdd[2][4]=14;\n\tdd[2][5]=30;\n\tdd[3][3]=4;\n\tdd[3][4]=12;\n\tdd[3][5]=28;\n\tdd[4][4]=8;\n\tdd[4][5]=24;\n\tdd[5][5]=16;\n\t\n\tint n,i,j,a;\n\twhile(cin>>n&&n){\n\t\tsy l;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tint c=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tcin>>a;\n\t\t\t\tc+=(a<<j);\n\t\t\t}\n\t\t\tl.k[i]=c;\n\t\t}\n\t\tl.d=0;\n\t\tqueue<sy> ac;\n\t\tac.push(l);\n\t\tbool f=0;\n\t\twhile(!ac.empty()){\n\t\t\tl=ac.front();\n\t\t\tac.pop();\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\tfor(int ii=i;ii<=n;ii++)\n\t\t\t\t\t\tfor(int jj=j;jj<=n;jj++){\n\t\t\t\t\t\t\tsy x=l;\n\t\t\t\t\t\t\tx.d++;\n\t\t\t\t\t\t\tfor(int t=i;t<=ii;t++){\n\t\t\t\t\t\t\t\tx.k[t]^=dd[j][jj];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(jud(x)){\n\t\t\t\t\t\t\t\twhile(x.d--){\n\t\t\t\t\t\t\t\t\tcout<<\"myon\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\t\t\tgoto asd;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tac.push(x);\n\t\t\t\t\t\t}\n\t\t}\nasd:;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint flag[(1<<25)/32];\n\nint check( long long int x ) {\n  return ( flag[x/32] & ( 1<<( x%32 ) ) );\n}\n\nint set( long long int x ) {\n  flag[x/32] |= ( 1<<( x%32 ) );\n}\n\nlong long int change( int x, int y, int n ) {\n  if ( x < 0 || y < 0 || x >= n || y >= n ) return 0;\n  return 1<<(x+y*n);\n}\n\nint main() {\n\n  while(true) {\n\n    int n,input;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    for ( int i = 0; i < ( 1<<(n*n) )/32; i++ ) {\n      flag[i] = 0;\n    }\n\n    //next[x_length][y_length]\n    long long int next[5][5];\n    int line = 0;\n    for ( int x = 0; x < n; x++ ) {\n      line = (line<<1) + 1;\n      long long int map = line;\n      for ( int y = 0; y < n; y++ ) {\n\tnext[x][y] = map;\n\tmap = (map << n) + line;\n      }\n    }\n\n    long long int map = 0;\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = 0; j < n; j++ ) {\n\tcin >> input;\n\tmap = ( map<<1 ) + input;\n      }\n    }\n    set(map);\n    vector<long long int> map_old;\n    vector<long long int> map_new;\n    map_old.push_back(map);\n\n    int cnt = 0;\n\n    while(true) {\n      cnt++;\n      cout << cnt << endl;\n\n      for ( int i = 0; i < map_old.size(); i++ ) {\n\tfor ( int x = 0; x < n; x++ ) {\n\t  for ( int y = 0; y < n; y++ ) {\n\t    if ( ( map_old[i] & change(x,y,n) ) == 0 || ( map_old[i] & change(x-1,y,n) ) != 0 || ( map_old[i] & change(x,y-1,n) ) != 0 ) continue;\n\n\t    for ( int x_l = 0; x_l < n-x; x_l++ ) {\n\t      for ( int y_l = 0; y_l < n-y; y_l++ ) {\n\t\tlong long int m = ( map_old[i] ^ ( next[x_l][y_l]<<( x+y*n ) ) );\n\t\tif ( check(m) == 0 ) {\n\t\t  map_new.push_back( m );\n\t\t  set(m);\n\t\t}\n\t      }\n\t    }\n\n\t  }\n\t}\n      }\n\n      if ( check(0) ) break;\n      if ( cnt > 50 ) {\n\tcout << \"error\" << endl;\n\tcnt = 0;\n\tbreak;\n      }\n\n      map_old.clear();\n      for ( int i = 0; i < map_new.size(); i++ ) {\n\tmap_old.push_back( map_new[i] );\n      }\n      map_new.clear();\n\n    }\n\n    for ( int i = 0; i < cnt; i++ ) {\n      cout << \"myon\";\n    }\n    cout << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint n;\nint xor_mask[5][5][5][5];\n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n// char dp[1 << 25];\nunordered_map<int, char> dp;\nint recur(int e)\n{\n    if (dp.count(e))\n        return dp[e];\n\n    for (int y = 0; y < n; ++y)\n    {\n        for (int x = 0; x < n; ++x)\n        {\n            if (e >> (y * size + x) & 1)\n            {\n                int res = 1 << 29;\n                for (int yy = y; yy < n; ++yy)\n                    for (int xx = x; xx < n; ++xx)\n                        min_swap(res, recur(e ^ xor_mask[y][x][yy][xx]) + 1);\n                return dp[e] = res;\n            }\n        }\n    }\n\n    puts(\"akan\");\n    exit(1);\n}\nint main()\n{\n    for (int y1 = 0; y1 < size; ++y1)\n    {\n        for (int x1 = 0; x1 < size; ++x1)\n        {\n            for (int y2 = y1; y2 < size; ++y2)\n            {\n                for (int x2 = x1; x2 < size; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = size - 1; y >= 0; --y)\n                        for (int x = size - 1; x >= 0; --x)\n                            mask = (mask << 1) | (x1 <= x && x <= x2 && y1 <= y && y <= y2);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    while (cin >> n, n)\n    {\n        bool f[5][5] = {};\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n        int e = 0;\n        for (int y = size - 1; y >= 0; --y)\n            for (int x = size - 1; x >= 0; --x)\n                e = (e << 1) | f[y][x];\n\n        int times = recur(e);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int t;\n  vector<int> v;\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<int> v(n*n);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcin>>v[i*n+j];\n      }\n    }\n    queue<S> que;\n    S is={0,v};\n    que.push(is);\n    set<vector<int> > s;\n    for(;;){\n      S c=que.front();\n      int i;\n      for(i=0;i<c.v.size();i++){\n\tif(c.v[i])break;\n      }\n      if(i==c.v.size())break;\n      que.pop();\n      if(!s.insert(c.v).second)continue;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=j;l<n;l++){\n\t    for(int m=k;m<n;m++){\n\t      vector<int> nv=c.v;\n\t      for(int o=j;o<=l;o++){\n\t\tfor(int p=k;p<=m;p++){\n\t\t  nv[o*n+p]^=1;\n\t\t}\n\t      }\n\t      S ns={c.t+1,nv};\n\t      que.push(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<que.front().t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\t//if(((s>>(miny*n+minx))&1)==0)\n\t\t\t//\tcontinue;\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=(~(1<<(i*n+j)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tif(bit==1)\n\t\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<bool>> vii;\n//\n#include<unordered_map>\nclass HashVI {  // ???n???b???V?????????????????I???u???W???F???N???g\npublic:\n\tsize_t operator()(const vector<vector<bool>> &x) const {\n\t\tconst int C = 997;      // ???f??????\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nunordered_map<vector<vector<bool>>,int,HashVI>memo;\n\nint N; \nint solve(const vii &field){\n    if(memo.find(field)==memo.end()){\n        for(int y=0;y<field.size();++y){\n            for(int x=0;x<field[y].size();++x){\n                if(field[y][x]){\n                int ans=100;\n                    for(int xsz=1;xsz<=N-x;++xsz){\n                        for(int ysz=1;ysz<=N-y;++ysz){\n                            vii nextfield(field);\n                            for(int dy=0;dy<ysz;++dy){\n                                for(int dx=0;dx<xsz;++dx){\n                                    int nexty=y+dy;\n                                    int nextx=x+dx;\n                                    nextfield[nexty][nextx]=!nextfield[nexty][nextx];\n                                }\n                            }\n                            ans=min(ans,1+solve(nextfield));\n                        }\n                    }\n                 return memo[field]=ans;\n                }\n            }\n        }\n        return memo[field]=0;\n    }\n    return memo[field];\n}\nint main(){\n    while(true){\n        cin>>N;\n        if(!N)break;\n        memo.clear();\n        vii field(N,vector<bool>(N));\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                int a;cin>>a;\n                field[i][j]=a;\n            }\n        }\n        int ans=solve(field);\n        for(int i=0;i<ans;++i){\n            cout<<\"myon\";\n        }\n        cout<<endl;\n\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * 5) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1 && y != 0 && x != 0) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n        ret = min(ret, calc(y, x + 1) + 1);\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  MEMSET(memo, -1);\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n\nint n,g,a,b;\nint d[1<<20];\nvector<int> m[5][5];\n\nint rec(int g, int t){\n  if(t == 5){\n    if( (g & 31) )return 1000000;\n    return d[g>>5];\n  }\n  int r = rec(g,t+1);\n  for(int i=0;i<m[0][t].size();i++)r = min(r,rec(g^m[0][t][i],t+1)+1);\n  return r;\n}\n    \nint main(){\n  REP(i,0,5)REP(j,0,5)REP(k,i,5)REP(l,j,5){\n    int tmp = 0;\n    REP(y,i,k+1)REP(x,j,l+1)tmp |= 1<<(y*5+x);\n    m[i][j].push_back(tmp);\n  }\n\n  for(int i=0;i<(1<<20);i++)d[i] = -1; d[0] = 0;\n  queue<int> q; q.push(0);\n  while(q.size()){\n    int p = q.front(); q.pop();\n    REP(i,0,4)REP(j,0,5)REP(k,0,m[i][j].size()){\n      if(m[i][j][k]>=1<<20)continue;\n      int nxt = p^m[i][j][k];\n      if(d[nxt]<0){\n\td[nxt] = d[p] + 1;\n\tq.push(nxt);\n      }\n    }\n  }\n\n  while(cin >> n,n){\n    g = 0;\n    REP(i,0,5)REP(j,0,5)\n      if(i<n && j<n){\n\tcin >> b;\n\tg |= b<<(i*5+j);\n      }\n    \n    if(n<5)a = d[g];\n    else a = rec(g,0);\n    \n    REP(i,0,a)cout << \"myon\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\n\nint n;\nmap<int, int> mm;\nint st, ed;\nvector<pair<int, int> > rec;\nvector<pair<int, int> > pro;\n\nint trans(int sta, int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; ++i) {\n        //for (int j = y1; j <= y2; ++j) {\n            //sta ^= (1 << j) << (i * n);\n        //}\n        sta ^= ((1<<y2+1) - 1 - ((1<<y1) - 1)) << (i * n);\n    }\n    return sta;\n}\nint find(int x) {\n    int low = 0, high = rec.size() - 1, res = -1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (rec[mid].first <= x) {\n            low = mid + 1;\n            if (rec[mid].first == x) res = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return res;\n}\nint get_bin(int x, int i, int j) {\n    return (x >> (i * n + j)) & 1;\n}\nint bfs(int x) {\n    if (x == 0) return 0;\n    int res = find(x);\n    if (res >= 0) return rec[res].second;\n    mm.clear();\n    mm[x] = 0;\n    queue<int> que;\n    que.push(x);\n    while (!que.empty()) {\n        int x = que.front();\n        que.pop();\n        int dep = mm[x];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = i; k < n; ++k) {\n                    for (int c = j; c < n; ++c) {\n                        if (get_bin(x, i, j) == 0 || get_bin(x, k, c) == 0) continue;\n                        if (get_bin(x, i, c) == 0 || get_bin(x, k, j) == 0) continue;\n                        int sta = trans(x, i, j, k, c);\n                        if (mm.find(sta) == mm.end()) {\n                            mm[sta] = dep + 1;\n                            que.push(sta);\n                            int res = find(sta);\n                            if (res >= 0) {\n                                return rec[res].second + dep + 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\nvoid init(int cut = 2) {\n    mm.clear();\n    queue<int> que;\n    que.push(0);\n    mm[0] = 0;\n    while (!que.empty()) {\n        int x = que.front();\n        que.pop();\n        int dep = mm[x];\n        //printf(\"%d %d\\n\", dep, cut);\n        if (dep >= cut) break;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = i; k < n; ++k) {\n                    for (int c = j; c < n; ++c) {\n                        int sta = trans(x, i, j, k, c);\n                        if (mm.find(sta) == mm.end()) {\n                            mm[sta] = dep + 1;\n                            que.push(sta);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    rec.clear();\n    for (map<int, int>::iterator it = mm.begin(); it != mm.end(); ++it) {\n        rec.push_back(*it);\n    }\n    sort(rec.begin(), rec.end());\n}\nbool cmp(int x1, int x2) {\n    return pro[x1].first < pro[x2].first;\n}\nint main() {\n    pro.clear();\n    while (scanf(\"%d\", &n) == 1 && n) {\n        st = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int x;\n                scanf(\"%d\", &x);\n                st = (st << 1) | x;\n            }\n        }\n        pro.push_back(make_pair(n, st));\n    }\n    vector<int> id(pro.size()), ans(pro.size());\n    for (int i = 0; i < (int) pro.size(); ++i) {\n        id[i] = i;\n    }\n    stable_sort(id.begin(), id.end(), cmp);\n    n = 0;\n    for (int i = 0; i < (int)pro.size(); ++i) {\n        if (pro[id[i]].first != n) {\n            n = pro[id[i]].first;\n            init();\n            //printf(\"%d: %d %d\\n\", n, mm.size(), rec.size());\n        }\n        int res = bfs(pro[id[i]].second);\n        ans[id[i]] = res;\n        //printf(\"%d\\n\", res);\n    }\n    for (int i = 0; i < (int) pro.size(); ++i) {\n        for (int j = 0; j < ans[i]; ++j) printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nint MIN_ANS;\nint dfs(int s, int c){\n  if(s == 0) return c;\n  if(c >= MIN_ANS) return INF;\n  int res = INF;\n  int next[6][6][6][6] = {};\n  REP(y, N) REP(x, N) next[y][y][x][x] = s;\n  // [y1][y2][x1][x2] = [y1][y2][x1][x2 - 1] ^ [y1][y2 - 1][x1][x2] - [y1][y2 - 1][x1][x2 - 1]\n  for(int y1 = 0; y1 < N; y1++){\n    for(int x1 = 0; x1 < N; x1++){\n      for(int y2 = y1 + 1; y2 <= N; y2++){\n        for(int x2 = x1 + 1; x2 <= N; x2++){\n          next[y1][y2][x1][x2] = next[y1][y2][x1][x2 - 1] ^ \n            next[y1][y2 - 1][x1][x2] ^\n            next[y1][y2 - 1][x1][x2 - 1] ^ \n            (1 << ((y2 - 1) * N + (x2 - 1)));\n          int ns = next[y1][y2][x1][x2];\n          res = min(res, dfs(ns, c + 1));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> N && N){\n    int start = 0;\n    REP(i, N * N){\n      int t;\n      cin >> t;\n      start |= t << i;\n    }\n    int ans = INF;\n    MIN_ANS = 0;\n    while(true){\n      ans = dfs(start, 0);\n      if(ans < INF){\n        break;\n      }else{\n        MIN_ANS ++;\n      }\n    }\n    string myon = \"myon\";\n    REP(i, ans) cout << myon;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\nint N;\n\nvector<int> mem;\nvector<int> mas;\n\nvector<int> item[25];\n\n\nint w[16];\nint h[16];\n\nchar memo[2][1<<25];\nchar dfs(int init){\n\n\tchar *a = memo[0] , *b = memo[1];\n\t\n\tfor(int j = 0 ; j < (1<<25) ; j++)\n\t\ta[j] = 32;\n\t\n\ta[init] = 0;\n\t\n\tfor(int i = 0 ; i < 5 * 5 ; i++){\n\t\tfor(int j = 0 ; j < (1<<25) ; j++) b[j] = a[j];\n\t\tfor(int j = 0 ; j < (1<<25) ; j++){\n\t\t\tif( a[j] == 32 ) continue;\n\t\t\tfor(int k = 0 ; k < item[i].size() ; k++)\n\t\t\t\tb[j^item[i][k]] = min(b[j^item[i][k]],(char)(a[j]+1));\n\t\t}\n\t\tswap(a,b);\n\t}\n\t\n}\t\n\nint main(){\n\t\n\tfor(int w = 1 ; w <= 5 ; w++){\n\t\tfor(int h = 1 ; h <= 5 ; h++){\n\t\t\tfor(int i = 0 ; i <= 5 - h ; i++){\n\t\t\t\tfor(int j = 0 ; j <= 5 - w ; j++){\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tfor(int k = 0 ; k < h ; k++)\n\t\t\t\t\t\tfor(int l = 0 ; l < w ; l++)\n\t\t\t\t\t\t\tmask |= (1<<((i+k)*5+j+l));\n\t\t\t\t\t//cout << init << \" \" << mask << endl;\n\t\t\t\t\titem[i*5+j].push_back(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\twhile(cin >> N && N){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tint c = 0;\n\t\t\t\tcin >> c;\n\t\t\t\tinit |= (c<<(i*5+j));\n\t\t\t}\n\t\t}\n\t\tint x = memo[0][init];\n\t\tfor(int i = 0 ; i < x ; i++) cout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint dp[1<<5][1<<5][1<<5][1<<5][1<<5];\nbool passed[1<<5][1<<5][1<<5][1<<5][1<<5];\n\nint n;\nint field[5][5];\n\t\nconst int INF=1000000;\n\nint dfs(int s1,int s2,int s3,int s4,int s5){\n\tif(!s1&&!s2&&!s3&&!s4&&!s5){\n\t\treturn 0;\n\t}\n\tif(dp[s1][s2][s3][s4][s5]!=0)\n\t\treturn dp[s1][s2][s3][s4][s5];\n\n\tint minRet=INF;\n\t\n\t// é`¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx= 0; minx < n; minx++){\n\t\t\t// é`EºÌÀW\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns[5];\n\t\t\t\t\tns[0] = s1;\n\t\t\t\t\tns[1] = s2;\n\t\t\t\t\tns[2] = s3;\n\t\t\t\t\tns[3] = s4;\n\t\t\t\t\tns[4] = s5;\n\t\t\t\t\t// èµ½ÍÍÌrbgð½]·é\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\tif(((ns[i] >> j) & 1)){\n\t\t\t\t\t\t\t\tns[i] &= ~(1 << j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tns[i] |= (1<<j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÄA\n\t\t\t\t\tif(passed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpassed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]]=true;\n\t\t\t\t\tif(ns[0]==0){\n\t\t\t\t\t//\tcout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tminRet=min(minRet,1+dfs(ns[0],ns[1],ns[2],ns[3],ns[4]));\n\t\t\t\t\tpassed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[s1][s2][s3][s4][s5]=minRet;\n\treturn minRet;\n\t//if(n==1){\n\t//\treturn 1;\n\t//}\n\t//else if(n==2){\n\t//\treturn 1;\n\t//}\n\t//else if(n==3){\n\t//\tif(s1==0&&s2==0&&s3==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][0][0]!=INF)\n\t//\t\treturn dp[s1][s2][s3][0][0];\n\t//\t// ñÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\t\n\t//\tfor(int i = 0; i < 3; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,0,0));\n\t//\tns1=s1;ns2=s2;ns3=s3;\n\t//\tfor(int i = 0; i < 3; i++){\n\t//\t\tif(i == 1){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,0,0));\n\t//\tdp[s1][s2][s3][0][0]=minRet;\n\t//\treturn minRet;\n\t//}\n\t//else if(n==4){\n\t//\tif(s1==0&&s2==0&&s3==0&&s4==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][s4][0]!=INF)\n\t//\t\treturn dp[s1][s2][s3][s4][0];\n\t//\t// ñÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\tint ns4 = s4;\n\t//\t\n\t//\tfor(int i = 0; i < 4; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s4 >> i) & 1)){\n\t//\t\t\tns4 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns4 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,0));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;\n\t//\tfor(int i = 0; i < 4; i++){\n\t//\t\tif(i == 1 || i == 2){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,0));\n\t//\tdp[s1][s2][s3][ns4][0]=minRet;\n\t//\treturn minRet;\n\t//}\n\t//else if(n==5){\n\t//\tif(s1==0&&s2==0&&s3==0&&s4==0&&s5==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][s4][s5]!=INF)\n\t//\t\treturn dp[s1][s2][s3][s4][s5];\n\t//\t// OÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\tint ns4 = s4;\n\t//\tint ns5 = s5;\n\t//\t\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s4 >> i) & 1)){\n\t//\t\t\tns4 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns4 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s5 >> i) & 1)){\n\t//\t\t\tns5 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns5 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;ns5=s5;\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(i != 0 && i != 4){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t\tif(((s4 >> i) & 1)){\n\t//\t\t\t\tns4 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns4 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t\tif(i == 1 || i == 3 || i == 2){\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;ns5=s5;\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(i == 2){\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tdp[s1][s2][s3][ns4][ns5]=minRet;\n\t//\treturn minRet;\n\t//}\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\n\t\tint s[5];\n\t\ts[0]=s[1]=s[2]=s[3]=s[4]=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]){\n\t\t\t\t\ts[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(passed,0,sizeof(passed));\n\n\t\tpassed[s[0]][s[1]][s[2]][s[3]][s[4]]=true;\n\t\tcout<<dfs(s[0],s[1],s[2],s[3],s[4])<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 3)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  rep(i,(1<<5))mincost5[i] = 100; \n  bitset<30> b(field),b2(field>>20);\n  //cout << \"b = \" << b << endl;\n  //cout << \"b2 = \" << b2 << endl;\n  mincost5[(field>>20)] = 0;\n  int ret = 5;\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define calc __builtin_popcount\nusing namespace std;\nint n,G[5][5],ans;\nmap<int,int>vis;\nvector<int>move[30];\nint H(int sta,int k){\n\treturn (calc(sta)+k-1)/k;\t\n}\nint Q[50];\nvoid show(int sta){\n\tfor(int r=0;r<n;r++){\n\t\tfor(int c=0;c<n;c++)\n\t\t\tputchar((sta&(1<<(r*n+c)))?'1':'0');\n\t\tputs(\"\");\n\t}\n\tputs(\"----\");\n}\nvoid ws(int dep,int sta,int k,int last){\n\tif(dep==3||k==0)return;\n\tif(vis.find(sta)==vis.end()){\n\t\tvis[sta]=dep;\n\t}else if(vis[sta]>dep){\n\t\tvis[sta]=dep;\n\t}\n\tfor(int i=last;i<move[k].size();i++){\n\t\tws(dep+1,sta^move[k][i],k,i);\n\t}\n\tws(dep,sta,k-1,0);\n}\nbool succ;\nvoid DFS(int dep,int k,int sta,int last){\n\tif(k==0)return;\n\tif(dep+H(sta,k)>=ans)return;\n\tif(sta==0){\n\t\tans=dep;\n\t\t/*printf(\"ans:%d\\n\",ans);\n\t\tfor(int i=0;i<dep;i++){\n\t\t\tshow(Q[i]);\n\t\t}*/\n\t\treturn;\n\t}\n\tfor(int i=last;i<move[k].size();i++){\n\t\tDFS(dep+1,k,sta^move[k][i],i);\n\t}\n\tDFS(dep,k-1,sta,0);\n}\nint lim;\nbool DFS5(int dep,int k,int sta,int last){\n\tif(dep+H(sta,k)>lim)return false;\n\tif(vis.find(sta)!=vis.end()){\n\t\tans=dep+vis[sta];\n\t\treturn true;\n\t}\n\tfor(int i=last;i<move[k].size();i++){\n\t\tif(DFS5(dep+1,k,sta^move[k][i],i))return true;\n\t}\n\tif(DFS5(dep,k-1,sta,0))return true;\n\treturn false;\n}\nvoid init(){\n\tfor(int r=1;r<=n;r++)\n\tfor(int c=1;c<=n;c++){\n\t\tfor(int i=0;i+r-1<n;i++)\n\t\tfor(int j=0;j+c-1<n;j++){\n\t\t\tint sta=0;\n\t\t\tfor(int y=i;y<i+r;y++)\n\t\t\tfor(int x=j;x<j+c;x++)\n\t\t\t\tsta^=(1<<(y*n+x));\n\t\t\tmove[r*c].push_back(sta);\n\t\t}\n\t}\n}\nmap<int,int> aa;\n\nint chan(){\n\tint sta=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(G[i][j])sta^=(1<<(i*n+j));\n\treturn sta;\n}\t\t\t\n\nvoid init2(){\n\taa.clear();\n\tmemset(G,0,sizeof(G));\n\tG[0][0]=1;G[0][2]=1;G[0][4]=1;\n\tG[2][0]=1;G[2][2]=1;G[2][4]=1;\n\tG[4][0]=1;G[4][2]=1;G[4][4]=1;\n\taa[chan()]=9;\n\t\n\tint dx[9]={0,0,0,2,2,2,4,4,4};\n\tint dy[9]={0,2,4,0,2,4,0,2,4};\n\tfor (int i=0;i<9;++i){\n\t\tG[dx[i]][dy[i]]=0;\n\t\taa[chan()]=8;\n\t\tG[dx[i]][dy[i]]=1;\n\t}\n\t\n\tfor (int i=0;i<8;++i)\n\t for (int j=i+1;j<9;++j){\n\t\tG[dx[i]][dy[i]]=0;\n\t\tG[dx[j]][dy[j]]=0;\n\t\taa[chan()]=7;\n\t\tG[dx[i]][dy[i]]=1;\n\t\tG[dx[j]][dy[j]]=1;\n\t }\n}\n\nint main(){\n\t\t\n\tn=5;\n\tinit();\n\tws(0,0,25,0);\n\tint maxans=0;\n\t//printf(\"%d\\n\",vis.size());\n\t\n\tinit2();\n\t\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<=n*n;i++)move[i].clear();\n\t\tinit();\n\t\tint sta=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t\t\tif(G[i][j])sta^=(1<<(i*n+j));\n\t\t\t}\n//\t\tcout << sta << endl;\n\t\tif (aa.find(sta)!=aa.end()){\n\t\t\tprintf(\"%d\\n\",aa[sta]);\n\t\t\tcontinue;\n\t\t}\n\t\tsucc=false;\n\t\tans=10;\n\t\tif(n<5){\n\t\t\tDFS(0,n*n,sta,0);\n\t\t}else{\n\t\t\tfor(lim=1;;lim++){\n\t\t\t\tif(DFS5(0,n*n,sta,0))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tif(ans>maxans){\n\t\t\tcout<<ans<<endl;\n\t\t\tfor (int i=0;i<5;++i){\n\t\t\t\tfor (int j=0;j<5;++j) printf(\"%d \",G[i][j]);\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tmaxans=ans;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  static int close[(1<<(5*5))/32];\n  static int cls[1000000];\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n    int pats[33][32]={};\n    int pats_cnt[33]={};\n    int tmp[5][5]={};\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    int ix=__builtin_clz(bd);\n\t    pats[ix][pats_cnt[ix]++]=bd;\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      //const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int ix=__builtin_clz(cbd);\n      int sz=pats_cnt[ix];\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^pats[ix][i];\n\tif (close[nbd>>5]&(1<<(nbd&31)))\n\t  continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    {\n      int i=0;\n      for (; i+3<cls_cnt; i+=4){\n\tclose[(cls[i+0]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+1]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+2]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+3]&0x1ffffff)>>5]=0;\n      }\n      for (; i<cls_cnt; i++)\n\tclose[(cls[i]&0x1ffffff)>>5]=0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nunsigned char dp[1<<25];\n\nint n;\nconst unsigned char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nunsigned char minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tunsigned char minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif((s&(1<<(miny*n+minx)))==0)\n\t\t\t\tcontinue;\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\t//int b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tint b=(s&(1<<(i*n+j)));\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns=(ns&(~(1<<(i*n+j))));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns=(ns|(1<<(i*n+j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(unsigned char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tif(bit==1)\n\t\t\t\t\tinit|=(1<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=100;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\tif(!((s>>(miny*n+minx))&1))\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tchar cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=minStep(init);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 1)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  rep(i,(1<<5))mincost5[i] = 100; \n  bitset<30> b(field),b2(field>>20);\n  //cout << \"b = \" << b << endl;\n  //cout << \"b2 = \" << b2 << endl;\n  mincost5[(field>>20)] = 0;\n  int ret = 5;\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tr1/unordered_set>\nusing namespace std;\nusing namespace std::tr1;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    //vector<bool> close(1<<(n*n), false);\n    unordered_set<int> close;\n    mm.push(make_pair(0, bd));\n    //close[bd]=true;\n    close.insert(bd);\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\t//if (close[nbd]) continue;\n\t//close[nbd]=true;\n\tif (close.count(nbd)) continue;\n\tclose.insert(nbd);\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( cnt == 2 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint F(int x1,int x2,int y1,int y2,int n)\n{\n\tint r=0,y,x;\n\tfor(y=n-1;y>=0;--y)\n\t{\n\t\tfor(x=4;x>=0;--x)\n\t\t{\n\t\t\tr<<=1;\n\t\t\tif(y1<=y&&y<=y2&&x1<=x&&x<=x2)\n\t\t\t\t++r;\n\t\t}\n\t}\n\treturn r;\n}\nvector<int>v;\nconst int M=(1<<20);\nsigned char m[M];\nint main()\n{\n\tint n,i,j,k,l,x;\n\tfor(i=0;i<4;++i)for(j=i;j<4;++j)for(k=0;k<4;++k)for(l=k;l<4;++l)v.push_back(F(i,j,k,l,4));\n\tsort(v.begin(),v.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\tstd::vector<int>t,u;\n\tmemset(m,0x7f,sizeof(m));\n\tm[0]=0;\n\tfor(t.push_back(0),n=1;!t.empty();t=u,++n)\n\t{\n\t\tu.clear();\n\t\tfor(i=0;i<t.size();++i)\n\t\t{\n\t\t\tfor(j=0;j<v.size();++j)\n\t\t\t{\n\t\t\t\tx=t[i]^v[j];\n\t\t\t\tif(m[x]>n)\n\t\t\t\t{\n\t\t\t\t\tm[x]=n;\n\t\t\t\t\tu.push_back(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tx=0;\n\t\tfor(i=n-1;i>=0;--i)\n\t\t{\n\t\t\tfor(j=n-1;j>=0;--j)\n\t\t\t\tscanf(\"%d\",&k),x|=(1<<(5*i+j))*k;\n\t\t}\n\t\tint res=99,t;\n\t\tif(x<M)res=m[x];\n\t\tfor(i=0;i<5;++i)for(j=i;j<5;++j)for(k=0;k<5;++k)for(l=k;l<5;++l)\n\t\t{\n\t\t\tt=F(i,j,k,l,5);\n\t\t\tif((x^t)<M)res=min(res,m[x^t]+1);\n\t\t}\n\t\tfor(i=0;i<res;++i)printf(\"myon\");\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6][6];\nint n;\nint solve(int p,int q,int t){\n\tif(t==0){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(c[i][j])return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t);\n\tif(!c[p][q])return solve(p,q+1,t);\n\tfor(int h=q;h<n;h++){\n\t\tfor(int i=p;i<n;i++){\n\t\t\tfor(int j=q;j<=h;j++)c[i][j]^=1;\n\t\t\tif(solve(p,q+1,t-1))return 1;\n\t\t}\n\t\tfor(int i=p;i<n;i++)for(int j=q;j<=h;j++)c[i][j]^=1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=1;;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++)c[j][k]=b[j][k];\n\t\t\tif(solve(0,0,i)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar memo[1<<25];\nint n;\n\nchar solve(int state){\n  if(state == 0) return 0;\n  if(memo[state]>0) return memo[state];\n  if(memo[state]<0) return 30;\n  memo[state] = -1;\n  printf(\"state:%x\\n\",state);\n\n  char ret = 30;\n  return memo[state] = ret;\n}\n\nint main(){\n  while(n = getInt()){\n    int init = 0;\n    memset(memo,0,1<<(n*n));\n    REP(i,n) REP(j,n){\n      int t = getInt();\n      init |= (t << (j + i*n));\n    }\n    queue<int> q;\n    int cost = 0;\n    q.push(init);\n    q.push(-1);\n\n    while(q.size()){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        continue;\n      }\n\n      if(state == 0){\n        while(cost --> 0)\n          printf(\"myon\");\n        puts(\"\");\n        break;\n      }\n\n      if(memo[state]) continue;\n      memo[state] = cost;\n\n      //printf(\"%d %x\\n\",cost,state);\n      //REP(i,n){REP(j,n) printf(\" %d\",(state & (1 << (i*n + j)))?1:0);puts(\"\");}\n\n      for(int xs = 0; xs < n; xs++){\n        for(int xe = xs+1; xe <= n; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys = 0; ys < n; ys++){\n            int next = state;\n            for(int ye = ys; ye < n; ye++){\n              next ^= mask << (ye * n);\n              if(!memo[next]) q.push(next);\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n  vector<int> cls(1000000);\n  int cls_cnt=0;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(33);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[__builtin_clz(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cur=0;\n    close[bd]=true;\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls_cnt; i++)\n      close[cls[i]&0x1ffffff]=false;\n    cls_cnt=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<bitset<25> > > change(25);\nvector<char> memo;\n\nint solve(bitset<25> enemy)\n{\n    if(enemy.none())\n        return 0;\n    if(memo[enemy.to_ulong()] != -1)\n        return memo[enemy.to_ulong()];\n\n    int k = 0;\n    while(!enemy[k])\n        ++ k;\n\n    int ret = INT_MAX;\n    for(unsigned i=0; i<change[k].size(); ++i){\n        bitset<25> bs = enemy ^ change[k][i];\n        ret = min(ret, solve(bs) + 1);\n    }\n\n    return memo[enemy.to_ulong()] = ret;\n}\n\nint main()\n{\n    for(int i=0; i<25; ++i){\n        for(int j=i/5; j<5; ++j){\n            for(int k=i%5; k<5; ++k){\n                bitset<25> bs;\n                for(int y=i/5; y<=j; ++y){\n                    for(int x=i%5; x<=k; ++x){\n                        bs[y*5+x] = true;\n                    }\n                }\n                change[i].push_back(bs);\n            }\n        }\n    }\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<25> enemy;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                char tmp;\n                cin >> tmp;\n                if(tmp == '1')\n                    enemy[i*5+j] = true;\n            }\n        }\n\n        memo.assign(1<<25, -1);\n        int m = solve(enemy);\n        string ret;\n        while(--m >= 0)\n            ret += \"myon\";\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool flag[1<<25];\n\nlong long int change( int x, int y, int n ) {\n  if ( x < 0 || y < 0 || x >= n || y >= n ) return 0;\n  return 1<<(x+y*n);\n}\n\nint main() {\n\n  while(true) {\n\n    int n,input;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    for ( int i = 0; i < ( 1<<(n*n) ); i++ ) {\n      flag[i] = false;\n    }\n\n    //next[x_length][y_length]\n    long long int next[5][5];\n    int line = 0;\n    for ( int x = 0; x < n; x++ ) {\n      line = (line<<1) + 1;\n      long long int map = line;\n      for ( int y = 0; y < n; y++ ) {\n\tnext[x][y] = map;\n\tmap = (map << n) + line;\n      }\n    }\n\n    long long int map = 0;\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = 0; j < n; j++ ) {\n\tcin >> input;\n\tmap = ( map<<1 ) + input;\n      }\n    }\n    flag[map] = true;\n    vector<long long int> map_old;\n    vector<long long int> map_new;\n    map_old.push_back(map);\n\n    int cnt = 0;\n\n    while(true) {\n      cnt++;\n\n      for ( int i = 0; i < map_old.size(); i++ ) {\n\tfor ( int x = 0; x < n; x++ ) {\n\t  for ( int y = 0; y < n; y++ ) {\n\t    if ( map_old[i] & change(x,y,n) == 0 || map_old[i] & change(x-1,y,n) != 0 || map_old[i] & change(x,y-1,n) != 0 ) continue;\n\n\t    for ( int x_l = 0; x_l < n-x; x_l++ ) {\n\t      for ( int y_l = 0; y_l < n-y; y_l++ ) {\n\t\tlong long int m = map_old[i] ^ ( next[x_l][y_l]<<( x+y*n ) );\n\t\tif ( flag[ m ] == false ) {\n\t\t  map_new.push_back( m );\n\t\t  flag[ m ] = true;\n\t\t}\n\t      }\n\t    }\n\n\t  }\n\t}\n      }\n\n      if ( flag[0] ) break;\n      if ( cnt > 50 ) {\n\tcout << \"error\" << endl;\n\tcnt = 0;\n\tbreak;\n      }\n\n      map_old.clear();\n      for ( int i = 0; i < map_new.size(); i++ ) {\n\tmap_old.push_back( map_new[i] );\n      }\n      map_new.clear();\n\n    }\n\n    for ( int i = 0; i < cnt; i++ ) {\n      cout << \"myon\";\n    }\n    cout << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    field[y][n] = 1;\n    field[n][x] = 1;\n    field[n][n] = 1;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[ny][n] = 1;\n        field[n][nx] = 1;\n        if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n          field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n          ret = min(ret, calc(y, x + 1) + 1);\n          field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n        }\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    assert(ans <= 25);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif(((s>>(miny*n+minx))&1)==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tchar cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint b[7][7];\nint conv[230];\nint v;\nint solve(int a,int t){\n\tif(a==0){\n\t\tif(t==0)return 1;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<v;i++){\n\t\tif(solve(a-1,t^conv[i]))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\tfor(int i=0;i<5;i++)for(int j=i;j<5;j++)for(int k=0;k<5;k++)for(int l=k;l<5;l++){\n\t\tfor(int m=i;m<=j;m++)for(int n=k;n<=l;n++){\n\t\t\tconv[v]+=1<<(m*5+n);\n\t\t}\n\t\tv++;\n\t}\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)b[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tint at=0;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)\n\t\t\tat+=(b[i][j]<<(i*5+j));\n\t\tint ret=0;\n\t\tfor(int i=0;i<14;i++){\n\t\t\tif(solve(i,at)){\n\t\t\t\tret=i;break;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<ret;i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<vector<unsigned> > change(25);\nvector<char> memo;\n\nint solve(unsigned enemy)\n{\n    if(enemy == 0)\n        return 0;\n    if(memo[enemy] != -1)\n        return memo[enemy];\n\n    int k = 0;\n    while(!(enemy & (1 << k)))\n        ++ k;\n\n    int ret = INT_MAX;\n    for(unsigned i=0; i<change[k].size(); ++i){\n        unsigned next = enemy ^ change[k][i];\n        ret = min(ret, solve(next) + 1);\n    }\n\n    return memo[enemy] = ret;\n}\n\nint main()\n{\n    for(int i=0; i<25; ++i){\n        for(int j=i/5; j<5; ++j){\n            for(int k=i%5; k<5; ++k){\n                bitset<25> bs;\n                for(int y=i/5; y<=j; ++y){\n                    for(int x=i%5; x<=k; ++x){\n                        bs[y*5+x] = true;\n                    }\n                }\n                change[i].push_back(bs.to_ulong());\n            }\n        }\n    }\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<25> enemy;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                char tmp;\n                cin >> tmp;\n                if(tmp == '1')\n                    enemy[i*5+j] = true;\n            }\n        }\n\n        memo.assign(1<<25, -1);\n        int m = solve(enemy.to_ulong());\n        string ret;\n        while(--m >= 0)\n            ret += \"myon\";\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint n_ptn=0,ptn[150];\n\trep(i2,4) rep(i1,i2+1) rep(j2,5) rep(j1,j2+1) {\n\t\tint S=0;\n\t\tfor(int y=i1;y<=i2;y++) for(int x=j1;x<=j2;x++) S|=1<<y*5+x;\n\t\tptn[n_ptn++]=S;\n\t}\n\n\tstatic int dp[1<<20];\n\tmemset(dp,-1,sizeof dp);\n\tdp[0]=0;\n\tqueue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().first,S=Q.front().second; Q.pop();\n\t\trep(i,n_ptn) if(dp[S^ptn[i]]==-1) {\n\t\t\tdp[S^ptn[i]]=t+1;\n\t\t\tQ.push(make_pair(t+1,S^ptn[i]));\n\t\t}\n\t}\n\n\tint n_ptn2[5]={1,1,1,1,1},ptn2[5][26]={};\n\trep(i1,5) rep(j2,5) rep(j1,j2+1) {\n\t\tint S=0;\n\t\tfor(int y=i1;y<5;y++) for(int x=j1;x<=j2;x++) S|=1<<y*5+x;\n\t\tptn2[j1][n_ptn2[j1]++]=S;\n\t}\n\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint S0=0;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint a; scanf(\"%d\",&a);\n\t\t\tS0|=a<<i*5+j;\n\t\t}\n\n\t\tif(n<5){ printf(\"%d\\n\",dp[S0]); continue; }\n\n\t\tint ans=77;\n\t\trep(k0,n_ptn2[0]) rep(k1,n_ptn2[1]) rep(k2,n_ptn2[2]) rep(k3,n_ptn2[3]) rep(k4,n_ptn2[4]) {\n\t\t\tint cost=0;\n\t\t\tif(k0>0) cost++;\n\t\t\tif(k1>0) cost++;\n\t\t\tif(k2>0) cost++;\n\t\t\tif(k3>0) cost++;\n\t\t\tif(k4>0) cost++;\n\t\t\tint S=S0^ptn2[0][k0]^ptn2[1][k1]^ptn2[2][k2]^ptn2[3][k3]^ptn2[4][k4];\n\t\t\tif((S&((1<<20)-1))==S) ans=min(ans,dp[S]+cost);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  if(cur >= 2)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  rep(i,(1<<5))mincost5[i] = 100; \n  bitset<30> b(field),b2(field>>20);\n  //cout << \"b = \" << b << endl;\n  //cout << \"b2 = \" << b2 << endl;\n  mincost5[(field>>20)] = 0;\n  int ret = 5;\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename I1,typename I2>\nbool is_intersection(I1 first1,I1 last1,I2 first2,I2 last2)\n{\n\twhile(first1!=last1 && first2!=last2){\n\t\tif(*first1==*first2) return true;\n\t\t(*first1<*first2?first1:first2)++;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstatic array<int,225> ms;\n\t{\n\t\tint k=0;\n\t\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\t\tint m=0;\n\t\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\t\tms[k++]=m;\n\t\t}\n\t}\n\t\n\tstatic array<uint8_t,1<<25> ds; ds.fill(-1); ds[0]=0;\n\tfor(int i=0;count(all(ds),i);i++)\n\t\trep(j,1<<25) if(ds[j]==i)\n\t\t\tfor(int m:ms) ds[j^m]=min<uint8_t>(ds[j^m],i+1);\n\t\n\tfor(int n;cin>>n && n;){\n\t\tint x=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx|=b<<(i*5+j);\n\t\t}\n\t\tstring res;\n\t\trep(i,ds[x]) res+=\"myon\";\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\nmap<int, short> dp;\nint recur(int e, int sum, int& min_res)\n{\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = n * n;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<bool>> vii;\n//\n#include<unordered_map>\nclass HashVI {  // ???n???b???V?????????????????I???u???W???F???N???g\npublic:\n\tsize_t operator()(const vector<vector<bool>> &x) const {\n\t\tconst int C = 997;      // ???f??????\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nunordered_map<vector<vector<bool>>,int,HashVI>memo;\n\nint N; \nint solve(const vii &field){\n    if(memo.find(field)==memo.end()){\n        for(int y=0;y<field.size();++y){\n            for(int x=0;x<field[y].size();++x){\n                if(field[y][x]){\n                int ans=100;\n                    for(int xsz=1;xsz<=N-x;++xsz){\n                        for(int ysz=1;ysz<=N-y;++ysz){\n                            vii nextfield(field);\n                            for(int dy=0;dy<ysz;++dy){\n                                for(int dx=0;dx<xsz;++dx){\n                                    int nexty=y+dy;\n                                    int nextx=x+dx;\n                                    nextfield[nexty][nextx]=!nextfield[nexty][nextx];\n                                }\n                            }\n                            ans=min(ans,1+solve(nextfield));\n                        }\n                    }\n                 return memo[field]=ans;\n                }\n            }\n        }\n        return memo[field]=0;\n    }\n    return memo[field];\n}\nint main(){\n    while(true){\n        cin>>N;\n        if(!N)break;\n        memo.clear();\n        vii field(N,vector<int>(N));\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                cin>>field[i][j];\n            }\n        }\n        int ans=solve(field);\n        for(int i=0;i<ans;++i){\n            cout<<\"myon\";\n        }\n        cout<<endl;\n\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=100;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif(((s>>(miny*n+minx))&1)==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\tif(b!=0&&b!=1){\n\t\t\t\t\t\t\t\tint x=0;\n\t\t\t\t\t\t\t\t3/x;\n\t\t\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tchar cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\t\n\tfor(int n;cin>>n && n;){\n\t\tvi mask;\n\t\trep(t,n) repi(b,t,n) rep(l,n) repi(r,l,n){\n\t\t\tvvi grid(n,vi(n));\n\t\t\trepi(i,t,b+1) repi(j,l,r+1)\n\t\t\t\tgrid[i][j]=1;\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n) t|=grid[i][j]<<i*n+j;\n\t\t\tmask.push_back(t);\n\t\t}\n\t\t\n\t\tvector<bool> cur(1<<n*n);\n\t\t{\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n){\n\t\t\t\tint x; cin>>x;\n\t\t\t\tt|=x<<i*n+j;\n\t\t\t}\n\t\t\tcur[t]=1;\n\t\t}\n\t\t\n\t\tvector<bool> vis(1<<n*n);\n\t\tint res=0;\n\t\tfor(;!cur[0];res++){\n\t\t\tvector<bool> next(1<<n*n);\n\t\t\trep(i,1<<n*n) if(cur[i])\n\t\t\t\tfor(int m:mask)\n\t\t\t\t\tnext[i^m]=1;\n\t\t\tswap(cur,next);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst int INF=100000000;\n\nint dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tif( n == 4 && cnt >= 5 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tif( n <= 3 ){\n\t\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t\t}else if( n == 4 ){\n\t\t\t\tcout << s[2] << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nchar dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst int INF=100000000;\n\nint dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n        }\n    }\n    return dp[s]=res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < res; i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  //vector<bool> close(1<<(5*5), false);\n  vector<int> close((1<<(5*5))/32, 0);\n  vector<int> cls(1000000);\n  int cls_cnt=0;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(33);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[__builtin_clz(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int sz=ps.size();\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^ps[i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\tif (close[nbd>>5]&(1<<(nbd&31))) continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls_cnt; i++)\n      close[(cls[i]&0x1ffffff)>>5]=0;\n    cls_cnt=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef unsigned long long ull;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nint n;\nstruct State{\n    ull S;\n    int cost, h_cost;\n    State(ull S, int cost, int h_cost) : S(S), cost(cost), h_cost(h_cost) {\n    }\n    bool operator < (const State& S) const{\n        if(cost + h_cost != S.cost + S.h_cost) return cost + h_cost > S.cost + S.h_cost;\n        return cost > S.cost;\n    }\n};\null encode( bool b[5][5]){\n    ull res = 0;\n    REP(y, n) REP(x, n){\n        res = (res << 1) + (b[y][x] ? 1 : 0);\n    }\n    return res;\n}\nvoid decode(ull S, bool b[5][5]){\n    for(int y = n - 1; y >= 0; y--){\n        for(int x = n - 1; x >= 0; x--){\n            b[y][x] = (S & 1);\n            S = S >> 1;\n        }\n    }\n}\nint h(bool b[5][5]){\n    bool used[5][5] = {};\n    int res = 0;\n    REP(y, n) REP(x, n) if(!used[y][x] && b[y][x]){\n        res++;\n        queue<int> qx, qy;\n        qx.push(x), qy.push(y);\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4){\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && ny >= 0 && nx < n && ny < n && !used[ny][nx] && b[ny][nx]){\n                    qx.push(nx); qy.push(ny);\n                    used[ny][nx] = true;\n                }\n            }\n        }\n    }\n    return res;\n}\nint answer;\nint dfs(ull S, int cost){\n    bool b[5][5];\n    decode(S, b);\n    int h_cost = h(b);\n    if(cost + h_cost >= answer) return INF;\n    if(h_cost == 0) return answer = cost;\n    int res = INF;\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        bool b[5][5];\n        REP(y, n) REP(x, n){\n            cin >> b[y][x];\n        }\n        answer = 0;\n        priority_queue<State> que;\n        que.push(State(encode(b), 0, h(b)));\n        set<ull> used;\n        while(!que.empty()){\n            int S = que.top().S;\n            int cost = que.top().cost;\n            int h_cost = que.top().h_cost;\n            que.pop();\n            if(h_cost == 0){\n                REP(iter, cost) cout << \"myon\";\n                cout << endl;\n                break;\n            }\n            bool b[5][5]; decode(S, b);\n            for(int y0 = 0; y0 < n; y0++)\n            for(int y1 = y0; y1 < n; y1++)\n            for(int x0 = 0; x0 < n; x0++)\n            for(int x1 = x0; x1 < n; x1++){\n                for(int y = y0; y <= y1; y++)\n                for(int x = x0; x <= x1; x++){\n                    b[y][x] = (b[y][x] ? false : true);\n                }\n                ull NS = encode(b);\n                if(!used.count(NS)){\n                    used.insert(NS);\n                    que.push(State(NS, cost + 1, h(b)));\n                }\n                for(int y = y0; y <= y1; y++)\n                for(int x = x0; x <= x1; x++){\n                    b[y][x] = (b[y][x] ? false : true);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\t//if( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 1000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\t\n\t\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tif( cnt >= 2 ){\n\t\treturn cnt;\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\treturn dfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ 4 ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ 5 ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define calc __builtin_popcount\nusing namespace std;\nint n,G[5][5],ans;\nvector<int>move[30];\nint H(int sta,int k){\n\treturn (calc(sta)+k-1)/k;\t\n}\nint Q[50];\nvoid show(int sta){\n\tfor(int r=0;r<n;r++){\n\t\tfor(int c=0;c<n;c++)\n\t\t\tputchar((sta&(1<<(r*n+c)))?'1':'0');\n\t\tputs(\"\");\n\t}\n\tputs(\"----\");\n}\nvoid DFS(int dep,int k,int sta,int last){\n\tif(k==0)return;\n\tQ[dep]=sta;\n\tif(dep+H(sta,k)>ans)return;\n\tif(sta==0){\n\t\tans=dep;\n\t\t/*printf(\"ans:%d\\n\",ans);\n\t\tfor(int i=0;i<dep;i++){\n\t\t\tshow(Q[i]);\n\t\t}*/\n\t\treturn;\n\t}\n\tfor(int i=last;i<move[k].size();i++){\n\t\tDFS(dep+1,k,sta^move[k][i],i);\n\t}\n\tDFS(dep,k-1,sta,0);\n}\nvoid init(){\n\tfor(int r=1;r<=n;r++)\n\tfor(int c=1;c<=n;c++){\n\t\tfor(int i=0;i+r-1<n;i++)\n\t\tfor(int j=0;j+c-1<n;j++){\n\t\t\tint sta=0;\n\t\t\tfor(int y=i;y<i+r;y++)\n\t\t\tfor(int x=j;x<j+c;x++)\n\t\t\t\tsta^=(1<<(y*n+x));\n\t\t\tmove[r*c].push_back(sta);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<=n*n;i++)move[i].clear();\n\t\tinit();\n\t\tint sta=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t\t\tif(G[i][j])sta^=(1<<(i*n+j));\n\t\t\t}\n\t\tans=calc(sta);\n\t\tDFS(0,n*n,sta,0);\n\t\tfor(int i=0;i<ans;i++)printf(\"myon\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 20000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( cnt >= 4 ){\n\t\treturn cnt;\n\t}\n\t\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\treturn dfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\nint n;\nint xor_mask[5][5][5][5];\nchar dp[1 << 25];\nint recur(int e)\n{\n    if (e == 0)\n        return 0;\n    else if (dp[e])\n        return dp[e];\n\n    for (int y = 0; y < n; ++y)\n    {\n        for (int x = 0; x < n; ++x)\n        {\n            if (e >> (y * size + x) & 1)\n            {\n                int res = 1 << 29;\n                for (int yy = y; yy < n; ++yy)\n                    for (int xx = x; xx < n; ++xx)\n                        min_swap(res, recur(e ^ xor_mask[y][x][yy][xx]) + 1);\n                return dp[e] = res;\n            }\n        }\n    }\n\n    puts(\"akan\");\n    exit(1);\n}\nint main()\n{\n    for (int y1 = 0; y1 < size; ++y1)\n    {\n        for (int x1 = 0; x1 < size; ++x1)\n        {\n            for (int y2 = y1; y2 < size; ++y2)\n            {\n                for (int x2 = x1; x2 < size; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = size - 1; y >= 0; --y)\n                        for (int x = size - 1; x >= 0; --x)\n                            mask = (mask << 1) | (x1 <= x && x <= x2 && y1 <= y && y <= y2);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int times = recur(enc(f));\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    field[y][n] = 1;\n    field[n][x] = 1;\n    field[n][n] = 1;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[ny][n] = 1;\n        field[n][nx] = 1;\n        if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n          field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n          ret = min(ret, calc(y, x + 1) + 1);\n          field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n        }\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  static int close[(1<<(5*5))/32];\n  static int cls[1000000];\n\n  for (int n; scanf(\"%d\", &n), !(n==0); ){\n    static int pats[33][32];\n    int pats_cnt[33]={};\n    static int tmp[5][5];\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    int ix=__builtin_clz(bd);\n\t    pats[ix][pats_cnt[ix]++]=bd;\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; scanf(\"%d\", &t);\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    int cls_cnt=0, cls_cur=0;\n    close[bd>>5]|=(1<<(bd&31));\n    cls[cls_cnt++]=bd;\n    for (;;){\n      int dep=cls[cls_cur]>>25;\n      int cbd=cls[cls_cur]&0x1ffffff;\n      cls_cur++;\n      //const vector<int> &ps=pats[__builtin_clz(cbd)];\n      int ix=__builtin_clz(cbd);\n      int sz=pats_cnt[ix];\n      for (int i=0; i<sz; i++){\n\tint nbd=cbd^pats[ix][i];\n\tif (close[nbd>>5]&(1<<(nbd&31)))\n\t  continue;\n\tclose[nbd>>5]|=(1<<(nbd&31));\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    printf(\"myon\");\n\t  puts(\"\");\n\t  goto _exit;\n\t}\n\tcls[cls_cnt++]=((dep+1)<<25)|nbd;\n      }\n    }\n  _exit:;\n    {\n      int i=0;\n      for (; i+3<cls_cnt; i+=4){\n\tclose[(cls[i+0]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+1]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+2]&0x1ffffff)>>5]=0;\n\tclose[(cls[i+3]&0x1ffffff)>>5]=0;\n      }\n      for (; i<cls_cnt; i++)\n\tclose[(cls[i]&0x1ffffff)>>5]=0;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6][6];\nint n;\nint solve(int p,int q,int t){\n\tif(t==0){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(c[i][j])return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t);\n\tif(!c[p][q])return solve(p,q+1,t);\n\tfor(int h=n-1;h>=q;h--){\n\t\tfor(int i=p;i<n;i++){\n\t\t\tfor(int j=q;j<=h;j++)c[i][j]^=1;\n\t\t\tif(solve(p,q+1,t-1))return 1;\n\t\t}\n\t\tfor(int i=p;i<n;i++)for(int j=q;j<=h;j++)c[i][j]^=1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=1;;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++)c[j][k]=b[j][k];\n\t\t\tif(solve(0,0,i)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=100;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\tif(!((s>>(miny*n+minx))&1))\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tchar cnt;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\t//scanf(\"%d\",&bit);\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=minStep(init,0);\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar memo[1<<20];\nint n;\n\nint main(){\n  {\n    queue<int> q;\n    int cost = 0;\n    q.push(-1);\n    q.push(0);\n    memo[0] = 1;\n\n    while(q.size() != 1){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        //printf(\"cost = %d, size = %d\\n\",cost,q.size());\n        continue;\n      }\n\n      //printf(\"state: %x\\n\",state);\n\n      for(int xs = 0; xs < 5; xs++){\n        for(int xe = xs+1; xe <= 5; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys =  0; ys < 4; ys++){\n            int next = state;\n            for(int ye = ys; ye < 4; ye++){\n              next ^= mask << (ye * 5);\n              if(!memo[next]){\n                q.push(next);\n                memo[next] = cost+1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  while(n = getInt()){\n    int ss = 0;\n    REP(i,n) REP(j,n){\n      int t = getInt();\n      ss |= (t << (j + i*5));\n    }\n\n    queue<int> q;\n    int cost = 0;\n    const int mm = ((1<<25)-1) ^ ((1<<20)-1);\n    set<int> f;\n    q.push(ss);\n    f.insert(ss);\n    q.push(-1);\n\n    int ans = INT_MAX;\n    while(q.size() != 1){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        //printf(\"cost = %d, size = %d\\n\",cost,q.size());\n        if(cost > ans) break;\n        continue;\n      }\n\n      if((state & mm) == 0){\n        ans = min(ans, cost + memo[state] - 1);\n      }\n\n      for(int xs = 0; xs < 5; xs++){\n        for(int xe = xs+1; xe <= 5; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys =  0; ys < 5; ys++){\n            int next = state;\n            for(int ye = ys; ye < 5; ye++){\n              next ^= mask << (ye * 5);\n              if(ye == 4 && !f.count(next)){\n                f.insert(next);\n                q.push(next);\n              }\n            }\n          }\n        }\n      }\n    }\n    while(ans --> 0) printf(\"myon\");\n    puts(\"\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tif( n <= 3 ){\n\t\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t\t}else if( n == 4 ){\n\t\t\t\tcout << s[2] << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n < 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6][6];\nint n;\nint solve(int p,int q,int t){\n\tif(t==0){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(c[i][j])return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t);\n\tif(!c[p][q])return solve(p,q+1,t);\n\tint r=q;\n\tfor(int i=q;i<n;i++){\n\t\tif(c[p][i])r=i;\n\t\telse break;\n\t}\n\tr++;\n\tfor(int h=n-1;h>=0;h--){\n\t\tfor(int i=p;i<n;i++){\n\t\t\tfor(int j=q;j<=h;j++)c[i][j]^=1;\n\t\t\tif(solve(p,q+1,t-1))return 1;\n\t\t}\n\t\tfor(int i=p;i<n;i++)for(int j=q;j<=h;j++)c[i][j]^=1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=1;;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++)c[j][k]=b[j][k];\n\t\t\tif(solve(0,0,i)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\tif(depth>mC)\n\t\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\tif(s==start){\n\t\t\t\t\t\t\t\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\tif(s==start){\n\t\t\t\t\t\t\t\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\t//fill(dp,dp+(1<<25),-1);\n\tmemset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    fill(close.begin(), close.begin()+(1<<(n*n)), false);\n    /*\n    for (int i=0; i<(n*n); i++)\n      close[i]=false;\n    */\n\n    queue<pair<int, int> > mm;\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){\n\t\tx = x_;\n\t\ty = y_;\n\t};\n};\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<int> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,int> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,int> > q;\n\tq.push( pair<int,int>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,int> > q;\n\tq.push( pair<int,int>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tint cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( cnt >= 3 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<int> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<int> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<int> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<int> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t\n\t// cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t// cout << \"input\" << endl;\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << dp[n-1][bits] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint res;\nbool used_left[5], used_right[5];\nvoid dfs(int e, int c, int depth)\n{\n    if (depth >= 5 || c >= res /* この枝狩りは申し訳程度の高速化 */)\n        return;\n    else if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    for (int left = 0; left < 5; ++left)\n    {\n        if (!used_left[left])\n        {\n            used_left[left] = true;\n\n            for (int right = left; right < 5; ++right)\n            {\n                if (!used_right[right])\n                {\n                    used_right[right] = true;\n\n                    for (int y = 0; y < 5; ++y)\n                        dfs(e ^ xor_mask[y][left][4][right], c + 1, depth + 1);\n\n                    used_right[right] = false;\n                }\n            }\n\n            used_left[left] = false;\n        }\n    }\n}\nint main()\n{\n    fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        const int first_row = ((1 << 5) - 1);\n        while (!(e & first_row) && e)\n            e >>= 5;\n\n        res = 25;\n        dfs(e, 0, 0);\n        cout << myon[res] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX_N (5)\nint n;\nchar memo[1<<25];\nint sq[6][6];\nint dfs(int bit){\n\tif(~memo[bit]) { return memo[bit];}\n\tint ans = (1<<25);\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( bit >> (i*MAX_N+j) & 1){\n\t\t\t\tfor(int s1 = 1 ; s1 <= n-i ; s1++)\n\t\t\t\t\tfor(int s2 = 1 ; s2 <= n-j ; s2++)\n\t\t\t\t\t\tans = min( ans , 1 + dfs( bit ^ (sq[s1][s2] << (i*MAX_N+j) ) ) );\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t}\n\t}\n\treturn memo[bit] = ans;\n}\nint gen(int x,int y){\n\tint ans = 0;\n\tfor(int i = 0 ; i < y ; i++)\n\t\tfor(int j = 0 ; j < x ; j++)\n\t\t\tans |= 1<< (i*MAX_N+j);\n\treturn ans;\n}\nint main(){\n\tfor(int i = 1 ; i <= 5 ; i++)for(int j = 1 ; j <= 5 ; j++) sq[i][j] = gen(j,i);\n\tmemset(memo,-1,sizeof(memo));\n\tmemo[0] = 0;\n\t\n\twhile(cin >> n , n){\n\t\tint bit = 0 , a;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tcin >> a , bit |= a << (i * MAX_N + j);\n\t\tint r = dfs(bit);\n\t\tfor(int i = 0 ; i < r ; i++)\n\t\t\tcout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=100;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\tif(!((s>>(miny*n+minx))&1))\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\tchar cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tcnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint n;\n\nstruct State {\n    int step, g;\n    State(int step, int g)\n        :step(step), g(g){}\n\n    void flip(int x, int y, int w, int h){\n        int t = (((1 << w) - 1) << x);\n        rep(i, h){\n            g ^= t << (n*(i + y));\n        }\n    }\n\n    void print(){\n        rep(i, n){\n            rep(j, n){\n                cout << ((g >> (i*n + j)) & 1);\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main(){\n    while (cin >> n && n){\n        State init(0, 0);\n        rep(i, n)rep(j, n){\n            int x; cin >> x;\n            if (x)init.flip(j, i, 1, 1);\n        }\n        queue<State> q;\n        q.push(init);\n        static bool vis[1 << 25];\n        memset(vis, 0, sizeof(vis));\n        vis[init.g] = true;\n        int res = -1;\n        while (q.size()){\n            State s = q.front();\n            q.pop();\n            if (s.g == 0) {\n                res = s.step;\n                break;\n            }\n            vis[s.g] = true;\n            rep(i, n){\n                rep(j, n){\n                    if ((s.g >> (i*n + j)) & 1){\n                        rep(h, n - i){\n                            rep(w, n - j){\n                                s.flip(j, i, w + 1, h + 1);\n                                s.step++;\n                                if (!vis[s.g]) q.push(s);\n                                s.flip(j, i, w + 1, h + 1);\n                                s.step--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        rep(i, res)cout << \"myon\";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool flag[1<<25];\n\nlong long int change( int x, int y, int n ) {\n  if ( x < 0 || y < 0 || x >= n || y >= n ) return 0;\n  return 1<<(x+y*n);\n}\n\nint main() {\n\n  while(true) {\n\n    int n,input;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    for ( int i = 0; i < ( 1<<(n*n) ); i++ ) {\n      flag[i] = false;\n    }\n\n    //next[x_length][y_length]\n    long long int next[5][5];\n    int line = 0;\n    for ( int x = 0; x < n; x++ ) {\n      line = (line<<1) + 1;\n      long long int map = line;\n      for ( int y = 0; y < n; y++ ) {\n\tnext[x][y] = map;\n\tmap = (map << n) + line;\n      }\n    }\n\n    long long int map = 0;\n    for ( int i = 0; i < n; i++ ) {\n      for ( int j = 0; j < n; j++ ) {\n\tcin >> input;\n\tmap = ( map<<1 ) + input;\n      }\n    }\n    flag[map] = true;\n    vector<long long int> map_old;\n    vector<long long int> map_new;\n    map_old.push_back(map);\n\n    int cnt = 0;\n\n    while(true) {\n      cnt++;\n\n      for ( int i = 0; i < map_old.size(); i++ ) {\n\tfor ( int x = 0; x < n; x++ ) {\n\t  for ( int y = 0; y < n; y++ ) {\n\t    if ( ( map_old[i] & change(x,y,n) ) == 0 || ( map_old[i] & change(x-1,y,n) ) != 0 || ( map_old[i] & change(x,y-1,n) ) != 0 ) continue;\n\n\t    for ( int x_l = 0; x_l < n-x; x_l++ ) {\n\t      for ( int y_l = 0; y_l < n-y; y_l++ ) {\n\t\tlong long int m = ( map_old[i] ^ ( next[x_l][y_l]<<( x+y*n ) ) );\n\t\tif ( flag[ m ] == false ) {\n\t\t  map_new.push_back( m );\n\t\t  flag[ m ] = true;\n\t\t}\n\t      }\n\t    }\n\n\t  }\n\t}\n      }\n\n      if ( flag[0] ) break;\n      if ( cnt > 50 ) {\n\tcout << \"error\" << endl;\n\tcnt = 0;\n\tbreak;\n      }\n\n      map_old.clear();\n      for ( int i = 0; i < map_new.size(); i++ ) {\n\tmap_old.push_back( map_new[i] );\n      }\n      map_new.clear();\n\n    }\n\n    for ( int i = 0; i < cnt; i++ ) {\n      cout << \"myon\";\n    }\n    cout << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[5][5];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint calc(int y, int x) {\n  if (x == n) { return calc(y + 1, 0); }\n  if (y == n) { return 0; }\n  if (field[y][x] == 0) { return calc(y, x + 1); }\n  int ret = calc(y, x + 1) + 1;\n  FOR(ny, y + 1, n) {\n    FOR(nx, x + 1, n) {\n      if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n        field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n        ret = min(ret, calc(y, x + 1) + 1);\n        field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nint MIN_ANS;\nset<int> used;\nint dfs(int s, int c){\n  if(s == 0) return c;\n  if(c >= MIN_ANS) return INF;\n  if(used.count(s)) return INF;\n  used.insert(s);\n  int res = INF;\n  int next[6][6][6][6] = {};\n  REP(y, N) REP(x, N) next[y][y][x][x] = s;\n  // [y1][y2][x1][x2] = [y1][y2][x1][x2 - 1] ^ [y1][y2 - 1][x1][x2] - [y1][y2 - 1][x1][x2 - 1]\n  for(int y1 = 0; y1 < N; y1++){\n    for(int x1 = 0; x1 < N; x1++){\n      for(int y2 = y1 + 1; y2 <= N; y2++){\n        for(int x2 = x1 + 1; x2 <= N; x2++){\n          next[y1][y2][x1][x2] = next[y1][y2][x1][x2 - 1] ^ \n            next[y1][y2 - 1][x1][x2] ^\n            next[y1][y2 - 1][x1][x2 - 1] ^ \n            (1 << ((y2 - 1) * N + (x2 - 1)));\n          int ns = next[y1][y2][x1][x2];\n          res = min(res, dfs(ns, c + 1));\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> N && N){\n    int start = 0;\n    REP(i, N * N){\n      int t;\n      cin >> t;\n      start |= t << i;\n    }\n    int ans = INF;\n    MIN_ANS = 0;\n    while(true){\n      used.clear();\n      ans = dfs(start, 0);\n      if(ans < INF){\n        break;\n      }else{\n        MIN_ANS ++;\n      }\n    }\n    string myon = \"myon\";\n    REP(i, ans) cout << myon;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 20000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( cnt >= 2 ){\n\t\treturn cnt;\n\t}\n\t\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\treturn dfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nstring solve(bitset<25> enemy)\n{\n    map<int, int> curr;\n    curr.insert(make_pair(enemy.to_ulong(), 0));\n\n    for(int i=0; i<25; ++i){\n        vector<int> change;\n        for(int j=i/5; j<5; ++j){\n            for(int k=i%5; k<5; ++k){\n                bitset<25> bs;\n                for(int y=i/5; y<=j; ++y){\n                    for(int x=i%5; x<=k; ++x){\n                        bs[y*5+x] = true;\n                    }\n                }\n                change.push_back(bs.to_ulong());\n            }\n        }\n\n        map<int, int> next;\n        map<int, int>::iterator it;\n        for(it=curr.begin(); it!=curr.end(); ++it){\n            bitset<25> bs = it->first;\n            int cost = it->second;\n            if(bs[i] == false){\n                map<int, int>::iterator it1 = next.find(bs.to_ulong());\n                if(it1 == next.end())\n                    next.insert(make_pair(bs.to_ulong(), cost));\n                else if(cost < it1->second)\n                    it1->second = cost;\n            }else{\n                for(unsigned j=0; j<change.size(); ++j){\n                    bitset<25> bs1 = bs;\n                    bs1 ^= change[j];\n                    map<int, int>::iterator it1 = next.find(bs1.to_ulong());\n                    if(it1 == next.end())\n                        next.insert(make_pair(bs1.to_ulong(), cost + 1));\n                    else if(cost + 1 < it1->second)\n                        it1->second = cost + 1;\n                }\n            }\n        }\n        curr = next;\n    }\n\n    int num = curr[0];\n    string ret;\n    for(int i=0; i<num; ++i)\n        ret += \"myon\";\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        bitset<25> bs;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                char tmp;\n                cin >> tmp;\n                if(tmp == '1')\n                    bs[i*5+j] = true;\n            }\n        }\n        cout << solve(bs) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\nint bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ bfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<int>> vii;\n//\n#include<unordered_map>\nclass HashVI {  // ???n???b???V?????????????????I???u???W???F???N???g\npublic:\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ???f??????\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nunordered_map<vector<vector<int>>,int,HashVI>memo;\n\nint N; \nint solve(const vii &field){\n    if(memo.find(field)==memo.end()){\n        for(int y=0;y<field.size();++y){\n            for(int x=0;x<field[y].size();++x){\n                if(field[y][x]){\n                int ans=100;\n                    for(int xsz=1;xsz<=N-x;++xsz){\n                        for(int ysz=1;ysz<=N-y;++ysz){\n                            vii nextfield(field);\n                            for(int dy=0;dy<ysz;++dy){\n                                for(int dx=0;dx<xsz;++dx){\n                                    int nexty=y+dy;\n                                    int nextx=x+dx;\n                                    nextfield[nexty][nextx]=!nextfield[nexty][nextx];\n                                }\n                            }\n                            ans=min(ans,1+solve(nextfield));\n                        }\n                    }\n                 return memo[field]=ans;\n                }\n            }\n        }\n        return memo[field]=0;\n    }\n    return memo[field];\n}\nint main(){\n    while(true){\n        cin>>N;\n        if(!N)break;\n        vii field(N,vector<int>(N));\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                cin>>field[i][j];\n            }\n        }\n        int ans=solve(field);\n        for(int i=0;i<ans;++i){\n            cout<<\"myon\";\n        }\n        cout<<endl;\n\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint b[7][7];\nint conv[230];\nchar dp[1<<25];\nint v;\nint solve(int a,int t){\n\tif(~dp[a])return dp[a];\n\tif(a==0){return dp[a]=0;}\n\tif(t==0)return 1;\n\tint ret=99999;\n\tfor(int i=0;i<v;i++){\n\t\tret=min(ret,solve(a^conv[i],t-1)+1);\n\t}\n\treturn dp[a]=ret;\n}\nint main(){\n\tint a;\n\tfor(int i=0;i<(1<<25);i++)dp[i]=-1;\n\tfor(int i=0;i<5;i++)for(int j=i;j<5;j++)for(int k=0;k<5;k++)for(int l=k;l<5;l++){\n\t\tfor(int m=i;m<=j;m++)for(int n=k;n<=l;n++){\n\t\t\tconv[v]+=1<<(m*5+n);\n\t\t}\n\t\tv++;\n\t}\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)b[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tint at=0;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)\n\t\t\tat+=(b[i][j]<<(i*5+j));\n\t\tint ret=0;\n\t\tret=solve(at,13);\n\t\tfor(int i=0;i<ret;i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<vector<int>> vii;\n//\n\n    int h(const vector<vector<int>> &x) {\n        const int C = 997;      // ???f??????\n        size_t t = 0;\n        for (int i = 0; i != x.size(); ++i) {\n            for (int j = 0; j < x[i].size(); ++j) {\n                t = t * 2 + x[i][j];\n            }\n        }\n        return t;\n    }\n\nvector<map<int,int>>memo(6);\n \nint N; \nint solve(const vii &field){\n    if(memo[field.size()].find(h(field))==memo[field.size()].end()){\n        for(int y=0;y<field.size();++y){\n            for(int x=0;x<field[y].size();++x){\n                if(field[y][x]){\n                int ans=100;\n                    for(int xsz=1;xsz<=N-x;++xsz){\n                        for(int ysz=1;ysz<=N-y;++ysz){\n                            vii nextfield(field);\n                            for(int dy=0;dy<ysz;++dy){\n                                for(int dx=0;dx<xsz;++dx){\n                                    int nexty=y+dy;\n                                    int nextx=x+dx;\n                                    nextfield[nexty][nextx]=!nextfield[nexty][nextx];\n                                }\n                            }\n                            ans=min(ans,1+solve(nextfield));\n                        }\n                    }\n                 return memo[field.size()][h(field)]=ans;\n                }\n            }\n        }\n        return memo[field.size()][h(field)]=0;\n    }\n    return memo[field.size()][h(field)];\n}\nint main(){\n    while(true){\n        cin>>N;\n        if(!N)break;\n        vii field(N,vector<int>(N));\n        for(int i=0;i<N;++i){\n            for(int j=0;j<N;++j){\n                cin>>field[i][j];\n            }\n        }\n        int ans=solve(field);\n        for(int i=0;i<ans;++i){\n            cout<<\"myon\";\n        }\n        cout<<endl;\n \n    }\n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\t\n\tfor(int n;cin>>n && n;){\n\t\tvi mask;\n\t\trep(t,n) repi(b,t,n) rep(l,n) repi(r,l,n){\n\t\t\tvvi grid(n,vi(n));\n\t\t\trepi(i,t,b+1) repi(j,l,r+1)\n\t\t\t\tgrid[i][j]=1;\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n) t|=grid[i][j]<<i*n+j;\n\t\t\tmask.push_back(t);\n\t\t}\n\t\t\n\t\tvector<bool> vis1(1<<n*n);\n\t\t{\n\t\t\tint t=0;\n\t\t\trep(i,n) rep(j,n){\n\t\t\t\tint x; cin>>x;\n\t\t\t\tt|=x<<i*n+j;\n\t\t\t}\n\t\t\tvis1[t]=1;\n\t\t}\n\t\tvector<bool> vis2(1<<n*n);\n\t\tvis2[0]=1;\n\t\t\n\t\tint res=0;\n\t\tfor(;;res++){\n\t\t\tbool ok=false;\n\t\t\trep(i,1<<n*n) ok|=vis1[i]&&vis2[i];\n\t\t\tif(ok) break;\n\t\t\t\n\t\t\tvector<bool>& vis=res%2==0?vis1:vis2;\n\t\t\tvector<bool> tmp(1<<n*n);\n\t\t\trep(i,1<<n*n) if(vis[i]) for(int m:mask) tmp[i^m]=1;\n\t\t\tswap(vis,tmp);\n\t\t}\n\t\trep(i,res) printf(\"myon\"); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nchar dp[1<<25];\n//int minArrivingDepth[1<<25];\n\nint n;\nconst char INF=100;\n\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\tif(minCnt==1){\n\t\t\t\t\t\tdp[s]=minCnt;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(cin>>n&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nvoid p(int e)\n{\n    for (int y = 0; y < 5; ++y)\n    {\n        for (int x = 0; x < 5; ++x)\n            printf(\"%d \", e >> (5 * y + x) & 1);\n        puts(\"\");\n    }\n    puts(\"\");\n}\n\n\nbool enemy(int e, int x, int y)\n{\n    return e >> (5 * y + x) & 1;\n}\nint xor_mask[5][5][5][5];\nint cost[1 << 20]; /// 4 rows * 5 cols\nvoid pre()\n{\n    // myon mask\n    for (int y1 = 0; y1 < 5; ++y1)\n    {\n        for (int x1 = 0; x1 < 5; ++x1)\n        {\n            for (int y2 = y1; y2 < 5; ++y2)\n            {\n                for (int x2 = x1; x2 < 5; ++x2)\n                {\n                    int mask = 0;\n                    for (int y = y1; y <= y2; ++y)\n                        for (int x = x1; x <= x2; ++x)\n                            mask |= 1 << (5 * y + x);\n                    xor_mask[y1][x1][y2][x2] = mask;\n                }\n            }\n        }\n    }\n\n    // bfs\n    CL(cost, -1);\n    queue<int> q;\n    cost[0] = 0;\n    q.push(0);\n    while (!q.empty())\n    {\n        int cur = q.front();\n        int ncost = cost[cur] + 1;\n        q.pop();\n\n        for (int y1 = 0; y1 < 4; ++y1)\n        {\n            for (int x1 = 0; x1 < 5; ++x1)\n            {\n                for (int y2 = y1; y2 < 4; ++y2)\n                {\n                    for (int x2 = x1; x2 < 5; ++x2)\n                    {\n                        int next = cur ^ xor_mask[y1][x1][y2][x2];\n                        if (cost[next] == -1)\n                        {\n                            cost[next] = ncost;\n                            q.push(next);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint res;\nbool used_left[5], used_right[5];\nvoid dfs(int e, int c, int depth)\n{\n    if (depth >= 5 || c >= res)\n        return;\n    else if (e < (1 << 20))\n    {\n        min_swap(res, c + cost[e]);\n        return;\n    }\n\n    for (int left = 0; left < 5; ++left)\n    {\n        if (!used_left[left])\n        {\n            used_left[left] = true;\n\n            for (int right = left; right < 5; ++right)\n            {\n                if (!used_right[right])\n                {\n                    used_right[right] = true;\n\n                    for (int y = 0; y < 5; ++y)\n                        dfs(e ^ xor_mask[y][left][4][right], c + 1, depth + 1);\n\n                    used_right[right] = false;\n                }\n            }\n\n            used_left[left] = false;\n        }\n    }\n\n    dfs(e, c, depth + 1);\n}\nint main()\n{\n    fast_io();\n    pre();\n\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 30; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    int n;\n    while (cin >> n, n)\n    {\n        int e = 0;\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                e |= t << (y * 5 + x);\n            }\n        }\n\n        // shift upward if no enemies in 1st row\n        const int first_row = ((1 << 5) - 1);\n        while (!(e & first_row) && e)\n            e >>= 5;\n\n        res = 25;\n        dfs(e, 0, 0);\n        cout << myon[res] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std; \nstruct point{\n\tint x1;\n\tint y1;\n}p[2];\nint a[8][8],n;\nvoid pd1(){\n\tint i,j;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(a[i][j]==1) break;}\n\t\tif(j<=n) break;\n\t}\n    p[0].x1=i;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(a[j][i]==1)  break;}\n\t\tif(j<=n) break;\n\t}\n\tp[0].y1=i;\n}\nvoid pd2(){\n\tint i,j;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(a[i][j]==1) break;\n             if(j>=1) break;\n\t}\n    p[1].x1=i;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=n;j>=1;j--)\n\t\t\tif(a[j][i]==1) break;\n  if(j>=1) break;\n\t}\n\tp[1].y1=i;\n}\nvoid change(point q1,point q2){\n\tint i,j;\n\tfor(i=q1.x1+1;i<q2.x1;i++)\n\t\tfor(j=q1.y1+1;j<q2.y1;j++){\n\t\t\tif(a[i][j]==1) a[i][j]=0;\n\t\t\telse a[i][j]=1;\n\t\t}\n}\nvoid clear(point q1,point q2){\n\t  int i;\n\t for(i=q1.x1;i<=q2.x1;i++)\n\t\t a[i][q1.y1]=a[i][q2.y1]=0;\n     for(i=q1.y1;i<=q2.y1;i++)\n\t\t a[q1.x1][i]=a[q2.x1][i]=0;\n}\nint main()\n{\n\tint i,j;\n\twhile(cin>>n&&n){\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=1;j<=n;j++)\n\t                 cin>>a[i][j];\n\t    int count=0;\n\twhile(1){\n\t    pd1();\n\t\tif(p[0].x1==n+1) break;\n\t\tcount++;\n\t\tpd2();\n\t\tif(p[0].x1==p[1].x1||p[0].y1==p[1].y1) break;\n\t\tchange(p[0],p[1]);\n        clear(p[0],p[1]);\n\t}\t \n\tfor(i=1;i<count;i++)\n\t      cout<<\"myon\";\n     if(count)cout<<\"myon\"<<endl;\n\t}\t    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    vector<int> cls;\n    //cls.reserve(1<<16);\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    cls.push_back(bd);\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls.push_back(nbd);\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls.size(); i++)\n      close[cls[i]]=false;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint dp[1<<5][1<<5][1<<5][1<<5][1<<5];\nbool passed[1<<5][1<<5][1<<5][1<<5][1<<5];\n\nint n;\nint field[5][5];\n\t\nconst int INF=1000000;\n\nint dfs(int s1,int s2,int s3,int s4,int s5){\n\tif(!s1&&!s2&&!s3&&!s4&&!s5){\n\t\treturn 0;\n\t}\n\tif(dp[s1][s2][s3][s4][s5]!=0)\n\t\treturn dp[s1][s2][s3][s4][s5];\n\n\tint minRet=INF;\n\t\n\t// é`¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx= 0; minx < n; minx++){\n\t\t\t// é`EºÌÀW\n\t\t\tfor(int maxy = miny; maxy < n; maxy++){\n\t\t\t\tfor(int maxx = minx; maxx < n; maxx++){\n\t\t\t\t\tint ns[5];\n\t\t\t\t\tns[0] = s1;\n\t\t\t\t\tns[1] = s2;\n\t\t\t\t\tns[2] = s3;\n\t\t\t\t\tns[3] = s4;\n\t\t\t\t\tns[4] = s5;\n\t\t\t\t\t// èµ½ÍÍÌrbgð½]·é\n\t\t\t\t\tfor(int i = miny; i <= maxy; i++){\n\t\t\t\t\t\tfor(int j = minx; j <= maxx; j++){\n\t\t\t\t\t\t\tif(((ns[i] >> j) & 1)){\n\t\t\t\t\t\t\t\tns[i] &= ~(1 << j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tns[i] |= (1<<j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÄA\n\t\t\t\t\tif(passed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpassed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]]=true;\n\t\t\t\t\tif(ns[0]==0){\n\t\t\t\t\t//\tcout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tminRet=min(minRet,1+dfs(ns[0],ns[1],ns[2],ns[3],ns[4]));\n\t\t\t\t\tpassed[ns[0]][ns[1]][ns[2]][ns[3]][ns[4]]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[s1][s2][s3][s4][s5]=minRet;\n\treturn minRet;\n\t//if(n==1){\n\t//\treturn 1;\n\t//}\n\t//else if(n==2){\n\t//\treturn 1;\n\t//}\n\t//else if(n==3){\n\t//\tif(s1==0&&s2==0&&s3==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][0][0]!=INF)\n\t//\t\treturn dp[s1][s2][s3][0][0];\n\t//\t// ñÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\t\n\t//\tfor(int i = 0; i < 3; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,0,0));\n\t//\tns1=s1;ns2=s2;ns3=s3;\n\t//\tfor(int i = 0; i < 3; i++){\n\t//\t\tif(i == 1){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,0,0));\n\t//\tdp[s1][s2][s3][0][0]=minRet;\n\t//\treturn minRet;\n\t//}\n\t//else if(n==4){\n\t//\tif(s1==0&&s2==0&&s3==0&&s4==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][s4][0]!=INF)\n\t//\t\treturn dp[s1][s2][s3][s4][0];\n\t//\t// ñÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\tint ns4 = s4;\n\t//\t\n\t//\tfor(int i = 0; i < 4; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s4 >> i) & 1)){\n\t//\t\t\tns4 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns4 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,0));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;\n\t//\tfor(int i = 0; i < 4; i++){\n\t//\t\tif(i == 1 || i == 2){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,0));\n\t//\tdp[s1][s2][s3][ns4][0]=minRet;\n\t//\treturn minRet;\n\t//}\n\t//else if(n==5){\n\t//\tif(s1==0&&s2==0&&s3==0&&s4==0&&s5==0)\n\t//\t\treturn 0;\n\t//\tif(dp[s1][s2][s3][s4][s5]!=INF)\n\t//\t\treturn dp[s1][s2][s3][s4][s5];\n\t//\t// OÊèÌû@ª é\n\t//\tint ns1 = s1;\n\t//\tint ns2 = s2;\n\t//\tint ns3 = s3;\n\t//\tint ns4 = s4;\n\t//\tint ns5 = s5;\n\t//\t\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(((s1 >> i) & 1)){\n\t//\t\t\tns1 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns1 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s2 >> i) & 1)){\n\t//\t\t\tns2 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns2 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s3 >> i) & 1)){\n\t//\t\t\tns3 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns3 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s4 >> i) & 1)){\n\t//\t\t\tns4 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns4 |= (1<<i);\n\t//\t\t}\n\t//\t\tif(((s5 >> i) & 1)){\n\t//\t\t\tns5 &= ~(1 << i);\n\t//\t\t}\n\t//\t\telse{\n\t//\t\t\tns5 |= (1<<i);\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;ns5=s5;\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(i != 0 && i != 4){\n\t//\t\t\tif(((s2 >> i) & 1)){\n\t//\t\t\t\tns2 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns2 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t\tif(((s4 >> i) & 1)){\n\t//\t\t\t\tns4 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns4 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t\tif(i == 1 || i == 3 || i == 2){\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tns1=s1;ns2=s2;ns3=s3;ns4=s4;ns5=s5;\n\t//\tfor(int i = 0; i < 5; i++){\n\t//\t\tif(i == 2){\n\t//\t\t\tif(((s3 >> i) & 1)){\n\t//\t\t\t\tns3 &= ~(1 << i);\n\t//\t\t\t}\n\t//\t\t\telse{\n\t//\t\t\t\tns3 |= (1<<i);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tminRet=min(minRet,1+dfs(ns1,ns2,ns3,ns4,ns5));\n\t//\tdp[s1][s2][s3][ns4][ns5]=minRet;\n\t//\treturn minRet;\n\t//}\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\n\t\tint s[5];\n\t\ts[0]=s[1]=s[2]=s[3]=s[4]=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]){\n\t\t\t\t\ts[i] |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(passed,0,sizeof(passed));\n\n\t\tpassed[s[0]][s[1]][s[2]][s[3]][s[4]]=true;\n\t\tcout<<dfs(s[0],s[1],s[2],s[3],s[4])<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( cnt >= 3 ){\n\t\treturn cnt;\n\t}\n\t\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\treturn dfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 50000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 50000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\n#define SIZE (5)\n#define SET(t, x, y) (((t) |= (1 << ((y) * SIZE + (x)))))\n#define CHECK(t, x, y) (((t) & ((1 << ((y) * SIZE + (x))))) != 0)\n\nint ans;\nunsigned int hash[1 << 25];\n\nint numofbits5(unsigned int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint dfs(unsigned int field, vector<unsigned int>& table, int depth)\n{\n\tif (field == 0){\n\t\tif (ans > depth){\n\t\t\tans = depth;\n\t\t}\n\t\treturn (0);\n\t}\n\tif (ans <= depth || hash[field] <= depth){\n\t\treturn (0);\n\t}\n\t\n\thash[field] = depth;\n\t\n\tfor (int i = table.size() - 1; i >= 0; i--){\n\t\tif (numofbits5(field) > numofbits5(field ^ table[i])){\n\t\t\tdfs(field ^ table[i], table, depth + 1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\n\nint main(void)\n{\n\tunsigned int field;\n\tint n;\n\tvector<unsigned int> table;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttable.clear();\n\t\tmemset(hash, -1, sizeof(hash));\n\t\tfor (int y = 0; y < n; y++){\n\t\t\tfor (int x = 0; x < n; x++){\n\t\t\t\tfor (int i = 1; i <= n - y; i++){\n\t\t\t\t\tfor (int j = 1; j <= n - x; j++){\n\t\t\t\t\ttable.push_back(0);\n\t\t\t\t\tfor (int dy = y; dy < y + i; dy++){\n\t\t\t\t\t\tfor (int dx = x; dx < x + j; dx++){\n\t\t\t\t\t\t\tSET(table.back(), dx, dy);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfield = 0;\n\t\tans = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1){\n\t\t\t\t\tSET(field, j, i);\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = n * n / 2 + 1;\n\t\t\n\t\tdfs(field, table, 0);\n\t\t\n\t\tfor (int i = 0; i < ans; i++){\n\t\t\tprintf(\"myon\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 999999999\n\ntypedef long long ll;\n\nint n;\nint xorMemo[5][5][5][5][5];\nshort dp[5][1<<25];\n\nint solve(int bit){\n  if(bit == 0) return 0;\n  if(dp[n-1][bit] != -1) return dp[n-1][bit];\n\n  int li,lj;\n  for(li=0;li<n;li++){\n    for(lj=0;lj<n;lj++){\n      if((bit & (1<<(n*li+lj))) != 0){\n        break;\n      }\n    }\n    if(lj != n) break;\n  }\n\n  int res = MAX;\n  REP(hi,li,n){\n    REP(hj,lj,n){\n      int next = (bit ^ xorMemo[n-1][li][lj][hi][hj]);\n      res = min(res,solve(next)+1);\n    }\n  }\n  return dp[n-1][bit]=res;\n}\n\nint main(){\n  memset(xorMemo,0,sizeof(xorMemo));\n  REP(m,1,6){\n    rep(li,m){\n      rep(lj,m){\n        REP(hi,li,m){\n          REP(hj,lj,m){\n            REP(i,li,hi+1){\n              REP(j,lj,hj+1){\n                xorMemo[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  memset(dp,-1,sizeof(dp));\n  while(cin>>n,n){\n    int bit = 0;\n    rep(i,n){\n      rep(j,n){\n        int x;\n        cin>>x;\n\n        if(x == 1){\n          bit |= (1<<(i*n+j));\n        }\n      }\n    }\n\n    int ans = solve(bit);\n    rep(i,ans){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\nmap<int,char> mem;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\tif(!((s>>(miny*n+minx))&1))\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nvoid initSit(){\n\tfill(dp,dp+(1<<25),INF);\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\tint ns=0;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++)\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++)\n\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\tdp[ns]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(map<int,char>::iterator it=mem.begin();it!=mem.end();it++)\n\t\tdp[it->first]=it->second;\n}\n\n\nvoid bfs(int s){\n\tqueue<int> *prv=new queue<int>();\n\tqueue<int> *nxt=new queue<int>();\n\tprv->push(s);\n\tfill(dp,dp+(1<<25),INF);\n\tint cnt=0;\n\tdp[0]=0;\n\twhile(prv->size()){\n\t\tcout<<cnt<<endl;\n\t\twhile(prv->size()){\n\t\t\tint cp=prv->front();\n\t\t\tprv->pop();\n\t\t\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t\t\t// ¶ãÌÀW\n\t\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t\tif(((cp>>(miny*n+minx))&1)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// c\n\t\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t\t// ¡\n\t\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t\t// ¡ñß½êÌrbgð½]\n\t\t\t\t\t\t\tint ns=cp;\n\t\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(dp[ns]==INF){\n\t\t\t\t\t\t\t\tdp[ns]=cnt+1;\n\t\t\t\t\t\t\t\tnxt->push(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n}\n\nint main(){\n\t//n=5;\n\t//bfs(0);\n\t//cout<<endl;\n\tfill(dp,dp+(1<<25),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tchar cnt;\n\t\t//initSit();\n\t\t//mC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\t//cnt=dp[init];\n\t\t//start=init;\n\t\tcnt=minStep(init,0);\n\t\t//mem[init]=cnt;\n\t\t\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,char depth){\n\t//if(depth!=0&&s==start){\n\t//\treturn INF;\n\t//}\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;p\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\t//if(res==STOP){\n\t\t\t\t\t\t//\treturn INF;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tfill(dp,dp+(1<<25),INF);\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tfor(int miny = 0; miny < n; miny++){\n\t\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t\t// c\n\t\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t\t// ¡\n\t\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t\t// ¡ñß½êÌrbgð1É·é\n\t\t\t\t\t\tint ns=0;\n\t\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[ns]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tif( dp_5.size() >= 12000 ) break;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\n// hash\n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n// map<int, short> dp;\n// short dp[1 << 25];\nunordered_map<int, short> dp;\nint recur(int e, int sum, int& min_res)\n{\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = min(n * n, 8);\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * 5) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1 && y != 0 && x != 0) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[n][x] = 1;\n        field[y][n] = 1;\n        field[n][n] = 1;\n        if (field[ny][x] + field[y][nx] + field[ny][nx] < 2) { continue; }\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n        ret = min(ret, calc(y, x + 1) + 1);\n        field[ny][x] ^=1;\n        field[y][nx] ^=1;\n        field[ny][nx] ^=1;\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  MEMSET(memo, -1);\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n < 5 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar memo[1<<25];\nint n;\n\nchar solve(int state){\n  if(state == 0) return 0;\n  if(memo[state]>0) return memo[state];\n  if(memo[state]<0) return 30;\n  memo[state] = -1;\n  printf(\"state:%x\\n\",state);\n\n  char ret = 30;\n  return memo[state] = ret;\n}\n\nint main(){\n  queue<int> q;\n  int cost = 0;\n  q.push(-1);\n  q.push(0);\n  memo[0] = 1;\n\n  while(q.size() != 1){\n    int state = q.front();\n    q.pop();\n\n    if(state == -1){\n      cost++;\n      q.push(-1);\n      printf(\"cost = %d, size = %d\\n\",cost,q.size());\n      continue;\n    }\n\n    //printf(\"state: %x\\n\",state);\n\n    for(int xs = 0; xs < 5; xs++){\n      for(int xe = xs+1; xe <= 5; xe++){\n        int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n        for(int ys = 0; ys < 5; ys++){\n          int next = state;\n          for(int ye = ys; ye < 5; ye++){\n            next ^= mask << (ye * 5);\n            if(!memo[next]) q.push(next);\n            memo[next] = cost+1;\n          }\n        }\n      }\n    }\n  }\n\n  while(n = getInt()){\n    int ss = 0;\n    REP(i,n) REP(j,n){\n      int t = getInt();\n      ss |= (t << (j + i*5));\n    }\n    int ans = memo[ss] - 3;\n    while(ans --> 0)\n      printf(\"myon\");\n    puts(\"\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nchar dp[1<<25];\nint n;\nconst char INF=127;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\tchar minCnt=INF;\n\tbool fin=false;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// ¶ãÌÀWª1ÅÈ¯êÎ\n\t\t\tif(((s>>(miny*n+minx))&1)==0)\n\t\t\t\tcontinue;\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1);\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(1<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// ÌóÔð\n\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfin=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(fin)\n\t\t\tbreak;\n\t}\n\treturn dp[s]=minCnt;\n}\n\nint main(){\n\tfill(dp,dp+(1<<25),INF);\n\twhile(cin>>n&&n!=0){\n\t\t//char cnt;\n\t\tint init=0;\n\t\tint bit;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=minStep(init);\n\t\tfor(int i = 0; i < (int)(cnt); i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 25];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x);\n  }\n  return ret;\n}\n\nvoid inv(int y, int x, int ey, int ex) {\n  FOREQ(ny, y, ey) FOREQ(nx, x, ex) {\n    field[ny][nx] ^= 1;\n  }\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    FOR(ny, y, n) {\n      FOR(nx, x, n) {\n        inv(y, x, ny, nx);\n        ret = min(ret, calc(y, x + 1) + 1);\n        inv(y, x, ny, nx);\n      }\n    }\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\t//if( n == 4 && cnt >= 6 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 5000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tif( n <= 3 ){\n\t\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t\t}else if( n == 4 ){\n\t\t\t\tcout << s[2] << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint calc(int y, int x) {\n  if (x == n) { return calc(y + 1, 0); }\n  if (y == n) { return 0; }\n  if (field[y][x] == 0) { return calc(y, x + 1); }\n  int ret = calc(y, x + 1) + 1;\n  field[y][n] = 1;\n  field[n][y] = 1;\n  field[n][n] = 1;\n  FOR(ny, y + 1, n + 1) {\n    FOR(nx, x + 1, n + 1) {\n      if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n        field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n        ret = min(ret, calc(y, x + 1) + 1);\n        field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    printField();\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "unsigned char cost[1<<20];\nint mask[5][5][6][6];\nvoid gen(){\n\tmemset(cost,-1,sizeof(cost));\n\tcost[0]=0;\n\trep(i,5)rep(j,5)for(int h=1;h<=5-i;h++)for(int w=1;w<=5-j;w++){\n\t\tint m=(1<<w)-1;\n\t\trep(k,h)mask[i][j][h][w]^=m<<(i+k)*5+j;\n\t}\n\tqueue<int> Q; Q.push(0); int cnt=0;\n\twhile(!Q.empty()){\n\t\tint c=Q.front(),cc=cost[c]; Q.pop();\n\t\trep(i,4)rep(j,5)for(int h=1;h<=4-i;h++)for(int w=1;w<=5-j;w++){\n\t\t\tint nc=c^mask[i][j][h][w];\n\t\t\tif(cost[nc]>cc+1)cost[nc]=cc+1,Q.push(nc);\n\t\t}\n\t}\n}\nint lim;\nint getcost(int c){\n\tint ret=cost[c&(1<<20)-1],bit=0;\n\tfor(c>>=20;c;c&=c-1)bit++;\n\treturn ret+min(bit,6-bit);\n}\nvoid rec(int c,int x,int cnt){\n\tif(c>>20==0)lim=min(lim,cost[c]+cnt);\n\tif(x>=5)return;\n\t\n\trep(i,5)for(int j=x;j<5;j++){\n\t\tint nc=c^mask[i][x][5-i][j-x+1];\n\t\tif(!(nc&1<<20+x))rec(nc,x+1,cnt+1);\n\t}\n\tif(!(c&1<<20+x))rec(c,x+1,cnt);\n}\nint solve(int c){\n\tlim=getcost(c);\n\trec(c,0,0);\n\treturn lim;\n}\nint main(){\n\tgen();\n\t\n\tint n,ans;\n\twhile(cin>>n,n){\n\t\tint c=0,t;\n\t\trep(i,n)rep(j,n){\n\t\t\tcin>>t;\n\t\t\tif(t)c^=1<<i*5+j;\n\t\t}\n\t\tans=n<5?cost[c]:solve(c);\n\t\trep(i,ans)cout<<\"myon\"; cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tif( dp_5.size() >= 30000 ) break;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\t\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\tsolve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\tsolve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nunsigned char dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst char INF=100;\n\nunsigned char dfs(int s){\n    if(dp[s]!=INF)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n            if(res==1)\n                return dp[s]=res;\n        }\n    }\n    return dp[s]=res;\n}\n\nint main(){\n    for(int i = 0; i < (1<<25); i++) dp[i]=INF;\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < res; i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<cassert>\nusing namespace std;\n#define REP(i, b, e) for( int i = b; i < e; i++ )\n#define rep(i, n) REP(i, 0, n)\n#define MAX 5\n#define INFTY (1<<10)\n\nclass Frame{\npublic:\n  int si, sj, ti, tj;\n  Frame(int si=0, int sj=0, int ti=0, int tj=0):si(si), sj(sj), ti(ti), tj(tj){}\n  bool operator < (const Frame &f) const{\n    if ( si == f.si ) {\n      if ( sj != f.sj ) {\n\treturn sj < f.sj;\n      } else {\n\treturn ti-si < f.ti-f.si;\n      }\n    }\n    return si < f.si;\n  }\n};\n\nclass State{\npublic:\n  int n;\n  short S[MAX-1];\n  State(int n=0): n(n){ rep(i, n-1) S[i] = 0; }\n  \n  int getValue(){\n    int sum = 0;\n    rep(i, n-1){\n      sum = (sum << n) + S[i];\n    }\n    return sum;\n  }\n\n  bool operator < ( const State &s) const{\n    rep(i, n-1){\n      if ( S[i] == s.S[i] ) continue;\n      return S[i] < s.S[i];\n    }\n    return false;\n  }\n};\n\nint limit;\nint n;\nshort D[MAX+1][(1<<(MAX*(MAX-1)))], S[MAX], M[MAX][MAX], MD[(1<<MAX)];\nint nframe;\nFrame F[MAX*MAX*MAX*MAX];\n\nvoid bfs(int h){\n  State init = State(h);\n  queue<State> Q;\n  Q.push(init);\n  rep(i, (1<< (h*(h-1))) ) D[h][i] = INFTY;\n  D[h][init.getValue()] = 0;\n\n  State u, v;\n  int value, uvalue;\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    uvalue = u.getValue();\n    rep(si, h-1) rep(sj, h) REP(ti, si, h-1) REP(tj, sj, h){\n      v = u;\n      REP(i, si, ti+1) v.S[i] ^= M[sj][tj];\n      value = v.getValue();\n      if ( D[h][value] == INFTY ){\n\tD[h][value] = D[h][uvalue] + 1;\n\tQ.push(v);\n      }\n    }\n  }\n}\n\nvoid init(){ \n  rep(i, MAX) rep(j, MAX) M[i][j] = 0;\n  REP(i, 0, MAX) REP(j, i, MAX ){\n    short base = (1<<(1+j-i))-1;\n    M[i][j] = (base << i);\n  }\n\n  REP(h, 1, MAX+1) bfs(h);\n}\n\nvoid initMD(){\n  rep(i, (1<<n)) {\n    bool bit[MAX];\n    int v = i;\n    rep(j, n){ bit[j] = v%2; v /= 2; }\n    int cnt = 0, j = 0;\n    while( j < n ){\n      if ( bit[j] ){\n\tcnt++;\n\twhile( j < n && bit[j] ) j++;\n      } else j++;\n    }\n    MD[i] = cnt;\n  }\n}\n\nint md(int si ){\n  if ( si == 0 ){\n    int sum = 0;\n    for ( int i = 1; i < n; i++ ){\n      sum = (sum<<n) + S[i];\n    }\n    return max( D[n][sum], MD[S[0]]);\n  }\n\n  int m = 0;\n  for ( int i = si; i < n; i++ ){\n    m = max(m, (int)MD[S[i]]);\n  }\n  return m;\n}\n\nbool dfs(int pos, int cnt ){\n int h = md(F[pos].si);\n  if ( h == 0 ) return true;\n  if ( pos == nframe) { return false; }\n  if ( cnt + h > limit || cnt >= limit) { return false; }\n  int si = F[pos].si;\n  int sj = F[pos].sj;\n  int ti = F[pos].ti;\n  int tj = F[pos].tj;\n  if ( sj ) if ( S[si]&(1<<(sj-1)) ) { return false; }\n  if ( sj == 0 && si ) if ( S[si-1]&((1<<(n-1))) ) {  return false;}\n\n  if ( dfs(pos+1, cnt) ) return true;\n\n  REP(i,si,ti+1) S[i] ^= M[sj][tj];\n  if ( dfs(pos+1, cnt+1) ) return true;\n  REP(i,si,ti+1) S[i] ^= M[sj][tj];\n  return false;\n}\n\nint compute(){\n  nframe = 0;\n  rep(i, n) rep(j, n){\n    REP(k, i, n) REP(l, j, n){\n      F[nframe++] = Frame(i, j, k, l);\n    }\n  }\n  sort( F, F + nframe);\n\n  for ( limit = 0; limit <= 100; limit++ ){\n    if (dfs(0, 0)) return limit;\n  }\n  return -1;\n}\n\nmain(){\n  init();\n  while( cin >> n && n ){\n    initMD();\n    int v, p, b;\n    \n    rep(i, n){\n      v = 0;\n      p = 1;\n      rep(j, n) {\n\tcin >> b; \n\tif ( b ) v += p;\n\tp *= 2;\n      }\n      S[i] = v;\n    }\n\n    int cnt = compute();\n\n\n    for ( int i = 0; i < cnt; i++ ){\n      cout << \"myon\";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct NODE{\n\tint con,depth;\n\tNODE(int a,int b){con = a,depth = b;};\n};\n#define rep(i,n) for(int i=0;i<n;i++)\n\nvoid check(int data,int n){\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcout << !!(data & (1<<i*n+j));\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tint current = 0;\n\t\trep(i,n*n){\n\t\t\tint a; cin >> a;\n\t\t\tcurrent |= (a<<i);\n\t\t}\n\t\t//check(current,n);\n\t\t\n\t\tvector<bool> done(33554432);\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(NODE(current,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\tif(q.con == 0){\n\t\t\t\trep(i,q.depth)cout << \"myon\";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(done[q.con])continue;\n\t\t\telse done[q.con] = true;\n\t\t\tfor(int w=1;w<=n;w++){\n\t\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\t\trep(i,n-h+1){\n\t\t\t\t\t\trep(j,n-w+1){\n\t\t\t\t\t\t\tif( q.con & (1 << (i*n+j)) ){\n\t\t\t\t\t\t\t\tint next = q.con;\n\t\t\t\t\t\t\t\trep(x,n)rep(y,n){\n\t\t\t\t\t\t\t\t\tif( j <= x && x < j+w && i <= y && y < i+h){\n\t\t\t\t\t\t\t\t\t\tnext = next ^ (1 << (y*n+x));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tQ.push(NODE(next,q.depth+1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int t,v;\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    queue<S> que;\n    S is={0,v};\n    que.push(is);\n    set<int> s;\n    for(;;){\n      S c=que.front();\n      if(c.v==0)break;\n      que.pop();\n      if(!s.insert(c.v).second)continue;\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=j;l<n;l++){\n\t    for(int m=k;m<n;m++){\n\t      int nv=c.v;\n\t      for(int o=j;o<=l;o++){\n\t\tfor(int p=k;p<=m;p++){\n\t\t  nv^=1<<o*n+p;\n\t\t}\n\t      }\n\t      S ns={c.t+1,nv};\n\t      que.push(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<que.front().t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar memo[1<<20];\nint n;\n\nint main(){\n  {\n    queue<int> q;\n    int cost = 0;\n    q.push(-1);\n    q.push(0);\n    memo[0] = 1;\n\n    while(q.size() != 1){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        //printf(\"cost = %d, size = %d\\n\",cost,q.size());\n        continue;\n      }\n\n      //printf(\"state: %x\\n\",state);\n\n      for(int xs = 0; xs < 5; xs++){\n        for(int xe = xs+1; xe <= 5; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys =  0; ys < 4; ys++){\n            int next = state;\n            for(int ye = ys; ye < 4; ye++){\n              next ^= mask << (ye * 5);\n              if(!memo[next]){\n                q.push(next);\n                memo[next] = cost+1;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  while(n = getInt()){\n    int ss = 0;\n    REP(i,n) REP(j,n){\n      int t = getInt();\n      ss |= (t << (j + i*5));\n    }\n\n    queue<int> q;\n    int cost = 0;\n    const int mm = ((1<<25)-1) ^ ((1<<20)-1);\n    set<int> f;\n    q.push(ss);\n    f.insert(ss);\n    q.push(-1);\n\n    int ans = INT_MAX;\n    while(q.size() != 1){\n      int state = q.front();\n      q.pop();\n\n      if(state == -1){\n        cost++;\n        q.push(-1);\n        //printf(\"cost = %d, size = %d\\n\",cost,q.size());\n        if(cost >= ans - 1) break;\n        continue;\n      }\n\n      if((state & mm) == 0){\n        ans = min(ans, cost + memo[state] - 1);\n      }\n\n      for(int xs = 0; xs < 5; xs++){\n        for(int xe = xs+1; xe <= 5; xe++){\n          int mask = ((1<<xe) - 1) ^ ((1<<xs) - 1);\n          for(int ys =  0; ys < 5; ys++){\n            int next = state;\n            for(int ye = ys; ye < 5; ye++){\n              next ^= mask << (ye * 5);\n              if(ye == 4 && !f.count(next)){\n                if(cost + 1 + memo[next & ((1<<20) - 1)] < ans){\n                  f.insert(next);\n                  q.push(next);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    while(ans --> 0) printf(\"myon\");\n    puts(\"\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint dp[1<<20], z[5][5][5][5];\nint n, f[5][5];\nint s;\n\nint rec(int at) {\n    if(at==5) return dp[s>>5];\n    if((s&(1<<at))==0) return rec(at+1);\n    int ans=1<<30;\n    rep(xe, 5) for(int ye=at; ye<5; ye++) {\n        s ^= z[0][xe][at][ye];\n        ans = min(ans, rec(at+1)+1);\n        s ^= z[0][xe][at][ye];\n    }\n    return ans;\n}\n\nint main() {\n    rep(xe, 5) rep(xs, xe+1) rep(ye, 5) rep(ys, ye+1) {\n        for(int x=xs; x<=xe; x++) for(int y=ys; y<=ye; y++) {\n            z[xs][xe][ys][ye] |= 1<<(x*5+y);\n        }\n    }\n    rep(ix, 20) rep(d, 1<<ix) {\n        int b=1<<ix|d, xe=ix/5, ye=ix%5;\n        dp[b] = 1<<30;\n        rep(xs, xe+1) rep(ys, ye+1) dp[b]=min(dp[b], dp[b^z[xs][xe][ys][ye]]+1);\n    }\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        memset(f, 0, sizeof(f));\n        rep(i, n) rep(j, n) scanf(\"%d\", f[i]+j);\n        s = 0;\n        rep(i, n) rep(j, n) s|=f[i][j]<<(i*5+j);\n        int ans = n<5 ? dp[s] : rec(0);\n        rep(i, ans) printf(\"myon\");\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nint op[5][5][5][5][5];\nint n;\n//short dp[5][1<<25];\nmap<int, short> dp;\n\n\nshort solve(int mask) {\n    if (mask == 0) return 0;\n    //short &ans = dp[n - 1][mask];\n    if (dp.count(mask))\n        return dp[mask];\n    //if(ans != -1) return ans;\n    int x, y;\n    for(x = 0; x < n; ++x){\n        for(y = 0; y < n; ++y)\n            if(mask & (1<<(n * x+ y )))\n                break;\n        if(y != n) break;\n    }\n    short ans = SHRT_MAX;\n    FOR(i,x,n){\n        FOR(j,y,n){\n            int next = (mask ^ op[n-1][x][y][i][j]);\n            short tmp = solve(next) + 1;\n            checkmin(ans, tmp);\n        }\n    }\n    return dp[mask] = ans;\n}\n\nint main(){\n  memset(op,0,sizeof(op));\n  FOR(m,1,6)\n    REP(li,m)\n      REP(lj,m)\n        FOR(hi,li,m)\n          FOR(hj,lj,m)\n            FOR(i,li,hi+1)\n              FOR(j,lj,hj+1)\n                op[m-1][li][lj][hi][hj] |= (1<<(i*m+j));\n  //memset(dp,-1,sizeof(dp));\n  while(scanf(\"%d\", &n), n){\n      dp.clear();\n      int mask = 0;\n      REP(i,n){\n          REP(j,n){\n              int tmp;\n              scanf(\"%d\", &tmp);\n              if(tmp == 1){\n                  mask |= (1<<(i*n+j));\n              }\n          }\n      }\n\n      int ans = solve(mask);\n      REP(i,ans)\n          printf(\"myon\");\n      puts(\"\"); \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    vector<int> cls;\n    cls.reserve(1<<16);\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    cls.push_back(bd);\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls.push_back(nbd);\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls.size(); i++)\n      close[cls[i]]=false;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 10000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\tdfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint n, X[5][5][5][5] = {0};\nchar dp[(1<<25)/2];\n\nvoid init(){\n\tfor(int i=0 ; i < (1<<25)/2 ; i++ ){\n\t\tdp[i] = -1;\n\t}\n\tfor(int ly = 0 ; ly < 5 ; ly++ ){\n\t\tfor(int lx = 0 ; lx < 5 ; lx++ ){\n\t\t\tfor(int ry = ly ; ry < 5 ; ry++ ){\n\t\t\t\tfor(int rx = lx ; rx < 5 ; rx++ ){\n\t\t\t\t\tfor(int y = ly ; y <= ry ; y++ ){\n\t\t\t\t\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\t\t\t\t\tX[ly][lx][ry][rx] |= (1 << (y * 5 + x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid set(int bits, char k){\n\tif( bits % 2 == 0 ){\n\t\tdp[bits/2] = ((0xf << 4) & dp[bits/2]) | k;\n\t}else{\n\t\tdp[bits/2] = (0xf & dp[bits/2]) | (k << 4);\n\t}\n}\n\nint get(int bits){\n\tif( bits % 2 == 0 ){\n\t\treturn dp[bits/2] & 0xf;\n\t}else{\n\t\treturn (dp[bits/2] >> 4) & 0xf;\n\t}\n}\n\nint solve(int bits){\n\tif( bits == 0 ) return 0;\n\tif( get(bits) != 0xf ) return get(bits);\n\t\n\tint sx, sy;\n\tfor(int i=0 ; i < 25 ; i++ ){\n\t\tif( bits & (1 << i) ){\n\t\t\tsx = i % 5; sy = i / 5; break;\n\t\t}\n\t}\n\tint res = INF;\n\tfor(int y = sy ; y < 5 ; y++ ){\n\t\tfor(int x = sx ; x < 5 ; x++ ){\n\t\t\tint next = bits ^ X[sy][sx][y][x];\n\t\t\tres = min(res, solve(next)+1 );\n\t\t}\n\t}\n\tset(bits, res);\n\treturn res;\n}\n \nint main(){\n\tinit();\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\tfor(int i=0 ; i < 25 ; i++ ){\n\t\t\tint e = 0;\n\t\t\tif( i % 5 < n && i / 5 < n ){\n\t\t\t\tcin >> e;\n\t\t\t}\n\t\t\tbits = (bits << 1) + e;\n\t\t}\n\t\tint ans = solve(bits);\n\t\tfor(int i=0 ; i < ans ; i++ )\n\t\t\tcout << \"myon\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[4];\n// dp[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3, n = 4 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( cnt == 2 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\tvector<char> v(65536);\n\t\t\tdp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t}else if( i == 4 ){\n\t\t\t//solve_3();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 4 ){\n\t\t\tif( n <= 3 )\n\t\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[2] << endl;\n\t\t}else{\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[3] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\nusing namespace std;\n\nchar a[33554432];\nint map[700], num[10];\nint tot = 0, n, deep;\n\nvoid dfs(int now, int d) {\n    a[now] = d;\n    if (d == deep || a[0] < 25) return;\n    for (int i = num[n - 1]; i < num[n]; ++i) {\n        int tmp = (now ^ map[i]);\n        dfs(tmp, d + 1);\n    }\n}\n\nint main() {\n    num[0] = 0;\n\n    for (int p = 1; p < 6; ++p) {\n        num[p] = num[p - 1];\n        for (int i = 0; i < 5; ++i)\n            for (int j = 0; j < 5; ++j)\n                for (int k = 0; k < 5; ++k)\n                    for (int l = 0; l < 5; ++l)\n                        if (i + k < p && j + l < p) {\n                            int x = i + k;\n                            int y = j + l;\n                            int tmp = 0;\n\n                            for (int ii = i; ii <= x; ++ii)\n                                for (int jj = j; jj <= y; ++jj)\n                                    tmp += (1 << (ii * p + jj));\n\n                            map[num[p]++] = tmp;\n                        }\n    }\n\n    while (scanf(\"%d\", &n)&n) {\n        int start = 0;\n        memset(a, 0x3f, sizeof(a));\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                int x;\n                scanf(\"%d\", &x);\n                start = 2 * start + x;\n            }\n\n        deep = 0;\n        a[start] = 0;\n        while (a[0] > 25) {\n            ++deep;\n            dfs(start, 0);\n        }\n\n        for (int i = 0; i < a[0]; ++i)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nshort dp[1<<25];\n\n// sÌ(x,y)n_ÌbitªÇ¤ÈÁÄ¢é©\nint getValue(int s,int x,int y){\n    return ((s>>(y*n+x))&1);\n}\n// sÌ(x,y)n_ÉrbgðZbg\nvoid setValue(int &s,int x,int y,int value){\n    if(value==1)\n        s|=(1<<(y*n+x));\n    else{\n        s&=~(1<<(y*n+x));\n    }\n}\n// sÌwè³ê½n_Ìrbgð½]\nvoid reverseBit(int &s,int minx,int miny,int maxx,int maxy){\n    for(int i = miny; i <= maxy; i++){\n        for(int j = minx; j <= maxx; j++){\n            if(getValue(s,j,i))\n                setValue(s,j,i,0);\n            else\n                setValue(s,j,i,1);\n        }\n    }\n}\nconst char INF=30;\n\nchar dfs(int s){\n    if(dp[s]!=-1)\n        return dp[s];\n    if(s==0)\n        return 0;\n    int miny,minx;\n    miny=minx=-1;\n    int res=INF;\n    // ÅÉÝÂ¯½1ð¶ãÆ·é·û`·×Äð²×é\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(getValue(s,j,i)){\n               miny=i;\n               minx=j;\n               break;\n           }\n        }\n        if(miny!=-1)\n            break;\n    }\n    for(int maxy=miny; maxy<n; maxy++){\n        for(int maxx=minx; maxx<n; maxx++){\n            int ns=s;\n            reverseBit(ns,minx,miny,maxx,maxy);\n            res=min(res,(int)(dfs(ns)+1));\n            if(res==1)\n                return dp[s]=res;\n        }\n    }\n    return dp[s]=(char)res;\n}\n\nint main(){\n    memset(dp,-1,sizeof(dp));\n    while(cin>>n&&n!=0){\n        int ss=0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int a;\n                cin>>a;\n                if(a)\n                    setValue(ss,j,i,a);\n            }\n        }\n        int res=dfs(ss);\n        for(int i = 0; i < min(25,res); i++)\n            printf(\"myon\");\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n// map<int, int> dp;\nshort dp[1 << 25];\nint recur(int e, int sum, int& min_res)\n{\n    if (e == 0)\n        return 0;\n    else if (dp[e])\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                for (int y2 = y1; y2 <= max_y; ++y2)\n                {\n                    for (int x2 = x1; x2 <= max_x; ++x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = n * n;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<bitset>\n#include<queue>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX (1<<20)\nusing namespace std;\n\nstruct P\n{\n  int state,cost;\n  P(int state=inf,int cost=inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nshort mincost[MAX];\nshort mincost5[1<<5];\nint rect[5][5][5][5];\n\n\nvoid init()\n{\n  rep(i,MAX)mincost[i] = 25;\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rect[i][j][k][l] = 0;\n}\n\nvoid makeRect()\n{\n  rep(y1,5)rep(x1,5)//top-left\n    REP(y2,y1,5)REP(x2,x1,5)//bottom-right\n      REP(y,y1,y2+1)REP(x,x1,x2+1)\n        rect[y1][x1][y2][x2] |= (1<<(y*5+x));\n}\n\nvoid makeMincost()\n{\n  mincost[0] = 0;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  while(!que.empty())\n    {\n      P p = que.top(); que.pop();\n\n      rep(y1,4)rep(x1,5)\n\tREP(y2,y1,4)REP(x2,x1,5)\n\t{\n\t  int nstate = p.state ^ rect[y1][x1][y2][x2];\n\t  if(mincost[nstate] > p.cost + 1)\n\t    {\n\t      mincost[nstate] = p.cost + 1;\n\t      que.push(P(nstate,p.cost+1));\n\t    }\n\t}\n    }\n\n}\n\nvoid print(int f)\n{\n  bitset<25> ff(f);\n  rep(i,5)\n    {\n      cout << i << \" : \";\n      rep(j,5)\n\t{\n\t  cout << ff[i*5+j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid dfs(int state,int cur,int cost,int &ans)\n{\n  if(state < (1<<20))ans = min(ans,cost + mincost[state]);\n  if(cost >= ans)return;\n  //if(cur >= 1)return;\n\n  rep(y1,5)rep(x1,5)REP(x,x1,5)\n    {\n      int nstate = state ^ rect[y1][x1][4][x];\n      int nstate5 = (nstate>>20);      \n\n      //cout << \"ns = \" << endl;\n      //print(nstate);\n\n      dfs(nstate,cur+1,cost+1,ans);\n\t\n    }\n  \n}\n\nint compute(int field)\n{\n  rep(i,(1<<5))mincost5[i] = 100; \n  bitset<30> b(field),b2(field>>20);\n  //cout << \"b = \" << b << endl;\n  //cout << \"b2 = \" << b2 << endl;\n  mincost5[(field>>20)] = 0;\n  int ret = 5;\n  //cout << \"start dfs\" << endl;\n  dfs(field,0,0,ret);\n  //cout << \"end dfs\" << endl;\n  //cout << \"ret = \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  int n,field;\n  init();\n  makeRect();\n  /*\n  rep(y,3)\n    rep(x,3)\n    {\n      bitset<20> b(rect[0][0][y][x]);\n      cout << \"(\" << x << \",\" << y << \") \" << b << endl;\n    }\n  */\n  //cout << \"finish -- makeRect\" << endl;\n  makeMincost();\n  //cout << \"finish -- makeMincost\" <<endl;\n\n  while(cin >> n,n)\n    {\n      field = 0;\n      {\n\tchar c;\n\trep(y,n)rep(x,n)\n\t  {\n\t    cin >> c;\n\t    if(c == '1')field |= (1<<(y*5+x));\n\t  }\n\tint cnt = (n<=4?mincost[field]:compute(field));\n\trep(i,cnt)cout << \"myon\";\n\tcout << endl;\n\n      }\n\n    }\n  return 0;\n}\n\n\n/*\nstruct P\n{\n  int state,cost;\n  P(int state = inf,int cost = inf):state(state),cost(cost){}\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint n;\nshort mincost[5][MAX];\nint rect[5][5][5][5][5];\nint lim;\n\nvoid makeRect()\n{\n  rep(i,5)rep(j,5)rep(k,5)rep(l,5)rep(m,5)rect[i][j][k][l][m] = 0;\n\n  rep(depth,5)\n    {\n      rep(y1,depth+1)rep(x1,depth+1)\n\tREP(y2,y1,depth+1)REP(x2,x1,depth+1)\n\t  REP(y,y1,y2+1)REP(x,x1,x2+1)\n\t  {\n            rect[depth][y1][x1][y2][x2] |= (1<<(y*(depth+1)+x));\n\t  }\n    }\n\n}\n\n\n\nvoid compute(int N)\n{\n  rep(i,(1<<(N*N)))mincost[N-1][i] = N*N+1;\n  mincost[N-1][0] = 0;\n  cout << \"N = \"<< N << endl;\n  rep(state,(1<<(N*N)))\n    {\n      if(mincost[N-1][state] == N*N+1)continue;\n      rep(y1,N)rep(x1,N)\n\tREP(y2,y1,N)REP(x2,x1,N)\n\t{  \n\t  int nstate = state ^ rect[N-1][y1][x1][y2][x2];\n\t  mincost[N-1][nstate] = min(mincost[N-1][nstate],\n\t\t\t\t     (short)(mincost[N-1][state]+1));\n\t}\n    }\n}\n\nint main()\n{\n\n  makeRect();\n  cout << \"finish --- make rectangle\" << endl;\n \n  compute(1);\n  compute(2);\n  compute(3);\n  compute(4);\n  //compute(5);\n  cout << \"-------------\" << endl;\n  while(cin >> n,n)\n    {\n      lim = (1<<n);\n\n      int field = 0,c;\n      rep(y,n)rep(x,n)\n\t{\n\t  cin >> c;\n\t  if(c)field |= (1<<(n*y + x));\n\t}\n      bitset<25> bi(field);\n      cout << \"field \" << bi << endl;\n\n      cout << mincost[n-1][field] << endl;\n\n    }\n  return 0;\n}\n*/\n\n /*\n  REP(y,1,3)\n    {\n      REP(x,1,3)\n\t{\n\t  cout << \"y = \" << y << \" x = \" << x << endl;\n\t  bitset<10> bit(rect[2][1][1][y][x]);\n\t  cout << \"***\" << bit << \"***\" << endl;\n\t}\n    }\n  */\n\n/*\nvoid compute(int N)\n{\n  rep(j,(1<<(N*N)))mincost[N-1][j] = N*N+1;\n  mincost[N-1][0] = 0;\n  //queue<P> que;\n  priority_queue<P> que;\n  que.push(P(0,0));\n\n  cout << \"N = \" << N << endl;\n  while(!que.empty())\n    {\n      //P p = que.front(); que.pop();\n      P p = que.top(); que.pop();\n      //bitset<5> bb(p.state);\n      //cout << \"cur = \" << bb << \" cost = \" << p.cost << endl;\n\n      rep(y1,N)\n\t{\n\t  rep(x1,N)\n\t    {\n\t      REP(y2,y1,N)\n\t\t{\n\t\t  REP(x2,x1,N)\n\t\t    {\n\t\t      //bitset<5> re(rect[N-1][y1][x1][y2][x2]);\n\t\t      //cout << \"rect[\"<<y1<<\"][\"<<x1<<\"][\"<<y2<<\"][\"<<x2<<\"] = \" << re << endl;\n\t\t      int nstate = p.state ^ rect[N-1][y1][x1][y2][x2];\n\t\t      if(mincost[N-1][nstate] > p.cost + 1)\n\t\t\t{\n\t\t\t  bitset<5> nex(nstate);\n\t\t\t  //cout << \"go to next = \" << nex << \" cost = \" << p.cost+1 << endl;\n\t\t\t  //cout << endl;\n\t\t\t  mincost[N-1][nstate] = p.cost + 1;\n\t\t\t  que.push(P(nstate,p.cost+1));\n\t\t\t}\n\t\t      //else cout << re << \" is bad case because \" << mincost[N-1][nstate] << \" !> \" << p.cost+1<< endl << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    }\n\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\nconst int size = 5;\n\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = size - 1; y >= 0; --y)\n        for (int x = size - 1; x >= 0; --x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\n\n// hash\n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n// map<int, short> dp;\n// short dp[1 << 25];\nunordered_map<int, short> dp;\nint recur(int e, int sum, int& min_res)\n{\n    if (dp.count(e))\n    {\n        min_swap(min_res, sum + dp[e]);\n        return dp[e];\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    int max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if ((e >> (size * y)) >> x & 1)\n            {\n                max_swap(max_x, x);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int y1 = 0; y1 <= max_y; ++y1)\n    {\n        for (int x1 = 0; x1 <= max_x; ++x1)\n        {\n            if ((e >> (size * y1)) >> x1 & 1)\n            {\n                // for (int y2 = y1; y2 <= max_y; ++y2)\n                for (int y2 = max_y; y2 >= y1; --y2)\n                {\n                    // for (int x2 = x1; x2 <= max_x; ++x2)\n                    for (int x2 = max_x; x2 >= x1; --x2)\n                    {\n                        int mask = ((1 << (x2 + 1)) - 1) & ~((1 << x1) - 1);\n                        int ne = e;\n                        for (int y = y1; y <= y2; ++y)\n                            ne ^= mask << (size * y);\n\n                        min_swap(res, recur(ne, sum + 1, min_res));\n                    } \n                }\n\n                break;\n            }\n        }\n    }\n    ++res;\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n        int t = (n * n + 1) / 2;\n        int times = recur(enc(f), 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[6][6];\nint c[6][6];\nint n;\nint solve(int p,int q,int t){\n\tif(t==0){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(c[i][j])return 0;\n\t\treturn 1;\n\t}\n\tif(p==n)return 0;\n\tif(q==n)return solve(p+1,0,t);\n\tif(!c[p][q])return solve(p,q+1,t);\n\tint r=q;\n\tfor(int i=q;i<n;i++){\n\t\tif(c[p][i])r=i;\n\t\telse break;\n\t}\n\tr++;\n\tfor(int i=p;i<n;i++){\n\t\tfor(int j=q;j<r;j++)c[i][j]^=1;\n\t\tif(solve(p,q+1,t-1))return 1;\n\t}\n\tfor(int i=p;i<n;i++)for(int j=q;j<r;j++)c[i][j]^=1;\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=1;;i++){\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<a;k++)c[j][k]=b[j][k];\n\t\t\tif(solve(0,0,i)){\n\t\t\t\tfor(int j=0;j<i;j++)printf(\"myon\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int t,v;\n  bool operator<(S a)const{\n    if(t!=a.t){\n      return t<a.t;\n    }else{\n      return v<a.v;\n    }\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    set<S> que;\n    S is={0,v};\n    que.insert(is);\n    set<int> s;\n    for(;;){\n      S c=*que.begin();\n      if(c.v==0)break;\n      que.erase(que.begin());\n      if(!s.insert(c.v).second)continue;\n      int j,k;\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  if(c.v>>j*n+k&1)goto next;\n\t}\n      }\n    next:\n      for(int l=j;l<n;l++){\n\tfor(int m=k;m<n;m++){\n\t  int nv=c.v;\n\t  for(int o=j;o<=l;o++){\n\t    for(int p=k;p<=m;p++){\n\t      nv^=1<<o*n+p;\n\t    }\n\t  }\n\t  if(s.count(nv))continue;\n\t  S ns={c.t+1,nv};\n\t  que.insert(ns);\n\t}\n      }\n    }\n    for(int i=0;i<que.begin()->t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ninline int ctz(uint x)\n{\n\tint i=0;\n\tif(!(x&0x0000ffff)) i+=16,x>>=16;\n\tif(!(x&0x000000ff)) i+=8,x>>=8;\n\tif(!(x&0x0000000f)) i+=4,x>>=4;\n\tif(!(x&0x00000003)) i+=2,x>>=2;\n\tif(!(x&0x00000001)) i+=1,x>>=1;\n\treturn i+!x;\n}\n\nint solve(int x0)\n{\n\tstatic array<int,225> ms;\n\t{\n\t\tint k=0;\n\t\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\t\tint m=0;\n\t\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\t\tms[k++]=m;\n\t\t}\n\t}\n\t\n\tqueue<tuple<int,int>> q; q.emplace(x0,0);\n\tunordered_set<int> vis;\n\twhile(q.size()){\n\t\tint x,c; tie(x,c)=q.front(); q.pop();\n\t\tif(x==0) return c;\n\t\tif(!vis.insert(x).second) continue;\n\t\tfor(int m:ms) if(ctz(x)==ctz(m))\n\t\t\tq.emplace(x^m,c+1);\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tint x0=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx0|=b<<(i*5+j);\n\t\t}\n\t\tcout<<solve(x0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[5];\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\npair<int,int> up_left(int bits, int n){\n\tint mx = 5, my = 5;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tif( get(n,bits,x,y) ){\n\t\t\t\tmx = min( mx , x );\n\t\t\t\tmy = min( my , y );\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_N3(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_N4(){\n\t/*queue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\t/*int bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 1000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n}\n\n// n <= 3 のすべての解を求めておく\nvoid solve(){\n\tfor(int i=1 ; i <= 5 ; i++ ){\n\t\tif( i == 1 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 3 ){\n\t\t\tdp[2] = vector<char>(512);\n\t\t\tsolve_N3( 3 );\n\t\t}else if( i == 4 ){\n\t\t\tdp[3] = vector<char>(65536);\n\t\t}else if( i == 5 ){\n\t\t\tdp[4] = vector<char>(33554432);\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 3 のすべての解を求めておく\n\tsolve();\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tcout << \"end;\" << endl;\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\tdebug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}else if( n == 5 ){\n\t\t\tcout << \"hoge\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// dp[n-1][bits] := 最小のmyonの回数\nvector<char> dp[3];\n// dp_4[bits] := n が 4 のときの最小のmyonの回数\nmap<int,char> dp_4;\n// dp_5[bits] := n が 5 のときの最小のmyonの回数\nmap<int,char> dp_5;\n\n// (x,y) の値(0 or 1) を返す\nint get(int n, int bits, int x, int y){\n\treturn ((bits & (1 << (x+y*n))) > 0 );\n}\n\nvoid debug(int bits, int n){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < n ; y++ ){\n\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\tcout << get(n,bits,x,y);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// [(sx,sy),(gx,gy)] の範囲に myon をかける (0 <=> 1 の反転)\nint myon(int bits, int n, int sx, int sy, int gx, int gy){\n\tfor(int y = sy ; y <= gy ; y++ ){\n\t\tfor(int x = sx ; x <= gx ; x++ ){\n\t\t\tint k = 1 << (x+y*n);\n\t\t\t(bits & k)? bits -= k : bits += k;\n\t\t}\n\t}\n\treturn bits;\n}\n\n// n = 3 のときのすべての状態からの最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS\nvoid solve_2(int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\tdp[n-1][bits] = cnt;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,char>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 4 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_3(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_4[bits] = cnt;\n\t\t\n\t\tif( dp_4.size() >= 12000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 4 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 4 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 4 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 4 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 4 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n = 5 のときの一部の最小の myon の回数を計算する\n// n*n のすべて 0 の状態からBFS (2手以下まで)\nvoid solve_4(){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( 0 , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tdp_5[bits] = cnt;\n\t\t\n\t\tif( dp_5.size() >= 12000 ) break;\n\t\t\n\t\tfor(int y = 0 ; y < 5 ; y++ ){\n\t\t\tfor(int x = 0 ; x < 5 ; x++ ){\n\t\t\t\tfor(int my = y ; my < 5 ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < 5 ; mx++){\n\t\t\t\t\t\tint next = myon( bits , 5 , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// n <= 4 のときのまだ求めていないときに BFS で求める\n/*int bfs(int bits, int n){\n\tqueue< pair<int,char> > q;\n\tq.push( pair<int,char>( bits , 0 ) );\n\tmap<int,bool> memo;\n\t\n\twhile( !q.empty() ){\n\t\tint bits = q.front().first; \n\t\tchar cnt = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tif( q.size() + memo.size() >= 20000 ){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\tif( n == 4 ){\n\t\t\tif( dp_4.count(bits) ){\n\t\t\t\treturn dp_4[bits] + cnt;\n\t\t\t}\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) ){\n\t\t\t\treturn dp_5[bits] + cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( memo[bits] ) continue;\n\t\tmemo[bits] = true;\n\t\t\n\t\tfor(int y = 0 ; y < n ; y++ ){\n\t\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\t\tif( !memo[next] ){\n\t\t\t\t\t\t\tq.push( pair<int,int>( next , cnt+1 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\n\nint dfs(int bits, int n, int cnt){\n\tif( n == 4 ){\n\t\tif( dp_4.count(bits) ){\n\t\t\treturn dp_4[bits] + cnt;\n\t\t}\n\t}else if( n == 5 ){\n\t\tif( dp_5.count(bits) ){\n\t\t\treturn dp_5[bits] + cnt;\n\t\t}\n\t}\n\t\n\tfor(int y = 0 ; y < n ; y++ ){\n\t\tfor(int x = 0 ; x < n ; x++ ){\n\t\t\tfor(int my = y ; my < n ; my++ ){\n\t\t\t\tfor(int mx = x ; mx < n ; mx++){\n\t\t\t\t\tint next = myon( bits , n , x , y , mx , my );\n\t\t\t\t\tdfs( next , n , cnt + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n// n <= 4 のすべての解と n = 5 の一部の解を求めておく\nvoid solve(){\n\tfor(int i=0 ; i < 5 ; i++ ){\n\t\tif( i == 0 ){\n\t\t\tvector<char> v(2);\n\t\t\tv[0] = 0;\n\t\t\tv[1] = 1;\n\t\t\tdp[0] = v;\n\t\t}else if( i == 1 ){\n\t\t\tvector<char> v(16);\n\t\t\tint f[16] = {0,1,1,1,1,1,2,2,1,2,1,2,1,2,2,1};\n\t\t\tfor(int j=0 ; j < 16 ; j++ ){\n\t\t\t\tv[j] = f[j];\n\t\t\t}\n\t\t\tdp[1] = v;\n\t\t}else if( i == 2 ){\n\t\t\tvector<char> v(512);\n\t\t\tdp[2] = v;\n\t\t\tsolve_2( 3 );\n\t\t}else if( i == 3 ){\n\t\t\t//vector<char> v(65536);\n\t\t\t//dp[3] = v;\n\t\t\t//solve_2( 4 );\n\t\t\tsolve_3();\n\t\t}else if( i == 4 ){\n\t\t\tsolve_4();\n\t\t}\n\t}\n}\n\nint main(){\n\t// n <= 4 のすべての解と n = 5 の一部の解を求めておく\n\tsolve();\n\t\n\t//cout << \"dp_5.size() : \" << dp_5.size() << endl;\n\t//cout << \"input\" << endl;\n\t\n\tstring s[5] = { \"\" , \"myon\" , \"myonmyon\", \"myonmyonmyon\", \"myonmyonmyonmyon\"};\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\t\n\t\tfor(int i=0 ; i < n*n ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tbits |= (b << i);\n\t\t}\n\t\t\n\t\t// debug( bits , n );\n\t\t\n\t\tint ans = 0;\n\t\tif( n <= 3 ){\n\t\t\tcout << s[ dp[n-1][bits] ] << endl;\n\t\t}else if( n == 4 ){\n\t\t\tif( dp_4.count(bits) )\n\t\t\t\tcout << s[ dp_4[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}else if( n == 5 ){\n\t\t\tif( dp_5.count(bits) )\n\t\t\t\tcout << s[ dp_5[bits] ] << endl;\n\t\t\telse\n\t\t\t\tcout << s[ dfs(bits,n,0) ] << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nchar dp[1<<25];\n//int minArrivingDepth[1<<25];\n\nint n;\nconst char INF=100;\n\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(cin>>n&&n!=0){\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tcin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tint cnt=minStep(init,0);\n\t\tfor(int i = 0; i < cnt; i++)\n\t\t\tcout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<pair<int, int> > mm;\n    vector<bool> close(1<<(n*n), false);\n    mm.push(make_pair(0, bd));\n    close[bd]=true;\n    while(!mm.empty()){\n      int dep=mm.front().first;\n      int cbd=mm.front().second;\n      mm.pop();\n      //cout<<cbd<<endl;\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tmm.push(make_pair(dep+1, nbd));\n      }\n    }\n  _exit:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[6][1 << 25];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    ret |= field[y][x] << ((y * n) + x);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[n][state] != -1) { return memo[n][state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    field[y][n] = 1;\n    field[n][x] = 1;\n    field[n][n] = 1;\n    FOR(ny, y + 1, n + 1) {\n      FOR(nx, x + 1, n + 1) {\n        if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n          field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n          ret = min(ret, calc(y, x + 1) + 1);\n          field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n        }\n      }\n    }\n    field[y][x] = 1;\n  }\n  return memo[n][state] = ret;\n}\n\nint main() {\n  MEMSET(memo, -1);\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nunsigned char dist[1 << 25];\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    REP(i, 1 << (N * N)) dist[i] = 255;\n    int start = 0;\n    REP(i, N * N){\n      int t;\n      cin >> t;\n      start |= t << i;\n    }\n    queue<int> que;\n    que.push(start);\n    dist[start] = 0;\n    while(!que.empty()){\n      int s = que.front(); que.pop();\n      if(s == 0) break;\n      for(int y1 = 0; y1 < N; y1++){\n        for(int y2 = y1; y2 < N; y2++){\n          for(int x1 = 0; x1 < N; x1++){\n            for(int x2 = y1; x2 < N; x2++){\n              int ns = s;\n              for(int y = y1; y <= y2; y++){\n                for(int x = x1; x <= x2; x++){\n                  ns ^= (1 << (N * y + x));\n                }\n              }\n              if(dist[ns] == 255){\n                dist[ns] = dist[s] + 1;\n                que.push(ns);\n              }\n            }\n          }\n        }\n      }\n    }\n    string myon = \"myon\";\n    REP(i, dist[0]) cout << myon;\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(start==s&&depth!=0)\n\t//\treturn INF;\n\t//if(depth>mC)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//if(s==start){\n\t\t\t\t\t\t\t//\tmC=min(minCnt,mC);\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//memset(dp,INF,sizeof(dp));\n\t//cout<<(int)dp[1]<<endl;\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tmC=INF;\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\nvoid pv(int bit,int h,int w){\n\trep(i,h)rep(j,w)cerr<<!!(bit&1<<i*w+j)<<(j==w-1?\"\\n\":\" \");\n}\n\nunsigned char cost[1<<20];\nint mask[5][5][6][6];\nvoid gen(){\n\tmemset(cost,-1,sizeof(cost));\n\tcost[0]=0;\n\trep(i,5)rep(j,5)for(int h=1;h<=5-i;h++)for(int w=1;w<=5-j;w++){\n\t\tint m=(1<<w)-1;\n\t\trep(k,h)mask[i][j][h][w]^=m<<(i+k)*5+j;\n\t}\n\tqueue<int> Q; Q.push(0); int cnt=0;\n\twhile(!Q.empty()){\n\t\tint c=Q.front(),cc=cost[c]; Q.pop();\n\t\trep(i,5)rep(j,4)for(int h=1;h<=4-i;h++)for(int w=1;w<=5-j;w++){\n\t\t\tint nc=c^mask[i][j][h][w];\n\t\t\tif(cost[nc]>cc+1)cost[nc]=cc+1,Q.push(nc);\n\t\t}\n\t}\n}\nint lim;\nint getcost(int c){\n\tint ret=cost[c&(1<<20)-1],bit=0;\n\tfor(c=c&~((1<<20)-1);c;c&=c-1)bit++;\n\treturn ret+min(bit,6-bit);\n}\nvoid rec(int c,int x,int cnt){\n\tif(c>>20==0)lim=min(lim,cost[c]+cnt);\n\tif(x>=5)return;\n\t\n\trep(i,5)for(int j=x;j<5;j++){\n\t\tint nc=c^mask[i][x][5-i][j-x+1];\n\t\tif(!(nc&1<<20+x))rec(nc,x+1,cnt+1);\n\t}\n\tif(!(c&1<<20+x))rec(c,x+1,cnt);\n}\nint solve(int c){\n\tlim=getcost(c);\n\trec(c,0,0);\n\treturn lim;\n}\nint main(){\n\tgen();\n\t\n\tint n,ans;\n\twhile(cin>>n,n){\n\t\tint c=0,t;\n\t\trep(i,n)rep(j,n){\n\t\t\tcin>>t;\n\t\t\tif(t)c^=1<<i*5+j;\n\t\t}\n\t\tans=n<5?cost[c]:solve(c);\n\t\trep(i,ans)cout<<\"myon\"; cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint upb(int n)\n{\n  int ret=0;\n  while(n>0) ret++, n/=2;\n  return ret;\n}\n\nint main()\n{\n  vector<bool> close(1<<(5*5), false);\n  vector<int> cls;\n\n  for (int n; cin>>n, !(n==0); ){\n\n    vector<vector<int> > pats(n*n+1);\n    vector<vector<int> > tmp(n, vector<int>(n, 0));\n\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tfor (int k=i; k<n; k++){\n\t  for (int l=j; l<n; l++){\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=1;\n\t    int bd=0;\n\t    for (int a=0; a<n; a++){\n\t      for (int b=0; b<n; b++){\n\t\tbd=(bd<<1)|tmp[a][b];\n\t      }\n\t    }\n\t    pats[upb(bd)].push_back(bd);\n\t    for (int a=i; a<=k; a++)\n\t      for (int b=j; b<=l; b++)\n\t\ttmp[a][b]=0;\n\t  }\n\t}\n      }\n    }\n\n    int bd=0;\n    for (int i=0; i<n; i++){\n      for (int j=0; j<n; j++){\n\tint t; cin>>t;\n\tbd=(bd<<1)|t;\n      }\n    }\n\n    queue<int> mm;\n    mm.push(bd);\n    close[bd]=true;\n    cls.push_back(bd);\n    while(!mm.empty()){\n      int dep=mm.front()>>25;\n      int cbd=mm.front()&0x1ffffff;\n      mm.pop();\n      int ub=upb(cbd);\n      for (int i=0; i<pats[ub].size(); i++){\n\tint nbd=cbd^pats[ub][i];\n\tif (nbd==0){\n\t  for (int i=0; i<=dep; i++)\n\t    cout<<\"myon\";\n\t  cout<<endl;\n\t  goto _exit;\n\t}\n\t//cout<<\"*** \"<<nbd<<endl;\n\tif (close[nbd]) continue;\n\tclose[nbd]=true;\n\tcls.push_back(nbd);\n\tmm.push(((dep+1)<<25)|nbd);\n      }\n    }\n  _exit:;\n    for (int i=0; i<cls.size(); i++)\n      close[cls[i]]=false;\n    cls.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint n;\nint field[6][6];\nchar memo[1 << 24];\n\nvoid printField() {\n  REP(y, n) {\n    REP(x, n) {\n      cout << field[y][x] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint encode() {\n  int ret = 0;\n  REP(y, n) REP(x, n) {\n    if (y == 0 && x == 0) { continue; }\n    ret |= field[y][x] << ((y * n) + x - 1);\n  }\n  return ret;\n}\n\nint calc(int y, int x) {\n  int state = encode();\n  if (memo[state] != -1) { return memo[state]; }\n  int ret = 100;\n  if (x == n) { ret = calc(y + 1, 0); }\n  else if (y == n) { ret = 0; }\n  else if (field[y][x] == 0) { ret = calc(y, x + 1); }\n  else {\n    field[y][x] = 0;\n    field[y][n] = 1;\n    field[n][x] = 1;\n    FOREQ(ny, y + 1, n) {\n      FOREQ(nx, x + 1, n) {\n        field[ny][n] = 1;\n        field[n][nx] = 1;\n        //if (field[ny][x] == 1 && field[y][nx] == 1 && field[ny][nx] == 1) {\n          //field[ny][x] = field[y][nx] = field[ny][nx] = 0;\n          field[ny][x] ^=1;\n          field[y][nx] ^=1;\n          field[ny][nx] ^=1;\n          ret = min(ret, calc(y, x + 1) + 1);\n          field[ny][x] ^=1;\n          field[y][nx] ^=1;\n          field[ny][nx] ^=1;\n          //field[ny][x] = field[y][nx] = field[ny][nx] = 1;\n        //}\n      }\n    }\n    field[y][x] = 1;\n  }\n  if (y == 0 && x == 0) { return ret; }\n  return memo[state] = ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    MEMSET(memo, -1);\n    MEMSET(field, 0);\n    REP(y, n) REP(x, n) {\n      scanf(\"%d\", &field[y][x]);\n    }\n    REP(y, n) REP(x, n) {\n      if (field[y][x] == 1) {\n        FOR(ny, y, n) FOR(nx, x, n) {\n          field[ny][nx] ^= 1;\n        }\n        field[y][x] = 1;\n      }\n    }\n    int ans = calc(0, 0);\n    while (ans--) { printf(\"myon\"); }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX_N (5)\nint n;\nchar memo[1<<25];\nint sq[6][6];\nint dfs(int bit){\n    if(~memo[bit]) { return memo[bit];}\n    int ans = (1<<25);\n     \n    for(int i = 0 ; i < n ; i++){\n        for(int j = 0 ; j < n ; j++){\n            if( bit >> (i*MAX_N+j) & 1){\n                for(int s1 = 1 ; s1 <= n-i ; s1++)\n                    for(int s2 = 1 ; s2 <= n-j ; s2++)\n                        ans = min( ans , 1 + dfs( bit ^ (sq[s1][s2] << (i*MAX_N+j) ) ) );\n                goto endfunction;\n            }\n        }\n    }\n    endfunction: return memo[bit] = ans;\n}\nint gen(int x,int y){\n    int ans = 0;\n    for(int i = 0 ; i < y ; i++)\n        for(int j = 0 ; j < x ; j++)\n            ans |= 1<< (i*MAX_N+j);\n    return ans;\n}\nint main(){\n    for(int i = 1 ; i <= 5 ; i++) for(int j = 1 ; j <= 5 ; j++) sq[i][j] = gen(j,i);\n    memset(memo,-1,sizeof(memo));\n    memo[0] = 0;\n     \n    while(cin >> n , n){\n        int bit = 0 , a;\n         \n        for(int i = 0 ; i < n ; i++)\n            for(int j = 0 ; j < n ; j++)\n                cin >> a , bit |= a << (i * MAX_N + j);\n        int r = dfs(bit);\n        for(int i = 0 ; i < r ; i++)\n            cout << \"myon\";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\t// 4*5 ãÌ myon ðSñ\n\tint n_ptn=0,ptn[150];\n\trep(i2,4) rep(i1,i2+1) rep(j2,5) rep(j1,j2+1) {\n\t\tint S=0;\n\t\tfor(int y=i1;y<=i2;y++) for(int x=j1;x<=j2;x++) S|=1<<y*5+x;\n\t\tptn[n_ptn++]=S;\n\t}\n\n\tstatic int dp[1<<20];\n\tmemset(dp,-1,sizeof dp);\n\tdp[0]=0;\n\tqueue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().first,S=Q.front().second; Q.pop();\n\t\trep(i,n_ptn) if(dp[S^ptn[i]]==-1) {\n\t\t\tdp[S^ptn[i]]=t+1;\n\t\t\tQ.push(make_pair(t+1,S^ptn[i]));\n\t\t}\n\t}\n\n\tint n_ptn2[5]={1,1,1,1,1},ptn2[5][26]={};\n\trep(i1,5) rep(j2,5) rep(j1,j2+1) {\n\t\tint S=0;\n\t\tfor(int y=i1;y<5;y++) for(int x=j1;x<=j2;x++) S|=1<<y*5+x;\n\t\tptn2[j1][n_ptn2[j1]++]=S;\n\t}\n\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint S0=0;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint a; scanf(\"%d\",&a);\n\t\t\tS0|=a<<i*5+j;\n\t\t}\n\n\t\tif(n<5){\n\t\t\trep(i,dp[S0]) printf(\"myon\"); puts(\"\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans=77;\n\t\trep(k0,n_ptn2[0]) rep(k1,n_ptn2[1]) rep(k2,n_ptn2[2]) rep(k3,n_ptn2[3]) rep(k4,n_ptn2[4]) {\n\t\t\tint cost=0;\n\t\t\tif(k0>0) cost++;\n\t\t\tif(k1>0) cost++;\n\t\t\tif(k2>0) cost++;\n\t\t\tif(k3>0) cost++;\n\t\t\tif(k4>0) cost++;\n\t\t\tint S=S0^ptn2[0][k0]^ptn2[1][k1]^ptn2[2][k2]^ptn2[3][k3]^ptn2[4][k4];\n\t\t\tif((S&((1<<20)-1))==S) ans=min(ans,dp[S]+cost);\n\t\t}\n\n\t\trep(i,ans) printf(\"myon\"); puts(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=n*n-1)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\t//passed[s]=false;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(true){\n\t\t\t\t\t\tif(dp[ns]!=INF){\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//passed[ns]=true;\n\t\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t\t\t\t//passed[ns]=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//passed[s]=false;\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\n\tfill(dp,dp+(1<<25),INF);\n\t//fill(minArrivingDepth,minArrivingDepth+(1<<20),INF);\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\t//cin>>bit;\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=min((char)(n*n),minStep(init,0));\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\t//cout<<\"myon\";\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n//bool passed[1<<25];\n\n\nint n;\nconst char INF=100;\nconst char STOP=-1;\n\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\t//if(depth!=0&&s==start)\n\t//\treturn INF;\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3){\n\t\treturn INF;\n\t}\n\tchar minCnt=INF;\n\t//if(passed[s]){\n\t//\treturn INF;\n\t//}\n\t//passed[s]=true;\n\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse{\n\t\t\t\t\t\tchar res=(char)(minStep(ns,depth+1));\n\t\t\t\t\t\t//if(res==STOP){\n\t\t\t\t\t\t//\treturn INF;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(res+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tfill(dp,dp+(1<<25),INF);\n\t\t//fill(passed,passed+(1<<25),false);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\nchar dp[1<<25];\n\nint n;\nconst char INF=100;\nint start;\n\nchar mC;\n\n// sÌóÔ©ç·×ÄÌrbgð0É·éÜÅÉ©©éÅ¬ñðÔ·\nchar minStep(int s,int depth){\n\tif(s==0)\n\t\treturn 0;\n\tif(dp[s]!=INF)\n\t\treturn dp[s];\n\t// [·¬éTõÍÅ¿Øé\n\tif(depth>=2*n+3)\n\t\treturn INF;\n\tchar minCnt=INF;\n\n\t// ÇÌÍÍðô¶ÌÎÛÆ·é©\n\t// ¶ãÌÀW\n\tfor(int miny = 0; miny < n; miny++){\n\t\tfor(int minx = 0; minx < n; minx++){\n\t\t\t// c\n\t\t\tfor(int height=1; height+miny-1<n; height++){\n\t\t\t\t// ¡\n\t\t\t\tfor(int width=1; width+minx-1<n; width++){\n\t\t\t\t\t// ¡ñß½êÌrbgð½]³¹AÄA\n\t\t\t\t\tint ns=s;\n\t\t\t\t\tfor(int i = miny; i < miny+height; i++){\n\t\t\t\t\t\tfor(int j = minx; j < minx+width; j++){\n\t\t\t\t\t\t\tint b=((ns>>(i*n+j))&1)^1;\n\t\t\t\t\t\t\t// bÌrbgðãü\n\t\t\t\t\t\t\tif(b==0)\n\t\t\t\t\t\t\t\tns&=~(1<<(i*n+j));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tns|=(b<<(i*n+j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ns==0){\n\t\t\t\t\t\tdp[s]=1;\n\t\t\t\t\t\treturn dp[s];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[ns]!=INF)\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(dp[ns]+1));\n\t\t\t\t\telse\n\t\t\t\t\t\tminCnt=min(minCnt,(char)(minStep(ns,depth+1)+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[s]=minCnt;\n\treturn minCnt;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)&&n!=0){\n\t\tfill(dp,dp+(1<<25),INF);\n\t\tmC=INF;\n\t\tint init=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint bit;\n\t\t\t\tscanf(\"%d\",&bit);\n\t\t\t\tinit|=(bit<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tstart=init;\n\t\tchar cnt=minStep(init,0);\n\t\tfor(char i = 0; i < cnt; i++)\n\t\t\tprintf(\"myon\");\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int INF = 30;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        vector<int> field(N);\n        for(int i = 0; i < N; ++i) {\n            int pat = 0;\n            for(int j = 0; j < N; ++j) {\n                int v;\n                cin >> v;\n                pat <<= 1;\n                pat |= v;\n            }\n            field[i] = pat;\n        }\n        vector<int> myons; // ティツ。ツ古」ツ?ォテ」ツ?凝」ツ?凝」ツつ砧yon\n        for(int c = 0; c < N; ++c) { // テ・ツ渉ウテァツォツッテ」ツ?ョテ、ツスツ催ァツスツョ\n            for(int w = 1; w <= N-c; ++w) {\n                int mask = ((1<<w)-1) << c;\n                myons.push_back(mask);\n                //cout << mask << endl;\n            }\n        }\n        const int M = myons.size();\n        // 0: prev\n        // 1: cur\n        vector<int> valid_pats[2];\n        vector<int> dp[2];\n        dp[0].resize(1<<M, INF);\n        dp[1].resize(1<<M, INF);\n        for(int r = 0; r < N; ++r) {\n            valid_pats[1].clear();\n            fill(dp[1].begin(), dp[1].end(), INF);\n            for(int pat = 0; pat < (1<<M); ++pat) {\n                int mask = 0;\n                for(int i = 0, ord = 1; i < M; ++i, ord <<= 1) {\n                    if(pat & ord) mask ^= myons[i];\n                }\n                if(mask == field[r]) {\n                    // Valid pattern\n                    int cost = INF;\n                    const int bits = __builtin_popcount(pat);\n                    if(r != 0) {\n                        for(vector<int>::iterator it = valid_pats[0].begin(); it != valid_pats[0].end(); ++it) {\n                            cost = min(cost, dp[0][*it] + bits - __builtin_popcount(pat & *it));\n                        }\n                    } else {\n                        cost = bits;\n                    }\n                    //cout << r << ' ' << pat << ' ' << cost << endl;\n                    dp[1][pat] = cost;\n                    valid_pats[1].push_back(pat);\n                }\n            }\n            valid_pats[0].swap(valid_pats[1]);\n            dp[0].swap(dp[1]);\n        }\n        int ans = INF;\n        for(vector<int>::iterator it = valid_pats[0].begin(); it != valid_pats[0].end(); ++it) {\n            ans = min(ans, dp[0][*it]);\n        }\n        for(int i = 0; i < ans; ++i) {\n            cout << \"myon\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//57\n#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int t,v;\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    int v=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tint b;\n\tcin>>b;\n\tv|=b<<i*n+j;\n      }\n    }\n    queue<S> que;\n    S is={0,v};\n    que.push(is);\n    static bitset<1<<25> s;\n    s.reset();\n    s.set(v);\n    for(;;){\n      S c=que.front();\n      if(c.v==0)break;\n      que.pop();\n      int j,k;\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  if(c.v>>j*n+k&1)goto next;\n\t}\n      }\n    next:\n      for(int l=j;l<n;l++){\n\tfor(int m=k;m<n;m++){\n\t  int nv=c.v;\n\t  for(int o=j;o<=l;o++){\n\t    for(int p=k;p<=m;p++){\n\t      nv^=1<<o*n+p;\n\t    }\n\t  }\n\t  if(s.test(nv))continue;\n\t  s.set(nv);\n\t  S ns={c.t+1,nv};\n\t  que.push(ns);\n\t}\n      }\n    }\n    for(int i=0;i<que.front().t;i++){\n      cout<<\"myon\";\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint n, f[5][5], s;\nint dp[1<<20];\n\nint rec(int at) {\n    if(at==5) return dp[s>>5];\n    if((s&(1<<at))==0) return rec(at+1);\n    int ans=1<<30;\n    rep(xe, 5) for(int ye=at; ye<5; ye++) {\n        rep(x, xe+1) for(int y=at; y<=ye; y++) s ^= 1<<(x*5+y);\n        ans = min(ans, rec(at+1)+1);\n        rep(x, xe+1) for(int y=at; y<=ye; y++) s ^= 1<<(x*5+y);\n    }\n    return ans;\n}\n\nint main() {\n    rep(i, 1<<20) dp[i]=1<<30;\n    dp[0] = 0;\n    rep(b, 1<<20) {\n        rep(xe, 4) rep(xs, xe+1) rep(ye, 5) rep(ys, ye+1) {\n            int nb=b;\n            for(int x=xs; x<=xe; x++) for(int y=ys; y<=ye; y++) {\n                nb ^= 1<<(x*5+y);\n            }\n            dp[nb] = min(dp[nb], dp[b]+1);\n        }\n    }\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        memset(f, 0, sizeof(f));\n        rep(i, n) rep(j, n) scanf(\"%d\", f[i]+j);\n        s = 0;\n        rep(i, n) rep(j, n) s|=f[i][j]<<(i*5+j);\n        int ans = n<5 ? dp[s] : rec(0);\n        rep(i, ans) printf(\"myon\");\n        putchar('\\n');\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint field[10][10];\nint n;\n\nint bfs(int ss){\n\tset<int> passed;\n\tqueue<int> q[2];\n\tint cur=0;\n\tint nxt=1;\n\tq[cur].push(ss);\n\tint cnt=0;\n\tpassed.insert(ss);\n\twhile(q[cur].size()){\n\t\twhile(q[cur].size()){\n\t\t\tint cs=q[cur].front();\n\t\t\tif(cs==0)return cnt;\n\t\t\tq[cur].pop();\n\t\t\t// csÌóÔ©çÚ®Å«éóÔðñ\n\t\t\tint minx,miny;\n\t\t\tminx=miny=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif((cs>>(i*n+j))&1){\n\t\t\t\t\t\tminx=j;\n\t\t\t\t\t\tminy=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(minx!=-1)break;\n\t\t\t}\n\t\t\t// EºÌÀWðè\n\t\t\tfor(int i=miny;i<n;i++){\n\t\t\t\tfor(int j=minx;j<n;j++){\n\t\t\t\t\t// ½]\n\t\t\t\t\tint ns=cs;\n\t\t\t\t\tfor(int k=miny;k<=i;k++){\n\t\t\t\t\t\tfor(int l=minx;l<=j;l++){\n\t\t\t\t\t\t\tif((ns>>(k*n+l))&1)ns&=~(1<<(k*n+l));\n\t\t\t\t\t\t\telse ns|=(1<<(k*n+l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(passed.find(ns)==passed.end()){\n\t\t\t\t\t\tq[nxt].push(ns);\n\t\t\t\t\t\tpassed.insert(ns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(cur,nxt);\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tint ss=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j])ss|=(1<<(i*n+j));\n\t\t\t}\n\t\t}\n\t\tint cnt=bfs(ss);\n\t\tfor(int i=0;i<cnt;i++)cout<<\"myon\";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n// X[sy][sx][gy][gx] := 5*5 テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ (sx,sy) - (gx,gy)テ」ツ?ォmyonテ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ、ツスツソテ」ツ??bit\n//int X[5][5][5][5] = {0};\n// dp[bits] := 5*5 テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ テァツ環カテヲツ??bits テ」ツ?ョテヲツ慊?ァツ淞ュテヲツ可凝ヲツ閉ーテ」ツつ津ィツソツ氾」ツ??\nchar dp[1<<25];\n\n// \"myon\" ** n テ」ツつ津ィツソツ氾」ツ??\n/*string ans_myon(int k){\n\tstring res;\n\tfor(int i=0 ; i < k ; i++ ){\n\t\tres += \"myon\";\n\t}\n\treturn res;\n}*/\n\n/*void init(){\n\tfor(int i=0 ; i < (1<<25) ; i++ ){\n\t\tdp[i] = -1;\n\t}\n\tfor(int ly = 0 ; ly < 5 ; ly++ ){\n\t\tfor(int lx = 0 ; lx < 5 ; lx++ ){\n\t\t\tfor(int ry = ly ; ry < 5 ; ry++ ){\n\t\t\t\tfor(int rx = lx ; rx < 5 ; rx++ ){\n\t\t\t\t\tfor(int y = ly ; y <= ry ; y++ ){\n\t\t\t\t\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\t\t\t\t\tX[ly][lx][ry][rx] |= (1 << (y * 5 + x));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nint get_xor(int lx, int ly, int rx, int ry){\n\tint res=0;\n\tfor(int y = ly ; y <= ry ; y++ ){\n\t\tfor(int x = lx ; x <= rx ; x++ ){\n\t\t\tres |= (1 << (y * 5 + x));\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(int bits){\n    if( dp[bits] != -1 ) return dp[bits];\n    \n    int sx, sy;\n    for(int i=0 ; i < 25 ; i++ ){\n        if( bits & (1 << i) ){\n            sx = i % 5; sy = i / 5; break;\n        }\n    }\n    int res = INF;\n    for(int y = sy ; y < 5 ; y++ ){\n        for(int x = sx ; x < 5 ; x++ ){\n            //int next = bits ^ X[sy][sx][y][x];\n            int next = bits ^ get_xor(sx,sy,x,y);\n            res = min(res, solve(next)+1 );\n        }\n    }\n    return dp[bits] = res;\n}\n\nint main(){\n\tint n;\n\t//init();\n\tfor(int i=0 ; i < (1<<25) ; i++ ) dp[i] = -1;\n\twhile( cin >> n , n ){\n\t\tint bits = 0;\n\t\tfor(int i=0 ; i < 25 ; i++ ){\n\t\t\tint e = 0;\n\t\t\tif( i % 5 < n && i / 5 < n ){\n\t\t\t\tcin >> e;\n\t\t\t}\n\t\t\tbits = (bits << 1) + e;\n\t\t}\n\t\tint ans = solve(bits);\n\t\tfor(int i=0 ; i < ans ; i++ )\n\t\t\tcout << \"myon\";\n\t\tcout << endl;\n\t\t//cout << ans_myon(ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\ntypedef vector<vector<bool> > tab;\n\nconst int size = 5;\nint enc(const tab& f)\n{\n    int res = 0;\n    for (int y = 0; y < size; ++y)\n        for (int x = 0; x < size; ++x)\n            res = (res << 1) | f[y][x];\n    return res;\n}\nmap<int, int> dp;\nint recur(const tab& f, int sum, int& min_res)\n{\n    // print2d(f, size,size);\n\n    const int e = enc(f);\n    if (dp.count(e))\n    {\n        if (dp[e] == -1)\n            return 1 << 29;\n        else\n        {\n            min_swap(min_res, sum + dp[e]);\n            return dp[e];\n        }\n    }\n    else if (sum >= min_res)\n        return 1 << 29;\n\n    dp[e] = -1; // prevent\n\n    int min_x = size, min_y = size, max_x = 0, max_y = 0;\n    for (int y = 0; y < size; ++y)\n    {\n        for (int x = 0; x < size; ++x)\n        {\n            if (f[y][x])\n            {\n                min_swap(min_x, x);\n                max_swap(max_x, x);\n                min_swap(min_y, y);\n                max_swap(max_y, y);\n            }\n        }\n    }\n\n    int res = 1 << 29;\n    for (int yy = max_y; yy >= min_y; --yy)\n    {\n        for (int xx = max_x; xx >= min_x; --xx)\n        {\n            tab nf = f;\n            for (int y = min_y; y <= yy; ++y)\n                for (int x = min_x; x <= xx; ++x)\n                    nf[y][x] = !nf[y][x];\n            min_swap(res, recur(nf, sum + 1, min_res) + 1);\n        }\n    }\n\n    return dp[e] = res;\n}\nint main()\n{\n    string myon[33];\n    myon[0] = \"\";\n    for (int i = 0; i < 25; ++i)\n        myon[i + 1] = myon[i] + \"myon\";\n\n    dp[0] = 0;\n\n    int n;\n    while (cin >> n, n)\n    {\n        tab f(size, vector<bool>(size));\n        for (int y = 0; y < n; ++y)\n        {\n            for (int x = 0; x < n; ++x)\n            {\n                int t;\n                cin >> t;\n                f[y][x] = t == 1;\n            }\n        }\n\n\n        int t = 1 << 29;\n        int times = recur(f, 0, t);\n        cout << myon[times] << endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5];\nchar memo[1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[b] >= 0) return memo[b];\n\n\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(r1*n + c1))) goto next;\n\t}\nnext:\n\tans = n*n;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\treturn memo[b] = ans;\n}\n\nvoid init()\n{\n\tint r1, r2, c1, c2, r, c;\n\n\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++)\n\t\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++)\n\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\tmap[r1][c1][r2][c2] |= (1<<(r*n+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\twhile (n = in()) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tinit();\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += n) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5];\nchar memo[1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[b] >= 0) return memo[b];\n\n\tfor (k = r1 = 0; r1 < n; r1++, k += 5) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(k + c1))) goto next;\n\t}\nnext:\n\tans = 25;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\treturn memo[b] = ans;\n}\n\nvoid init()\n{\n\tint r1, r2, c1, c2, r, c;\n\n\tfor (r1 = 0; r1 < 5; r1++) for (c1 = 0; c1 < 5; c1++)\n\t\tfor (r2 = r1; r2 < 5; r2++) for (c2 = c1; c2 < 5; c2++)\n\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\tmap[r1][c1][r2][c2] |= (1<<(r*5+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\tmemset(memo, -1, sizeof(memo));\n\tinit();\n\twhile (n = in()) {\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += 5) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5];\nchar memo[1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[b] >= 0) return memo[b];\n\n\tfor (k = r1 = 0; r1 < n; r1++, k += n) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(k + c1))) goto next;\n\t}\nnext:\n\tans = n*n;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) { ans = k; if (ans == 1) break; }\n\t}\n\treturn memo[b] = ans;\n}\n\nvoid init()\n{\n\tint r1, r2, c1, c2, r, c;\n\n\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++)\n\t\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++)\n\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\tmap[r1][c1][r2][c2] |= (1<<(r*n+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\twhile (n = in()) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tinit();\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += n) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5][5];\nint memo[5][1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[n-1][b] >= 0) return memo[n-1][b];\n\n\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(r1*n + c1))) goto next;\n\t}\n\nnext:\n\tans = n*n;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[n-1][r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\n\treturn memo[n-1][b] = ans;\n}\n\nvoid init()\n{\n\tint n, r1, r2, c1, c2, r, c;\n\n\tfor (n = 1; n <= 5; n++)\n\t\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++)\n\t\t\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++)\n\t\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\t\tmap[n-1][r1][c1][r2][c2] |= (1<<(r*n+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\tinit();\n\twhile (n = in()) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += n) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5];\nchar memo[1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 1;\n\tif (memo[b] > 0) return memo[b];\n\n\tfor (k = r1 = 0; ; r1++, k += 5) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(k + c1))) goto next;\n\t}\n\nnext:\n\tans = 25;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\treturn memo[b] = ans;\n}\n\nvoid init()\n{\n\tint r1, r2, c1, c2, r, c;\n\n\tfor (r1 = 0; r1 < 5; r1++) for (c1 = 0; c1 < 5; c1++)\n\t\tfor (r2 = r1; r2 < 5; r2++) for (c2 = c1; c2 < 5; c2++)\n\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\tmap[r1][c1][r2][c2] |= (1<<(r*5+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\tinit();\n\twhile (n = in()) {\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += 5) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b)-1;\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5][5];\nshort memo[5][1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[n-1][b] >= 0) return memo[n-1][b];\n\n\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(r1*n + c1))) goto next;\n\t}\n\nnext:\n\tans = n*n;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[n-1][r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\n\treturn memo[n-1][b] = ans;\n}\n\nvoid init()\n{\n\tint n, r1, r2, c1, c2, r, c;\n\n\tfor (n = 1; n <= 5; n++)\n\t\tfor (r1 = 0; r1 < n; r1++) for (c1 = 0; c1 < n; c1++)\n\t\t\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++)\n\t\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\t\tmap[n-1][r1][c1][r2][c2] |= (1<<(r*n+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\tinit();\n\tmemset(memo, -1, sizeof(memo));\n\twhile (n = in()) {\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += n) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOL 1059 Mysterious Onslaught\n// 2018.2.18 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint map[5][5][5][5];\nchar memo[1<<25];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int b)\n{\n\tint r1, c1, r2, c2, k, ans;\n\n\tif (!b) return 0;\n\tif (memo[b] >= 0) return memo[b];\n\n\tfor (k = r1 = 0; r1 < n; r1++, k += 5) for (c1 = 0; c1 < n; c1++) {\n\t\tif (b & (1<<(k + c1))) goto next;\n\t}\n\treturn memo[b] = 0;\nnext:\n\tans = 25;\n\tfor (r2 = r1; r2 < n; r2++) for (c2 = c1; c2 < n; c2++) {\n\t\tk = b ^ map[r1][c1][r2][c2];\n\t\tk = calc(k) + 1;\n\t\tif (ans > k) ans = k;\n\t}\n\treturn memo[b] = ans;\n}\n\nvoid init()\n{\n\tint r1, r2, c1, c2, r, c;\n\n\tfor (r1 = 0; r1 < 5; r1++) for (c1 = 0; c1 < 5; c1++)\n\t\tfor (r2 = r1; r2 < 5; r2++) for (c2 = c1; c2 < 5; c2++)\n\t\t\tfor (r = r1; r <= r2; r++) for (c = c1; c <= c2; c++)\n\t\t\t\tmap[r1][c1][r2][c2] |= (1<<(r*5+c));\n}\n\nint main()\n{\n\tint r, c, b, k;\n\n\tmemset(memo, -1, sizeof(memo));\n\tinit();\n\twhile (n = in()) {\n\t\tb = 0;\n\t\tfor (k = r = 0; r < n; r++, k += 5) for (c = 0; c < n; c++) {\n\t\t\tif (getchar_unlocked() & 1) b |= 1 << (k+c);\n\t\t\tgetchar_unlocked();\n\t\t}\n\t\tk = calc(b);\n\t\twhile (k--) printf(\"myon\");\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT\t((long)(1 << 30))\n#define MAX_N\t(5)\n#define MAX_BITS\t((long)(1 << (MAX_N * MAX_N)))\n\n/* global variables */\n\nstatic int n;\nstatic unsigned char dists[MAX_BITS];\nstatic long masks[MAX_N][MAX_N][MAX_N][MAX_N];\n\n/* subroutines */\n\nlong make_mask(int x0, int x1, int y0, int y1) {\n  int y;\n  long bits, hbits;\n\n  hbits = ((1 << (x1 - x0 + 1)) - 1) << x0;\n  bits = 0;\n\n  for (y = y0; y <= y1; y++)\n    bits |= (hbits << (y * n));\n\n  return bits;\n}\n\nint min_dist(long bits) {\n  int d, id, md, x0, x1, y0, y1;\n  long bits0;\n\n  if (dists[bits] < 255) return dists[bits];\n\n  for (id = 0; ((bits >> id) & 1) == 0; id++);\n\n  x0 = id % n;\n  y0 = id / n;\n  md = MAX_INT;\n\n  for (y1 = n - 1; y1 >= y0; y1--)\n    for (x1 = n - 1; x1 >= x0; x1--) {\n      bits0 = bits ^ masks[x0][x1][y0][y1];\n      d = min_dist(bits0) + 1;\n      if (md > d) md = d;\n    }\n\n  return (dists[bits] = md);\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int d, i, md, x, x0, x1, y, y0, y1;\n  long st;\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n\n    st = 0;\n\n    for (y = 0; y < n; y++)\n      for (x = 0; x < n; x++) {\n\tscanf(\"%d\", &d);\n\tif (d)\n\t  st |= (1 << (x + y * n));\n      }\n\n    memset(masks, 0, sizeof(masks));\n\n    for (x0 = 0; x0 < n; x0++)\n      for (x1 = x0; x1 < n; x1++)\n\tfor (y0 = 0; y0 < n; y0++)\n\t  for (y1 = y0; y1 < n; y1++)\n\t    masks[x0][x1][y0][y1] = make_mask(x0, x1, y0, y1);\n\n    memset(dists, 255, sizeof(dists));\n    dists[0] = 0;\n\n    md = min_dist(st);\n\n    for (i = 0; i < md; i++) printf(\"myon\");\n    putchar('\\n');\n  }\n\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 5;\n\t\n\tpublic static boolean check(final int x, final int y, final int n, boolean[][] field){\n\t\tfor(int cur_x = x; cur_x < n; cur_x++){\n\t\t\tif(field[y][cur_x]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int cur_y = y + 1; cur_y < n; cur_y++){\n\t\t\tfor(int cur_x = 0; cur_x < n; cur_x++){\n\t\t\t\tif(field[cur_y][cur_x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(final int x, final int y, final int n, boolean[][] field, final int flips, final int limit){\n\t\tfinal int next_x = x == n - 1 ? 0 : x + 1;\n\t\tfinal int next_y = x == n - 1 ? y + 1 : y;\n\t\t\n\t\t//System.out.println(x + \" \" + y + \" \" + flips + \" \" + limit);\n\t\tif(x == n - 1 && y == n - 1){\n\t\t\treturn field[y][x] ? 1 : 0;\n\t\t}else if(check(x, y, n, field)){\n\t\t\treturn 0;\n\t\t}else if(!field[y][x]){\n\t\t\treturn dfs(next_x, next_y, n, field, flips, limit);\n\t\t}\n\t\t\n\t\tint ret = limit;\n\t\t\n\t\tfor(int lim_y = n - 1; lim_y >= y; lim_y--){\n\t\t\tfor(int lim_x = n - 1; lim_x >= x; lim_x--){\t\t\n\t\t\t\tif(flips >= ret){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret = Math.min(ret, dfs(next_x, next_y, n, field, flips + 1, ret));\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret + 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] field = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfield[i][j] = sc.nextInt() == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int ret = dfs(0, 0, n, field, 0, 25);\n\t\t\t\n\t\t\tfor(int i = 0; i < ret; i++){\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n    public static void main(String args[]) throws Exception\n    { new Main();}\n  \n    static int MAX = 9999;\n    \n    Main(){\n    \tScanner cin = new Scanner(System.in);\n    \tint i,j,k,num;\n    \twhile(true){\n    \t\tint n;\n    \t\tn = cin.nextInt();\n    \t\tif(n==0) break;\n    \t\tint input[] = new int[n];\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tinput[i] = 0;\n    \t\t\tfor(j=0;j<n;j++){\n    \t\t\t\tif(cin.nextInt()!=0) input[i] += 1<<j;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tnum = n*(n+1)/2;\n    \t\tint range[] = new int[num];\n    \t\tint count = 0;\n    \t\tfor(i=0;i<=n;i++){\n    \t\t\tfor(j=i+1;j<=n;j++){\n    \t\t\t\trange[count++] = (1<<j)- (1<<i);\n    \t\t\t}\n    \t\t}\n    \t\tint memo[] = new int[1<<num];\n    \t\tint plus[] = new int[1<<num];\n    \t\tfor(i=0;i<(1<<num);i++){\n    \t\t\tmemo[i] = 0;\n    \t\t\tplus[i] = 0;\n    \t\t\tfor(j=0;j<num;j++){\n    \t\t\t\tif(((1<<j)&i)!=0){\n    \t\t\t\t\tmemo[i] ^= range[j];\n    \t\t\t\t\tplus[i]++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tArrayList<LinkedList<Integer> > list = new ArrayList<LinkedList<Integer> >(0);\n    \t\tfor(i=0;i<(1<<n);i++) list.add(new LinkedList<Integer>());\n    \t\tfor(i=0;i<(1<<num);i++){\n    \t\t\tlist.get(memo[i]).add(i);\n    \t\t}\n    \t\tint dp[] = new int[1<<num];\n    \t\tfor(j=0;j<(1<<num);j++) dp[j] = MAX;\n    \t\tdp[0] = 0;\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tint newdp[] = new int[1<<num];\n    \t\t\tfor(j=0;j<(1<<num);j++) newdp[j] = MAX;\n    \t\t\tfor(j=0;j<(1<<num);j++){\n    \t\t\t\tif(dp[j]==MAX) continue;\n    \t\t\t\tint need = memo[j] ^ input[i];\n    \t\t\t\tfor(int l : list.get(need)){\n    \t\t\t\t\tnewdp[j ^ l] = Math.min(newdp[j ^ l], dp[j]+plus[l]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tdp = newdp.clone();\n    \t\t}\n    \t\tint res = MAX;\n    \t\tfor(j=0;j<(1<<num);j++) res = Math.min(res, dp[j]+Integer.bitCount(j));\n    \t\tfor(j=0;j<res/2;j++) System.out.print(\"myon\");\n    \t\tSystem.out.println();\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Myon\n{\n    public static void main(String args[]) throws Exception\n    { new Myon();}\n  \n    static int MAX = 9999;\n    \n    Myon(){\n    \tScanner cin = new Scanner(System.in);\n    \tint i,j,k,num;\n    \twhile(true){\n    \t\tint n;\n    \t\tn = cin.nextInt();\n    \t\tif(n==0) break;\n    \t\tint input[] = new int[n];\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tinput[i] = 0;\n    \t\t\tfor(j=0;j<n;j++){\n    \t\t\t\tif(cin.nextInt()!=0) input[i] += 1<<j;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tnum = n*(n+1)/2;\n    \t\tint range[] = new int[num];\n    \t\tint count = 0;\n    \t\tfor(i=0;i<=n;i++){\n    \t\t\tfor(j=i+1;j<=n;j++){\n    \t\t\t\trange[count++] = (1<<j)- (1<<i);\n    \t\t\t}\n    \t\t}\n    \t\tint memo[] = new int[1<<num];\n    \t\tint plus[] = new int[1<<num];\n    \t\tfor(i=0;i<(1<<num);i++){\n    \t\t\tmemo[i] = 0;\n    \t\t\tplus[i] = 0;\n    \t\t\tfor(j=0;j<num;j++){\n    \t\t\t\tif(((1<<j)&i)!=0){\n    \t\t\t\t\tmemo[i] ^= range[j];\n    \t\t\t\t\tplus[i]++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t//System.out.println(\"start!\");\n    \t\tint dp[] = new int[1<<num];\n    \t\tfor(j=0;j<(1<<num);j++) dp[j] = MAX;\n    \t\tdp[0] = 0;\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tint newdp[] = new int[1<<num];\n    \t\t\tfor(j=0;j<(1<<num);j++) newdp[j] = MAX;\n    \t\t\tfor(j=0;j<(1<<num);j++){\n    \t\t\t\tif(dp[j]==MAX) continue;\n    \t\t\t\tint need = memo[j] ^ input[i];\n    \t\t\t\t//System.out.println(\"test\");\n    \t\t\t\tfor(k=0;k<(1<<num);k++){\n    \t\t\t\t\tif(need != memo[k]) continue;\n    \t\t\t\t\t//System.out.println(\"test\");\n    \t\t\t\t\tnewdp[j ^ k] = Math.min(newdp[j ^ k], dp[j]+plus[k]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tdp = newdp.clone();\n    \t\t}\n    \t\tint res = MAX;\n    \t\tfor(j=0;j<(1<<num);j++) res = Math.min(res, dp[j]+Integer.bitCount(j));\n    \t\t//System.out.println(res);\n    \t\tfor(j=0;j<res/2;j++) System.out.print(\"myon\");\n    \t\tSystem.out.println();\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[][][][] masks = new int[5][5][5][5];\n\n\tstatic int solve(int start) {\n\t\tHashSet<Integer> visited = new HashSet<Integer>();\n\t\tvisited.add(start);\n\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\t\tcur.add(start);\n\t\tfor (int i = 0; i < 12; ++i) {\n//\t\t\tSystem.out.println(i + \" \" + cur.size());\n\t\t\tArrayList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor (int v : cur) {\n\t\t\t\tint zero = Integer.numberOfTrailingZeros(v);\n\t\t\t\tint r = zero / 5;\n\t\t\t\tint c = zero % 5;\n\t\t\t\tfor (int er = r; er < N; ++er) {\n\t\t\t\t\tfor (int ec = c; ec < N; ++ec) {\n\t\t\t\t\t\tint n = v ^ masks[r][c][er][ec];\n\t\t\t\t\t\tif (n == 0) return i + 1;\n\t\t\t\t\t\tif (!visited.contains(n)) {\n\t\t\t\t\t\t\tvisited.add(n);\n\t\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = next;\n\t\t}\n\t\treturn 13;\n\t}\n\n\tstatic boolean bit(int state, int r, int c) {\n\t\treturn (state & (1 << (r * 5 + c))) != 0;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tfor (int k = i; k < 5; ++k) {\n\t\t\t\t\tfor (int l = j; l < 5; ++l) {\n\t\t\t\t\t\tfor (int r = i; r <= k; ++r) {\n\t\t\t\t\t\t\tfor (int c = j; c <= l; ++c) {\n\t\t\t\t\t\t\t\tmasks[i][j][k][l] |= (1 << (r * 5 + c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint start = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tint v = sc.nextInt();\n\t\t\t\t\tif (v == 1) start += (1 << (i * 5 + j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = solve(start);\n\t\t\tfor (int j = 0; j < ans; ++j) {\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Mysterious Onslaught\npublic class Main{\n\n\tint[] d;\n\tint res, M = (0x1f)<<20;\n\tList<Integer>[] mask;\n\t\n\tvoid f(int S, int depth, int k){\n\t\tif((S&M)==0){\n\t\t\tres = Math.min(res, depth+d[S]);\n\t\t\treturn;\n\t\t}\n\t\tif(res<=depth+d[(0xfffff)&S]|| k==5)return;\n\t\tfor(int m:mask[k]){\n\t\t\tf(S^m, depth+1, k+1);\n\t\t}\n\t\tf(S, depth, k+1);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\td = new int[1<<20];\n\t\tint INF = 1<<28;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint S = q.poll();\n\t\t\tfor(int i=0;i<4;i++)for(int j=0;j<5;j++)for(int h=i;h<4;h++)for(int w=j;w<5;w++){\n\t\t\t\tint ns = S;\n\t\t\t\tfor(int y=i;y<=h;y++)for(int x=j;x<=w;x++)ns^=1<<(y*5+x);\n\t\t\t\tif(d[ns]==INF){\n\t\t\t\t\td[ns] = d[S]+1;\n\t\t\t\t\tq.add(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask = new List[5];\n\t\tfor(int j=0;j<5;j++){\n\t\t\tmask[j] = new ArrayList<Integer>();\n\t\t\tfor(int h=4;h>=0;h--)for(int w=j;w<5;w++){\n\t\t\t\tint m = 0;\n\t\t\t\tfor(int y=4;y>=h;y--)for(int x=j;x<=w;x++)m+=1<<(y*5+x);\n\t\t\t\tmask[j].add(m);\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint x = 0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(sc.nextInt()==1)x|=1<<(i*5+j);\n\t\t\tres = 9;\n\t\t\tif(n<=4)res=d[x];\n\t\t\telse f(x, 0, 0);\n\t\t\twhile(res--!=0)System.out.print(\"myon\");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\n\tstatic int solve(int start) {\n\t\tHashMap<Integer, Integer> visited = new HashMap<Integer, Integer>();\n\t\tvisited.put(start, 0);\n\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\t\tcur.add(start);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tArrayList<Integer> next = new ArrayList<Integer>();\n\t\t\t\tfor (int st : cur) {\n\t\t\t\t\tif (!bit(st, i, j)) {\n\t\t\t\t\t\tnext.add(st);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = i; k < N; ++k) {\n\t\t\t\t\t\tfor (int l = j; l < N; ++l) {\n\t\t\t\t\t\t\tint nv = st;\n\t\t\t\t\t\t\tfor (int r = i; r <= k; ++r) {\n\t\t\t\t\t\t\t\tfor (int c = j; c <= l; ++c) {\n\t\t\t\t\t\t\t\t\tnv ^= (1 << (r * N + c));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint count = visited.get(st) + 1;\n\t\t\t\t\t\t\tif (visited.containsKey(nv)) {\n\t\t\t\t\t\t\t\tif (count < visited.get(nv)) {\n\t\t\t\t\t\t\t\t\tvisited.put(nv, count);\n\t\t\t\t\t\t\t\t\tnext.add(nv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvisited.put(nv, count);\n\t\t\t\t\t\t\t\tnext.add(nv);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\t\treturn visited.get(0);\n\t}\n\n\tstatic boolean bit(int state, int r, int c) {\n\t\treturn (state & (1 << (r * N + c))) != 0;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint start = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tint v = sc.nextInt();\n\t\t\t\t\tif (v == 1) start += (1 << (i * N + j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = solve(start);\n\t\t\tfor (int j = 0; j < ans; ++j) {\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 5;\n\t\n\tpublic static boolean check(final int x, final int y, final int n, boolean[][] field){\n\t\tfor(int cur_x = x; cur_x < n; cur_x++){\n\t\t\tif(field[y][cur_x]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int cur_y = y + 1; cur_y < n; cur_y++){\n\t\t\tfor(int cur_x = 0; cur_x < n; cur_x++){\n\t\t\t\tif(field[cur_y][cur_x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(final int x, final int y, final int n, boolean[][] field, final int flips, final int limit){\n\t\tfinal int next_x = x == n - 1 ? 0 : x + 1;\n\t\tfinal int next_y = x == n - 1 ? y + 1 : y;\n\t\t\n\t\t//System.out.println(x + \" \" + y + \" \" + flips + \" \" + limit);\n\t\tif(flips > limit){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}else if(check(x, y, n, field)){\n\t\t\treturn 0;\n\t\t}else if(x == n - 1 && y == n - 1){\n\t\t\treturn field[y][x] ? 1 : 0;\n\t\t}else if(!field[y][x]){\n\t\t\treturn dfs(next_x, next_y, n, field, flips, limit);\n\t\t}\n\t\t\n\t\tint ret = limit;\n\t\t\n\t\tfor(int lim_y = n - 1; lim_y >= y; lim_y--){\n\t\t\tfor(int lim_x = n - 1; lim_x >= x; lim_x--){\t\t\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret = Math.min(ret, dfs(next_x, next_y, n, field, flips + 1, ret));\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret + 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] field = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfield[i][j] = sc.nextInt() == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int ret = dfs(0, 0, n, field, 0, 25);\n\t\t\t\n\t\t\tfor(int i = 0; i < ret; i++){\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Mysterious Onslaught\npublic class Main{\n\n\tint[] d;\n\tint res, M = (0x1f)<<20;\n\tList<Integer>[] mask;\n\t\n\tvoid f(int S, int depth, int k){\n\t\tif((S&M)==0){\n\t\t\tres = Math.min(res, depth+d[S]);\n\t\t\treturn;\n\t\t}\n\t\tif(res<=depth|| k==5)return;\n\t\tfor(int m:mask[k]){\n\t\t\tf(S^m, depth+1, k+1);\n\t\t}\n\t\tf(S, depth, k+1);\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\td = new int[1<<20];\n\t\tint INF = 1<<28;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint S = q.poll();\n\t\t\tfor(int i=0;i<4;i++)for(int j=0;j<5;j++)for(int h=i;h<4;h++)for(int w=j;w<5;w++){\n\t\t\t\tint ns = S;\n\t\t\t\tfor(int y=i;y<=h;y++)for(int x=j;x<=w;x++)ns^=1<<(y*5+x);\n\t\t\t\tif(d[ns]==INF){\n\t\t\t\t\td[ns] = d[S]+1;\n\t\t\t\t\tq.add(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask = new List[5];\n\t\tfor(int j=0;j<5;j++){\n\t\t\tmask[j] = new ArrayList<Integer>();\n\t\t\tfor(int h=4;h>=0;h--)for(int w=j;w<5;w++){\n\t\t\t\tint m = 0;\n\t\t\t\tfor(int y=4;y>=h;y--)for(int x=j;x<=w;x++)m+=1<<(y*5+x);\n\t\t\t\tmask[j].add(m);\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint x = 0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(sc.nextInt()==1)x|=1<<(i*5+j);\n\t\t\tres = 9;\n\t\t\tif(n<=4)res=d[x];\n\t\t\telse f(x, 0, 0);\n\t\t\twhile(res--!=0)System.out.print(\"myon\");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n    public static void main(String args[]) throws Exception\n    { new Main();}\n  \n    static int MAX = 9999;\n    \n    Main(){\n    \tScanner cin = new Scanner(System.in);\n    \tint i,j,k,num;\n    \twhile(true){\n    \t\tint n;\n    \t\tn = cin.nextInt();\n    \t\tif(n==0) break;\n    \t\tint input[] = new int[n];\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tinput[i] = 0;\n    \t\t\tfor(j=0;j<n;j++){\n    \t\t\t\tif(cin.nextInt()!=0) input[i] += 1<<j;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tnum = n*(n+1)/2;\n    \t\tint range[] = new int[num];\n    \t\tint count = 0;\n    \t\tfor(i=0;i<=n;i++){\n    \t\t\tfor(j=i+1;j<=n;j++){\n    \t\t\t\trange[count++] = (1<<j)- (1<<i);\n    \t\t\t}\n    \t\t}\n    \t\tint memo[] = new int[1<<num];\n    \t\tint plus[] = new int[1<<num];\n    \t\tfor(i=0;i<(1<<num);i++){\n    \t\t\tmemo[i] = 0;\n    \t\t\tplus[i] = 0;\n    \t\t\tfor(j=0;j<num;j++){\n    \t\t\t\tif(((1<<j)&i)!=0){\n    \t\t\t\t\tmemo[i] ^= range[j];\n    \t\t\t\t\tplus[i]++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t//System.out.println(\"start!\");\n    \t\tint dp[] = new int[1<<num];\n    \t\tfor(j=0;j<(1<<num);j++) dp[j] = MAX;\n    \t\tdp[0] = 0;\n    \t\tfor(i=0;i<n;i++){\n    \t\t\tint newdp[] = new int[1<<num];\n    \t\t\tfor(j=0;j<(1<<num);j++) newdp[j] = MAX;\n    \t\t\tfor(j=0;j<(1<<num);j++){\n    \t\t\t\tif(dp[j]==MAX) continue;\n    \t\t\t\tint need = memo[j] ^ input[i];\n    \t\t\t\t//System.out.println(\"test\");\n    \t\t\t\tfor(k=0;k<(1<<num);k++){\n    \t\t\t\t\tif(need != memo[k]) continue;\n    \t\t\t\t\t//System.out.println(\"test\");\n    \t\t\t\t\tnewdp[j ^ k] = Math.min(newdp[j ^ k], dp[j]+plus[k]);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tdp = newdp.clone();\n    \t\t}\n    \t\tint res = MAX;\n    \t\tfor(j=0;j<(1<<num);j++) res = Math.min(res, dp[j]+Integer.bitCount(j));\n    \t\t//System.out.println(res);\n    \t\tfor(j=0;j<res/2;j++) System.out.print(\"myon\");\n    \t\tSystem.out.println();\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 5;\n\t\n\tpublic static boolean check(final int x, final int y, final int n, boolean[][] field){\n\t\tfor(int cur_x = x; cur_x < n; cur_x++){\n\t\t\tif(field[y][cur_x]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int cur_y = y + 1; cur_y < n; cur_y++){\n\t\t\tfor(int cur_x = 0; cur_x < n; cur_x++){\n\t\t\t\tif(field[cur_y][cur_x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(final int x, final int y, final int n, boolean[][] field, final int flips, final int limit){\n\t\tfinal int next_x = x == n - 1 ? 0 : x + 1;\n\t\tfinal int next_y = x == n - 1 ? y + 1 : y;\n\t\t\n\t\t//System.out.println(x + \" \" + y + \" \" + flips + \" \" + limit);\n\t\tif(x == n - 1 && y == n - 1){\n\t\t\treturn field[y][x] ? flips + 1 : flips;\n\t\t}else if(check(x, y, n, field)){\n\t\t\treturn flips;\n\t\t}else if(!field[y][x]){\n\t\t\treturn dfs(next_x, next_y, n, field, flips, limit);\n\t\t}\n\t\t\n\t\tint ret = limit;\n\t\t\n\t\tfor(int lim_y = n - 1; lim_y >= y; lim_y--){\n\t\t\tfor(int lim_x = n - 1; lim_x >= x; lim_x--){\t\t\n\t\t\t\tif(flips >= ret){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret = Math.min(ret, dfs(next_x, next_y, n, field, flips + 1, ret));\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void test(int n){\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\t\n\t\tboolean[][] field = new boolean[MAX][MAX];\n\t\t\n\t\tfor(int t = 0; t < n; t++){\n\t\t\tSystem.out.println(\"iteration : \" + t);\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tfield[i][j] = Math.random() > 0.5 ? true : false;\n\t\t\t\t\t//System.out.print((field[i][j] ? 1 : 0) + \" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tfinal int ret = dfs(0, 0, 5, field, 0, 100);\n\t\t\t\n\t\t\tmax = Math.max(max, ret);\n\t\t\tmin = Math.min(min, ret);\n\t\t}\n\t\t\n\t\tSystem.out.println(max + \" \" + min);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] field = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//test(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfield[i][j] = sc.nextInt() == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int ret = dfs(0, 0, n, field, 0, 7);\n\t\t\t//System.out.println(ret);\n\t\t\t\n\t\t\tfor(int i = 0; i < ret; i++){\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int MAX = 5;\n\t\n\tpublic static boolean check(final int x, final int y, final int n, boolean[][] field){\n\t\tfor(int cur_x = x; cur_x < n; cur_x++){\n\t\t\tif(field[y][cur_x]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int cur_y = y + 1; cur_y < n; cur_y++){\n\t\t\tfor(int cur_x = 0; cur_x < n; cur_x++){\n\t\t\t\tif(field[cur_y][cur_x]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int dfs(final int x, final int y, final int n, boolean[][] field, final int flips, final int limit){\n\t\tfinal int next_x = x == n - 1 ? 0 : x + 1;\n\t\tfinal int next_y = x == n - 1 ? y + 1 : y;\n\t\t\n\t\t//System.out.println(x + \" \" + y + \" \" + flips + \" \" + limit);\n\t\tif(x == n - 1 && y == n - 1){\n\t\t\treturn field[y][x] ? flips + 1 : flips;\n\t\t}else if(check(x, y, n, field)){\n\t\t\treturn flips;\n\t\t}else if(!field[y][x]){\n\t\t\treturn dfs(next_x, next_y, n, field, flips, limit);\n\t\t}\n\t\t\n\t\tint ret = limit;\n\t\t\n\t\tfor(int lim_y = n - 1; lim_y >= y; lim_y--){\n\t\t\tfor(int lim_x = n - 1; lim_x >= x; lim_x--){\t\t\n\t\t\t\tif(flips >= ret){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret = Math.min(ret, dfs(next_x, next_y, n, field, flips + 1, ret));\n\t\t\t\t\n\t\t\t\tfor(int cur_y = y; cur_y <= lim_y; cur_y++){\n\t\t\t\t\tfor(int cur_x = x; cur_x <= lim_x; cur_x++){\n\t\t\t\t\t\tfield[cur_y][cur_x] = !field[cur_y][cur_x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] field = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfield[i][j] = sc.nextInt() == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int ret = dfs(0, 0, n, field, 0, 25);\n\t\t\t\n\t\t\tfor(int i = 0; i < ret; i++){\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[][][][] mask = new int[5][5][5][5];\n\n\tstatic int solve(int start) {\n\t\tHashMap<Integer, Integer> visited = new HashMap<Integer, Integer>();\n\t\tvisited.put(start, 0);\n\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\t\tcur.add(start);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tArrayList<Integer> next = new ArrayList<Integer>();\n\t\t\t\tfor (int st : cur) {\n\t\t\t\t\tif (!bit(st, i, j)) {\n\t\t\t\t\t\tnext.add(st);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = i; k < N; ++k) {\n\t\t\t\t\t\tfor (int l = j; l < N; ++l) {\n\t\t\t\t\t\t\tint nv = st ^ mask[i][j][k][l];\n\t\t\t\t\t\t\tint count = visited.get(st) + 1;\n\t\t\t\t\t\t\tif (visited.containsKey(nv)) {\n\t\t\t\t\t\t\t\tif (count < visited.get(nv)) {\n\t\t\t\t\t\t\t\t\tvisited.put(nv, count);\n\t\t\t\t\t\t\t\t\tnext.add(nv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvisited.put(nv, count);\n\t\t\t\t\t\t\t\tnext.add(nv);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t}\n\t\treturn visited.get(0);\n\t}\n\n\tstatic boolean bit(int state, int r, int c) {\n\t\treturn (state & (1 << (r * 5 + c))) != 0;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\t\tfor (int k = i; k < 5; ++k) {\n\t\t\t\t\tfor (int l = j; l < 5; ++l) {\n\t\t\t\t\t\tfor (int r = i; r <= k; ++r) {\n\t\t\t\t\t\t\tfor (int c = j; c <= l; ++c) {\n\t\t\t\t\t\t\t\tmask[i][j][k][l] |= (1 << (r * 5 + c));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint start = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tint v = sc.nextInt();\n\t\t\t\t\tif (v == 1) start += (1 << (i * 5 + j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = solve(start);\n\t\t\tfor (int j = 0; j < ans; ++j) {\n\t\t\t\tSystem.out.print(\"myon\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Mysterious Onslaught\npublic class Main{\n\n\tint[] d;\n\tint res, M = (0x1f)<<20;\n\tList<Integer> mask;\n\t\n\tvoid f(int S, int depth, int k){\n\t\tif((S&M)==0){\n\t\t\tres = Math.min(res, depth+d[S]);\n\t\t\treturn;\n\t\t}\n\t\tif(res<=depth+d[(0xfffff)&S] || k==mask.size())return;\n\t\tf(S^mask.get(k), depth+1, k+1);\n\t\tf(S, depth, k+1);\n\t}\n\t\n\tvoid run(){\n\t\td = new int[1<<20];\n\t\tint INF = 1<<28;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint S = q.poll();\n\t\t\tfor(int i=0;i<4;i++)for(int j=0;j<5;j++)for(int h=i;h<4;h++)for(int w=j;w<5;w++){\n\t\t\t\tint ns = S;\n\t\t\t\tfor(int y=i;y<=h;y++)for(int x=j;x<=w;x++)ns^=1<<(y*5+x);\n\t\t\t\tif(d[ns]==INF){\n\t\t\t\t\td[ns] = d[S]+1;\n\t\t\t\t\tq.add(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask = new ArrayList<Integer>();\n\t\tfor(int j=0;j<5;j++)for(int h=4;h>=0;h--)for(int w=j;w<5;w++){\n\t\t\tint m = 0;\n\t\t\tfor(int y=4;y>=h;y--)for(int x=j;x<=w;x++)m+=1<<(y*5+x);\n\t\t\tmask.add(m);\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tint x = 0;\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(sc.nextInt()==1)x|=1<<(i*5+j);\n\t\t\tres = 9;\n\t\t\tif(n<=4)res=d[x];\n\t\t\telse f(x, 0, 0);\n\t\t\twhile(res--!=0)System.out.print(\"myon\");\n\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n//writeMap(Map));\t\t\n\t\tQueue<int>[] Q=new Queue<int>[2];\n\t\tQ[0]=new Queue<int>();\n\t\tQ[1]=new Queue<int>();\n\t\tHashSet<int> H=new HashSet<int>();\n\t\t\n\t\tint cnt=0;\n\t\tQ[0].Enqueue(Map);\n\t\t\n\t\twhile(Q[cnt%2].Count>0){\n//if(cnt==2)return;\n\t\t\twhile(Q[cnt%2].Count>0){\n//Console.WriteLine(\"cnt={0},Q[{0}].Count={1}\",cnt,Q[cnt%2].Count);\n\t\t\t\tint m=Q[cnt%2].Dequeue();\n//writeMap(m);\n//Console.WriteLine(\"masks are:\");\n\t\t\t\tif(m==0){\n\t\t\t\t\tString S=\"\";\n\t\t\t\t\tfor(int i=0;i<cnt;i++)S+=\"myon\";\n\t\t\t\t\tConsole.WriteLine(S);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint x=m&-m;\n\t\t\t\tint idx=bitCnt(x-1);\n\t\t\t\tint cMax=idx;\n\t\t\t\tfor(;cMax<(idx/N+1)*N;cMax++){\n\t\t\t\t\tif(((m>>cMax)&0x1)==0)break;\n\t\t\t\t}\n\t\t\t\tcMax=cMax-idx;\n\t\t\t\t\n\t\t\t\tint rMax=idx;\n\t\t\t\tfor(;rMax<N*N;rMax+=N){\n\t\t\t\t\tif(((m>>rMax)&0x1)==0)break;\n\t\t\t\t}\n\t\t\t\trMax=(rMax-idx)/N;\n//Console.WriteLine(\"x={2},idx={3},cMax={0},rMax={1}\",cMax,rMax,x,idx);\n//bool chk=true;if(chk)return;\n\t\t\t\tfor(int i=0;i<=rMax;i++){\n\t\t\t\t\tfor(int j=0;j<=cMax;j++){\n\t\t\t\t\t\tint mask=0;\n\t\t\t\t\t\tfor(int ii=0;ii<i;ii++){\n\t\t\t\t\t\t\tfor(int jj=0;jj<j;jj++){\n\t\t\t\t\t\t\t\tmask=mask|x<<(ii*N+jj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(mask==0)continue;\n//writeMap(mask);\n\t\t\t\t\t\tif(!H.Contains(m^mask)){\n\t\t\t\t\t\t\tQ[(cnt+1)%2].Enqueue(m^mask);\n\t\t\t\t\t\t\tH.Add(m^mask);\n//writeMap(m);\n//writeMap(m^mask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tstatic int bitCnt(int x){\n\t\tx=(x&0x55555555)+((x>>1)&0x55555555);\n\t\tx=(x&0x33333333)+((x>>2)&0x33333333);\n\t\tx=(x&0x0F0F0F0F)+((x>>4)&0x0F0F0F0F);\n\t\tx=(x&0x00FF00FF)+((x>>8)&0x00FF00FF);\n\t\tx=(x&0x0000FFFF)+((x>>16)&0x0000FFFF);\n\t\treturn x;\n\t}\n\t\n\tvoid writeMap(int x){\n\t\tList<char> L=new List<char>();\n \t\twhile(true){\n\t\t\tL.Add((char)('0'+(x&0x1)));\n\t\t\tx=x>>1;\n\t\t\tif(x==0)break;\n\t\t}\n\t\t\n\t\tchar[] C=new char[N*N];\n\t\tfor(int i=0;i<N*N;i++)C[i]='0';\n\t\tfor(int i=0;i<L.Count;i++){\n\t\t\tC[N*N-1-i]=L[i];\n\t\t}\n\t\tString s=new String(C);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tConsole.WriteLine(s.Substring(i*N,N));\n\t\t} \n\t\t\n\t\tConsole.WriteLine(\"\");\n\t}\n\n\tint N;\n\tint Map;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tMap=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t//左上が最下位bit\n\t\t\t\tMap=Map|(d[j]<<i*N+j);\n\t\t\t\t//Console.WriteLine(Map);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n//writeMap(Map));\t\t\n\t\tQueue<int>[] Q=new Queue<int>[2];\n\t\tQ[0]=new Queue<int>();\n\t\tQ[1]=new Queue<int>();\n\t\tHashSet<int> H=new HashSet<int>();\n\t\t\n\t\tint cnt=0;\n\t\tQ[0].Enqueue(Map);\n\t\t\n\t\twhile(Q[cnt%2].Count>0){\n//if(cnt==2)return;\n\t\t\twhile(Q[cnt%2].Count>0){\n//Console.WriteLine(\"cnt={0},Q[{0}].Count={1}\",cnt,Q[cnt%2].Count);\n\t\t\t\tint m=Q[cnt%2].Dequeue();\n//writeMap(m);\n//Console.WriteLine(\"masks are:\");\n\t\t\t\tif(m==0){\n\t\t\t\t\tString S=\"\";\n\t\t\t\t\tfor(int i=0;i<cnt;i++)S+=\"myon\";\n\t\t\t\t\tConsole.WriteLine(S);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint x=m&-m;\n\t\t\t\tint idx=bitCnt(x-1);\n\t\t\t\tint cMax=idx;\n\t\t\t\tfor(;cMax<(idx/N+1)*N;cMax++){\n\t\t\t\t\t//if(((m>>cMax)&0x1)==0)break;\n\t\t\t\t}\n\t\t\t\tcMax=cMax-idx;\n\t\t\t\t\n\t\t\t\tint rMax=idx;\n\t\t\t\tfor(;rMax<N*N;rMax+=N){\n\t\t\t\t\t//if(((m>>rMax)&0x1)==0)break;\n\t\t\t\t}\n\t\t\t\trMax=(rMax-idx)/N;\n//Console.WriteLine(\"x={2},idx={3},cMax={0},rMax={1}\",cMax,rMax,x,idx);\n//bool chk=true;if(chk)return;\n\t\t\t\tfor(int i=0;i<=rMax;i++){\n\t\t\t\t\tfor(int j=0;j<=cMax;j++){\n\t\t\t\t\t\tint mask=0;\n\t\t\t\t\t\tfor(int ii=0;ii<i;ii++){\n\t\t\t\t\t\t\tfor(int jj=0;jj<j;jj++){\n\t\t\t\t\t\t\t\tmask=mask|x<<(ii*N+jj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(mask==0)continue;\n//writeMap(mask);\n\t\t\t\t\t\tif(!H.Contains(m^mask)){\n\t\t\t\t\t\t\tQ[(cnt+1)%2].Enqueue(m^mask);\n\t\t\t\t\t\t\tH.Add(m^mask);\n//writeMap(m);\n//writeMap(m^mask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tstatic int bitCnt(int x){\n\t\tx=(x&0x55555555)+((x>>1)&0x55555555);\n\t\tx=(x&0x33333333)+((x>>2)&0x33333333);\n\t\tx=(x&0x0F0F0F0F)+((x>>4)&0x0F0F0F0F);\n\t\tx=(x&0x00FF00FF)+((x>>8)&0x00FF00FF);\n\t\tx=(x&0x0000FFFF)+((x>>16)&0x0000FFFF);\n\t\treturn x;\n\t}\n\t\n\tvoid writeMap(int x){\n\t\tList<char> L=new List<char>();\n \t\twhile(true){\n\t\t\tL.Add((char)('0'+(x&0x1)));\n\t\t\tx=x>>1;\n\t\t\tif(x==0)break;\n\t\t}\n\t\t\n\t\tchar[] C=new char[N*N];\n\t\tfor(int i=0;i<N*N;i++)C[i]='0';\n\t\tfor(int i=0;i<L.Count;i++){\n\t\t\tC[N*N-1-i]=L[i];\n\t\t}\n\t\tString s=new String(C);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tConsole.WriteLine(s.Substring(i*N,N));\n\t\t} \n\t\t\n\t\tConsole.WriteLine(\"\");\n\t}\n\n\tint N;\n\tint Map;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tMap=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar d=ria();\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t//左上が最下位bit\n\t\t\t\tMap=Map|(d[j]<<i*N+j);\n\t\t\t\t//Console.WriteLine(Map);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef make_mask(x0, x1, y0, y1)\n  hbits = ((1 << (x1 - x0 + 1)) - 1) << x0\n  bits = 0\n  for y in (y0..y1)\n    bits |= (hbits << (y * $n))\n  end\n  bits\nend\n\ndef min_dist(bits)\n  return $dists[bits] if ! $dists[bits].nil?\n\n  id = 0\n  while ((bits >> id) & 1) == 0\n    id += 1\n  end\n\n  x0 = id % $n\n  y0 = id / $n\n  md = MAX_INT\n\n  ($n - 1).downto(y0) do |y1|\n    ($n - 1).downto(x0) do |x1|\n      bits0 = bits ^ $nbrs[x0 * $n3 + x1 * $n2 + y0 * $n + y1]\n      d = min_dist(bits0) + 1\n      md = d if md > d\n    end\n  end\n\n  $dists[bits] = md\nend\n\n### main\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  $n2 = $n * $n\n  $n3 = $n2 * $n\n  \n  st = 0\n\n  for y in (0...$n)\n    hl = gets.split.map(&:to_i)\n    for x in (0...$n)\n      st |= (hl[x] << (x + y * $n))\n    end\n  end\n  #p st.to_s(2)\n\n  $nbrs = []\n\n  for x0 in (0...$n)\n    for x1 in (x0...$n)\n      for y0 in (0...$n)\n        for y1 in (y0...$n)\n          id = x0 * $n3 + x1 * $n2 + y0 * $n + y1\n          $nbrs[id] = make_mask(x0, x1, y0, y1)\n        end\n      end\n    end\n  end\n  #p $nbrs; exit\n\n  $dists = {}\n  $dists[0] = 0\n\n  md = min_dist(st)\n  puts (['myon'] * md).join('')\nend"
  },
  {
    "language": "Python",
    "code": "code=\"\"\"\\\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define all(c) begin(c),end(c)\n\nint main()\n{\n\tstatic array<int,225> ms;\n\t{\n\t\tint k=0;\n\t\trep(t,5) repi(b,t,5) rep(l,5) repi(r,l,5){\n\t\t\tint m=0;\n\t\t\trepi(i,t,b+1) repi(j,l,r+1) m|=1<<(i*5+j);\n\t\t\tms[k++]=m;\n\t\t}\n\t}\n\t\n\tstatic array<uint8_t,1<<25> ds; ds.fill(-1); ds[0]=0;\n\tfor(int i=0;count(all(ds),i);i++)\n\t\trep(j,1<<25) if(ds[j]==i)\n\t\t\tfor(int m:ms) ds[j^m]=min<uint8_t>(ds[j^m],i+1);\n\t\n\tfor(int n;cin>>n && n;){\n\t\tint x=0;\n\t\trep(i,n) rep(j,n){\n\t\t\tint b; cin>>b;\n\t\t\tx|=b<<(i*5+j);\n\t\t}\n\t\tstring res;\n\t\trep(i,ds[x]) res+=\"myon\";\n\t\tcout<<res<<endl;\n\t}\n}\n\"\"\"\n\nimport os,tempfile\n(_,filename)=tempfile.mkstemp(\".cpp\")\n\nf=open(filename,\"w\")\nf.write(code)\nf.close()\n\nos.system(\"g++ -std=c++0x -O2 {}\".format(filename))\nos.system(\"./a.out\")"
  },
  {
    "language": "Python",
    "code": "# AOJ 1059 Mysterious Onslaught\n# Python3 2018.7.7 bal4u\n\ndef calc(b):\n\tif b == 0: return 0;\n\tif memo[b] >= 0: return memo[b]\n\tf = False\n\tfor r1 in range(n):\n\t\tfor c1 in range(n):\n\t\t\tif b & (1<<(5*r1+c1)):\n\t\t\t\tf, rr, cc = True, r1, c1\n\t\t\t\tbreak\n\t\tif f: break\n\tif not f:\n\t\tmemo[b] = 0\n\t\treturn 0\n\n\tans = 25;\n\tfor r2 in range(rr, n):\n\t\tfor c2 in range(cc, n):\n\t\t\tk = b ^ arr[rr][cc][r2][c2]\n\t\t\tans = min(ans, calc(k)+1)\n\tmemo[b] = ans\n\treturn ans\n\nmemo = [-1]*(1<<25)\narr = [[[[0 for c2 in range(5)] for r2 in range(5)] \\\n\t\t    for c1 in range(5)] for r1 in range(5)]\nfor r1 in range(5):\n\tfor c1 in range(5):\n\t\tfor r2 in range(r1, 5):\n\t\t\tfor c2 in range(c1, 5):\n\t\t\t\tfor r in range(r1, r2+1):\n\t\t\t\t\tfor c in range(c1, c2+1):\n\t\t\t\t\t\tarr[r1][c1][r2][c2] |= (1<<(r*5+c))\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\ta = [list(map(int, input().split())) for i in range(n)]\n\tb = 0;\n\tfor r in range(n):\n\t\tfor c in range(n):\n\t\t\tif a[r][c]: b |= 1 << (5*r+c)\n\tprint(\"myon\"*calc(b))\n"
  }
]