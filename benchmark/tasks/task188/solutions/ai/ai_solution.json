[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid flip(int **grid, int n, int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; i++) {\n        for (int j = y1; j <= y2; j++) {\n            grid[i][j] ^= 1;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int **grid = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        grid[i] = (int *)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int count = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if (grid[i][j] == 1) {\n                flip(grid, n, 0, 0, i, j);\n                count++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    \n    for (int i = 0; i < n; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int[] shortestSpell(int[][] grid) {\n        int n = grid.length;\n        int minSpells = Integer.MAX_VALUE;\n        int[] bestSequence = null;\n\n        for (int mask = 0; mask < (1 << (n * n)); mask++) {\n            int[][] tempGrid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                tempGrid[i] = grid[i].clone();\n            }\n\n            List<int[]> currentSpells = new ArrayList<>();\n            for (int bit = 0; bit < n * n; bit++) {\n                if ((mask & (1 << bit)) != 0) {\n                    int row = bit / n;\n                    int col = bit % n;\n                    currentSpells.add(new int[]{row, col});\n                    castSpell(tempGrid, row, col);\n                }\n            }\n\n            if (isDefeated(tempGrid) && currentSpells.size() < minSpells) {\n                minSpells = currentSpells.size();\n                bestSequence = currentSpells.stream()\n                    .flatMapToInt(spell -> Arrays.stream(new int[]{spell[0], spell[1]}))\n                    .toArray();\n            }\n        }\n\n        return bestSequence;\n    }\n\n    private static void castSpell(int[][] grid, int row, int col) {\n        for (int i = 0; i < grid.length; i++) {\n            grid[row][i] = 1 - grid[row][i];\n            grid[i][col] = 1 - grid[i][col];\n        }\n        grid[row][col] = 1 - grid[row][col];\n    }\n\n    private static boolean isDefeated(int[][] grid) {\n        for (int[] row : grid) {\n            for (int cell : row) {\n                if (cell == 1) return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 1, 0},\n            {0, 1, 1},\n            {1, 0, 1}\n        };\n        int[] result = shortestSpell(grid);\n        System.out.println(Arrays.toString(result));\n    }\n}",
    "timestamp": "2025-08-05 18:59:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> shortestSpell(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<vector<int>> spells;\n    \n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = n - 1; j >= 0; --j) {\n            if (grid[i][j] == 1) {\n                spells.push_back({0, 0, i, j});\n                for (int x = 0; x <= i; ++x) {\n                    for (int y = 0; y <= j; ++y) {\n                        grid[x][y] ^= 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    return spells;\n}",
    "timestamp": "2025-08-05 18:59:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 10\n\nint n;\nint grid[MAX_N][MAX_N];\nint best_spell_count = INT_MAX;\nchar best_spells[MAX_N * MAX_N][20];\n\nvoid flip_rectangle(int r1, int c1, int r2, int c2) {\n    for (int r = r1; r <= r2; r++) {\n        for (int c = c1; c <= c2; c++) {\n            grid[r][c] = 1 - grid[r][c];\n        }\n    }\n}\n\nint count_enemies() {\n    int enemies = 0;\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < n; c++) {\n            if (grid[r][c] == 1) {\n                enemies++;\n            }\n        }\n    }\n    return enemies;\n}\n\nvoid solve(int current_spell_count, char spells[][20]) {\n    if (count_enemies() == 0) {\n        if (current_spell_count < best_spell_count) {\n            best_spell_count = current_spell_count;\n            memcpy(best_spells, spells, current_spell_count * sizeof(spells[0]));\n        }\n        return;\n    }\n\n    if (current_spell_count >= best_spell_count) {\n        return;\n    }\n\n    for (int r1 = 0; r1 < n; r1++) {\n        for (int c1 = 0; c1 < n; c1++) {\n            for (int r2 = r1; r2 < n; r2++) {\n                for (int c2 = c1; c2 < n; c2++) {\n                    int original_grid[MAX_N][MAX_N];\n                    memcpy(original_grid, grid, sizeof(grid));\n\n                    char spell[20];\n                    sprintf(spell, \"myon %d %d %d %d\", r1, c1, r2, c2);\n                    strcpy(spells[current_spell_count], spell);\n\n                    flip_rectangle(r1, c1, r2, c2);\n                    solve(current_spell_count + 1, spells);\n\n                    memcpy(grid, original_grid, sizeof(grid));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < n; c++) {\n            scanf(\"%d\", &grid[r][c]);\n        }\n    }\n\n    char initial_spells[MAX_N * MAX_N][20];\n    solve(0, initial_spells);\n\n    printf(\"%d\\n\", best_spell_count);\n    for (int i = 0; i < best_spell_count; i++) {\n        printf(\"%s\\n\", best_spells[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:00:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestSpell(vector<vector<int>>& grid) {\n        int n = grid.size();\n        \n        vector<pair<int, int>> enemies;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    enemies.push_back({i, j});\n                }\n            }\n        }\n        \n        if (enemies.empty()) return 0;\n        \n        int minSpells = INT_MAX;\n        \n        for (int x1 = 0; x1 < n; x1++) {\n            for (int y1 = 0; y1 < n; y1++) {\n                for (int x2 = x1; x2 < n; x2++) {\n                    for (int y2 = y1; y2 < n; y2++) {\n                        vector<vector<int>> tempGrid = grid;\n                        int spells = 0;\n                        \n                        // Apply spell on current rectangular area\n                        for (int x = x1; x <= x2; x++) {\n                            for (int y = y1; y <= y2; y++) {\n                                tempGrid[x][y] = 1 - tempGrid[x][y];\n                            }\n                        }\n                        spells++;\n                        \n                        // Check remaining enemies\n                        bool allDefeated = true;\n                        for (auto& enemy : enemies) {\n                            if (enemy.first >= x1 && enemy.first <= x2 &&\n                                enemy.second >= y1 && enemy.second <= y2) {\n                                continue;\n                            }\n                            \n                            if (tempGrid[enemy.first][enemy.second] == 1) {\n                                allDefeated = false;\n                                break;\n                            }\n                        }\n                        \n                        if (allDefeated) {\n                            minSpells = min(minSpells, spells);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return minSpells == INT_MAX ? -1 : minSpells;\n    }\n};",
    "timestamp": "2025-08-05 19:00:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<String> generateShortestSpell(int[][] grid) {\n        List<String> spells = new ArrayList<>();\n        int n = grid.length;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    spells.add(\"myon \" + i + \" \" + j + \" \" + i + \" \" + j);\n                    flip(grid, i, j, i, j);\n                }\n            }\n        }\n        \n        return spells;\n    }\n    \n    private void flip(int[][] grid, int x1, int y1, int x2, int y2) {\n        for (int i = x1; i <= x2; i++) {\n            for (int j = y1; j <= y2; j++) {\n                grid[i][j] ^= 1;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:01:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shortest_spells_to_clear_enemies(grid):\n    from copy import deepcopy\n\n    n = len(grid)\n    min_operations = []\n\n    def toggle(row, col):\n        for i in range(row[0], row[1] + 1):\n            for j in range(col[0], col[1] + 1):\n                grid_copy[i][j] = 1 - grid_copy[i][j]\n\n    def all_zero():\n        return all(all(cell == 0 for cell in row) for row in grid_copy)\n\n    def backtrack(path):\n        if len(min_operations) != 0 and len(path) >= len(min_operations):\n            return\n        \n        if all_zero():\n            if len(min_operations) == 0 or len(path) < len(min_operations):\n                min_operations[:] = path[:]\n            return\n        \n        for i in range(n):\n            for j in range(n):\n                for k in range(i, n):\n                    for l in range(j, n):\n                        toggle((i, k), (j, l))\n                        path.append((i, j, k, l))\n                        backtrack(path)\n                        path.pop()\n                        toggle((i, k), (j, l))\n\n    grid_copy = deepcopy(grid)\n    backtrack([])\n    return min_operations\n\n# Example usage:\ngrid = [\n    [1, 0, 1],\n    [1, 1, 0],\n    [0, 1, 1]\n]\nprint(shortest_spells_to_clear_enemies(grid))",
    "timestamp": "2025-08-13 01:54:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SpellCaster {\n\n    static class Spell {\n        int x1, y1, x2, y2;\n\n        Spell(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + x1 + \", \" + y1 + \", \" + x2 + \", \" + y2 + \")\";\n        }\n    }\n\n    public static List<Spell> generateSpells(int[][] grid) {\n        int n = grid.length;\n        List<Spell> spells = new ArrayList<>();\n\n        for (int x1 = 0; x1 < n; x1++) {\n            for (int y1 = 0; y1 < n; y1++) {\n                for (int x2 = x1; x2 < n; x2++) {\n                    for (int y2 = y1; y2 < n; y2++) {\n                        int count = 0;\n                        for (int i = x1; i <= x2; i++) {\n                            for (int j = y1; j <= y2; j++) {\n                                count += grid[i][j];\n                            }\n                        }\n                        if (count > (x2 - x1 + 1) * (y2 - y1 + 1) / 2) {\n                            spells.add(new Spell(x1, y1, x2, y2));\n                            for (int i = x1; i <= x2; i++) {\n                                for (int j = y1; j <= y2; j++) {\n                                    grid[i][j] = 1 - grid[i][j];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return spells;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n                {1, 0, 1},\n                {0, 1, 0},\n                {1, 1, 0}\n        };\n\n        List<Spell> spells = generateSpells(grid);\n        for (Spell spell : spells) {\n            System.out.println(spell);\n        }\n    }\n}",
    "timestamp": "2025-08-13 01:54:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 15\n\nint n;\nint grid[MAX_N][MAX_N];\nint best_flip_count = MAX_N * MAX_N;\nint current_flips[MAX_N * MAX_N];\nint best_flips[MAX_N * MAX_N];\nint flip_count = 0;\n\nvoid flip(int start_x, int start_y, int end_x, int end_y) {\n    for (int i = start_x; i <= end_x; i++) {\n        for (int j = start_y; j <= end_y; j++) {\n            grid[i][j] = 1 - grid[i][j];\n        }\n    }\n}\n\nvoid dfs(int x, int y) {\n    if (x == n) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    return;\n                }\n            }\n        }\n\n        if (flip_count < best_flip_count) {\n            best_flip_count = flip_count;\n            memcpy(best_flips, current_flips, flip_count * sizeof(int));\n        }\n\n        return;\n    }\n\n    int next_x = (y + 1 == n) ? x + 1 : x;\n    int next_y = (y + 1 == n) ? 0 : y + 1;\n\n    dfs(next_x, next_y);\n\n    for (int end_x = x; end_x < n; ++end_x) {\n        for (int end_y = y; end_y < n; ++end_y) {\n            flip(x, y, end_x, end_y);\n            current_flips[flip_count++] = (x * n + y) * n * n + end_x * n + end_y;\n            dfs(next_x, next_y);\n            flip_count--;\n            flip(x, y, end_x, end_y);\n        }\n    }\n}\n\nint main() {\n    // Get the dimension n.\n    scanf(\"%d\", &n);\n\n    // Initialize the grid from input.\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    dfs(0, 0);\n\n    printf(\"%d\\n\", best_flip_count);\n    for (int i = 0; i < best_flip_count; ++i) {\n        int pos = best_flips[i];\n        int start_x = (pos / (n * n)) / n;\n        int start_y = (pos / (n * n)) % n;\n        int end_x = (pos % (n * n)) / n;\n        int end_y = (pos % (n * n)) % n;\n        printf(\"%d %d %d %d\\n\", start_x, start_y, end_x, end_y);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:54:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\n\ndef shortest_spell(grid: List[List[str]]) -> List[tuple]:\n    n = len(grid)\n    spells = []\n\n    def apply_spell(r1, c1, r2, c2):\n        for r in range(r1, r2+1):\n            for c in range(c1, c2+1):\n                grid[r][c] = '0' if grid[r][c] == '1' else '1'\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == '1':\n                spells.append((r, c, r, c))\n                apply_spell(r, c, r, c)\n\n    return spells",
    "timestamp": "2025-08-13 01:54:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shortest_spell(grid):\n    n = len(grid)\n    spells = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                # The spell is the rectangle from (i,j) to (n-1, n-1)\n                spells.append((i, j, n-1, n-1))\n                # Flip the rectangle\n                for x in range(i, n):\n                    for y in range(j, n):\n                        grid[x][y] ^= 1\n    return spells",
    "timestamp": "2025-08-13 01:54:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> grid;\n    int x1, y1, x2, y2;\n    vector<pair<pair<int, int>, pair<int, int>>> spells;\n\n    bool operator==(const State& other) const {\n        return grid == other.grid;\n    }\n};\n\nnamespace std {\n    template <>\n    struct hash<State> {\n        size_t operator()(const State& state) const {\n            size_t h = 0;\n            for (const auto& row : state.grid) {\n                for (int cell : row) {\n                    h = h * 31 + cell;\n                }\n            }\n            return h;\n        }\n    };\n}\n\nvoid toggle(vector<vector<int>>& grid, int x1, int y1, int x2, int y2) {\n    for (int i = x1; i <= x2; ++i)\n        for (int j = y1; j <= y2; ++j)\n            grid[i][j] = 1 - grid[i][j];\n}\n\nvector<vector<int>> clone_and_toggle(const vector<vector<int>>& grid, int x1, int y1, int x2, int y2) {\n    auto new_grid = grid;\n    toggle(new_grid, x1, y1, x2, y2);\n    return new_grid;\n}\n\nbool is_zero_grid(const vector<vector<int>>& grid) {\n    for (const auto& row : grid)\n        for (int cell : row)\n            if (cell == 1)\n                return false;\n    return true;\n}\n\nvector<pair<pair<int, int>, pair<int, int>>> find_shortest_spell_sequence(vector<vector<int>>& grid) {\n    int n = grid.size();\n\n    queue<State> q;\n    unordered_set<State> visited;\n\n    State initial_state = {grid, 0, 0, 0, 0, {}};\n    q.push(initial_state);\n    visited.insert(initial_state);\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (is_zero_grid(current.grid)) {\n            return current.spells;\n        }\n\n        for (int x1 = 0; x1 < n; ++x1) {\n            for (int y1 = 0; y1 < n; ++y1) {\n                for (int x2 = x1; x2 < n; ++x2) {\n                    for (int y2 = y1; y2 < n; ++y2) {\n                        auto new_grid = clone_and_toggle(current.grid, x1, y1, x2, y2);\n                        State new_state = {new_grid, x1, y1, x2, y2, current.spells};\n                        new_state.spells.emplace_back(make_pair(x1, y1), make_pair(x2, y2));\n                        \n                        if (visited.find(new_state) == visited.end()) {\n                            q.push(new_state);\n                            visited.insert(new_state);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {};\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> grid(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> grid[i][j];\n\n    auto spells = find_shortest_spell_sequence(grid);\n    cout << spells.size() << endl;\n    for (auto& spell : spells)\n        cout << spell.first.first << \" \" << spell.first.second << \" \" << spell.second.first << \" \" << spell.second.second << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:03:15"
  }
]