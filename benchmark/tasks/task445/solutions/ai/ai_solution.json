[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint R, C;\nchar grid[100][100];\nchar s[100][101];\nint max_points = 0;\n\nvoid calculate_points() {\n    int points = 0;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (grid[i][j] == '\\0') continue;\n            if (i > 0 && grid[i-1][j] == grid[i][j]) points++;\n            if (i < R-1 && grid[i+1][j] == grid[i][j]) points++;\n            if (j > 0 && grid[i][j-1] == grid[i][j]) points++;\n            if (j < C-1 && grid[i][j+1] == grid[i][j]) points++;\n        }\n    }\n    if (points > max_points) {\n        max_points = points;\n    }\n}\n\nvoid backtrack(int row, int col, int pos) {\n    if (row == R) {\n        calculate_points();\n        return;\n    }\n    if (col == C) {\n        if (pos == strlen(s[row])) {\n            backtrack(row + 1, 0, 0);\n        }\n        return;\n    }\n    if (pos < strlen(s[row])) {\n        grid[row][col] = s[row][pos];\n        backtrack(row, col + 1, pos + 1);\n        grid[row][col] = '\\0';\n    }\n    backtrack(row, col + 1, pos);\n}\n\nint main() {\n    scanf(\"%d %d\", &R, &C);\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", s[i]);\n    }\n    backtrack(0, 0, 0);\n    printf(\"%d\\n\", max_points);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    vector<string> s(R);\n    for (int i = 0; i < R; ++i) {\n        cin >> s[i];\n    }\n\n    int total = 0;\n    vector<vector<char>> grid(R, vector<char>(C, ' '));\n\n    for (int i = 0; i < R; ++i) {\n        string &str = s[i];\n        int len = str.size();\n        int max_score = -1;\n        vector<char> best_row(C, ' ');\n\n        for (int pos = 0; pos <= C - len; ++pos) {\n            vector<char> row(C, ' ');\n            for (int k = 0; k < len; ++k) {\n                row[pos + k] = str[k];\n            }\n\n            int score = 0;\n            for (int k = 0; k < C; ++k) {\n                if (row[k] == ' ') continue;\n                if (k > 0 && row[k-1] == row[k]) score++;\n                if (k < C-1 && row[k+1] == row[k]) score++;\n                if (i > 0 && grid[i-1][k] == row[k]) score++;\n            }\n\n            if (score > max_score) {\n                max_score = score;\n                best_row = row;\n            }\n        }\n\n        grid[i] = best_row;\n        total += max_score;\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Connect {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int R = scanner.nextInt();\n        int C = scanner.nextInt();\n        scanner.nextLine(); // consume the newline\n        String[] s = new String[R];\n        for (int i = 0; i < R; i++) {\n            s[i] = scanner.nextLine().trim();\n        }\n\n        char[][] grid = new char[R][C];\n        for (int i = 0; i < R; i++) {\n            Arrays.fill(grid[i], ' '); // Initialize with empty\n        }\n\n        int maxScore = 0;\n        maxScore = backtrack(0, 0, R, C, grid, s, maxScore);\n        System.out.println(maxScore);\n    }\n\n    private static int backtrack(int row, int col, int R, int C, char[][] grid, String[] s, int currentMax) {\n        if (row == R) {\n            return calculateScore(grid, R, C);\n        }\n        if (col == C) {\n            return backtrack(row + 1, 0, R, C, grid, s, currentMax);\n        }\n\n        String currentStr = s[row];\n        int maxScore = currentMax;\n\n        for (int i = 0; i < currentStr.length(); i++) {\n            if (col + i >= C) break;\n            grid[row][col + i] = currentStr.charAt(i);\n        }\n\n        int nextCol = col + currentStr.length();\n        int score;\n        if (nextCol <= C) {\n            score = backtrack(row, nextCol, R, C, grid, s, maxScore);\n            if (score > maxScore) {\n                maxScore = score;\n            }\n        }\n\n        // Backtrack\n        for (int i = 0; i < currentStr.length(); i++) {\n            if (col + i >= C) break;\n            grid[row][col + i] = ' ';\n        }\n\n        return maxScore;\n    }\n\n    private static int calculateScore(char[][] grid, int R, int C) {\n        int score = 0;\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (grid[i][j] == ' ') continue;\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (ni >= 0 && ni < R && nj >= 0 && nj < C && grid[ni][nj] == grid[i][j]) {\n                        score++;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n}",
    "timestamp": "2025-08-05 21:35:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Connect {\n    public static int maximumPoints(int R, int C, String[] tiles) {\n        int[][] points = new int[R][C];\n        \n        for (int r = 0; r < R; r++) {\n            for (int c = 0; c < C; c++) {\n                points[r][c] = calculatePoints(tiles, r, c);\n            }\n        }\n        \n        int totalPoints = 0;\n        for (int[] row : points) {\n            for (int point : row) {\n                totalPoints += point;\n            }\n        }\n        \n        return totalPoints;\n    }\n    \n    private static int calculatePoints(String[] tiles, int r, int c) {\n        if (r < 0 || r >= tiles.length || c < 0 || c >= tiles[r].length()) {\n            return 0;\n        }\n        \n        char current = tiles[r].charAt(c);\n        int adjacentPoints = 0;\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        for (int[] dir : directions) {\n            int newR = r + dir[0];\n            int newC = c + dir[1];\n            \n            if (newR >= 0 && newR < tiles.length && \n                newC >= 0 && newC < tiles[newR].length() && \n                tiles[newR].charAt(newC) == current) {\n                adjacentPoints++;\n            }\n        }\n        \n        return adjacentPoints;\n    }\n    \n    public static void main(String[] args) {\n        int R = 3;\n        int C = 4;\n        String[] tiles = {\"ABCD\", \"EFGH\", \"IJKL\"};\n        \n        System.out.println(maximumPoints(R, C, tiles));\n    }\n}",
    "timestamp": "2025-08-05 21:35:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_R 20\n#define MAX_C 20\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint calc_points(char grid[MAX_R][MAX_C], int R, int C) {\n    int points = 0;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (grid[i][j] != '.') {\n                for (int k = 0; k < 4; k++) {\n                    int ni = i + dx[k];\n                    int nj = j + dy[k];\n                    if (ni >= 0 && ni < R && nj >= 0 && nj < C && \n                        grid[ni][nj] == grid[i][j]) {\n                        points++;\n                    }\n                }\n            }\n        }\n    }\n    return points / 2;\n}\n\nint solve(int R, int C, char rows[MAX_R][MAX_C + 1]) {\n    char grid[MAX_R][MAX_C];\n    int max_points = 0;\n\n    for (int mask = 0; mask < (1 << (R * C)); mask++) {\n        memset(grid, '.', sizeof(grid));\n\n        for (int r = 0; r < R; r++) {\n            int idx = 0;\n            for (int c = 0; c < C; c++) {\n                if (mask & (1 << (r * C + c)) && idx < strlen(rows[r])) {\n                    grid[r][c] = rows[r][idx++];\n                }\n            }\n        }\n\n        int curr_points = calc_points(grid, R, C);\n        max_points = (curr_points > max_points) ? curr_points : max_points;\n    }\n\n    return max_points;\n}\n\nint main() {\n    int R, C;\n    char rows[MAX_R][MAX_C + 1];\n\n    scanf(\"%d %d\", &R, &C);\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", rows[i]);\n    }\n\n    printf(\"%d\\n\", solve(R, C, rows));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint maxPoints(int R, int C, vector<string>& strings) {\n    vector<vector<char>> grid(R, vector<char>(C, '.'));\n    \n    for (int row = 0; row < R; row++) {\n        for (int col = 0; col < min((int)strings[row].length(), C); col++) {\n            grid[row][col] = strings[row][col];\n        }\n    }\n    \n    int totalPoints = 0;\n    \n    for (int row = 0; row < R; row++) {\n        for (int col = 0; col < C; col++) {\n            if (grid[row][col] == '.') continue;\n            \n            int points = 0;\n            \n            // Check adjacent cells\n            vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            \n            for (auto& dir : directions) {\n                int newRow = row + dir.first;\n                int newCol = col + dir.second;\n                \n                if (newRow >= 0 && newRow < R && newCol >= 0 && newCol < C) {\n                    if (grid[newRow][newCol] == grid[row][col]) {\n                        points++;\n                    }\n                }\n            }\n            \n            totalPoints += points;\n        }\n    }\n    \n    return totalPoints;\n}\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    \n    vector<string> strings(R);\n    for (int i = 0; i < R; i++) {\n        cin >> strings[i];\n    }\n    \n    cout << maxPoints(R, C, strings) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points(R, C, strings):\n    def place_string(s, row_points):\n        best_points = 0\n        for start in range(C - len(s) + 1):\n            points = row_points\n            end = start + len(s)\n\n            # Check horizontally:\n            for col in range(start, end):\n                if col > 0 and board[row][col - 1] == s[col - start]:\n                    points += 1\n                if col < C - 1 and board[row][col + 1] == s[col - start]:\n                    points += 1\n\n            # Check vertically:\n            for col in range(start, end):\n                if row > 0 and board[row - 1][col] == s[col - start]:\n                    points += 1\n                if row < R - 1 and board[row + 1][col] == s[col - start]:\n                    points += 1\n\n            best_points = max(best_points, points)\n\n        return best_points\n\n    board = [[''] * C for _ in range(R)]\n    total_max_points = 0\n\n    for row in range(R):\n        row_points = place_string(strings[row], 0)\n        total_max_points += row_points\n\n        # Place the string in the board to affect future rows:\n        max_points_position = 0\n        max_points = 0\n        \n        for start in range(C - len(strings[row]) + 1):\n            points = 0\n            for col in range(start, start + len(strings[row])):\n                if col > 0 and board[row][col - 1] == strings[row][col - start]:\n                    points += 1\n                if col < C - 1 and board[row][col + 1] == strings[row][col - start]:\n                    points += 1\n\n            if points > max_points:\n                max_points = points\n                max_points_position = start\n\n        # Place the string with max points:\n        for col in range(len(strings[row])):\n            board[row][max_points_position + col] = strings[row][col]\n    \n    return total_max_points\n\n# Example usage:\nR = 3\nC = 4\nstrings = ['ab', 'acb', 'ccb']\nprint(max_points(R, C, strings))",
    "timestamp": "2025-08-13 07:08:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConnectPuzzle {\n    static final int[] dx = {0, 1};\n    static final int[] dy = {1, 0};\n\n    public static int maxPoints(int R, int C, String[] strings) {\n        int[][] score = new int[R][C];\n\n        for (int row = 0; row < R; row++) {\n            char[] s = strings[row].toCharArray();\n            int len = s.length;\n            for (int startCol = 0; startCol <= C - len; startCol++) {\n                for (int i = 0; i < len; i++) {\n                    score[row][startCol + i]++;\n                }\n            }\n        }\n\n        return calculateMaxScore(R, C, strings, score);\n    }\n\n    private static int calculateMaxScore(int R, int C, String[] strings, int[][] score) {\n        int maxScore = 0;\n        int[][] grid = new int[R][C];\n\n        class State {\n            int row;\n            int startCol;\n            int currentScore;\n\n            State(int r, int c, int sc) {\n                row = r;\n                startCol = c;\n                currentScore = sc;\n            }\n        }\n\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(0, 0, 0));\n\n        while (!queue.isEmpty()) {\n            State state = queue.poll();\n\n            if (state.row == R) {\n                maxScore = Math.max(maxScore, state.currentScore);\n                continue;\n            }\n\n            char[] s = strings[state.row].toCharArray();\n            int len = s.length;\n\n            for (int startCol = 0; startCol <= C - len; startCol++) {\n                int currScore = state.currentScore;\n\n                for (int i = 0; i < len; i++) {\n                    int row = state.row;\n                    int col = startCol + i;\n                    grid[row][col] = s[i];\n\n                    for (int d = 0; d < 2; d++) {\n                        int newRow = row + dx[d];\n                        int newCol = col + dy[d];\n\n                        if (newRow < R && newCol < C && grid[newRow][newCol] == s[i]) {\n                            currScore += 2;\n                        }\n                    }\n                }\n                queue.add(new State(state.row + 1, startCol, currScore));\n            }\n        }\n        return maxScore;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int R = scanner.nextInt();\n        int C = scanner.nextInt();\n        scanner.nextLine(); // consume the line break\n\n        String[] strings = new String[R];\n        for (int i = 0; i < R; i++) {\n            strings[i] = scanner.nextLine();\n        }\n\n        System.out.println(maxPoints(R, C, strings));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 07:08:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_R 100\n#define MAX_C 100\n\nint R, C;\nchar grid[MAX_R][MAX_C];\n\nint maxPoints(int row, int col) {\n    int points = 0;\n    // Check adjacent above\n    if (row > 0 && grid[row][col] == grid[row - 1][col])\n        points++;\n    // Check adjacent below\n    if (row < R - 1 && grid[row][col] == grid[row + 1][col])\n        points++;\n    // Check adjacent left\n    if (col > 0 && grid[row][col] == grid[row][col - 1])\n        points++;\n    // Check adjacent right\n    if (col < C - 1 && grid[row][col] == grid[row][col + 1])\n        points++;\n    return points;\n}\n\nint main() {\n    char strings[MAX_R][MAX_C + 1];\n    \n    // Input the number of rows (R) and columns (C)\n    scanf(\"%d %d\", &R, &C);\n    \n    // Input strings for each row\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", strings[i]);\n    }\n    \n    // Fill the grid\n    for (int i = 0; i < R; i++) {\n        int len = strlen(strings[i]);\n        for (int j = 0; j < len; j++) {\n            grid[i][j] = strings[i][j];\n        }\n    }\n    \n    // Calculate maximum points\n    int totalPoints = 0;\n    for (int i = 0; i < R; i++) {\n        int len = strlen(strings[i]);\n        for (int j = 0; j < len; j++) {\n            totalPoints += maxPoints(i, j);\n        }\n    }\n    \n    // Output the result\n    printf(\"%d\\n\", totalPoints);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:08:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points_connect(R, C, grid):\n    max_points = 0\n    \n    def calculate_points(current_grid):\n        points = 0\n        for r in range(R):\n            for c in range(C):\n                if current_grid[r][c] != '.':\n                    # Check adjacent cells\n                    if r > 0 and current_grid[r][c] == current_grid[r-1][c]:\n                        points += 1\n                    if r < R-1 and current_grid[r][c] == current_grid[r+1][c]:\n                        points += 1\n                    if c > 0 and current_grid[r][c] == current_grid[r][c-1]:\n                        points += 1\n                    if c < C-1 and current_grid[r][c] == current_grid[r][c+1]:\n                        points += 1\n        return points // 2\n    \n    def backtrack(row, current_grid):\n        nonlocal max_points\n        \n        if row == R:\n            max_points = max(max_points, calculate_points(current_grid))\n            return\n        \n        # Try all possible substrings for current row\n        for start in range(len(grid[row])):\n            for end in range(start, len(grid[row])+1):\n                substring = grid[row][start:end]\n                \n                # Try to place substring\n                temp_grid = [r[:] for r in current_grid]\n                can_place = True\n                for c, char in enumerate(substring):\n                    if start + c >= C or temp_grid[row][start+c] != '.':\n                        can_place = False\n                        break\n                    temp_grid[row][start+c] = char\n                \n                if can_place:\n                    backtrack(row+1, temp_grid)\n    \n    grid = [list('.' * C) for _ in range(R)]\n    backtrack(0, grid)\n    \n    return max_points\n\n# Example usage\nR, C = 2, 3\ngrid = ['ABC', 'DEF']\nprint(max_points_connect(R, C, grid))",
    "timestamp": "2025-08-13 07:09:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    R, C = map(int, input().split())\n    grid = [input().strip() for _ in range(R)]\n    \n    total = 0\n    \n    for i in range(R):\n        for j in range(C):\n            current = grid[i][j]\n            points = 0\n            # Check adjacent cells\n            if i > 0 and grid[i-1][j] == current:\n                points += 1\n            if i < R - 1 and grid[i+1][j] == current:\n                points += 1\n            if j > 0 and grid[i][j-1] == current:\n                points += 1\n            if j < C - 1 and grid[i][j+1] == current:\n                points += 1\n            total += points\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 07:09:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint calculateMaxPoints(int R, int C, vector<string>& strings) {\n    vector<vector<int>> dp(R, vector<int>(C, 0));\n\n    // Fill rows with strings\n    for (int i = 0; i < R; ++i) {\n        string& s = strings[i];\n        for (int j = 0; j < s.length(); ++j) {\n            dp[i][j] = s[j];\n        }\n    }\n\n    int maxPoints = 0;\n\n    // Calculate points\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (dp[i][j] != 0) {\n                char ch = dp[i][j];\n                int points = 0;\n\n                if (i > 0 && dp[i - 1][j] == ch) points++;\n                if (j > 0 && dp[i][j - 1] == ch) points++;\n                if (j < C - 1 && dp[i][j + 1] == ch) points++;\n                if (i < R - 1 && dp[i + 1][j] == ch) points++;\n\n                maxPoints += points;\n            }\n        }\n    }\n\n    return maxPoints;\n}\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n\n    vector<string> strings(R);\n    for (int i = 0; i < R; ++i) {\n        cin >> strings[i];\n    }\n\n    int maxPoints = calculateMaxPoints(R, C, strings);\n    cout << maxPoints << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:09"
  }
]