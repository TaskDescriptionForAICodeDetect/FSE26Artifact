[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 130\n#define W 16\n#define INF 1e9\nusing namespace std;\nint h,w;\nstring str[H];\n\nshort mem[H][W][1<<W],used[H][W][1<<W];\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -10000;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PInt;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint dp[2][1<<16];\nint main() {\n  int R, C;\n  cin >> R >> C;\n  string A[130];\n  rep(i, R) cin >> A[i];\n  int cur = 0, next = 1;\n  memset(dp, -1, sizeof(dp));\n  dp[cur][0] = 0;\n  rep(i, R) rep(j, C) {\n    //    rep(k, 1<<C) dp[next][k] = 0;\n    memset(dp + next, -1, sizeof(dp[0]));\n    rep(k, 1<<C) if (dp[cur][k] != -1) {\n      int score = 0;\n      int ak = k & ~(1<<j);\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n\n      char c = A[i][__builtin_popcount(k&((1<<j)-1))];\n      if (i > 0 && (k>>j&1) && (A[i-1][SZ(A[i-1]) - __builtin_popcount(k>>j)] == c)) score++;\n      if (j > 0 && (k>>(j-1)&1) && (A[i][__builtin_popcount(k&((1<<j)-1))-1] == c)) score++;\n      ak = k | 1<<j;\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n    }\n    swap(cur, next);\n    if (j+1 == C) {\n      rep(k, 1<<C) if (__builtin_popcount(k) != SZ(A[i])) dp[cur][k] = -1;\n    }\n  }\n\n  int ans = 0;\n  rep(k, 1<<C)\n    ans = max(ans, dp[cur][k]);\n  cout << ans * 2 << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\nconst int MAX_R = 128;\nconst int MAX_C = 16+1;\nconst int BIT = 1<<MAX_C;\n\nint r, c;\nstring s[MAX_R];\n//int dp[2][BIT];\nmap<int,int> dp[2];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    dp[0].clear();\n    dp[1].clear();\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      int sum = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          sum += 2;\n        }\n      }\n      dp[p][k] = sum;\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        dp[q].clear();\n        for(map<int,int>::iterator it = dp[p].begin();\n            it != dp[p].end(); ++it) {\n          int k = it->first;\n          int Lu = c - j;\n          string u, v;\n          int use;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          use = 0;\n          for(int t = Lu; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][use++];\n            else v += '.';\n          }\n\n          if(use + (c-j) < s[i].size()) continue;\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(use < s[i].size()) {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (s[i][use] == u[0]) * 2;\n            if(v.size()) add += (s[i][use] == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PInt;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint dp[2][1<<16];\nint main() {\n  int R, C;\n  cin >> R >> C;\n  string A[130];\n  rep(i, R) cin >> A[i];\n  int cur = 0, next = 1;\n  rep(i, R) rep(j, C) {\n    rep(k, 1<<C) dp[next][k] = 0;\n    rep(k, 1<<C){\n      int score = 0;\n      int ak = k & ~(1<<j);\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n\n      char c = A[i][__builtin_popcount(k&((1<<j)-1))];\n      if (i > 0 && (k>>j&1) && (A[i-1][SZ(A[i-1]) - __builtin_popcount(k>>j)] == c)) score++;\n      if (j > 0 && (k>>(j-1)&1) && (A[i][__builtin_popcount(k&((1<<j)-1))-1] == c)) score++;\n      ak = k | 1<<j;\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n    }\n    swap(cur, next);\n    if (j+1 == C) {\n      rep(k, 1<<C) if (__builtin_popcount(k) != SZ(A[i])) dp[cur][k] = 0;\n    }\n  }\n\n  int ans = 0;\n  rep(k, 1<<C)\n    ans = max(ans, dp[cur][k]);\n  cout << ans * 2 << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16];\nconst int INF=1<<30;\nint bitPos[1<<16][18];\nint bitCnt[1<<16][18];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      int res=-INF;\n      if(i==R*C)res=0;\n      else{\n\tint cnt=0;\n\tif(cy-1>=0)\n\t  cnt=(int)ss[cy-1].size()-(bitCnt[mask][16]-bitCnt[mask][cx]);\n\tconst int ct=bitCnt[mask][cx];\n\tif(ct<(int)ss[cy].size()){\n\t  int nmask=mask|(1<<cx);\n\t  int add=0;\n\t  if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t     &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t     &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t     &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t    add+=2;\n\t  }\n\t  if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t     &&cnt<(int)ss[cy-1].size()\n\t     &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t     &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t    add+=2;\n\t  }\n\t  if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t    res=max(res,dp[nxt][nmask]+add);\n\t  }\n\t}\n\t{\n\t  int nmask=mask&~(1<<cx);\n\t  if(cx!=C-1||ct==(int)ss[cy].size()){\n\t    res=max(res,dp[nxt][nmask]);\n\t  }\n\t}\n      }\n      dp[cur][mask]=res;\n    }\n  }\n  cout<<dp[0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x){ return __popcnt(x); }\ninline unsigned long long __builtin_popcountll(unsigned long long x) { return __popcnt64(x); }\n\n#pragma pop_macro(\"long\")\n#endif\ninline int bsf(int v) { return __builtin_ctz(v); }\ninline long bsf(long v) { return __builtin_ctzll(v); }\ninline int bsr(int v) { return 31 - __builtin_clz(v); }\ninline long bsr(long v) { return 63 - __builtin_clzll(v); }\ninline int msb(int v) { return 1 << bsr(v); }\ninline long msb(long v) { return 1ll << bsr(v); }\ninline int lsb(int v) { return v & -v; }\ninline long lsb(long v) { return v & -v; }\ninline int pop_lsb(int v) { return v & v - 1; }\ninline long pop_lsb(long v) { return v & v - 1; }\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (bsf(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nstring mkstr(string x, int xx, int c, int t)\n{\n\tconst char s1[] = \"0123456789!@#$%^\";\n\tconst char s2[] = \"abcdefghijklmnop\";\n\tstring r(t ? s1 : s2, (t ? s1 : s2) + c);\n\tint rp = 0;\n\tREP(i, c)\n\t{\n\t\tif (xx >> i & 1)\n\t\t{\n\t\t\tr[i] = x[rp++];\n\t\t}\n\t}\n\treturn r;\n}\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, R, C);\n\t\tif (!R) { break; }\n\n\t\tauto strs = read<string>(R);\n\n\t\tint count = 1 << C;\n\t\tvector<int> dp(count);\n\n\t\tFOR(i, 0, R-1)\n\t\t{\n\t\t\tvector<int> nxt(count);\n\t\t\tstring x = strs[i];\n\t\t\tstring y = strs[i + 1];\n\n\t\t\tvector<string> xtbl(count), ytbl(count); \n\t\t\tfor (int xx = (1 << x.length()) - 1; xx < count; xx = next_bit_permutation(xx)) xtbl[xx] = mkstr(x, xx, C, 0);\n\t\t\tfor (int yy = (1 << y.length()) - 1; yy < count; yy = next_bit_permutation(yy)) ytbl[yy] = mkstr(y, yy, C, 1);\n\n\t\t\tfor (int yy = (1 << y.length()) - 1; yy < count; yy = next_bit_permutation(yy))\n\t\t\t{\n\t\t\t\tint ret = 0;\n\t\t\t\tREP(i, C - 1) { if (ytbl[yy][i] == ytbl[yy][i + 1]) ret += 2; }\n\t\t\t\tfor (int xx = (1 << x.length()) - 1; xx < count; xx = next_bit_permutation(xx))\n\t\t\t\t{\n\t\t\t\t\tint ret2 = ret;\n\t\t\t\t\tREP(i, C) { if (xtbl[xx][i] == ytbl[yy][i]) ret2 += 2; }\n\t\t\t\t\t//WRITE(\"score:\", xtbl[xx], ytbl[yy], ret);\n\n\t\t\t\t\tnxt[yy] = max(nxt[yy], dp[xx] + ret2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tswap(dp, nxt);\n\t\t}\n\t\tWRITE(*max_element(allof(dp)));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),INT_MIN);\n    dp[0][0]=0;\n    int mask=(1<<W)-1;\n    for(int t=0;t<H*W;t++){\n            const int i=t/W,j=t%W,p=t&1,q=(t+1)&1;\n            const int beet=(1<<(W-1));\n            const int ei=(1<<W);\n            for(int k=0;k<beet;k++){\n                if(dp[p][k]==INT_MIN)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&((1<<j)-1)];\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=INT_MIN;\n            }\n\n            for(int k=beet;k<ei;k++){\n                if(dp[p][k]==INT_MIN)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&((1<<j)-1)];\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(S[i][S[i].size()-pc[k]+l]==S[i+1][l])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=INT_MIN;\n            }\n\n        if(j==W-1)for(int k=0;k<1<<W;k++)if(pc[k]!=S[i+1].size())dp[q][k]=INT_MIN;\n    }\n\n    int ans=INT_MIN;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\nint R,C;\n\nchar s[128][20];\nint len[128];\nint dp[129][16][(1<<16)];\n\nint main(){\n  scanf(\"%d %d\",&R,&C);\n  for(int i=0;i<R;i++){\n    scanf(\"%s\",s[i]);\n    len[i]=strlen(s[i]);\n  }\n  \n  fill( (int*)dp[0], (int*)dp[128], -INF);\n  dp[0][0][0]=0;\n\n  int ans=0;\n  \n  for(int i=0;i<=R;i++){\n    for(int j=0;j<C;j++){\n      for(int bit=0;bit<(1<<C);bit++){\n        if(dp[i][j][bit]==-INF)continue;\n\n        if(j==0 && __builtin_popcount(bit) != len[i-1])continue;\n        if(i==R)ans=max(ans,dp[i][j][bit]);\n        if(i==R)continue;\n        int a=0,b=0,cost=dp[i][j][bit];\n        for(int k=0;k<C-j;k++)a+=(bit>>k&1);\n        for(int k=C-j;k<C;k++)b+=(bit>>k&1);\n\n        //   cout<<i<<' '<<j<<' '<<bit<<' '<<a<<' '<<b<<endl;\n        \n        int nbit=bit>>1;\n        if(j+1<C){\n          dp[i][j+1][nbit]=max(dp[i][j+1][nbit],cost);\n        }else{\n          dp[i+1][0][nbit]=max(dp[i+1][0][nbit],cost);\n        }\n\n        if(b==len[i])continue;\n        \n        int flg=0;\n        if(bit&1 && s[i][b]==s[i-1][len[i-1]-a])flg++;\n        if(bit>>(C-1)&1)\n          if(b>0&&s[i][b-1]==s[i][b])flg++;\n        \n        \n        nbit=(bit|(1<<C))>>1;\n        if(j+1<C){\n          dp[i][j+1][nbit]=max(dp[i][j+1][nbit],cost+flg);\n        }else{\n          dp[i+1][0][nbit]=max(dp[i+1][0][nbit],cost+flg);\n        }\n      }\n    }\n  }\n  cout<<ans*2<<endl;\n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXC = 16;\nconst int MAXR = 200;\nint R, C;\nstring S[MAXR];\n\nint dp[2][1<<MAXC];\n\nint main() {\n  cin >> R >> C;\n  for(int i = 0; i < R; ++i) {\n    cin >> S[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  dp[0][0] = 0;\n  int now = 0, next = 1;\n  for(int i = 0; i < R; ++i) {\n    for(int j = 0; j < C; ++j) {\n      fill(dp[next], dp[next] + (1<<C), -1);\n      for(int bit = 0; bit < (1<<C); ++bit) {\n        if(dp[now][bit] == -1) continue;\n        int value = dp[now][bit];\n\n        char top = '_';\n        if(i) {\n          for(int k = C - j - 1, l = S[i-1].size(); k >= 0; --k) {\n            if(bit >> k & 1) top = S[i-1][--l];\n            else top = '_';\n          }\n        }\n\n        char left = '_';\n        int num = 0;\n        for(int k = C - j, l = 0; k < C; ++k) {\n          if(bit >> k & 1) left = S[i][l++], ++num;\n          else left = '_';\n        }\n\n        do {\n          int nbit = bit >> 1;\n          if(num == S[i].size()) break;\n          char c = S[i][num];\n          nbit |= 1 << (C - 1);\n          if(j+1 == C) {\n            if(num+1 != S[i].size()) break;\n          }\n          dp[next][nbit] = max(dp[next][nbit],\n                               value\n                               + (isalpha(c) && c == top)\n                               + (isalpha(c) && c == left));\n        } while(0);\n\n        do {\n          int nbit = bit >> 1;\n          if(j+1 == C) {\n            if(num != S[i].size()) break;\n          }\n          dp[next][nbit] = max(dp[next][nbit], value);\n        } while(0);\n      }\n      swap(now, next);\n    }\n  }\n  int res = 0;\n  for(int bit = 0; bit < (1<<C); ++bit) {\n    res = max(res, dp[now][bit]);\n  }\n  cout << res*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W){\n        vector<string> str(H);\n        REP(i, H) cin >> str[i];\n\n        const int MAXS = 1 << W;\n        int dp[2][MAXS];\n        int* curr = dp[0], *next = dp[1];\n        for(int s = 0; s < MAXS; s++) curr[s] = -1;\n        curr[0] = 0;\n        for(int y = 0; y < H; y++){\n            for(int x = 0; x < W; x++){\n                for(int s = 0; s < MAXS; s++) next[s] = -1;\n                for(int s = 0; s < MAXS; s++) if(curr[s] >= 0){\n                    int cu = __builtin_popcount(s >> x); // count of upper\n                    int cl = __builtin_popcount(s & ((1 << x) - 1)); // count of lower\n                    assert(cu + cl == __builtin_popcount(s));\n\n                    if(cl + (W - 1 - x) >= str[y].size())\n                        next[s & ~(1 << x)] = max(next[s & ~(1 << x)], curr[s]); // path through\n\n                    if(cl == str[y].size()) continue;\n\n                    int add = 0;\n                    if(cl > 0 && str[y][cl] == str[y][cl - 1] && (s >> (x - 1) & 1)){\n                        add += 2;\n                    }\n                    if(y > 0 && (s >> x & 1) && str[y - 1][str[y - 1].size() - cu] == str[y][cl]){\n                        add += 2;\n                    }\n                    next[s | (1 << x)] = max(next[s | (1 << x)], curr[s] + add);\n                }\n                swap(curr, next);\n            }\n        }\n        int ans = 0;\n        for(int s = 0; s < MAXS; s++) ans = max(ans, curr[s]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\nint main(){\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\tint cs=0;\n\t\n\tif(i && c[j][k][0]<(int)s[i].size() && c[j][k][1] && 0 <= (int)s[i-1].size()-c[j][k][1] && s[i][c[j][k][0]] == s[i-1][(int)s[i-1].size()-c[j][k][1]]) cs+=2;\n\n\tif(c[j][k][0] && c[j][k][0] < (int)s[i].size() && k& 1<<(j-1) && s[i][ c[j][k][0] -1 ] == s[i][c[j][k][0]]) cs+=2;\n\n\tif( j!=w-1 || c[w-1][k][0] == (int)s[i].size() - 1) dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j] = max(dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j],dp[i%2][j][k]+cs);\n\t\n\t\n\tint nk=k;\n\tif(k&1<<j) nk-=1<<j;\n\t\n\tif( j!=w-1 || c[0][k][1] == (int)s[i].size() ) dp[(i+(j==w-1))%2][(j+1)%w][nk]=max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if(s[h-1].size()==c[0][i][1])ans=max(ans,dp[h%2][0][i]);\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n\n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n\n  int dp1[1 << 16], dp2[1 << 16];\n  memset(dp1, -1, sizeof(dp1));\n  int *latte = dp1, *malta = dp2;\n  latte[0] = 0;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      for(int j = 0; j < 1 << C; j++) malta[j] = -1;\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n\n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n\n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) {\n          ch(malta[j & ~(1 << x)], latte[j]);\n        }\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      swap(latte, malta);\n    }\n  }\n  cout << *max_element(begin(dp1), end(dp1)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    string s[200];\n    input(s, h);\n\n    int bits[bin(16)];\n    rep(mask, bin(w))\n        bits[mask] = __builtin_popcount(mask);\n\n    \n    const int inf = ten(6);\n    int cur[bin(16)], next[bin(16)];\n    fill_n(cur, bin(w), -inf);\n    rep(mask, bin(w))\n        if (bits[mask] == s[0].size())\n            cur[mask] = 0;\n    \n    rep(y, h)\n    {\n        // hor\n        rep(mask, bin(w))\n        {\n            if (bits[mask] == s[y].size())\n            {\n                int pos[16];\n                int k = 0;\n                rep(x, w)\n                    if (mask >> x & 1)\n                        pos[k++] = x;\n                rep(i, s[y].size() - 1)\n                    if (s[y][i] == s[y][i + 1] && pos[i] + 1 == pos[i + 1])\n                        ++cur[mask];\n            }\n            else\n                cur[mask] = -inf;\n        }\n\n        if (y == h - 1)\n            break;\n\n        // ver\n        rep(x, w)\n        {\n            fill_n(next, bin(w), -inf);\n            // mask = [next_mask(x bits), cur_mask(w - x bits)]\n            rep(mask, bin(w))\n            {\n                int cur_mask = mask & ((bin(w - x) - 1) << x);\n                int next_mask = mask & (bin(x) - 1);\n                int cur_i = s[y].size() - (int)bits[cur_mask];\n                int next_i = bits[next_mask];\n                if (next_i >= s[y + 1].size() || cur_i < 0)\n                    continue;\n\n\n                // empty\n                chmax(next[mask & ~bin(x)], cur[mask]);\n\n                if (next_i < s[y + 1].size())\n                {\n                    // put s[y + 1][next_i]\n                    int adjacent = (mask >> x & 1) && s[y][cur_i] == s[y + 1][next_i];\n                    chmax(next[mask | bin(x)], cur[mask] + adjacent);\n                }\n            }\n            swap(cur, next);\n        }\n    }\n\n    int res = 2 * *max_element(cur, cur + bin(w));\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n \n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n \n  vector< int > latte(1 << C, -1);\n  latte[0] = 0;\n  const int mask = (1 << C) - 1;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      vector< int > malta(1 << C, -1);\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n \n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n \n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) ch(malta[j & ~(1 << x)], latte[j]);\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      latte = malta;\n    }\n  }\n  cout << *max_element(begin(latte), end(latte)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16][20];\nconst int INF=1<<30;\nint bitPos[1<<16][17];\nint bitCnt[1<<16][17];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      for(int k=0;k<16;k++){\n\tint res=-INF;\n\tif(i==R*C)res=0;\n\telse{\n\t  const int cnt=k;\n\t  const int ct=bitCnt[mask][cx];\n\t  if(ct<(int)ss[cy].size()){\n\t    int nmask=mask|(1<<cx);\n\t    int add=0;\n\t    if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t       &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t       &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t       &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t      add+=2;\n\t    }\n\t    if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t       &&cnt<(int)ss[cy-1].size()\n\t       &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t       &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t      add+=2;\n\t    }\n\t    if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]+add);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]+add);\n\t    }\n\t  }\n\t  {\n\t    int nmask=mask&~(1<<cx);\n\t    if(cx!=C-1||ct==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]);\n\t    }\n\t  }\n\t}\n\tdp[cur][mask][k]=res;\n      }\n    }\n  }\n  cout<<dp[0][0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 130\n#define W 16\n#define INF 1e9\nusing namespace std;\nint h,w;\nstring str[H];\n\nint mem[H][W][1<<W],used[H][W][1<<W];\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]++) return mem[y][x][bit];\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ninline int popcount(int x){\n\tx=((x>>1)&0x55555555)+(x&0x55555555);\n\tx=((x>>2)&0x33333333)+(x&0x33333333);\n\tx=((x>>4)+x)&0x0f0f0f0f;\n\tx+=(x>>8);\n\tx+=(x>>16);\n\treturn x&0x3f;\n}\n\nint main(){\n\tint h,w; scanf(\"%d%d\",&h,&w);\n\tchar s[128][17];\n\tint len[128];\n\trep(i,h) scanf(\"%s\",s[i]), len[i]=strlen(s[i]);\n\n\tstatic int pc[1<<16];\n\trep(S,1<<w) pc[S]=popcount(S);\n\n\tstatic int dp[2][16][1<<16];\n\trep(i,2) rep(j,w) rep(S,1<<w) dp[i][j][S]=-INF;\n\tdp[1][w-1][0]=0;\n\trep(i,h){\n\t\tint y=i%2;\n\t\trep(j,w){\n\t\t\t// i 行目の 0~j-1 列目に k 文字置いた\n\t\t\tfor(int k=max(len[i]-(w-j),0);k<=min(len[i],j);k++){\n\t\t\t\t// j 個から k 個選ぶ組み合わせ\n\t\t\t\tfor(int S1=(1<<k)-1,_,__;S1<(1<<j);_=S1&-S1,__=S1+_,S1=((S1&~__)/_>>1)|__){\n\t\t\t\t\t// i-1 行目の j~w-1 列目に l 文字置いた\n\t\t\t\t\tfor(int l=max((i>0?len[i-1]:0)-j,0);l<=min(w-j,(i>0?len[i-1]:w));l++){\n\t\t\t\t\t\t// w-j 個から l 個選ぶ組み合わせ\n\t\t\t\t\t\tfor(int S2=(1<<l)-1,_,__;S2<(1<<w-j);_=S2&-S2,__=S2+_,S2=((S2&~__)/_>>1)|__){\n\t\t\t\t\t\t\tint S=S1|S2<<j;\n\n\t\t\t\t\t\t\tif(j>0){\n\t\t\t\t\t\t\t\t// s[i][k] を置かない\n\t\t\t\t\t\t\t\tdp[y][j][S&~(1<<j)]=max(dp[y][j][S&~(1<<j)],dp[y][j-1][S]);\n\t\t\t\t\t\t\t\t// s[i][k] を置く\n\t\t\t\t\t\t\t\tint plus=0;\n\t\t\t\t\t\t\t\tif(k>0 && s[i][k-1]==s[i][k] && S&1<<j-1) plus++; // 左と隣接\n\t\t\t\t\t\t\t\tif(i>0 && s[i][k]==s[i-1][len[i-1]-pc[S2]] && S&1<<j) plus++; // 上と隣接\n\t\t\t\t\t\t\t\tdp[y][j][S|(1<<j)]=max(dp[y][j][S|(1<<j)],dp[y][j-1][S]+plus);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{ // j==0\n\t\t\t\t\t\t\t\t// s[i][k] を置かない\n\t\t\t\t\t\t\t\tdp[y][j][S&~(1<<j)]=max(dp[y][j][S&~(1<<j)],dp[1-y][w-1][S]);\n\t\t\t\t\t\t\t\t// s[i][k] を置く\n\t\t\t\t\t\t\t\tint plus=0;\n\t\t\t\t\t\t\t\tif(i>0 && s[i][k]==s[i-1][len[i-1]-pc[S2]] && S&1<<j) plus++; // 上と隣接\n\t\t\t\t\t\t\t\tdp[y][j][S|(1<<j)]=max(dp[y][j][S|(1<<j)],dp[1-y][w-1][S]+plus);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(S2==0) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(S1==0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(S,1<<w) ans=max(ans,2*dp[(h-1)%2][w-1][S]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 17\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\n/*\n  short mem[H][W][1<<W];\n  bool used[H][W][1<<W];\n  int dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n  if(p < (int)str[y].size()) return -INF;\n  return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n  int score = 0;\n  score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n  score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n  b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n  }\n*/\n\n\nint Max(int &a,int b){return a=max(a,b);}\nint dp[2][W][1<<W];\nint A[W][1<<W],B[W][1<<W];\nvoid mkAB(int x,int bit){\n  int sum = __builtin_popcount(bit);\n  int cnt = 0;\n  for(int i=0;i<x;i++)cnt+=(bit>>i&1);\n  A[x][bit] = cnt;\n  B[x][bit] = sum - cnt;\n}\n\nint DP(){\n  for(int i=0;i<W;i++)\n    for(int j=0;j<(1<<W);j++)mkAB(i,j);\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0] = 0;\n  int res = 0;\n  for(int i=0;i<h;i++){\n    int idx = i%2;\n    for(int j=0;j<w;j++){\n      for(int bit=0;bit<(1<<w);bit++){\n        if(dp[idx][j][bit]==-1)continue;\n        int p = A[j][bit];\n        int u = str[i].size()-B[j][bit]-1;\n \n        //use space\n        int abit = bit & (~(1<<j));\n        Max(dp[idx][j+1][abit],dp[idx][j][bit]);\n        \n\n        //use character\n        if(p>=(int)str[i].size())continue;\n        int bbit = bit | (1<<j);\n        int score = 0;\n        score += 2*((bit>>j&1)&&(str[i][p]==str[i-1][u]));\n        score += 2*(j>=1&&(bit>>(j-1)&1)&&str[i][p]==str[i][p-1]);\n        Max(dp[idx][j+1][bbit],dp[idx][j][bit]+score);\n      }\n    }\n    for(int bit=0;bit<(1<<w);bit++){\n      if(__builtin_popcount(bit) != str[i].size())continue;\n      Max(dp[!idx][0][bit],dp[idx][w][bit]);\n      Max(res,dp[idx][w][bit]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  //  cout<<dfs(0,0,0,0,0)<<endl;\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int BEET=-1001001001;\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),BEET);\n    dp[0][0]=0;\n    int mask=(1<<W)-1;\n    for(int t=0;t<H*W;t++){\n            const int i=t/W,j=t%W,p=t&1,q=(t+1)&1;\n            const int beet=(1<<(W-1));\n            const int ei=(1<<W);\n            const int mask2=(1<<j)-1;\n            const int len=S[i].size();\n            const int len2=S[i+1].size();\n\n            for(int k=0;k<beet;k++){\n                if(dp[p][k]==BEET)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&mask2];\n                if(l<len2){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=BEET;\n            }\n\n            for(int k=beet;k<ei;k++){\n                if(dp[p][k]==BEET)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&mask2];\n                if(l<len2){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(S[i][len-pc[k]+l]==S[i+1][l])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=BEET;\n            }\n\n        if(j==W-1)for(int k=0;k<ei;k++)if(pc[k]!=len2)dp[q][k]=BEET;\n    }\n\n    int ans=BEET;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint pc(int b){\n  return __builtin_popcount(b);\n}\n\nint main(){\n  int R,C;\n  cin>>R>>C;\n  string s[128];\n  for(int i=0;i<R;i++){\n    cin>>s[i];\n  }\n  int dp[1<<16];\n  fill(begin(dp),end(dp),-1e9);\n  dp[0]=0;\n  int idx=0;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      int ndp[1<<16];\n      fill(begin(ndp),end(ndp),-1e9);\n      for(int k=0;k<1<<C;k++){\n\tif(dp[k]>=0){\n\t  ndp[(k<<1)%(1<<C)]=max(ndp[(k<<1)%(1<<C)],dp[k]);\n\t  int nc=pc(k%(1<<j));\n\t  if(nc<s[i].size()){\n\t    ndp[(k*2+1)%(1<<C)]=max(ndp[(k*2+1)%(1<<C)],dp[k]\n\t\t\t\t+(i&&k>>C-1&1&&s[i-1][s[i-1].size()-pc(k>>j)]==s[i][nc])\n\t\t\t\t+(C>1&&nc&&s[i][nc-1]==s[i][nc])\n\t\t\t\t);\n\t  }\n\t}\n      }\n      copy(begin(ndp),end(ndp),begin(dp));\n    }\n    for(int j=0;j<1<<C;j++){\n      if(pc(j)<s[i].size()){\n\tdp[j]=-1e9;\n      }\n    }\n  }\n  cout<<2**max_element(begin(dp),end(dp))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<string> mat;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nint r,c,ans;\n\nbool f;\n\nint check(int y, int x, mat str){\n  int res = 0;\n  if(str[y][x] == ' ') return 0;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= str.size()) continue;\n    if(nx < 0 || nx >= str[y].size()) continue;\n    if(str[ny].size() < nx) continue;\n    if(str[ny][nx] == str[y][x]) res++;\n  }\n  return res;\n}\n\nvoid calc(mat str){\n  int res = 0;\n\n  for(int i=0;i<str.size();i++)\n    for(int j=0;j<str[i].size();j++)\n      res += check(i, j, str);\n  ans = max(ans,res);\n  /*\n  if(res == 18){\n    for(int i=0;i<str.size();i++){\n      cout << str[i] << endl;\n    }\n    cout << endl;\n    for(int i=0;i<str.size();i++){\n      for(int j=0;j<str[i].size();j++) cout << check(i,j,str);\n        cout << endl;\n    }\n    cout << endl;\n    }*/\n}\n\nvoid func(int y, int x, mat str){\n  if(x == c){\n    x = 0;\n    y++;\n  }\n  if(y == r){\n    calc(str);\n    return;\n  }\n\n  if(str[y].size() < c && x < str[y].size()){\n    func(y, x+1, str);\n    if(str[y][x] == ' ') return;\n    if(y > 0){\n      for(int i=x+1;i<str[y-1].size();i++){\n        if(str[y].size() + i - x > c) break;\n        if(str[y][x] == str[y-1][i]){\n          str[y].insert(str[y].begin()+x, i-x, ' ');\n          func(y, x+(i-x)+1, str);\n          //break;\n        }\n      }\n      for(int j=x+1;j<str[y].size();j++){\n        if(str[y][j] == ' ' || str[y][j-1] != str[y][j]) break;\n        for(int i=j+1;i<str[y-1].size();i++){\n          if(str[y].size() + i - j > c) break;\n          if(str[y][j] == str[y-1][i]){\n            str[y].insert(str[y].begin()+x, i-j, ' ');\n            func(y, x+(i-j)+1, str);\n            //break;\n          }\n        }\n      }        \n    } else {\n      str[y].insert(str[y].begin()+x, ' ');\n      func(y, x+1, str);\n    }\n  } else {\n    func(y+1, 0, str);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    mat v;\n    for(int i=0;i<r;i++){\n      string str;\n      cin >> str;\n      v.push_back(str);\n    }\n    ans = 0;\n    func(0,0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll R,C; cin >> R >> C;\n    vector<string> S(R);\n    for(auto& in:S) cin >> in;\n    vector<int> bitcnt(1<<C);\n    for(int i = 0; i < (1<<C);i++){\n        bitcnt[i] = __builtin_popcount(i);\n    }\n    vector<vector<int>> dp(2,vector<int>(1<<C,-1));\n    int cur = 0, next = 1;\n    dp[cur][0] = 0;\n    for(int i = 0; i < R;i++){\n        for(int j = 0; j < C;j++){\n            for(int k = 0; k < (1<<C);k++) dp[next][k] = -1;\n            for(int k = 0; k < (1<<C);k++){\n                if(dp[cur][k] == -1) continue;\n                int cur_cnt = bitcnt[k&(1<<j) - 1];\n                if(cur_cnt < S[i].length()){\n                    int tmp = dp[cur][k];\n                    if(cur_cnt > 0 && (k & 1<<(j-1))){\n                        if(S[i][cur_cnt-1] == S[i][cur_cnt]) tmp++;\n                    }\n                    if(i > 0 && (k & (1<<j))){\n                        if(S[i][cur_cnt] == S[i-1][S[i-1].length() - bitcnt[k >> j]]) tmp++;\n                    }\n                    dp[next][k|1<<j] = max(dp[next][k|1<<j],tmp);\n                }\n                if(C - j > S[i].length() - cur_cnt){\n                    dp[next][k & ~(1<<j)] = max(dp[next][k & ~(1<<j)],dp[cur][k]);\n                }\n            }\n            cur = (cur == 0)? 1:0;\n            next = (next == 0)?1:0;\n        }\n    }\n    cout <<2 * (*max_element(dp[cur].begin(), dp[cur].end())) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, w;\nint dp[2][1 << 16], bc[1 << 16];\nstring in[130];\n\nint main(){\n\tcin >> n >> w;\n\trep(i, n) cin >> in[i];\n\trep(i, 1 << w) bc[i] = __builtin_popcount(i);\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0] = 0;\n\t\n\tint cur = 0, next = 1;\n\trep(i, n) rep(j, w){\n\t\tmemset(dp[next], -1, sizeof(dp[next]));\n\t\t\n\t\trep(bit, 1 << w) if(dp[cur][bit] >= 0){\n\t\t\tint idx = bc[bit & (1 << j) - 1];\n\t\t\tif(idx < in[i].size()){\n\t\t\t\tint nxt = dp[cur][bit];\n\t\t\t\tif(j && (bit & 1 << (j - 1)) && in[i][idx - 1] == in[i][idx]) nxt++;\n\t\t\t\tif(i && (bit & 1 << j) && in[i][idx] == in[i - 1][in[i - 1].size() - bc[bit >> j]]) nxt++;\n\t\t\t\tdp[next][bit | 1 << j] = max(dp[next][bit | 1 << j], nxt);\n\t\t\t}\n\t\t\tif(idx + w - j > in[i].size()){\n\t\t\t\tdp[next][bit & ~(1 << j)] = max(dp[next][bit & ~(1 << j)], dp[cur][bit]);\n\t\t\t}\n\t\t}\n\t\tswap(cur, next);\n\t}\n\tcout << 2 * *max_element(dp[cur], dp[cur] + (1 << w)) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 130\n#define W 16\n#define INF 1e9\nusing namespace std;\nint h,w;\nstring str[H];\n\nshort mem[H][W][1<<W],used[H][W][1<<W];\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]++) return mem[y][x][bit];\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W){\n        vector<string> str(H);\n        REP(i, H) cin >> str[i];\n\n        const int MAXS = 1 << W;\n\n        int bp[MAXS];\n        for(int s = 0; s < MAXS; s++) bp[s] = __builtin_popcount(s);\n        \n        int dp[2][MAXS];\n        int* curr = dp[0], *next = dp[1];\n        for(int s = 0; s < MAXS; s++) curr[s] = -1;\n        curr[0] = 0;\n\n        for(int y = 0; y < H; y++){\n            for(int x = 0; x < W; x++){\n                for(int s = 0; s < MAXS; s++) next[s] = -1;\n                for(int s = 0; s < MAXS; s++) if(curr[s] >= 0){\n                    int cu = bp[s >> x]; // count of upper\n                    int cl = bp[s & ((1 << x) - 1)]; // count of lower\n\n                    if(cl + (W - 1 - x) >= str[y].size())\n                        next[s & ~(1 << x)] = max(next[s & ~(1 << x)], curr[s]); // path through\n\n                    if(cl == str[y].size()) continue;\n\n                    int add = 0;\n                    if(cl > 0 && str[y][cl] == str[y][cl - 1] && (s >> (x - 1) & 1)){\n                        add += 2;\n                    }\n                    if(y > 0 && (s >> x & 1) && str[y - 1][str[y - 1].size() - cu] == str[y][cl]){\n                        add += 2;\n                    }\n                    next[s | (1 << x)] = max(next[s | (1 << x)], curr[s] + add);\n                }\n                swap(curr, next);\n            }\n        }\n\n        int ans = 0;\n        for(int s = 0; s < MAXS; s++) ans = max(ans, curr[s]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-7)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nint R,C;\nstring ss[201];\nmap<vector<char>,int> dp[128][16];\nconst int INF=1<<30;\n\nint dfs(vector<char> v,int cy,int cx,int pos){\n  if(dp[cy][cx].count(v)>0)return dp[cy][cx][v];\n  int res=-INF;\n  if(cy==R)return 0;\n  if((int)ss[cy].size()-pos>C-cx)return res;\n  if(cx==(int)v.size()){\n    if(pos!=(int)ss[cy].size())return res;\n    return dfs(v,cy+1,0,0);\n  }\n  // 今回の所に割り当てる場合\n  if(pos!=(int)ss[cy].size()){\n    vector<char> nv=v;\n    int add=0;\n    nv[cx]=pos;\n    if(cx-1>=0&&ss[cy][v[cx-1]]==ss[cy][pos])add+=2;\n    if(v[cx]!=-1&&cy!=0&&ss[cy-1][v[cx]]==ss[cy][pos])add+=2;\n    res=max(res,add+dfs(nv,cy,cx+1,pos+1));\n  }\n  // 今回の所に割り当てない場合\n  {\n    vector<char> nv=v;\n    nv[cx]=-1;\n    res=max(res,dfs(nv,cy,cx+1,pos));\n  }\n  return dp[cy][cx][v]=res;\n}\n\nint main(){\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  vector<char> initv(C,-1);\n  int res=dfs(initv,0,0,0);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,dp[2][1<<16],I;\nstring s[128];\nbool B(int x,int i){return (x>>i)&1;}\nint bc(int x){return x==0?0:__builtin_popcount(x);}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[i];\n\trep(b,1<<W) dp[0][b]=-1;\n\tdp[0][0]=0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\trep(b,1<<W) dp[1-I][b]=-1;\n\t\t\trep(b,1<<W){\n\t\t\t\tif(dp[I][b]<0) continue;\n\t\t\t\t//put\n\t\t\t\tint x=bc(b&((1<<j)-1));\n\t\t\t\tif(x<s[i].size()){\n\t\t\t\t\tint pl=0;\n\t\t\t\t\tif(i>0&&B(b,j)&&s[i-1][s[i-1].size()+x-bc(b)]==s[i][x]) pl+=2;//tate\n\t\t\t\t\tif(j>0&&B(b,j-1)&&s[i][x]==s[i][x-1]) pl+=2;//yoko\n\t\t\t\t\tchmax(dp[1-I][b|(1<<j)],dp[I][b]+pl);\n\t\t\t\t}\n\t\t\t\t//dont put\n\t\t\t\tchmax(dp[1-I][b&(~(1<<j))],dp[I][b]);\n\t\t\t}\n\t\t\tI=1-I;\n\t\t}\n\t\trep(b,1<<W) if(bc(b)!=s[i].size()) dp[I][b]=0;\n\t}\n\tint ans=0;\n\trep(i,1<<W) chmax(ans,dp[I][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16];\nconst int INF=1<<30;\nint bitPos[1<<16][18];\nint bitCnt[1<<16][18];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      int res=-INF;\n      if(i==R*C)res=0;\n      else{\n\tconst int cnt=(int)ss[cy].size()-(bitCnt[mask][16]-bitCnt[mask][cx]);\n\tconst int ct=bitCnt[mask][cx];\n\tif(ct<(int)ss[cy].size()){\n\t  int nmask=mask|(1<<cx);\n\t  int add=0;\n\t  if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t     &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t     &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t     &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t    add+=2;\n\t  }\n\t  if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t     &&cnt<(int)ss[cy-1].size()\n\t     &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t     &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t    add+=2;\n\t  }\n\t  if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t    res=max(res,dp[nxt][nmask]+add);\n\t  }\n\t}\n\t{\n\t  int nmask=mask&~(1<<cx);\n\t  if(cx!=C-1||ct==(int)ss[cy].size()){\n\t    res=max(res,dp[nxt][nmask]);\n\t  }\n\t}\n      }\n      dp[cur][mask]=res;\n    }\n  }\n  cout<<dp[0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 19191919;\n\nint main(){\n    int r,c;\n    cin >>r >>c;\n    vector<string> s(r);\n    vector<int> L(r);\n    rep(i,r){\n        cin >>s[i];\n        L[i] = s[i].size();\n    }\n\n    int U = (1<<c)-1;\n    vector<int> cm(c), pm(c);\n    rep(i,c){\n        rep(j,i) cm[i] |= (1<<j);\n        pm[i] = cm[i]^U;\n    }\n\n    vector<int> dp(1<<c, -INF);\n    dp[0] = 0;\n    rep(i,r)rep(j,c){\n        int nr = i;\n        int nc = j+1;\n        if(nc == c){\n            ++nr;\n            nc = 0;\n        }\n\n        vector<int> nx(1<<c,-INF);\n        rep(mask,1<<c)if(dp[mask]>=0){\n            // printf(\" %d %d %d\\n\",i,j,mask);\n            int idx = __builtin_popcount(mask&cm[j]);\n            if(idx<=L[i]){\n                // not put\n                int nmask = (mask<<1)&U;\n                if( !(i!=nr && idx<L[i]) ) nx[nmask] = max(nx[nmask], dp[mask]);\n\n                // put\n                if(idx<L[i]){\n                    nmask |= 1;\n\n                    int add = 0;\n                    // left\n                    if(idx>0 && j>0 && (mask&1)) add += (s[i][idx]==s[i][idx-1]);\n                    // up\n                    if( (mask>>(c-1))&1 ){\n                        int ct = __builtin_popcount(mask&pm[j]);\n                        int pre_idx = L[i-1]-ct;\n                        if(pre_idx<0) continue;\n\n                        add += (s[i][idx]==s[i-1][pre_idx]);\n                    }\n\n                    if( !(i!=nr && idx<L[i]-1) ) nx[nmask] = max(nx[nmask], dp[mask]+add);\n                }\n            }\n        }\n\n        dp = nx;\n    }\n\n    int ans = 0;\n    rep(i,1<<c) ans = max(ans, dp[i]);\n    cout << ans*2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dp[2][1<<16];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int R, C;\n  cin >> R >> C;\n  VI len(R);\n  VS vs(R);\n  REP(i,R){\n\tcin >> vs[i];\n\tlen[i] = SZ(vs[i]);\n  }\n\n  int crt = 0, nxt = 1;\n  REP(B,1<<C){\n\tif(__builtin_popcount(B) != len[0]) continue;\n\tfor(int x=0,i=0;i+1<len[0];++i){\n\t  while(x < C && (B>>x&1) == 0) ++x;\n\t  if((B>>(x+1)&1) && vs[0][i] == vs[0][i+1])\n\t\tdp[crt][B]++;\n\t  ++x;\n\t}\n  }\n\n  FOR(y,1,R){\n\tREP(x,C){\n\t  fill(dp[nxt], dp[nxt]+(1<<16), 0);\n\t  REP(B,1<<C){\n\t\t// not place character\n\t\tmaxi(dp[nxt][B>>1], dp[crt][B]);\n\n\t\tint next_b = (B >> 1) | (1 << (C-1));\n\t\tint next = dp[crt][B];\n\t\tint lb = B & ((1<<(C-x))-1);\n\t\tint lbi = len[y-1] - __builtin_popcount(lb);\n\t\tint ub = B >> (C-x);\n\t\tint ubi = __builtin_popcount(ub);\n\n\t\tif(ubi >= len[y])\n\t\t  continue;\n\t\t// up\n\t\tif(lbi < len[y-1] && (B&1) && vs[y-1][lbi] == vs[y][ubi])\n\t\t  ++next;\n\t\t// left\n\t\tif(ubi > 0 && (B>>(C-1)&1) && vs[y][ubi-1] == vs[y][ubi])\n\t\t  ++next;\n\n\t\tmaxi(dp[nxt][next_b], next);\n\t  }\n\t  swap(crt, nxt);\n\t}\n\n\tREP(B,1<<C){\n\t  if(__builtin_popcount(B) != len[y])\n\t\tdp[crt][B] = 0;\n\t}\n  }\n\n  int ans = 0;\n  REP(B,1<<C)\n\tmaxi(ans, dp[crt][B]);\n  cout << ans*2 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<string> mat;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nint r,c,ans,cnt;\n\nbool f;\n\nint check(int y, int x, mat str){\n  int res = 0;\n  if(str[y][x] == ' ') return 0;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= str.size()) continue;\n    if(nx < 0 || nx >= str[y].size()) continue;\n    if(str[ny].size() < nx) continue;\n    if(str[ny][nx] == str[y][x]) res++;\n  }\n  return res;\n}\n\nvoid calc(mat str){\n  int res = 0;\n\n  for(int i=0;i<str.size();i++)\n    for(int j=0;j<str[i].size();j++)\n      res += check(i, j, str);\n  ans = max(ans,res);\n\n  /*\n  if(res == 18){\n    for(int i=0;i<str.size();i++){\n      cout << str[i] << endl;\n    }\n    cout << endl;\n    for(int i=0;i<str.size();i++){\n      for(int j=0;j<str[i].size();j++) cout << check(i,j,str);\n        cout << endl;\n    }\n    cout << endl;\n    }\n  */\n  cnt++;\n}\n\nvoid func(int y, int x, mat str){\n  if(x == c){\n    x = 0;\n    y++;\n  }\n  if(y == r){\n    calc(str);\n    return;\n  }\n\n  if(str[y].size() < c && x < str[y].size()){\n    func(y, x+1, str);\n    if(str[y][x] == ' ') return;\n    if(y > 0){\n      for(int i=x+1;i<str[y-1].size();i++){\n        if(str[y].size() + i - x > c) break;\n        if(str[y][x] == str[y-1][i]){\n          str[y].insert(str[y].begin()+x, i-x, ' ');\n          func(y, x+(i-x)+1, str);\n          break;\n        }\n      }\n\n      if(y < r - 1){\n        for(int i=x+1;i<str[y+1].size();i++){\n          if(str[y].size() + i - x > c) break;\n          if(str[y][x] == str[y+1][i]){\n            str[y].insert(str[y].begin()+x, i-x, ' ');\n            func(y, x+(i-x)+1, str);\n            break;\n          }\n        }\n      }\n      \n      for(int j=x+1;j<str[y].size();j++){\n        if(str[y][j] == ' ' || str[y][j-1] != str[y][j]) break;\n        for(int i=j+1;i<str[y-1].size();i++){\n          if(str[y].size() + i - j > c) break;\n          if(str[y][j] == str[y-1][i]){\n            str[y].insert(str[y].begin()+x, i-j, ' ');\n            func(y, x+(i-j)+1, str);\n            break;\n          }\n        }\n      }\n    } else {\n      str[y].insert(str[y].begin()+x, ' ');\n      func(y, x+1, str);\n    }\n  } else {\n    func(y+1, 0, str);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    mat v;\n    for(int i=0;i<r;i++){\n      string str;\n      cin >> str;\n      v.push_back(str);\n    }\n    ans = 0;\n    cnt = 0;\n    func(0,0,v);\n    cout << ans /*<< ' ' << cnt*/<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,c;\nstring str[130];\nint dp[2][1<<17];\nvector<int> pat[17];\n\nint main(void){\n\tscanf(\"%d%d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tint now=1,prev=0;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tfor(int bit=0;bit<(1<<c);bit++){\n\t\t\t\tif(dp[prev][bit]>=0){\n\t\t\t\t\tif(j==0 && i>0){\n\t\t\t\t\t\tif(__builtin_popcount(bit)!=(int)str[i-1].size())continue;\n\t\t\t\t\t}\n\t\t\t\t\tint nbit=bit<<1;\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\tif(nbit>=(1<<c)){\n\t\t\t\t\t\tnbit-=(1<<c);\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t\tdp[now][nbit]=max(dp[now][nbit],dp[prev][bit]);\n\t\t\t\t\tint sc=0;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\tif(bit>>k & 1)cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j>0 && (bit>>1 & 1)){\n\t\t\t\t\t\tif(cnt>0 && str[i][cnt-1]==str[i][cnt])sc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tint v=__builtin_popcount(bit)-cnt;\n\t\t\t\t\t\tif(v>0){\n\t\t\t\t\t\t\tif(str[i-1][(int)str[i-1].size()-v]==str[i][cnt])sc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[now][nbit+1]=max(dp[now][nbit+1],dp[prev][bit]+sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(now,prev);\n\t\t\tmemset(dp[now],-1,sizeof(dp[now]));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<c);i++){\n\t\tif(__builtin_popcount(i)==(int)str[r-1].size()){\n\t\t\tans=max(ans,dp[prev][i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\n// 長さnの11..11\nuint one(int n)\n{\n\treturn (1<<n)-1;\n}\n\ntemplate<typename T>\nvoid chmax(T& a,const T& b)\n{\n\ta=max(a,b);\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs ss(h);\n\t\trep(i,h) cin>>ss[i];\n\t\t\n\t\tss.insert(begin(ss),string(w,'#'));\n\t\th++;\n\t\t\n\t\tvector<vvi> dp(1,vvi(w,vi(1<<w,-INF)));\n\t\tdp[0][w-1][(1<<w)-1]=0;\n\t\t\n\t\trepi(i,1,h){\n\t\t\tdp.push_back(vvi(w,vi(1<<w,-INF)));\n\t\t\trep(j,w){\n\t\t\t\tint pi=i,pj=j-1;\n\t\t\t\tif(pj<0) pi--,pj+=w;\n\t\t\t\trep(k,1<<w){\n\t\t\t\t\tint al=popcount(k&one(j+1)),ar=ss[i].size()-al;\n\t\t\t\t\tint br=popcount(k>>j+1&one(w-j-1)),bl=ss[i-1].size()-br;\n\t\t\t\t\tif(al<0 || j+1<al || ar<0 || w-j-1<ar\n\t\t\t\t\t   || bl<0 || j+1<bl || br<0 || w-j-1<br) continue;\n\t\t\t\t\tif(k>>j&1){\n\t\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]+2*(ss[i][al-1]==ss[i-1][bl-1]));\n\t\t\t\t\t\tif(al>=2 && (k>>j-1&1) && ss[i][al-2]==ss[i][al-1])\n\t\t\t\t\t\t\tdp[i][j][k]+=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]);\n\t\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvvi().swap(dp[i-1]);\n\t\t}\n\t\t\n\t\tcout<<*max_element(all(dp[h-1][w-1]))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n\n    vector<string> s(h);\n    for(int i=0; i<h; ++i)\n        cin >> s[i];\n\n    vector<int> dp(1<<w, -1);\n    dp[0] = 0;\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            vector<int> next(1<<w, -1);\n            for(int i=0; i<(1<<w); ++i){\n                if(dp[i] == -1)\n                    continue;\n\n                bitset<32> bs(i);\n                int a = (bs & bitset<32>((1 << x) - 1)).count();\n                int b = (bs >> x).count();\n\n                if(a + w - x - 1 >= s[y].size()){\n                    bitset<32> bs2 = bs << 1;\n                    bs2[w] = false;\n                    next[bs2.to_ulong()] = max(next[bs2.to_ulong()], dp[i]);\n                }\n\n                if(a < s[y].size()){\n                    int p = dp[i];\n                    if(bs[w-1] && s[y-1][s[y-1].size()-b] == s[y][a])\n                        p += 2;\n                    if(a > 0 && bs[0] && s[y][a-1] == s[y][a])\n                        p += 2;\n\n                    bitset<32> bs2 = bs << 1;\n                    bs2[w] = false;\n                    bs2[0] = true;\n                    next[bs2.to_ulong()] = max(next[bs2.to_ulong()], p);\n                }\n            }\n            dp.swap(next);\n        }\n    }\n\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-7)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nint R,C;\nstring ss[201];\nmap<vector<char>,int> dp[128][16];\nconst int INF=1<<30;\n\nint dfs(vector<char> v,int cy,int cx,int pos){\n  if(dp[cy][cx].count(v)>0)return dp[cy][cx][v];\n  int res=-INF;\n  if(cy==R)return 0;\n  if(cx==(int)v.size()){\n    if(pos!=(int)ss[cy].size())return res;\n    return dfs(v,cy+1,0,0);\n  }\n  // 今回の所に割り当てる場合\n  if(pos!=(int)ss[cy].size()){\n    vector<char> nv=v;\n    int add=0;\n    nv[cx]=pos;\n    if(cx-1>=0&&ss[cy][v[cx-1]]==ss[cy][pos])add+=2;\n    if(v[cx]!=-1&&cy!=0&&ss[cy-1][v[cx]]==ss[cy][pos])add+=2;\n    res=max(res,add+dfs(nv,cy,cx+1,pos+1));\n  }\n  // 今回の所に割り当てない場合\n  {\n    vector<char> nv=v;\n    nv[cx]=-1;\n    res=max(res,dfs(nv,cy,cx+1,pos));\n  }\n  return dp[cy][cx][v]=res;\n}\n\nint main(){\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  vector<char> initv(C,-1);\n  int res=dfs(initv,0,0,0);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\n\nsigned main(){\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),INT_MIN);\n    dp[0][0]=0;\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<(1<<W);k++){\n                if(dp[(i*W+j)&1][k]==INT_MIN)continue;\n                chmax(dp[(i*W+j+1)&1][(k<<1)&((1<<W)-1)],dp[(i*W+j)&1][k]);\n\n                int l=__builtin_popcount(k&((1<<j)-1));\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(k>>(W-1)&1){\n                        int m=__builtin_popcount(k)-l;\n                        m=S[i].size()-m;\n                        if(S[i][m]==S[i+1][l])po++;\n                    }\n                    chmax(dp[(i*W+j+1)&1][((k<<1)&((1<<W)-1))+1],dp[(i*W+j)&1][k]+po*2);\n                }\n\n                dp[(i*W+j)&1][k]=INT_MIN;\n            }\n        }\n        for(int j=0;j<1<<W;j++)if(__builtin_popcount(j)!=S[i+1].size())dp[(i*W+W)&1][j]=INT_MIN;\n    }\n\n    int ans=INT_MIN;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-7)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nint R,C;\nstring ss[201];\nmap<vector<char>,int> dp[128][16][16];\nconst int INF=1<<30;\n\nint dfs(vector<char> v,int cy,int cx,int pos){\n  if(dp[cy][cx][pos].count(v)>0)return dp[cy][cx][pos][v];\n  int res=-INF;\n  if(cy==R)return 0;\n  if(cx==(int)v.size()){\n    if(pos!=(int)ss[cy].size())return res;\n    return dfs(v,cy+1,0,0);\n  }\n  // 今回の所に割り当てる場合\n  if(pos!=(int)ss[cy].size()){\n    vector<char> nv=v;\n    int add=0;\n    nv[cx]=pos;\n    if(cx-1>=0&&ss[cy][v[cx-1]]==ss[cy][pos])add+=2;\n    if(v[cx]!=-1&&cy!=0&&ss[cy-1][v[cx]]==ss[cy][pos])add+=2;\n    res=max(res,add+dfs(nv,cy,cx+1,pos+1));\n  }\n  // 今回の所に割り当てない場合\n  {\n    vector<char> nv=v;\n    nv[cx]=-1;\n    res=max(res,dfs(nv,cy,cx+1,pos));\n  }\n  return dp[cy][cx][pos][v]=res;\n}\n\nint main(){\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  vector<char> initv(C,-1);\n  int res=dfs(initv,0,0,0);\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 130\n#define C 16\nusing namespace std;\ntypedef pair<int,int> P;\n\nint r, c, dp[2][C][(1<<C)];\nP memo[C][(1<<C)];\nstring s[N];\n\nvoid init(){\n  \n  for(int i=0;i<c;i++)\n    \n    for(int j=0;j<(1<<c);j++){\n\n      int cnt=0;\n      for(int k=0;k<i;k++)\n\tif(j&(1<<k)) cnt++;\n      memo[i][j].first=cnt;\n      \n      cnt=0;\n      for(int k=i;k<c;k++)\n\tif(j&(1<<k)) cnt++;\n      memo[i][j].second=cnt;\n      \n    }\n\n}\n\nint main(){\n  \n  cin>>r>>c;\n  \n  for(int i=0;i<r;i++) cin>>s[i];\n\n  init();\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][0][0]=0;\n  \n  for(int i=0;i<r;i++){\n\n    for(int j=0;j<c;j++)\n      for(int k=0;k<(1<<c);k++) dp[(i+1)%2][j][k]=-1;\n    \n    for(int j=0;j<c;j++){\n      \n      for(int k=0;k<(1<<c);k++){\n\t\n\tif(dp[i%2][j][k]==-1) continue;\n\t\n\tif(memo[j][k].first<s[i].size()){\n\t  \n\t  int cost=dp[i%2][j][k], nk=k|(1<<j);\n\t  \n\t  if(i&&(k&(1<<j))&&s[i][memo[j][k].first]==s[i-1][s[i-1].size()-memo[j][k].second]) cost+=2;\n\t  \n\t  if(j&&(k&(1<<(j-1)))&&s[i][memo[j][k].first]==s[i][memo[j][k].first-1]) cost+=2;\n\t  \n\t  if(j==c-1&&memo[j][k].first+1==s[i].size()) dp[(i+1)%2][0][nk]=max(dp[(i+1)%2][0][nk],cost);\n\t  if(j!=c-1) dp[i%2][j+1][nk]=max(dp[i%2][j+1][nk],cost);\n\t  \n\t}\n\n\tint nk=k&~(1<<j);\n\t\n\tif(j==c-1&&memo[0][nk].second==s[i].size()) dp[(i+1)%2][0][nk]=max(dp[(i+1)%2][0][nk],dp[i%2][j][k]);\n\tif(j!=c-1) dp[i%2][j+1][nk]=max(dp[i%2][j+1][nk],dp[i%2][j][k]);\n\t\n      }\n      \n    }\n    \n  }\n  \n  int ans=0;\n  \n  for(int i=0;i<(1<<c);i++) ans=max(ans,dp[r%2][0][i]);\n\n  cout<<ans<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 19191919;\n\nint main(){\n    int r,c;\n    cin >>r >>c;\n    vector<string> s(r);\n    vector<int> L(r);\n    rep(i,r){\n        cin >>s[i];\n        L[i] = s[i].size();\n    }\n\n    int U = (1<<c)-1;\n    vector<int> cm(c), pm(c);\n    rep(i,c){\n        rep(j,i) cm[i] |= (1<<j);\n        pm[i] = cm[i]^U;\n    }\n\n    vector<int> dp(1<<c, -INF);\n    dp[0] = 0;\n    rep(i,r)rep(j,c){\n        int nr = i;\n        int nc = j+1;\n        if(nc == c){\n            ++nr;\n            nc = 0;\n        }\n\n        vector<int> nx(1<<c,-INF);\n        rep(mask,1<<c)if(dp[mask]>=0){\n            // printf(\" %d %d %d\\n\",i,j,mask);\n            int idx = __builtin_popcount(mask&cm[j]);\n            if(idx<=L[i]){\n                // not put\n                int nmask = (mask<<1)&U;\n                if( !(i!=nr && idx<L[i]) ) nx[nmask] = max(nx[nmask], dp[mask]);\n\n                // put\n                if(idx<L[i]){\n                    nmask |= 1;\n\n                    int add = 0;\n                    // left\n                    if(idx>0) add += (s[i][idx]==s[i][idx-1]);\n                    // up\n                    if( (mask>>(c-1))&1 ){\n                        int ct = __builtin_popcount(mask&pm[j]);\n                        int pre_idx = L[i-1]-ct;\n                        if(pre_idx<0) continue;\n\n                        add += (s[i][idx]==s[i-1][pre_idx]);\n                    }\n\n                    if( !(i!=nr && idx<L[i]-1) ) nx[nmask] = max(nx[nmask], dp[mask]+add);\n                }\n            }\n        }\n\n        dp = nx;\n    }\n\n    int ans = 0;\n    rep(i,1<<c) ans = max(ans, dp[i]);\n    cout << ans*2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\tdp[(i+1)%2][j][k]=-1e9;\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tint idx = c[j][k][0],o=(int)s[i-1].size()-c[j][k][1];\n\t\n\tif(i && k&(1<<j) && idx <(int)s[i].size() && 0<=o && o < (int)s[i-1].size() && s[i][idx] == s[i-1][o]) cs+=2;\n\n\n\tif(j && idx && idx < (int)s[i].size() && (k & 1<<(j-1) ) && s[i][idx -1] == s[i][idx]) cs+=2;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() -1){\n\t  Max(dp[(i+(j==w-1))%2][(j+1)%w][k|(1<<j)],dp[i%2][j][k]+cs);\n\n\t}\n\tint nk=k;\n\tif(k&1<<j) nk^=1<<j;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() ) Max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if((int)s[h-1].size()==c[0][i][1]){\n      ans=max(ans,dp[h%2][0][i]);\n    }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n\nvoid solve() {\n\tint h, w; cin >> h >> w;\n\tvector<int> dp(1 << w,-mod);\n\tvector<int> cop(1 << w);\n\tint sup = (1 << w);\n\tdp[0] = 0;\n\tvector<string> s(h);\n\trep(i, h)cin >> s[i];\n\trep(i, h) {\n\t\tint len = s[i].length();\n\t\trep(j, w) {\n\t\t\tfill(cop.begin(), cop.end(), -mod);\n\t\t\trep(k, sup) {\n\t\t\t\tif (dp[k] < 0)continue;\n\t\t\t\t//take\n\t\t\t\tint tmp = 0;\n\t\t\t\tvector<bool> b;\n\t\t\t\trep(l, w) {\n\t\t\t\t\tif (k&(1 << l))b.push_back(true);\n\t\t\t\t\telse b.push_back(false);\n\t\t\t\t}\n\t\t\t\trep(l, j)if (b[l])tmp++;\n\t\t\t\tint tmpall = 0;\n\t\t\t\trep(l, w)if (b[l])tmpall++;\n\t\t\t\tif (tmp < len) {\n\t\t\t\t\tint nid = k * 2+1; nid %= sup;\n\t\t\t\t\tint val = dp[k];\n\t\t\t\t\tif (b[0] && j > 0) {\n\t\t\t\t\t\tif (s[i][tmp - 1] == s[i][tmp])val++;\n\t\t\t\t\t}\n\t\t\t\t\tif (b[w - 1]) {\n\t\t\t\t\t\tif (s[i - 1][(int)s[i - 1].length() - (tmpall - tmp)] == s[i][tmp])val++;\n\t\t\t\t\t}\n\t\t\t\t\tcop[nid] = max(cop[nid], val);\n\t\t\t\t}\n\t\t\t\t//non_take\n\t\t\t\tint nid = k * 2; nid %= sup;\n\t\t\t\tcop[nid] = max(cop[nid], dp[k]);\n\t\t\t}\n\t\t\trep(k, sup) {\n\t\t\t\tbool f = true;\n\t\t\t\tint tmp = 0;\n\t\t\t\trep(l, j + 1) {\n\t\t\t\t\tif (k&(1 << l))tmp++;\n\t\t\t\t}\n\t\t\t\tif (tmp + w - (j + 1) < len)f=false;\n\t\t\t\tif (f) {\n\t\t\t\t\tdp[k] = cop[k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[k] = -mod;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, (1 << w))ans = max(ans, dp[i]);\n\tcout << ans*2 << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t/*while (cin >> m >> num[0] >> num[1], m | num[0] | num[1]) {\n\t\tsolve();\n\t}*/\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst BEET=-1001001001;\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),BEET);\n    dp[0][0]=0;\n    int mask=(1<<W)-1;\n    for(int t=0;t<H*W;t++){\n            const int i=t/W,j=t%W,p=t&1,q=(t+1)&1;\n            const int beet=(1<<(W-1));\n            const int ei=(1<<W);\n            const int mask2=(1<<j)-1;\n            const int len=S[i].size();\n            const int len2=S[i+1].size();\n            \n            for(int k=0;k<beet;k++){\n                if(dp[p][k]==BEET)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&mask2];\n                if(l<len2){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=BEET;\n            }\n\n            for(int k=beet;k<ei;k++){\n                if(dp[p][k]==BEET)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&mask2];\n                if(l<len2){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(S[i][len-pc[k]+l]==S[i+1][l])po++;\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=BEET;\n            }\n\n        if(j==W-1)for(int k=0;k<ei;k++)if(pc[k]!=len2)dp[q][k]=BEET;\n    }\n\n    int ans=BEET;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W){\n        vector<string> str(H);\n        REP(i, H) cin >> str[i];\n\n        const int MAXS = 1 << W;\n        vector<int> dp(MAXS, -INF);\n        dp[0] = 0;\n        for(int y = 0; y < H; y++){\n            for(int x = 0; x < W; x++){\n                vector<int> next(MAXS, -INF);\n                for(int s = 0; s < MAXS; s++) if(dp[s] >= 0){\n                    int cu = __builtin_popcount(s >> x); // count of upper\n                    int cl = __builtin_popcount(s & ((1 << x) - 1)); // count of lower\n                    assert(cu + cl == __builtin_popcount(s));\n\n                    if(cl + (W - 1 - x) >= str[y].size())\n                        next[s << 1 & (MAXS - 1)] = max(next[s << 1 & (MAXS - 1)], dp[s]); // path through\n\n                    if(cl == str[y].size()) continue;\n\n                    int add = 0;\n                    if(cl > 0 && str[y][cl] == str[y][cl - 1] && (s & 1)){\n                        add += 2;\n                    }\n                    if(y > 0 && (s >> (W - 1) & 1) && str[y - 1][str[y - 1].size() - cu] == str[y][cl]){\n                        add += 2;\n                    }\n                    next[(s << 1 & (MAXS - 1)) | 1] = max(next[(s << 1 & (MAXS - 1)) | 1], dp[s] + add);\n                }\n                dp.swap(next);\n            }\n        }\n        int ans = 0;\n        for(int s = 0; s < MAXS; s++) ans = max(ans, dp[s]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 16\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\nunordered_map <short,short> mem[H][W];\n\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n  \n  if(mem[y][x].count(bit)) return mem[y][x][bit];\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\n// 長さnの11..11\nuint one(int n)\n{\n\treturn (1<<n)-1;\n}\n\ntemplate<typename T>\nvoid chmax(T& a,const T& b)\n{\n\ta=max(a,b);\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs ss(h);\n\t\trep(i,h) cin>>ss[i];\n\t\t\n\t\tss.insert(begin(ss),string(w,'#'));\n\t\th++;\n\t\t\n\t\tvector<vvi> dp(h,vvi(w,vi(1<<w,-INF)));\n\t\tdp[0][w-1][(1<<w)-1]=0;\n\t\t\n\t\trepi(i,1,h) rep(j,w){\n\t\t\tint pi=i,pj=j-1;\n\t\t\tif(pj<0) pi--,pj+=w;\n\t\t\trep(k,1<<w){\n\t\t\t\tint al=popcount(k&one(j+1)),ar=ss[i].size()-al;\n\t\t\t\tint br=popcount(k>>j+1&one(w-j-1)),bl=ss[i-1].size()-br;\n\t\t\t\tif(al<0 || j+1<al || ar<0 || w-j-1<ar\n\t\t\t\t|| bl<0 || j+1<bl || br<0 || w-j-1<br) continue;\n\t\t\t\tif(k>>j&1){\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]+2*(ss[i][al-1]==ss[i-1][bl-1]));\n\t\t\t\t\tif(al>=2 && (k>>j+1&1) && ss[i][al-2]==ss[i][al-1])\n\t\t\t\t\t\tdp[i][j][k]+=2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout<<*max_element(all(dp[h-1][w-1]))<<endl;\n\t\tint res=*max_element(all(dp[h-1][w-1]));\n\t\tif(res==-INF) cout<<0<<endl;\n\t\telse          cout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W){\n        vector<int> vs[17];\n        for(int s = 0; s < 1 << W; s++){\n            vs[__builtin_popcount(s)].push_back(s);\n        }\n        vector<string> str(H + 1);\n        static int dp[129][1 << 16] = {};\n        int ans = 0;\n        for(int y = 1; y <= H; y++){\n            cin >> str[y];\n            for(auto bs : vs[str[y - 1].size()]){\n                char bgrid[16] = {};\n                for(int x = 0, curr = 0; x < W; x++){\n                    if(bs >> x & 1){\n                        bgrid[x] = str[y - 1][curr++];\n                    }\n                    assert(x != W - 1 || curr == str[y - 1].size());\n                }\n                for(auto ns : vs[str[y].size()]){\n                    char ngrid[16] = {};\n                    for(int x = 0, curr = 0; x < W; x++){\n                        if(ns >> x & 1){\n                            ngrid[x] = str[y][curr++];\n                        }\n                        assert(x != W - 1 || curr == str[y].size());\n                    }\n                    int add = 0;\n                    for(int x = 0; x < W; x++){\n                        if(ngrid[x] && ngrid[x] == bgrid[x]) add += 2;\n                        if(x < W - 1 && ngrid[x] && ngrid[x] == ngrid[x + 1]) add += 2;\n                    }\n                    dp[y][ns] = max(dp[y][ns], dp[y - 1][bs] + add);\n                    ans = max(ans, dp[y][ns]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PInt;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint dp[2][1<<16];\nint main() {\n  int R, C;\n  cin >> R >> C;\n  string A[130];\n  rep(i, R) cin >> A[i];\n  int cur = 0, next = 1;\n  memset(dp, -1, sizeof(dp));\n  dp[cur][0] = 0;\n  rep(i, R) rep(j, C) {\n    //    rep(k, 1<<C) dp[next][k] = 0;\n    memset(dp + next, -1, sizeof(dp[0]));\n    rep(k, 1<<C) if (dp[cur][k] != -1) {\n      int score = 0;\n      int ak = k & ~(1<<j);\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n\n      char c = A[i][__builtin_popcount(k&((1<<j)-1))];\n      if (i > 0 && (k>>j&1) && (A[i-1][SZ(A[i-1]) - __builtin_popcount(k>>j)] == c)) score++;\n      if (j > 0 && (k>>(j-1)&1) && (A[i][__builtin_popcount(k&((1<<j)-1))-1] == c)) score++;\n      ak = k | 1<<j;\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n    }\n    swap(cur, next);\n\n  }\n\n  int ans = 0;\n  rep(k, 1<<C)\n    ans = max(ans, dp[cur][k]);\n  cout << ans * 2 << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\n\n\n\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint r,c;\n \tcin>>r>>c;\n \tstring s[130];\n \tint x=0,y=c-1;\n \tfor(int i=1;i<=r;i++)cin>>s[i];\n \tvector<int>dp(1<<(c),-inf);\n \tdp[0]=0;\n \ts[0]=\"\";\n \twhile(1){\n \t\t\n \t\tint tx=x,ty=y+1;\n \t\tif(ty==c){\n \t\t\tty=0;\n \t\t\ttx++;\n \t\t}\n \t\tif(tx==r+1) break;\n \t\tvector<int>dp2(1<<(c),-inf);\n \t\tfor(int i=0;i<(1<<(c));i++)if(dp[i]>=0){\n \t\t\t\n \t\t\t\n \t\t\tdp2[i/2]=max(dp2[i/2],dp[i]);\n \t\t\tint mask=(1<<c)-(1<<(c-ty));\n \t\t\tint sita=__builtin_popcountll(mask&i);\n \t\t\tint ue=__builtin_popcountll(i)-sita;\n \t\t\t//cout<<sita<<\" \"<<s[tx].length()<<endl;\n \t\t\tif(sita>=s[tx].length()) continue;\n \t\t\tchar w=s[tx][sita];\n \t\t\tint ko=dp[i];\n \t\t\t{\n \t\t\t\tif((i&(1<<(c-1)))>0 && ty>0 && sita>0 && s[tx][sita]==s[tx][sita-1]){\n \t\t\t\t\t//dp2[i/2+(1<<(c-1))]=max(dp2[i/2+(1<<(c-1))],dp[i]+1);\n \t\t\t\t\tko++;\n \t\t\t\t}\n \t\t\t\telse{\n \t\t\t//\t\tdp2[i/2+(1<<(c-1))]=max(dp2[i/2+(1<<(c-1))],dp[i]);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(i%2){\n \t\t\t\tif(s[tx-1][s[tx-1].length()-ue]==w)ko++;\n \t\t\t}\n \t\t\tdp2[i/2+(1<<(c-1))]=max(dp2[i/2+(1<<(c-1))],ko);\n \t\t}\n \t\n \t\n \t\tif(ty==c-1){\n \t\t\tfor(int i=0;i<(1<<(c));i++)if(__builtin_popcountll(i)!=(int)s[tx].length())dp2[i]=-inf;\n \t\t}\n \t\tswap(dp,dp2);\n \t\tx=tx;\n \t\ty=ty;\n \t\t\n //\t\tcout<<x<<\" \"<<y<<endl;\n \t//\tfor(int i=0;i<(1<<(c));i++)cout<<bitset<2>(i)<<\" \"<<dp[i]<<endl;\n \t}\n \tint ans=-1;\n \tfor(int i=0;i<(1<<(c));i++)ans=max(ans,dp[i]);\n \tcout<<2*ans<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int R = 130;\nconst int C = 16;\nconst int INF = 19191919;\nint dp[R][C][1<<C];\n\nint main(){\n    int r,c;\n    cin >>r >>c;\n    vector<string> s(r);\n    vector<int> L(r);\n    rep(i,r){\n        cin >>s[i];\n        L[i] = s[i].size();\n    }\n\n    int U = (1<<c)-1;\n    vector<int> cm(c), pm(c);\n    rep(i,c){\n        rep(j,i) cm[i] |= (1<<j);\n        pm[i] = cm[i]^U;\n    }\n\n    rep(i,R)rep(j,C)rep(k,1<<C) dp[i][j][k] = -INF;\n    dp[0][0][0] = 0;\n    rep(i,r)rep(j,c){\n        int nr = i;\n        int nc = j+1;\n        if(nc == c){\n            ++nr;\n            nc = 0;\n        }\n\n        rep(mask,1<<c)if(dp[i][j][mask]>=0){\n            // printf(\" %d %d %d\\n\",i,j,mask);\n            int idx = __builtin_popcount(mask&cm[j]);\n            if(idx<=L[i]){\n                // not put\n                int nmask = (mask<<1)&U;\n                if( !(i!=nr && idx<L[i]) ) dp[nr][nc][nmask] = max(dp[nr][nc][nmask], dp[i][j][mask]);\n\n                // put\n                if(idx<L[i]){\n                    nmask |= 1;\n\n                    int add = 0;\n                    // left\n                    if(idx>0) add += (s[i][idx]==s[i][idx-1]);\n                    // up\n                    if( (mask>>(c-1))&1 ){\n                        int ct = __builtin_popcount(mask&pm[j]);\n                        int pre_idx = L[i-1]-ct;\n                        if(pre_idx<0) continue;\n\n                        add += (s[i][idx]==s[i-1][pre_idx]);\n                    }\n\n                    if( !(i!=nr && idx<L[i]-1) ) dp[nr][nc][nmask] = max(dp[nr][nc][nmask], dp[i][j][mask]+add);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,1<<c) ans = max(ans, dp[r][0][i]);\n    cout << ans*2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nsigned main(){\n  int r,c;\n  cin>>r>>c;\n  string s[r];\n  for(int i=0;i<r;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0]=0;\n  int mask=(1<<c)-1;\n  for(int i=0;i<r;i++){\n    bool f=i%2;\n    memset(dp[!f],-1,sizeof(dp[!f]));\n    for(int j=0;j<c;j++){\n      for(int b=0;b<(1<<c);b++){\n\tif(dp[f][j][b]<0) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<b<<\":\"<<dp[f][j][b]<<endl;\n\tchar t,u;\n\tt=u='$';\n\tint y=0;\n\tfor(int k=j-1;k>=0;k--) if((b>>k)&1) y++;\n\tif(j&&(b&1)) u=s[i][y-1];\n\n\tif(i){\n\t  int x=s[i-1].size()-(__builtin_popcountll(b)-y);\n\t  if(x<(int)s[i-1].size()&&((b>>(c-1))&1)) t=s[i-1][x];\n\t}\n\t\n\tif(y<(int)s[i].size()){\n\t  int nb=((b<<1)&mask)+1;\n\t  int nd=dp[f][j][b]+(t==s[i][y])*2+(u==s[i][y])*2;\n\t  if(j+1<c)\n\t    dp[f][j+1][nb]=max(dp[f][j+1][nb],nd);\n\t  else if(y+1==(int)s[i].size())\n\t    dp[!f][0][nb]=max(dp[!f][0][nb],nd);\n\t}\n\t{\n\t  int nb=(b<<1)&mask;\n\t  int nd=dp[f][j][b];\n\t  if(j+1<c)\n\t    dp[f][j+1][nb]=max(dp[f][j+1][nb],nd);\n\t  else if(y==(int)s[i].size())\n\t    dp[!f][0][nb]=max(dp[!f][0][nb],nd);\n\t}\n      }\n    }\n  }\n  int ans=0;\n  for(int b=0;b<(1<<c);b++)\n    ans=max(ans,dp[r%2][0][b]);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 17\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\n/*\n  short mem[H][W][1<<W];\n  bool used[H][W][1<<W];\n  int dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n  if(p < (int)str[y].size()) return -INF;\n  return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n  int score = 0;\n  score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n  score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n  b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n  }\n*/\n\n\nint Max(int &a,int b){return a=max(a,b);}\nint dp[2][W][1<<W];\nint A[W][1<<W],B[W][1<<W];\nvoid mkAB(int x,int bit){\n  int sum = __builtin_popcount(bit);\n  int cnt = 0;\n  for(int i=0;i<x;i++)cnt+=(bit>>i&1);\n  A[x][bit] = cnt;\n  B[x][bit] = sum - cnt;\n}\n\nint DP(){\n  for(int i=0;i<W;i++)\n    for(int j=0;j<(1<<W);j++)mkAB(i,j);\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0] = 0;\n  int res = 0;\n  for(int i=0;i<h;i++){\n    int idx = i%2;\n    for(int j=0;j<w;j++){\n      for(int bit=0;bit<(1<<w);bit++){\n        if(dp[idx][j][bit]==-1)continue;\n        int p = A[j][bit];\n        int u = i? str[i-1].size()-B[j][bit]:0;\n        //use space\n        int abit = bit & (~(1<<j));\n        Max(dp[idx][j+1][abit],dp[idx][j][bit]);\n        \n\n        //use character\n        if(p>=(int)str[i].size())continue;\n        int bbit = bit | (1<<j);\n        int score = 0;\n        score += 2*((bit>>j&1)&&(str[i][p]==str[i-1][u]));\n        score += 2*(j>=1&&(bit>>(j-1)&1)&&str[i][p]==str[i][p-1]);\n        Max(dp[idx][j+1][bbit],dp[idx][j][bit]+score);\n      }\n    }\n    for(int bit=0;bit<(1<<w);bit++){\n      if(__builtin_popcount(bit) != str[i].size())continue;\n      Max(dp[!idx][0][bit],dp[idx][w][bit]);\n      Max(res,dp[idx][w][bit]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  //  cout<<dfs(0,0,0,0,0)<<endl;\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<string> mat;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nint r,c,ans;\n\nbool f;\n\nint check(int y, int x, mat str){\n  int res = 0;\n  if(str[y][x] == ' ') return 0;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= str.size()) continue;\n    if(nx < 0 || nx >= str[y].size()) continue;\n    if(str[ny].size() < nx) continue;\n    if(str[ny][nx] == str[y][x]) res++;\n  }\n  return res;\n}\n\nvoid calc(mat str){\n  int res = 0;\n\n  for(int i=0;i<str.size();i++)\n    for(int j=0;j<str[i].size();j++)\n      res += check(i, j, str);\n\n  ans = max(ans,res);\n  /*\n  if(res == 18){\n    for(int i=0;i<str.size();i++){\n      cout << str[i] << endl;\n    }\n    cout << endl;\n    for(int i=0;i<str.size();i++){\n      for(int j=0;j<str[i].size();j++) cout << check(i,j,str);\n        cout << endl;\n    }\n    cout << endl;\n    }*/\n}\n\nvoid func(int y, int x, mat str){\n  if(x == c){\n    x = 0;\n    y++;\n  }\n  if(y == r){\n    calc(str);\n    return;\n  }\n\n  if(str[y].size() < c && x < str[y].size()){\n    func(y, x+1, str);\n    if(str[y][x] != ' '){\n      if(y > 0){\n        for(int i=x+1;i<str[y-1].size();i++){\n          if(str[y].size() + i - x > c) break;\n          if(str[y][x] == str[y-1][i]){\n            str[y].insert(str[y].begin()+x, i-x, ' ');\n            func(y, x+(i-x)+1, str);\n            break;\n          }\n        }\n        for(int j=x+1;j<str[y-1].size();j++){\n          if(str[y][j] == ' ' || str[y][j-1] != str[y][j]) break;\n          for(int i=j+1;i<str[y-1].size();i++){\n            if(str[y].size() + i - j > c) break;\n            if(str[y][j] == str[y-1][i]){\n              str[y].insert(str[y].begin()+x, i-j, ' ');\n              func(y, x+(i-j)+1, str);\n              break;\n            }\n          }\n        }\n      } else {\n        str[y].insert(str[y].begin()+x, ' ');\n        func(y, x+1, str);\n      }\n    }\n  } else {\n    func(y+1, 0, str);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    mat v;\n    for(int i=0;i<r;i++){\n      string str;\n      cin >> str;\n      v.push_back(str);\n    }\n    ans = 0;\n    func(0,0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PInt;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint dp[2][1<<16];\nint main() {\n  int R, C;\n  cin >> R >> C;\n  string A[130];\n  rep(i, R) cin >> A[i];\n  int cur = 0, next = 1;\n  memset(dp, -1, sizeof(dp));\n  dp[cur][0] = 0;\n  rep(i, R) rep(j, C) {\n    //    rep(k, 1<<C) dp[next][k] = 0;\n    memset(dp + next, -1, sizeof(dp[0]));\n    rep(k, 1<<C) if (dp[cur][k] != -1) {\n      int score = 0;\n      int ak = k & ~(1<<j);\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n\n      char c = A[i][__builtin_popcount(k&((1<<j)-1))];\n      if (i > 0 && (k>>j&1) && (A[i-1][SZ(A[i-1]) - __builtin_popcount(k>>j)] == c)) score++;\n      if (j > 0 && (k>>(j-1)&1) && (A[i][__builtin_popcount(k&((1<<j)-1))-1] == c)) score++;\n      ak = k | 1<<j;\n      dp[next][ak] = max(dp[next][ak], dp[cur][k] + score);\n    }\n    swap(cur, next);\n    if (j+1 == C) {\n      rep(k, 1<<C) if (__builtin_popcount(k) != SZ(A[i])) dp[cur][k] = 0;\n    }\n  }\n\n  int ans = 0;\n  rep(k, 1<<C)\n    ans = max(ans, dp[cur][k]);\n  cout << ans * 2 << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n \n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n \n  vector< int > latte(1 << C, -1);\n  latte[0] = 0;\n  const int mask = (1 << C) - 1;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      vector< int > malta(1 << C, -1);\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n \n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n \n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) ch(malta[j & ~(1 << x)], latte[j]);\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      latte = move(malta);\n    }\n  }\n  cout << *max_element(begin(latte), end(latte)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nvoid cmax(int &lhs,int rhs){\n    lhs=max(lhs,rhs);\n}\nconst int INF=1e5;\nint main(){\n    int r,c;\n    cin>>r>>c;\n    \n    vector<string> s(r+1);\n    for(int i=0;i<r;i++) cin>>s[i+1];\n    vvi dp(c+1,vi(1<<c,-INF));\n    dp[0][0]=0;\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            for(int bit=0;bit<(1<<c);bit++){\n                int upperc=__builtin_popcount((((1<<(c-j))-1)&bit));\n                int posu=(int)(s[i].size())-upperc;\n                int posn=(int)(__builtin_popcount(bit))-upperc;\n                if(posu<0 || posu>s[i].size() || posn<0 || posn>s[i+1].size()) continue;\n                int nextbit=bit>>1;\n                cmax(dp[j+1][nextbit],dp[j][bit]);\n                if(posn<s[i+1].size()){\n                    nextbit|=(1<<(c-1));\n                    if((bit&1) && s[i][posu]==s[i+1][posn]){\n                        cmax(dp[j+1][nextbit],dp[j][bit]+1);\n                    }\n                    else{\n                        cmax(dp[j+1][nextbit],dp[j][bit]);\n                    }\n                }\n            }\n        }\n        for(int bit=0;bit<(1<<c);bit++){\n            if(__builtin_popcount(bit)!=s[i+1].size()) dp[c][bit]=-INF;\n            else{\n                int idx=0;\n                for(int j=0;j<c;j++){\n                    if(((bit>>j)&1) && ((bit>>(j+1))&1) && s[i+1][idx]==s[i+1][idx+1]){\n                        dp[c][bit]++;\n                    }                    \n                    if((bit>>j)&1) idx++;\n                }\n            }\n            dp[0][bit]=dp[c][bit];\n        }\n        for(int j=1;j<=c;j++){\n            fill(dp[j].begin(),dp[j].end(),-INF);\n        }\n    }\n    cout<<*max_element(dp[0].begin(),dp[0].end())*2<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tif(i && c[j][k][0]<(int)s[i].size() && c[j][k][1] && 0 <= (int)s[i-1].size()-c[j][k][1] && s[i][c[j][k][0]] == s[i-1][(int)s[i-1].size()-c[j][k][1]]) cs+=2;\n\n\tif(j && c[j][k][0] && c[j][k][0] < (int)s[i].size() && k & 1<<(j-1) && s[i][ c[j][k][0] -1 ] == s[i][c[j][k][0] ]) cs+=2;\n\n\tif( j!=w-1 || c[j][k][0] == (int)s[i].size() -1) dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j] = max(dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j],dp[i%2][j][k]+cs);\n\t\n\t\n\tint nk=k;\n\tif(k&1<<j) nk-=1<<j;\n\t\n\tif( j!=w-1 || c[0][k][1] == (int)s[i].size() ) dp[(i+(j==w-1))%2][(j+1)%w][nk]=max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if(s[h-1].size()==c[0][i][1])ans=max(ans,dp[h%2][0][i]);\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n\n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n\n  vector< int > latte(1 << C, -1);\n  latte[0] = 0;\n  const int mask = (1 << C) - 1;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      vector< int > malta(1 << C, -1);\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n\n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n\n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) ch(malta[j & ~(1 << x)], latte[j]);\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      latte.swap(malta);\n    }\n  }\n  cout << *max_element(begin(latte), end(latte)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint R,C,/*dp[130][16][(1<<16)]*/dp[2][(1<<16)],len[130];\nstring s[130];\n\nint main(){\n\n  cin >> R >> C;\n  rep(i,R){\n    cin >> s[i];\n    len[i] = (int)s[i].size();\n  }\n\n  rep(i,(1<<C))dp[0][i] = -1;\n  dp[0][0] = 0;\n\n  int answer = 0;\n  rep(r,R)rep(c,C){\n\n    int phase = ( (c+r*C) & 1 );\n    int next_phase = !phase;\n\n    rep(i,(1<<C))dp[next_phase][i] = -1;\n\n    rep(state,(1<<C)){\n      if( dp[phase][state] == -1 ) continue;\n      int next_state = state & (~(1<<c));\n      int bitmask = (1<<c)-1;\n      int bits_L = __builtin_popcount(bitmask&state);\n      int bits_R = __builtin_popcount(state)-bits_L;\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n\n      if( ( r-1 >= 0 && bits_R > len[r-1] ) || ( r-1>=0 && c+bits_R < len[r-1] ) ) continue;\n      if( bits_L > len[r] || ( C-c+bits_L < len[r] ) ) continue;\n\n      next_state |= (1<<c);\n      int score = 0;\n      char char_M = s[r][bits_L];\n      if( r-1 >= 0 && bits_R <= len[r-1] && c+bits_R >= len[r-1] ){\n\tif( bits_R > 0 && ((state>>c)&1) ){\n\t  char char_R = s[r-1][len[r-1]-bits_R];\n\t  if( char_M == char_R ) score++;\n\t}\n      }\n\n      if( c-1 >= 0 && bits_L < len[r] && C-c+bits_L >= len[r] ){\n\tif( bits_L > 0 && ((state>>(c-1))&1) ){\n\t  char char_L = s[r][bits_L-1];\n\t  if( char_L == char_M ) score++;\n\t}\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]+score);\n      answer = max(answer,dp[next_phase][next_state]);\n\n    }\n  }\n  cout << answer*2 << endl;\n\n  /*\n    rep(r,R)rep(c,C){\n    int phase = ((c+r*C)&1);\n    int next_phase = !phase;\n    rep(i,(1<<C))dp[next_phase][i] = 0;\n    rep(state,(1<<C)){\n      bitset<9> BIT(state);      \n      int bitmask = (1<<c)-1;\n      int bits_L  = __builtin_popcount(state & bitmask);\n      int bits_R  = __builtin_popcount(state) - bits_L;\n      cout << \"(\" << c << \",\" << r  << \") : \" << BIT << endl;\n      cout << \"bits ( \" << bits_L << \",\" << bits_R << \")\" << endl;\n      if( bits_L   > len[r]   ) continue; \n      if( bits_L+C-c < len[r] ) continue;\n      if( c+bits_R < len[r+1] ) continue; \n      cout << \"here\" << endl;\n\n      int next_state = state & (~(1<<c));\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n      next_state |= (1<<c);\n      if( bits_L == len[r] ){\n\tdp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t\t dp[phase][state]);\n\tcontinue;\n      }\n\n      int score = 0;\n      char char_M = s[r][c];\n      if( bits_L > 0 && c-1 > 0 && ((state>>(c-1))&1) ){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n\n      if( bits_R > 0 && r+1 < R && ((state>>c)&1) ){\n\tchar char_B = s[r+1][len[r+1]-bits_R];\n\tif( char_M == char_B ) score++;\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state] + score);\n      cout << \"score = \" << score << endl;\n      BIT = next_state;\n      cout << \"dp[\" << next_phase << \"][\" << BIT << \"] = \" << dp[next_phase][next_state] << endl;\n      answer = max(answer,dp[next_phase][next_state]);\n    }\n  }\n  cout << 2 * answer << endl;\n  */\n\n  /*\n\n  rep(r,R)rep(c,C)rep(state,(1<<C)){\n\n    int bitmask = (1<<c)-1;\n    int bits_L = __builtin_popcount(bitmask&state);\n    int bits_R = __builtin_popcount(state)-bits_L;\n\n    if( bits_L > len[r]   ) continue;\n\n    int next_state = state & ~(1<<c);\n    int next_r = r, next_c = c+1;\n    if( next_c >= C ) next_r++, next_c = 0;\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n    char char_M = s[r][bits_L];\n    int score = 0;\n    if( c-1>=0 && ((state>>(c-1))&1) ){\n      if(bits_L-1>=0){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n    }\n\n    if( (state>>c)&1 && r+1 < R){\n      char char_B = s[r+1][len[r+1]-bits_R];\n      if( char_M == char_B ) score++;\n    }\n\n    next_state |= (1<<c);\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]+score);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n  }\n\n  cout << 2*answer << endl;\n\n  */\n\n  /*\n  REP(r,1,R){\n    rep(c,C){\n      rep(state,(1<<C)){\n\tint bitmask = (1<<(c+1))-1;\n\tint bits_R = __builtin_popcount(bitmask&state);\n\tint bits_L = __builtin_popcount(state)-bits_R;\n\n\tif( bits_R > len[r-1] ) continue;\n\tif( bits_L > len[r] ) continue;\n\n\tint next_state = state & ~(1<<c);\n\tint prer = ((c-1>=0)?r  :r-1);\n\tint prec = ((c-1>=0)?c-1:C-1);\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]);\n\tanswer = max(answer,dp[r][c][next_state]);\n\n\tif( bits_L+1 > len[r] ) continue;\n\n\tnext_state |= (1<<c);\n\tchar char_M = s[r][len[r]-bits_L-1];\n\tint score = 1;\n\tif( (state>>c) & 1 ){\n\t  char char_T = s[r-1][bits_R];\n\t  if( char_M == char_T ) score++;\n\t}\n\n\tif( ( (state>>(c+1)) & 1 ) ) {\n\t  char char_L = s[r][len[r]-bits_L];\n\t  if( char_M == char_L )score++;\n\t}\n\tif( score == 1 ) continue;\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]+score);\n\tanswer = max(answer,dp[r][c][next_state]);\n      }\n    }\n  }\n\n  cout << answer << endl;\n  */\n\n  return 0;\n}\n\n/*\n21:27 -  22:26 give up \nthe following code is too slow!\n\n\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint dx[] = {0,-1};\nint dy[] = {-1,0};\nstring G[130];\nint dp[130][(1<<17)];\nstring line[2];\n\nint main(){\n  int H,W;\n  cin >> H >> W;\n  vector<int> loop[H];\n  rep(i,H){\n    cin >> G[i];\n    int remain = W - (int)G[i].size();\n    //cout << i << \" => \" << remain << endl;\n    rep(j,(1<<W)){\n      if(__builtin_popcount(j) == remain)loop[i].push_back(j);\n    } \n  }\n\n  vector<string> pre[H];\n  rep(i,H){\n    sort(loop[i].begin(),loop[i].end());\n    loop[i].erase(unique(loop[i].begin(),loop[i].end()),loop[i].end());\n    cout << loop[i].size() << endl;\n    assert((int)loop[i].size() < (1<<W));\n    rep(j,loop[i].size()){\n      int state = loop[i][j],idx = 0;\n      string line = \"\";\n      rep(j,W){\n\tif((state>>j) & 1)line += \" \";\n\telse              line += G[i][idx++];\n      }\n      pre[i].push_back(line);\n    }\n  }\n  //cout << \"-----------\" << endl;\n  int ans = 0;\n  rep(y,H){\n    rep(i,loop[y].size()){\n      int state = loop[y][i];\n      line[1] = pre[y][i];\n      rep(j,((y-1>=0)?loop[y-1].size():1) ){\n\tint pstate = ((y-1>=0)?loop[y-1][j]:0);\n\tline[0] = ((y-1>=0)?pre[y-1][j]:string(W,' '));\n\tint point = 0;\n\trep(k,W){\n\t  int X = k, Y = 1;\n\t  rep(l,2){\n\t    int nx = X + dx[l], ny = Y + dy[l];\n\t    if(!( 0 <= nx && nx < W && 0 <= ny && ny < H ))continue;\n\t    if(line[Y][X] != ' ' && line[Y][X] == line[ny][nx]) point++;\n\t  }\n\t}\n\tdp[y][state] = max(dp[y][state],((y-1>=0)?dp[y-1][pstate]:0)+point);\n\tans = max(ans,dp[y][state]);\n      } \n    }\n  }\n  cout << ans * 2 << endl;\n  return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\n// 長さnの11..11\nuint one(int n)\n{\n\treturn (1<<n)-1;\n}\n\ntemplate<typename T>\nvoid chmax(T& a,const T& b)\n{\n\ta=max(a,b);\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs ss(h);\n\t\trep(i,h) cin>>ss[i];\n\t\t\n\t\tss.insert(begin(ss),string(w,'#'));\n\t\th++;\n\t\t\n\t\tvector<vvi> dp(h,vvi(w,vi(1<<w,-INF)));\n\t\tdp[0][w-1][(1<<w)-1]=0;\n\t\t\n\t\trepi(i,1,h) rep(j,w){\n\t\t\tint pi=i,pj=j-1;\n\t\t\tif(pj<0) pi--,pj+=w;\n\t\t\trep(k,1<<w){\n\t\t\t\tint al=popcount(k&one(j+1)),ar=ss[i].size()-al;\n\t\t\t\tint br=popcount(k>>j+1&one(w-j-1)),bl=ss[i-1].size()-br;\n\t\t\t\tif(al<0 || j+1<al || ar<0 || w-j-1<ar\n\t\t\t\t|| bl<0 || j+1<bl || br<0 || w-j-1<br) continue;\n\t\t\t\tif(k>>j&1){\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]+2*(ss[i][al-1]==ss[i-1][bl-1]));\n\t\t\t\t\tif(al>=2 && (k>>j-1&1) && ss[i][al-2]==ss[i][al-1])\n\t\t\t\t\t\tdp[i][j][k]+=2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<*max_element(all(dp[h-1][w-1]))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 16\n#define INF 1e9\nusing namespace std;\nint h,w;\nstring str[H];\n\nshort mem[H][W][1<<W];\nbool used[H][W][1<<W];\n\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -10000;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 17\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\n/*\n  short mem[H][W][1<<W];\n  bool used[H][W][1<<W];\n  int dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n  if(p < (int)str[y].size()) return -INF;\n  return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n  int score = 0;\n  score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n  score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n  b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n  }\n*/\n\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint dp[2][W][1<<W];\nint A[W][1<<W],B[W][1<<W];\nvoid mkAB(int x,int bit){\n  int sum = __builtin_popcount(bit);\n  int cnt = 0;\n  for(int i=0;i<x;i++)cnt+=(bit>>i&1);\n  A[x][bit] = cnt;\n  B[x][bit] = sum - cnt;\n}\n\nint DP(){\n  for(int i=0;i<W;i++)\n    for(int j=0;j<(1<<W);j++)mkAB(i,j);\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0] = 0;\n  int res = 0;\n  for(int i=0;i<h;i++){\n    int idx = i%2;\n    for(int j=0;j<w;j++){\n      for(int bit=0;bit<(1<<w);bit++){\n        if(dp[idx][j][bit]==-1)continue;\n        int p = A[j][bit];\n        int u = i? str[i-1].size()-B[j][bit]:0;\n        \n        //use space\n        int abit = bit & (~(1<<j));\n        Max(dp[idx][j+1][abit],dp[idx][j][bit]);\n        \n\n        //use character\n        if(p>=(int)str[i].size())continue;\n        int bbit = bit | (1<<j);\n        int score = 0;\n        score += 2*((bit>>j&1)&&(str[i][p]==str[i-1][u]));\n        score += 2*(j>=1&&(bit>>(j-1)&1)&&str[i][p]==str[i][p-1]);\n        Max(dp[idx][j+1][bbit],dp[idx][j][bit]+score);\n      }\n    }\n    for(int bit=0;bit<(1<<w);bit++){\n      if(__builtin_popcount(bit) != str[i].size())continue;\n      Max(dp[!idx][0][bit],dp[idx][w][bit]);\n      Max(res,dp[idx][w][bit]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  //  cout<<dfs(0,0,0,0,0)<<endl;\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dpc[1 << 16], dpn[1 << 16];\n\nsigned main() {\n    int R, C; cin >> R >> C;\n    fill(dpc, dpc + (1<<C), -1);\n    fill(dpn, dpn + (1<<C), -1);\n    dpc[0] = 0;\n    int pn = 0;\n    string ps = \"\";\n    for(int i=0; i<R; i++) {\n        string s; cin >> s;\n        int N = s.length();\n        for(int j=0; j<C; j++) {\n            for(int bit=0; bit<(1<<C); bit++) {\n                if(dpc[bit] < 0) continue;\n                // fprintf(stderr, \"i = %lld, j = %lld, bit = %lld, dp = %lld\\n\", i, j, bit, dpc[bit]);\n                {\n                    int mask1 = (1 << j) - 1;\n                    int mask2 = (1 << C) - 1 - mask1;\n                    // 置く (j 列目に k 文字目を置く)\n                    int k = __builtin_popcount(bit & mask1);\n                    int l = pn - __builtin_popcount(bit & mask2);\n                    \n                    if(k < N) {\n                        int c1 = (k > 0 and j > 0 and (bit >> (j-1) & 1) and s[k-1] == s[k]);\n                        int c2 = (i > 0 and bit >> j & 1) and (ps[l] == s[k]);\n\n                        int nbit = bit | (1 << j);\n                        chmax(dpn[nbit], dpc[bit] + (c1 + c2) * 2);\n                    }\n                }\n\n                {\n                    // 置かない\n                    int mask1 = (1 << j) - 1;\n                    int k =__builtin_popcount(bit & mask1);\n                    // 残りマス数\n                    int remA = C - j - 1, remB = N - k;\n                    if(remA >= remB) {\n                        int nbit = bit;\n                        if(nbit >> j & 1) nbit -= (1 << j);\n                        chmax(dpn[nbit], dpc[bit]);\n                    }\n                }\n                dpc[bit] = -1;\n            }\n            swap(dpn, dpc);\n        }\n        pn = N; ps = s;\n    }\n    int ans = *max_element(dpc, dpc + (1<<C));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 16+1;\nconst int BIT = 1<<MAX_R;\nint r, c;\nstring s[MAX_R];\n\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        fill(dp[q], dp[q+1], -1);\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          char nc;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          for(int t = Lu, a = 0; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][a++];\n            else v += '.';\n          }\n          { \n            int tmp = 0;\n            for(int t = 0; t < v.size(); ++t) tmp += (v[t] != '.');\n            if(tmp == s[i].size()) nc = '$';\n            else nc = s[i][tmp]; \n          }\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(nc != '$') {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (nc == u[0]) * 2;\n            if(v.size()) add += (nc == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W){\n        vector<string> str(H);\n        REP(i, H) cin >> str[i];\n\n        const int MAXS = 1 << W;\n        vector<int> dp(MAXS, -INF);\n        dp[0] = 0;\n        for(int y = 0; y < H; y++){\n            for(int x = 0; x < W; x++){\n                vector<int> next(MAXS, -INF);\n                for(int s = 0; s < MAXS; s++) if(dp[s] >= 0){\n                    int cu = __builtin_popcount(s >> x); // count of upper\n                    int cl = __builtin_popcount(s & ((1 << x) - 1)); // count of lower\n                    assert(cu + cl == __builtin_popcount(s));\n\n                    if(cl + (W - 1 - x) >= str[y].size())\n                        next[s & ~(1 << x)] = max(next[s & ~(1 << x)], dp[s]); // path through\n\n                    if(cl == str[y].size()) continue;\n\n                    int add = 0;\n                    if(cl > 0 && str[y][cl] == str[y][cl - 1] && (s >> (x - 1) & 1)){\n                        add += 2;\n                    }\n                    if(y > 0 && (s >> x & 1) && str[y - 1][str[y - 1].size() - cu] == str[y][cl]){\n                        add += 2;\n                    }\n                    next[s | (1 << x)] = max(next[s | (1 << x)], dp[s] + add);\n                }\n                dp.swap(next);\n            }\n        }\n        int ans = 0;\n        for(int s = 0; s < MAXS; s++) ans = max(ans, dp[s]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 16\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\nunordered_map<short,short> mem[H][W];\nbool used[H][W][1<<W];\n\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n  \n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint R, C;\nstring s[202];\n\nint dp[2][1<<16];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> R >> C;\n  rep(i, R) cin >> s[i];\n\n  memset(dp, -1, sizeof(dp));\n\n  int *cur = dp[0], *next = dp[1];\n  cur[0] = 0;\n  rep(i, R) rep(j, C) {\n    rep(bit, 1<<16) next[bit] = -1;\n    rep(bit, 1<<C) {\n      if(cur[bit] == -1) continue;\n      //rep(bit, C) cout<<(int)(bit&(1<<C));\n      //cout<<endl;\n\n      int idx = __builtin_popcountll(bit&((1<<j)-1));\n      //cout<<idx<<\" \"<<j<<\" \"<<C<<endl;\n\n      if(idx+C-j > (int)s[i].size()) { // empty\n\tchmax(next[bit&~(1<<j)], cur[bit]);\n      }\n\n      if(idx < (int)s[i].size()) { // char\n\t//cout<<s[i]<<endl;\n\tint same = 0;\n\tif(j > 0 && ((bit>>(j-1))&1)) { // left\n\t  if(idx > 0 && s[i][idx] == s[i][idx-1]) same += 2;\n\t}\n\n\tif(i > 0 && ((bit>>j)&1)) { // above\n\t  int sz = s[i-1].size();\n\t  int above = __builtin_popcountll(bit>>j);\n\t  //cout<<sz<<\" \"<<above<<endl;\n\t  //cout<<s[i-1]<<endl;\n\t  if(sz >= above && s[i][idx] == s[i-1][sz-above]) same += 2;\n\t}\n\n\t//cout<<same<<endl;\n\tchmax(next[bit|1<<j], cur[bit]+same);\n      }\n    }\n    swap(cur, next);\n  }\n\n  int ans = 0;\n  rep(bit, 1<<C) chmax(ans, cur[bit]);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint R,C;\nstring S[129];\nint dp[2][(1<<16)];\n\nint getcost(int x,int y,int bt,int txc,int tyc){\n  int ret = 0;\n  if( bt&1 ) {\n    if( (int)S[y].size() <= txc ) return -100000000;\n    if(y>0){\n      if( (bt & (1<<C)) ){\n        int ind = (int)S[y-1].size() - tyc;\n        if( S[y][txc] == S[y-1][ind] ) {\n          ret += 2;\n        }\n      }\n    }\n    if(txc>0 && (bt&2) ){\n      if( S[y][txc] == S[y][txc-1] ) {\n        ret += 2;\n      }\n    }\n  }\n\n  //  cout << x << \" \"<< y << \" \"<< txc<< \" \" <<tyc <<\" \"<< endl;\n  //cout << bitset<17>(bt) << endl;\n  //cout << ret << endl;\n  return ret; \n}\n\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++) cin >> S[i];\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0] = 0;\n  for(int y=0;y<R;y++){\n    int size = (int)S[y].size();\n    for(int x=0;x<C;x++){\n      int now = (C*y+x)&1;\n      int nex = 1-now;\n      memset(dp[nex],-1,sizeof(dp[nex]));\n      for(int i=0;i<(1<<C);i++){\n        int nc = dp[now][i];\n        if(nc < 0 ) continue;\n        int prx = (i & ((1<<x)-1) );\n        int pry = (i & (~((1<<x)-1)) );\n        int txc = __builtin_popcount(prx);\n        int tyc = __builtin_popcount(pry);\n        if( txc > size ) continue;\n        if( y>0 &&  x==0 && (int)S[y-1].size() != tyc ) continue;\n        if( y>0 && (int)S[y-1].size() - tyc < 0 ) continue;\n        int nbt = (i<<1);\n        nbt &= ((1<<C)-1);\n        if( x - txc < C-size )\n          dp[nex][nbt] = max( dp[nex][nbt], nc );\n        int nxc = getcost(x,y,(i<<1)|1,txc,tyc);\n        dp[nex][nbt|1] = max( dp[nex][nbt|1], nc + nxc );\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=0;i<(1<<C);i++){\n    int now = (C*R)&1;\n    int tyc = __builtin_popcount(i);\n    if((int)S[R-1].size() != tyc ) continue;\n    res = max( res, dp[now][i] );\n }\n  cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x){ return __popcnt(x); }\ninline unsigned long long __builtin_popcountll(unsigned long long x) { return __popcnt64(x); }\n\n#pragma pop_macro(\"long\")\n#endif\ninline int bsf(int v) { return __builtin_ctz(v); }\ninline long bsf(long v) { return __builtin_ctzll(v); }\ninline int bsr(int v) { return 31 - __builtin_clz(v); }\ninline long bsr(long v) { return 63 - __builtin_clzll(v); }\ninline int msb(int v) { return 1 << bsr(v); }\ninline long msb(long v) { return 1ll << bsr(v); }\ninline int lsb(int v) { return v & -v; }\ninline long lsb(long v) { return v & -v; }\ninline int pop_count(int v) { return __builtin_popcount(v); }\ninline long pop_count(long v) { return __builtin_popcountll(v); }\ninline int pop_lsb(int v) { return v & v - 1; }\ninline long pop_lsb(long v) { return v & v - 1; }\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (bsf(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline int setbit(int n) { return (1 << n) - 1; }\ninline bool contains(int x, int min, int max) { return x >= min && x < max; } // max含まない\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, R, C);\n\t\tif (!R) { break; }\n\n\t\tauto strs = read<string>(R);\n\n\t\tint count = 1 << C;\n\n\t\tvector<int> dp(count);\n\t\t\n\t\tstrs.insert(strs.begin(), string(C, '_'));\n\n\t\tFOR(i, 1, strs.size()) REP(j, C)\n\t\t{\n\t\t\tvector<int> nxt(count);\n\n\t\t\t// i行j文字目を処理する。\n\t\t\tstring &strA = strs[i];\n\t\t\tstring &strB = strs[i - 1];\n\n\t\t\t// 遷移を k で列挙\n\t\t\tREP(k, count)\n\t\t\t{\n\t\t\t\tint maskA = setbit(C) & setbit(j);\n\t\t\t\tint maskB = setbit(C) ^ maskA;\n\n\t\t\t\tint idxA = pop_count(k & maskA);\n\t\t\t\tint idxB = strB.length() - pop_count(k & maskB);\n\n\t\t\t\tint score = 0;\n\n\t\t\t\t// してもよい遷移？\n\t\t\t\tif (!contains(idxA, 0, strA.length() + 1)) continue;\n\t\t\t\tif (!contains(strA.length() - idxA, 0, C - j + 1)) continue;\n\n\t\t\t\tif (!contains(idxB, 0, strB.length() + 1)) continue;\n\n\t\t\t\t// idxAをjに入れる遷移\n\t\t\t\t{\n\t\t\t\t\t// 前の文字と一緒か？\n\t\t\t\t\tif (contains(idxA, 1, strA.length()))\n\t\t\t\t\t{\n\t\t\t\t\t\t// 直前がスペースではない\n\t\t\t\t\t\tif (k & (1 << (j - 1)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 前の文字が等しい。\n\t\t\t\t\t\t\tif (strA[idxA] == strA[idxA - 1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscore += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 上の文字といっしょか？\n\t\t\t\t\tif (contains(idxA, 0, strA.length()))\n\t\t\t\t\t{\n\t\t\t\t\t\t// 上の文字がスペースではない\n\t\t\t\t\t\tif (k & (1 << j))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 上の文字が等しい\n\t\t\t\t\t\t\tif (strA[idxA] == strB[idxB])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscore += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// jにidxAを採用した。\n\t\t\t\t\tint next = k | j << 1;\n\t\t\t\t\tnxt[next] = max(nxt[next], dp[k] + score);\n\t\t\t\t}\n\n\t\t\t\t// idxAをjに入れない。\n\t\t\t\t{\n\t\t\t\t\tint next = k & ~(j << 1);\n\t\t\t\t\tnxt[next] = max(nxt[next], dp[k] + 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp.swap(nxt);\n\t\t}\n\t\tWRITE(*max_element(allof(dp)));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nsigned main(){\n  int r,c;\n  cin>>r>>c;\n  string s[r];\n  for(int i=0;i<r;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0]=0;\n  int mask=(1<<c)-1;\n  for(int i=0;i<r;i++){\n    bool f=i%2;\n    memset(dp[!f],-1,sizeof(dp[!f]));\n    for(int j=0;j<c;j++){\n      for(int b=0;b<(1<<c);b++){\n\tif(dp[f][j][b]<0) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<b<<\":\"<<dp[i][j][b]<<endl;\n\tstring t(c,'%'),u;\n\tif(i){\n\t  t=string(j,'%');\n\t  string p;\n\t  for(int k=j,y=(int)s[i-1].size();k<c;k++)\n\t    p.push_back(((b>>k)&1?s[i-1][--y]:'$'));\n\t  reverse(p.begin(),p.end());\n\t  t+=p;\n\t}\n\tint y=0;\n\tfor(int k=j-1;k>=0;k--)\n\t  u.push_back(((b>>k)&1?s[i][y++]:'$'));\n\t\n\tif(y<(int)s[i].size()){\n\t  int nb=((b<<1)&mask)+1;\n\t  //cout<<t<<endl<<u<<s[i][y]<<endl;\n\t  int nd=dp[i][j][b]+(t[j]==s[i][y])*2+(u.back()==s[i][y])*2;\n\t  if(j+1<c)\n\t    dp[f][j+1][nb]=max(dp[f][j+1][nb],nd);\n\t  else if(y+1==(int)s[i].size())\n\t    dp[!f][0][nb]=max(dp[!f][0][nb],nd);\n\t}\n\t{\n\t  //cout<<t<<endl<<u<<'&'<<endl;\n\t  int nb=(b<<1)&mask;\n\t  int nd=dp[i][j][b];\n\t  if(j+1<c)\n\t    dp[f][j+1][nb]=max(dp[f][j+1][nb],nd);\n\t  else if(y==(int)s[i].size())\n\t    dp[!f][0][nb]=max(dp[!f][0][nb],nd);\n\t}\n      }\n    }\n  }\n  int ans=0;\n  for(int b=0;b<(1<<c);b++)\n    ans=max(ans,dp[r%2][0][b]);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 16\n#define INF 1e9\nusing namespace std;\nint h,w;\nstring str[H];\n\nunordered_map <int,int> mem[H][W];\n\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -10000;\n    return dfs(y+1,0,bit,0,0);\n  }\n  \n  if(mem[y][x].count(bit)) return mem[y][x][bit];\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint popcount(int n){\n    n = (n & 0x55555555) + (n >> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >> 2 & 0x33333333);\n    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);\n    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);\n    return (n & 0x0000ffff) + (n >>16 & 0x0000ffff);\n}\n\nint main(){\n    int h,w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for(int i=0; i<h; i++){\n        cin >> s[i];\n    }\n\n    vector<int> dp(1<<w, 0);\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            vector<int> ndp(1<<w, 0);\n            for(int bits=0; bits<(1<<w); bits++){\n                int pop_total = popcount(bits);\n                int pop_prevline = popcount(bits>>j);\n                int pop_currline = pop_total -pop_prevline;\n                if(i==0 and pop_prevline>0) continue;\n                if(i>0 and pop_prevline>(int)s[i-1].length()) continue;\n                if(i>0 and j+pop_prevline<(int)s[i-1].length()) continue;\n                if(pop_currline > (int)s[i].length()) continue;\n                if(i==3 and j==0 and bits==53191){\n                }\n                // 空白\n                if(w-j-1+pop_currline >= (int)s[i].length()){\n                    int &next = ndp[bits&~(1<<j)];\n                    next = max(next, dp[bits]);\n                }\n                // 置く\n                if(pop_currline+1 <= (int)s[i].length()){\n                    int score = 0;\n                    char self = s[i][pop_currline];\n                    if(i>0 and (bits>>j&1) and self==s[i-1][(int)s[i-1].length()-pop_prevline]){\n                        score += 2;\n                    }\n                    if(j>0 and (bits>>(j-1)&1) and self==s[i][pop_currline-1]){\n                        score += 2;\n                    }\n                    int &next = ndp[bits|(1<<j)];\n                    next = max(next, dp[bits]+score);\n                }\n            }\n            swap(dp, ndp);\n        }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <valarray>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n \nint dp[2][1<<16];\nint r,c;\nstring input[128];\n \nint main() {\n  cin>>r>>c;\n  for(int i=0; i<r; ++i) cin>>input[i];\n \n  memset(dp,-1,sizeof(dp));\n \n  int *cur = dp[0];\n  int *nxt = dp[1];\n \n  cur[0] = 0;\n  REP(i,r) {\n    REP(j,c) {\n      REP(S,1<<c) nxt[S] = -1;\n      REP(S,1<<c) {\n        if (cur[S] == -1) continue;\n \n        int S1 = S & ((1<<j)-1);\n        int S2 = S ^ S1;\n        int n1 = __builtin_popcount(S1);\n        int n2 = __builtin_popcount(S2);\n        char left = '_';\n        if (j&&n1) {\n          if (S>>(j-1)&1) {\n            left = input[i][n1-1];\n          }\n        }\n        char up = '_';\n        if (i>0 && n2) {\n          if ((S>>j)&1) {\n            up = input[i-1][input[i-1].size()-n2];\n          }\n        }\n        // cout << bitset<3>(S) << \" \" << bitset<3>(S1) << \" \"<< bitset<3>(S2) << endl;\n        // printf(\"(%d,%d) %d %c %c\\n\", i,j, cur[S],left,up);\n        // bit たてる\n        if (n1 < input[i].size()) {\n          char now = input[i][n1];\n          int score = 0;\n          if (now == left) score+=2;\n          if (now == up) score+=2;\n          int T = S|1<<j;\n          // if (score) {\n          //   printf(\"(%d,%d) %d %c %c %c\\n\", i,j, cur[S],left,up, now);\n          // }\n          nxt[T] = max(nxt[T], cur[S]+score);\n        }\n        int len = input[i].size();\n        if (len-n1 <= c-j-1) {\n          // たてない\n          int T = S & (~(1<<j));\n          nxt[T] = max(nxt[T], cur[S]);\n        }\n      }\n      swap(cur, nxt);\n    }\n  }\n  int ans = 0;\n  REP(S,1<<c) {\n    // if (cur[S] == 18) {\n    //   cout <<bitset<16>(S) << endl;\n    // }\n    ans = max(ans, cur[S]);\n  }\n \n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x){ return __popcnt(x); }\ninline unsigned long long __builtin_popcountll(unsigned long long x) { return __popcnt64(x); }\n\n#pragma pop_macro(\"long\")\n#endif\ninline int bsf(int v) { return __builtin_ctz(v); }\ninline long bsf(long v) { return __builtin_ctzll(v); }\ninline int bsr(int v) { return 31 - __builtin_clz(v); }\ninline long bsr(long v) { return 63 - __builtin_clzll(v); }\ninline int msb(int v) { return 1 << bsr(v); }\ninline long msb(long v) { return 1ll << bsr(v); }\ninline int lsb(int v) { return v & -v; }\ninline long lsb(long v) { return v & -v; }\ninline int pop_count(int v) { return __builtin_popcount(v); }\ninline long pop_count(long v) { return __builtin_popcountll(v); }\ninline int pop_lsb(int v) { return v & v - 1; }\ninline long pop_lsb(long v) { return v & v - 1; }\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (bsf(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline int setbit(int n) { return (1 << n) - 1; }\ninline bool contains(int x, int min, int max) { return x >= min && x < max; } // max含まない\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, R, C);\n\t\tif (!R) { break; }\n\n\t\tauto strs = read<string>(R);\n\n\t\tint count = 1 << C;\n\n\t\tvector<int> dp(count);\n\t\t\n\t\tstrs.insert(strs.begin(), string(C, '_'));\n\n\t\tFOR(i, 1, strs.size()) REP(j, C)\n\t\t{\n\t\t\tvector<int> nxt(count);\n\n\t\t\t// i行j文字目を処理する。\n\t\t\tstring &strA = strs[i];\n\t\t\tstring &strB = strs[i - 1];\n\n\t\t\t// 遷移を k で列挙\n\t\t\tREP(k, count)\n\t\t\t{\n\t\t\t\tint maskA = setbit(C) & setbit(j);\n\t\t\t\tint maskB = setbit(C) ^ maskA;\n\n\t\t\t\tint idxA = pop_count(k & maskA);\n\t\t\t\tint idxB = strB.length() - pop_count(k & maskB);\n\n\t\t\t\tint score = 0;\n\n\t\t\t\t// してもよい遷移？\n\t\t\t\tif (!contains(idxA, 0, strA.length() + 1)) continue;\n\t\t\t\tif (!contains(strA.length() - idxA, 0, C - j + 1)) continue;\n\n\t\t\t\tif (!contains(idxB, 0, strB.length() + 1)) continue;\n\t\t\t\tif (!contains(strB.length() - idxB, 0, C - j + 1)) continue;\n\n\t\t\t\t// idxAをjに入れる遷移\n\t\t\t\t{\n\t\t\t\t\t// 前の文字と一緒か？\n\t\t\t\t\tif (contains(idxA, 1, strA.length()))\n\t\t\t\t\t{\n\t\t\t\t\t\t// 直前がスペースではない\n\t\t\t\t\t\tif (k & (1 << (j - 1)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 前の文字が等しい。\n\t\t\t\t\t\t\tif (strA[idxA] == strA[idxA - 1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscore += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 上の文字といっしょか？\n\t\t\t\t\tif (contains(idxA, 0, strA.length()))\n\t\t\t\t\t{\n\t\t\t\t\t\t// 上の文字がスペースではない\n\t\t\t\t\t\tif (k & (1 << j))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 上の文字が等しい\n\t\t\t\t\t\t\tif (strA[idxA] == strB[idxB])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscore += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// jにidxAを採用した。\n\t\t\t\t\tint next = k | j << 1;\n\t\t\t\t\tnxt[next] = max(nxt[next], dp[k] + score);\n\t\t\t\t}\n\n\t\t\t\t// idxAをjに入れない。\n\t\t\t\t{\n\t\t\t\t\tint next = k & ~(j << 1);\n\t\t\t\t\tnxt[next] = max(nxt[next], dp[k] + 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp.swap(nxt);\n\t\t}\n\t\tWRITE(*max_element(allof(dp)));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar word[128][17],pre[17],now[17];\nint POW[17];\nint length[128],dp[2][1<<17];\nint num_bit[1<<17];\n\nint main(){\n\n\tfor(int i = 0; i < 17; i++)POW[i] = pow(2,i);\n\n\tint H,W;\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",word[row]);\n\t\tfor(length[row] = 0; word[row][length[row]] != '\\0'; length[row]++);\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\n\tfor(int state = 0; state < POW[W]; state++){\n\t\tnum_bit[state] = __builtin_popcount(state);\n\t\tdp[CURRENT][state] = -1;\n\t\tdp[NEXT][state] = -1;\n\t}\n\n\tdp[CURRENT][0] = 0;\n\tint loc,next;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tfor(int state = 0; state < POW[W]; state++)dp[NEXT][state] = -1;\n\n\t\t\tfor(int state = 0; state < POW[W]; state++){\n\n\t\t\t\tif(dp[CURRENT][state] == -1)continue;\n\n\t\t\t\tloc = num_bit[state & (1 << col)-1];\n\n\t\t\t\tif(loc < length[row]){\n\t\t\t\t\tnext = dp[CURRENT][state];\n\n\t\t\t\t\tif(col > 0 && (state & (1 << (col-1))) != 0 && word[row][loc-1] == word[row][loc])next++;\n\n\t\t\t\t\tif(row > 0 && (state & 1 << col) != 0 && word[row][loc] == word[row-1][length[row-1]-num_bit[state >> col]])next++;\n\t\t\t\t\tdp[NEXT][state|1 << col] = max(dp[NEXT][state|1 << col],next);\n\t\t\t\t}\n\n\t\t\t\tif(loc+W-col > length[row]){\n\t\t\t\t\tdp[NEXT][state & ~(1 << col)] = max(dp[NEXT][state & ~(1 << col)], dp[CURRENT][state]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(CURRENT,NEXT);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int state = 0; state < POW[W]; state++){\n\t\tans = max(ans,dp[CURRENT][state]);\n\t}\n\n\tprintf(\"%d\\n\",2*ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16];\nconst int INF=1<<30;\nint bitPos[1<<16][17];\nint bitCnt[1<<16][17];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      int res=-INF;\n      if(i==R*C)res=0;\n      else{\n\tconst int cnt=bitCnt[mask][17]-(bitCnt[mask][17]-bitCnt[mask][cx]);\n\tconst int ct=bitCnt[mask][cx];\n\tif(ct<(int)ss[cy].size()){\n\t  int nmask=mask|(1<<cx);\n\t  int add=0;\n\t  if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t     &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t     &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t     &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t    add+=2;\n\t  }\n\t  if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t     &&cnt<(int)ss[cy-1].size()\n\t     &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t     &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t    add+=2;\n\t  }\n\t  if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t    if(cx==C-1)res=max(res,dp[nxt][nmask]+add);\n\t    else res=max(res,dp[nxt][nmask]+add);\n\t  }\n\t}\n\t{\n\t  int nmask=mask&~(1<<cx);\n\t  if(cx!=C-1||ct==(int)ss[cy].size()){\n\t    if(cx==C-1)res=max(res,dp[nxt][nmask]);\n\t    else res=max(res,dp[nxt][nmask]);\n\t  }\n\t}\n\tdp[cur][mask]=res;\n      }\n    }\n  }\n  cout<<dp[0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\nint main(){\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\tint cs=0;\n\t\n\tif(i && c[j][k][0]<(int)s[i].size() && c[j][k][1] && 0 <= (int)s[i-1].size()-c[j][k][1] && s[i][c[j][k][0]] == s[i-1][(int)s[i-1].size()-c[j][k][1]]) cs+=2;\n\n\tif(c[j][k][0] && c[j][k][0] < (int)s[i].size() && k&1<<(j-1) && s[i][ c[j][k][0] -1 ]== s[i][c[j][k][0]]) cs+=2;\n\n\tif( j!=w-1 || c[w-1][k][0] == (int)s[i].size() - 1) dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j] = max(dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j],dp[i%2][j][k]+cs);\n\t\n\t\n\tint nk=k;\n\tif(k&1<<j) nk-=1<<j;\n\t\n\tif( j!=w-1 || c[w-1][k][0] == (int)s[i].size() ) dp[(i+(j==w-1))%2][(j+1)%w][nk]=max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)ans=max(ans,dp[h%2][0][i]);\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint R,C;\nstring S[129];\nint dp[2][(1<<16)];\nP memo[129][17];\n\nint getcost(int x,int y,int bt,int txc,int tyc){\n  int ret = 0;\n  if( bt&1 ) {\n    if( (int)S[y].size() <= txc ) return -100000000;\n    if(y>0){\n      if( (bt & (1<<C)) ){\n        int ind = (int)S[y-1].size() - tyc;\n        if( S[y][txc] == S[y-1][ind] ) {\n          ret += 2;\n        }\n      }\n    }\n    if(txc>0 && (bt&2) ){\n      if( S[y][txc] == S[y][txc-1] ) {\n        ret += 2;\n      }\n    }\n  }\n\n  //  cout << x << \" \"<< y << \" \"<< txc<< \" \" <<tyc <<\" \"<< endl;\n  //cout << bitset<17>(bt) << endl;\n  //cout << ret << endl;\n  return ret; \n}\n\nint main(){\n  cin >> R >> C;\n  for(int i=0;i<R;i++) cin >> S[i];\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0] = 0;\n  for(int y=0;y<R;y++){\n    int size = (int)S[y].size();\n    for(int x=0;x<C;x++){\n      int now = (C*y+x)&1;\n      int nex = 1-now;\n      for(int i=0;i<(1<<C);i++){\n        int nc = dp[now][i];\n        if(nc < 0 ) continue;\n        int prx = (i & (1<<x)-1 );\n        int pry = (i & ~((1<<x)-1) );\n        int txc = __builtin_popcount(prx);\n        int tyc = __builtin_popcount(pry);\n        if( txc > size ) continue;\n        if( x - txc > C-size ) continue;\n        if( y>0 &&  x==0 && (int)S[y-1].size() != tyc ) continue;\n        int nbt = (i<<1);\n        nbt &= ((1<<C)-1);\n        dp[nex][nbt] = max( dp[nex][nbt], nc );\n        int nxc = getcost(x,y,(i<<1)|1,txc,tyc);\n        dp[nex][nbt|1] = max( dp[nex][nbt|1], nc + nxc );\n      }\n    }\n  }\n\n  int res = 0;\n  for(int i=0;i<(1<<C);i++){\n    int now = (C*R)&1;\n    int tyc = __builtin_popcount(i);\n    if((int)S[R-1].size() != tyc ) continue;\n    if( dp[now][i] == 20 )   cout << bitset<16>(i) << \" \" << dp[now][i] << endl;\n    res = max( res, dp[now][i] );\n }\n  cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n\n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n\n  int dp[2][1 << 16];\n  memset(dp, -1, sizeof(dp));\n  int *latte = dp[0], *malta = dp[1];\n  latte[0] = 0;\n  const int mask = (1 << C) - 1;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      memset(malta, -1, sizeof(malta));\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n\n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n\n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) {\n          ch(malta[j & ~(1 << x)], latte[j]);\n        }\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      swap(latte, malta);\n    }\n  }\n  cout << *max_element(latte, latte + (1 << 16)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 128;\nconst int MAX_C = 16+1;\nconst int BIT = 1<<MAX_C;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        for(int k = 0; k < (1<<c); ++k) dp[q][k] = -1;\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          char nc;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          for(int t = Lu, a = 0; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][a++];\n            else v += '.';\n          }\n          { \n            int tmp = 0;\n            for(int t = 0; t < v.size(); ++t) tmp += (v[t] != '.');\n            if(tmp == s[i].size()) nc = '$';\n            else nc = s[i][tmp]; \n          }\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(nc != '$') {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (nc == u[0]) * 2;\n            if(v.size()) add += (nc == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,c;\nstring str[130];\nint dp[2][1<<17];\nvector<int> pat[17];\n\nint main(void){\n\tscanf(\"%d%d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tint now=1,prev=0;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tfor(int bit=0;bit<(1<<c);bit++){\n\t\t\t\tif(dp[prev][bit]>=0){\n\t\t\t\t\tif(j==0 && i>0){\n\t\t\t\t\t\tif(__builtin_popcount(bit)!=(int)str[i-1].size())continue;\n\t\t\t\t\t}\n\t\t\t\t\tint nbit=bit<<1;\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\tif(nbit>=(1<<c)){\n\t\t\t\t\t\tnbit-=(1<<c);\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t\tdp[now][nbit]=max(dp[now][nbit],dp[prev][bit]);\n\t\t\t\t\tint sc=0;\n\t\t\t\t\tint cnt=0;\n\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\tif(bit>>k & 1)cnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif(j>0 && (bit>>0 & 1)){\n\t\t\t\t\t\tif(cnt>0 && str[i][cnt-1]==str[i][cnt])sc++;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tint v=__builtin_popcount(bit)-cnt;\n\t\t\t\t\t\tif(v>0){\n\t\t\t\t\t\t\tif(str[i-1][(int)str[i-1].size()-v]==str[i][cnt])sc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[now][nbit+1]=max(dp[now][nbit+1],dp[prev][bit]+sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(now,prev);\n\t\t\tmemset(dp[now],-1,sizeof(dp[now]));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<c);i++){\n\t\tif(__builtin_popcount(i)==(int)str[r-1].size()){\n\t\t\tans=max(ans,dp[prev][i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16];\nconst int INF=1<<30;\nint bitPos[1<<16][18];\nint bitCnt[1<<16][18];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      int res=-INF;\n      if(i==R*C)res=0;\n      else{\n\tconst int cnt=(int)ss[cy].size()-(bitCnt[mask][16]-bitCnt[mask][cx]);\n\tconst int ct=bitCnt[mask][cx];\n\tif(ct<(int)ss[cy].size()){\n\t  int nmask=mask|(1<<cx);\n\t  int add=0;\n\t  if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t     &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t     &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t     &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t    add+=2;\n\t  }\n\t  if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t     &&cnt<(int)ss[cy-1].size()\n\t     &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t     &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t    add+=2;\n\t  }\n\t  if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t    if(cx==C-1)res=max(res,dp[nxt][nmask]+add);\n\t    else res=max(res,dp[nxt][nmask]+add);\n\t  }\n\t}\n\t{\n\t  int nmask=mask&~(1<<cx);\n\t  if(cx!=C-1||ct==(int)ss[cy].size()){\n\t    if(cx==C-1)res=max(res,dp[nxt][nmask]);\n\t    else res=max(res,dp[nxt][nmask]);\n\t  }\n\t}\n\tdp[cur][mask]=res;\n      }\n    }\n  }\n  cout<<dp[0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 16;\nconst int BIT = 1<<MAX_R;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        fill(dp[q], dp[q+1], -1);\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          char nc;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          for(int t = Lu, a = 0; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][a++];\n            else v += '.';\n          }\n          { \n            int tmp = 0;\n            for(int t = 0; t < v.size(); ++t) tmp += (v[t] != '.');\n            if(tmp == s[i].size()) nc = '$';\n            else nc = s[i][tmp]; \n          }\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(nc != '$') {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (nc == u[0]) * 2;\n            if(v.size()) add += (nc == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,w,dp[2][1<<16],cnt,ans;\nstring s[1000];\n\nint DP(int i,int j,int k,int now){\n  now%=2;\n  int L=0,res=0,sut=0,mask=0;\n\n  if(j){\n    int mask=0;\n    r(l,j)mask<<=1,mask|=1;\n    L = __builtin_popcount(mask&k);\n    if( L < s[i].size()){\n      if(L&&s[i][L-1]==s[i][L]&&(k&1))res+=2;\n    }\n    sut=L;\n  }\n\n  mask=(1<<25)-1;\n  r(l,j)mask<<=1;\n  int sum = __builtin_popcount(mask&k);\n  if((k&(1<<(w-1)))&&s[i-1][s[i-1].size()-sum]==s[i][sut])res+=2;\n\n  int nex=0;\n  r(l,w-1)nex|=1,nex<<=1;\n  nex&=(k<<1);\n\n  if(w-j-1>=s[i].size()-sut){\n    dp[(now+1)%2][nex] = max(dp[(now+1)%2][nex],dp[now%2][k]);\n  }\n  if(s[i].size()-sut-1>=0&&s[i].size()-sut-1<=w-j-1){\n    dp[(now+1)%2][nex|1] = max(dp[(now+1)%2][nex|1] , dp[now%2][k]+ res);\n  }\n}\n\nsigned main(){\n  memset(dp,-1,sizeof(dp));\n  dp[0][0]=0;\n  cin>>n>>w;\n  r(i,n)cin>>s[i+1];\n  r(i,w)s[0]+='z'+1; n++;\n  for(int i=1;i<n;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<(1<<w);k++){\n        if(dp[cnt%2][k]==-1)continue;\n        DP(i,j,k,cnt);\n      }\n      r(k,1<<w)dp[cnt%2][k]=-1;\n      cnt++;\n    }\n  }\n  r(i,1<<w) ans=max(ans,dp[cnt%2][i]);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,c;\nstring str[130];\nint dp[2][1<<17];\nvector<int> pat[17];\n\nint main(void){\n\tscanf(\"%d%d\",&r,&c);\n\tfor(int i=0;i<r;i++){\n\t\tcin >> str[i];\n\t}\n\tfor(int i=0;i<(1<<c);i++){\n\t\tpat[(int)__builtin_popcount(i)].push_back(i);\n\t}\n\tint now=1,prev=0;\n\tint f,t;\n\tt=(int)str[0].size();\n\tfor(int i=0;i<(int)pat[t].size();i++){\n\t\tint nbit=pat[t][i];\n\t\tint cnt=0;\n\t\tint sc=0;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(nbit>>j & 1){\n\t\t\t\tif(cnt>0){\n\t\t\t\t\tif(nbit>>(j-1) & 1){\n\t\t\t\t\t\tif(str[0][cnt]==str[0][cnt-1])sc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tdp[prev][nbit]=sc;\n\t}\n\tfor(int i=1;i<r;i++){\n\t\tf=(int)str[i-1].size();\n\t\tt=(int)str[i].size();\n\t\tfor(int j=0;j<(int)pat[f].size();j++){\n\t\t\tfor(int k=0;k<(int)pat[t].size();k++){\n\t\t\t\tint pbit=pat[f][j];\n\t\t\t\tint nbit=pat[t][k];\n\t\t\t\tint cnt[2]={0,0};\n\t\t\t\tint sc=0;\n\t\t\t\tfor(int l=0;l<c;l++){\n\t\t\t\t\tif(nbit>>l & 1){\n\t\t\t\t\t\tif(cnt[1]>0){\n\t\t\t\t\t\t\tif(nbit>>(l-1) & 1){\n\t\t\t\t\t\t\t\tif(str[i][cnt[1]]==str[i][cnt[1]-1])sc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt[1]++;\n\t\t\t\t\t}\n\t\t\t\t\tif(pbit>>l & 1){\n\t\t\t\t\t\tif(nbit>>l & 1){\n\t\t\t\t\t\t\tif(cnt[1]>0 && str[i-1][cnt[0]]==str[i][cnt[1]-1])sc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt[0]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[now][nbit]=max(dp[now][nbit],dp[prev][pbit]+sc);\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tint ans=0;\n\tfor(int i=0;i<(1<<c);i++){\n\t\tans=max(ans,dp[prev][i]);\n\t}\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 17\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\n/*\n  short mem[H][W][1<<W];\n  bool used[H][W][1<<W];\n  int dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n  if(p < (int)str[y].size()) return -INF;\n  return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n  int score = 0;\n  score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n  score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n  b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n  }\n*/\n\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint dp[2][W][1<<W];\nint A[W][1<<W],B[W][1<<W];\nvoid mkAB(int x,int bit){\n  int sum = __builtin_popcount(bit);\n  int cnt = 0;\n  for(int i=0;i<x;i++)cnt+=(bit>>i&1);\n  A[x][bit] = cnt;\n  B[x][bit] = sum - cnt;\n}\n\nint DP(){\n  for(int i=0;i<W;i++)\n    for(int j=0;j<(1<<W);j++)mkAB(i,j);\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0] = 0;\n  int res = 0;\n  for(int i=0;i<h;i++){\n    int idx = i%2;\n    for(int j=0;j<w;j++){\n      for(int bit=0;bit<(1<<w);bit++){\n        if(dp[idx][j][bit]==-1)continue;\n        int p = A[j][bit];\n        int u = i? str[i-1].size()-B[j][bit]:0;\n        if(p+(w-j) < str[i].size()) continue;\n\n        //use space\n        int abit = bit & (~(1<<j));\n        Max(dp[idx][j+1][abit],dp[idx][j][bit]);\n        \n\n        //use character\n        if(p>=(int)str[i].size())continue;\n        int bbit = bit | (1<<j);\n        int score = 0;\n        score += 2*((bit>>j&1)&&(str[i][p]==str[i-1][u]));\n        score += 2*(j>=1&&(bit>>(j-1)&1)&&str[i][p]==str[i][p-1]);\n        Max(dp[idx][j+1][bbit],dp[idx][j][bit]+score);\n      }\n    }\n    for(int bit=0;bit<(1<<w);bit++){\n      if(__builtin_popcount(bit) != str[i].size())continue;\n      Max(dp[!idx][0][bit],dp[idx][w][bit]);\n      Max(res,dp[idx][w][bit]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  //  cout<<dfs(0,0,0,0,0)<<endl;\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 16;\nconst int BIT = 1<<MAX_R;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        fill(dp[q], dp[q+1], -1);\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          char nc;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          for(int t = Lu, a = 0; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][a++];\n            else v += '.';\n          }\n          { \n            int tmp = 0;\n            for(int t = 0; t < v.size(); ++t) tmp += (v[t] != '.');\n            if(tmp == s[i].size()) nc = '$';\n            else nc = s[i][tmp]; \n          }\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(nc != '$') {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (nc == u[0]) * 2;\n            if(v.size()) add += (nc == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n    break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 1000000000;\n\nint popcount[1 << 16];\nint dp[2][16][1 << 16];\nvector<int> patterns[17];\n\nint main(){\n\tint R, C;\n\tcin >> R >> C;\n\tvector<string> words(R + 2);\n\tfor(int i = 1; i <= R; ++i){ cin >> words[i + 1]; }\n\tfor(int i = 0; i < (1 << C); ++i){ popcount[i] = __builtin_popcount(i); }\n\tfor(int i = 0; i < 2; ++i){\n\t\tfor(int j = 0; j < C; ++j){\n\t\t\tfor(int k = 0; k < (1 << C); ++k){ dp[i][j][k] = -INF; }\n\t\t}\n\t}\n\tdp[1][C - 1][0] = 0;\n\tconst int all_mask = (1 << C) - 1;\n\tfor(int i = 1; i < R + 2; ++i){\n\t\tint crow = i & 1, nrow = 1 - crow;\n\t\tfor(int j = 0; j < C; ++j){\n\t\t\tfor(int k = 0; k < (1 << C); ++k){\n\t\t\t\tint dp_cur = dp[crow][j][k];\n\t\t\t\tdp[crow][j][k] = -INF;\n\t\t\t\tint cur = k & ((1 << j) - 1), prev = k >> j;\n\t\t\t\tint pcc = popcount[cur], pcp = popcount[prev];\n\t\t\t\tif(j == 0 && pcp != words[i - 1].size()){ continue; }\n\t\t\t\tif(pcc > words[i].size() || pcp > words[i - 1].size()){ continue; }\n\t\t\t\tint nr = (j == C - 1 ? nrow : crow), nc  = (j + 1) % C, nk = (k << 1) & all_mask;\n\t\t\t\tdp[nr][nc][nk] = max(dp[nr][nc][nk], dp_cur);\n\t\t\t\tif(pcc < words[i].size()){\n\t\t\t\t\tint s = dp_cur;\n\t\t\t\t\tchar c = words[i][pcc];\n\t\t\t\t\tif((k & 1) && words[i][pcc - 1] == c){ s += 2; }\n\t\t\t\t\tif((k & (1 << (C - 1))) && words[i - 1][words[i - 1].size() - pcp] == c){ s += 2; }\n\t\t\t\t\tdp[nr][nc][nk | 1] = max(dp[nr][nc][nk | 1], s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint answer = -INF;\n\tfor(int i = 0; i < (1 << C); ++i){\n\t\tif(popcount[i] != words.back().size()){ continue; }\n\t\tanswer = max(answer, dp[R & 1][0][i]);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[130][16][1<<16];\nsigned main(){\n  int r,c;\n  cin>>r>>c;\n  string s[r];\n  for(int i=0;i<r;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0]=0;\n  int mask=(1<<c)-1;\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++){\n      for(int b=0;b<(1<<c);b++){\n\tif(dp[i][j][b]<0) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<b<<\":\"<<dp[i][j][b]<<endl;\n\tstring t(c,'%'),u;\n\tif(i){\n\t  t=string(j,'%');\n\t  string p;\n\t  for(int k=j,y=(int)s[i-1].size();k<c;k++)\n\t    p.push_back(((b>>k)&1?s[i-1][--y]:'$'));\n\t  reverse(p.begin(),p.end());\n\t  t+=p;\n\t}\n\tint y=0;\n\tfor(int k=j-1;k>=0;k--)\n\t  u.push_back(((b>>k)&1?s[i][y++]:'$'));\n\t\n\tif(y<(int)s[i].size()){\n\t  int nb=((b<<1)&mask)+1;\n\t  //cout<<t<<endl<<u<<s[i][y]<<endl;\n\t  int nd=dp[i][j][b]+(t[j]==s[i][y])*2+(u.back()==s[i][y])*2;\n\t  if(j+1<c)\n\t    dp[i][j+1][nb]=max(dp[i][j+1][nb],nd);\n\t  else if(y+1==(int)s[i].size())\n\t    dp[i+1][0][nb]=max(dp[i+1][0][nb],nd);\n\t}\n\t{\n\t  //cout<<t<<endl<<u<<'&'<<endl;\n\t  int nb=(b<<1)&mask;\n\t  int nd=dp[i][j][b];\n\t  if(j+1<c)\n\t    dp[i][j+1][nb]=max(dp[i][j+1][nb],nd);\n\t  else if(y==(int)s[i].size())\n\t    dp[i+1][0][nb]=max(dp[i+1][0][nb],nd);\n\t}\n      }\n    }\n  }\n  int ans=0;\n  for(int b=0;b<(1<<c);b++)\n    ans=max(ans,dp[r][0][b]);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    string s[200];\n    input(s, h);\n\n    int bits[bin(16)];\n    rep(mask, bin(w))\n        bits[mask] = __builtin_popcount(mask);\n\n    \n    const int inf = ten(6);\n    int cur[bin(16)], next[bin(16)];\n    fill_n(cur, bin(w), -inf);\n    rep(mask, bin(w))\n        if (bits[mask] == s[0].size())\n            cur[mask] = 0;\n    \n    rep(y, h)\n    {\n        // hor\n        rep(mask, bin(w))\n        {\n            if (bits[mask] == s[y].size())\n            {\n                int pos[16];\n                int k = 0;\n                rep(x, w)\n                    if (mask >> x & 1)\n                        pos[k++] = x;\n                rep(i, s[y].size() - 1)\n                    if (s[y][i] == s[y][i + 1] && pos[i] + 1 == pos[i + 1])\n                        ++cur[mask];\n            }\n            else\n                cur[mask] = -inf;\n        }\n\n        if (y == h - 1)\n            break;\n\n        // ver\n        rep(x, w)\n        {\n            fill_n(next, bin(w), -inf);\n            // mask: [next_mask(x bits) + cur_mask(w - x bits)]\n            rep(mask, bin(w))\n            {\n                int cur_mask = mask & ((bin(w - x) - 1) << x);\n                int next_mask = mask & (bin(x) - 1);\n                int cur_i = (int)s[y].size() - bits[cur_mask];\n                int next_i = bits[next_mask];\n                if (cur[mask] < 0 || cur_i < 0)\n                    continue;\n\n\n                // empty\n                chmax(next[mask & ~bin(x)], cur[mask]);\n\n                // put s[y + 1][next_i]\n                if (next_i < s[y + 1].size())\n                {\n                    int adjacent = (mask >> x & 1) && cur_i < s[y].size() && s[y][cur_i] == s[y + 1][next_i];\n                    chmax(next[mask | bin(x)], cur[mask] + adjacent);\n                }\n            }\n            swap(cur, next);\n        }\n    }\n\n    int res = 2 * *max_element(cur, cur + bin(w));\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nhttps://suikaba.hatenablog.com/entry/2017/09/28/182203\n十分に高速化を考えないとTLE\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    int R, C;\n    cin>>R>>C;\n    vector<string>s(R);\n    for(int i=0;i<R;i++)cin>>s[i];\n    vector<int>bitcount(1<<C);\n    for(int i=0;i<(1<<C);i++)bitcount[i]=__builtin_popcount(i);\n    vector<int>dp(1<<C, -1);\n    dp[0] = 0;\n    for(int i=0;i<R;i++){\n        for(int j=0;j<C;j++){\n            vector<int>nxt(1<<C, -1);\n            for(int S=0;S<(1<<C);S++){\n                if(dp[S]==-1)continue;\n                int idx = bitcount[S & (1<<j) - 1];\n                if(idx < s[i].size()){\n                    int t = dp[S];\n                    if(idx > 0 && (S & 1 << (j - 1)) && s[i][idx - 1] == s[i][idx]) {\n                        t++;\n                    }\n                    if(i > 0 && (S & 1 << j) && s[i][idx] == s[i - 1][s[i - 1].size() - bitcount[S >> j]]) {\n                        t++;\n                    }\n                    nxt[S | 1 << j] = max(nxt[S | 1 << j], t);\n                }\n                if(C - j > s[i].size() - idx) {\n                    nxt[S & ~(1 << j)] = max(nxt[S & ~(1 << j)], dp[S]);\n                }\n            }\n            dp.swap(nxt);\n        }\n    }\n    int ans = 0;\n    for(int i=0;i<dp.size();i++)ans=max(ans, dp[i]);\n    cout<<ans*2<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16][20];\nconst int INF=1<<30;\nint bitPos[1<<16][17];\nint bitCnt[1<<16][17];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      for(int k=0;k<16;k++){\n\tint res=-INF;\n\tif(i==R*C)res=0;\n\telse{\n\t  const int cnt=k;\n\t  const int ct=bitCnt[mask][cx];\n\t  if(cnt<(int)ss[cy].size()){\n\t    int nmask=mask|(1<<cx);\n\t    int add=0;\n\t    if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t       &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t       &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t       &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t      add+=2;\n\t    }\n\t    if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t       &&cnt<(int)ss[cy-1].size()\n\t       &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t       &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t      add+=2;\n\t    }\n\t    if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]+add);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]+add);\n\t    }\n\t  }\n\t  {\n\t    int nmask=mask&~(1<<cx);\n\t    if(cx!=C-1||ct==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]);\n\t    }\n\t  }\n\t}\n\tdp[cur][mask][k]=res;\n      }\n    }\n  }\n  cout<<dp[0][0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 16+1;\nconst int BIT = 1<<MAX_R;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        for(int k = 0; k < (1<<c); ++k) dp[q][k] = -1;\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          char nc;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          for(int t = Lu, a = 0; t < c && a < s[i].size(); ++t) {\n            if(k&(1<<t)) v += s[i][a++];\n            else v += '.';\n          }\n          { \n            int tmp = 0;\n            for(int t = 0; t < v.size(); ++t) tmp += (v[t] != '.');\n            if(tmp == s[i].size()) nc = '$';\n            else nc = s[i][tmp]; \n          }\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(nc != '$') {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (nc == u[0]) * 2;\n            if(v.size()) add += (nc == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 16\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\nshort mem[H][W][1<<W];\nbool used[H][W][1<<W];\n\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2449.cc: Connect\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_R = 128;\nconst int MAX_C = 16;\nconst int MAX_CN = 12870;  // 16C8\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\n/* global variables */\n\nvi combs[MAX_C + 1];\nstring ss[MAX_R];\nint als[MAX_R][26];\nvs css[MAX_R];\nint dp[MAX_R][MAX_CN];\n\n/* subroutines */\n\nvoid comb_rec(vi &comb, int n, int k, int i = 0, int m = 0, int bits = 0) {\n  if (m >= k) {\n    comb.push_back(bits);\n    return;\n  }\n  if (i >= n) return;\n\n  comb_rec(comb, n, k, i + 1, m + 1, bits | (1 << i));\n  comb_rec(comb, n, k, i + 1, m, bits);\n}\n\nstring arng(string &s, int c, int bits) {\n  int n = s.size();\n  string ret(c, '.');\n  for (int i = 0, j = 0; i < n; i++, j++) {\n    while (! (bits & (1 << j))) j++;\n    ret[j] = s[i];\n  }\n  return ret;\n}\n\n/* main */\n\nint main() {\n  int r, c;\n  cin >> r >> c;\n  int cbits = 1 << c;\n\n  for (int i = 0; i < r; i++) {\n    cin >> ss[i];\n    for (int j = 0; j < ss[i].size(); j++) als[i][ss[i][j] - 'A']++;\n  }\n\n  for (int i = 0; i <= c; i++) {\n    comb_rec(combs[i], c, i);\n    //printf(\"%d: %lu\\n\", i, combs[i].size());\n  }\n  //printf(\"%x\\n\", combs[c][0]);\n\n  for (int i = 0; i < r; i++) {\n    int sn = ss[i].size();\n    for (int j = 0; j < sn; j++) {\n      char ch = ss[i][j];\n      int ci = ch - 'A';\n      bool ex =\n\t(j > 0 && ss[i][j - 1] == ch) || (j < sn - 1 && ss[i][j + 1] == ch) ||\n\t(i > 0 && als[i - 1][ci] > 0) || (i < r - 1 && als[i + 1][ci] > 0);\n      if (! ex) ss[i][j] = '.';\n    }\n    //cout << ss[i] << endl;\n\n    vi &cmb = combs[sn];\n    for (vi::iterator vit = cmb.begin(); vit != cmb.end(); vit++) {\n      string ar = arng(ss[i], c, *vit);\n      css[i].push_back(ar);\n    }\n\n    sort(css[i].begin(), css[i].end());\n    vs::iterator ce = unique(css[i].begin(), css[i].end());\n    css[i].erase(ce, css[i].end());\n    //printf(\"%d: %lu\\n\", i, css[i].size());\n  }\n  \n  memset(dp, -1, sizeof(dp));\n\n  for (int j = 0; j < css[0].size(); j++) {\n    string &s = css[0][j];\n    int dsum = 0;\n    for (int k = 0; k < c; k++)\n      if (s[k] != '.') {\n\tif (k > 0 && s[k - 1] == s[k]) dsum++;\n\tif (k < c - 1 && s[k] == s[k + 1]) dsum++;\n      }\n    dp[0][j] = dsum;\n  }\n\n  for (int i = 1; i < r; i++) {\n    for (int j0 = 0; j0 < css[i - 1].size(); j0++)\n      if (dp[i - 1][j0] >= 0) {\n\tstring &s0 = css[i - 1][j0];\n\tfor (int j1 = 0; j1 < css[i].size(); j1++) {\n\t  string &s1 = css[i][j1];\n\t  int dsum = 0;\n\t  for (int k = 0; k < c; k++)\n\t    if (s1[k] != '.') {\n\t      if (s0[k] == s1[k]) dsum += 2;\n\t      if (k > 0 && s1[k - 1] == s1[k]) dsum++;\n\t      if (k < c - 1 && s1[k] == s1[k + 1]) dsum++;\n\t    }\n\n\t  int dp0 = dp[i - 1][j0] + dsum;\n\t  if (dp[i][j1] < dp0) dp[i][j1] = dp0;\n\t}\n      }\n  }\n\n  int maxdp = 0;\n  for (int j = 0; j < css[r - 1].size(); j++)\n    if (maxdp < dp[r - 1][j]) maxdp = dp[r - 1][j];\n  printf(\"%d\\n\", maxdp);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 128;\nconst int MAX_C = 16+1;\nconst int BIT = 1<<MAX_C;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        for(int k = 0; k < (1<<c); ++k) dp[q][k] = -1;\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          char u, l;\n          int use;\n          u = l = '.';\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u = s[i-1][a--];\n            else u = '.';\n          }\n          use = 0;\n          for(int t = Lu; t < c; ++t) {\n            if(k&(1<<t)) l = s[i][use++];\n            else l = '.';\n          }\n\n          if(use + (c-j) < s[i].size()) continue;\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(use < s[i].size()) {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (s[i][use] == u) * 2;\n            add += (s[i][use] == l) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\n// 長さnの11..11\nuint one(int n)\n{\n\treturn (1<<n)-1;\n}\n\ntemplate<typename T>\nvoid chmax(T& a,const T& b)\n{\n\ta=max(a,b);\n}\n\nint main()\n{\n\tconst char WILD='*';\n\tconst char EMPTY0='#';\n\tconst char EMPTY1='!';\n\tconst char EMPTY2='?';\n\tstatic_assert(EMPTY0!=EMPTY1 && EMPTY1!=EMPTY2 && EMPTY2!=EMPTY0,\"ha?\");\n\t\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs ss(h);\n\t\trep(i,h) cin>>ss[i];\n\t\t\n\t\tss.insert(begin(ss),string(w,'#'));\n\t\th++;\n\t\t\n\t\tvector<vvi> dp(h,vvi(w,vi(1<<w,-INF)));\n\t\tdp[0][w-1][(1<<w)-1]=0;\n\t\t\n\t\trepi(i,1,h) rep(j,w){\n\t\t\tint pi=i,pj=j-1;\n\t\t\tif(pj<0) pi--,pj+=w;\n\t\t\trep(k,1<<w){\n\t\t\t\tint al=popcount(k&one(j+1)),ar=ss[i].size()-al;\n\t\t\t\tint br=popcount(k>>j+1&one(w-j-1)),bl=ss[i-1].size()-br;\n\t\t\t\tif(al<0 || j+1<al || ar<0 || w-j-1<ar\n\t\t\t\t|| bl<0 || j+1<bl || br<0 || w-j-1<br) continue;\n\t\t\t\tif(k>>j&1){\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]+2*(ss[i][al-1]==ss[i-1][bl-1]));\n\t\t\t\t\tif(al>=2 && (k>>j+1&1) && ss[i][al-2]==ss[i][al-1])\n\t\t\t\t\t\tdp[i][j][k]+=2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]);\n\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<*max_element(all(dp[h-1][w-1]))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define H 128\n#define W 17\n#define INF 1e4\nusing namespace std;\nint h,w;\nstring str[H];\n\n/*\nshort mem[H][W][1<<W];\nbool used[H][W][1<<W];\nint dfs(int y,int x,int bit,int p,int u){\n  if( y == h ) return 0;\n  if(p+(w-x) < str[y].size()) return -INF;\n  if( x == w ) {\n    if(p < (int)str[y].size()) return -INF;\n    return dfs(y+1,0,bit,0,0);\n  }\n\n  if(used[y][x][bit]) return mem[y][x][bit];\n  used[y][x][bit] = 1;\n  int a=0,b=0;\n\n  //?????????????????????\n  int abit = bit & (~(1<<x));\n  a = dfs(y,x+1,abit,p,u+(bit>>x&1));\n  \n  //???????????????\n  int bbit = bit | (1<<x);\n  if(p<(int)str[y].size()){\n    int score = 0;\n    score += 2*((bit>>x&1)&&(str[y][p]==str[y-1][u]));\n    score += 2*(x>=1&&(bit>>(x-1)&1)&&str[y][p]==str[y][p-1]);\n    b = score+dfs(y,x+1,bbit,p+1,u+(bit>>x&1));\n  }\n  return mem[y][x][bit]=max(a,b);\n}\n*/\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint dp[2][W][1<<W];\nint A[W][1<<W],B[W][1<<W];\n\nvoid mkAB(int x,int bit){\n  int sum = __builtin_popcount(bit);\n  int cnt = 0;\n  for(int i=0;i<x;i++)cnt+=(bit>>i&1);\n  A[x][bit] = cnt;\n  B[x][bit] = sum - cnt;\n}\n\nint DP(){\n  for(int i=0;i<W;i++)\n    for(int j=0;j<(1<<W);j++)mkAB(i,j);\n\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0] = 0;\n  int res = 0;\n  \n  for(int i=0;i<h;i++){\n    int idx = i%2;\n    for(int j=0;j<w;j++){\n      for(int bit=0;bit<(1<<W);bit++){\n        if(dp[idx][j][bit]==-1)continue;\n\n        int p = A[j][bit];\n        int u = str[i].size()-B[j][bit];\n        \n        //use space\n        int abit = bit & (~(1<<j));\n        Max(dp[idx][j+1][abit],dp[idx][j][bit]);\n        \n\n        //use character\n        if(p>=(int)str[i].size())continue;\n        int bbit = bit | (1<<j);\n        int score = 0;\n        score += 2*((bit>>j&1)&&(str[i][p]==str[i-1][u]));\n        score += 2*(j>=1&&(bit>>(j-1)&1)&&str[i][p]==str[i][p-1]);\n        Max(dp[idx][j+1][bbit],dp[idx][j][bit]+score);\n\n    }\n\n      for(int bit=0;bit<(1<<W);bit++){\n        if(__builtin_popcount(bit) != str[i].size())continue;\n        Max(dp[!idx][0][bit],dp[idx][w][bit]);\n        Max(res,dp[idx][w][bit]);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++) cin>>str[i];\n  //  cout<<dfs(0,0,0,0,0)<<endl;\n  cout<<DP()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint R,C,/*dp[130][16][(1<<16)]*/dp[2][(1<<16)],len[130];\nstring s[130];\n\nint main(){\n\n  cin >> R >> C;\n  rep(i,R){\n    cin >> s[i];\n    len[i] = (int)s[i].size();\n  }\n\n  rep(i,(1<<C))dp[0][i] = -1;\n  dp[0][0] = 0;\n\n  int answer = 0;\n  rep(r,R)rep(c,C){\n\n    int phase = ( (c+r*C) & 1 );\n    int next_phase = !phase;\n\n    rep(i,(1<<C))dp[next_phase][i] = -1;\n\n    rep(state,(1<<C)){\n      if( dp[phase][state] == -1 ) continue;\n      int next_state = state & (~(1<<c));\n      int bitmask = (1<<c)-1;\n      int bits_L = __builtin_popcount(bitmask&state);\n      int bits_R = __builtin_popcount(state)-bits_L;\n\n      if( ( r-1 >= 0 && bits_R > len[r-1] ) || ( r-1>=0 && c+bits_R < len[r-1] ) ) continue;\n      if( bits_L > len[r] || ( C-c+bits_L < len[r] ) ) continue;\n\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n\n\n\n      next_state |= (1<<c);\n      int score = 0;\n      char char_M = s[r][bits_L];\n      if( r-1 >= 0 && bits_R <= len[r-1] && c+bits_R >= len[r-1] ){\n\tif( bits_R > 0 && ((state>>c)&1) ){\n\t  char char_R = s[r-1][len[r-1]-bits_R];\n\t  if( char_M == char_R ) score++;\n\t}\n      }\n\n      if( c-1 >= 0 && bits_L < len[r] && C-c+bits_L >= len[r] ){\n\tif( bits_L > 0 && ((state>>(c-1))&1) ){\n\t  char char_L = s[r][bits_L-1];\n\t  if( char_L == char_M ) score++;\n\t}\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]+score);\n      answer = max(answer,dp[next_phase][next_state]);\n\n    }\n  }\n  cout << answer*2 << endl;\n\n  /*\n    rep(r,R)rep(c,C){\n    int phase = ((c+r*C)&1);\n    int next_phase = !phase;\n    rep(i,(1<<C))dp[next_phase][i] = 0;\n    rep(state,(1<<C)){\n      bitset<9> BIT(state);      \n      int bitmask = (1<<c)-1;\n      int bits_L  = __builtin_popcount(state & bitmask);\n      int bits_R  = __builtin_popcount(state) - bits_L;\n      cout << \"(\" << c << \",\" << r  << \") : \" << BIT << endl;\n      cout << \"bits ( \" << bits_L << \",\" << bits_R << \")\" << endl;\n      if( bits_L   > len[r]   ) continue; \n      if( bits_L+C-c < len[r] ) continue;\n      if( c+bits_R < len[r+1] ) continue; \n      cout << \"here\" << endl;\n\n      int next_state = state & (~(1<<c));\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n      next_state |= (1<<c);\n      if( bits_L == len[r] ){\n\tdp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t\t dp[phase][state]);\n\tcontinue;\n      }\n\n      int score = 0;\n      char char_M = s[r][c];\n      if( bits_L > 0 && c-1 > 0 && ((state>>(c-1))&1) ){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n\n      if( bits_R > 0 && r+1 < R && ((state>>c)&1) ){\n\tchar char_B = s[r+1][len[r+1]-bits_R];\n\tif( char_M == char_B ) score++;\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state] + score);\n      cout << \"score = \" << score << endl;\n      BIT = next_state;\n      cout << \"dp[\" << next_phase << \"][\" << BIT << \"] = \" << dp[next_phase][next_state] << endl;\n      answer = max(answer,dp[next_phase][next_state]);\n    }\n  }\n  cout << 2 * answer << endl;\n  */\n\n  /*\n\n  rep(r,R)rep(c,C)rep(state,(1<<C)){\n\n    int bitmask = (1<<c)-1;\n    int bits_L = __builtin_popcount(bitmask&state);\n    int bits_R = __builtin_popcount(state)-bits_L;\n\n    if( bits_L > len[r]   ) continue;\n\n    int next_state = state & ~(1<<c);\n    int next_r = r, next_c = c+1;\n    if( next_c >= C ) next_r++, next_c = 0;\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n    char char_M = s[r][bits_L];\n    int score = 0;\n    if( c-1>=0 && ((state>>(c-1))&1) ){\n      if(bits_L-1>=0){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n    }\n\n    if( (state>>c)&1 && r+1 < R){\n      char char_B = s[r+1][len[r+1]-bits_R];\n      if( char_M == char_B ) score++;\n    }\n\n    next_state |= (1<<c);\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]+score);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n  }\n\n  cout << 2*answer << endl;\n\n  */\n\n  /*\n  REP(r,1,R){\n    rep(c,C){\n      rep(state,(1<<C)){\n\tint bitmask = (1<<(c+1))-1;\n\tint bits_R = __builtin_popcount(bitmask&state);\n\tint bits_L = __builtin_popcount(state)-bits_R;\n\n\tif( bits_R > len[r-1] ) continue;\n\tif( bits_L > len[r] ) continue;\n\n\tint next_state = state & ~(1<<c);\n\tint prer = ((c-1>=0)?r  :r-1);\n\tint prec = ((c-1>=0)?c-1:C-1);\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]);\n\tanswer = max(answer,dp[r][c][next_state]);\n\n\tif( bits_L+1 > len[r] ) continue;\n\n\tnext_state |= (1<<c);\n\tchar char_M = s[r][len[r]-bits_L-1];\n\tint score = 1;\n\tif( (state>>c) & 1 ){\n\t  char char_T = s[r-1][bits_R];\n\t  if( char_M == char_T ) score++;\n\t}\n\n\tif( ( (state>>(c+1)) & 1 ) ) {\n\t  char char_L = s[r][len[r]-bits_L];\n\t  if( char_M == char_L )score++;\n\t}\n\tif( score == 1 ) continue;\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]+score);\n\tanswer = max(answer,dp[r][c][next_state]);\n      }\n    }\n  }\n\n  cout << answer << endl;\n  */\n\n  return 0;\n}\n\n/*\n21:27 -  22:26 give up \nthe following code is too slow!\n\n\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint dx[] = {0,-1};\nint dy[] = {-1,0};\nstring G[130];\nint dp[130][(1<<17)];\nstring line[2];\n\nint main(){\n  int H,W;\n  cin >> H >> W;\n  vector<int> loop[H];\n  rep(i,H){\n    cin >> G[i];\n    int remain = W - (int)G[i].size();\n    //cout << i << \" => \" << remain << endl;\n    rep(j,(1<<W)){\n      if(__builtin_popcount(j) == remain)loop[i].push_back(j);\n    } \n  }\n\n  vector<string> pre[H];\n  rep(i,H){\n    sort(loop[i].begin(),loop[i].end());\n    loop[i].erase(unique(loop[i].begin(),loop[i].end()),loop[i].end());\n    cout << loop[i].size() << endl;\n    assert((int)loop[i].size() < (1<<W));\n    rep(j,loop[i].size()){\n      int state = loop[i][j],idx = 0;\n      string line = \"\";\n      rep(j,W){\n\tif((state>>j) & 1)line += \" \";\n\telse              line += G[i][idx++];\n      }\n      pre[i].push_back(line);\n    }\n  }\n  //cout << \"-----------\" << endl;\n  int ans = 0;\n  rep(y,H){\n    rep(i,loop[y].size()){\n      int state = loop[y][i];\n      line[1] = pre[y][i];\n      rep(j,((y-1>=0)?loop[y-1].size():1) ){\n\tint pstate = ((y-1>=0)?loop[y-1][j]:0);\n\tline[0] = ((y-1>=0)?pre[y-1][j]:string(W,' '));\n\tint point = 0;\n\trep(k,W){\n\t  int X = k, Y = 1;\n\t  rep(l,2){\n\t    int nx = X + dx[l], ny = Y + dy[l];\n\t    if(!( 0 <= nx && nx < W && 0 <= ny && ny < H ))continue;\n\t    if(line[Y][X] != ' ' && line[Y][X] == line[ny][nx]) point++;\n\t  }\n\t}\n\tdp[y][state] = max(dp[y][state],((y-1>=0)?dp[y-1][pstate]:0)+point);\n\tans = max(ans,dp[y][state]);\n      } \n    }\n  }\n  cout << ans * 2 << endl;\n  return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint dp[2][1 << 16],*now = dp[0],*nxt = dp[1];\n\tint h,w;\n\tstring s[130];\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++) cin >> s[i];\n\tfor(int i = 0;i < (1 << w);i++) now[i] = nxt[i] = -INF;\n\tnow[0] = 0;\n\tint popcount[1 << 16];\n\tfor(int i = 0;i < (1 << w);i++) popcount[i] = __builtin_popcountll(i);\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tfor(int k = 0;k < (1 << w);k++) nxt[k] = -INF;\n\t\t\tfor(int k = 0;k < (1 << w);k++){\n\t\t\t\tint l = popcount[k % (1 << j)];\n\t\t\t\tif(now[k] < 0) continue;\n\t\t\t\tint up = s[i-1].length()-popcount[k >> j];\n\t\t\t\tint add = (((k>>j)&1) && i && s[i-1][up]==s[i][l])\n\t\t\t\t+ (l && ((k>>(j-1))&1) && s[i][l-1]==s[i][l]);\n\t\t\t\tchmax(nxt[k | (1 << j)],now[k] + 2 * add);\n\t\t\t\tchmax(nxt[k & ~(1 << j)],now[k]);\n\t\t\t}\n\t\t\tswap(now,nxt);\n\t\t}\n\t\tfor(int k = 0;k < (1 << w);k++){\n\t\t\tif(popcount[k] != s[i].length()) now[k] = -INF;\n\t\t}\n\t}\n\tint ans = -INF;\n\tfor(int i = 0;i < (1 << w);i++) chmax(ans,now[i]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tint idx = c[j][k][0],o=(int)s[i-1].size()-c[j][k][1]; //idx?????????????????¨???????????????????????????????????????o ?????????????????????????????????\n\t\n\tif(i && k&(1<<j) && idx <(int)s[i].size() && o && o < (int)s[i-1].size() && s[i][idx] == s[i-1][o]) cs+=2;\n\n\n\tif(j && idx && idx < (int)s[i].size() && (k & 1<<(j-1) ) && s[i][idx -1] == s[i][idx]) cs+=2;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() -1){\n\t  Max(dp[(i+(j==w-1))%2][(j+1)%w][k|(1<<j)],dp[i%2][j][k]+cs);\n\n\t}\n\tint nk=k;\n\tif(k&1<<j) nk^=1<<j;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() ) Max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if((int)s[h-1].size()==c[0][i][1]){\n      ans=max(ans,dp[h%2][0][i]);\n    }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dp[2][1<<16];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int R, C;\n  cin >> R >> C;\n  VI len(R);\n  VS vs(R);\n  REP(i,R){\n\tcin >> vs[i];\n\tlen[i] = SZ(vs[i]);\n  }\n\n  int crt = 0, nxt = 1;\n  fill((int*)dp, (int*)dp+2*(1<<16), -1);\n  REP(B,1<<C){\n\tif(__builtin_popcount(B) != len[0]) continue;\n\tdp[crt][B] = 0;\n\tfor(int x=0,i=0;i+1<len[0];++i){\n\t  while(x < C && (B>>x&1) == 0) ++x;\n\t  if((B>>(x+1)&1) && vs[0][i] == vs[0][i+1])\n\t\tdp[crt][B]++;\n\t  ++x;\n\t}\n  }\n\n  FOR(y,1,R){\n\tREP(x,C){\n\t  fill(dp[nxt], dp[nxt]+(1<<16), -1);\n\t  REP(B,1<<C) if(dp[crt][B] >= 0){\n\t\t// not place character\n\t\tmaxi(dp[nxt][B>>1], dp[crt][B]);\n\n\t\tint next_b = (B >> 1) | (1 << (C-1));\n\t\tint next = dp[crt][B];\n\t\tint lb = B & ((1<<(C-x))-1);\n\t\tint lbi = len[y-1] - __builtin_popcount(lb);\n\t\tint ub = B >> (C-x);\n\t\tint ubi = __builtin_popcount(ub);\n\n\t\tif(ubi >= len[y])\n\t\t  continue;\n\t\t// up\n\t\tif(lbi < len[y-1] && (B&1) && vs[y-1][lbi] == vs[y][ubi])\n\t\t  ++next;\n\t\t// left\n\t\tif(ubi > 0 && (B>>(C-1)&1) && vs[y][ubi-1] == vs[y][ubi])\n\t\t  ++next;\n\n\t\tmaxi(dp[nxt][next_b], next);\n\t  }\n\t  swap(crt, nxt);\n\t}\n\n\tREP(B,1<<C){\n\t  if(__builtin_popcount(B) != len[y])\n\t\tdp[crt][B] = -1;\n\t}\n  }\n\n  int ans = 0;\n  REP(B,1<<C)\n\tmaxi(ans, dp[crt][B]);\n  cout << ans*2 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define inf 1000000000\n\nusing namespace std;\n\nint R, C;\nstring s[130];\n\nint dp[2][70000];\n\nint main(void)\n{\n\tcin >> R >> C;\n\tfor(int i = 1; i <= R; i++) cin >> s[i];\n\t\n\tint N = 1 << C;\n\tfor(int i = 0; i < N; i++) dp[1][i] = -inf;\n\tdp[1][0] = 0;\n\t\n\tfor(int i = 1; i <= R; i++){\n\t\tfor(int j = 0; j < C; j++){\n\t\t\tint cur = ((i-1)*C+j+1) % 2, next = !cur;\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\n\t\t\t\tint left = 0, up = 0;\n\t\t\t\tfor(int l = 0; l < j; l++) if(k & (1<<l)) left++;\n\t\t\t\t\n\t\t\t\tif(s[i].size() - left <= C - j - 1){\n\t\t\t\t\tdp[next][k & ~(1<<j)] = max(dp[next][k & ~(1<<j)], dp[cur][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(left < s[i].size()){\n\t\t\t\t\tint val = dp[cur][k];\n\t\t\t\t\tif(j > 0 && (k & (1 << (j-1)))){\n\t\t\t\t\t\tif(s[i][left-1] == s[i][left]) val += 2;\n\t\t\t\t\t}\n\t\t\t\t\tif(i > 1 && k & (1<<j)){\n\t\t\t\t\t\tfor(int l = C-1; l >= j; l--) if(k & (1<<l)) up++;\n\t\t\t\t\t\tup = s[i-1].size() - up;\n\t\t\t\t\t\tif(up < s[i-1].size() && s[i-1][up] == s[i][left]) val += 2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdp[next][k | (1<<j)] = max(dp[next][k | (1<<j)], val);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(j == C-1){\n\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int l = 0; l < C; l++) if(k & (1<<l)) cnt++;\n\t\t\t\t\tif(cnt != s[i].size()) dp[next][k] = -inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(int k = 0; k < N; k++){\n\t\t\t\tif(dp[next][k] < 0) cout << \"x \";\n\t\t\t\telse cout << dp[next][k] << \" \";\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tans = max(ans, dp[((R-1)*C + (C-1)) % 2][i]);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<string> mat;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nint r,c,ans;\n\nbool f;\n\nint check(int y, int x, mat str){\n  int res = 0;\n  if(str[y][x] == ' ') return 0;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= str.size()) continue;\n    if(nx < 0 || nx >= str[y].size()) continue;\n    if(str[ny].size() < nx) continue;\n    if(str[ny][nx] == str[y][x]) res++;\n  }\n  return res;\n}\n\nvoid calc(mat str){\n  int res = 0;\n\n  for(int i=0;i<str.size();i++)\n    for(int j=0;j<str[i].size();j++)\n      res += check(i, j, str);\n\n  ans = max(ans,res);\n  /*\n  if(res == 18){\n    for(int i=0;i<str.size();i++){\n      cout << str[i] << endl;\n    }\n    cout << endl;\n    for(int i=0;i<str.size();i++){\n      for(int j=0;j<str[i].size();j++) cout << check(i,j,str);\n        cout << endl;\n    }\n    cout << endl;\n    }*/\n}\n\nvoid func(int y, int x, mat str){\n  if(x == c){\n    x = 0;\n    y++;\n  }\n  if(y == r){\n    calc(str);\n    return;\n  }\n\n  if(str[y].size() < c && x < str[y].size()){\n    func(y, x+1, str);\n    if(str[y][x] != ' '){\n      if(y > 0){\n        for(int i=x+1;i<str[y-1].size();i++){\n          if(str[y].size() + i - x > c) break;\n          if(str[y][x] == str[y-1][i]){\n            str[y].insert(str[y].begin()+x, i-x, ' ');\n            func(y, x+(i-x)+1, str);\n            return;\n          }\n        }\n      } else {\n        str[y].insert(str[y].begin()+x, ' ');\n        func(y, x+1, str);\n      }\n    }\n  } else {\n    func(y+1, 0, str);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    mat v;\n    for(int i=0;i<r;i++){\n      string str;\n      cin >> str;\n      v.push_back(str);\n    }\n    ans = 0;\n    func(0,0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\tdp[(i+1)%2][j][k]=0;\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tint idx = c[j][k][0],o=(int)s[i-1].size()-c[j][k][1];\n\t\n\tif(i && k&(1<<j) && idx <(int)s[i].size() && 0<=o && o < (int)s[i-1].size() && s[i][idx] == s[i-1][o]) cs+=2;\n\n\n\tif(j && idx && idx < (int)s[i].size() && (k & 1<<(j-1) ) && s[i][idx -1] == s[i][idx]) cs+=2;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() -1){\n\t  Max(dp[(i+(j==w-1))%2][(j+1)%w][k|(1<<j)],dp[i%2][j][k]+cs);\n\n\t}\n\tint nk=k;\n\tif(k&1<<j) nk^=1<<j;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() ) Max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if((int)s[h-1].size()==c[0][i][1]){\n      ans=max(ans,dp[h%2][0][i]);\n    }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXC = 16;\nconst int MAXR = 200;\nint R, C;\nstring S[MAXR];\n\nint dp[2][1<<MAXC];\n\nint main() {\n  cin >> R >> C;\n  for(int i = 0; i < R; ++i) {\n    cin >> S[i];\n  }\n  memset(dp, -1, sizeof(dp));\n  dp[0][0] = 0;\n  int now = 0, next = 1;\n  for(int i = 0; i < R; ++i) {\n    for(int j = 0; j < C; ++j) {\n      fill(dp[next], dp[next] + (1<<C), -1);\n      for(int bit = 0; bit < (1<<C); ++bit) {\n        if(dp[now][bit] == -1) continue;\n        int value = dp[now][bit];\n\n        char top = '_';\n        if(i) {\n          for(int k = C - j - 1, l = S[i-1].size(); k >= 0; --k) {\n            if(bit >> k & 1) top = S[i-1][--l];\n            else top = '_';\n          }\n        }\n\n        char left = '_';\n        int num = 0;\n        for(int k = C - j, l = 0; k < C; ++k) {\n          if(bit >> k & 1) left = S[i][l++], ++num;\n          else left = '_';\n        }\n\n        do {\n          int nbit = bit >> 1;\n          if(num == S[i].size()) break;\n          char c = S[i][num];\n          nbit |= 1 << (C - 1);\n          if(j+1 == C) {\n            if(num+1 != S[i].size()) break;\n          }\n          dp[next][nbit] = max(dp[next][nbit],\n                               value\n                               + (isalpha(c) && c == top)\n                               + (isalpha(c) && c == left));\n        } while(0);\n\n        do {\n          int nbit = bit >> 1;\n          if(j+1 == C) {\n            if(num != S[i].size()) break;\n          }\n          dp[next][nbit] = max(dp[next][nbit], value);\n        } while(0);\n      }\n      swap(now, next);\n    }\n  }\n  int res = 0;\n  for(int bit = 0; bit < (1<<C); ++bit) {\n    res = max(res, dp[now][bit]);\n  }\n  cout << res*2 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\nint R,C;\n\nchar s[128][20];\nint len[128];\nint dp[2][(1<<16)];\n\nint main(){\n  scanf(\"%d %d\",&R,&C);\n  for(int i=0;i<R;i++){\n    scanf(\"%s\",s[i]);\n    len[i]=strlen(s[i]);\n  }\n  \n\n  fill( (int*)dp[0], (int*)dp[2], -INF);\n  dp[0][0]=0;\n\n  int ai=1,bi=0;\n  int ans=0;\n  for(int i=0;i<=R;i++){\n\n    \n    for(int j=0;j<C;j++){\n\n      swap(ai,bi);\n      fill( (int*)dp[bi], (int*)dp[bi+1] ,-INF);\n    \n      for(int bit=0;bit<(1<<C);bit++){\n        if(dp[ai][bit]==-INF)continue;\n\n        if(j==0 && __builtin_popcount(bit) != len[i-1])continue;\n        if(i==R&&j==0)ans=max(ans,dp[ai][bit]);\n        \n        if(i==R)continue;\n        int a=0,b=0,cost=dp[ai][bit];\n        for(int k=0;k<C-j;k++)a+=(bit>>k&1);\n        for(int k=C-j;k<C;k++)b+=(bit>>k&1);\n        \n        int nbit=bit>>1;\n        dp[bi][nbit]=max(dp[bi][nbit],cost);\n        \n\n        if(b==len[i])continue;\n        \n        int flg=0;\n        if(bit&1 && s[i][b]==s[i-1][len[i-1]-a])flg++;\n        if(bit>>(C-1)&1)\n          if(b>0&&s[i][b-1]==s[i][b])flg++;\n        \n        nbit=(bit|(1<<C))>>1;\n        dp[bi][nbit]=max(dp[bi][nbit],cost+flg);\n  \n      }\n    }\n  }\n  cout<<ans*2<<endl;\n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tint idx = c[j][k][0],o=(int)s[i-1].size()-c[j][k][1];\n\t\n\tif(i && idx <(int)s[i].size() && o && o < (int)s[i-1].size() - o && s[i][idx] == s[i-1][o]) cs+=2;\n\n\n\tif(j && idx && idx < (int)s[i].size() && (k & 1<<(j-1) ) && s[i][idx -1] == s[i][idx]) cs+=2;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() -1){\n\t  Max(dp[(i+(j==w-1))%2][(j+1)%w][k|(1<<j)],dp[i%2][j][k]+cs);\n\n\t}\n\tint nk=k;\n\tif(k&1<<j) nk^=1<<j;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() ) Max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if((int)s[h-1].size()==c[0][i][1]){\n      ans=max(ans,dp[h%2][0][i]);\n    }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,dp[2][1<<16],I;\nstring s[128];\nbool B(int x,int i){return (x>>i)&1;}\nint bc(int x){return x==0?0:__builtin_popcount(x);}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[i];\n\trep(b,1<<W) dp[0][b]=-1;\n\tdp[0][0]=0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\trep(b,1<<W) dp[1-I][b]=-1;\n\t\t\trep(b,1<<W){\n\t\t\t\tif(dp[I][b]<0) continue;\n\t\t\t\t//put\n\t\t\t\tint x=bc(b&((1<<j)-1));\n\t\t\t\tif(x<s[i].size()){\n\t\t\t\t\tint pl=0;\n\t\t\t\t\tif(i>0&&B(b,j)&&s[i-1][s[i-1].size()+x-bc(b)]==s[i][x]) pl+=2;//tate\n\t\t\t\t\tif(j>0&&B(b,j-1)&&s[i][x]==s[i][x-1]) pl+=2;//yoko\n\t\t\t\t\tchmax(dp[1-I][b|(1<<j)],dp[I][b]+pl);\n\t\t\t\t}\n\t\t\t\t//dont put\n\t\t\t\tchmax(dp[1-I][b&(~(1<<j))],dp[I][b]);\n\t\t\t}\n\t\t\tI=1-I;\n\t\t}\n\t\trep(b,1<<W) if(bc(b)!=s[i].size()) dp[I][b]=-1;\n\t}\n\tint ans=0;\n\trep(i,1<<W) chmax(ans,dp[I][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ninline int popcount(uint x)\n{\n\tx=(x&0x55555555)+(x>>1&0x55555555);\n\tx=(x&0x33333333)+(x>>2&0x33333333);\n\tx=(x&0x0f0f0f0f)+(x>>4&0x0f0f0f0f);\n\tx=(x&0x00ff00ff)+(x>>8&0x00ff00ff);\n\treturn (x&0x0000ffff)+(x>>16&0x0000ffff);\n}\n\n// 長さnの11..11\nuint one(int n)\n{\n\treturn (1<<n)-1;\n}\n\ntemplate<typename T>\nvoid chmax(T& a,const T& b)\n{\n\ta=max(a,b);\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs ss(h);\n\t\trep(i,h) cin>>ss[i];\n\t\t\n\t\tss.insert(begin(ss),string(w,'#'));\n\t\th++;\n\t\t\n\t\tvector<vvi> dp(h,vvi(w,vi(1<<w,-INF)));\n\t\tdp[0][w-1][(1<<w)-1]=0;\n\t\t\n\t\trepi(i,1,h){\n\t\t\trep(j,w){\n\t\t\t\tint pi=i,pj=j-1;\n\t\t\t\tif(pj<0) pi--,pj+=w;\n\t\t\t\trep(k,1<<w){\n\t\t\t\t\tint al=popcount(k&one(j+1)),ar=ss[i].size()-al;\n\t\t\t\t\tint br=popcount(k>>j+1&one(w-j-1)),bl=ss[i-1].size()-br;\n\t\t\t\t\tif(al<0 || j+1<al || ar<0 || w-j-1<ar\n\t\t\t\t\t   || bl<0 || j+1<bl || br<0 || w-j-1<br) continue;\n\t\t\t\t\tif(k>>j&1){\n\t\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]+2*(ss[i][al-1]==ss[i-1][bl-1]));\n\t\t\t\t\t\tif(al>=2 && (k>>j-1&1) && ss[i][al-2]==ss[i][al-1])\n\t\t\t\t\t\t\tdp[i][j][k]+=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(bl<j+1)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k]);\n\t\t\t\t\t\tif(bl>0)\n\t\t\t\t\t\t\tchmax(dp[i][j][k],dp[pi][pj][k^1<<j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvvi().swap(dp[i-1]);\n\t\t}\n\t\t\n\t\tcout<<*max_element(all(dp[h-1][w-1]))<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[130][16][1<<16];\nsigned main(){\n  int r,c;\n  cin>>r>>c;\n  string s[r];\n  for(int i=0;i<r;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0]=0;\n  int mask=(1<<c)-1;\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++){\n      for(int b=0;b<(1<<c);b++){\n\tif(dp[i][j][b]<0) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<b<<\":\"<<dp[i][j][b]<<endl;\n\tstring t(c,'%'),u;\n\tif(i){\n\t  t=string(j,'%');\n\t  string p;\n\t  for(int k=j,y=(int)s[i-1].size();k<c;k++)\n\t    p.push_back(((b>>k)&1?s[i-1][--y]:'$'));\n\t  reverse(p.begin(),p.end());\n\t  t+=p;\n\t}\n\tint y=0;\n\tfor(int k=j-1;k>=0;k--)\n\t  u.push_back(((b>>k)&1?s[i][y++]:'$'));\n\t\n\tif(y<(int)s[i].size()){\n\t  int nb=((b<<1)&mask)+1;\n\t  //cout<<t<<endl<<u<<s[i][y]<<endl;\n\t  int nd=dp[i][j][b]+(t[j]==s[i][y])*2+(u.back()==s[i][y])*2;\n\t  if(j+1<c)\n\t    dp[i][j+1][nb]=max(dp[i][j+1][nb],nd);\n\t  else if(y+1==(int)s[i].size())\n\t    dp[i+1][0][nb]=max(dp[i+1][0][nb],nd);\n\t}\n\t{\n\t  //cout<<t<<endl<<u<<'&'<<endl;\n\t  int nb=(b<<1)&mask;\n\t  int nd=dp[i][j][b];\n\t  if(j+1<c)\n\t    dp[i][j+1][nb]=max(dp[i][j+1][nb],nd);\n\t  else if(y==(int)s[i].size())\n\t    dp[i+1][0][nb]=max(dp[i+1][0][nb],nd);\n\t}\n      }\n    }\n  }\n  int ans=0;\n  for(int b=0;b<(1<<c);b++)\n    ans=max(ans,dp[r][0][b]);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint len[128];\nint dp[2][1<<16];\nchar str[128][17];\nint L[16][1<<16];\nint R[16][1<<16];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str[i]);\n\t\tlen[i]=strlen(str[i]);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tfor(int j=0;j<(1<<b);j++){\n\t\t\tfor(int k=0;k<b;k++)\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tif(k<i)L[i][j]++;\n\t\t\t\t\telse R[i][j]++;\n\t\t\t\t}\n\t\t}\n\t}\n\tint u=0;\n\tint mask=(1<<b)-1;\n\tint inf=99999999;\n\tfor(int i=1;i<(1<<b);i++)dp[u][i]=-inf;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tfor(int k=0;k<(1<<b);k++)dp[!u][k]=-inf;\n\t\t\tfor(int k=0;k<(1<<b);k++){\n\t\t\t\tif(len[i]<L[j][k])continue;\n\t\t\t\tif(len[i]>L[j][k]+b-j)continue;\n\t\t\t\tif(len[i]>L[j][k]){\n\t\t\t\t\tint A=0;\n\t\t\t\t\tif(j&&(k&1)&&(str[i][L[j][k]]==str[i][L[j][k]-1]))A++;\n\t\t\t\t\tif(i&&(k&(1<<b-1))&&(str[i-1][len[i-1]-R[j][k]]==str[i][L[j][k]]))A++;\n\t\t\t\t\tdp[!u][(k*2+1)&mask]=max(dp[!u][(k*2+1)&mask],dp[u][k]+A);\n\t\t\t\t}\n\t\t\t\tif(len[i]<L[j][k]+b-j){\n\t\t\t\t\tdp[!u][(k*2)&mask]=max(dp[!u][(k*2)&mask],dp[u][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu=!u;\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<(1<<b);i++)\n\t\tret=max(ret,dp[u][i]);\n\tprintf(\"%d\\n\",ret*2);\n}\n/*\n   INTERNATIONAL\nC O LLEGIATE\nPROGRAMMING\nC O      NTEST\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),INT_MIN);\n    dp[0][0]=0;\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<(1<<W);k++){\n                if(dp[(i*W+j)&1][k]==INT_MIN)continue;\n                chmax(dp[(i*W+j+1)&1][(k<<1)&((1<<W)-1)],dp[(i*W+j)&1][k]);\n\n                int l=pc[k&((1<<j)-1)];\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(k>>(W-1)&1){\n                        int m=pc[k]-l;\n                        m=S[i].size()-m;\n                        if(S[i][m]==S[i+1][l])po++;\n                    }\n                    chmax(dp[(i*W+j+1)&1][((k<<1)&((1<<W)-1))+1],dp[(i*W+j)&1][k]+po*2);\n                }\n\n                dp[(i*W+j)&1][k]=INT_MIN;\n            }\n        }\n        for(int j=0;j<1<<W;j++)if(pc[j]!=S[i+1].size())dp[(i*W+W)&1][j]=INT_MIN;\n    }\n\n    int ans=INT_MIN;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int MAX_R = 128;\nconst int MAX_C = 16+1;\nconst int BIT = 1<<MAX_C;\n\nint r, c;\nstring s[MAX_R];\nint dp[2][BIT];\n\nint main() {\n  while(1) {\n    if(cin >> r >> c) ; else break;\n    for(int i = 0; i < r; ++i) cin >> s[i];\n\n    int p = 0;\n\n    fill(dp[0], dp[2], -1);\n    for(int k = 0; k < (1<<c); ++k) {\n      if(__builtin_popcount(k) != s[0].size()) continue;\n      string tmp = \"\";\n      for(int i = 0, a = 0; i < c; ++i) {\n        if(k&(1<<i)) tmp += s[0][a++];\n        else tmp += '.';\n      }\n      dp[p][k] = 0;\n      for(int i = 1; i < tmp.size(); ++i) {\n        if(tmp[i] != '.' && tmp[i-1] == tmp[i]) {\n          dp[p][k] += 2;\n        }\n      }\n    }\n\n    for(int i = 1; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        int q = 1-p;\n        for(int k = 0; k < (1<<c); ++k) dp[q][k] = -1;\n        for(int k = 0; k < (1<<c); ++k) {\n          if(dp[p][k] == -1) continue;\n          int Lu = c - j;\n          string u, v;\n          int use;\n          u = v = \"\";\n          for(int t = Lu-1, a = (int)s[i-1].size()-1; t >= 0; --t) {\n            if(k&(1<<t)) u += s[i-1][a--];\n            else u += '.';\n          }\n          reverse(u.begin(), u.end());\n          use = 0;\n          for(int t = Lu; t < c; ++t) {\n            if(k&(1<<t)) v += s[i][use++];\n            else v += '.';\n          }\n\n          if(use + (c-j) < s[i].size()) continue;\n\n          // space\n          {\n            int nk = k/2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k]);\n            }\n          }\n\n          // char\n          if(use < s[i].size()) {\n            int nk = k/2 + (1<<(c-1));\n            int add = 0;\n            add += (s[i][use] == u[0]) * 2;\n            if(v.size()) add += (s[i][use] == *v.rbegin()) * 2;\n            if(j+1 == c && __builtin_popcount(nk) != s[i].size()); else {\n              dp[q][nk] = max(dp[q][nk], dp[p][k] + add);\n            }\n          }\n        }\n        p = q;\n      }\n    }\n\n    int res = 0;\n    for(int k = 0; k < (1<<c); ++k) {\n      res = max(res, dp[p][k]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint R,C,dp[2][(1<<16)],len[130];\nstring s[130];\nint bitcount[(1<<16)];\n\nint main(){\n\n  cin >> R >> C;\n  rep(i,R){\n    cin >> s[i];\n    len[i] = (int)s[i].size();\n  }\n\n  rep(i,(1<<C))bitcount[i] = __builtin_popcount(i);\n  rep(i,(1<<C))dp[0][i] = -1;\n  dp[0][0] = 0;\n\n  int answer = 0;\n  rep(r,R)rep(c,C){\n\n    int phase = ( (c+r*C) & 1 );\n    int next_phase = !phase;\n\n    rep(i,(1<<C))dp[next_phase][i] = -1;\n\n    rep(state,(1<<C)){\n      if( dp[phase][state] == -1 ) continue;\n      int next_state = state & (~(1<<c));\n      int bitmask = (1<<c)-1;\n      int bits_L = bitcount[bitmask&state];//__builtin_popcount(bitmask&state);\n      int bits_R = bitcount[state]-bits_L;//__builtin_popcount(state)-bits_L;\n\n      if( ( r-1 >= 0 && bits_R > len[r-1] ) || ( r-1>=0 && c+bits_R < len[r-1] ) ) continue; \n      if( bits_L > len[r] || ( C-c+bits_L < len[r] ) ) continue;\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n      next_state |= (1<<c);\n      int score = 0;\n      char char_M = s[r][bits_L];\n      if( r-1 >= 0 && bits_R <= len[r-1] && c+bits_R >= len[r-1] ){\n\tif( bits_R > 0 && ((state>>c)&1) ){\n\t  char char_R = s[r-1][len[r-1]-bits_R];\n\t  if( char_M == char_R ) score++;\n\t}\n      }\n\n      if( c-1 >= 0 && bits_L < len[r] && C-c+bits_L >= len[r] ){\n\tif( bits_L > 0 && ((state>>(c-1))&1) ){\n\t  char char_L = s[r][bits_L-1];\n\t  if( char_L == char_M ) score++;\n\t}\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],dp[phase][state]+score);\n      answer = max(answer,dp[next_phase][next_state]);\n\n    }\n  }\n  cout << answer*2 << endl;\n\n  /*\n    rep(r,R)rep(c,C){\n    int phase = ((c+r*C)&1);\n    int next_phase = !phase;\n    rep(i,(1<<C))dp[next_phase][i] = 0;\n    rep(state,(1<<C)){\n      bitset<9> BIT(state);      \n      int bitmask = (1<<c)-1;\n      int bits_L  = __builtin_popcount(state & bitmask);\n      int bits_R  = __builtin_popcount(state) - bits_L;\n      cout << \"(\" << c << \",\" << r  << \") : \" << BIT << endl;\n      cout << \"bits ( \" << bits_L << \",\" << bits_R << \")\" << endl;\n      if( bits_L   > len[r]   ) continue; \n      if( bits_L+C-c < len[r] ) continue;\n      if( c+bits_R < len[r+1] ) continue; \n      cout << \"here\" << endl;\n\n      int next_state = state & (~(1<<c));\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state]);\n      answer = max(answer,dp[next_phase][next_state]);\n\n      next_state |= (1<<c);\n      if( bits_L == len[r] ){\n\tdp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t\t dp[phase][state]);\n\tcontinue;\n      }\n\n      int score = 0;\n      char char_M = s[r][c];\n      if( bits_L > 0 && c-1 > 0 && ((state>>(c-1))&1) ){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n\n      if( bits_R > 0 && r+1 < R && ((state>>c)&1) ){\n\tchar char_B = s[r+1][len[r+1]-bits_R];\n\tif( char_M == char_B ) score++;\n      }\n\n      dp[next_phase][next_state] = max(dp[next_phase][next_state],\n\t\t\t\t       dp[phase][state] + score);\n      cout << \"score = \" << score << endl;\n      BIT = next_state;\n      cout << \"dp[\" << next_phase << \"][\" << BIT << \"] = \" << dp[next_phase][next_state] << endl;\n      answer = max(answer,dp[next_phase][next_state]);\n    }\n  }\n  cout << 2 * answer << endl;\n  */\n\n  /*\n\n  rep(r,R)rep(c,C)rep(state,(1<<C)){\n\n    int bitmask = (1<<c)-1;\n    int bits_L = __builtin_popcount(bitmask&state);\n    int bits_R = __builtin_popcount(state)-bits_L;\n\n    if( bits_L > len[r]   ) continue;\n\n    int next_state = state & ~(1<<c);\n    int next_r = r, next_c = c+1;\n    if( next_c >= C ) next_r++, next_c = 0;\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n    char char_M = s[r][bits_L];\n    int score = 0;\n    if( c-1>=0 && ((state>>(c-1))&1) ){\n      if(bits_L-1>=0){\n\tchar char_L = s[r][bits_L-1];\n\tif( char_M == char_L ) score++;\n      }\n    }\n\n    if( (state>>c)&1 && r+1 < R){\n      char char_B = s[r+1][len[r+1]-bits_R];\n      if( char_M == char_B ) score++;\n    }\n\n    next_state |= (1<<c);\n    dp[next_r][next_c][next_state] = max(dp[next_r][next_c][next_state],dp[r][c][state]+score);\n    answer = max(answer,dp[next_r][next_c][next_state]);\n\n  }\n\n  cout << 2*answer << endl;\n\n  */\n\n  /*\n  REP(r,1,R){\n    rep(c,C){\n      rep(state,(1<<C)){\n\tint bitmask = (1<<(c+1))-1;\n\tint bits_R = __builtin_popcount(bitmask&state);\n\tint bits_L = __builtin_popcount(state)-bits_R;\n\n\tif( bits_R > len[r-1] ) continue;\n\tif( bits_L > len[r] ) continue;\n\n\tint next_state = state & ~(1<<c);\n\tint prer = ((c-1>=0)?r  :r-1);\n\tint prec = ((c-1>=0)?c-1:C-1);\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]);\n\tanswer = max(answer,dp[r][c][next_state]);\n\n\tif( bits_L+1 > len[r] ) continue;\n\n\tnext_state |= (1<<c);\n\tchar char_M = s[r][len[r]-bits_L-1];\n\tint score = 1;\n\tif( (state>>c) & 1 ){\n\t  char char_T = s[r-1][bits_R];\n\t  if( char_M == char_T ) score++;\n\t}\n\n\tif( ( (state>>(c+1)) & 1 ) ) {\n\t  char char_L = s[r][len[r]-bits_L];\n\t  if( char_M == char_L )score++;\n\t}\n\tif( score == 1 ) continue;\n\tdp[r][c][next_state] = max(dp[r][c][next_state],dp[prer][prec][state]+score);\n\tanswer = max(answer,dp[r][c][next_state]);\n      }\n    }\n  }\n\n  cout << answer << endl;\n  */\n\n  return 0;\n}\n\n/*\n21:27 -  22:26 give up \nthe following code is too slow!\n\n\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nint dx[] = {0,-1};\nint dy[] = {-1,0};\nstring G[130];\nint dp[130][(1<<17)];\nstring line[2];\n\nint main(){\n  int H,W;\n  cin >> H >> W;\n  vector<int> loop[H];\n  rep(i,H){\n    cin >> G[i];\n    int remain = W - (int)G[i].size();\n    //cout << i << \" => \" << remain << endl;\n    rep(j,(1<<W)){\n      if(__builtin_popcount(j) == remain)loop[i].push_back(j);\n    } \n  }\n\n  vector<string> pre[H];\n  rep(i,H){\n    sort(loop[i].begin(),loop[i].end());\n    loop[i].erase(unique(loop[i].begin(),loop[i].end()),loop[i].end());\n    cout << loop[i].size() << endl;\n    assert((int)loop[i].size() < (1<<W));\n    rep(j,loop[i].size()){\n      int state = loop[i][j],idx = 0;\n      string line = \"\";\n      rep(j,W){\n\tif((state>>j) & 1)line += \" \";\n\telse              line += G[i][idx++];\n      }\n      pre[i].push_back(line);\n    }\n  }\n  //cout << \"-----------\" << endl;\n  int ans = 0;\n  rep(y,H){\n    rep(i,loop[y].size()){\n      int state = loop[y][i];\n      line[1] = pre[y][i];\n      rep(j,((y-1>=0)?loop[y-1].size():1) ){\n\tint pstate = ((y-1>=0)?loop[y-1][j]:0);\n\tline[0] = ((y-1>=0)?pre[y-1][j]:string(W,' '));\n\tint point = 0;\n\trep(k,W){\n\t  int X = k, Y = 1;\n\t  rep(l,2){\n\t    int nx = X + dx[l], ny = Y + dy[l];\n\t    if(!( 0 <= nx && nx < W && 0 <= ny && ny < H ))continue;\n\t    if(line[Y][X] != ' ' && line[Y][X] == line[ny][nx]) point++;\n\t  }\n\t}\n\tdp[y][state] = max(dp[y][state],((y-1>=0)?dp[y-1][pstate]:0)+point);\n\tans = max(ans,dp[y][state]);\n      } \n    }\n  }\n  cout << ans * 2 << endl;\n  return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\nint R,C;\nstring ss[201];\nint dp[2][1<<16][20];\nconst int INF=1<<30;\nint bitPos[1<<16][17];\nint bitCnt[1<<16][17];\nint main(){\n  for(int mask=0;mask<(1<<16);mask++){\n    int a=0;\n    for(int i=0;i<16;i++){\n      if(((mask>>i)&1))bitPos[mask][i]=a++;\n      else bitPos[mask][i]=-1;\n      bitCnt[mask][i+1]=bitCnt[mask][i]+((mask>>i)&1);\n    }\n  }\n  cin>>R>>C;\n  for(int i=0;i<R;i++)cin>>ss[i];\n  for(int i=R*C;i>=0;i--){\n    int cur=i%2;\n    int nxt=cur^1;\n    const int cy=i/C;\n    const int cx=i%C;\n    for(int mask=0;mask<(1<<C);mask++){\n      for(int k=0;k<16;k++){\n\tint res=-INF;\n\tif(i==R*C)res=0;\n\telse{\n\t  const int cnt=k;\n\t  const int ct=bitCnt[mask][cx];\n\t  if(ct<(int)ss[cy].size()){\n\t    int nmask=mask|(1<<cx);\n\t    int add=0;\n\t    if(cx-1>=0&&bitPos[mask][cx-1]!=-1\n\t       &&bitPos[mask][cx-1]<(int)ss[cy].size()\n\t       &&bitPos[mask][cx-1]+1<(int)ss[cy].size()\n\t       &&ss[cy][bitPos[mask][cx-1]]==ss[cy][bitPos[mask][cx-1]+1]){\n\t      add+=2;\n\t    }\n\t    if(cy-1>=0&&bitPos[mask][cx]!=-1\n\t       &&cnt<(int)ss[cy-1].size()\n\t       &&bitCnt[mask][cx]<(int)ss[cy].size()\n\t       &&ss[cy-1][cnt]==ss[cy][bitCnt[mask][cx]]){\n\t      add+=2;\n\t    }\n\t    if(cx!=C-1||ct+1==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]+add);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]+add);\n\t    }\n\t  }\n\t  {\n\t    int nmask=mask&~(1<<cx);\n\t    if(cx!=C-1||ct==(int)ss[cy].size()){\n\t      if(cx==C-1)res=max(res,dp[nxt][nmask][0]);\n\t      else res=max(res,dp[nxt][nmask][k+((mask>>cx)&1)]);\n\t    }\n\t  }\n\t}\n\tdp[cur][mask][k]=res;\n      }\n    }\n  }\n  cout<<dp[0][0][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<string> mat;\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nint r,c,ans;\n\nbool f;\n\nint check(int y, int x, mat str){\n  int res = 0;\n  if(str[y][x] == ' ') return 0;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= str.size()) continue;\n    if(nx < 0 || nx >= str[y].size()) continue;\n    if(str[ny].size() < nx) continue;\n    if(str[ny][nx] == str[y][x]) res++;\n  }\n  return res;\n}\n\nvoid calc(mat str){\n  int res = 0;\n\n  for(int i=0;i<str.size();i++)\n    for(int j=0;j<str[i].size();j++)\n      res += check(i, j, str);\n\n  ans = max(ans,res);\n  /*\n  if(res == 18){\n    for(int i=0;i<str.size();i++){\n      cout << str[i] << endl;\n    }\n    cout << endl;\n    for(int i=0;i<str.size();i++){\n      for(int j=0;j<str[i].size();j++) cout << check(i,j,str);\n        cout << endl;\n    }\n    cout << endl;\n    }*/\n}\n\nvoid func(int y, int x, mat str){\n  if(x == c){\n    x = 0;\n    y++;\n  }\n  if(y == r){\n    calc(str);\n    return;\n  }\n\n  if(str[y].size() < c && x < str[y].size()){\n    func(y, x+1, str);\n    if(str[y][x] != ' '){\n      if(y > 0){\n        for(int i=x+1;i<str[y-1].size();i++){\n          if(str[y].size() + i - x > c) break;\n          if(str[y][x] == str[y-1][i]){\n            str[y].insert(str[y].begin()+x, i-x, ' ');\n            func(y, x+(i-x)+1, str);\n            break;\n          }\n        }\n        for(int j=x+1;j<str[y].size();j++){\n          if(str[y][j] == ' ' || str[y][j-1] != str[y][j]) break;\n          for(int i=j+1;i<str[y-1].size();i++){\n            if(str[y].size() + i - j > c) break;\n            if(str[y][j] == str[y-1][i]){\n              str[y].insert(str[y].begin()+x, i-j, ' ');\n              func(y, x+(i-j)+1, str);\n              break;\n            }\n          }\n        }\n      } else {\n        str[y].insert(str[y].begin()+x, ' ');\n        func(y, x+1, str);\n      }\n    }\n  } else {\n    func(y+1, 0, str);\n  }\n}\n\nint main(){\n  while(cin >> r >> c){\n    mat v;\n    for(int i=0;i<r;i++){\n      string str;\n      cin >> str;\n      v.push_back(str);\n    }\n    ans = 0;\n    func(0,0,v);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint pc(int b){\n  return __builtin_popcount(b);\n}\n\nint main(){\n  int R,C;\n  cin>>R>>C;\n  string s[128];\n  for(int i=0;i<R;i++){\n    cin>>s[i];\n  }\n  int dp[1<<16];\n  fill(begin(dp),end(dp),-1e9);\n  dp[0]=0;\n  for(int i=0;i<R;i++){\n    for(int j=0;j<C;j++){\n      int ndp[1<<16];\n      fill(begin(ndp),end(ndp),-1e9);\n      for(int k=0;k<1<<C;k++){\n\tif(dp[k]>=0){\n\t  ndp[(k<<1)%(1<<C)]=max(ndp[(k<<1)%(1<<C)],dp[k]);\n\t  int nc=pc(k%(1<<j));\n\t  if(nc<s[i].size()){\n\t    ndp[(k*2+1)%(1<<C)]=max(ndp[(k*2+1)%(1<<C)],dp[k]\n\t\t\t\t+(i&&k>>C-1&1&&s[i-1][s[i-1].size()-pc(k>>j)]==s[i][nc])\n\t\t\t\t+(C>1&&k%2&&nc&&s[i][nc-1]==s[i][nc])\n\t\t\t\t);\n\t  }\n\t}\n      }\n      copy(begin(ndp),end(ndp),begin(dp));\n    }\n    for(int j=0;j<1<<C;j++){\n      if(pc(j)<s[i].size()){\n\tdp[j]=-1e9;\n      }\n    }\n  }\n  cout<<2**max_element(begin(dp),end(dp))<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define R 128\n#define C 16\n\nint r, c;\nstring ss[R];\n\nint dp[2][1 << C];\nint bc[1 << C], mask[C+1];\n\nint solve() {\n  string &s1 = ss[0];\n  int l1 = s1.size();\n  repl(j, 1, c-1) {\n    int b0 = 1 << (j-1);\n    int b1 = 1 << j;\n    rep(state, (1 << j)) {\n      int lc = bc[state];\n      if(l1-lc < c-j) {\n        dp[1][state] = max(dp[1][state], dp[0][state]);\n      }\n      if(lc < l1) {\n        int n_state = state | b1;\n        if((state & b0) && (s1[lc-1] == s1[lc])) {\n          dp[1][n_state] = max(dp[1][n_state], dp[0][state] + 2);\n        } else {\n          dp[1][n_state] = max(dp[1][n_state], dp[0][state]);\n        }\n      }\n    }\n    rep(k, (1 << (j+1))) dp[0][k] = dp[1][k], dp[1][k] = 0;\n  }\n  repl(i, 1, r-1) {\n    string &s0 = ss[i-1], &s1 = ss[i];\n    int l0 = s0.size(), l1 = s1.size();\n    rep(j, c) {\n      int b0 = (j > 0 ? 1 << (j-1) : 0);\n      int b1 = (1 << j);\n      int k = i*c + j;\n      rep(state, (1 << c)) {\n        int lc = bc[state & mask[j]], rc = bc[state] - lc;\n        if(l1-lc < 0 || c-j < l1-lc) continue;\n        if(l0-rc < 0 || j < l0-rc) continue;\n\n        int n_state = (state & b1) ? (state ^ b1) : state;\n        if(l1-lc < c-j) {\n          dp[1][n_state] = max(dp[1][n_state], dp[0][state]);\n        }\n        if(lc < l1) {\n          int x = 0;\n          n_state |= b1;\n          if((state & b0) && s1[lc-1] == s1[lc]) x += 2;\n          if((state & b1) && s0[l0-rc] == s1[lc]) x += 2;\n          dp[1][n_state] = max(dp[1][n_state], dp[0][state] + x);\n        }\n      }\n      rep(k, (1 << c)) dp[0][k] = dp[1][k], dp[1][k] = 0;\n    }\n  }\n  int ans = 0;\n  rep(i, (1 << c)) {\n    ans = max(ans, dp[0][i]);\n  }\n  return ans;\n}\n\nint main() {\n  cin >> r >> c;\n  repl(i, 1, (1 << c)-1) bc[i] = bc[i ^ (i & -i)] + 1;\n  rep(i, c) mask[i+1] = mask[i] | (1 << i);\n\n  rep(i, r) cin >> ss[i];\n  cout << solve() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),INT_MIN);\n    dp[0][0]=0;\n    int mask=(1<<W)-1;\n    for(int t=0;t<H*W;t++){\n            const int i=t/W,j=t%W,p=t&1,q=(t+1)&1;\n\n            for(int k=0;k<(1<<W);k++){\n                if(dp[p][k]==INT_MIN)continue;\n                chmax(dp[q][(k<<1)&mask],dp[p][k]);\n\n                int l=pc[k&((1<<j)-1)];\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(k>>(W-1)&1){\n                        int m=S[i].size()-pc[k]+l;\n                        if(S[i][m]==S[i+1][l])po++;\n                    }\n                    chmax(dp[q][((k<<1)&mask)+1],dp[p][k]+po*2);\n                }\n                dp[p][k]=INT_MIN;\n            }\n\n        if(j==W-1)for(int k=0;k<1<<W;k++)if(pc[k]!=S[i+1].size())dp[q][k]=INT_MIN;\n    }\n\n    int ans=INT_MIN;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nstring S[222];\n\nint dp[2][1<<16];\nint pc[1<<16];\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    for(int i=0;i<1<<16;i++)pc[i]=__builtin_popcount(i);\n    cin>>H>>W;\n    S[0]=\"\";\n    rep(i,H)cin>>S[i+1];\n\n    fill_n(*dp,2*(1<<16),INT_MIN);\n    dp[0][0]=0;\n    int mask=(1<<W)-1;\n    for(int t=0;t<H*W;t++){\n            int i=t/W;\n            int j=t%W;\n            for(int k=0;k<(1<<W);k++){\n                if(dp[t&1][k]==INT_MIN)continue;\n                chmax(dp[(t+1)&1][(k<<1)&mask],dp[t&1][k]);\n\n                int l=pc[k&((1<<j)-1)];\n                if(l<S[i+1].size()){\n                    int po=0;\n                    if(j&&(k&1)&&S[i+1][l]==S[i+1][l-1])po++;\n                    if(k>>(W-1)&1){\n                        int m=S[i].size()-pc[k]+l;\n                        if(S[i][m]==S[i+1][l])po++;\n                    }\n                    chmax(dp[(t+1)&1][((k<<1)&mask)+1],dp[t&1][k]+po*2);\n                }\n                dp[t&1][k]=INT_MIN;\n            }\n\n        if(j==W-1)for(int k=0;k<1<<W;k++)if(pc[k]!=S[i+1].size())dp[(t+1)&1][k]=INT_MIN;\n    }\n\n    int ans=INT_MIN;\n    rep(i,1<<W)chmax(ans,dp[(H*W)&1][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \nusing namespace std;\n  \nint main()\n{\n  int R, C;\n  string S[128];\n  int hash[1 << 16];\n  for(int i = 0; i < 1 << 16; i++) hash[i] = __builtin_popcount(i);\n  \n  cin >> R >> C;\n  for(int i = 0; i < R; i++) cin >> S[i];\n  \n  vector< int > latte(1 << C, -1);\n  latte[0] = 0;\n  const int mask = (1 << C) - 1;\n  for(int y = 0; y < R; y++) {\n    for(int x = 0; x < C; x++) {\n      vector< int > malta(1 << C, -1);\n      for(int j = 0; j < 1 << C; j++) {\n        if(latte[j] == -1) continue;\n  \n        auto ch = [&](int &a, int b)\n        {\n          a = max(a, b);\n        };\n  \n        const int beet = hash[j & ((1 << x) - 1)];\n        if(beet + C - x > S[y].size()) ch(malta[j & ~(1 << x)], latte[j]);\n        if(beet < S[y].size()) {\n          int point = 0;\n          if(x && (j >> (x - 1)) & 1) {\n            if(beet && S[y][beet] == S[y][beet - 1]) ++point;\n          }\n          if(y && (j >> x) & 1) {\n            int pos = (int) S[y - 1].size() - hash[j >> x];\n            if(pos >= 0 && S[y - 1][pos] == S[y][beet]) ++point;\n          }\n          ch(malta[j | (1 << x)], latte[j] + point);\n        }\n      }\n      latte = move(malta);\n    }\n  }\n  cout << *max_element(begin(latte), end(latte)) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W,dp[2][1<<16],I;\nstring s[16];\nbool B(int x,int i){return (x>>i)&1;}\nint bc(int x){return x==0?0:__builtin_popcount(x);}\nint main(){\n\tcin>>H>>W;\n\trep(i,H) cin>>s[i];\n\trep(b,1<<W) dp[0][b]=-1;\n\tdp[0][0]=0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\trep(b,1<<W) dp[1-I][b]=-1;\n\t\t\trep(b,1<<W){\n\t\t\t\tif(dp[I][b]<0) continue;\n\t\t\t\t//put\n\t\t\t\tint x=bc(b&((1<<j)-1));\n\t\t\t\tif(x<s[i].size()){\n\t\t\t\t\tint pl=0;\n\t\t\t\t\tif(i>0&&B(b,j)&&s[i-1][s[i-1].size()+x-bc(b)]==s[i][x]) pl+=2;//tate\n\t\t\t\t\tif(j>0&&B(b,j-1)&&s[i][x]==s[i][x-1]) pl+=2;//yoko\n\t\t\t\t\tchmax(dp[1-I][b|(1<<j)],dp[I][b]+pl);\n\t\t\t\t}\n\t\t\t\t//dont put\n\t\t\t\tchmax(dp[1-I][b&(~(1<<j))],dp[I][b]);\n\t\t\t}\n\t\t\tI=1-I;\n\t\t}\n\t\trep(b,1<<W) if(bc(b)!=s[i].size()) dp[I][b]=0;\n\t}\n\tint ans=0;\n\trep(i,1<<W) chmax(ans,dp[I][i]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[2][16][1<<16];\nint c[16][1<<16][2];\n\nint Max(int &a,int b){return a=max(a,b);}\n\nint main(){\n\n  int h,w;\n  string s[128];\n\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>s[i];\n  for(int i=0;i<w;i++)\n    for(int j=0;j<1<<w;j++){\n      int cnt=0;\n\n      for(int k=0;k<i;k++)\n\tcnt+=bool(j&(1<<k));\n      \n      c[i][j][0]=cnt;\n      c[i][j][1]=__builtin_popcount(j)-cnt;\n    }\n\n\n  for(int i=0;i<h;i++){\n    \n    for(int j=0;j<w;j++)\n      for(int k=0;k<1<<w;k++){\n\t\n\tif( i && j!=0 )dp[i%2][j][k]=0;\n\tdp[(i+1)%2][j][k]=0;\n\t\n      }\n\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<w);k++){\n\tint cs=0;\n\t\n\tint idx = c[j][k][0],o=c[j][k][1];\n\n\tif(i && idx <(int)s[i].size() && o && 0 <= (int)s[i-1].size() - o && s[i][idx] == s[i-1][(int)s[i-1].size()-o]) cs+=2;\n\n\n\tif(j && idx && idx < (int)s[i].size() && (k & 1<<(j-1) ) && s[i][idx -1] == s[i][idx]) cs+=2;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() -1){\n\t  Max(dp[(i+(j==w-1))%2][(j+1)%w][k|1<<j],dp[i%2][j][k]+cs);\n\n\t}\n\tint nk=k;\n\tif(k&1<<j) nk^=1<<j;\n\t\n\tif( j!=w-1 || idx == (int)s[i].size() ) Max(dp[(i+(j==w-1))%2][(j+1)%w][nk],dp[i%2][j][k]);\n\t\n      }\n  }\n\n  int ans=0;\n\n  for(int i=0;i<1<<w;i++)\n    if(s[h-1].size()==c[0][i][1])ans=max(ans,dp[h%2][0][i]);\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF=1e9;\nint R,C;\n \nchar s[128][20];\nint len[128];\nint dp[2][(1<<16)];\n \nint main(){\n  scanf(\"%d %d\",&R,&C);\n  for(int i=0;i<R;i++){\n    scanf(\"%s\",s[i]);\n    len[i]=strlen(s[i]);\n  }\n   \n \n  fill( (int*)dp[0], (int*)dp[2], -INF);\n  dp[0][0]=0;\n \n  int ai=1,bi=0;\n  int ans=0;\n  for(int i=0;i<=R;i++){\n \n     \n    for(int j=0;j<C;j++){\n \n      swap(ai,bi);\n\n      for(int bit=0;bit<(1<<C);bit++)dp[bi][bit]=-INF;\n      \n      for(int bit=0;bit<(1<<C);bit++){\n        if(dp[ai][bit]==-INF)continue;\n \n        if(i>0 && j==0 && __builtin_popcount(bit) != len[i-1])continue;\n        if(i==R&&j==0)ans=max(ans,dp[ai][bit]);\n         \n        if(i==R)continue;\n        int a=0,b=0,cost=dp[ai][bit];\n        for(int k=0;k<C-j;k++)a+=(bit>>k&1);\n        for(int k=C-j;k<C;k++)b+=(bit>>k&1);\n         \n        int nbit=bit>>1;\n        dp[bi][nbit]=max(dp[bi][nbit],cost);\n         \n \n        if(b==len[i])continue;\n         \n        int flg=0;\n        if(bit&1 && s[i][b]==s[i-1][len[i-1]-a])flg++;\n        if(bit>>(C-1)&1)\n          if(b>0&&s[i][b-1]==s[i][b])flg++;\n         \n        nbit=(bit|(1<<C))>>1;\n        dp[bi][nbit]=max(dp[bi][nbit],cost+flg);\n   \n      }\n    }\n  }\n  cout<<ans*2<<endl;\n       \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    vector<string> s(R);\n    for(int i = 0; i < R; ++i) {\n        cin >> s[i];\n    }\n    vector<int> bitcount(1 << C);\n    for(int i = 0; i < 1 << C; ++i) {\n        bitcount[i] = __builtin_popcount(i);\n    }\n\n    vector<int> dp(1 << C, -1);\n    dp[0] = 0;\n    for(int i = 0; i < R; ++i) {\n        for(int j = 0; j < C; ++j) {\n            vector<int> nxt(1 << C, -1);\n            for(int S = 0; S < (1 << C); ++S) {\n                if(dp[S] == -1) {\n                    continue;\n                }\n                int idx = bitcount[S & (1 << j) - 1];\n                if(idx < s[i].size()) {\n                    int t = dp[S];\n                    if(idx > 0 && (S & 1 << (j - 1)) && s[i][idx - 1] == s[i][idx]) {\n                        t++;\n                    }\n                    if(i > 0 && (S & 1 << j) && s[i][idx] == s[i - 1][s[i - 1].size() - bitcount[S >> j]]) {\n                        t++;\n                    }\n                    nxt[S | 1 << j] = max(nxt[S | 1 << j], t);\n                }\n                if(C - j > s[i].size() - idx) {\n                    nxt[S & ~(1 << j)] = max(nxt[S & ~(1 << j)], dp[S]);\n                }\n            }\n            dp.swap(nxt);\n        }\n    }\n    cout << 2 * *max_element(begin(dp), end(dp)) << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nint dp[2][18][65600];\nbool bit[65600][18];\nchar s[130][18];\nint m, n, maxbt, len[130];\nint top[65600][18], btm[65600][18];\n\nvoid intit()\n{\n    int i, j, p;\n    for( i = 0; i <= maxbt; i ++ ){\n        int tmp = i;\n        for( j = 0; j < m; j ++ ){\n            bit[i][j] = tmp%2;\n            tmp /= 2;\n        }\n        for( j = 1, top[i][0] = 0; j <= m; j ++ ){\n            if( bit[i][j-1] == 1 ){\n                top[i][j] = top[i][j-1]+1;\n            }\n            else top[i][j] = top[i][j-1];\n        }\n        for( j = m-1, btm[i][0] = 0, p = 1; j >= 0; j --, p ++ ){\n            if( bit[i][j] == 1 ){\n                btm[i][p] = btm[i][p-1]+1;\n            }\n            else btm[i][p] = btm[i][p-1];\n        }\n    }\n}\n\nint caltop( int y, int st )\n{\n    return top[st][y];\n}\n\nint calbtm( int y, int st )\n{\n    return btm[st][y];\n}\n\nint lf( int x, int y, int st )\n{\n    if( y == 0 ) return 0;\n    if( bit[st][0] == 0 )return 0;\n    int tmp = caltop(y, st);\n    if( tmp == 0 )return 0;\n    if( s[x][tmp] == s[x][tmp-1] )return 1;\n    else return 0;\n}\n\nint up( int x, int y, int st )\n{\n    int tmp = calbtm( m-y, st );\n    int tmp1 = caltop( y, st );\n    if( x == 0 ) return 0;\n    if( bit[st][m-1] == 0 ) return 0;\n    if( s[x][tmp1] == s[x-1][len[x-1]-tmp] )return 1;\n    else return 0;\n}\n\n\nint main()\n{\n    int i, j, p, tmp, k;\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    while(~scanf(\"%d%d\", &n, &m)){\n        maxbt = (1<<m) - 1;\n        intit();\n        for( i = 1; i <= n; i ++ ){\n            scanf(\"%s\", s[i]);\n            len[i] = strlen(s[i]);\n        }\n        for( i = 0; i <= 17; i ++ )\n            for( j = 0; j <= 65536; j ++ )\n            dp[0][i][j] = dp[1][i][j] = -999999999;\n        dp[1][0][0] = 0; dp[1][0][1] = 0;//第一行第一个放或者不放都是0\n        for( i = 1; i <= n; i ++ ){\n            p = i%2;\n            for( j = 0; j < m; j ++ ){\n                for( k = 0; k <= maxbt; k ++ ){\n                    if( i == 1 && j == 0 )continue;\n                    tmp = (k<<1)&maxbt;\n                    if( i == 1 ){\n                        if( caltop( j, k ) > len[i] ) continue;\n                        dp[p][j][tmp] = max(dp[p][j][tmp], dp[p][j-1][k]);// not draw\n                        if( caltop( j, k ) != len[i] )\n                        dp[p][j][tmp|1] = max(dp[p][j][tmp|1], dp[p][j-1][k]+2*lf(i,j,k) ); //draw;\n                    }\n                    else if( j == 0 ){\n                        if( caltop( m, k ) != len[i-1] ) continue;\n                        dp[p][j][tmp] = max( dp[p][j][tmp], dp[p^1][m-1][k] );\n                        dp[p][j][tmp|1] = max( dp[p][j][tmp|1], dp[p^1][m-1][k]+2*up(i,j,k) );\n                    }\n                    else{\n                        if( caltop( j, k ) > len[i] ) continue;\n                        if( calbtm( m-j, k ) > len[i-1] ) continue;\n                        dp[p][j][tmp] = max(dp[p][j][tmp], dp[p][j-1][k]);// not draw\n                        if( caltop( j, k ) != len[i] ){\n                            dp[p][j][tmp|1] = max(dp[p][j][tmp|1], dp[p][j-1][k]+2*lf(i,j,k)+2*up(i,j,k) ); //draw;\n                        }\n                    }\n                }\n//                for( int q = 0; q <= maxbt; q ++ ){\n//                    printf(\"%d dp[%d][%d][%d] = %d\\n \", i, p, j, q, dp[p][j][q] );\n//                }\n//                printf(\"\\n\");\n            }\n        }\n        //printf(\"%d\\n\", dp[0][2][8163]) ;\n        int max1 = 0;\n        for( i = 0; i < m; i ++ )\n            for( j = 0; j <= maxbt; j ++ ){\n            if( caltop( m, j ) == len[n] )\n                max1 = max( max1, dp[n%2][i][j] );\n            }\n        printf(\"%d\\n\", max1);\n    }\n}\n//  http://www.mamicode.com/info-detail-1066123.html\n//  http://async.icpc-camp.org/d/124-jag-summer-2012-day-4-c-connect"
  },
  {
    "language": "C",
    "code": "// AOJ 2449: Connect\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\nchar s[129][20]; int w[129];\nint dp[2][65536], bc[65536];\n\nint bitcount16(int x)\n{\n\tx = ((x & 0xAAAAAA) >>  1) + (x & 0x555555);\n\tx = ((x & 0xCCCCCC) >>  2) + (x & 0x333333);\n\tx = ((x & 0xF0F0F0) >>  4) + (x & 0x0F0F0F);\n\tx = ((x & 0x00FF00) >>  8) + (x & 0xFF00FF);\n\treturn x;\n}\n\nint main()\n{\n\tint R, C, r, c, i, k, k1, k2, lim, p, q, x, ans;\n\tchar buf[10], *t;\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &R, &C);\n\tfor (r = 0; r < R; r++) {\n\t\tfgets(t=s[r], 20, stdin);\n\t\twhile (*t > ' ') t++;\n\t\tw[r] = t - s[r];\n\t}\n\tlim = 1 << C;\n\tfor (i = 0; i < lim; i++) bc[i] = bitcount16(i);\n\t\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0] = 0;\n\t\n\tk1 = 0, k2 = 1;\n\tfor (r = 0; r < R; r++) for (c = 0; c < C; c++) {\n\t\tmemset(dp[k2], -1, sizeof(dp[k2]));\n\t\tfor (k = 0; k < lim; k++) if (dp[k1][k] >= 0) {\n\t\t\tp = bc[k & (1 << c) - 1];\n\t\t\tif (p < w[r]) {\n\t\t\t\tq = dp[k1][k];\n\t\t\t\tif (c && (k & (1 << (c-1))) && s[r][p-1] == s[r][p]) q++;\n\t\t\t\tif (r && (k & (1 << c))     && s[r][p  ] == s[r-1][w[r-1] - bc[k>>c]]) q++;\n\t\t\t\tx = k | (1 << c);\n\t\t\t\tif (q > dp[k2][x]) dp[k2][x] = q;\n\t\t\t}\n\t\t\tif (p + C - c > w[r]) {\n\t\t\t\tx = k & ~(1 << c);\n\t\t\t\tif (dp[k1][k] > dp[k2][x]) dp[k2][x] = dp[k1][k];\n\t\t\t}\n\t\t}\n\t\tk1 = k2, k2 = !k2;\n\t}\n\n\tans = 0;\n\tfor (c = 0; c < lim; c++) if (dp[k1][c] > ans) ans = dp[k1][c];\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\nimport core.bitop;\n\nconst INF = 1 << 28;\n\nint R, C;\nstring[] F;\n\nvoid input() {\n    scanf(\"%d %d\\n\", &R, &C);\n    F = new string[R];\n    foreach (i; 0 .. R) {\n        F[i] = readln.chomp;\n    }\n}\n\nint calc() {\n    auto dp = new int[][](2, 1 << C);\n    foreach (i; 0 .. 2) dp[i][] = -INF;\n    int p = 0, q = 1;\n    dp[p][0] = 0;\n    foreach (y; 0 .. R) {\n        foreach (x; 0 .. C) {\n            dp[q][] = -INF;\n            for (int bit = 0; bit < (1 << C); bit++) {\n                if (dp[p][bit] < 0) continue;\n                int l = (bit & ((1 << x) - 1)).popcnt,\n                    r = (bit & ~((1 << x) - 1)).popcnt;\n\n                int f() {\n                    int ret = 0;\n                    if (x >= 1 && l >= 1 && (bit & (1 << (x - 1))) && F[y][l - 1] == F[y][l]) ret++;\n                    if (y >= 1 && r >= 1 && (bit & (1 << x)) && F[y - 1][$ - r] == F[y][l]) ret++;\n                    return ret;\n                }\n\n                if (l + 1 <= F[y].length) {\n                    int nbit = bit | 1 << x;\n                    dp[q][nbit] = max(dp[q][nbit], dp[p][bit] + f());\n                }\n                if (C - x - 1 >= F[y].length - l) {\n                    int nbit = bit & ~(1 << x);\n                    dp[q][nbit] = max(dp[q][nbit], dp[p][bit]);\n                }\n            }\n            p = !p; q = !q;\n            //writeln(dp[p].reduce!max);\n        }\n    }\n    return dp[p].reduce!max;\n}\n\nvoid solve() {\n    writeln(calc * 2);\n}\n\nvoid main() {\n    input; solve;\n}"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef gen(N, K):\n    if K == 0:\n        yield 0\n        return\n    v = (1 << K) - 1\n    N2 = (1 << N)\n    while v < N2:\n        yield v\n        x = v & -v; y = v + x\n        v = ((v & ~y) // x >> 1) | y\n\ndef solve():\n    R, C = map(int, readline().split())\n    S = [readline().strip() for i in range(R)]\n    C2 = (1 << C)\n    bc = [0]*C2\n    for state in range(1, C2):\n        bc[state] = bc[state ^ (state & -state)] + 1\n\n    LI = [None]*(C+1)\n    RI = [None]*(C+1)\n    for sl in range(C+1):\n        r0 = [None]*(C+1)\n        r1 = [None]*(C+1)\n        for j in range(C+1):\n            sr = sl - (C-j)\n            e0 = []\n            for k in range(max(sr, 0), min(sl, C)+1):\n                e0.extend(gen(j, k))\n            r0[j] = e0\n            r1[j] = [state << (C-j) for state in e0]\n        LI[sl] = r0\n        RI[sl] = r1\n\n    dp0 = [0]*C2; dp1 = [0]*C2\n    zeros = [0]*C2\n    s = S[0]; sl = len(s)\n    for j in range(1, C):\n        dp1[:] = zeros\n        b0 = (1 << (j-1))\n        b1 = (1 << j)\n        for state in LI[sl][j]:\n            ll = bc[state]\n            dp1[state] = dp0[state]\n            if ll < sl:\n                if state & b0 and s[ll-1] == s[ll]:\n                    dp1[state | b1] = dp0[state] + 2\n                else:\n                    dp1[state | b1] = dp0[state]\n        dp0, dp1 = dp1, dp0\n    for i in range(1, R):\n        p = S[i-1]; pl = len(p)\n        s = S[i]; sl = len(s)\n        for j in range(C):\n            dp1[:] = zeros\n            b0 = (1 << (j-1)) if j else 0\n            b1 = (1 << j)\n            L0 = LI[sl][j]; R0 = RI[pl][C-j-1]\n            for state1 in L0:\n                ll = bc[state1]\n                if ll < sl:\n                    c = s[ll]\n                    for state2 in R0:\n                        rl = bc[state2]\n                        state = state1 | state2\n                        n_state = state | b1\n\n                        if j < C-1:\n                            dp1[state] = max(dp0[state], dp0[n_state]) if rl < pl else dp0[state]\n                        r1 = max(dp0[state], (dp0[n_state] + 2 if (p[-rl-1] == c) else dp0[n_state])) if rl < pl else dp0[state]\n                        if state & b0 and s[ll-1] == c:\n                            dp1[n_state] = r1 + 2\n                        else:\n                            dp1[n_state] = r1\n                else:\n                    for state2 in R0:\n                        state = state1 | state2\n                        if bc[state2] < pl:\n                            dp1[state] = max(dp0[state], dp0[state | b1])\n                        else:\n                            dp1[state] = dp0[state]\n            dp0, dp1 = dp1, dp0\n    write(\"%d\\n\" % max(dp0))\nsolve()\n"
  }
]