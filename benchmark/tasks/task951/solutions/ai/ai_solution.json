[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long dp[101][101];\n\nint solve(int N, int A, int B, int C, int D) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n\n    for (int people = 1; people <= N; people++) {\n        for (int groups = 1; groups <= people; groups++) {\n            for (int groupSize = A; groupSize <= B; groupSize++) {\n                if (people >= groupSize) {\n                    long long ways = 0;\n                    for (int k = C; k <= D; k++) {\n                        if (groups + k - 1 <= groups) {\n                            ways = (ways + dp[people - groupSize][groups - 1]) % MOD;\n                        }\n                    }\n                    dp[people][groups] = (dp[people][groups] + ways) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[N][N];\n}\n\nint main() {\n    int N, A, B, C, D;\n    scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n    printf(\"%d\\n\", solve(N, A, B, C, D));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 1000\n#define MAXM 1000\n\nlong long dp[MAXN + 1][MAXM + 1];\nlong long fact[MAXN + 1];\nlong long inv_fact[MAXN + 1];\n\nlong long power(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid precompute_factorials() {\n    fact[0] = 1;\n    for (int i = 1; i <= MAXN; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    inv_fact[MAXN] = power(fact[MAXN], MOD - 2);\n    for (int i = MAXN - 1; i >= 0; i--) {\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    int N, A, B, C, D;\n    scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n\n    precompute_factorials();\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n\n    for (int i = A; i <= B; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = dp[i - 1][j];\n            for (int k = C; k <= D; k++) {\n                if (j >= k * i) {\n                    long long ways = comb(N - (j - k * i), k * i);\n                    ways = ways * comb(fact[i * k] * inv_fact[i] % MOD * inv_fact[k] % MOD * fact[k] % MOD, 1) % MOD;\n                    ways = ways * inv_fact[k] % MOD;\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k * i] * ways) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", dp[B][N]);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint N, A, B, C, D;\nlong long dp[1001][1001];\nlong long fact[1001];\nlong long inv_fact[1001];\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i <= 1000; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n    inv_fact[1000] = power(fact[1000], MOD - 2);\n    for (int i = 999; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (n < 0 || k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD;\n}\n\nint main() {\n    precompute();\n    cin >> N >> A >> B >> C >> D;\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int i = A; i <= B; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            dp[i][j] = dp[i-1][j];\n            long long f = 1;\n            for (int k = 1; k <= D; ++k) {\n                if (j - k * i < 0) break;\n                f = f * comb(N - (j - k * i), i) % MOD;\n                if (k >= C) {\n                    long long temp = dp[i-1][j - k * i] * f % MOD;\n                    temp = temp * inv_fact[k] % MOD;\n                    dp[i][j] = (dp[i][j] + temp) % MOD;\n                }\n            }\n        }\n    }\n    cout << dp[B][N] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GroupDivision {\n    static final int MOD = 1000000007;\n    static long[][][] dp;\n    static int N, A, B, C, D;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        A = scanner.nextInt();\n        B = scanner.nextInt();\n        C = scanner.nextInt();\n        D = scanner.nextInt();\n\n        dp = new long[N + 1][N + 1][B + 1];\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= N; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n\n        long result = solve(0, 0, A);\n        System.out.println(result % MOD);\n    }\n\n    static long solve(int pos, int groups, int currentSize) {\n        if (pos == N) {\n            return (groups == 0) ? 1 : 0;\n        }\n        if (currentSize > B) {\n            return 0;\n        }\n        if (dp[pos][groups][currentSize] != -1) {\n            return dp[pos][groups][currentSize];\n        }\n\n        long res = 0;\n        // Skip current size\n        res += solve(pos, groups, currentSize + 1);\n        res %= MOD;\n\n        // Use current size\n        if (currentSize >= A) {\n            int maxGroups = Math.min(D, (N - pos) / currentSize);\n            for (int k = C; k <= maxGroups; k++) {\n                int newPos = pos + k * currentSize;\n                if (newPos > N) break;\n                long ways = comb(N - pos, k * currentSize) * comb(k * currentSize, currentSize) % MOD;\n                for (int i = 1; i < k; i++) {\n                    ways = ways * comb(k * currentSize - i * currentSize, currentSize) % MOD;\n                }\n                ways = ways * invFact[k] % MOD;\n                res += ways * solve(newPos, groups + k, currentSize + 1) % MOD;\n                res %= MOD;\n            }\n        }\n\n        dp[pos][groups][currentSize] = res % MOD;\n        return dp[pos][groups][currentSize];\n    }\n\n    static long[] fact, invFact;\n\n    static {\n        int maxN = 1000;\n        fact = new long[maxN + 1];\n        invFact = new long[maxN + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= maxN; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[maxN] = pow(fact[maxN], MOD - 2);\n        for (int i = maxN - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n    }\n\n    static long comb(int n, int k) {\n        if (n < 0 || k < 0 || n < k) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    static long pow(long a, long b) {\n        long res = 1;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 23:29:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int waysToDivide(int N, int A, int B, int C, int D) {\n        final int MOD = 1_000_000_007;\n        int[][][][] dp = new int[N + 1][N + 1][B + 1][B + 1];\n        dp[0][0][0][0] = 1;\n\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= N; j++) {\n                for (int k = 0; k <= B; k++) {\n                    for (int g = 0; g <= B; g++) {\n                        for (int size = A; size <= B && size <= j; size++) {\n                            if (k + (g == size ? 1 : 0) > D) continue;\n                            if (g == size && (g < C || g > D)) continue;\n\n                            dp[i][j][k + (g == size ? 1 : 0)][size] = \n                                (dp[i][j][k + (g == size ? 1 : 0)][size] + \n                                dp[i - size][j - size][k][g]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        int result = 0;\n        for (int k = 0; k <= B; k++) {\n            for (int g = 0; g <= B; g++) {\n                if (k >= C && k <= D) {\n                    result = (result + dp[N][N][k][g]) % MOD;\n                }\n            }\n        }\n\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 23:29:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int waysToDivideGroups(int N, int A, int B, int C, int D) {\n        vector<vector<vector<vector<int>>>> dp(\n            N + 1, \n            vector<vector<vector<int>>>(\n                N + 1, \n                vector<vector<int>>(\n                    N + 1, \n                    vector<int>(N + 1, -1)\n                )\n            )\n        );\n        \n        return solve(N, A, B, C, D, 0, 0, 0, dp);\n    }\n    \nprivate:\n    int solve(int N, int A, int B, int C, int D, \n              int people_left, int group_count, \n              int current_group_size, \n              vector<vector<vector<vector<int>>>>& dp) {\n        \n        if (people_left == 0) {\n            return (group_count >= C && group_count <= D) ? 1 : 0;\n        }\n        \n        if (people_left < 0) {\n            return 0;\n        }\n        \n        if (dp[N][people_left][group_count][current_group_size] != -1) {\n            return dp[N][people_left][group_count][current_group_size];\n        }\n        \n        long long total_ways = 0;\n        \n        for (int size = A; size <= B; size++) {\n            if (size > people_left) break;\n            \n            int new_group_count = (current_group_size == 0) ? group_count + 1 : group_count;\n            \n            total_ways += solve(N, A, B, C, D, \n                                people_left - size, \n                                new_group_count, \n                                size, \n                                dp);\n            \n            total_ways %= MOD;\n        }\n        \n        return dp[N][people_left][group_count][current_group_size] = total_ways;\n    }\n};",
    "timestamp": "2025-08-05 23:29:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef count_groupings(N, A, B, C, D):\n    # DP table: dp[n] represents number of ways to group n people\n    dp = [0] * (N + 1)\n    dp[0] = 1  # Base case: one way to group 0 people (no groups)\n\n    for i in range(A, B + 1):  # Iterate over possible group sizes\n        # Temporary table to adjust counts based on new group size i\n        temp_dp = [0] * (N + 1)\n\n        for j in range(N + 1):  # Iterate over all current states\n            for k in range(C, D + 1):  # Iterate over count of groups of size i\n                if j >= i * k:  # Ensure enough people to form k groups\n                    temp_dp[j] = (temp_dp[j] + dp[j - i * k]) % MOD\n\n        # Update dp table with temporary results\n        for j in range(N + 1):\n            dp[j] = temp_dp[j]\n\n    return dp[N]\n\n# Example usage\nN, A, B, C, D = 6, 2, 3, 1, 2\nprint(count_groupings(N, A, B, C, D))  # Replace with desired inputs",
    "timestamp": "2025-08-13 15:23:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GroupDivision {\n\n    private static final int MOD = 1000000007;\n\n    public static int numberOfWays(int N, int A, int B, int C, int D) {\n        long[][] dp = new long[N+1][B+1];\n        dp[0][0] = 1;\n\n        for (int people = 1; people <= N; people++) {\n            for (int size = A; size <= B; size++) {\n                if (people < size) continue;\n\n                for (int k = C; k <= D; k++) {\n                    long sumWays = 0;\n                    for (int q = 0; q <= k * size && q <= people; q += size) {\n                        sumWays = (sumWays + dp[people - q][size - 1]) % MOD;\n                    }\n                    dp[people][size] = (dp[people][size] + sumWays) % MOD;\n                }\n            }\n        }\n\n        long result = 0;\n        for (int size = A; size <= B; size++) {\n            result = (result + dp[N][size]) % MOD;\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n        int D = scanner.nextInt();\n\n        System.out.println(numberOfWays(N, A, B, C, D));\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:23:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, A, B, C, D;\n    scanf(\"%d %d %d %d %d\", &N, &A, &B, &C, &D);\n    \n    int dp[2][N + 1];\n    for (int i = 0; i <= N; ++i) dp[0][i] = 0;\n    dp[0][0] = 1;\n    \n    for (int i = A; i <= B; ++i) {\n        int current = i & 1;\n        int previous = current ^ 1;\n        \n        for (int j = 0; j <= N; ++j) dp[current][j] = dp[previous][j];\n        \n        for (int j = 0; j <= N; ++j) {\n            if (dp[previous][j] == 0) continue;\n            for (int k = C; k <= D; ++k) {\n                int new_size = j + i * k;\n                if (new_size > N) break;\n                for (int l = 1; l <= k; ++l) {\n                    dp[current][new_size] = (dp[current][new_size] + dp[previous][j]) % MOD;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", dp[B & 1][N]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:23:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\nstd::vector<std::vector<int>> combinations(int n, int k) {\n    std::vector<std::vector<int>> C(n + 1, std::vector<int>(k + 1, 0));\n\n    for (int i = 0; i <= n; ++i) {\n        C[i][0] = 1;\n    }\n    for (int j = 1; j <= k; ++j) {\n        for (int i = j; i <= n; ++i) {\n            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n        }\n    }\n    return C;\n}\n\nint groupWays(int n, int A, int B, int C, int D) {\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));\n    dp[0][0] = 1;\n\n    auto C = combinations(n, n);\n\n    for (int i = A; i <= B; ++i) {\n        for (int j = C; j <= D; ++j) {\n            for (int k = n; k >= i; --k) {\n                for (int l = j; l >= 1; --l) {\n                    dp[k][l] = (dp[k][l] + dp[k - i][l - 1] * C[n - k + i][i]) % MOD;\n                }\n            }\n        }\n    }\n\n    int totalWays = 0;\n    for (int i = 0; i <= n; ++i) {\n        totalWays = (totalWays + dp[n][i]) % MOD;\n    }\n    return totalWays;\n}\n\nint main() {\n    int N, A, B, C, D;\n    std::cin >> N >> A >> B >> C >> D;\n\n    std::cout << groupWays(N, A, B, C, D) << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:24:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_group_divisions(N, A, B, C, D):\n    MOD = 10**9 + 7\n    \n    # Initialize dynamic programming array\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Count frequency of group sizes\n    group_count = [0] * (N + 1)\n    \n    # Dynamic programming to generate valid group divisions\n    for total_people in range(1, N + 1):\n        for group_size in range(A, B + 1):\n            if total_people < group_size:\n                break\n            \n            for count in range(total_people // group_size + 1):\n                if count < C or count > D:\n                    continue\n                \n                remaining_people = total_people - count * group_size\n                if remaining_people < 0:\n                    break\n                \n                for prev_group_count in range(N + 1):\n                    dp[total_people][prev_group_count + count] += dp[remaining_people][prev_group_count]\n                    dp[total_people][prev_group_count + count] %= MOD\n    \n    # Sum all valid group division counts\n    result = sum(dp[N]) % MOD\n    \n    return result",
    "timestamp": "2025-08-13 15:24:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    N, A, B, C, D = map(int, sys.stdin.readline().split())\n    \n    # Precompute factorial, inverse factorial, and inverse arrays modulo MOD up to N\n    fact = [1] * (N + 1)\n    inv_fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[N] = pow(fact[N], MOD-2, MOD)\n    for i in range(N-1, -1, -1):\n        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n    \n    # DP table: dp[i][j] = number of ways to split i people into groups of sizes in [A..j]\n    dp = [[0] * (B + 1) for _ in range(N + 1)]\n    dp[0][A-1] = 1\n    \n    for j in range(A, B + 1):\n        for i in range(N + 1):\n            dp[i][j] = dp[i][j-1]  # carry over the previous count\n            max_k = min(D, i // j)\n            if C > max_k:\n                continue\n            # Compute the sum for k from C to max_k\n            # The term is (fact[i] * inv_fact[i - k*j] % MOD) * inv_fact[j]^k % MOD * inv_fact[k] % MOD\n            # We can precompute inv_j = inv_fact[j], then inv_j_pow_k = inv_j^k mod MOD\n            inv_j = inv_fact[j]\n            inv_j_pow_k = pow(inv_j, C, MOD)\n            fact_i = fact[i]\n            inv_fact_i_minus_kj = inv_fact[i - C*j] if i >= C*j else 0\n            term = fact_i * inv_fact_i_minus_kj % MOD\n            term = term * pow(inv_j, C, MOD) % MOD\n            term = term * inv_fact[C] % MOD\n            dp[i][j] = (dp[i][j] + term) % MOD\n            \n            # Now handle k from C+1 to max_k\n            # We can compute the terms incrementally\n            for k in range(C + 1, max_k + 1):\n                if i < k * j:\n                    break\n                inv_fact_i_minus_kj = inv_fact[i - k*j]\n                term = term * inv_j % MOD\n                term = term * inv_fact_i_minus_kj % MOD\n                term = term * (i - (k-1)*j) % MOD  # because fact[i] / fact[i - k*j] = fact[i] / fact[i - (k-1)*j] * (i - (k-1)*j) ... (i - k*j + 1)\n                # But the above is not straightforward, so better to recompute term from scratch for each k\n                # Alternative approach: recompute term for each k\n                term = fact[i] * inv_fact[i - k*j] % MOD\n                term = term * pow(inv_j, k, MOD) % MOD\n                term = term * inv_fact[k] % MOD\n                dp[i][j] = (dp[i][j] + term) % MOD\n    \n    print(dp[N][B] % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 15:24:28"
  }
]