[
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n  import scala.io.StdIn._\n  import scala.math\n  val str = readLine.trim.toList\n  val winCounts = Array.tabulate(26){_ ⇒ 0}\n  for (_ ← 0 until str.count{_.isLetter}) {\n    val Array(p, c) = readLine.trim.split(' ')\n    winCounts(p(0) - 'a') = c.toInt\n  }\n  Person.winCounts = winCounts\n  println(\n    str match{\n      case winner Winner Nil if winner.isValid && winner.winCount == 0 ⇒ \"Yes\"\n      case _ ⇒ \"No\"\n    }\n  )\n\n  sealed trait Winner {\n    def isValid: Boolean\n    def winCount: Int\n  }\n  object Winner{\n    def unapply(arg: List[Char]): Option[(Winner, List[Char])] = {\n      arg match{\n        case Person(p)::t ⇒ Some((new Person(p), t))\n        case (a, b) Match t ⇒ Some((new Match(a, b), t))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Person{\n    var winCounts: Array[Int] = Array()\n    def unapply(str: Char): Option[Int] = {\n      str match {\n        case c if c.isLetter ⇒ Some(winCounts(c - 'a'))\n        case _ ⇒ None\n      }\n    }\n  }\n  object Match{\n    def unapply(arg: List[Char]): Option[((Winner, Winner), List[Char])] = {\n      arg match {\n        case '['::(a Winner ('-':: (b Winner ']'::t))) ⇒ Some(((a, b), t))\n        case _ ⇒ None\n      }\n    }\n  }\n  class Person(override val winCount: Int) extends Winner {\n    override def isValid: Boolean = true\n  }\n  class Match(val left: Winner, val right: Winner) extends Winner {\n    override val isValid: Boolean = left.isValid && right.isValid && ((left.winCount > 0 && right.winCount == 0) || (left.winCount == 0 && right.winCount > 0))\n    override val winCount: Int = if (left.winCount == 0) right.winCount - 1 else left.winCount - 1\n  }\n  implicit class ScopeFunc[T](private val value: T) {\n    def let[A](func:T ⇒ A): A = func(value)\n    def also(func:T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin>>s;\n  int n = s.size();\n  \n  int numNode = 0;\n  for(int i=0;i<n;i++) if(isalpha(s[i])) numNode++;\n\n  \n  vector<int> win(26, 0);\n  int sumWin = 0;\n  for(int i=0;i<numNode;i++){\n    string s;\n    int num;\n    cin>>s>>num;\n    sumWin += num;\n    win[s[0] - 'a'] = num;\n  }\n\n  int valid = 1;\n  int idx = 0;\n  assert(s[0]=='[');\n  \n  function<P()> dfs = [&](){\n    if(isalpha(s[idx])) {\n      int i = idx++;\n      return P(win[s[i] - 'a'], 0);\n    }\n    \n    if(s[idx] == '['){\n      idx++;\n      auto l = dfs();\n      assert(s[idx] == '-');\n      idx++;\n\n      auto r = dfs();\n      assert(s[idx] == ']');\n      idx++;\n      if(l.first == l.second) return P(r.first, r.second + 1);\n      if(r.first == r.second) return P(l.first, l.second + 1);\n      valid = 0;\n      return P(0, 0);\n    }\n    assert(0);\n    return P(0, 0);\n  };\n  \n  auto winner = dfs();\n  valid &= (winner.first == winner.second);\n  assert(idx == n);\n  cout<<(valid? \"Yes\":\"No\")<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n \nusing namespace std;\n \nstring s;\nint n;\nint cnt[26];\n \ntypedef struct node{\n    int id;\n    node* right;\n    node* left;\n    node(){right = nullptr,left = nullptr;}\n} node;\n \nint dfs(node* nd){\n    if(nd->left){\n        int le = dfs(nd->left);\n        if(le < 0){\n            return -1;\n        }\n        int ri = dfs(nd->right);\n        if(ri < 0){\n            return -1;\n        }\n        if(le == 0 && ri == 0){\n            return -1;\n        }\n        if(le == 0){\n            return ri-1;\n        }else if(ri == 0){\n            return le-1;\n        }else{\n            return -1;\n        }\n    }else{\n        return cnt[nd->id];\n    }\n}\n \nnode* expr(int& pos);\nnode* factor(int& pos);\n \n \n \nnode* expr(int& pos)\n{\n    node* nw = new node;\n    node* l = factor(pos);\n    pos++;\n    if(pos == (int)s.size()+1){\n        return l;\n    }\n    node* r = factor(pos);\n    nw->left = l;\n    nw->right = r;\n    return nw;\n}\n \nnode* factor(int& pos){\n    if(isalpha(s[pos])){\n        node* nw = new node;\n        n++;\n        nw->id = s[pos]-'a';\n        pos++;\n        return nw;\n    }\n    pos++;\n    node* res = expr(pos);\n    pos++;\n    return res;\n}\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> s;\n    n = 0;\n    int pos = 0;\n    node* root = expr(pos);\n    rep(i,n){\n        char c;\n        int a;\n        cin >> c >> a;\n        cnt[c-'a'] = a;\n    }\n    int res = dfs(root);\n    if(res != 0){\n        cout << \"No\\n\";\n    }else{\n        cout << \"Yes\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0,1,-1,1,-1};\nint dy[]={0,1,0,-1,1,-1,-1,1};\n\nstring s;\nmap<char,int> ma;\nbool f = true;\n\nP dfs(int l,int r){\n    if(!f) return mp(-1,-1);\n    if(r - l <= 1) return mp(ma[s[l]],0);\n    int cnt = 0;\n    int idx = -1;\n    for (int i = l; i < r; i++) {\n        if(cnt == 1 && s[i] == '-'){\n            idx = i;\n            break;\n        }\n        else if(s[i] == '[') cnt++;\n        else if(s[i] == ']') cnt--;\n    }\n    auto ll = dfs(l+1,idx), rr = dfs(idx+1,r-1); \n    if(ll.fs == ll.sc && rr.fs == rr.sc) f = false;\n    else if(ll.fs == ll.sc) return mp(rr.fs,rr.sc+1);\n    else if(rr.fs == rr.sc) return mp(ll.fs,ll.sc+1);\n    else f = false;\n    return mp(-1,-1);\n}\n\n\nint main(){\n    cin >> s;\n    for (int i = 0; i < s.length(); i++) {\n        int a = s[i] - 'a';\n        if(0<=a&&a<26){\n            char ch;cin >> ch;\n            int num;cin >> num;\n            ma[ch] = num;\n        }\n    }\n    auto r = dfs(0,s.length());\n    if(f&&r.fs == r.sc) puts(\"Yes\");\n    else puts(\"No\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=203,INF=1<<20;\nint cnt[26];\nstring S;\nbool ok=true;\n\nint expr(int &i){\n    if('a'<=S[i]&&S[i]<='z'){\n        return S[i++]-'a';\n    }\n    \n    i++;\n    int a=expr(i);\n    i++;\n    int b=expr(i);\n    i++;\n    \n    //cout<<i<<endl;\n    if(cnt[a]>0){\n        if(cnt[b]>0) ok=false;\n        cnt[a]--;\n        return a;\n    }else if(cnt[a]==0){\n        if(cnt[b]<=0) ok=false;\n        cnt[b]--;\n        return b;\n    }else{\n        ok=false;\n        return a;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>S;\n    int N=int(S.size()+3)/4;\n    \n    for(int i=0;i<N;i++){\n        char a;int b;cin>>a>>b;\n        cnt[a-'a']=b;\n    }\n    int i=0;\n    expr(i);\n    \n    //cout<<ok<<endl;\n    \n    for(int i=0;i<26;i++){\n        if(cnt[i]) ok=false;\n        //cout<<cnt[i]<<endl;\n    }\n    \n    if(ok) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nint win[26] = {};\n\nstruct node{\n    int id;\n    node *left;\n    node *right;\n    node (int i){\n        id = i;\n        left = NULL;\n        right = NULL;\n    }\n};\n\nnode* new_node(int id){\n    node *ret;\n    ret = (node*)malloc(sizeof(node));\n    ret->id = id;\n    ret->left = NULL;\n    ret->right = NULL;\n    return ret;\n}\n\nstring s;\n\nnode* f(int &pos){\n    if(inRange(s[pos], 'a', 'z')){\n        return new_node(s[pos++]-'a');\n    }\n    if(s[pos] == '['){\n        pos++;\n        node* ret = new_node(-1);\n        ret->left = f(pos);\n        pos++;  // -\n        ret->right = f(pos);\n        pos++;  // ]\n        return ret;\n    }\n    return NULL;    // unreachable\n}\n\nbool valid = true;\n\nint dfs(node *cur){\n    if(cur->id != -1){\n        return cur->id;\n    }else{\n        int a = dfs(cur->left);\n        int b = dfs(cur->right);\n        int judge = (win[a]!=0) + (win[b]!=0);\n        if(judge == 0 || judge == 2){\n            valid = false;\n        }\n        if(win[a] == 0){\n            win[b]--;\n            return b;\n        }else if(win[b] == 0){\n            win[a]--;\n            return a;\n        }else{\n            // invalid\n            return 0;\n        }\n    }\n}\n\nint main(){\n    cin >> s;\n    char c; int x;\n    while(cin >> c >> x){\n        win[c-'a'] = x;\n    }\n    int pos = 0;\n    node *root = f(pos);\n    cout << (win[dfs(root)] == 0 && valid ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint n, ptr;\nstring s;\nint cnt[1000] = {};\n \nint dfs()\n{\n  if(s[ptr] == '[') {\n    ++ptr;\n    int latte = dfs();\n    ++ptr;\n    int malta = dfs();\n    ++ptr;\n    if(cnt[latte] > 0) {\n      --cnt[latte];\n      return (latte);\n    } else {\n      --cnt[malta];\n      return (malta);\n    }\n  } else {\n    return (s[ptr++]);\n  }\n}\n \nint main()\n{\n  cin >> s;\n \n  for(int i = 0; i < s.size(); ++i) {\n    if('a' <= s[i] && s[i] <= 'z') n++;\n  }\n \n  for(int i = 0; i < n; ++i) {\n    char c;\n    cin >> c;\n    cin >> cnt[c];\n  }\n \n  dfs();\n  for(int i = 0; i < 1000; i++) {\n    if(cnt[i] != 0) {\n      cout << \"No\" << endl;\n      return (0);\n    }\n  }\n \n  cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <map>\n#include <stdexcept>\n\nchar parse(const std::string& s, size_t& i, std::map<char, int>& av) {\n  if (isalpha(s[i])) return s[i++];\n  if (s[i] == '[') {\n    char c1=parse(s, ++i, av);\n    assert(s[i] == '-');\n    char c2=parse(s, ++i, av);\n    assert(s[i] == ']');\n    ++i;\n\n    if (av[c1] == av[c2]) throw std::logic_error(\"1\");\n    if (av[c1] > av[c2]) std::swap(c1, c2);\n\n    assert(av[c1] < av[c2]);\n    if (av[c1] != 0) throw std::logic_error(\"1\");\n    --av[c2];\n    return c2;\n  }\n  assert(false);\n}\n\nint main() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n\n  std::map<char, int> av;\n  while (true) {\n    char a;\n    int v;\n    if (scanf(\" %c %d\", &a, &v) == EOF) break;\n    av[a] = v;\n  }\n\n  try {\n    size_t i=0;\n    char z=parse(s, i, av);\n    if (av[z]) throw std::logic_error(\"1\");\n    puts(\"Yes\");\n  } catch (std::logic_error&) {\n    puts(\"No\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge;\n\nint main(){\n  string s;\n  cin>>s;\n  int a[26];\n  int count =0;\n  lp(i,s.size()){\n    if('a'<=s[i]&&s[i]<='z'){\n      count++;\n    }\n  }\n  lp(i,count){\n    char c;\n    int hoge;\n    cin>>c>>hoge;\n    a[c-'a']=hoge;\n  }\n  int stat=0;\n  while(s.size()!=1){\n    lp(i,s.size()){\n      if(i==0) continue;\n      if(s[i-1]=='['&&'a'<=s[i]&&s[i]<='z'&&s[i+3]==']'){\n\tstring bef=s.substr(0,i-1);\n\tstring cont=s.substr(i-1,5);\n\tstring aft=s.substr(i+4,s.size()-i+5);\n\tint x,y;\n\tx=a[cont[1]-'a'];\n\ty=a[cont[3]-'a'];\n\tif(x==0){\n\t  a[cont[3]-'a']--;\n\t  cont=cont.substr(3,1);\n\t}\n\telse if(y==0){\n\t  a[cont[1]-'a']--;\n\t  cont=cont.substr(1,1);\n\t}\n\telse stat=1;\n\ts=bef+cont+aft;\n\tif(stat==1) break;\n      }\n    }\n    if(stat==1) break;\n  }\n  if(stat==1||a[s[0]-'a']!=0) cout<<\"No\"<<endl;\n  else cout<<\"Yes\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint main(){\n\n\tchar buf[1000];\n\tscanf(\"%s\",buf);\n\n\tint N = 0;\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(buf[i] >= 'a' && buf[i] <= 'z'){\n\t\t\tN++;\n\t\t}\n\t}\n\n\tchar word[2];\n\tint table[26],tmp;\n\tfor(int i = 0; i < 26; i++)table[i] = -1;\n\n\tint total_win = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d\",word,&tmp);\n\t\ttable[word[0]-'a'] = tmp;\n\t\ttotal_win += tmp;\n\t}\n\tif(total_win != N-1){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\n\tint lose_num = 0,max_depth,depth;\n\tint match_num[26];\n\tfor(int i = 0; i < 26; i++)match_num[i] = 0;\n\n\tqueue<int> LEFT,RIGHT;\n\n\tint calc_left,calc_right;\n\tchar person_left,person_right,winner;\n\n\twhile(lose_num < N-1){\n\n\t\tmax_depth = -1;\n\t\tdepth = 0;\n\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '['){\n\t\t\t\tdepth++;\n\t\t\t\tmax_depth = max(max_depth,depth);\n\t\t\t}else if(buf[i] == ']'){\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\n\t\tdepth = 0;\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '['){\n\t\t\t\tdepth++;\n\t\t\t\tif(depth == max_depth){\n\t\t\t\t\tLEFT.push(i);\n\t\t\t\t}\n\t\t\t}else if(buf[i] == ']'){\n\t\t\t\tif(depth == max_depth){\n\t\t\t\t\tRIGHT.push(i);\n\t\t\t\t}\n\t\t\t\tdepth--;\n\t\t\t}else if(buf[i] >= 'a' && buf[i] <= 'z'){\n\t\t\t\tif(depth == max_depth){\n\t\t\t\t\tmatch_num[buf[i]-'a']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!LEFT.empty()){\n\t\t\tcalc_left = LEFT.front();\n\t\t\tLEFT.pop();\n\t\t\tcalc_right = RIGHT.front();\n\t\t\tRIGHT.pop();\n\n\t\t\tperson_left = '@';\n\t\t\tfor(int i = calc_left; i <= calc_right; i++){\n\t\t\t\tif(buf[i] >= 'a' && buf[i] <= 'z'){\n\t\t\t\t\tif(person_left == '@'){\n\t\t\t\t\t\tperson_left = buf[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tperson_right = buf[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(table[person_left-'a'] == match_num[person_left-'a']-1 && table[person_right-'a'] >= match_num[person_right-'a']){\n\t\t\t\twinner = person_right;\n\t\t\t\tlose_num++;\n\t\t\t}else if(table[person_left-'a'] >= match_num[person_left-'a'] && table[person_right-'a'] == match_num[person_right-'a']-1){\n\t\t\t\twinner = person_left;\n\t\t\t\tlose_num++;\n\t\t\t}else{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfor(int i = calc_left; i <= calc_right; i++){\n\t\t\t\tif(buf[i] == winner){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tbuf[i] = '@';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\n\nmap<char,int> mp;\nint N;\n\npair<bool,char> rec(int& i,const string& S){\n    if(i == S.length()) return {true,' '};\n    if(S[i] == '['){\n        bool ok; char l,r;\n        tie(ok,l) = rec(++i,S);\n        if(!ok) return {false,' '};\n        tie(ok,r) = rec(++i,S);\n        if(!ok) return {false,' '};\n        \n        if(mp[l] != 0 && mp[r] != 0) return {false,' '};\n        if(mp[l] == 0 && mp[r] == 0) return {false,' '};\n        \n        i++;\n        if(mp[l] != 0){\n            mp[l]--;\n            return {true,l};\n        }\n        if(mp[r] != 0){\n            mp[r]--;\n            return {true,r};\n        }\n    }else{\n        return {true,S[i++]};\n    }\n    return {true,' '};\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    string S; cin >> S;\n    char a; int v;\n    while(cin >> a >> v){\n        mp[a] = v;\n    }\n    N = (int)mp.size();\n    int i = 0;\n    bool ok;\n    tie(ok,ignore)= rec(i,S);\n    for(auto p:mp){\n        if(p.second) ok = false;\n    }\n    if(ok){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint check(string s) {\n    for (int i = 0; i < (int)s.size() - 4; i++) {\n        if (s[i] == '[' && s[i + 4] == ']') {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    string S;\n    cin >> S;\n    vector<char> char_vector;\n    for (int i = 0; i < S.size(); i++) {\n        char_vector.push_back(S[i]);\n    }\n    int N = char_vector.size();\n    int v[26] = {};\n    for (int i = 0; i < N; i++) {\n        char a;\n        cin >> a;\n        cin >> v[a - 'a'];\n    }\n    while (true) {\n        int index = check(S);\n        if (index == -1) break;\n        if (v[S[index + 1] - 'a'] != 0 && v[S[index + 3] - 'a'] != 0) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n        if (v[S[index + 1] - 'a'] != 0) {\n            v[S[index + 1] - 'a']--;\n            S.erase(index + 2, 3);\n            S.erase(index, 1);\n        } else {\n            v[S[index + 3] - 'a']--;\n            S.erase(index + 4, 1);\n            S.erase(index, 3);\n        }\n    }\n    for (int i = 0; i < 26; i++) {\n        if (v[i] != 0) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x,p;\nchar c;\nmap<char,int>m;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='[')p++,res=bnf1(),p++;\n  else res=m[s[p++]];\n  return res;\n}\nint bnf1(){\n  int res=get_A();\n  while(s[p]=='-'){\n    int t=p++;\n    int x=get_A();\n    if(x&&res)flag++;\n    if(!x&&!res)flag++;\n    res=max(res,x)-1;\n  }\n  return res;\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  if(bnf1()!=0)flag++;\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nint t[26];\n\npair<bool,int> dfs(char *S, int l, int r) {\n  int sum = 0, mid;\n\n  if (l+1 == r) {\n    return { true, S[l]-'a' };\n  }\n\n  for (int i=l; i<r; i++) {\n    if (S[i] == '[') sum++;\n    if (S[i] == ']') sum--;\n    if (S[i] == '-') {\n      if (sum == 1) mid = i;\n    }\n  }\n\n  auto p = dfs(S, l+1, mid);\n  auto q = dfs(S, mid+1, r-1);\n\n  if (!p.first || !q.first) return {false, 0};\n\n  int a = p.second;\n  int b = q.second;\n  if (min(t[a], t[b]) != 0 || max(t[a], t[b]) <= 0) return {false, 0};\n\n  t[a]--; t[b]--;\n\n  if (t[a] > t[b])\n    return {true, a};\n  else\n    return {true, b};\n}\n\nint main(){\n  char S[50];\n\n  scanf(\"%s\", S);\n  int M = strlen(S);\n  int N = (M + 3) / 4;\n\n  debug(N);\n\n  for (int i=0; i<N; i++) {\n    char c;\n    int v;\n    scanf(\" %c%d\", &c, &v);\n\n    t[c-'a'] = v;\n  }\n\n  auto p = dfs(S, 0, M);\n\n  if (p.first && t[p.second] == 0) {\n    puts(\"Yes\");\n  } else {\n    puts(\"No\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint rest[26];\n\nchar winner(string &s, int &i);\nchar person(string &s, int &i);\n\nchar winner(string &s, int &i){\n    if(s[i] == '['){\n        ++i;\n        char lhs = winner(s, i);\n        ++i;\n        char rhs = winner(s, i);\n        ++i;\n        if(lhs == '#' || rhs == '#') return '#';\n        else if(rest[lhs-'a'] == 0){\n            if(rest[rhs-'a'] >= 1){\n                --rest[rhs-'a'];\n                return rhs;\n            }\n            else return '#';\n        }\n        else{\n            if(rest[rhs-'a'] != 0) return '#';\n            --rest[lhs-'a'];\n            return lhs;\n        }\n    }\n    else return person(s, i);\n}\n\nchar person(string &s, int &i){\n    char ret = s[i];\n    ++i;\n    return ret;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    int cnt = 0;\n    for(auto c: s)if('a' <= c && c <= 'z') ++cnt;\n    rep(i, cnt){\n        char c;\n        int a;\n        scanf(\" %c%d\", &c, &a);\n        rest[c-'a'] = a;\n    }\n    int i = 0;\n    char w = winner(s, i);\n    puts((w != '#' && rest[w-'a'] == 0) ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin>>s;\n  int n = s.size();\n  \n  int numNode = 0;\n  for(int i=0;i<n;i++) if(isalpha(s[i])) numNode++;\n\n  \n  vector<int> win(26, 0);\n  int sumWin = 0;\n  for(int i=0;i<numNode;i++){\n    string s;\n    int num;\n    cin>>s>>num;\n    sumWin += num;\n    win[s[0] - 'a'] = num;\n  }\n\n  int valid = 1;\n  int idx = 0;\n  assert(s[0]=='[');\n  \n  function<P()> dfs = [&](){\n    if(isalpha(s[idx])) {\n      int i = idx++;\n      return P(win[s[i] - 'a'], 0);\n    }\n    \n    if(s[idx] == '['){\n      idx++;\n      auto l = dfs();\n      assert(s[idx] == '-');\n      idx++;\n\n      auto r = dfs();\n      assert(s[idx] == ']');\n      idx++;\n      if(l.first == l.second) return P(r.first, r.second + 1);\n      if(r.first == r.second) return P(l.first, l.second + 1);\n      valid = 0;\n      return P(0, 0);\n    }\n    assert(0);\n    return P(0, 0);\n  };\n  \n  auto winner = dfs();\n  valid &= (winner.first == winner.second);\n  assert(idx == n);\n  cout<<(valid? \"Yes\":\"No\")<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing pii = pair<int, int>;\n \ntemplate <typename T> T inf;\ntemplate <> const int inf<int> = 1e9;\ntemplate <> const ll inf<ll> = 1e18;\n \nchar winner(string const& s, int& p, vector<int>& cnt) {\n    if('a' <= s[p] && s[p] <= 'z') {\n        return s[p++];\n    } else {\n        int p1 = winner(s, ++p, cnt) - 'a';\n        p++;\n        int p2 = winner(s, p, cnt) - 'a';\n        p++;\n        int lose, win;\n        if(cnt[p1] > cnt[p2]) {\n            lose = p2; win = p1;\n        } else {\n            lose = p1; win = p2;\n        }\n        if(cnt[lose] > 0 || cnt[win] <= 0) {\n            throw runtime_error(\"hoge\");\n        }\n        cnt[win]--;\n        cnt[lose]--;\n        return 'a' + win;\n    }\n}\n \nint main() {\n    string S;\n    cin >> S;\n    vector<int> cnt(26);\n    char c; int win;\n    while(cin >> c >> win) {\n        cnt[c - 'a'] = win;\n    }\n    int p = 0;\n    try {\n        winner(S, p, cnt);\n        if(*max_element(cnt.begin(), cnt.end()) > 0) {\n            cout << \"No\" << endl;\n        } else {\n            cout << \"Yes\" << endl;\n        }\n    } catch(...) {\n        cout << \"No\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t Int;\n#define all(x) (x).begin(), (x).end()\n \nconst double EPS = 1e-10;\nconst Int INF = 1e18;\nconst int inf = 1e9;\nconst Int mod = 1e9+7;\n\nbool print_space_enable = false;\nvoid print() { \n    cout << endl; \n    print_space_enable = false;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n    if (print_space_enable) cout << \" \";\n    cout << fixed << setprecision(15) << head;\n    print_space_enable = true;\n    print(std::forward<Tail>(tail)...);\n}\n\ntemplate<typename T>\nvoid print(vector<T> v) {\n    for (size_t i = 0; i < v.size(); i++) {\n        if (i > 0) std::cout << \" \";\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    map<char, Int> mp;\n    Int cnt = 0;\n    for (Int i = 0; i < (Int)s.size(); i++) {\n        if (isalpha(s[i])) cnt++;\n    }\n    for (Int i = 0; i < (Int)cnt; i++) {\n        char a;\n        Int x;\n        cin >> a >> x;\n        mp[a] = x;\n    }\n    stack<char> st;\n    for (Int i = 0; i < (Int)s.size(); i++) {\n        if (s[i] == '-') continue;\n        if (s[i] == '[' or isalpha(s[i])) {\n            st.push(s[i]);\n        }\n        if (s[i] == ']') {\n            char a = st.top();\n            st.pop();\n            char b = st.top();\n            st.pop();\n            st.pop();\n            if (mp[a] == 0 and mp[b] == 0) {\n                print(\"No\");\n                return 0;\n            } else if (mp[a] == 0) {\n                mp[b]--;\n                st.push(b);\n            } else if (mp[b] == 0) {\n                mp[a]--;\n                st.push(a);\n            } else {\n                print(\"No\");\n                return 0;\n            }\n        }\n    }\n    if (st.size() == 1 and mp[st.top()] == 0) {\n        print(\"Yes\");\n    } else {\n        print(\"No\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else{\n    int f=0,le=0,ri=0i;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"NO\":\"YES\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nchar S[200020];\nint A[20000],N;\nstruct Node{\n\tchar c;\n\tint Pre,Ne;\n}C[200200];\nbool Work(){\n\tfor (int pos=1;pos!=N+1;pos=C[pos].Ne)\n\t\tif (C[pos].c>='a'&&C[pos].c<='z'){\n\t\tint n1=C[pos].Ne,n2=C[n1].Ne;\n\t\tif (C[n1].c=='-'&&C[n2].c>='a'&&C[n2].c<='z'){\n\t\t\tint x=C[pos].c,y=C[n2].c;\n\t\t\tif (!A[x]) swap(x,y),swap(C[pos].c,C[n2].c);\n\t\t\tif ((A[x]>0&&A[y]>0)||(A[x]<=0&&A[y]<=0)){\n\t\t\t\tcout<<\"No\"<<endl; exit(0);\n\t\t\t}\n\t\t\tA[x]--;\n\t\t\tint st=C[pos].Pre,en=C[n2].Ne;\n\t\t\tif (C[st].Pre==0) return 0;\n\t\t\tC[st].c=C[pos].c; C[st].Ne=C[en].Ne; \n\t\t}\n\t}\n\treturn 1;\n}\nint main(){\n\tcin>>(S+1);\n\tN=strlen(S+1);\n\tint num=0;\n\tfor (int i=1;i<=N;i++) if (S[i]>='a'&&S[i]<='z') num++;\n\tfor (int i=1;i<=N;i++)\n\t\tC[i].c=S[i],C[i].Pre=i-1,C[i].Ne=i+1;\n\tfor (int i=1;i<=num;i++){\n\t\tchar x; cin>>x; scanf(\"%d\",&A[x]);\n\t}\n\twhile (Work());\n\tfor (int i='a';i<='z';i++) if (A[i]){\n\t\tcout<<\"No\"<<endl; return 0;\n\t}\n\tcout<<\"Yes\"<<endl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x,p;\nchar c;\nmap<char,int>m;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='[')p++,res=bnf1(),p++;\n  else res=m[s[p++]];\n  return res;\n}\nint bnf1(){\n  int res=get_A();\n  while(s[p]=='-'){\n    int t=p++;\n    int x=get_A();\n    if(x&&res)flag++;\n    if(!x&&!res)flag++;\n    res=max(res,x)-1;\n  }\n  return res;\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  bnf1();\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n\nusing namespace std;\n\nstring s;\nint dt[30], j=0;\n\npair<char, int> dfs(){\n\t// printf(\"j: %d\\n\", j);\n\tint v1, v2;\n\tchar a1, a2;\n\t\n\tj++;\n\t\n\tif (s[j]=='['){\n\t\tpair<char, int> ret;\n\t\tret = dfs();\n\t\ta1 = ret.first;\n\t\tv1 = ret.second;\n\t\tif (v1<0){\n\t\t\treturn make_pair('0', -1);\n\t\t} \n\t}else{\n\t\ta1 = s[j];\n\t\tv1 = dt[a1-'a'];\n\t}\n\t\n\tj++;\n\tj++;\n\t\n\tif (s[j]=='['){\n\t\tpair<char, int> ret;\n\t\tret = dfs();\n\t\ta2 = ret.first;\n\t\tv2 = ret.second;\n\t\tif (v2<0){\n\t\t\treturn make_pair('0', -1);\n\t\t}\n\t}else{\n\t\ta2 = s[j];\n\t\tv2 = dt[a2-'a'];\n\t}\n\t\n\tj++;\n\t\n\t// printf(\"1: (%c, %d) 2: (%c, %d)\\n\", a1, v1, a2, v2);\n\t\n\tif (v1==0){\n\t\treturn make_pair(a2, v2-1);\n\t}else if (v2==0){\n\t\treturn make_pair(a1, v1-1);\n\t}else{\n\t\treturn make_pair('0', -1);\n\t}\n}\n\nint main(){\n\tchar letter;\n\tint v;\n\tcin >> s;\n\tscanf(\"%*c\");\n\twhile(1){\n\t\tif (scanf(\"%c%*c%d%*c\", &letter, &v)==EOF){\n\t\t\tbreak;\n\t\t}\n\t\tdt[letter - 'a'] = v;\n\t\t// printf(\"letter[%d] = %d\\n\", letter - 'a', v);\n\t}\n\tpair<char, int> ret;\n\tret = dfs();\n\tcout << (ret.second==0 ? \"Yes\" : \"No\") << endl;\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\n\nstring st;\nint a=0;\nstruct game {\n\tshared_ptr<game>l;\n\tshared_ptr<game>r;\n\n\tchar name;\n\n\tgame(char a) :name(a){\n\n\t}\n\tgame():name('A') {\n\n\t}\n};\n\ngame get_game() {\n\tgame now_game;\n\tif (st[a] == '[') {\n\t\ta++;\n\t\tauto l_game=make_shared<game>(get_game());\n\t\tassert(st[a]=='-');\n\t\ta++;\n\t\tauto r_game=make_shared<game>(get_game());\n\t\tassert(st[a]==']');\n\t\ta++;\n\t\tnow_game.l=l_game;\n\t\tnow_game.r=r_game;\n\t\treturn now_game;\n\t}\n\telse {\n\t\tnow_game.name=st[a];\n\t\ta++;\n\t\treturn now_game;\n\t}\n}\n\nint dfs(game g,const map<char,int>&mp) {\n\tif (g.name == 'A') {\n\t\tauto l=dfs(*g.l,mp);\n\t\tauto r=dfs(*g.r,mp);\n\n\t\tif (l == 0 && r) {\n\t\t\treturn r-1;\n\t\t}\n\t\telse if (r == 0 && l) {\n\t\t\treturn l-1;\n\t\t}\n\t\telse {\n\t\t\treturn 100;\n\t\t}\n\t}\n\telse {\n\t\tif ((mp.find(g.name))->second==0) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tauto x=mp.find(g.name);\n\t\t\t\n\t\t\treturn mp.find(g.name)->second;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tcin>>st;\n\tmap<char,int>mp;\n\tstring line;\n\tgetline(cin,line);\n\twhile (getline(cin, line)) {\n\t\tchar name=line[0];\n\t\tint k=stoi(line.substr(2));\n\n\t\tmp[name]=k;\n\t}\n\tgame g=get_game();\n\tint ok=dfs(g,mp);\n\tif(ok==0)cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <utility>\n\nusing namespace std;\ntypedef pair<char, int> P;\n\nstring s;\nmap<char, int> mp;\n\nbool ans = true;\nP parseWin(int &p)\n{\n  if(s[p] == '['){\n    p++;\n    P res = parseWin(p);\n    p++;\n    P res2 = parseWin(p);\n    p++;\n    if(mp[res.first] == res.second){\n      if(mp[res2.first] >= res2.second+1) {\n        //cout << p << \" \" << res2.first << \" \" << res2.second+1 << endl;\n        return make_pair(res2.first, res2.second+1);\n      }\n    }\n    else if(mp[res2.first] == res2.second){\n      if(mp[res.first] >= res.second+1){\n        //cout << p << \" \" << res.first << \" \" << res.second+1 << endl;\n        return make_pair(res.first, res.second+1);\n      }\n    }\n    ans = false;\n    return res;\n  }\n  else if(s[p] >= 'a' && s[p] <= 'z'){\n    P res = make_pair(s[p], 0);\n    p++;\n    return res;\n  }\n  return make_pair('a', 0);\n}\n\nint main(void)\n{\n  cin >> s;\n  //s += \"#\";\n  int cnt = 0;\n  for(int i = 0; i < s.size(); i++){\n    if(s[i] >= 'a' && s[i] <= 'z') cnt++;\n  }\n  char c; int x;\n  for(int i = 0; i < cnt; i++){\n    cin >> c >> x;\n    mp[c] = x;\n  }\n\n  int p = 0;\n  P res = parseWin(p);\n  //cout << res.first << \" \" << res.second << endl;\n  if(ans && mp[res.first] == res.second) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint hoge[114514];\nstring s;\nint it;\nint cnt=0;\n//int a[1000];\nint ri[3000],le[3000],ans[3000],a[3000],oya[3000];\nint use[3000]={0};\nint winner(){\n\tcnt++;\nint r=cnt;\n//cout<<it<<s[it]<<endl;\n\tif(s[it]>='a' && s[it]<='z'){\n\t\ta[r]=s[it]-'a';\n\t\tuse[r]=2;\n//\t\tcout<<s[it]<<endl;\n\t\tit++;\n\t\treturn r;\n\t}\n\telse if(s[it]=='['){\n\t//\tcout<<\"it \"<<it<<endl;\n\t\tit++;\n\t\tint z=winner();\n\t\tit++;\n\t\tint zz=winner();\n\t\tit++;\n\t\toya[z]=r;\n\t\toya[zz]=r;\n\t\tuse[r]=1;\n\t\t\tri[r]=z,le[r]=zz;\n//cout<<r<<\" \"<<ri[r]<<\" \"<<le[r]<<endl;\n\n\t\treturn r;\n\t}\n\treturn -1;\n}\n\n//int ans[1000];\nint mr[1000];\nint main() {\n   cin>>s;\n//   cout<<s<<endl;\n   s=s+\"*\";\n   it=0;\n   for(int i=0;i<1000;i++) a[i]=-1,ans[i]=-1,mr[i]=-1;\n\twinner();\n//cout<<\"ss\"<<endl;\n//return 0;\n\toya[1]=-1;\n\n\nfor(int i=1;i<=10;i++){\n//\tcout<<a[i]<<\" \"<<ri[i]<<\" \"<<le[i]<<endl;\n}\n\n\tint n=(s.length()+3)/4;\n//\tcout<<n<<endl;\n\tfor(int i=0;i<n;i++){\n\t\tchar c;\n\t\tint y;\n\t\tcin>>c>>y;\n\t\tans[c-'a']=y;\n\t}\n\n\n\tfor(int i=0;i<26;i++){\n\n\t//\tcout<<ans[i]<<endl;\n\t\tif(ans[i]==-1) continue;\nint j;\n//cout<<i<<endl;\n\t\tfor(j=0;j<1000;j++){\n\t\t\tif(a[j]==i) break;\n\n\t\t}\n\n\t\tint e=oya[j];\n\t\tfor(int k=0;k<ans[i];k++){\n\t\t//\tcout<<\"e \"<<e<<endl;\n\t\t\tif(e==-1){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(mr[e]!=-1){\n\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmr[e]=i;\n\t\t//\tcout<<e<<\" \"<<i<<endl;\n\t\t\t\n\t\t\te=oya[e];\n\t\t}\n\n\t}\n\n\n\tfor(int i=0;i<1000;i++){\n\t\tif(use[i]!=1) continue;\n\t\tif(mr[i]==-1){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstring str;\nint win[29];\n\nint main(void){\n\tcin >> str;\n\tint cnt=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]>='a' && str[i]<='z'){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tstring a;\n\t\tint b;\n\t\tcin >> a >> b;\n\t\tchar d=a[0];\n\t\twin[(d-'a')]=b;\n\t}\n\tbool flag=true;\n\tstack<int> st;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]>='a' && str[i]<='z'){\n\t\t\tst.push((str[i]-'a'));\n\t\t}\n\t\tif(str[i]==']'){\n\t\t\tint a=st.top();\n\t\t\tst.pop();\n\t\t\tint b=st.top();\n\t\t\tst.pop();\n\t\t\tif(win[a]>0 && win[b]>0){\n\t\t\t\tflag=false;\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tif(win[a]==0 && win[b]==0){\n\t\t\t\tflag=false;\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tif(win[a]>0 && win[b]==0){\n\t\t\t\twin[a]--;\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tif(win[a]==0 && win[b]>0){\n\t\t\t\twin[b]--;\n\t\t\t\tst.push(b);\n\t\t\t}\n\t\t}\n\t}\n\tint a=st.top();\n\tif(win[a]>0)flag=false;\n\tprintf(\"%s\\n\",flag?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define debug cerr\nusing namespace std;\nconst int maxn = 53;\n\nchar in[maxn * maxn];\nint lson[maxn], rson[maxn], id[maxn], cnt;\nint tar[maxn], pts[maxn];\n\nstack<int> nums, ope;\n\ninline void gen() {\n\tfor(int i = 1; i <= 26; i++) id[cnt = i] = i;\n\tint len  = strlen(in + 1);\n\tfor(int i = 1; i <= len; i++) {\n\t\tif(in[i] == '[') ope.push(0);\n\t\tif(in[i] == ']') {\n\t\t\t// assert(nums.size() >= 2 && ope.top() == 0);\n\t\t\t++cnt, ope.pop();\n\t\t\tlson[cnt] = nums.top(), nums.pop();\n\t\t\trson[cnt] = nums.top(), nums.pop();\n\t\t\tnums.push(cnt);\n\t\t}\n\t\tif('a' <= in[i] && in[i] <= 'z') nums.push(in[i] - 'a' + 1);\n\t}\n\t// assert(!ope.size() && nums.size() == 1);\n}\ninline void getTar() {\n\tstatic char tp[maxn];\n\tstatic int tt;\n\tmemset(tar, -1, sizeof tar);\n\twhile(scanf(\"%s%d\", tp, &tt) == 2) {\n\t\tif(tar[*tp - 'a' + 1] != -1 && tar[*tp - 'a' + 1] != tt) exit((puts(\"No\"), 0));\n\t\ttar[*tp - 'a' + 1] = tt;\n\t}\n\tfor(int i = 1; i <= 26; i++) if(!~tar[i]) tar[i] = 0;\n}\ninline bool test(int sta) {\n\tmemset(pts + 1, 0, (sizeof(int)) * 26);\n\tfor(int i = 27, cur; i <= cnt; i++) {\n\t\tcur = sta & 1, sta >>= 1;\n\t\tif(cur) id[i] = id[lson[i]];\n\t\telse id[i] = id[rson[i]];\n\t\t++pts[id[i]];\n\t\tif(pts[id[i]] > tar[id[i]]) return 0;\n\t}\n\tfor(int i = 1; i <= 26; i++) if(pts[i] != tar[i]) return 0;\n\treturn 1;\n}\n\nint main() {\n\tscanf(\"%s\", in + 1), gen(), getTar();\n\tconst int fs = 1 << (cnt - 26);\n\tfor(int i = 0; i < fs; i++) if(test(i)) return puts(\"Yes\"), 0;\n\treturn puts(\"No\"), 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint ans = 1;\n\nmap<char, int> inputs;\n\nchar eval(State &a) {\n    char b, c;\n    if (*a == '[') {\n        a++;\n        b = eval(a);\n    }\n    else {\n        b = *a;\n        a++;\n    }\n    a++;\n    \n    if (*a == '[') {\n        a++;\n        c = eval(a);\n    }\n    else {\n        c = *a;\n        a++;\n    }\n    a++;\n    if (inputs[b] == 0 && inputs[c] == 0) {\n        ans = 0;\n    }\n    if (inputs[b] == 0) {\n        inputs[c]--;\n        return c;\n    }\n    if (inputs[c] == 0) {\n        inputs[b]--;\n        return b;\n    }\n    ans = 0;\n    return b;\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    char a;\n    int b;\n    while (cin >> a >> b) {\n        inputs[a] = b;\n    }\n    State now = s.begin();\n    now++;\n    eval(now);\n    for (auto i : inputs) {\n        if (i.second != 0) ans = 0;\n    }\n    if (ans == 1) {\n        cout << \"Yes\" << endl;\n    }\n    else {\n        cout << \"No\" << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//const ll mod = 1000000007;\n//const ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\n\nint alf[26];\n\nstring s;\nbool valid = true;\n\nint winner(int& i);\nint person(int& i);\nint winner(int &i) {\n\tif (s[i] == '[') {\n\t\ti++;\n\t\tint l = winner(i);\n\t\ti++;\n\t\tint r = winner(i);\n\t\ti++;\n\t\tif (alf[l] > 0 && alf[r] > 0) {\n\t\t\tvalid = false; return 0;\n\t\t}\n\t\telse if (alf[l] == 0 && alf[r] == 0) {\n\t\t\tvalid = false; return 0;\n\t\t}\n\t\telse if (alf[l] == 0) {\n\t\t\talf[r]--; return r;\n\t\t}\n\t\telse {\n\t\t\talf[l]--; return l;\n\t\t}\n\t}\n\telse {\n\t\treturn person(i);\n\t}\n}\nint person(int &i) {\n\treturn s[i++]-'a';\n}\n\nvoid solve() {\n\tcin >> s; int j = 0;\n\tint n = 0;\n\trep(i, s.length()) {\n\t\tif ('a' <= s[i] && s[i] <= 'z')n++;\n\t}\n\tchar t; int c;\n\trep(i, n) {\n\t\tcin >> t >> c;\n\t\talf[t - 'a'] = c;\n\t}\n\tint las = winner(j);\n\trep(i, 26) {\n\t\tif (alf[i])valid = false;\n\t}\n\tif (valid) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//init();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint v[26], cnt[26];\n\nchar rec(int &pos){\n    if(s[pos] >= 'a' && s[pos] <= 'z'){\n        return s[pos++];\n    }\n    char lhs, rhs, winner;\n    if(s[pos] == '['){\n        pos++;\n        lhs = rec(pos);\n    }\n    if(s[pos] == '-') pos++;\n    rhs = rec(pos);\n    pos++;\n    if(v[lhs-'a'] > cnt[lhs-'a']){\n        cnt[lhs-'a']++;\n        winner = lhs;\n    }\n    else{\n        cnt[rhs-'a']++;\n        winner = rhs;\n    }\n    return winner;\n}\n\nint main() {\n    cin >> s;\n    char a;\n    while(cin >> a) cin >> v[a-'a'];\n    int pos = 0;\n    rec(pos);\n    bool ok = true;\n    for(int i=0;i<26;i++){\n        ok &= cnt[i] == v[i];\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nstruct Tree\n{\n\tchar win;\n\tint winnum;\n};\nmap<int, Tree> tree;\nint numchar = 0;\nint hash1[2000];\nint res = 0;\nvoid judge(int i)\n{\n\tif (tree[i].win==0)\n\t{\n\t\tjudge(i * 2);\n\t\tjudge(i * 2 + 1);\n\t\tif (tree[i * 2].winnum&&tree[i * 2 + 1].winnum)\n\t\t\tres = 1;\n\t\tif (tree[i * 2].winnum < 0 || tree[i * 2 + 1].winnum < 0)\n\t\t\tres = 1;\n\t\tif (tree[i * 2].winnum > tree[i * 2 + 1].winnum)\n\t\t{\n\t\t\ttree[i].win = tree[i * 2].win;\n\t\t\ttree[i].winnum = tree[i * 2].winnum - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[i].win = tree[i * 2 + 1].win;\n\t\t\ttree[i].winnum = tree[i * 2 + 1].winnum - 1;\n\t\t}\n\t\tif (tree[i].winnum < 0)\n\t\t\tres = 1;\n\t\tif (i == 1 && tree[i].winnum)\n\t\t\tres = 1;\n\t}\n}\nint main()\n{\n\tstring str;\n\tcin >> str;\n\tint flag = 0;\n\tint now = 1;\n\tmemset(hash1, 0, sizeof(hash1));\n\tfor (int i = 0; i < str.size(); i++)\n\t{\n\t\tchar s = str[i];\n\t\tif (s == '[')\n\t\t{\n\t\t\tflag++;\n\t\t\tnow *= 2;\n\t\t}\n\t\telse if (s == '-')\n\t\t{\n\t\t\tnow += 1;\n\t\t}\n\t\telse if (s == ']')\n\t\t{\n\t\t\tnow /= 2;\n\t\t\ttree[now].win = 0;\n\t\t\ttree[now].winnum = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[now].win = s;\n\t\t\ttree[now].winnum = -1;\n\t\t\tnumchar++;\n\t\t\thash1[s - 'a'] = now;\n\t\t}\n\t\t//cout << now << endl;\n\t}\n\t//cout << numchar << endl;\n\tfor (int i = 0; i < numchar; i++)\n\t{\n\t\tchar c;\n\t\tint x;\n\t\tcin >> c >> x;\n\t\ttree[hash1[c - 'a']].winnum = x;\n\t}\n\tjudge(1);\n\tif (res)\n\t\tcout << \"No\" << endl;\n\telse\n\t\tcout << \"Yes\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nstruct {\n    Map<Char, Int> win;\n    String s;\n    Int i;\n    Bool valid;\n\n    Int expr() {\n        if (s[i] == '[') {\n            ++i;\n            Int a = expr();\n            ++i;\n            Int b = expr();\n            ++i;\n\n            if (a > b) std::swap(a, b);\n            if (a != 0) valid = false;\n            return b - 1;\n        } else {\n            return win[s[i++]];\n        }\n    }\n\n    void operator()() {\n        i = 0;\n        valid = true;\n        if (expr() != 0) valid = false;\n    }\n} parser;\n\nint main() {\n    std::cin >> parser.s;\n    Char c;\n    while (std::cin >> c) {\n        std::cin >> parser.win[c];\n    }\n\n    parser();\n    std::cout << (parser.valid ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nstring s;\nmap<char,int>M;\nint id;\nchar f()\n{\n\tchar a,b;\n\tif(s[id]=='[')\n\t{\n\t\tid++;\n\t\ta=f();\n\t}\n\telse a=s[id++];\n\tid++;\n\tif(s[id]=='[')\n\t{\n\t\tid++;\n\t\tb=f();\n\t}\n\telse b=s[id++];\n\tid++;\n\tif(M[a]>M[b])\n\t{\n\t\tM[a]--;\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\tM[b]--;\n\t\treturn b;\n\t}\n}\nmain()\n{\n\tcin>>s;\n\tchar a;int v;\n\twhile(cin>>a>>v)\n\t{\n\t\tM[a]=v;\n\t}\n\tid=1;\n\tf();\n\tfor(pair<char,int>p:M)\n\t{\n\t\tif(p.second!=0)\n\t\t{\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint V[26];\nbool flag = true;\n\n\nint solve(string &s, int b, int e){\n    if(flag == false) return -1;\n\n\t\n    if(e - b == 1) {\n\t\treturn s[b] - 'a';\n\t}\n\n    int x;\n\n    for(int i = b, d = 0; i < e; i++){\n        if(s[i] == '[') {\n            d++;\n        } else if(s[i] == ']') {\n            d--;\n        } else if(s[i] == '-') {\n            if(d ==  1) x = i;\n        }\n    }\n\t\n    int ch1 = solve(s, b+1, x);\n    int ch2 = solve(s, x+1, e-1);\n\t\n    if(ch1 == -1 || ch2 == -1) return -1;\n\t\n    if(!!V[ch1] == !!V[ch2]) {\n        flag = false;\n        return -1;\n    } else if(V[ch1]) {\n        V[ch1]--;\n\n        return ch1;\n    } else {\n        V[ch2]--;\n        return ch2;\n    }\n\n\t\n    return -1;\n}\n\nsigned main(){\n    string s;\n\n    cin>>s;\n\n    char a;\n    int v;\n\n    int N = 0;\n\n    for(int i = 0; i<  s.size(); i++){\n        if('a' <= s[i] && s[i] <= 'z') N++;\n    }\n\t\n    for(int i = 0; i < N; i++){\n\t\tif(!(cin>>a)) break;\n\t\t\n\t\tcin>>v;\n\t\t\n        V[a - 'a'] = v;\n    }\n\n    solve(s, 0, s.size());\n\t\n\tfor(int i = 0; i < 26; i++){\n\t\tif(V[i]) flag = false;\n\t}\n\n    if(flag == true) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else{\n    int f=0,le=0,ri=0;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x,p;\nchar c;\nmap<char,int>m;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='[')p++,res=bnf1(),p++;\n  else res=m[s[p++]];\n  return res;\n}\nint bnf1(){\n  int res=get_A();\n  while(s[p]=='-'){\n    int t=p++;\n    int x=get_A();\n    if(x&&res)flag++;\n    res=max(res,x)-1;\n  }\n  return res;\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  bnf1();\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL=long long;\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rep1(i,n) for(int i=1; i<n; i++)\n#define all(a) (a).begin(),(a).end();\n\nstring s;\nint id;\nmap<char,int>M;\nchar f()\n{\n  char a,b;\n  if(s[id]=='[')\n  {\n    id++;\n    a=f();\n  }\n  else\n  {\n    a=s[id];\n   }\n  id+=2;\n  if(s[id]=='[')\n  {\nid++;\nb=f();\n  }\n  else\n  {\n    b=s[id];\n  }\n  id++;\n  if(M[a]>M[b])\n  {\n    M[a]--;\n    return a;\n  }\n  else\n  {\n    M[b]--;\n    return b;\n  }\n}\n\n\nint main(){\n\n  cin>>s;\n  char c;\n  int v;\n  while(cin>>c>>v)\n  {\n    M[c]=v;\n  }\n  id=1;\n  f();\n  for(pair<char,int>p:M)\n  {\n    if(p.second!=0)\n    {\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2857.cc: Tournament Chart\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\n/* global variables */\n\nchar s[256];\nint vs[26];\n\n/* subroutines */\n\nint winner(char *(&cpt)) {\n  if (*cpt != '[') {\n    int w = *(cpt++) - 'a';\n    //printf(\"vs[%c]=%d\\n\", w + 'a', vs[w]);\n    return (vs[w] >= 0) ? w : -1;\n  }\n\n  cpt++; // '['\n  int w0 = winner(cpt);\n  if (w0 < 0) return -1;\n  cpt++; // '-'\n  int w1 = winner(cpt);\n  if (w1 < 0) return -1;\n  cpt++; // ']'\n\n  if (vs[w0] > 0 && vs[w1] == 0) {\n    vs[w0]--;\n    return w0;\n  }\n  if (vs[w0] == 0 && vs[w1] > 0) {\n    vs[w1]--;\n    return w1;\n  }\n  return -1;\n}\n\n/* main */\n\nint main() {\n  scanf(\"%s\", s);\n\n  memset(vs, -1, sizeof(vs));\n  char ai[2];\n  int vi;\n  while (scanf(\"%s%d\", ai, &vi) == 2)\n    vs[ai[0] - 'a'] = vi;\n\n  char *cpt = s;\n  int w = winner(cpt);\n  if (w >= 0 && vs[w] == 0) puts(\"Yes\");\n  else puts(\"No\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt c[26],n,f=1;\nstring s;\nInt dfs(Int l,Int r){\n  if(l+1==r){\n    return s[l]-'a';\n  }\n  assert(s[l]=='[');\n  assert(s[r-1]==']');\n  l++;r--;\n  Int o=0;\n  for(Int i=l;i<r;i++){\n    if(s[i]=='[') o++;\n    if(s[i]==']') o--;\n    if(o==0&&s[i]=='-'){\n      Int x=dfs(l,i);\n      Int y=dfs(i+1,r);\n      if(c[x]*c[y]||c[x]+c[y]==0){\n\tf=0;\n\treturn 0;\n      }\n      if(c[y]) swap(x,y);\n      c[x]--;\n      return x;\n    }\n  }\n}\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cin>>s;\n  n=0;\n  for(Int i=0;i<(Int)s.size();i++)\n    n+=isalpha(s[i]);\n  for(Int i=0;i<n;i++){\n    char x;\n    Int y;\n    cin>>x>>y;\n    c[x-'a']=y;\n  }\n  dfs(0,s.size());\n  for(Int i=0;i<26;i++) f&=(c[i]==0);\n  cout<<(f?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else{\n    int f=0,le=0,ri=0;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"NO\":\"YES\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <string>\n#include <map>\n#include <algorithm>\n\nchar parse(const std::string& s, size_t& i, std::map<char, int>& vic) {\n  if (islower(s[i])) return s[i++];\n\n  assert(s[i] == '[');\n  char c1=parse(s, ++i, vic);\n  assert(s[i] == '-');\n  char c2=parse(s, ++i, vic);\n  assert(s[i] == ']');\n  ++i;\n\n  if (vic[c1] == vic[c2]) throw 0;\n  if (vic[c1] > vic[c2]) std::swap(c1, c2);\n  if (vic[c1] != 0) throw 0;\n  --vic[c2];\n  return c2;\n}\n\nint main() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n\n  std::map<char, int> vic;\n  while (true) {\n    char a;\n    int v;\n    if (scanf(\" %c %d\", &a, &v) == EOF) break;\n    vic[a] = v;\n  }\n\n  std::string s=buf;\n  size_t i=0;\n  try {\n    if (vic[parse(s, i, vic)] != 0) throw 0;\n    puts(\"Yes\");\n  } catch (int) {\n    puts(\"No\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lambda(res,...) (function<res(__VA_ARGS__)>)[&](__VA_ARGS__) -> res\n#define method(name,res,...) function<res(__VA_ARGS__)> name = (function<res(__VA_ARGS__)>)[&](__VA_ARGS__) -> res\n#define foreach(i,n) for(auto &i:(n))\n\nusing namespace std;\n\nint alphabet_size(string str){\n\tint res= 0 ;\n\tforeach(i,str){\n\t\tif('a'<=i and i<='z')++res;\n\t}\n\treturn res;\n}\t\n\nint main(){\n\tstring str;\n\tcin >> str;\n\tmap<char,int> m;\n\tfor(int i = 0;i<alphabet_size(str);++i){\n\t\tchar c;\n\t\tint num;\n\t\tcin >> c >> num;\n\t\tm[c] = num;\n\t}\n\n\tmethod(func,int,string str){\n\t\tif(str.size()==1){\n\t\t\treturn m[str[0]];\n\t\t}\n\t\tint deapth = 0;\n\t\tint pos = 0;\n\t\tfor(int i=0;i<str.size();++i){\n\t\t\tif(str[i]=='['){\n\t\t\t\t++deapth;\n\t\t\t}else if(str[i]==']'){\n\t\t\t\t--deapth;\n\t\t\t}else if(deapth==1 and str[i]=='-'){\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint a = func(str.substr(1,pos-1));\n\t\tint b = func(str.substr(pos+1,str.size()-pos-2));\n\t\tif(min(a,b) or !max(a,b)){\n\t\t\tcout << \"No\" << endl;\n\t\t\texit(0);\n\t\t}\n\t\treturn max(a,b) - 1;\n\t};\n\tif(func(str)){\n\t\tcout << \"No\" << endl;\n\t}else{\n\t\tcout << \"Yes\" << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint cnt[30];\nint f=1;\n\nchar win(int l,int r){\n  if(l==r)return s[l];\n  int cnts=0;\n  int k;\n  for(int i=l+1;i<r;i++){\n    if(s[i]=='[')cnts++;\n    if(s[i]==']')cnts--;\n    if(cnts==0&&s[i]=='-'){\n      k=i;\n      break;\n    }\n  }\n  char a=win(l+1,k-1);\n  char b=win(k+1,r-1);\n  int p1=cnt[a-'a']--;\n  int p2=cnt[b-'a']--;\n  if(p1==0&&p2==0)f=0;\n  if(p1>0&&p2>0)f=0;\n  if(p1>0)return a;\n  if(p2>0)return b;\n  return 'a';\n}\n\nint main(){\n  cin>>s;\n  int n=0;\n  for(int i=0;i<s.size();i++)\n    if('a'<=s[i]&&s[i]<='z')n++;\n  \n  for(int i=0;i<n;i++){\n    char a;\n    int v;\n    cin>>a>>v;\n    cnt[a-'a']=v;\n  }\n\n  if(cnt[win(0,s.size()-1)-'a']!=0)f=0;\n  cout<<(f?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else{\n    int f=0,le=0,ri=0;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"NO\":\"YES\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nstring str;\nmap<char,int> w;\n\nchar winner(int &i){\n\tif(str[i] == '['){\n\t\tchar l = winner(++i);\n\t\tassert(str[i] == '-');\n\t\tchar r = winner(++i);\n\t\tassert(str[i] == ']');\n\t\ti++;\n//\t\tcerr << l << \":\" << w[l] << \" , \" << r << \":\" << w[r] << endl;\n\t\tif(l == 0  || r == 0)return 0;\n\t\tif(w[l] == 0){\n\t\t\tif(w[r] == 0)return 0;\n\t\t\tw[r]--;\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\tif(w[r] != 0)return 0;\n\t\t\tw[l]--;\n\t\t\treturn l;\n\t\t}\n\t}\n\tchar t = str[i];\n\ti++;\n\treturn t;\n}\n\nsigned main(){\n\tcin >> str;\n\tint n = 0;\n\tfor(auto e: str){\n\t\tif(isalpha(e) && w.find(e) == w.end()){\n\t\t\tn++;\n\t\t\tw[e] = 0;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tchar a;\n\t\tint v;\n\t\tcin >> a >> v;\n\t\tw[a] = v;\n\t}\n\tint tmp = 0;\n\tint cnt = 0;\n\tchar ret = winner(tmp);\n\tfor(auto e : w){\n//\t\tcerr << e.first << \",\" << e.second << endl;\n\t\tif(e.second != 0){\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(ret == 0 || cnt != 0){\n\t\tcout << \"No\" << endl;\n\t}\n\telse{\n\t\t\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x,p;\nchar c;\nmap<char,int>m;\nint bnf1();\nint get_A(){\n  int res=0;\n  if(s[p]=='[')p++,res=bnf1(),p++;\n  else res=m[s[p++]];\n  return res;\n}\nint bnf1(){\n  int res=get_A();\n  while(s[p]=='-'){\n    int t=p++;\n    int x=get_A();\n    if(x&&res)flag++;\n    if(!x&&!res)\n    res=max(res,x)-1;\n  }\n  return res;\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  bnf1();\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  string s;\n  cin>>s;\n  map<char,int> m;\n  vector<char> lis;\n  int n=0;\n  lp(i,s.size()){\n    if('a'<=s[i]&&s[i]<='z')n++;\n  }\n  lp(i,n){\n    char c;\n    int a;\n    cin>>c>>a;\n    m[c]=a;\n    lis.push_back(c);\n  }\n  while(true){\n    bool act=false;\n\n    lp(i,s.size()-4){\n      //cout<<i<<\" \"<<s<<endl;\n      if(i>=(int)s.size()-4)break;\n      if(s[i]=='['&&s[i+2]=='-'&&s[i+4]==']'){\n\tact=true;\n      }\n      else{\n\tcontinue;\n      }\n      char t1=s[i+1];\n      char t2=s[i+3];\n      string bef=s.substr(0,i);\n      string af=s.substr(i+5,s.size()-(i+5));\n      int a=m[t1];\n      int b=m[t2];\n      if(a==0){\n\tif(m[t2]==0){\n\t  cout<<\"No\"<<endl;\n\t  return 0;\n\t}\n\tm[t2]--;\n\ts=bef+t2;\n\ts=s+af;\n      }\n      else if(b==0){\n\tm[t1]--;\n\ts=bef+t1;\n\ts=s+af;\n      }\n      else{\n\tcout<<\"No\"<<endl;\n\treturn 0;\n      }\n    }\n    if(act)continue;\n    break;\n  }\n  if(s.size()!=1){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  lp(i,n){\n    if(m[lis[i]]==0)continue;\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  cout<<\"Yes\"<<endl;\n  return 0; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint bfs(int &p, string s, vector<int> &win){\n    if(s[p] != '['){\n        return s[p++];\n    }\n    int left = bfs(++p, s, win);\n    int right = bfs(++p, s, win);\n    p++;\n    if(left == -1 or right == -1) return -1;\n    if(win[left] != 0 and win[right] != 0) return -1;\n    if(win[left] == 0 and win[right] == 0) return -1;\n    if(win[left] == 0){\n        win[right]--;\n        return right;\n    }else{\n        win[left]--;\n        return left;\n    }\n}\n\nint main(){\n    string s;\n    cin >> s;\n    vector<int> win(256, 0);\n    char ch;\n    int winnum;\n    int n=0, sum=0;\n    while(cin >> ch >> winnum){\n        win[(int)ch] = winnum;\n        n++;\n        sum += winnum;\n    }\n    int p = 0;\n    if(sum != n-1 or bfs(p, s, win) == -1){\n        cout << \"No\" << endl;\n    }else{\n        cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint V[26];\nbool flag = true;\n\n\nint solve(string &s, int b, int e){\n    if(flag == false) return -1;\n\n\t\n    if(e - b == 1) {\n\t\treturn s[b] - 'a';\n\t}\n\n    int x;\n\n    for(int i = b, d = 0; i < e; i++){\n        if(s[i] == '[') {\n            d++;\n        } else if(s[i] == ']') {\n            d--;\n        } else if(s[i] == '-') {\n            if(d ==  1) x = i;\n        }\n    }\n\t\n    int ch1 = solve(s, b+1, x);\n    int ch2 = solve(s, x+1, e-1);\n\t\n    if(ch1 == -1 || ch2 == -1) return -1;\n\t\n    if(!!V[ch1] == !!V[ch2]) {\n        flag = false;\n        return -1;\n    } else if(V[ch1]) {\n        V[ch1]--;\n\n        return ch1;\n    } else {\n        V[ch2]--;\n        return ch2;\n    }\n\n\t\n    return -1;\n}\n\nsigned main(){\n    string s;\n\n    cin>>s;\n\n    char a;\n    int v;\n\n    int N = 0;\n\n    for(int i = 0; i<  s.size(); i++){\n        if('a' <= s[i] && s[i] <= 'z') N++;\n    }\n\t\n    for(int i = 0; i < N; i++){\n\t\tif(!(cin>>a)) break;\n\t\t\n\t\tcin>>v;\n\t\t\n        V[a - 'a'] = v;\n    }\n\n    solve(s, 0, s.size());\n\t\n\tfor(int i = 0; i < 26; i++){\n\t\tif(V[i]) flag = false;\n\t}\n\n    if(flag == true) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <numeric>\n#include <math.h>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <vector>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <complex>\n#define full(c) c.begin(), c.end()\n#define vector2d(name,type,h,w,init) vector<vector<type>> name(h,vector<type>(w,init)) \nconst int PRIME = 1000000007;\nconst int INT_INF = 2147483647;\nconst long long int LL_INF = 9223372036854775807;\nconst double PI = acos(-1);\nconst double EPS = 0.000000001;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\nusing namespace std;\n\nint main() {\n\tint i;\n\tstring s;\n\tmap<char, int> win;\n\tcin >> s;\n\twhile (1) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (cin.eof()) break;\n\t\tint n;\n\t\tcin >> n;\n\t\twin[c] = n;\n\t}\n\twhile (s.size() != 1) {\n\t\tint k, i;\n\t\tk = 0;\n\t\ti = 0;\n\t\twhile (s[k] != ']') k++;\n\t\twhile (s[k] != '[') k--;\n\t\tif (win[s[k + 1]] > win[s[k + 3]]) {\n\t\t\twin[s[k + 1]]--;\n\t\t\ts.replace(k, 5, s.substr(k + 1, 1));\n\t\t}\n\t\telse {\n\t\t\twin[s[k + 3]]--;\n\t\t\ts.replace(k, 5, s.substr(k + 3, 1));\n\t\t}\n\t}\n\ti = 0;\n\tfor (auto d : win) {\n\t\tif (d.second != 0) break;\n\t\ti++;\n\t}\n\tif (i == win.size()) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else if(l==r){\n    return m[s[l]];\n  }\n  else{\n    int f=0,le=0,ri=0;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"No\":\"Yes\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge;\n\nint main(){\n  string s;\n  cin>>s;\n  int a[26];\n  int count =0;\n  lp(i,s.size()){\n    if('a'<=s[i]&&s[i]<='z'){\n      count++;\n    }\n  }\n  lp(i,count){\n    char c;\n    int hoge;\n    cin>>c>>hoge;\n    a[c-'a']=hoge;\n  }\n  int stat=0;\n  while(s.size()!=1){\n    lp(i,s.size()){\n      if(i==0) continue;\n      if(s[i-1]=='['&&'a'<=s[i]&&s[i]<='z'&&s[i+3]==']'){\n\tstring bef=s.substr(0,i-1);\n\tstring cont=s.substr(i-1,5);\n\tstring aft=s.substr(i+4,s.size()-i+5);\n\tint x,y;\n\tx=a[cont[1]-'a'];\n\ty=a[cont[3]-'a'];\n\tif(x==0){\n\t  a[cont[3]-'a']--;\n\t  cont=cont.substr(3,1);\n\t}\n\telse if(y==0){\n\t  a[cont[1]-'a']--;\n\t  cont=cont.substr(1,1);\n\t}\n\telse stat=1;\n\ts=bef+cont+aft;\n\tif(stat==1) break;\n      }\n    }\n    if(stat==1) break;\n  }\n  if(stat==1||a[s[0]-'a']!=0) cout<<\"No\"<<endl;\n  else cout<<\"Yes\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lambda(res, ...) (function<res(__VA_ARGS__)>)[&](__VA_ARGS__)->res\n#define method(name, res, ...)                                                 \\\n  function<res(__VA_ARGS__)> name = lambda(res, __VA_ARGS__)\n#define foreach(i,n) for(auto&i:(n))\n\nusing namespace std;\n\nint main(){\n  string str;\n  cin >> str;\n  map<char,int> m;\n  int n = 0;\n  foreach(i,str){\n    if('a'<=i and i <= 'z')++n;\n  }\n\n  for(int i=0;i<n;++i){\n    char ch;\n    int num;\n    cin >> ch >> num;\n    m[ch] = num;\n  }\n\n  method(func,int,string str){\n    if(str.size()==1){\n      return m[str[0]];\n    }\n    int pos;\n    int nest = 0;\n    for(int i=0;i<str.size();++i){\n      if(str[i]=='[')++nest;\n      if(str[i]==']')--nest;\n      if(nest==1 and str[i]=='-'){\n        pos = i;\n        break;\n      }\n    }\n    int a = func(str.substr(1,pos-1));\n    int b = func(str.substr(pos+1, str.size()-pos-2));\n    if(min(a,b) or max(a,b)==0){\n      cout << \"No\" << endl;\n      exit(0);\n    }\n    return max(a,b) - 1;\n  };\n\n  cout << (func(str)?\"No\":\"Yes\") << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else{\n    int f=0,le=0,ri=0i;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"NO\":\"YES\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\nint n,len;\nint cnt[30];\nchar s[100010];\nint solve(int l,int r)\n{\n\tif(l==r)\n\t\treturn s[l]-'a'+1;\n\tif(r-l+1==5)\n\t{\n\t\tint x=s[l+1]-'a'+1,y=s[r-1]-'a'+1;\n\t\tif(!cnt[x]&&!cnt[y])\n\t\t\treturn -1;\n\t\tif(cnt[x]&&cnt[y])\n\t\t\treturn -1;\n\t\tif(cnt[x])\n\t\t{\n\t\t\tcnt[x]--;\n\t\t\treturn x;\n\t\t}\n\t\tcnt[y]--;\n\t\treturn y;\n\t}\n\tint pos=l+1,id=0;\n\tif(s[pos]=='[')\n\t\tid++;\n\twhile(id)\n\t{\n\t\tpos++;\n\t\tif(s[pos]=='[')\n\t\t\tid++;\n\t\tif(s[pos]==']')\n\t\t\tid--;\n\t}\n\tint x=solve(l+1,pos),y=solve(pos+2,r-1);\n\tif(x==-1||y==-1)\n\t\treturn -1;\n\tif(!cnt[x]&&!cnt[y])\n\t\t\treturn -1;\n\tif(cnt[x]&&cnt[y])\n\t\t\treturn -1;\n\tif(cnt[x])\n\t{\n\t\t\tcnt[x]--;\n\t\t\treturn x;\n\t}\n\tcnt[y]--;\n\treturn y;\n}\nint main()\n{\n\tscanf(\"%s\",&s[1]);\n\tlen=strlen(&s[1]);\n\tfor(int i=1; i<=len; i++)\n\t\tif(s[i]>='a'&&s[i]<='z')\n\t\t\tn++;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tchar ch=getchar();\n\t\twhile(ch<'a'||ch>'z')\n\t\t\tch=getchar();\n\t\tint num=0;\n\t\tscanf(\"%d\",&num);\n\t\tcnt[ch-'a'+1]=num;\n\t}\n\tif(solve(1,len)==-1)\n\t\tputs(\"No\");\n\telse\n\t{\n\t\tfor(int i=1; i<=26; i++)\n\t\t\tif(cnt[i])\n\t\t\t{\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\t\t\n\t\t\t}\n\t\tputs(\"Yes\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s;\nint n,flag,x;\nchar c;\nmap<char,int>m;\nint make_tree(int l,int r,int depth){\n  if((r-l)==3){\n    if(m[s[l+1]]&&m[s[r-1]])flag++;\n    return max(m[s[l+1]],m[s[r-1]])-1;\n  }\n  else if(l==r){\n    return m[s[l]];\n  }\n  else{\n    int f=0,le=0,ri=0;\n    for(int i=l+1;i<=r;i++){\n      if(s[i]=='[')f++;\n      if(s[i]==']')f--;\n      if(f==0){\n\tle=make_tree(l+1,i,depth+1);\n\tri=make_tree(i+1,r-1,depth+1);\n\tbreak;\n      }\n    }\n    if(le&&ri)flag++;\n    if(!le&&ri-1!=depth)flag++;\n    if(le-1!=depth&&!ri)flag++;\n    return max(le,ri)-1;\n  }\n}\nint main(){\n  cin>>s;\n  set<char>st;\n  r(i,s.size())if(isalpha(s[i]))st.insert(s[i]);\n  r(i,(int)s.size())if(s[i]=='-')s.erase(s.begin()+i),i--;\n  n=st.size();\n  r(i,n){\n    cin>>c>>x;\n    m[c]=x;\n  }\n  make_tree(0,s.size()-1,0);\n  cout<<(flag?\"NO\":\"YES\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(string S, vector<pair<char, vector<int>>> &c, int &N){\n  if (S[0] != '['){\n    c.back().first = S[0];\n    N++;\n  } else {\n    int L = S.size();\n    int cnt = 0;\n    int p = 0;\n    for (int i = 0; i < L; i++){\n      if (S[i] == '['){\n        cnt++;\n      }\n      if (S[i] == ']'){\n        cnt--;\n      }\n      if (S[i] == '-' && cnt == 1){\n        p = i;\n        break;\n      }\n    }\n    int v = c.size() - 1;\n    c[v].second.push_back(c.size());\n    c.push_back(make_pair(' ', vector<int>(0)));\n    dfs(S.substr(1, p), c, N);\n    c[v].second.push_back(c.size());\n    c.push_back(make_pair(' ', vector<int>(0)));\n    dfs(S.substr(p + 1, L - 1), c, N);\n  }\n}\nint main(){\n  string S;\n  cin >> S;\n  vector<pair<char, vector<int>>> c;\n  c.push_back(make_pair(' ', vector<int>(0)));\n  int N = 0;\n  dfs(S, c, N);\n  map<char, int> mp;\n  for (int i = 0; i < N; i++){\n    char a;\n    int v;\n    cin >> a >> v;\n    mp[a] = v;\n  }\n  int M = c.size();\n  vector<int> p(M, -1);\n  for (int i = 0; i < M; i++){\n    for (int j : c[i].second){\n      p[j] = i;\n    }\n  }\n  vector<int> cnt(M, 0);\n  bool ok = true;\n  for (int i = 0; i < M; i++){\n    if (c[i].first != ' '){\n      int v = i;\n      int n = mp[c[i].first];\n      cnt[v]++;\n      for (int j = 0; j < n; j++){\n        if (v == 0){\n          ok = false;\n          break;\n        }\n        v = p[v];\n        cnt[v]++;\n      }\n    }\n  }\n  for (int i = 0; i < M; i++){\n    if (cnt[i] != 1){\n      ok = false;\n    }\n  }\n  if (ok){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2857: Tournament Chart\n// 2018.1.5 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r; char p; } T;\t\t// left node, right node, person\nT tbl[60]; int sz;\nchar s[200];\nint n;\nint a[27];\t\t\t//  won time\n\nvoid tree(int i, char *p)\n{\n\tint c;\n\n\tif (*p >= 'a' && *p <= 'z') {\n\t\ttbl[i].p = c = *p-'a'+1;\n\t\tn++;\n\t\treturn;\n\t}\n\ttbl[i].l = sz++, tree(sz-1, ++p);\n\tif (*p == '[') {\n\t\tc = 1; while (1) {\n\t\t\tif    (*++p == '[') c++;\n\t\t\telse if (*p == ']') c--;\n\t\t\tif (!c) break;\n\t\t}\n\t}\n\ttbl[i].r = sz++, tree(sz-1, p+2);\n}\n\nint check(int i)\n{\n\tint l, r;\n\tchar lp, rp;\n\n\tl = tbl[i].l, r = tbl[i].r;\n\tif (tbl[l].p == 0) { if (!check(l)) return 0; }\n\tif (tbl[r].p == 0) { if (!check(r)) return 0; }\n\tlp = tbl[l].p, rp = tbl[r].p; \n\tif      (a[lp] == 0) { tbl[i].p = rp; if (--a[rp] < 0) return 0; return 1; }\n\telse if (a[rp] == 0) { tbl[i].p = lp; if (--a[lp] < 0) return 0; return 1; }\n\treturn 0;\n}\n\nint main()\n{\n\tint i, v;\n\tchar b[5];\n\n\tscanf(\"%s\", s);\n\tn = 0, sz = 1;\n\ttree(0, s);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s%d\", b, &v);\n\t\ta[*b-'a'+1] = v;\n\t}\n\n\tputs(check(0) && a[tbl[0].p] == 0? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2857: Tournament Chart\n// 2018.1.5 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r; char p; } T;\t\t// left node, right node, person\nT tbl[60]; int sz;\nchar s[200];\nint n;\nint a[27];\t\t\t//  won time\n\nvoid tree(int i, char *p)\n{\n\tint c;\n\n\tif (*p >= 'a' && *p <= 'z') {\n\t\ttbl[i].p = c = *p-'a'+1;\n\t\tn++;\n\t\treturn;\n\t}\n\ttbl[i].l = sz++, tree(sz-1, ++p);\n\tif (*p == '[') {\n\t\tc = 1; while (1) {\n\t\t\tif    (*++p == '[') c++;\n\t\t\telse if (*p == ']') c--;\n\t\t\tif (!c) break;\n\t\t}\n\t}\n\ttbl[i].r = sz++, tree(sz-1, p+2);\n}\n\nint check(int i)\n{\n\tint l, r;\n\tchar lp, rp;\n\n\tl = tbl[i].l, r = tbl[i].r;\n\tif (tbl[l].p == 0) { if (!check(l)) return 0; }\n\tif (tbl[r].p == 0) { if (!check(r)) return 0; }\n\tlp = tbl[l].p, rp = tbl[r].p; \n\tif      (a[lp] == 0) { tbl[i].p = rp; if (--a[rp] < 0) return 0; return 1; }\n\telse if (a[rp] == 0) { tbl[i].p = lp; if (--a[lp] < 0) return 0; return 1; }\n\treturn 0;\n}\n\nint main()\n{\n\tint i, v;\n\tchar b[5];\n\n\tscanf(\"%s\", s);\n\tn = 0, sz = 1;\n\ttree(0, s);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%s%d\", b, &v);\n\t\ta[*b-'a'+1] = v;\n\t}\n\n\tputs(check(0)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\npublic static class P\n{\n    public static void Main()\n    {\n        var s = Console.ReadLine();\n        int n = s.Count(x => char.IsLetter(x));\n        var tournament = Node.Parse(s) as Tournament;\n        int[] wins = new int[26];\n        for (int i = 0; i < n; i++)\n        {\n            var av = Console.ReadLine().Split();\n            var a = av[0][0] - 'a';\n            var v = int.Parse(av[1]);\n            wins[a] = v;\n        }\n        foreach (var person in tournament.People())\n        {\n            var win = wins[person.ID];\n            var current = person as Node;\n            for (int i = 0; i <= win; i++)\n            {\n                if (current == null || current.Winner != null) goto end;\n                current.Winner = person;\n                current = current.Parent;\n            }\n        }\n        if (Node.Fixed(tournament)) \n        {\n            Console.WriteLine(\"Yes\");\n            return;\n        }\n        \n        end:;\n        Console.WriteLine(\"No\");\n    }\n}\n\nclass Node\n{\n    public Tournament Parent;\n    public Person Winner;\n    public static bool Fixed(Node node)\n    {\n        if (node is Person) return true;\n        var tournament = node as Tournament;\n        return tournament.Winner != null && Fixed(tournament.L) && Fixed(tournament.R);\n    }\n    public static Node Parse(string s)\n    {\n        if (!(s[0] == '[')) return new Person() { ID = s[0] - 'a' };\n        var depth = 0;\n        Node l = null;\n        Node r = null;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (s[i] == '[') depth++;\n            else if (s[i] == ']') depth--;\n            else if (s[i] == '-' && depth == 1)\n            {\n                l = Parse(s.Substring(1, i - 1));\n                r = Parse(s.Substring(i + 1, s.Length - i - 2));\n            }\n        }\n        var res = new Tournament() { L = l, R = r };\n        res.L.Parent = res;\n        res.R.Parent = res;\n        return res;\n    }\n}\n\nclass Tournament : Node\n{\n    public Node L;\n    public Node R;\n    public IEnumerable<Person> People()\n    {\n        IEnumerable<Person> l;\n        if (L is Person) l = new[] { L as Person };\n        else l = (L as Tournament).People();\n        IEnumerable<Person> r;\n        if (R is Person) r = new[] { R as Person };\n        else r = (R as Tournament).People();\n        return l.Concat(r);\n    }\n}\n\nclass Person : Node\n{\n    public int ID;\n}\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs(a)\n\ta.map!{|e|e.is_a?(Array) ? dfs(e) : e}\n\tx,y=a.minmax\n\traise if x!=0\n\ty-1\nend\ns=gets.tr('-',',')\n$<.each{|e|s.sub!(*e.split)}\nputs dfs(eval s)==0?:Yes: :No rescue puts :No"
  },
  {
    "language": "Ruby",
    "code": "class MyException < Exception; end\n\nclass Player\n  def initialize(name)\n    @name\n    @win = 0\n  end\n\n  def -(other)\n    if @win == 0\n      raise MyException if other.win == 0\n      other.win -= 1\n      return other\n    end\n    if other.win == 0\n      @win -= 1\n      return self\n    end\n    raise MyException\n  end\n\n  attr_accessor :win\nend\n\n(?a..?z).each do |c|\n  eval \"#{c.upcase} = Player.new(?#{c})\"\nend\n\ns = gets.chomp.tr('a-z[]', 'A-Z()')\nwhile gets\n  c, k = $_.chomp.split\n  eval \"#{c.upcase}.win = #{k}\"\nend\n\nbegin\n  winner = eval s\n  puts winner.win == 0 ? 'Yes' : 'No'\nrescue MyException\n  puts 'No'\nend\n"
  },
  {
    "language": "Python",
    "code": "import re\n\ndef main():\n    s = input()\n    d = {}\n    n = len(re.findall(r'\\w', s))\n    for i in range(n):\n        a, v = input().split()\n        v = int(v)\n        d[a] = v\n\n    prog = re.compile(r'\\[(\\w)-(\\w)\\]')\n    m = prog.search(s)\n    while m is not None:\n        c1, c2 = m.group(1, 2)\n        if d[c1] == d[c2]:\n            print('No')\n            return 0\n\n        if d[c1] < d[c2]:\n            d[c2] -= 1\n            s = prog.sub(c2, s, 1)\n            if d[c1] != 0:\n                print('No')\n                return 0\n        else:\n            d[c1] -= 1\n            s = prog.sub(c1, s, 1)\n            if d[c2] != 0:\n                print('No')\n                return 0\n\n        m = prog.search(s)\n\n    if len(s) != 1:\n        print('No')\n    elif [0 for k, v in d.items() if v]:\n        print('No')\n    else:\n        print('Yes')\n    return 0\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    def parse_winner(s,i):\n        if s[i] == \"[\":\n            i += 1\n            w1, i = parse_winner(s,i)\n            i += 1\n            w2, i = parse_winner(s,i)\n            return calc(w1, w2), i+1\n        else:\n            p, i = parse_person(s,i)\n            return p, i\n\n    def parse_person(s,i):\n        return s[i], i+1\n\n    def calc(w1,w2):\n        if f[w1] == 0:\n            if f[w2] == 0:\n                return \"0\"\n            else:\n                f[w2] -= 1\n                return w2\n        else:\n            if f[w2] != 0:\n                return \"0\"\n            else:\n                f[w1] -= 1\n                return w1\n\n    s = S()\n    k = 0\n    for i in s:\n        if i not in \"[-]\":\n            k += 1\n    f = defaultdict(int)\n    f[\"0\"] = 100000\n    for i in range(k):\n        a,b = input().split()\n        f[a] = int(b)\n    w = parse_winner(s,0)[0]\n    if f[w]:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n    return\n\n#B\ndef B():\n    n,k = LI()\n    s = S()\n    t = S()\n    q = deque()\n    ans = 0\n    for i in range(n):\n        if s[i] == \"B\" and t[i] == \"W\":\n            if q:\n                x = q.popleft()\n                if i-x >= k:\n                    ans += 1\n                    while q:\n                        q.popleft()\n            q.append(i)\n    if q:\n        ans += 1\n    for i in range(n):\n        if s[i] == \"W\" and t[i] == \"B\":\n            if q:\n                x = q.popleft()\n                if i-x >= k:\n                    ans += 1\n                    while q:\n                        q.popleft()\n            q.append(i)\n    if q:\n        ans += 1\n    print(ans)\n    return\n\n#C\ndef C():\n    n = I()\n    s = SR(n)\n    t = S()\n\n    return\n\n#D\nfrom operator import mul\ndef D():\n    def dot(a,b):\n        return sum(map(mul,a,b))\n    def mul_matrix(a,b,m):\n        tb = tuple(zip(*b))\n        return [[dot(a_i,b_j)%m for b_j in tb] for a_i in a]\n\n    def pow_matrix(a,n,m):\n        h = len(a)\n        b = [[1 if i == j else 0 for j in range(h)] for i in range(h)]\n        k = n\n        while k:\n            if (k&1):\n                b = mul_matrix(b,a,m)\n            a = mul_matrix(a,a,m)\n            k >>= 1\n        return b\n    while 1:\n        n,m,a,b,c,t = LI()\n        if n == 0:\n            break\n        s = LI()\n        s2 = [[s[i] for j in range(1)] for i in range(n)]\n        mat = [[0 for j in range(n)] for i in range(n)]\n        mat[0][0] = b\n        mat[0][1] = c\n        for i in range(1,n-1):\n            mat[i][i-1] = a\n            mat[i][i] = b\n            mat[i][i+1] = c\n        mat[n-1][-2] = a\n        mat[n-1][-1] = b\n        mat = pow_matrix(mat,t,m)\n        mat = mul_matrix(mat,s2,m)\n        for i in mat[:-1]:\n            print(i[0],end = \" \")\n        print(mat[-1][0])\n    return\n\n\n#E\ndef E():\n    def surface(x,y,z):\n        return ((x == 0)|(x == a-1))+((y == 0)|(y == b-1))+((z == 0)|(z == c-1))+k\n\n    d = [(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)]\n    a,b,c,n = LI()\n    s = [0 for i in range(7)]\n    k = (a==1)+(b==1)+(c==1)\n    if k == 0:\n        s[1] = 2*(max(0,a-2)*max(0,b-2)+max(0,c-2)*max(0,b-2)+max(0,a-2)*max(0,c-2))\n        s[2] = 4*(max(0,a-2)+max(0,b-2)+max(0,c-2))\n        s[3] = 8\n    elif k == 1:\n        s[2] = max(0,a-2)*max(0,b-2)+max(0,c-2)*max(0,b-2)+max(0,a-2)*max(0,c-2)\n        s[3] = 2*(max(0,a-2)+max(0,b-2)+max(0,c-2))\n        s[4] = 4\n    elif k == 2:\n        s[4] = max(0,a-2)+max(0,b-2)+max(0,c-2)\n        s[5] = 2\n    else:\n        s[6] = 1\n    f = defaultdict(int)\n    for i in range(n):\n        x,y,z = LI()\n        s[surface(x,y,z)] -= 1\n        f[(x,y,z)] = -1\n        for dx,dy,dz in d:\n            if f[(x+dx,y+dy,z+dz)] != -1:\n                f[(x+dx,y+dy,z+dz)] += 1\n    ans = 0\n    for i,j in f.items():\n        if j != -1:\n            x,y,z = i\n            if 0 <= x < a and 0 <= y < b and 0 <= z < c:\n                ans += j+surface(x,y,z)\n                s[surface(x,y,z)] -= 1\n    for i in range(1,7):\n        ans += i*s[i]\n    print(ans)\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    A()\n\n"
  }
]