[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int W, H, N;\n    vector<string> F;\n\n    bool input() {\n        cin >> W >> H >> N;\n        if (W == 0 && H == 0 && N == 0) return false;\n        string s; getline(cin, s);\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) getline(cin, F[i]);\n        return true;\n    }\n    \n    struct Point {\n        int y, x;\n        Point() {}\n        Point(int y, int x) : y(y), x(x) {}\n    };\n    bool operator==(const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }\n    bool operator<(const Point& a, const Point& b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }\n    ostream& operator<<(ostream& os, const Point& a) { return os << \"Point(\" << a.x << \",\" << a.y << \")\"; }\n\n    vector<Point> start, goal;\n\n    void init() {\n        start.resize(N);\n        goal.resize(N);\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c = F[i][j];\n                if (islower(c)) {\n                    start[ c - 'a' ] = Point(i, j);\n                } else if (isupper(c)) {\n                    goal[ c - 'A' ] = Point(i, j);\n                }\n            }\n        }\n    }\n\n    struct State {\n        vector<Point> ps;\n        int t;\n        State() { ps.clear(); ps.resize(N); }\n        State(const vector<Point>& ps, int t) : ps(ps), t(t) {}\n    };\n\n    const int dy[] = {-1, 0, 1, 0, 0},\n              dx[] = {0, 1, 0, -1, 0};\n\n    bool check(const State& prev, const State& next) {\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (i != j && next.ps[i] == next.ps[j]) return false;\n                if (i != j && prev.ps[i] == next.ps[j] && prev.ps[j] == next.ps[i]) return false;\n            }\n        }\n        return true;\n    }\n\n    int encode(const vector<Point>& ps);\n    bitset<(1<<24) + 1> D;\n    void genNextState(const State& c, queue<State>& Q, State next, int index = 0 ) {\n        if (index == N) {\n            if (!check(c, next)) return;\n            int h = encode(next.ps);\n            if (D[h]) return;\n            D[h] = true;\n            Q.push(next);\n            return;\n        }\n        for (int i = 0; i < 5; i++) {\n            int ny = c.ps[index].y + dy[i];\n            int nx = c.ps[index].x + dx[i];\n            if (F[ny][nx] == '#') continue;\n            next.ps[index] = Point(ny, nx);\n            genNextState(c, Q, next, index + 1);\n        }\n    }\n\n    int encode(const vector<Point>& ps) {\n        int r = 0;\n        for (int i = 0; i < N; i++) {\n            const Point& p = ps[i];\n            r += (p.y << (i * 8));\n            r += (p.x << (i * 8 + 4));\n        }\n        return r;\n    }\n\n    const int INF = 1<<29;\n\n    void solve() {\n        init();\n        D.reset();\n        queue<State> Q;\n        Q.push(State(start, 0));\n        D[encode(start)] = true;\n        while (!Q.empty()) {\n            State c = Q.front(); Q.pop();\n            if (c.ps == goal) {\n                cout << c.t << endl;\n                break;\n            }\n            State stub; stub.t = c.t + 1;\n            genNextState(c, Q, stub);\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n// [0, n) ??? m ???\nvector<vector<int>> generate_duplicate_permutation(int n, int m) {    \n    if(m == 0) return {{}};\n    vector<vector<int>> res;\n    rep(i, n) {\n        auto tmp = generate_duplicate_permutation(n, m - 1);\n        rep(j, tmp.size()) {\n            tmp[j].push_back(i);\n            res.emplace_back(move(tmp[j]));\n        }\n    }\n    return res;\n}\nstruct State {\n    array<int, 3> xs, ys;\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\narray<short, 1 << 24> dist;\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n\n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>&xs, vector<int>&ys) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>&xs, vector<int>&ys, const int value) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tfor (int k = 0; k < 15; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 15; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 15; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 15; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(3);\n\t\tgy.resize(3);\n\t\tfor (int i = N; i < 3; ++i) {\n\t\t\tgx[i] = 0;\n\t\t\tgy[i] = 0;\n\t\t}\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx]) {\n\t\t\t\t\t\taok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!aok)continue;\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))continue;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\ts.clear();\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\twhile(!q.empty()) q.pop();\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nint cost[3][16][16];\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;;\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<ghost>& S,int now,int n){\n  if ( n == now){\n    if ( dest.legal(source) && S.find(dest.data) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n\t\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<ghost> S;\n  S.insert(ini);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n  /*\n  cout << \"bfs for \" << num<< \" th ghoast\" << endl;\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      if ( cost[num][i][j] == INF)cout << \"x  \";\n      else cout << cost[num][i][j] << \"  \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nP goal[MAX_N];\nP start[MAX_N];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nvoid move(State& s, const State& prev, int k, map<int, int>& dist, priority_queue<State>& que){\n  if(k == 0) s.d++;\n  if(k == N){\n    if(!valid(s, prev)) return;\n    int h = 0;\n    REP(i, N){\n      h = max(h, calc_distance(s.p[i], goal[i]));\n    }\n    s.f = s.d + h;\n    add(s, dist, que);\n  }else{\n    REP(r, 5){\n      if(valid(s.p[k].first + dx[r], s.p[k].second + dy[r], W, H)){\n        s.p[k].first += dx[r];\n        s.p[k].second += dy[r];\n        move(s, prev, k + 1, dist, que);\n        s.p[k].first -= dx[r];\n        s.p[k].second -= dy[r];\n      }\n    }\n  }\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n    //  print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      State ss = s;\n\n      move(s, ss, 0, dist, que);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct P{\n  int ay,ax,by,bx,cy,cx,cost;\n  P(int a1,int a2,int b1,int b2,int c1,int c2,int c){\n    ax=a1;ay=a2;\n    bx=b1;by=b2;\n    cx=c1;cy=c2;\n    cost=c;\n  }\n};\n\nint h,w,n,gx[3],gy[3],sx[3],sy[3];\nstring s[14],iranai;\nbool used[14][14][14][14][14][14];\nint dx[]={1,0,-1,0,0};\nint dy[]={0,1,0,-1,0};\n\nint BFS(){\n  memset(used,0,sizeof(used));\n  queue<P>q;\n  q.push(P(sx[0],sy[0],sx[1],sy[1],sx[2],sy[2],0));\n  used[sx[0]][sy[0]][sx[1]][sy[1]][sx[2]][sy[2]]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int ay=p.ay;\n    int ax=p.ax;\n    int by=p.by;\n    int bx=p.bx;\n    int cy=p.cy;\n    int cx=p.cx;\n    int cost=p.cost;\n    if(ay==gy[0]&&ax==gx[0]&&by==gy[1]&&bx==gx[1]&&cy==gy[1]&&cx==gx[2])return cost;\n    for(int i=0;i<5;i++){\n      int Ay=ay+dy[i];\n      int Ax=ax+dx[i];\n      if(Ay<0||Ax<0||Ay>=h||Ax>=w)continue;\n      if(s[Ay][Ax]=='#')continue;\n      if(n>=2){\n\n        for(int j=0;j<5;j++){\n          int By=by+dy[j];\n          int Bx=bx+dx[j];\n          if(By<0||Bx<0||By>=h||Bx>=w)continue;\n          if(s[By][Bx]=='#')continue;\n          if(n>=3){\n\n            for(int j=0;j<5;j++){\n              int Cy=cy+dy[j];\n              int Cx=cx+dx[j];\n              if(Cy<0||Cx<0||Cy>=h||Cx>=w)continue;\n              if(s[Cy][Cx]=='#')continue;\n              if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n              if(Cx==bx&&Cy==by&&Bx==cx&&By==cy)continue;\n              if(Ax==cx&&Ay==cy&&Cx==ax&&Cy==ay)continue;\n              if(Ax==Bx&&Ay==By)continue;\n              if(Ax==Cx&&Ay==Cy)continue;\n              if(Cx==Bx&&Cy==By)continue;\n              if(!used[Ay][Ax][By][Bx][Cy][Cx]){\n                used[Ay][Ax][By][Bx][Cy][Cx]=1;\n                q.push(P(Ax,Ay,Bx,By,Cx,Cy,cost+1));\n              }\n            }\n\n          }\n          else{\n            if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n            if(Ax==Bx&&Ay==By)continue;\n            if(!used[Ay][Ax][By][Bx][cy][cx]){\n              used[Ay][Ax][By][Bx][cy][cx]=1;\n              q.push(P(Ax,Ay,Bx,By,cx,cy,cost+1));\n            }\n          }\n        }\n\n      }\n      else{\n        if(!used[Ay][Ax][by][bx][cy][cx]){\n          used[Ay][Ax][by][bx][cy][cx]=1;\n          q.push(P(Ax,Ay,bx,by,cx,cy,cost+1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h>>n,n){\n    memset(sy,0,sizeof(sy));\n    memset(sx,0,sizeof(sx));\n    memset(gx,0,sizeof(gx));\n    memset(gy,0,sizeof(gy));\n    getline(cin,s[0]);\n    getline(cin,s[0]);\n    r(i,h-2)getline(cin,s[i]);\n    getline(cin,iranai);\n    h-=2;w-=2;\n    r(i,h)s[i].erase(s[i].begin(),s[i].begin()+1);\n    r(i,h)s[i].erase(s[i].begin()+w);\n    r(i,h)r(j,w){\n      if(s[i][j]=='a')sy[0]=i,sx[0]=j;\n      if(s[i][j]=='b')sy[1]=i,sx[1]=j;\n      if(s[i][j]=='c')sy[2]=i,sx[2]=j;\n      if(s[i][j]=='A')gy[0]=i,gx[0]=j;\n      if(s[i][j]=='B')gy[1]=i,gx[1]=j;\n      if(s[i][j]=='C')gy[2]=i,gx[2]=j;\n    }\n    cout<<BFS()<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\nconstexpr int dx[5] = {-1, +0, +1, +0, +0};\nconstexpr int dy[5] = {+0, -1, +0, +1, +0};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nbool same(int x1, int y1, int x2, int y2)\n{\n    return (x1 == x2 && y1 == y2);\n}\n\nbool d[MAX_H][MAX_W][MAX_H][MAX_W][MAX_H][MAX_W];\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;\n    queue<int> qc;\n    \n    que.push(make_pair(sx, sy));    \n    qc.push(0);\n    \n    memset(d, 0, sizeof(d));\n    d[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]] = 1;\n\n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        int c = qc.front(); qc.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) return c;\n                \n        for (int i = 0; i < 5; i++) {            \n            int nx0 = csx[0] + dx[i], ny0 = csy[0] + dy[i];\n            if (field[ny0][nx0] == '#') continue;\n            for (int j = 0; j < 5; j++) {                \n                int nx1 = csx[1], ny1 = csy[1];\n                \n                if (N >= 2) {\n                    nx1 += dx[j]; ny1 += dy[j];\n                    if (field[ny1][nx1] == '#') continue;\n                    if (same(nx0, ny0, nx1, ny1)) continue;\n                    if (same(nx0, ny0, csx[1], csy[1]) && same(csx[0], csy[0], nx1, ny1)) continue;                \n                }\n                for (int k = 0; k < 5; k++) {\n                    int nx2 = csx[2], ny2 = csy[2];\n                    \n                    if (N >= 3) {\n                        nx2 += dx[k]; ny2 += dy[k];\n                        if (field[ny2][nx2] == '#') continue;\n                        if (same(nx0, ny0, nx2, ny2) || same(nx1, ny1, nx2, ny2)) continue;\n                        if (same(nx0, ny0, csx[2], csy[2]) && same(csx[0], csy[0], nx2, ny2)) continue;                \n                        if (same(nx1, ny1, csx[2], csy[2]) && same(csx[1], csy[1], nx2, ny2)) continue;                \n                    }\n                    \n                    vector<int> nx = {nx0, nx1, nx2}, ny = {ny0, ny1, ny2};                     \n                    if (!d[ny0][nx0][ny1][nx1][ny2][nx2]) {\n                        d[ny0][nx0][ny1][nx1][ny2][nx2] = 1;\n                        \n                        que.push(make_pair(nx, ny));\n                        qc.push(c + 1);\n                    }\n                }\n            }\n        }      \n    }    \n    return -1;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        while (sx.size() < 3) {\n            sx.emplace_back(0);\n            sy.emplace_back(0);\n            gx.emplace_back(0);\n            gy.emplace_back(0);\n        }\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\nS i2s(int x){\n  return S(x/2744,x%2744);\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first*2744)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+p.first[i]-1;\n    x=x*14+p.second[i]-1;\n  }\n  return S(y,x);\n}\n\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%14+1);\n    x.push_back(b%14+1);\n    a/=14;b/=14;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nshort m[7530000];\nqueue<int> q;\n\nvector<int> ys,xs;\n\nint calc(){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+ys[i]-1;\n    x=x*14+xs[i]-1;\n  }\n  return s2i(S(y,x));\n}\n\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    int abc=calc();\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tint x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tqueue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> w >> h >> n, w){\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tq = priority_queue<ll>();\n\t\ts.clear();\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n#pragma GCC target \"tune=native\"\n#pragma GCC target \"avx\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 10000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P start, P goal){\n  int& dist = memo[start.first][start.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  queue<P> que;\n  que.push(goal);\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    REP(r, 4){\n      P q = p;\n      q.first += dx[r];\n      q.second += dy[r];\n      if(!valid(q.first, q.second, W, H)) continue;\n      if(memo[q.first][q.second][goal.first][goal.second] != -1) continue;\n      memo[q.first][q.second][goal.first][goal.second] = memo[p.first][p.second][goal.first][goal.second] + 1;\n      que.push(q);\n    }\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\n\nS i2s(int x){\n  return S(x>>12,x&((1<<12)-1));\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first<<12)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*16+p.first[i];\n    x=x*16+p.second[i];\n  }\n  return S(y,x);\n}\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%16);\n    x.push_back(b%16);\n    a/=16;b/=16;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nchar m[1<<26];\nqueue<int> q;\n\nvector<int> ys,xs;\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    P r=P(ys,xs);\n    int abc=p2i(r);\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nint d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=(1e4);\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n      \t  if(!check(ncy,ncx)) continue;\n      \n\t  if(!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(nay==nby&&nax==nbx) continue;\n\t  if(nay==ncy&&nax==ncx) continue;\n\t  if(nby==ncy&&nbx==ncx) continue;\n\n\t  if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\t    q.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n\t  }\n      \n\t}\n      }\n    }\n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    if(n<=1){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][0]=(char)i;\n\t  s[0][1]=char('A'+i-'a');\n\t  by=0, bx=0;\n\t}\n    }\n    \n    if(n<=2){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][2]=(char)i;\n\t  s[0][3]=char('A'+i-'a');\n\t  cy=0, cx=2;\n\t}\n      \n    }\n    \n    memo.clear();\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint tm0;\nvector<int> q[2];\n\nbool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = (i + 8) % 24;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = (v >> j % 24) & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j % 24 & 255) &&\n\t\t\t\tp2 == (u >> i % 24 & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\tq[0].clear();\n\tq[1].clear();\n\tq[0].push_back(start);\n\n\tint tm = tm0 + 1;\n\tvis[start] = tm;\n\twhile(1){\n\t\tif(q[0].empty()){\n\t\t\tq[0].swap(q[1]);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tint u = q[0].back();\n\t\t\tq[0].pop_back();\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\tq[1].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tm = solve(start, goal);\n\t\tprintf(\"%d\\n\", tm - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define all(c) (c).begin(),(c).end()\n#define show(x) cout << #x << \" \" << x << endl\nstruct State{int ax,ay,bx,by,cx,cy;};\nstring s[16];\nint W,H,N,dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0},inf=1e4;\nint Ax,Ay,Bx,By,Cx,Cy,ax,ay,bx,by,cx,cy;\nshort int d[16][16][16][16][16][16];\nbool is(int x,int y){\n\treturn (0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#');\n}\nvoid three(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) rep(bi,H) rep(bj,W) rep(ci,H) rep(cj,W) d[ai][aj][bi][bj][ci][cj]=inf;\n\td[Ax][Ay][Bx][By][Cx][Cy]=0;\n\tque.push(State{Ax,Ay,Bx,By,Cx,Cy});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\trep(bd,5){\n\t\t\t\tint nbx=st.bx+dx[bd],nby=st.by+dy[bd];\n\t\t\t\tif(!is(nbx,nby)) continue;\n\t\t\t\trep(cd,5){\n\t\t\t\t\tint ncx=st.cx+dx[cd],ncy=st.cy+dy[cd];\n\t\t\t\t\tif(!is(ncx,ncy)) continue;\n\t\t\t\t\tif(d[nax][nay][nbx][nby][ncx][ncy]!=inf) continue;\n\t\t\t\t\tif(nax==nbx&&nay==nby) continue;\n\t\t\t\t\tif(nbx==ncx&&nby==ncy) continue;\n\t\t\t\t\tif(ncx==nax&&ncy==nay) continue;\n\t\t\t\t\tif(nax==st.bx&&nay==st.by&&nbx==st.ax&&nby==st.ay) continue;\n\t\t\t\t\tif(nbx==st.cx&&nby==st.cy&&ncx==st.bx&&ncy==st.by) continue;\n\t\t\t\t\tif(ncx==st.ax&&ncy==st.ay&&nax==st.cx&&nay==st.cy) continue;\n\t\t\t\t\td[nax][nay][nbx][nby][ncx][ncy]=d[st.ax][st.ay][st.bx][st.by][st.cx][st.cy]+1;\n\t\t\t\t\tque.push(State{nax,nay,nbx,nby,ncx,ncy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid two(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) rep(bi,H) rep(bj,W) d[ai][aj][bi][bj][0][0]=inf;\n\td[Ax][Ay][Bx][By][0][0]=0;\n\tque.push(State{Ax,Ay,Bx,By,0,0});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\trep(bd,5){\n\t\t\t\tint nbx=st.bx+dx[bd],nby=st.by+dy[bd];\n\t\t\t\tif(!is(nbx,nby)) continue;\n\t\t\t\tif(d[nax][nay][nbx][nby][0][0]!=inf) continue;\n\t\t\t\tif(nax==nbx&&nay==nby) continue;\n\t\t\t\tif(nax==st.bx&&nay==st.by&&nbx==st.ax&&nby==st.ay) continue;\n\t\t\t\td[nax][nay][nbx][nby][0][0]=d[st.ax][st.ay][st.bx][st.by][0][0]+1;\n\t\t\t\tque.push(State{nax,nay,nbx,nby,0,0});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid one(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) d[ai][aj][0][0][0][0]=inf;\n\td[Ax][Ay][0][0][0][0]=0;\n\tque.push(State{Ax,Ay,0,0,0,0});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\tif(d[nax][nay][0][0][0][0]!=inf) continue;\n\t\t\td[nax][nay][0][0][0][0]=d[st.ax][st.ay][0][0][0][0]+1;\n\t\t\tque.push(State{nax,nay,0,0,0,0});\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d\\n\",&W,&H,&N);\n\t\tif(W==0) break;\n\t\trep(i,H) getline(cin,s[i]);\n\t\tax=0,ay=0,bx=0,by=0,cx=0,cy=0;\n\t\trep(i,H) rep(j,W){\n\t\t\tif(s[i][j]=='A') Ax=i,Ay=j;\n\t\t\tif(s[i][j]=='B') Bx=i,By=j;\n\t\t\tif(s[i][j]=='C') Cx=i,Cy=j;\n\t\t\tif(s[i][j]=='a') ax=i,ay=j;\n\t\t\tif(s[i][j]=='b') bx=i,by=j;\n\t\t\tif(s[i][j]=='c') cx=i,cy=j;\n\t\t}\n\t\tif(N==3) three();\n\t\tif(N==2) two();\n\t\tif(N==1) one();\n\t\tcout<<d[ax][ay][bx][by][cx][cy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[14][14];\nint sx[3],sy[3];\nint gx[3],gy[3];\nint dp[196][196][196];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// forked from http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1587939#1\n#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n \nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n \narray<point_t,3> start, goal;\nint dist(const array<point_t, 3>& s, const array<point_t, 3>& t) {\n    int r = 0;\n    for (int i = 0; i < 3; i++) {\n        r += abs(s[i].x - t[i].x);\n        r += abs(s[i].y - t[i].y);\n    }\n    return r;\n}\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    bool operator<(const state_t& s) const {\n        if (cost == s.cost) {\n            return dist(a, goal) > dist(s.a, goal);\n        } else {\n            return cost > s.cost;\n        }\n    }\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n \nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n \n        assert (1 <= n and n <= 3);\n        //array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n \n        unordered_set<uint32_t> used;\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n// [0, n) ??? m ???\nvector<vector<int>> generate_duplicate_permutation(int n, int m) {    \n    if(m == 0) return {{}};\n    vector<vector<int>> res;\n    rep(i, n) {\n        auto tmp = generate_duplicate_permutation(n, m - 1);\n        rep(j, tmp.size()) {\n            tmp[j].push_back(i);\n            res.emplace_back(move(tmp[j]));\n        }\n    }\n    return res;\n}\nstruct State {\n    array<int, 3> xs, ys;\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\narray<int, 1 << 24> dist;\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n\n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 16 * 16 + 2;\n//const int IINF = INT_MAX;\nconst short IINF = 200;\n\nstruct Data {\n  int p[3],cost;\n  \n  bool operator < ( const Data &data ) const {\n    return cost > data.cost;\n  }\n};\n\n\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint w,h,n,gn,sn;\nchar c[20][20];\nshort mindist[MAX][MAX][MAX];\n\nint gs[3],sp[3];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nbool isValidMove(Data cur,Data next){\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == next.p[j] ) return false;\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == cur.p[j] && next.p[j] == cur.p[i] ) return false;\n  return true;\n}\n\nvoid printState(Data cur){\n  rep(i,h){\n    rep(j,w){\n      bool f = false;\n      rep(k,sn) if( cur.p[k] == j + i*w ) {\n\tcout << (char)('a'+k);\n\tf = true;\n\tbreak;\n      }\n      if( f ) continue;\n      cout << c[i][j];\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nvoid dfs(priority_queue<Data> &Q,int cur,Data state,int mask,Data prev){\n  if( cur >= sn ) {\n\n    if( isValidMove(prev,state) ) {\n\n      int A=MAX-1,B=MAX-1,C=MAX-1;\n      if( sn >= 1 ) A = state.p[0];\n      if( sn >= 2 ) B = state.p[1];\n      if( sn >= 3 ) C = state.p[2];\n      if( mindist[A][B][C] > state.cost ) {\n\tmindist[A][B][C] = state.cost;\n\tQ.push(state);\n      }\n\n    }\n    return;\n  }\n  if( !( ( mask >> cur ) & 1 ) ) {\n    dfs(Q,cur+1,state,mask,prev);\n    return;\n  }\n  int x = state.p[cur] % w, y = state.p[cur] / w;\n  rep(i,5){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( c[ny][nx] == '#' ) continue;\n    state.p[cur] = nx + ny * w;\n    dfs(Q,cur+1,state,mask,prev);\n  }\n  state.p[cur] = x + y * w;\n}\n\nvoid pushNextState(priority_queue<Data> &Q,int mask,int cost,Data cdata){\n  Data state = cdata;\n  ++state.cost;\n  dfs(Q,0,state,mask,cdata);\n}\n\n\n\nvoid compute(){\n  rep(i,MAX)rep(j,MAX)rep(k,MAX) mindist[i][j][k] = IINF;\n  gn = 0;\n  rep(i,h) rep(j,w) if( 'A' <= c[i][j] && c[i][j] <= 'C' ) {\n    gs[c[i][j]-'A'] = j + i * w;\n    c[i][j] = '.';\n    ++gn;\n  }\n\n  sn = 0;\n  rep(i,h) rep(j,w) if( 'a' <= c[i][j] && c[i][j] <= 'c' ) {\n    sp[c[i][j]-'a'] = j + i * w;\n    c[i][j] = '.';\n    ++sn;\n  }\n  priority_queue<Data> Q;\n  {\n    Data data;\n    data.cost = 0;\n    rep(i,sn) data.p[i] = sp[i];\n    Q.push(data);\n  }\n  bool found = false;\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n\n    bool fin = true;\n    rep(i,gn) if( gs[i] != data.p[i] ) {\n      fin = false;\n      break;\n    }\n    if( fin ) {\n      found = true;\n\n      printf(\"%d\\n\",data.cost);\n      return;\n    }\n    rep(mask,(1<<sn)){\n      pushNextState(Q,mask,data.cost,data);\n    }\n    \n  }\n  assert(found);\n}\n\nint main(){\n  while( cin >> w >> h >> n, w|h|n ){\n    cin.ignore();\n    rep(i,h) {\n      string s;\n      getline(cin,s);\n      rep(j,w) {\n\tif( s[j] == ' ' ) s[j] = '.';\n\tc[i][j] = s[j];\n      }\n    }\n\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <complex>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ninline double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ninline double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ninline int ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\ninline bool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ninline double distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<L> l;\n\t//set< pair<int,int> > S;\n\tif( n > 5150 ){\n\t\tprintf(\"%.10lf\\n\",0.0);\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tl.push_back(L(P(a,b),P(c,d)));\n\t}\n\trandom_shuffle(l.begin(),l.end());\n\tdouble ans = 1e10;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i + 1 ; j < n ; j++){\n\t\t\tans = min(ans,distanceSS(l[i],l[j]));\n\t\t\tif( ans < EPS ){\n\t\t\t\tprintf(\"%.10lf\\n\",ans);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< pair< int, int > > T;\n\nconst int vy[] = {0, 1, 0, -1, 0}, vx[] = {1, 0, -1, 0, 0};\n\nvector< vector< pair< int, int > > > vec;\n\nint W, H, N;\nstring S[16];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W || S[y][x] == '#');\n}\n\nvoid CreateVector(int sz, vector< pair< int, int > > &vs)\n{\n  if(sz == 0) {\n    vec.push_back(vs);\n    return;\n  }\n  for(int i = 0; i < 5; i++) {\n    int ny = vs[sz - 1].first + vy[i];\n    int nx = vs[sz - 1].second + vx[i];\n    if(isover(ny, nx)) continue;\n    vs[sz - 1].first += vy[i];\n    vs[sz - 1].second += vx[i];\n    CreateVector(sz - 1, vs);\n    vs[sz - 1].first -= vy[i];\n    vs[sz - 1].second -= vx[i];\n  }\n}\n\n\nint main()\n{\n\n\n  while(cin >> W >> H >> N, W) {\n    vector< char > nums;\n    cin.ignore();\n\n    for(int i = 0; i < H; i++) {\n      getline(cin, S[i]);\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) nums.push_back(S[i][j]);\n      }\n    }\n\n    sort(begin(nums), end(nums));\n\n    vector< pair< int, int > > vs(N), ans(N);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), S[i][j]) - begin(nums);\n          vs[q] = {i, j};\n        } else if(isupper(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), tolower(S[i][j])) - begin(nums);\n          ans[q] = {i, j};\n        }\n      }\n    }\n\n\n    map< T, int > v;\n    queue< T > que;\n    que.emplace(vs);\n    v[vs] = 0;\n\n    while(!que.empty()) {\n      auto p = que.front();\n      int cost = v[p];\n      que.pop();\n      if(p == ans) {\n        cout << cost << endl;\n        break;\n      }\n\n\n      vec.clear();\n      CreateVector(N, p);\n      for(auto &beet : vec) {\n        bool isok = true;\n        for(int i = 0; i < p.size(); i++) {\n          for(int j = 0; j < i; j++) {\n            isok &= beet[i] != p[j] || beet[j] != p[i];\n            isok &= beet[i] != beet[j];\n          }\n        }\n        if(isok && !v.count(beet)) {\n          que.emplace(beet);\n          v[beet] = cost + 1;\n        }\n      }\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\nconstexpr int dx[5] = {-1, +0, +1, +0, +0};\nconstexpr int dy[5] = {+0, -1, +0, +1, +0};\n\nint W, H, N;\n\ninline bool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline bool same(int& x1, int& y1, int& x2, int& y2)\n{\n    return (x1 == x2 && y1 == y2);\n}\n\nbool d[MAX_H][MAX_W][MAX_H][MAX_W][MAX_H][MAX_W];\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;\n    queue<int> qc;\n    \n    que.push(make_pair(sx, sy));    \n    qc.push(0);\n    \n    memset(d, 0, sizeof(d));\n    d[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]] = 1;\n\n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        int c = qc.front(); qc.pop();\n        auto& csx = f.first;\n        auto& csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) return c;\n                \n        for (int i = 0; i < 5; i++) {            \n            int nx0 = csx[0] + dx[i], ny0 = csy[0] + dy[i];\n            \n            if (field[ny0][nx0] == '#') continue;\n            \n            for (int j = 0; j < 5; j++) {                \n                int nx1 = csx[1], ny1 = csy[1];\n                \n                if (N >= 2) {\n                    nx1 += dx[j]; ny1 += dy[j];\n                    if (field[ny1][nx1] == '#') continue;\n                    if (same(nx0, ny0, nx1, ny1)) continue;\n                    if (same(nx0, ny0, csx[1], csy[1]) && same(csx[0], csy[0], nx1, ny1)) continue;                \n                }\n                \n                for (int k = 0; k < 5; k++) {\n                    int nx2 = csx[2], ny2 = csy[2];\n                    \n                    if (N >= 3) {\n                        nx2 += dx[k]; ny2 += dy[k];\n                        if (field[ny2][nx2] == '#') continue;\n                        if (same(nx0, ny0, nx2, ny2) || same(nx1, ny1, nx2, ny2)) continue;\n                        if (same(nx0, ny0, csx[2], csy[2]) && same(csx[0], csy[0], nx2, ny2)) continue;                \n                        if (same(nx1, ny1, csx[2], csy[2]) && same(csx[1], csy[1], nx2, ny2)) continue;                \n                    }\n                    \n                    vector<int> nx = {nx0, nx1, nx2}, ny = {ny0, ny1, ny2};                     \n                    if (!d[ny0][nx0][ny1][nx1][ny2][nx2]) {\n                        d[ny0][nx0][ny1][nx1][ny2][nx2] = 1;\n                        \n                        que.push(make_pair(nx, ny));\n                        qc.push(c + 1);\n                    }\n                }\n            }\n        }      \n    }    \n    return -1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        while (sx.size() < 3) {\n            sx.emplace_back(0);\n            sy.emplace_back(0);\n            gx.emplace_back(0);\n            gy.emplace_back(0);\n        }\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,0};\nconst int dy[8]={0,1,0,-1,0};\n\nconst int limit=1<<24;\nusing S=short int;\n\nS pre[3][limit];\nS dist[limit];\n\ninline int hstar(int n,int cmask,int tmask){\n\tint ret=0;\n\trep(i,n){\n\t\tint cur=(cmask>>(8*i))&255;\n\t\tchmax<int>(ret,pre[i][cur]);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint w,h,n;\n\t\n\twhile(cin >> w >> h >> n,n){\n\t\tint smask=0,tmask=0;\n\t\tstring board[16];\n\t\t\n\t\tcin.ignore();\n\t\trep(i,h) getline(cin,board[i]);\n\n\t\t// cout << w << \" \" << h << \" \" << n << endl;\n\t\t// rep(i,h) cout << board[i] << endl;\n\n\t\trep(i,h)rep(j,w)rep(k,3){\n\t\t\tif(board[i][j]==('a'+k)) smask|=((16*i+j)<<(8*k));\n\t\t\tif(board[i][j]==('A'+k)) tmask|=((16*i+j)<<(8*k));\n\t\t}\n\n\t\trep(i,3){\n\t\t\tfill(pre[i],pre[i]+256,300);\n\t\t\tconst int start=(tmask>>(8*i))&255;\n\t\t\tpre[i][start]=0;\n\t\t\tqueue<int> q;\n\t\t\tq.push(start);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint cmask=q.front();q.pop();\n\t\t\t\tconst int cy=cmask/16,cx=cmask%16;\n\t\t\t\trep(j,4){\n\t\t\t\t\tconst int ny=cy+dy[j],nx=cx+dx[j];\n\t\t\t\t\tif(board[ny][nx]=='#') continue;\n\t\t\t\t\tif(chmin<S>(pre[i][16*ny+nx],pre[i][16*cy+cx]+1)) q.push(16*ny+nx);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\tfill(dist,dist+limit,30000);\n\t\tdist[smask]=0;\n\t\tusing state=tuple<S,int>;\n\t\tpriority_queue<state,vector<state>,greater<state>> q;\n\t\tq.push(state(0,smask));\n\n\t\twhile(!q.empty()){\n\t\t\tint cost,cmask;\n\t\t\ttie(cost,cmask)=q.top();q.pop();\n\n\t\t\tif(dist[tmask]!=30000) break;\n\n\t\t\tint cy[3],cx[3],tmp=cmask;\n\t\t\trep(i,n){\n\t\t\t\tcx[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t\tcy[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t}\n\n\t\t\tconst int all=pow<int>(5,n);\n\n\t\t\trep(mask,all){\n\t\t\t\tconst int didx[3]={mask%5,mask/5%5,mask/25};\n\t\t\t\tint ny[3],nx[3];\n\t\t\t\trep(i,n){\n\t\t\t\t\tny[i]=cy[i]+dy[didx[i]];\n\t\t\t\t\tnx[i]=cx[i]+dx[didx[i]];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n) if(board[ny[i]][nx[i]]=='#') ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==ny[j] && nx[i]==nx[j] ) ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==cy[j] && nx[i]==cx[j] && ny[j]==cy[i] && nx[j]==cx[i]) ok=false;\n\t\t\t\tif(ok==false) continue;\n\n\n\t\t\t\tint nmask=0;\n\t\t\t\trep(i,n) nmask|=(16*ny[i]+nx[i])<<(8*i);\n\n\t\t\t\tif(chmin<S>(dist[nmask],dist[cmask]+1)) q.push(state(dist[nmask]+hstar(n,nmask,tmask),nmask));\t\t\n\t\t\t}\n\n\t\t}\n\t\tcout << dist[tmask] << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 100000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return 1.3 * a.cost + a.dist > 1.3 * b.cost + b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nshort dp[196][196][196];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n, d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=INF;\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5) rep(j,5) rep(k,5){\n      \n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      int nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n      int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n      \n      if(!check(nay,nax)||!check(nby,nbx)||!check(ncy,ncx)) continue;\n      \n      if(!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n      if(!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n      if(!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n      \n      if(nay==nby&&nax==nbx) continue;\n      if(nay==ncy&&nax==ncx) continue;\n      if(nby==ncy&&nbx==ncx) continue;\n\n      if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\td[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\tq.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n      }\n      \n    }\n    \n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    set<char> memo;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    if(n<=1){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][0]=(char)i;\n\t  s[0][1]=char('A'+i-'a');\n\t  by=0, bx=0;\n\t}\n    }\n\n    if(n<=2){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][2]=(char)i;\n\t  s[0][3]=char('A'+i-'a');\n\t  cy=0, cx=2;\n\t}\n      \n    }\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        set<uint32_t> used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nint cost[3][16][16];\nint id[16][16];\nint numid=0;\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  int me;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;\n  }\n  void hash(int column){\n    me = 0;\n    rep(i,n){\n      me = (me << 8) + id[p[i]/column][p[i]%column];\n      //me = me * numid + id[p[i]/column][p[i]%column]; \n    }\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<int>& S,int now,int n){\n  if ( n == now){\n    dest.data.hash(column);\n    if ( dest.legal(source) && S.find(dest.data.me) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data.me);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<int> S;\n  first.data.hash(column);\n  S.insert(first.data.me);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    numid = 0;\n    rep(i,row)rep(j,column)id[i][j]=-1;\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n\tif (m[i][j]=='#');\n\telse id[i][j] = numid++;\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: Oct 11, 2013\n *      Author: Hesham\n */\n#include<iostream>\n#include<string>\n#include<map>\n#include<ctime>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<algorithm>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<bitset>\n#include<fstream>\n#include<cmath>\n#include<cassert>\n#include <stdio.h>\n#include<ctype.h>\nusing namespace std;\nint dx[] = { 0, 0, 1, -1, 0 };\nint dy[] = { 0, 1, 0, 0, -1 };\nint w, h, n;\nstring house[16];\nstruct State {\n\tvector<int> y, x;\n\tState() {\n\t\tx.resize(3, 0);\n\t\ty.resize(3, 0);\n\t}\n\tState(vector<int>& yy, vector<int>& xx) :\n\t\t\tx(xx), y(yy) {\n\t}\n\tbool operator ==(const State& other) const {\n\t\treturn x == other.x && y == other.y;\n\t}\n};\nbool vis1[16][16][16][16][16][16];\nbool vis2[16][16][16][16][16][16];\n//short dist[16][16][16][16][16][16];\n\nbool isVis(State& s, bool vis[16][16][16][16][16][16]) {\n\treturn vis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setVis(State& s, bool vis[16][16][16][16][16][16]) {\n\tvis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = true;\n}\n/*int getDist(State& s) {\n\treturn dist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}*/\n/*void setDist(State& s, int v) {\n\tdist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = v;\n}*/\n\nbool ok(int y, int x) {\n\tif (y < 0 || y == h || x < 0 || x == w)\n\t\treturn false;\n\tif (house[y][x] == '#')\n\t\treturn false;\n\treturn true;\n}\nint d1, d2;\nint c11, c12, c21, c22;\nint pushAdjs(int i, State& adj, State& curr, queue<State>& q,\n\t\tbool visA[16][16][16][16][16][16], bool visB[16][16][16][16][16][16], int da, int db, int& c) {\n\tif (i == n) {\n\t\tif (isVis(adj, visA))\n\t\t\treturn -1;\n\t\tif (isVis(adj, visB))\n\t\t\treturn da + 1 + db;\n\t\tsetVis(adj, visA);\n\t\tq.push(adj);\n\t\t++c;\n\t\treturn -1;\n\t}\n\tfor (int d = 0; d < 5; ++d) {\n\t\tadj.y[i] = dy[d] + curr.y[i];\n\t\tadj.x[i] = dx[d] + curr.x[i];\n\t\tif (!ok(adj.y[i], adj.x[i]))\n\t\t\tcontinue;\n\t\tbool okk = true;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (adj.y[i] == curr.y[j] && adj.x[i] == curr.x[j]&&\n\t\t\t    adj.y[j] == curr.y[i] && adj.x[j] == curr.x[i]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (adj.y[i] == adj.y[j] && adj.x[i] == adj.x[j]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!okk)\n\t\t\tcontinue;\n\t\tint cost = pushAdjs(i + 1, adj, curr, q, visA, visB, da, db, c);\n\t\tif (cost != -1)\n\t\t\treturn cost;\n\t}\n\treturn -1;\n}\nint meetMiddle(vector<int>& sy, vector<int>& sx, vector<int>& ty,\n\t\tvector<int>& tx) {\n\tmemset(vis1, false, sizeof vis1);\n\tmemset(vis2, false, sizeof vis2);\n\tState s(sy, sx);\n\tState t(ty, tx);\n\t//setDist(s, 0);\n\t//setDist(t, 0);\n\td1 = 0;\n\td2 = 0;\n\tc11 = 1, c12 = 0, c21 = 1, c22 = 0;\n\tsetVis(s, vis1);\n\tsetVis(t, vis2);\n\tqueue<State> q1;\n\tqueue<State> q2;\n\tq1.push(s);\n\tq2.push(t);\n\twhile (true) {\n\t\tif(d1 <= d2)\n\t\t{\n\t\t\tState curr1 = q1.front();\n\t\t\tq1.pop();\n\t\t\t--c11;\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr1, q1, vis1, vis2, d1, d2, c12);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t\tif(!c11){\n\t\t\t\tswap(c11, c12);\n\t\t\t\td1++;\n\t\t\t}\n\t\t}\n\t\tif(d2 < d1)\n\t\t{\n\t\t\tState curr2 = q2.front();\n\t\t\tq2.pop();\n\t\t\t--c21;\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr2, q2, vis2, vis1, d2, d1, c22);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t\tif(!c21){\n\t\t\t\tswap(c21, c22);\n\t\t\t\td2++;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//clock_t begin = clock();\n\tstring line;\n\twhile (cin >> w >> h >> n) {\n\t\tif (!w && !h && !n)\n\t\t\tbreak;\n\t\tcin.ignore();\n\t\t//cin.ignore();\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tgetline(cin, house[i]);\n\n\t\tvector<int> sx(3, 0);\n\t\tvector<int> sy(3, 0);\n\n\t\tvector<int> tx(3, 0);\n\t\tvector<int> ty(3, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (house[i][j] >= 'A' && house[i][j] <= 'C') {\n\t\t\t\t\ttx[(house[i][j] - 'A')] = j;\n\t\t\t\t\tty[(house[i][j] - 'A')] = i;\n\t\t\t\t}\n\t\t\t\tif (house[i][j] >= 'a' && house[i][j] <= 'c') {\n\t\t\t\t\tsx[(house[i][j] - 'a')] = j;\n\t\t\t\t\tsy[(house[i][j] - 'a')] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << meetMiddle(sy, sx, ty, tx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nint dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tbool goal=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d.y[i]!=gy[i] || d.x[i]!=gx[i])goal=false;\n\t\t}\n\t\tif(goal){\n\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]];\n\t\t}\n\t\tfor(int i=0;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            // c\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.push_back(w);\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h+1, 1 };\n                h += 1;\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<unordered_map>\n#include<vector>\n#include<utility>\n#include<map>\n#define MAX_W 16 + 5\n#define MAX_N 3 + 2\n#define INF 0x3f3f3f3f\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h, n;\nchar m[MAX_W][MAX_W];\nint d[MAX_N][MAX_W][MAX_W];\nint dir[MAX_N];\nmap<int, int>::iterator it;\nint x[] = {0, 1, -1, 0,  0}; //ä¸å/ä¸/ä¸/å³/å·¦\nint y[] = {0, 0,  0, 1, -1};\nint ct = 0;\n\nint hstar(int cur){\n\tint res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tint sx = (cur >> 4) & 0xf;\n\t\tint sy =  cur & 0xf;\n\t\tcur >>= 8;\n\t\tres = max(res, d[i][sx][sy]);\n\t}\n\treturn res;\n}\nint check(int cur, int *dir){\n\tint sxy[3], nxy[3], nxt = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tsxy[i] = (cur >> (i * 8)) & 0xff;\n\t\tint nx = ((sxy[i] >> 4) & 0xf) + x[dir[i]];\n\t\tint ny = (sxy[i] & 0xf) + y[dir[i]];\n\t\tnxy[i] = (nx << 4) | ny;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint nx = (nxy[i] >> 4) & 0xf;\n\t\tint ny = nxy[i] & 0xf;\n\t\tif(m[nx][ny] == '#') return 0; //hit the wall\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif((nxy[i] == nxy[j]) || (nxy[i] == sxy[j] && sxy[i] == nxy[j])) return 0; // overlap && switch\n\t\t}\n\t\tnxt |= (nxy[i] << (i * 8));\n\t}\n\treturn nxt;\n}\n// void show(int cur){\n\t// for(int i = 0; i < n; i++){\n\t\t// int sx = cur >> 4 & 0xf;\n\t\t// int sy = cur & 0xf;\n\t\t// cur >>= 8;\n\t\t// printf(\"%c : (%d, %d)\\n\", i + 'a', sx, sy);\n\t// }\n// }\nint solve(){\n\tmemset(d, 0x3f, sizeof(d));\n\t//BFS\n\tfor(int i = 0; i < n; i++){\n\t\tint sx, sy;\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tsx = j / w, sy = j % w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<P> que;\n\t\tque.push(make_pair(sx, sy));\n\t\td[i][sx][sy] = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor(int j = 1; j < 5; j++){\n\t\t\t\tint nx = p.first + x[j];\n\t\t\t\tint ny = p.second + y[j];\n\t\t\t\tif(m[nx][ny] != '#' && d[i][nx][ny] > d[i][p.first][p.second] + 1){\n\t\t\t\t\td[i][nx][ny] = d[i][p.first][p.second] + 1;\n\t\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = 0, end = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'a'){\n\t\t\t\tcur |= ((j / w) << (8 * i + 4));\n\t\t\t\tcur |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tend |= ((j / w) << (8 * i + 4));\n\t\t\t\tend |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tunordered_map<int, int> mp;\n\tmp[cur] = 0;\n\tque.push(make_pair(hstar(cur), cur));\n\twhile(!que.empty()){\n\t\tcur = que.top().second; que.pop();\n\t\t\n\t\tif(cur == end) return mp[cur];\n\t\t\n\t\tct++;\n\t\t\n\t\tfor(int i = 0; i < 5; i++){\n\t\t    dir[0] = i;\n\t\t\tfor(int j = 0; j < (n < 2 ? 1 : 5); j++){\n\t\t\t\tdir[1] = j;\n\t\t\t\tfor(int k = 0; k < (n < 3 ? 1 : 5); k++){\n\t\t\t\t\tdir[2] = k;\n\t\t\t\t\tint nx = check(cur, dir);\n\t\t\t\t\t\n\t\t\t\t\tif(nx > 0){ //ç¢ºèªä¸ä¸æ­¥æ¯åæ³ç\n\t\t\t\t\t\tif(mp.find(nx) == mp.end() || mp[nx] > mp[cur] + 1){\n\t\t\t\t\t\t\tmp[nx] = mp[cur] + 1;\n\t\t\t\t\t\t\tque.push(make_pair(mp[nx] + hstar(nx), nx)); //d(v) + h*(v)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(scanf(\"%d %d %d\\n\", &w, &h, &n) != EOF && (w || h || n)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%[^\\n]%*c\", m[i]);\n\t\t}\n\t\tct = 0;\n\t\tcout << solve() << endl;\n\t\t//printf(\"ct = %d\\n\", ct);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nusing namespace std;\nconst int inf = 1e9;\nconst int dx[5] = {1, 0, -1, 0, 0};\nconst int dy[5] = {0, 1, 0, -1, 0};\nint mindist[256][256][256];\nvoid init(){\n\tfor(int i=0; i<256; i++){\n\t\tfor(int j=0; j<256; j++){\n\t\t\tfor(int k=0; k<256; k++){\n\t\t\t\tmindist[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct info{\n\tint p[3];\n\tint dist;\n\tinfo(int a, int b, int c, int d):p{a,b,c},dist(d){}\n\tinfo(){}\n};\n\nint main(){\n\twhile(1){\n\t\tint w,h,n;\n\t\tcin >> w >> h >> n;\n\t\tif(w == 0) break;\n\n\t\t//input\n\t\tbool wall[16][16] = {};\n\t\tvector<pair<int, int> > s, g;\n\t\tcin.ignore();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tstring str;\n\t\t\tgetline(cin, str);\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif('a'<=str[j] && str[j]<='z'){\n\t\t\t\t\ts.emplace_back(str[j], (i<<4) +j);\n\t\t\t\t}\n\t\t\t\tif('A'<=str[j] && str[j]<='Z'){\n\t\t\t\t\tg.emplace_back(str[j], (i<<4) +j);\n\t\t\t\t}\n\t\t\t\tif(str[j] == '#') wall[i][j] = true;\n\t\t\t}\n\t\t}\n\t\twhile((int)s.size() < 3){\n\t\t\ts.emplace_back(0, s.size());\n\t\t\tg.emplace_back(0, g.size());\n\t\t}\n\t\tsort(s.begin(), s.end());\n\t\tsort(g.begin(), g.end());\n\n\t\t//bfs\n\t\tinit();\n\t\tmindist[s[0].second][s[1].second][s[2].second] = 0;\n\t\tqueue<info> wait;\n\t\tinfo start(s[0].second, s[1].second, s[2].second, 0);\n\t\tinfo goal(g[0].second, g[1].second, g[2].second, 0);\n\t\twait.push(start);\n\t\twhile(!wait.empty()){\n\t\t\tinfo curr = wait.front();\n\t\t\twait.pop();\n\t\t\tint p[3] = {curr.p[0], curr.p[1], curr.p[2]};\n\t\t\tint py[3] = {p[0]>>4, p[1]>>4, p[2]>>4};\n\t\t\tint px[3] = {p[0]&0b1111, p[1]&0b1111, p[2]&0b1111};\n\t\t\tint dist = curr.dist;\n\t\t\tif(p[0]==goal.p[0] && p[1]==goal.p[1] && p[2]==goal.p[2]) break;\n\n\t\t\tint np[3];\n\t\t\tint y,x;\n\t\t\tfor(int i=0; i<5; i++){\n\t\t\t\tif(py[0]==0 && i<4) continue;\n\t\t\t\ty = py[0] +dy[i];\n\t\t\t\tx = px[0] +dx[i];\n\t\t\t\tif(py[0]!=0 && wall[y][x]) continue;\n\t\t\t\tnp[0] = y*16 +x;\n\t\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\t\tif(py[1]==0 && j<4) continue;\n\t\t\t\t\ty = py[1] +dy[j];\n\t\t\t\t\tx = px[1] +dx[j];\n\t\t\t\t\tif(py[1]!=0 && wall[y][x]) continue;\n\t\t\t\t\tnp[1] = y*16 +x;\n\t\t\t\t\tif(np[0] == np[1] || (np[0]==p[1] && np[1]==p[0])) continue;\n\t\t\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\t\t\ty = py[2] +dy[k];\n\t\t\t\t\t\tx = px[2] +dx[k];\n\t\t\t\t\t\tif(wall[y][x]) continue;\n\t\t\t\t\t\tnp[2] = y*16 +x;\n\t\t\t\t\t\tif(np[1] == np[2] || (np[1]==p[2] && np[2]==p[1])) continue;\n\t\t\t\t\t\tif(np[2] == np[0] || (np[2]==p[0] && np[0]==p[2])) continue;\n\t\t\t\t\t\tif(dist +1 < mindist[np[0]][np[1]][np[2]]){\n\t\t\t\t\t\t\tmindist[np[0]][np[1]][np[2]] = dist +1;\n\t\t\t\t\t\t\twait.push(info(np[0], np[1], np[2], dist +1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mindist[g[0].second][g[1].second][g[2].second] << endl;\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\nchar f[16][16];\nint fx,fy,N;\nint dx[] = {0, 0, -1, 1, 0};\nint dy[] = {0, -1, 0, 0, 1};\n\nclass Ghost\n{\npublic:\n\tint x[3],y[3],c;\n\tbool r;\n\t\n\tGhost(int* i, int* j, int c, bool r)\n\t:r(r),c(c)\n\t{\n\t\tfor(int k=0; k<3; k++)\n\t\t{\n\t\t\tx[k]=i[k];\n\t\t\ty[k]=j[k];\n\t\t\t\n\t\t}\n\t}\n};\n\nbool move(int x, int y, int p)\n{\n\tif(p>=N) return true;\n\tif(x<0||y<0||x>=fx||y>=fy) return false;\n\tif(f[x][y]=='#') return false;\n\t\n\treturn true;\n}\n\nbool crash(int* x, int* y, int* gx, int* gy, int p)\n{\n\tif(p<N) return false;\n\tfor(int i=0; i<p; i++)\n\tfor(int j=i+1; j<p; j++)\n\t{\n\t\tif(x[i]==x[j]&&y[i]==y[j]) return true;\n\t\tif(x[i]==gx[j]&&y[i]==gy[j]&&gx[i]==x[j]&&gy[i]==y[j]) return true;\n\t}\n\treturn false;\n}\n\nshort h[256][256][256][2];\n\nint main()\n{\t\n\twhile(scanf(\"%d%d%d\",&fx,&fy,&N), (fx||fy||N))\n\t{\n\t\tint sx[3]={0},sy[3]={0},gx[3]={0},gy[3]={0};\n\t\tmemset(h,0,sizeof(h));\n\t\t\t\n\t\tchar s[20];\n\t\t\n\t\tgetchar();\n\t\tfor(int i=0; i<fy; i++)\n\t\t{\n\t\t\tgets(s);\n\t\t\tfor(int j=0; j<fx; j++)\n\t\t\t{\n\t\t\t\tif(islower(s[j]))\n\t\t\t\t{\n\t\t\t\t\tsx[s[j]-'a']=j;\n\t\t\t\t\tsy[s[j]-'a']=i;\n\t\t\t\t}\n\t\t\t\tif(isupper(s[j]))\n\t\t\t\t{\n\t\t\t\t\tgx[s[j]-'A']=j;\n\t\t\t\t\tgy[s[j]-'A']=i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf[j][i]=s[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Ghost> q;\n\t\tq.push(Ghost(sx,sy,1,0));\n\t\tq.push(Ghost(gx,gy,1,1));\n\t\t\n\t\tint th[3];\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(sx[l]<<4)+sy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][0]=1;\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(gx[l]<<4)+gy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][1]=1;\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tGhost g=q.front(); q.pop();\n\t\t\t\n\t\t\tint th[3];\n\n\t\t\tfor(int l=0; l<3; l++)\n\t\t\t{\n\t\t\t\tth[l]=(g.x[l]<<4)+g.y[l];\n\t\t\t}\n\n\t\t\tif(h[th[0]][th[1]][th[2]][!g.r])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", g.c+h[th[0]][th[1]][th[2]][!g.r]-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint tx[3],ty[3];\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\ttx[i]=g.x[i];\n\t\t\t\tty[i]=g.y[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<5; i++)\n\t\t\t{\n\t\t\t\ttx[0]=g.x[0]+dx[i], ty[0]=g.y[0]+dy[i];\n\t\t\t\tif(!move(tx[0],ty[0],0))\n\t\t\t\t{\n\t\t\t\t\ttx[0]=g.x[0];\n\t\t\t\t\tty[0]=g.y[0];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<(N>1?5:1); j++)\n\t\t\t\t{\n\t\t\t\t\ttx[1]=g.x[1]+dx[j], ty[1]=g.y[1]+dy[j];\n\t\t\t\t\tif(N>=2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!move(tx[1],ty[1], 1) || (crash(tx,ty,g.x,g.y,2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[1]=g.x[1];\n\t\t\t\t\t\t\tty[1]=g.y[1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0; k<(N>2?5:1); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttx[2]=g.x[2]+dx[k], ty[2]=g.y[2]+dy[k];\n\t\t\t\t\t\tif(N>=3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!move(tx[2],ty[2], 2) || (crash(tx,ty,g.x,g.y,3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0; l<3; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tth[l]=(tx[l]<<4)+ty[l];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(h[th[0]][th[1]][th[2]][g.r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th[th[0]][th[1]][th[2]][g.r]=g.c;\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tq.push(Ghost(tx, ty, g.c+1,g.r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cctype>\n\nusing namespace std;\n\nstruct S{\n  int p[3][2];\n  int t;\n};\n\nint main(){\n  for(int w,h,n;cin>>w>>h>>n,w;){\n    cin.ignore();\n    char g[16][16];\n    S is={{},0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin.get(g[i][j]);\n\tif(islower(g[i][j])){\n\t  auto x=g[i][j]-'a';\n\t  is.p[x][0]=i;\n\t  is.p[x][1]=j;\n\t}\n      }\n      cin.ignore();\n    }\n    queue<S> que;\n    que.push(is);\n    set<int> p;\n    for(;;){\n      S cs=que.front();\n      bool f=false;\n      for(int i=0;i<n;i++){\n\tf|=g[cs.p[i][0]][cs.p[i][1]]!='A'+i;\n      }\n      if(!f)break;\n      que.pop();\n      // int b=0;\n      // for(int i=0;i<n;i++){\n      // \tb=b<<8|cs.p[i][0]<<4|cs.p[i][1];\n      // }\n      // if(!p.insert(b).second)continue;\n      static int dy[]={-1,0,0,0,1};\n      static int dx[]={0,-1,0,1,0};\n      for(int i=0;i<5;i++){\n\tint y1,x1,y2,x2,y3,x3;\n\tauto enqueue=[&](){\n\t  S ns{{y1,x1,y2,x2,y3,x3},cs.t+1};\n\t  int b=0;\n\t  for(int i=0;i<n;i++){\n\t    b=b<<8|ns.p[i][0]<<4|ns.p[i][1];\n\t  }\n\t  if(p.insert(b).second){\n\t    que.push(ns);\n\t  }\n\t};\n\ty1=cs.p[0][0]+dy[i];\n\tx1=cs.p[0][1]+dx[i];\n\ty2=cs.p[1][0];\n\tx2=cs.p[1][1];\n\ty3=cs.p[2][0];\n\tx3=cs.p[2][1];\n\tif(g[y1][x1]=='#')continue;\n\tif(n==1){\n\t  enqueue();\n\t}else{\n\t  for(int j=0;j<5;j++){\n\t    y2=cs.p[1][0]+dy[j];\n\t    x2=cs.p[1][1]+dx[j];\n\t    if(g[y2][x2]=='#'||y2==y1&&x2==x1||y1==cs.p[1][0]&&x1==cs.p[1][1]&&y2==cs.p[0][0]&&x2==cs.p[0][1])continue;\n\t    if(n==2){\n\t      enqueue();\n\t    }else{\n\t      for(int k=0;k<5;k++){\n\t\ty3=cs.p[2][0]+dy[k];\n\t\tx3=cs.p[2][1]+dx[k];\n\t\tif(g[y3][x3]=='#'||y3==y1&&x3==x1||y3==y2&&x3==x2||y3==cs.p[0][0]&&x3==cs.p[0][1]&&y1==cs.p[2][0]&&x1==cs.p[2][1]||y3==cs.p[1][0]&&x3==cs.p[1][1]&&y2==cs.p[2][0]&&x2==cs.p[2][1])continue;\n\t\tenqueue();\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.front().t<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> p;\n    bitset<3> bs;\n    Data(vector<int>& p0, bitset<3> bs0){\n        p = p0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h * w;\n            ret += p[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    string gridLine = accumulate(grid.begin(), grid.end(), string());\n    int diff[] = {1, -1, w, -w};\n\n    vector<int> sp(n), gp(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sp[c-'a'] = i * w + j;\n            }else if('A' <= c && c <= 'C'){\n                gp[c-'A'] = i * w + j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= h * w;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sp, 0).toInt()] = true;\n    check[1][Data(gp, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sp, 0));\n    dq[1].push_back(Data(gp, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.p[i] += diff[j];\n\n                bool ok = true;\n                if(gridLine[d.p[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.p[k] == d.p[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.p[i] -= diff[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            if(check[turn^1][a])\n                return ret;\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[16][16][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tint x[3], y[3];\n\tdouble h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\ndouble calcH(S& s) {\n\tdouble ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (double)dist[s.y[i]][s.x[i]][gy[i]][gx[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\tq.push(make_pair(j, i));\n\t\t\t\tdist[i][j][i][j] = 0;\n\t\t\t\twhile(q.size()) {\n\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\tif(dist[i][j][ny][nx] != -1) continue;\n\t\t\t\t\t\tdist[i][j][ny][nx] = dist[i][j][y][x] + 1;\n\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nint N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nbool same(const vector<int>& sx, const vector<int>& sy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == sx[j] && sy[i] == sy[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool is_swap(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 1;\n            }\n        }       \n    }\n    return 0;\n}\n\nvoid print(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        cout << i << \" \" << sx[i] << \" \" << sy[i] << \" \" << gx[i] << \" \" << gy[i] << endl;  \n    }\n    cout << endl;\n}\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;    \n    que.push(make_pair(sx, sy));\n\n    map<pair<vector<int>, vector<int>>, int> d;\n    d[make_pair(sx, sy)] = 0;    \n    \n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) {\n            return d[f];\n        }\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (same(nsx, nsy) || is_swap(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            auto next = make_pair(nsx, nsy);\n            if (d.count(next) == 0) {\n                d[next] = d[f] + 1;\n                que.push(next);\n            }\n        }\n    }    \n    return -1;\n}\n\nint main()\n{\n    int W, H;\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        cout << bfs(field, sx, sy, gx, gy) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[16][16][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tint x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[s.y[i]][s.x[i]][gy[i]][gx[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\tq.push(make_pair(j, i));\n\t\t\t\tdist[i][j][i][j] = 0;\n\t\t\t\twhile(q.size()) {\n\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\tif(dist[i][j][ny][nx] != -1) continue;\n\t\t\t\t\t\tdist[i][j][ny][nx] = dist[i][j][y][x] + 1;\n\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n \nconst int MAXW = 16;\nconst int MAXH = 16;\nconst int COSTSIZE = 14;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nconst int INF = 1<<28;\n \nint W, H, N;\nstring C[MAXH];\nint cost[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nbool vis[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nint ans;\n \nstruct State {\n  vector<pair<int,int> > ps;\n  bool operator < (const State &s) const {\n    return ps < s.ps;\n  }\n};\n \nvector<pair<int,int> > npos(int i, int j) {\n  vector<pair<int,int> > v;\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(C[ni][nj] == '#') continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  return v;\n}\n \ninline void putCost(const State &s, int c) {\n  if(N == 1) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getCost(const State &s) {\n  if(N == 1) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \ninline void putVis(const State &s, bool c) {\n  if(N == 1) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getVis(const State &s) {\n  if(N == 1) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \nvoid rec(vector<vector<pair<int,int> > > &v, queue<State> &que, const State &s, State &t, int k) {\n  if(k == N) {\n    if(!getVis(t)) {\n      if(getCost(t) == INF) {\n        que.push(t);\n        putCost(t, getCost(s) + 1);\n        putVis(t, true);\n      } else {\n        ans = min(ans, getCost(t) + getCost(s) + 1);\n        putVis(t, true);\n        throw 0;\n      }\n    }\n    return;\n  }\n \n  for(int i = 0; i < v[k].size(); ++i) {\n    bool flag = true;\n    t.ps[k] = v[k][i];\n    for(int j = 0; j < k; ++j) {\n      if(t.ps[k] == t.ps[j]) {\n        flag = false;\n        break;\n      }\n      if(s.ps[k] == t.ps[j] && s.ps[j] == t.ps[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      rec(v, que, s, t, k+1);\n    }\n  }\n}\n \nbool isFinished(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    int ni = s.ps[i].first;\n    int nj = s.ps[i].second;\n    if(C[ni][nj]-'A' != i) return false;\n  }\n  return true;\n}\n \nvoid show(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s.ps[i].first << \", \" << s.ps[i].second;\n    cout << endl;\n  }\n}\n \nint bfs(State initS, bool flag = true) {\n  queue<State> que;\n  que.push(initS);\n  memset(vis, 0, sizeof(vis));\n  putCost(initS, 0);\n  putVis(initS, true);\n  while(!que.empty()) {\n    const State s = que.front();\n    que.pop();\n    if(!flag && getCost(s) >= 40) continue;\n    if(getCost(s)*2 >= ans) continue;\n    vector<vector<pair<int,int> > > v(N);\n    for(int i = 0; i < N; ++i) {\n      v[i] = npos(s.ps[i].first, s.ps[i].second);\n    }\n    State t = s;\n    rec(v, que, s, t, 0);\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> W >> H >> N && (W|H|N)) {\n    cin.ignore();\n    for(int i = 0; i < H; ++i) {\n      getline(cin, C[i]);\n    }\n    State s, t;\n    s.ps.resize(N);\n    t.ps.resize(N);\n    pair<int,int> a, b, c;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        int k;\n        k = C[i][j] - 'a';\n        if(0 <= k && k < N) {\n          s.ps[k] = make_pair(i,j);\n        }\n        k = C[i][j] - 'A';\n        if(0 <= k && k < N) {\n          t.ps[k] = make_pair(i,j);\n        }\n      }\n    }\n    fill(cost[0][0][0][0][0], cost[COSTSIZE][0][0][0][0], INF);\n    ans = INF;\n    bfs(t, false);\n    try {\n      bfs(s);\n    } catch(...) {}\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint d[16][16][16][16][16][16];\n\n\n\nint main(){\n  \n  d[0][0][0][0][0][15]=22222222;\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P start, P goal){\n  int& dist = memo[start.first][start.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  queue<P> que;\n  que.push(goal);\n  memo[goal.first][goal.second][goal.first][goal.second] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    REP(r, 4){\n      P q = p;\n      q.first += dx[r];\n      q.second += dy[r];\n      if(!valid(q.first, q.second, W, H)) continue;\n      if(memo[q.first][q.second][goal.first][goal.second] != -1) continue;\n      memo[q.first][q.second][goal.first][goal.second] = memo[p.first][p.second][goal.first][goal.second] + 1;\n      que.push(q);\n    }\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> w >> h >> n, w){\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tq = priority_queue<ll>();\n\t\ts.clear();\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> state;\n\nconst int dy[] = {0,-1,0,1,0}, dx[] = {0,0,1,0,-1};\n\ninline int encode(const state &x, const int &w){\n  int res = 0, k = 1;\n  for(pii p : x){\n    res += k * (p.fs*w + p.sc);\n    k <<= 8;\n  }\n  return res;\n}\n\ninline state decode(int x, const int &n, const int &w){\n  int k = 1<<8;\n  state res;\n  rep(i,n){\n    int t = x % k;\n    res.push_back(pii(t/w, t%w));\n    x >>= 8;\n  }\n  return res;\n}\n\nint memo[1<<24];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int h,w,n;\n  string g[16];\n  while(cin >> w >> h >> n, w){\n    cin.ignore();\n\n    state start(n), end(n);\n    rep(i,h){\n      getline(cin,g[i]);\n      rep(j,w){\n\tif(islower(g[i][j]))start[g[i][j]-'a'] = pii(i,j);\n\tif(isupper(g[i][j]))end[g[i][j]-'A'] = pii(i,j);\n      }\n    }\n    int start_id = encode(start,w);\n    int end_id = encode(end,w);\n\n    memset(memo,-1,sizeof(memo));\n    memo[start_id] = 0;\n    queue<int> q; q.push(start_id);\n    \n    while(q.size()){\n      int cur_id = q.front(); q.pop();\n      state cur = decode(cur_id,n,w);\n      if(cur_id == end_id)break;\n\n      vi dir(n,0); dir[0] = 1;\n      while(dir[n-1]<5){\n\tstate nxt = cur;\n\tbool f = true;\n\tfor(int i=0;f && i<n;i++){\n\t  nxt[i].fs += dy[dir[i]], nxt[i].sc += dx[dir[i]];\n\t  if(g[nxt[i].fs][nxt[i].sc] == '#')f = false;\n\n\t  for(int j=0;f && j<i;j++){\n\t    if(nxt[i] == nxt[j])f = false;\n\t    if(nxt[i] == cur[j] && nxt[j] == cur[i])f = false;\n\t  }\n\t}\n\n\tif(f){\n\t  int nxt_id = encode(nxt, w);\n\t  if(memo[nxt_id] < 0){\n\t    memo[nxt_id] = memo[cur_id] + 1;\n\t    q.push(nxt_id);\n\t  }\n\t}\n\n\tdir[0]++;\n\tfor(int i=0;i<n-1;i++){\n\t  if(dir[i]==5)dir[i] = 0, dir[i+1]++;\n\t}\n      }\n\n    }\n    cout << memo[end_id] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,n;\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\nstring mp[20];\n\nstruct dat{\n  int y1,x1;\n  int y2,x2;\n  int y3,x3;\n};\n\n\nint D[14][14][15][15][15][15];\nqueue<dat> Q;\nvoid DD(dat &a,int b){D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1] = b;}\nint DD(const dat &a){return D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1];}\n\nbool check(const dat &a){\n  if(mp[a.y1][a.x1]=='#') return 0;\n  if(n>=2&&mp[a.y2][a.x2]=='#') return 0;\n  if(n>=3&&mp[a.y3][a.x3]=='#') return 0;\n  return DD(a)==-1;\n}\n\nvoid update(const dat &a){\n  int cost = DD(a);\n\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++)\n      for(int k=0;k<5;k++){\n\tint ny1 = a.y1+dy[i], nx1 = a.x1+dx[i];\n\tint ny2 = a.y2+dy[j], nx2 = a.x2+dx[j];\n\tint ny3 = a.y3+dy[k], nx3 = a.x3+dx[k];\n\tif(n<=1) ny2 = 15,nx2 = 14;\n\tif(n<=2) ny3 = 14,nx3 = 15;\n\t\n\tdat nt = (dat){ny1,nx1,ny2,nx2,ny3,nx3};\n\tif(!check(nt))continue;\n\tif((ny1==ny2&&nx1==nx2) ||(ny2==ny3&&nx2==nx3) ||(ny3==ny1&&nx3==nx1))continue;//same pos\n\tif(((a.y1==ny2&&a.x1==nx2) && (a.y2==ny1&&a.x2==nx1)) || // swap positoin\n\t   ((a.y2==ny3&&a.x2==nx3) && (a.y3==ny2&&a.x3==nx2)) ||\n\t   ((a.y3==ny1&&a.x3==nx1) && (a.y1==ny3&&a.x1==nx3)) )continue;\n\n\tQ.push(nt);\n\tDD(nt,cost+1);\n      }\n}\n\nbool goal(const dat &s,const dat &t){\n  char a = mp[s.y1][s.x1];\n  char b = mp[s.y2][s.x2];\n  char c = mp[s.y3][s.x3];\n  char A = mp[t.y1][t.x1];\n  char B = mp[t.y2][t.x2];\n  char C = mp[t.y3][t.x3];\n  return toupper(a)==A&&(n<=1||toupper(b)==B)&&(n<=2||toupper(c)==C);\n}\n\nint bfs(dat start){\n  memset(D,-1,sizeof(D));\n  while(!Q.empty())Q.pop();\n  Q.push(start);\n  DD(start,0);\n  \n  while(!Q.empty()){\n    dat t = Q.front();Q.pop();\n    if(goal(start,t)) return DD(t);\n    update(t);\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>w>>h>>n;\n  if(!w&&!h&&!n)break;\n  cin.ignore();\n  for(int i=0;i<h;i++)getline(cin,mp[i]),mp[i]+='#';\n  \n\n  dat start = (dat){15,15,15,14,14,15};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!islower(mp[i][j]))continue;\n      if(start.y1==15) start.y1=i,start.x1=j;\n      else if(start.y2==15) start.y2=i,start.x2=j;\n      else start.y3=i,start.x3=j;\n    }\n\n  cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(cost >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct P{\n  int ay,ax,by,bx,cy,cx,cost;\n  P(int a1,int a2,int b1,int b2,int c1,int c2,int c){\n    ax=a1;ay=a2;\n    bx=b1;by=b2;\n    cx=c1;cy=c2;\n    cost=c;\n  }\n};\n\nint h,w,n,gx[3],gy[3],sx[3],sy[3];\nstring s[14],iranai;\nbool used[14][14][14][14][14][14];\nint dx[]={1,0,-1,0,0};\nint dy[]={0,1,0,-1,0};\n\nint BFS(){\n  memset(used,0,sizeof(used));\n  queue<P>q;\n  q.push(P(sx[0],sy[0],sx[1],sy[1],sx[2],sy[2],0));\n  used[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int ay=p.ay;\n    int ax=p.ax;\n    int by=p.by;\n    int bx=p.bx;\n    int cy=p.cy;\n    int cx=p.cx;\n    int cost=p.cost;\n    if(ay==gy[0]&&ax==gx[0]&&by==gy[1]&&bx==gx[1]&&cy==gy[2]&&cx==gx[2])return cost;\n    for(int i=0;i<5;i++){\n      int Ay=ay+dy[i];\n      int Ax=ax+dx[i];\n      if(Ay<0||Ax<0||Ay>=h||Ax>=w)continue;\n      if(s[Ay][Ax]=='#')continue;\n      if(n>=2){\n\n        for(int j=0;j<5;j++){\n          int By=by+dy[j];\n          int Bx=bx+dx[j];\n          if(By<0||Bx<0||By>=h||Bx>=w)continue;\n          if(s[By][Bx]=='#')continue;\n          if(n>=3){\n\n            for(int j=0;j<5;j++){\n              int Cy=cy+dy[j];\n              int Cx=cx+dx[j];\n              if(Cy<0||Cx<0||Cy>=h||Cx>=w)continue;\n              if(s[Cy][Cx]=='#')continue;\n              if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n              if(Cx==bx&&Cy==by&&Bx==cx&&By==cy)continue;\n              if(Ax==cx&&Ay==cy&&Cx==ax&&Cy==ay)continue;\n              if(Ax==Bx&&Ay==By)continue;\n              if(Ax==Cx&&Ay==Cy)continue;\n              if(Cx==Bx&&Cy==By)continue;\n              if(!used[Ay][Ax][By][Bx][Cy][Cx]){\n                used[Ay][Ax][By][Bx][Cy][Cx]=1;\n                q.push(P(Ax,Ay,Bx,By,Cx,Cy,cost+1));\n              }\n            }\n\n          }\n          else{\n            if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n            if(Ax==Bx&&Ay==By)continue;\n            if(!used[Ay][Ax][By][Bx][cy][cx]){\n              used[Ay][Ax][By][Bx][cy][cx]=1;\n              q.push(P(Ax,Ay,Bx,By,cx,cy,cost+1));\n            }\n          }\n        }\n\n      }\n      else{\n        if(!used[Ay][Ax][by][bx][cy][cx]){\n          used[Ay][Ax][by][bx][cy][cx]=1;\n          q.push(P(Ax,Ay,bx,by,cx,cy,cost+1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h>>n,n){\n    memset(sy,0,sizeof(sy));\n    memset(sx,0,sizeof(sx));\n    memset(gx,0,sizeof(gx));\n    memset(gy,0,sizeof(gy));\n    getline(cin,s[0]);\n    getline(cin,s[0]);\n    r(i,h-2)getline(cin,s[i]);\n    getline(cin,iranai);\n    h-=2;w-=2;\n    r(i,h)s[i].erase(s[i].begin(),s[i].begin()+1);\n    r(i,h)s[i].erase(s[i].begin()+w);\n    r(i,h)r(j,w){\n      if(s[i][j]=='a')sy[0]=i,sx[0]=j;\n      if(s[i][j]=='b')sy[1]=i,sx[1]=j;\n      if(s[i][j]=='c')sy[2]=i,sx[2]=j;\n      if(s[i][j]=='A')gy[0]=i,gx[0]=j;\n      if(s[i][j]=='B')gy[1]=i,gx[1]=j;\n      if(s[i][j]=='C')gy[2]=i,gx[2]=j;\n    }\n    cout<<BFS()<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nshort d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=(1e4);\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n      \t  if(!check(ncy,ncx)) continue;\n      \n\t  if(!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(nay==nby&&nax==nbx) continue;\n\t  if(nay==ncy&&nax==ncx) continue;\n\t  if(nby==ncy&&nbx==ncx) continue;\n\n\t  if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\t    q.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n\t  }\n      \n\t}\n      }\n    }\n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    if(n<=1){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][0]=(char)i;\n\t  s[0][1]=char('A'+i-'a');\n\t  by=0, bx=0;\n\t}\n    }\n    \n    if(n<=2){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][2]=(char)i;\n\t  s[0][3]=char('A'+i-'a');\n\t  cy=0, cx=2;\n\t}\n      \n    }\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nchar dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tbool goal=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d.y[i]!=gy[i] || d.x[i]!=gx[i])goal=false;\n\t\t}\n\t\tif(goal){\n\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]];\n\t\t}\n\t\tfor(int i=0;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <map>\n#include <queue>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\n#define MAGIC_WEIGHT 1.3\nbool operator < (state_t const & a, state_t const & b) {\n    return MAGIC_WEIGHT * a.cost + a.dist > MAGIC_WEIGHT * b.cost + b.dist;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        assert (1 <= n and n <= 3);\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        array<point_t,3> start;\n        array<point_t,3> goal;\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        repeat_from (i,n,3) {\n            start[i] = ix.begin()->first; // fill with some non-wall cell\n            goal[i]  = ix.begin()->first;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            queue<point_t> que; // bfs\n            que.push(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            while (not que.empty()) {\n                point_t p = que.front(); que.pop();\n                repeat (j,4) {\n                    auto q = p + dp[j];\n                    if (c[q.y][q.x] == '#') continue;\n                    if (dist[i][q.y][q.x] == 1000000007) {\n                        dist[i][q.y][q.x] = dist[i][p.y][p.x] + 1;\n                        que.push(q);\n                    }\n                }\n            }\n        }\n\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    if (n < 2 and j != 4) continue;\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        if (n < 3 and k != 4) continue;\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (n == 3 and not is_valid_move(1, 2, s, t)) continue;\n                        if (n == 3 and not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    static bool used[1 << 24] = {};\n    memset(used, 0, sizeof used);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      int k = make(s.p);\n      if(used[k]) continue;\n      used[k] = true;\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, dist, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      if(dist[make(s.p)] < s.d) continue;\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, dist, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define var auto\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint starts[3];\nint ends[3];\n\nbool m[256];\n\nint states[256*256*256];\n\n\nbool solve(){\n  int w, h, n;\n  cin >> w >> h >> n;\n  if (w == 0) return false;\n  \n  starts[0] = 0;\n  starts[1] = 0;\n  starts[2] = 0;\n  ends[0] = 0;\n  ends[1] = 0;\n  ends[2] = 0;\n  for (int i = 0; i < 256*256*256; i++){\n    states[i] = 2147483647 / 2;\n  }\n\n  getchar();\n  for (int i = 0; i < h; i++){\n    std::string s;\n    char ch;\n    for (int j = 0; j < w; j++){\n      ch = getchar();\n      s += ch;\n      if ('A' <= s[j] && s[j] <= 'C'){\n\tstarts[s[j] - 'A'] = i * w + j;\n      }\n      if ('a' <= s[j] && s[j] <= 'c'){\n\tends[s[j] - 'a'] = i * w + j;\n      }\n      m[i * w + j] = (s[j] != '#');\n\n    }\n    getchar();\n    //cout << s << endl;\n  }\n  \n  int amove[5];\n  int bmove[5];\n  int cmove[5];\n  int acnt;\n  int bcnt;\n  int ccnt;\n\n  var add = [&](int& cnt, int mv[], int ind){\n    if (!m[ind]) return;\n    mv[cnt] = ind;\n    cnt++;\n  };\n  var adds = [&](int& cnt, int mv[], int p){\n    add(cnt, mv, p);\n    add(cnt, mv, p - 1);\n    add(cnt, mv, p + 1);\n    add(cnt, mv, p - w);\n    add(cnt, mv, p + w);\n  };\n\n  std::queue<int> st{};\n  var initind = (starts[2] << 16) | (starts[1] << 8) | starts[0];\n  st.push(initind);\n  states[initind] = 0;\n\n  if (n == 1){\n    while (!st.empty()){\n      var elem = st.front(); st.pop();\n      var nexttime = states[elem] + 1;\n      var ap = elem & 255;\n      //printf(\"a:%d, b:%d, c:%d ->\\n\", ap, bp, cp);\n      acnt = 0;\n      adds(acnt, amove, ap);\n      for (int i = 0; i < acnt; i++){\n\tvar ab = amove[i];\n\tif (states[ab] <= nexttime) continue;\n\t//printf(\"   a:%d, b:%d, c:%d\\n\", amove[i], bmove[j], cmove[k]);\n\tstates[ab] = nexttime;\n\tst.push(ab);\n      }\n    }\n  }\n  else if (n == 2){\n    while (!st.empty()){\n      var elem = st.front(); st.pop();\n      var nexttime = states[elem] + 1;\n      var ap = elem & 255; elem >>= 8;\n      var bp = elem & 255;\n      //printf(\"a:%d, b:%d, c:%d ->\\n\", ap, bp, cp);\n      acnt = 0;\n      bcnt = 0;\n      adds(acnt, amove, ap);\n      adds(bcnt, bmove, bp);\n      for (int i = 0; i < acnt; i++){\n\tfor (int j = 0; j < bcnt; j++){\n\t  if (amove[i] == bmove[j] || (amove[i] == bp && bmove[j] == ap)) continue;\n\t  var ab = (bmove[j] << 8) | amove[i];\n\t  if (states[ab] <= nexttime) continue;\n\t  //printf(\"   a:%d, b:%d, c:%d\\n\", amove[i], bmove[j], cmove[k]);\n\t  states[ab] = nexttime;\n\t  st.push(ab);\n\t}\n      }\n    }\n  }\n  else{\n    while (!st.empty()){\n      var elem = st.front(); st.pop();\n      var nexttime = states[elem] + 1;\n      var ap = elem & 255; elem >>= 8;\n      var bp = elem & 255; elem >>= 8;\n      var cp = elem & 255;\n      //printf(\"a:%d, b:%d, c:%d ->\\n\", ap, bp, cp);\n      acnt = 0;\n      bcnt = 0;\n      ccnt = 0;\n      adds(acnt, amove, ap);\n      adds(bcnt, bmove, bp);\n      adds(ccnt, cmove, cp);\n      for (int i = 0; i < acnt; i++){\n\tfor (int j = 0; j < bcnt; j++){\n\t  if (amove[i] == bmove[j] || (amove[i] == bp && bmove[j] == ap)) continue;\n\t  var ab = (bmove[j] << 8) | amove[i];\n\t  for (int k = 0; k < ccnt; k++){\n\t    if (amove[i] == cmove[k] || (amove[i] == cp && cmove[k] == ap) ||\n\t\tbmove[j] == cmove[k] || (bmove[j] == cp && cmove[k] == bp)) continue;\n\t    var abc = (cmove[k] << 16) | ab;\n\t    if (states[abc] <= nexttime) continue;\n\t    //printf(\"   a:%d, b:%d, c:%d\\n\", amove[i], bmove[j], cmove[k]);\n\t    states[abc] = nexttime;\n\t    st.push(abc);\n\t  }\n\t}\n      }\n    }\n  }\n\n  var endind = (ends[2] << 16) | (ends[1] << 8) | ends[0];\n  \n  std::cout << states[endind] << std::endl;\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,s,t ) for (int i = s; i < t ; i++)\nusing LL = long long; using VI = vector<int>;\nusing VL = vector<LL>; using VVI = vector<VI>;\nconst LL LINF = 1e18; const int INF = 1e9;\n#define SZ(a) (int)a.size()\n\n// J ãã\nint dist[256][256][256];\nusing PII = pair<int, int>;\nconst PII NoUse = PII(0, 0);\n\nvoid solve() {\n\tint  W, H, N;\n\twhile (cin >> W >> H >> N, W || H) {\n\t\tstring s; getline(cin, s);\n\t\tvector<string>vs(H);\n\t\tPII sa = NoUse, sb = NoUse, sc = NoUse;\n\t\tPII ta = NoUse, tb = NoUse, tc = NoUse;\n\t\tFOR(i, 0, H) {\n\t\t\tgetline(cin, vs[i]);\n\t\t\tFOR(j, 0, W) {\n\t\t\t\tif (vs[i][j] == 'a') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\tsa = PII(i, j);\n\t\t\t\t}\n\t\t\t\telse if (vs[i][j] == 'b') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\tsb = PII(i, j);\n\t\t\t\t}\n\t\t\t\telse if (vs[i][j] == 'c') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\tsc = PII(i, j);\n\t\t\t\t}\n\t\t\t\telse if (vs[i][j] == 'A') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\tta = PII(i, j);\n\t\t\t\t}\n\t\t\t\telse if (vs[i][j] == 'B') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\ttb = PII(i, j);\n\t\t\t\t}\n\t\t\t\telse if (vs[i][j] == 'C') {\n\t\t\t\t\tvs[i][j] = ' ';\n\t\t\t\t\ttc = PII(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ææªãæ¸ã\n\t\tfill(**dist, **dist + 256 * 256 * 256, INF);\n\t\tusing tp = tuple<PII, PII, PII>;\n\t\tqueue<tp>q;\n\t\tq.push(tp( sa,sb,sc ));\n\t\tauto ha = [&](const PII & x) {\n\t\t\treturn x.first*H + x.second;\n\t\t};\n\t\tint dy[4] = { -1,0,1,0 };\n\t\tint dx[4] = { 0,1,0,-1 };\n\n\t\tauto f = [&](const PII & a) {\n\t\t\tvector<PII>res;\n\t\t\tres.push_back(a);\n\t\t\tFOR(p, 0, 4) {\n\t\t\t\tint ny = a.first + dy[p], nx = a.second + dx[p];\n\t\t\t\tif (0 <= ny && ny < H && 0 <= nx && nx < W) {\n\t\t\t\t\tif (vs[ny][nx] != '#') {\n\t\t\t\t\t\tres.push_back(PII(ny, nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\n\t\tdist[ha(sa)][ha(sb)][ha(sc)] = 0;\n\t\tint ans = 0;\n\t\t// O(H^6*(UNCHI))\n\n\t\twhile (!q.empty()) {\n\t\t\tPII aa, bb, cc;\n\t\t\ttie(aa, bb, cc) = q.front(); q.pop();\n\n\t\t\tint d = dist[ha(aa)][ha(bb)][ha(cc)];\n\t\t\t//if (ta == aa && tb == bb && tc == cc) {\n\t\t\t//\tans = d;\n\t\t\t//\tbreak;\n\t\t\t//}\n\t\t\t// nx stateãå¨é¨æã£ã¦ãã\n\t\t\tvector<PII>na = f(aa), nb = f(bb), nc = f(cc);\n\t\t\tFOR(i, 0, SZ(na)) {\n\t\t\t\tPII a = na[i];\n\t\t\t\tFOR(j, 0, SZ(nb)) {\n\t\t\t\t\tPII b = nb[j];\n\t\t\t\t\tFOR(k, 0, SZ(nc)) {// éè¤ããªããswapãããªã\n\t\t\t\t\t\tPII c = nc[k];\n\n\t\t\t\t\t\t// è©ä¾¡é åºãç¥ããªãäººã®ã¢ãããããã¾ã\n\n\t\t\t\t\t\t//cout << \"brf eval\" << endl;\n\t\t\t\t\t\t//FOR(n, 0, H) {\n\t\t\t\t\t\t//\tFOR(m, 0, W) {\n\t\t\t\t\t\t//\t\tif (PII(n, m) == a)cout << \"a\";\n\t\t\t\t\t\t//\t\telse if (PII(n, m) == b)cout << \"b\";\n\t\t\t\t\t\t//\t\telse if (PII(n, m) == c)cout << \"c\";\n\t\t\t\t\t\t//\t\telse cout << vs[n][m];\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t//\tcout << endl;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\t//cout << endl;\n\n\t\t\t\t\t\t// - éè¤ããã ãæªä½¿ç¨ã¯ã¢ã¬\n\t\t\t\t\t\tif (((a != NoUse) && (a == b || a == c)))continue;\n\t\t\t\t\t\tif (((b != NoUse) && (b == c)))continue;\n\t\t\t\t\t\t// a,b a,c b,c\n\n\t\t\t\t\t\t// ããã§ããããªããã®ãã¯ãã\n\t\t\t\t\t\t// - swap\n\t\t\t\t\t\tif (a != NoUse && aa == b && bb == a)continue; // a,b\n\t\t\t\t\t\tif (a != NoUse && aa == c && cc == a)continue; // a,c\n\t\t\t\t\t\tif (b != NoUse && bb == c && cc == b)continue; // b,c\n\n\t\t\t\t\t\t//cout << \"ok,\" << endl;\n\t\t\t\t\t\t//FOR(n, 0, H) {\n\t\t\t\t\t\t//\tFOR(m, 0, W) {\n\t\t\t\t\t\t//\t\tif (PII(n, m) == a)cout << \"a\";\n\t\t\t\t\t\t//\t\telse if (PII(n, m) == b)cout << \"b\";\n\t\t\t\t\t\t//\t\telse if (PII(n, m) == c)cout << \"c\";\n\t\t\t\t\t\t//\t\telse cout << vs[n][m];\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t//\tcout << endl;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\t//cout << endl;\n\t\t\t\t\t\tif (dist[ha(a)][ha(b)][ha(c)] > d + 1) {\n\t\t\t\t\t\t\tdist[ha(a)][ha(b)][ha(c)] = d + 1;\n\t\t\t\t\t\t\tq.push(tp( a,b,c ));\n\t\t\t\t\t\t\tif (ta == a && tb == b && tc == c) {\n\t\t\t\t\t\t\t\tans = d + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\nconstexpr int dx[5] = {-1, +0, +1, +0, +0};\nconstexpr int dy[5] = {+0, -1, +0, +1, +0};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nbool same(int x1, int y1, int x2, int y2)\n{\n    return (x1 == x2 && y1 == y2);\n}\n\nvector<int> v2l(const pair<vector<int>, vector<int>>& v)\n{\n    vector<int> p(N);    \n    for (int i = 0; i < 3; i++) {\n        p[i] = v.first[i] + v.second[i] * W;  \n    }\n    return p;\n}\n\npair<vector<int>, vector<int>> l2v(const vector<int>& l)\n{\n    pair<vector<int>, vector<int>> v;\n    for (int i = 0; i < 3; i++) {        \n        v.first.emplace_back(l[i] % W);\n        v.second.emplace_back(l[i] / W);\n    }\n    return v;\n}\n\nbool d[MAX_H][MAX_W][MAX_H][MAX_W][MAX_H][MAX_W];\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<vector<int>> que;\n    queue<int> qc;\n    \n    que.push(v2l(make_pair(sx, sy)));    \n    qc.push(0);\n    \n    memset(d, 0, sizeof(d));\n    d[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]] = 1;\n\n    while (!que.empty()) {\n        auto f = l2v(que.front()); que.pop();\n        int c = qc.front(); qc.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) return c;\n                \n        for (int i = 0; i < 5; i++) {            \n            int nx0 = csx[0] + dx[i], ny0 = csy[0] + dy[i];\n            if (field[ny0][nx0] == '#') continue;\n            for (int j = 0; j < 5; j++) {                \n                int nx1 = csx[1], ny1 = csy[1];\n                \n                if (N >= 2) {\n                    nx1 += dx[j]; ny1 += dy[j];\n                    if (field[ny1][nx1] == '#') continue;\n                    if (same(nx0, ny0, nx1, ny1)) continue;\n                    if (same(nx0, ny0, csx[1], csy[1]) && same(csx[0], csy[0], nx1, ny1)) continue;                \n                }\n                for (int k = 0; k < 5; k++) {\n                    int nx2 = csx[2], ny2 = csy[2];\n                    \n                    if (N >= 3) {\n                        nx2 += dx[k]; ny2 += dy[k];\n                        if (field[ny2][nx2] == '#') continue;\n                        if (same(nx0, ny0, nx2, ny2) || same(nx1, ny1, nx2, ny2)) continue;\n                        if (same(nx0, ny0, csx[2], csy[2]) && same(csx[0], csy[0], nx2, ny2)) continue;                \n                        if (same(nx1, ny1, csx[2], csy[2]) && same(csx[1], csy[1], nx2, ny2)) continue;                \n                    }\n                    \n                    vector<int> nx = {nx0, nx1, nx2}, ny = {ny0, ny1, ny2};                     \n                    if (!d[ny0][nx0][ny1][nx1][ny2][nx2]) {\n                        d[ny0][nx0][ny1][nx1][ny2][nx2] = 1;\n                        \n                        que.push(v2l(make_pair(nx, ny)));\n                        qc.push(c + 1);\n                    }\n                }\n            }\n        }      \n    }    \n    return -1;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        while (sx.size() < 3) {\n            sx.emplace_back(0);\n            sy.emplace_back(0);\n            gx.emplace_back(0);\n            gy.emplace_back(0);\n        }\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nstruct State{\n    int pa,pb,pc;\n};\n\nconst int N = 16*16;\nconst int INF = 19191919;\nint dp[N][N][N];\n\nint main(){\n    int w,h,n;\n    while(cin >>w >>h >>n,w){\n        cin.ignore();\n        vector<string> f(h);\n        rep(i,h) getline(cin, f[i]);\n\n        auto cv = [&](pi p){\n            return p.fi*w+p.se;\n        };\n\n        int sa=0,sb=0,sc=0,ga=0,gb=0,gc=0;\n        rep(i,h)rep(j,w){\n            if(f[i][j]=='a') sa = cv({i,j});\n            if(f[i][j]=='b') sb = cv({i,j});\n            if(f[i][j]=='c') sc = cv({i,j});\n            if(f[i][j]=='A') ga = cv({i,j});\n            if(f[i][j]=='B') gb = cv({i,j});\n            if(f[i][j]=='C') gc = cv({i,j});\n        }\n\n        auto cand = [&](int p){\n            int y = p/w, x = p%w;\n\n            vector<int> ret;\n            ret.pb(p);\n\n            rep(d,4){\n                int ny = y+dy[d], nx = x+dx[d];\n                if(0<=ny && ny<h && 0<=nx && nx<w && f[ny][nx]!='#') ret.pb(cv({ny,nx}));\n            }\n            return ret;\n        };\n\n\n        rep(i,N)rep(j,N)rep(k,N) dp[i][j][k] = INF;\n        dp[sa][sb][sc] = 0;\n        queue<State> que;\n        que.push({sa,sb,sc});\n        while(!que.empty()){\n            State now = que.front();\n            que.pop();\n\n            vector<int> da = cand(now.pa), db = cand(now.pb), dc = cand(now.pc);\n\n            for(int A:da)for(int B:db)for(int C:dc){\n                if(B != 0){\n                    if(B == A) continue;\n                    if(now.pa == B && now.pb == A) continue;\n                }\n                if(C != 0){\n                    if(C == A || C == B) continue;\n                    if(now.pa == C && now.pc == A) continue;\n                    if(now.pb == C && now.pc == B) continue;\n                }\n\n                if(dp[A][B][C] > dp[now.pa][now.pb][now.pc]+1){\n                    dp[A][B][C] = dp[now.pa][now.pb][now.pc]+1;\n                    que.push({A,B,C});\n                }\n            }\n        }\n        cout << dp[ga][gb][gc] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++) \nstatic const int dy[] = { -1, 0, 1, 0, 0}, dx[] = { 0, -1, 0, 1, 0 };\n\nstruct state {\n        int a;\n        int b;\n        int c;\n        int step;\n};\n\nbool used[260][260][260];\n\nint main() {\n        int w, h, n;\n        while (true) {\n                cin >> w >> h >> n;\n                cin.ignore();\n                if (n == 0) break;\n                vector<string> m(h);\n                for (int i = 0; i < h; i ++) {\n                        getline(cin, m[i]);\n                }\n                int as, ag, bs = (h - 1) * w + (w - 1), bg = (h - 1) * w + (w - 1), cs = 0, cg = 0;\n                for (int i = 0; i < h; i ++) {\n                        for (int j = 0; j < w; j ++) {\n                                if (m[i][j] == 'A') as = i * w + j;\n                                if (m[i][j] == 'a') ag = i * w + j;\n                                if (m[i][j] == 'B') bs = i * w + j;\n                                if (m[i][j] == 'b') bg = i * w + j;\n                                if (m[i][j] == 'C') cs = i * w + j;\n                                if (m[i][j] == 'c') cg = i * w + j;\n                        }\n                }\n                queue<state> q;\n                memset(used, false, sizeof(used));\n                used[as][bs][cs] = true;\n                q.push((state) { as, bs, cs });\n                int ans = -1;\n                while (!q.empty()) {\n                        state now = q.front(); q.pop();\n                        if (now.a == ag && now.b == bg && now.c == cg) {\n                                ans = now.step;\n                                break;\n                        }\n                        int noway = now.a / w, nowax = now.a % w;\n                        int nowby = now.b / w, nowbx = now.b % w;\n                        int nowcy = now.c / w, nowcx = now.c % w;\n                        for (int da = 0; da < 5; da ++) {\n                                int neway = noway + dy[da], newax = nowax + dx[da];\n                                if (neway < 0 || h <= neway || newax < 0 || w <= newax) continue;\n                                if (m[neway][newax] == '#') continue;\n                                for (int db = 0; db < 5; db ++) {\n                                        int newby = nowby + dy[db], newbx = nowbx + dx[db];\n                                        if (newby < 0 || h <= newby || newbx < 0 || w <= newbx) continue;\n                                        if (n > 1) if (m[newby][newbx] == '#') continue;\n                                        for (int dc = 0; dc < 5; dc ++) {\n                                                int newcy = nowcy + dy[dc], newcx = nowcx + dx[dc];\n                                                if (newcy < 0 || h <= newcy || newcx < 0 || w <= newcx) continue;\n                                                if (n > 2) if (m[newcy][newcx] == '#') continue;\n                                                int newa = neway * w + newax;\n                                                int newb = newby * w + newbx;\n                                                int newc = newcy * w + newcx;\n                                                if (used[newa][newb][newc]) continue;\n                                                if (newa == newb || newa == newc || newb == newc) continue;\n                                                if (newa == now.b && newb == now.a) continue;\n                                                if (newa == now.c && newc == now.a) continue;\n                                                if (newb == now.c && newc == now.b) continue;\n                                                used[newa][newb][newc] = true;\n                                                q.push((state) { newa, newb, newc, now.step + 1 });\n                                        }\n                                }\n                        }\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint encode(const pair<int,int> *pos, int N)\n{\n  int s = 0;\n  for (int i = 0; i < N; i++) {\n    s = 256*s + pos[i].first*16 + pos[i].second;\n  }\n  return s;\n}\n\nvoid decode(pair<int,int> *ps, int s, int N)\n{\n  for (int i = 0; i < N; i++) {\n    const int t = s % 256;\n    ps[N-i-1] = make_pair(t/16, t%16);\n    s /= 256;\n  }\n}\n\nint manhattan(const pair<int,int> *ps, const pair<int,int> *fin, int N)\n{\n  int l = 0;\n  for (int i = 0; i < N; i++) {\n    l = max(l, abs(ps[i].first - fin[i].first) + abs(ps[i].second - fin[i].second));\n  }\n  return l;\n}\n\nbool calc_next(pair<int,int> *next, int N, const char grid[16][20], const pair<int,int> *ps, int a)\n{\n  for (int i = 0; i < N; i++) {\n    static const int di[] = {-1, 1, 0, 0, 0}, dj[] = {0, 0, -1, 1, 0};\n    const int k = ps[i].first + di[a%5];\n    const int l = ps[i].second + dj[a%5];\n    a /= 5;\n    if (grid[k][l] == '#') {\n      return false;\n    }\n    next[i] = make_pair(k, l);\n  }\n  return true;\n}\n\nbool valid(const pair<int,int> *cur, const pair<int,int> *next, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (next[i] == next[j]) {\n        return false;\n      }\n      if (next[i] == cur[j] && next[j] == cur[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  char buf[1000];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    pair<int,int> pos[3];\n    pair<int,int> fin[3];\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          pos[grid[i][j]-'a'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          fin[grid[i][j]-'A'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int final = encode(fin, N);\n    int A = 1;\n    for (int i = 0; i < N; i++) {\n      A *= 5;\n    }\n\n    static unsigned short dist[256*256*256];\n    fill_n(dist, 256*256*256, 1000);\n    dist[encode(pos, N)] = 0;\n    priority_queue<pair<short,int> > q;\n    q.push(make_pair(-manhattan(pos, fin, N), encode(pos, N)));\n    while (!q.empty()) {\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", dist[s]);\n        break;\n      }\n      pair<int,int> ps[3];\n      decode(ps, s, N);\n\n      for (int a = 0; a < A; a++) {\n        pair<int,int> next[3];\n        if (!calc_next(next, N, grid, ps, a)) {\n          continue;\n        }\n        const int u = encode(next, N);\n        if (dist[s]+1 >= dist[u]) {\n          continue;\n        }\n        if (valid(ps, next, N)) {\n          dist[u] = dist[s]+1;\n          q.push(make_pair(-dist[u]-manhattan(next, fin, N), u));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint manhattan(int s, int t, int N)\n{\n  int l = 0;\n  for (int i = 0; i < N; i++) {\n    const int a = (s >> (i*8))&0xff;\n    const int b = (t >> (i*8))&0xff;\n    l = max(l, abs((a>>4) - (b>>4)) + abs((a&0xf) - (b&0xf)));\n  }\n  return l;\n}\n\nint calc_next(int N, const char grid[16][20], int s, int *a)\n{\n  int next = 0;\n  for (int i = 0; i < N; i++) {\n    static const int di[] = {0, -1, 1, 0, 0}, dj[] = {0, 0, 0, -1, 1};\n    const int t = (s>>(i*8))&0xff;\n    const int k = (t>>4) + di[a[i]];\n    const int l = (t&0xf) + dj[a[i]];\n    if (grid[k][l] == '#') {\n      return -i-1;\n    }\n    const int u = ((k<<4) | l);\n    const int v = (s>>(8*i))&0xff;\n    for (int j = 0; j < i; j++) {\n      const int w = (next>>(8*j))&0xff;\n      if (u == w) {\n        return 0;\n      }\n      if (u == ((s>>(8*j))&0xff) && w == v) {\n        return 0;\n      }\n    }\n    next |= u<<(i*8);\n  }\n  return next;\n}\n\nint get(int s, const unsigned char *d1, const map<int,short>& d2)\n{\n  int d = d1[s];\n  if (d == 255) {\n    return 1000;\n  } else if (d == 254) {\n    return d2.find(s)->second;\n  } else {\n    return d;\n  }\n}\n\nvoid set(int s, unsigned char *d1, map<int,short>& d2, int d)\n{\n  if (d >= 254) {\n    d1[s] = 254;\n    d2[s] = d;\n  } else {\n    d1[s] = d;\n  }\n}\n\nint main()\n{\n  char buf[100];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    int init = 0, final = 0;\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          init |= (i<<4|j) << (8*(grid[i][j]-'a'));\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          final |= (i<<4|j) << (8*(grid[i][j]-'A'));\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int A = N >= 0 ? 5 : 1;\n    const int B = N >= 1 ? 5 : 1;\n    const int C = N >= 2 ? 5 : 1;\n\n    static unsigned char dist[256*256*256];\n    fill_n(dist, 256*256*256, 255);\n    map<int,short> dist2;\n    dist[init] = 0;\n    priority_queue<pair<short,int> > q;\n    q.push(make_pair(-manhattan(init, final, N), init));\n    while (!q.empty()) {\n      const int cost = -q.top().first;\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", cost);\n        break;\n      }\n      const int d = cost - manhattan(s, final, N);\n      const int d2 = get(s, dist, dist2);\n      if (d > d2) {\n        continue;\n      }\n\n      for (int a = 0; a < A; a++) {\n        for (int b = 0; b < B; b++) {\n          for (int c = 0; c < C; c++) {\n            int v[3] = {a, b, c};\n            int next = calc_next(N, grid, s, v);\n            if (next == 0) {\n              continue;\n            } else if (next < 0) {\n              if (next == -1) {\n                goto SKIP_A;\n              } else if (next == -2) {\n                goto SKIP_B;\n              } else {\n                continue;\n              }\n            }\n            const int du = get(next, dist, dist2);\n            if (d+1 < du) {\n              set(next, dist, dist2, d+1);\n              q.push(make_pair(-d-1-manhattan(next, final, N), next));\n            }\n          }\nSKIP_B:\n          ;\n        }\nSKIP_A:\n        ;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return a.dist > b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\nint cnt = 0;\n        while (not que.empty()) {\ncnt ++;\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n// cerr << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint d[16][16][16][16][16][16];\n\nint main(){\n  \n    \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost += ev[p.p[i]][goal[i]];\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(35);\n      makeEv();\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.1 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 100000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nP goal[MAX_N];\nP start[MAX_N];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\nvoid add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nvoid move(State& s, const State& prev, int k, map<int, int>& dist, priority_queue<State>& que){\n  if(k == 0) s.d++;\n  if(k == N){\n    if(!valid(s, prev)) return;\n    int h = 0;\n    REP(i, N){\n      h = max(h, calc_distance(s.p[i], goal[i]));\n    }\n    s.f = s.d + h;\n    add(s, que);\n  }else{\n    REP(r, 5){\n      if(valid(s.p[k].first + dx[r], s.p[k].second + dy[r], W, H)){\n        s.p[k].first += dx[r];\n        s.p[k].second += dy[r];\n        move(s, prev, k + 1, dist, que);\n        s.p[k].first -= dx[r];\n        s.p[k].second -= dy[r];\n      }\n    }\n  }\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n    //  print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      State ss = s;\n\n      move(s, ss, 0, dist, que);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tfor (int k = 0; k < 15; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 15; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 15; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 15; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx]) {\n\t\t\t\t\t\taok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!aok)continue;\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))continue;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: Oct 11, 2013\n *      Author: Hesham\n */\n#include<iostream>\n#include<string>\n#include<map>\n#include<ctime>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<algorithm>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<bitset>\n#include<fstream>\n#include<cmath>\n#include<cassert>\n#include <stdio.h>\n#include<ctype.h>\nusing namespace std;\nint dx[] = { 0, 0, 1, -1, 0 };\nint dy[] = { 0, 1, 0, 0, -1 };\nint w, h, n;\nstring house[16];\nstruct State {\n\tvector<int> y, x;\n\tState() {\n\t\tx.resize(3, 0);\n\t\ty.resize(3, 0);\n\t}\n\tState(vector<int>& yy, vector<int>& xx) :\n\t\t\tx(xx), y(yy) {\n\t}\n\tbool operator ==(const State& other) const {\n\t\treturn x == other.x && y == other.y;\n\t}\n};\nbool vis1[16][16][16][16][16][16];\nbool vis2[16][16][16][16][16][16];\n//short dist[16][16][16][16][16][16];\n\nbool isVis(State& s, bool vis[16][16][16][16][16][16]) {\n\treturn vis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setVis(State& s, bool vis[16][16][16][16][16][16]) {\n\tvis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = true;\n}\n/*int getDist(State& s) {\n\treturn dist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}*/\n/*void setDist(State& s, int v) {\n\tdist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = v;\n}*/\n\nbool ok(int y, int x) {\n\tif (y < 0 || y == h || x < 0 || x == w)\n\t\treturn false;\n\tif (house[y][x] == '#')\n\t\treturn false;\n\treturn true;\n}\nint d1, d2;\nint c11, c12, c21, c22;\nint pushAdjs(int i, State& adj, State& curr, queue<State>& q,\n\t\tbool visA[16][16][16][16][16][16], bool visB[16][16][16][16][16][16], int da, int db, int& c) {\n\tif (i == n) {\n\t\tif (isVis(adj, visA))\n\t\t\treturn -1;\n\t\tif (isVis(adj, visB))\n\t\t\treturn da + 1 + db;\n\t\tsetVis(adj, visA);\n\t\tq.push(adj);\n\t\t++c;\n\t\treturn -1;\n\t}\n\tfor (int d = 0; d < 5; ++d) {\n\t\tadj.y[i] = dy[d] + curr.y[i];\n\t\tadj.x[i] = dx[d] + curr.x[i];\n\t\tif (!ok(adj.y[i], adj.x[i]))\n\t\t\tcontinue;\n\t\tbool okk = true;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (adj.y[i] == curr.y[j] && adj.x[i] == curr.x[j]&&\n\t\t\t    adj.y[j] == curr.y[i] && adj.x[j] == curr.x[i]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (adj.y[i] == adj.y[j] && adj.x[i] == adj.x[j]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!okk)\n\t\t\tcontinue;\n\t\tint cost = pushAdjs(i + 1, adj, curr, q, visA, visB, da, db, c);\n\t\tif (cost != -1)\n\t\t\treturn cost;\n\t}\n\treturn -1;\n}\nint meetMiddle(vector<int>& sy, vector<int>& sx, vector<int>& ty,\n\t\tvector<int>& tx) {\n\tmemset(vis1, false, sizeof vis1);\n\tmemset(vis2, false, sizeof vis2);\n\tState s(sy, sx);\n\tState t(ty, tx);\n\t//setDist(s, 0);\n\t//setDist(t, 0);\n\td1 = 0;\n\td2 = 0;\n\tc11 = 1, c12 = 0, c21 = 1, c22 = 0;\n\tsetVis(s, vis1);\n\tsetVis(t, vis2);\n\tqueue<State> q1;\n\tqueue<State> q2;\n\tq1.push(s);\n\tq2.push(t);\n\twhile (true) {\n\t\tif(d1 <= d2)\n\t\t{\n\t\t\tState curr1 = q1.front();\n\t\t\tq1.pop();\n\t\t\t--c11;\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr1, q1, vis1, vis2, d1, d2, c12);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t\tif(!c11){\n\t\t\t\tswap(c11, c12);\n\t\t\t\td1++;\n\t\t\t}\n\t\t}\n\t\tif(d2 < d1)\n\t\t{\n\t\t\tState curr2 = q2.front();\n\t\t\tq2.pop();\n\t\t\t--c21;\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr2, q2, vis2, vis1, d2, d1, c22);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t\tif(!c21){\n\t\t\t\tswap(c21, c22);\n\t\t\t\td2++;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//clock_t begin = clock();\n\tstring line;\n\twhile (cin >> w >> h >> n) {\n\t\tif (!w && !h && !n)\n\t\t\tbreak;\n\t\tcin.ignore();\n\t\tcin.ignore();\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tgetline(cin, house[i]);\n\n\t\tvector<int> sx(3, 0);\n\t\tvector<int> sy(3, 0);\n\n\t\tvector<int> tx(3, 0);\n\t\tvector<int> ty(3, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (house[i][j] >= 'A' && house[i][j] <= 'C') {\n\t\t\t\t\ttx[(house[i][j] - 'A')] = j;\n\t\t\t\t\tty[(house[i][j] - 'A')] = i;\n\t\t\t\t}\n\t\t\t\tif (house[i][j] >= 'a' && house[i][j] <= 'c') {\n\t\t\t\t\tsx[(house[i][j] - 'a')] = j;\n\t\t\t\t\tsy[(house[i][j] - 'a')] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << meetMiddle(sy, sx, ty, tx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 16 * 16 + 2;\n//const int IINF = INT_MAX;\nconst short IINF = 32760;\nstruct Data {\n  int p[3],cost;\n  \n  bool operator < ( const Data &data ) const {\n    return cost > data.cost;\n  }\n};\n\n\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint w,h,n,gn,sn;\nchar c[20][20];\nshort mindist[MAX][MAX][MAX];\n\nint gs[3],sp[3];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nbool isValidMove(Data cur,Data next){\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == next.p[j] ) return false;\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == cur.p[j] && next.p[j] == cur.p[i] ) return false;\n  return true;\n}\n\nvoid printState(Data cur){\n  rep(i,h){\n    rep(j,w){\n      bool f = false;\n      rep(k,sn) if( cur.p[k] == j + i*w ) {\n\tcout << (char)('a'+k);\n\tf = true;\n\tbreak;\n      }\n      if( f ) continue;\n      cout << c[i][j];\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nvoid dfs(priority_queue<Data> &Q,int cur,Data state,int mask,Data prev){\n  if( cur >= sn ) {\n\n    if( isValidMove(prev,state) ) {\n\n      int A=MAX-1,B=MAX-1,C=MAX-1;\n      if( sn >= 1 ) A = state.p[0];\n      if( sn >= 2 ) B = state.p[1];\n      if( sn >= 3 ) C = state.p[2];\n      if( mindist[A][B][C] > state.cost ) {\n\tmindist[A][B][C] = state.cost;\n\tQ.push(state);\n      }\n\n    }\n    return;\n  }\n  if( !( ( mask >> cur ) & 1 ) ) {\n    dfs(Q,cur+1,state,mask,prev);\n    return;\n  }\n  int x = state.p[cur] % w, y = state.p[cur] / w;\n  rep(i,5){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( c[ny][nx] == '#' ) continue;\n    state.p[cur] = nx + ny * w;\n    dfs(Q,cur+1,state,mask,prev);\n  }\n  state.p[cur] = x + y * w;\n}\n\nvoid pushNextState(priority_queue<Data> &Q,int mask,int cost,Data cdata){\n  Data state = cdata;\n  ++state.cost;\n  dfs(Q,0,state,mask,cdata);\n}\n\n\n\nvoid compute(){\n  rep(i,MAX)rep(j,MAX)rep(k,MAX) mindist[i][j][k] = IINF;\n  gn = 0;\n  rep(i,h) rep(j,w) if( 'A' <= c[i][j] && c[i][j] <= 'C' ) {\n    gs[c[i][j]-'A'] = j + i * w;\n    c[i][j] = '.';\n    ++gn;\n  }\n\n  sn = 0;\n  rep(i,h) rep(j,w) if( 'a' <= c[i][j] && c[i][j] <= 'c' ) {\n    sp[c[i][j]-'a'] = j + i * w;\n    c[i][j] = '.';\n    ++sn;\n  }\n  priority_queue<Data> Q;\n  {\n    Data data;\n    data.cost = 0;\n    rep(i,sn) data.p[i] = sp[i];\n    Q.push(data);\n  }\n  bool found = false;\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n\n    bool fin = true;\n    rep(i,gn) if( gs[i] != data.p[i] ) {\n      fin = false;\n      break;\n    }\n    if( fin ) {\n      found = true;\n\n      printf(\"%d\\n\",data.cost);\n      return;\n    }\n    rep(mask,(1<<sn)){\n      pushNextState(Q,mask,data.cost,data);\n    }\n    \n  }\n  assert(found);\n}\n\nint main(){\n  while( cin >> w >> h >> n, w|h|n ){\n    cin.ignore();\n    rep(i,h) {\n      string s;\n      getline(cin,s);\n      rep(j,w) {\n\tif( s[j] == ' ' ) s[j] = '.';\n\tc[i][j] = s[j];\n      }\n    }\n\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n \nconst int MAXW = 16;\nconst int MAXH = 16;\nconst int COSTSIZE = 14;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nconst int INF = 1<<28;\n \nint W, H, N;\nstring C[MAXH];\nint cost[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nbool vis[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nint ans;\n\nstruct State {\n  vector<pair<int,int> > ps;\n  bool operator < (const State &s) const {\n    return ps < s.ps;\n  }\n};\n \nvector<pair<int,int> > npos(int i, int j) {\n  vector<pair<int,int> > v;\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(C[ni][nj] == '#') continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  return v;\n}\n \ninline void putCost(const State &s, int c) {\n  if(N == 1) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getCost(const State &s) {\n  if(N == 1) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \ninline void putVis(const State &s, bool c) {\n  if(N == 1) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getVis(const State &s) {\n  if(N == 1) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \nvoid rec(vector<vector<pair<int,int> > > &v, queue<State> &que, const State &s, State &t, int k) {\n  if(k == N) {\n    if(!getVis(t)) {\n      if(getCost(t) == INF) {\n        que.push(t);\n        putCost(t, getCost(s) + 1);\n        putVis(t, true);\n      } else {\n        ans = min(ans, getCost(t) + getCost(s) + 1);\n        putVis(t, true);\n        throw 0;\n      }\n    }\n    return;\n  }\n \n  for(int i = 0; i < v[k].size(); ++i) {\n    bool flag = true;\n    t.ps[k] = v[k][i];\n    for(int j = 0; j < k; ++j) {\n      if(t.ps[k] == t.ps[j]) {\n        flag = false;\n        break;\n      }\n      if(s.ps[k] == t.ps[j] && s.ps[j] == t.ps[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      rec(v, que, s, t, k+1);\n    }\n  }\n}\n \nbool isFinished(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    int ni = s.ps[i].first;\n    int nj = s.ps[i].second;\n    if(C[ni][nj]-'A' != i) return false;\n  }\n  return true;\n}\n \nvoid show(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s.ps[i].first << \", \" << s.ps[i].second;\n    cout << endl;\n  }\n}\n \nint bfs(State initS, bool flag = true) {\n  queue<State> que;\n  que.push(initS);\n  memset(vis, 0, sizeof(vis));\n  putCost(initS, 0);\n  putVis(initS, true);\n  while(!que.empty()) {\n    const State s = que.front();\n    que.pop();\n    if(!flag && getCost(s) >= 50) continue;\n    if(getCost(s)*2 >= ans) continue;\n    vector<vector<pair<int,int> > > v(N);\n    for(int i = 0; i < N; ++i) {\n      v[i] = npos(s.ps[i].first, s.ps[i].second);\n    }\n    State t = s;\n    rec(v, que, s, t, 0);\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> W >> H >> N && (W|H|N)) {\n    cin.ignore();\n    for(int i = 0; i < H; ++i) {\n      getline(cin, C[i]);\n    }\n    State s, t;\n    s.ps.resize(N);\n    t.ps.resize(N);\n    pair<int,int> a, b, c;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        int k;\n        k = C[i][j] - 'a';\n        if(0 <= k && k < N) {\n          s.ps[k] = make_pair(i,j);\n        }\n        k = C[i][j] - 'A';\n        if(0 <= k && k < N) {\n          t.ps[k] = make_pair(i,j);\n        }\n      }\n    }\n    fill(cost[0][0][0][0][0], cost[COSTSIZE][0][0][0][0], INF);\n    ans = INF;\n    bfs(t, false);\n    try {\n      bfs(s);\n    } catch(...) {}\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint encode(const pair<int,int> *pos, int N)\n{\n  int s = 0;\n  for (int i = 0; i < N; i++) {\n    s = 256*s + pos[i].first*16 + pos[i].second;\n  }\n  return s;\n}\n\nvoid decode(pair<int,int> *ps, int s, int N)\n{\n  for (int i = 0; i < N; i++) {\n    const int t = s % 256;\n    ps[N-i-1] = make_pair(t/16, t%16);\n    s /= 256;\n  }\n}\n\nint manhattan(const pair<int,int> *ps, const pair<int,int> *fin, int N)\n{\n  int l = 0;\n  for (int i = 0; i < N; i++) {\n    l = max(l, abs(ps[i].first - fin[i].first) + abs(ps[i].second - fin[i].second));\n  }\n  return l;\n}\n\nbool calc_next(pair<int,int> *next, int N, const char grid[16][20], const pair<int,int> *ps, int a)\n{\n  for (int i = 0; i < N; i++) {\n    static const int di[] = {-1, 1, 0, 0, 0}, dj[] = {0, 0, -1, 1, 0};\n    const int k = ps[i].first + di[a%5];\n    const int l = ps[i].second + dj[a%5];\n    a /= 5;\n    if (grid[k][l] == '#') {\n      return false;\n    }\n    next[i] = make_pair(k, l);\n  }\n  return true;\n}\n\nbool valid(const pair<int,int> *cur, const pair<int,int> *next, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (next[i] == next[j]) {\n        return false;\n      }\n      if (next[i] == cur[j] && next[j] == cur[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  char buf[1000];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    pair<int,int> pos[3];\n    pair<int,int> fin[3];\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          pos[grid[i][j]-'a'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          fin[grid[i][j]-'A'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int final = encode(fin, N);\n    int A = 1;\n    for (int i = 0; i < N; i++) {\n      A *= 5;\n    }\n\n    static int dist[256*256*256];\n    fill_n(dist, 256*256*256, 10000000);\n    dist[encode(pos, N)] = 0;\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(-manhattan(pos, fin, N), encode(pos, N)));\n    while (!q.empty()) {\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", dist[s]);\n        break;\n      }\n      pair<int,int> ps[3];\n      decode(ps, s, N);\n\n      for (int a = 0; a < A; a++) {\n        pair<int,int> next[3];\n        if (!calc_next(next, N, grid, ps, a)) {\n          continue;\n        }\n        const int u = encode(next, N);\n        if (dist[s]+1 >= dist[u]) {\n          continue;\n        }\n        if (valid(ps, next, N)) {\n          dist[u] = dist[s]+1;\n          q.push(make_pair(-dist[u]-manhattan(next, fin, N), u));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<bitset>\n#include<queue>\nchar m[32][32];\nint n,dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\nstd::bitset<1<<24 >f;\nvoid I2P(int a,int*x,int*y)\n{\n\tfor(int i=0;i<n;++i)\n\t{\n\t\ty[n-i-1]=a&15;\n\t\tx[n-i-1]=(a>>4)&15;\n\t\ta>>=8;\n\t}\n}\nint P2I(int*x,int*y)\n{\n\tint res=0,i;\n\tfor(i=0;i<n;++i)\n\t\tres=(res<<8)|(x[i]<<4)+y[i];\n\treturn res;\n}\nint EQ(int*x,int*y,int*gx,int*gy)\n{\n\tfor(int i=0;i<n;++i)\n\t\tif(x[i]-gx[i]||y[i]-gy[i])\n\t\t\treturn 0;\n\treturn 1;\n}\nvoid G(std::queue<int>&q, int*x,int*y,int*nx,int*ny,int i)\n{\n\tint j,k;\n\tif(i==n)\n\t{\n\t\tint a=P2I(nx,ny);\n\t\tif(f[a])return;\n\t\tfor(j=0;j<n;++j)\n\t\t\tfor(k=j+1;k<n;++k)\n\t\t\t\tif(x[j]==nx[k]&&y[j]==ny[k]&&\n\t\t\t\t   x[k]==nx[j]&&y[k]==ny[j])\n\t\t\t\t\treturn;\n\t\tq.push(a);\n\t}\n\telse\n\t\tfor(k=0;k<5;++k)\n\t\t{\n\t\t\tnx[i]=x[i]+dx[k];\n\t\t\tny[i]=y[i]+dy[k];\n\t\t\tif(m[ny[i]][nx[i]]=='#')\n\t\t\t\tcontinue;\n\t\t\tfor(j=0;j<i;++j)\n\t\t\t\tif(nx[i]==nx[j]&&ny[i]==ny[j])\n\t\t\t\t\tgoto N;\n\t\t\tG(q,x,y,nx,ny,i+1);\n\t\t\tN:;\n\t\t}\n}\nint F(int (&x)[3],int (&y)[3],int (&gx)[3],int(&gy)[3])\n{\n\tf.reset();\n\tstd::queue<int>q;\n\tq.push(P2I(x,y));\n\tq.push(-1);\n\tint a,res=0;\n\tint nx[3],ny[3];\n\tfor(;;)\n\t{\n\t\ta=q.front();\n\t\tq.pop();\n\t\tif(a<0)\n\t\t{\n\t\t\t++res;\n\t\t\tq.push(a);\n\t\t\tcontinue;\n\t\t}\n\t\tif(f[a])continue;\n\t\tf[a]=true;\n\t\tI2P(a,x,y);\n\t\tif(EQ(x,y,gx,gy))return res;\n\t\tG(q,x,y,nx,ny,0);\n\t}\n}\nint main()\n{\n\tint h,w,i,x[3],y[3],gx[3],gy[3];\n\tchar*p;\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),n)\n\t{\n\t\tfgets(m[0],32,stdin);\n\t\tfor(i=0;i<h;++i)\n\t\t{\n\t\t\tfgets(m[i],32,stdin);\n\t\t\tfor(p=m[i];p=strpbrk(p,\"abc\");++p)\n\t\t\t{\n\t\t\t\ty[*p-'a']=i;\n\t\t\t\tx[*p-'a']=p-m[i];\n\t\t\t}\n\t\t\tfor(p=m[i];p=strpbrk(p,\"ABC\");++p)\n\t\t\t{\n\t\t\t\tgy[*p-'A']=i;\n\t\t\t\tgx[*p-'A']=p-m[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",F(x,y,gx,gy));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nconst int dy[] = {-1,0,1,0,0}, dx[] = {0,1,0,-1,0};\n\ninline int encode(const vi &x, const int &w){\n  int res = 0, k = 1;\n  for(int p : x){\n    res += k * p;\n    k <<= 8;\n  }\n  return res;\n}\n\ninline vi decode(int x, const int &n, const int &w){\n  int k = 1<<8;\n  vi res(n);\n  rep(i,n){\n    res[i] = x & (k-1);\n    x >>= 8;\n  }\n  return res;\n}\n\nshort memo[1<<24];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int h,w,n;\n  string g[16];\n  while(cin >> w >> h >> n, w){\n    cin.ignore();\n\n    vi start(n), end(n);\n    rep(i,h){\n      getline(cin,g[i]);\n      rep(j,w){\n\tif(islower(g[i][j]))start[g[i][j]-'a'] = i*w+j;\n\tif(isupper(g[i][j]))end[g[i][j]-'A'] = i*w+j;\n      }\n    }\n    int start_id = encode(start,w);\n    int end_id = encode(end,w);\n\n    vector<int> edge[256];\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '#')continue;\n      rep(d,5){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(g[ny][nx] !='#')edge[i*w+j].push_back(ny*w+nx);\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n    memo[start_id] = 0;\n    queue<int> q;\n    q.push(start_id);\n    \n    while(q.size()){\n      int cur_id = q.front(); q.pop();\n      vi cur = decode(cur_id,n,w), nxt(n);\n\n      vi dir(n,0);\n      while(dir[n-1]<(int)edge[cur[n-1]].size()){\n\tbool f = true;\n\trep(i,n)nxt[i] = edge[cur[i]][dir[i]];\n\n\tfor(int i=0;f && i<n;i++){\n\t  for(int j=0;f && j<i;j++){\n\t    if(nxt[i] == nxt[j])f = false;\n\t    if(nxt[i] == cur[j] && nxt[j] == cur[i])f = false;\n\t  }\n\t}\n\n\tif(f){\n\t  int nxt_id = encode(nxt, w);\n\t  if(memo[nxt_id] < 0){\n\t    memo[nxt_id] = memo[cur_id] + 1;\n\t    if(nxt_id == end_id)goto OUTPUT;\n\t    q.push(nxt_id);\n\t  }\n\t}\n\n\tdir[0]++;\n\tfor(int i=0;i<n-1;i++){\n\t  if(dir[i]==(int)edge[cur[i]].size())dir[i] = 0, dir[i+1]++;\n\t}\n      }\n\n    }\n  OUTPUT: cout << memo[end_id] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j) {\n\t\t\t\tfor (int k = 0; k < 16; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 16; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 16; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 16; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx])aok = false;\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))aok = false;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// forked from http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1587939#1\n#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n \nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n \narray<point_t,3> start, goal;\nint dist(const array<point_t, 3>& s, const array<point_t, 3>& t) {\n    int r = 0;\n    for (int i = 0; i < 3; i++) {\n        r += abs(s[i].x - t[i].x);\n        r += abs(s[i].y - t[i].y);\n    }\n    return r;\n}\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    bool operator<(const state_t& s) const {\n        if (cost == s.cost) {\n            return dist(a, goal) > dist(s.a, goal);\n        } else {\n            return cost > s.cost;\n        }\n    }\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n \nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n \n        assert (1 <= n and n <= 3);\n        //array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n \n        unordered_set<uint32_t> used;\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\nchar f[16][16];\nint fx,fy,N;\nint dx[] = {0, 0, -1, 1, 0};\nint dy[] = {0, -1, 0, 0, 1};\n\nclass Ghost\n{\npublic:\n\tint x[3],y[3],c;\n\tbool r;\n\t\n\tGhost(int* i, int* j, int c, bool r)\n\t:r(r),c(c)\n\t{\n\t\tfor(int k=0; k<3; k++)\n\t\t{\n\t\t\tx[k]=i[k];\n\t\t\ty[k]=j[k];\n\t\t\t\n\t\t}\n\t}\n};\n\nbool move(int x, int y, int p)\n{\n\tif(p>=N) return true;\n\tif(x<0||y<0||x>=fx||y>=fy) return false;\n\tif(f[x][y]=='#') return false;\n\t\n\treturn true;\n}\n\nbool crash(int* x, int* y, int* gx, int* gy, int p)\n{\n\tif(p<N) return false;\n\tfor(int i=0; i<p; i++)\n\tfor(int j=i+1; j<p; j++)\n\t{\n\t\tif(x[i]==x[j]&&y[i]==y[j]) return true;\n\t\tif(x[i]==gx[j]&&y[i]==gy[j]&&gx[i]==x[j]&&gy[i]==y[j]) return true;\n\t}\n\treturn false;\n}\n\nunsigned char h[256][256][256][2];\n\nint main()\n{\t\n\twhile(scanf(\"%d%d%d\",&fx,&fy,&N), (fx||fy||N))\n\t{\n\t\tint sx[3]={0},sy[3]={0},gx[3]={0},gy[3]={0};\n\t\tmemset(h,0,sizeof(h));\n\t\t\t\n\t\tstring s;\n\t\t\n\t\tgetchar();\n\t\tfor(int i=0; i<fy; i++)\n\t\t{\n\t\t\tgetline(cin, s);\n\t\t\tfor(int j=0; j<fx; j++)\n\t\t\t{\n\t\t\t\tif(islower(s[j]))\n\t\t\t\t{\n\t\t\t\t\tsx[s[j]-'a']=j;\n\t\t\t\t\tsy[s[j]-'a']=i;\n\t\t\t\t}\n\t\t\t\tif(isupper(s[j]))\n\t\t\t\t{\n\t\t\t\t\tgx[s[j]-'A']=j;\n\t\t\t\t\tgy[s[j]-'A']=i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf[j][i]=s[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Ghost> q;\n\t\tq.push(Ghost(sx,sy,1,0));\n\t\tq.push(Ghost(gx,gy,1,1));\n\t\t\n\t\tint th[3];\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(sx[l]<<4)+sy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][0]=1;\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(gx[l]<<4)+gy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][1]=1;\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tGhost g=q.front(); q.pop();\n\t\t\t\n\t\t\tint th[3];\n\n\t\t\tfor(int l=0; l<3; l++)\n\t\t\t{\n\t\t\t\tth[l]=(g.x[l]<<4)+g.y[l];\n\t\t\t}\n\n\t\t\tif(h[th[0]][th[1]][th[2]][!g.r])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", g.c+h[th[0]][th[1]][th[2]][!g.r]-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint tx[3],ty[3];\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\ttx[i]=g.x[i];\n\t\t\t\tty[i]=g.y[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<5; i++)\n\t\t\t{\n\t\t\t\ttx[0]=g.x[0]+dx[i], ty[0]=g.y[0]+dy[i];\n\t\t\t\tif(!move(tx[0],ty[0],0))\n\t\t\t\t{\n\t\t\t\t\ttx[0]=g.x[0];\n\t\t\t\t\tty[0]=g.y[0];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<(N>1?5:1); j++)\n\t\t\t\t{\n\t\t\t\t\ttx[1]=g.x[1]+dx[j], ty[1]=g.y[1]+dy[j];\n\t\t\t\t\tif(N>=2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!move(tx[1],ty[1], 1) || (crash(tx,ty,g.x,g.y,2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[1]=g.x[1];\n\t\t\t\t\t\t\tty[1]=g.y[1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0; k<(N>2?5:1); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttx[2]=g.x[2]+dx[k], ty[2]=g.y[2]+dy[k];\n\t\t\t\t\t\tif(N>=3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!move(tx[2],ty[2], 2) || (crash(tx,ty,g.x,g.y,3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0; l<3; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tth[l]=(tx[l]<<4)+ty[l];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(h[th[0]][th[1]][th[2]][g.r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th[th[0]][th[1]][th[2]][g.r]=g.c;\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tq.push(Ghost(tx, ty, g.c+1,g.r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tshort x[3],y[3];\n\tdata(){}\n};\n\nshort dx[5]={0,1,-1,0,0};\nshort dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nshort dp[196][196][196];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tdata nd=d;\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]=d.x[j]+dx[pi%5];\n\t\t\t\tnd.y[j]=d.y[j]+dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nstatic const int di[] = {0, -1, 1, 0, 0}, dj[] = {0, 0, 0, -1, 1};\n\ninline int h(int s, const unsigned short hh[3][256], int N)\n{\n  unsigned short l = 0;\n  for (int i = 0; i < N; i++) {\n    l = max(l, hh[i][(s>>(i<<3))&0xff]);\n  }\n  return l;\n}\n\nint calc_next(int N, const char grid[16][20], int s, int *a)\n{\n  int next = 0;\n  for (int i = 0; i < N; i++) {\n    const int t = (s>>(i<<3))&0xff;\n    const int k = (t>>4) + di[a[i]];\n    const int l = (t&0xf) + dj[a[i]];\n    if (grid[k][l] == '#') {\n      return -i-1;\n    }\n    const int u = (k<<4)|l;\n    const int v = (s>>(i<<3))&0xff;\n    for (int j = 0; j < i; j++) {\n      const int w = (next>>(j<<3))&0xff;\n      if (u == w) {\n        return 0;\n      }\n      if (u == ((s>>(j<<3))&0xff) && w == v) {\n        return 0;\n      }\n    }\n    next |= u<<(i<<3);\n  }\n  return next;\n}\n\ninline int get(int s, const unsigned char *d1, const map<int,short>& d2)\n{\n  int d = d1[s];\n  if (d == 255) {\n    return 1000;\n  } else if (d == 254) {\n    return d2.find(s)->second;\n  } else {\n    return d;\n  }\n}\n\ninline void set(int s, unsigned char *d1, map<int,short>& d2, int d)\n{\n  if (d >= 254) {\n    d1[s] = 254;\n    d2[s] = d;\n  } else {\n    d1[s] = d;\n  }\n}\n\nint main()\n{\n  char buf[100];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    int init = 0, final = 0;\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          init |= (i<<4|j) << ((grid[i][j]-'a')<<3);\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          final |= (i<<4|j) << ((grid[i][j]-'A')<<3);\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int A = N >= 0 ? 5 : 1;\n    const int B = N >= 1 ? 5 : 1;\n    const int C = N >= 2 ? 5 : 1;\n\n    static unsigned short int hh[3][256];\n    for (int i = 0; i < N; i++) {\n      fill_n(hh[i], 256, 1000);\n      queue<int> q;\n      q.push((final>>(i<<3))&0xff);\n      hh[i][(final>>(i<<3))&0xff] = 0;\n      while (!q.empty()) {\n        const int s = q.front();\n        const int x = s>>4;\n        const int y = s&0xf;\n        q.pop();\n        for (int d = 1; d < 5; d++) {\n          const int k = x + di[d];\n          const int l = y + dj[d];\n          const int t = (k<<4)|l;\n          if (grid[k][l] != '#' && hh[i][s]+1 < hh[i][t]) {\n            hh[i][t] = hh[i][s]+1;\n            q.push(t);\n          }\n        }\n      }\n    }\n\n    static unsigned char dist[256*256*256];\n    fill_n(dist, 256*256*256, 255);\n    map<int,short> dist2;\n    dist[init] = 0;\n    priority_queue<pair<short,int> > q;\n    q.push(make_pair(-h(init, hh, N), init));\n    while (!q.empty()) {\n      const int cost = -q.top().first;\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", cost);\n        break;\n      }\n      const int d = cost - h(s, hh, N);\n      const int d2 = get(s, dist, dist2);\n      if (d > d2) {\n        continue;\n      }\n\n      bool inv[5] = {false, false, false, false, false};\n      int a[3];\n      for (a[0] = 0; a[0] < A; a[0]++) {\n        for (a[1] = 0; a[1] < B; a[1]++) {\n          if (inv[a[1]]) {\n            continue;\n          }\n          for (a[2] = 0; a[2] < C; a[2]++) {\n            const int next = calc_next(N, grid, s, a);\n            if (next == 0) {\n              continue;\n            } else if (next < 0) {\n              if (next == -1) {\n                goto SKIP_A;\n              } else if (next == -2) {\n                inv[a[1]] = true;\n                goto SKIP_B;\n              } else {\n                continue;\n              }\n            }\n            const int du = get(next, dist, dist2);\n            if (d+1 < du) {\n              set(next, dist, dist2, d+1);\n              q.push(make_pair(-d-1-h(next, hh, N), next));\n            }\n          }\nSKIP_B:\n          ;\n        }\nSKIP_A:\n        ;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nint cost[3][16][16];\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;;\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<ghost>& S,int now,int n){\n  if ( n == now){\n    if ( dest.legal(source) && S.find(dest.data) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n\t\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<ghost> S;\n  S.insert(ini);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n  /*\n  cout << \"bfs for \" << num<< \" th ghoast\" << endl;\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      if ( cost[num][i][j] == INF)cout << \"x  \";\n      else cout << cost[num][i][j] << \"  \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nconst int dy[] = {-1,0,1,0,0}, dx[] = {0,1,0,-1,0};\n\ninline int encode(const vi &x, const int &w){\n  int res = 0, k = 1;\n  for(int p : x){\n    res += k * p;\n    k <<= 8;\n  }\n  return res;\n}\n\ninline vi decode(int x, const int &n, const int &w){\n  int k = 1<<8;\n  vi res(n);\n  rep(i,n){\n    res[i] = x & (k-1);\n    x >>= 8;\n  }\n  return res;\n}\n\nshort memo[1<<24];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int h,w,n;\n  string g[16];\n  while(cin >> w >> h >> n, w){\n    cin.ignore();\n\n    vi start(n), end(n);\n    rep(i,h){\n      getline(cin,g[i]);\n      rep(j,w){\n\tif(islower(g[i][j]))start[g[i][j]-'a'] = i*w+j;\n\tif(isupper(g[i][j]))end[g[i][j]-'A'] = i*w+j;\n      }\n    }\n    int start_id = encode(start,w);\n    int end_id = encode(end,w);\n\n    vector<int> edge[256];\n    rep(i,h)rep(j,w){\n      if(g[i][j] == '#')continue;\n      rep(d,5){\n\tint ny = i+dy[d], nx = j+dx[d];\n\tif(g[ny][nx] !='#')edge[i*w+j].push_back(ny*w+nx);\n      }\n    }\n\n    memset(memo,-1,sizeof(memo));\n    memo[start_id] = 0;\n    queue<int> q;\n    q.push(start_id);\n    \n    while(q.size()){\n      int cur_id = q.front(); q.pop();\n      vi cur = decode(cur_id,n,w), nxt(n);\n      if(cur_id == end_id)break;\n\n      vi dir(n,0); dir[0] = 0;\n      while(dir[n-1]<(int)edge[cur[n-1]].size()){\n\tbool f = true;\n\trep(i,n)nxt[i] = edge[cur[i]][dir[i]];\n\tint nxt_id = encode(nxt, w);\n\n\tif(memo[nxt_id]==-2)f = false;\n\telse{\n\t  for(int i=0;f && i<n;i++){\n\t    for(int j=0;f && j<i;j++){\n\t      if(nxt[i] == nxt[j])f = false;\n\t    }\n\t  }\n\t}\n\n\tif(!f)memo[nxt_id] = -2;\n\telse{\n\t  for(int i=0;f && i<n;i++){\n\t    for(int j=0;f && j<i;j++){\n\t      if(nxt[i] == cur[j] && nxt[j] == cur[i])f = false;\n\t    }\n\t  }\n\t}\n\n\tif(f){\n\t  if(memo[nxt_id] < 0){\n\t    memo[nxt_id] = memo[cur_id] + 1;\n\t    q.push(nxt_id);\n\t  }\n\t}\n\n\tdir[0]++;\n\tfor(int i=0;i<n-1;i++){\n\t  if(dir[i]==(int)edge[cur[i]].size())dir[i] = 0, dir[i+1]++;\n\t}\n      }\n\n    }\n    cout << memo[end_id] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 1000000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cctype>\n\nusing namespace std;\n\nstruct S{\n  int p[3][2];\n  int t;\n};\n\nint main(){\n  for(int w,h,n;cin>>w>>h>>n,w;){\n    cin.ignore();\n    char g[16][16];\n    S is={{},0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin.get(g[i][j]);\n\tif(islower(g[i][j])){\n\t  auto x=g[i][j]-'a';\n\t  is.p[x][0]=i;\n\t  is.p[x][1]=j;\n\t}\n      }\n      cin.ignore();\n    }\n    queue<S> que;\n    que.push(is);\n    set<int> p;\n    for(;;){\n      S cs=que.front();\n      bool f=false;\n      for(int i=0;i<n;i++){\n\tf|=g[cs.p[i][0]][cs.p[i][1]]!='A'+i;\n      }\n      if(!f)break;\n      que.pop();\n      int b=0;\n      for(int i=0;i<n;i++){\n\tb=b<<8|cs.p[i][0]<<4|cs.p[i][1];\n      }\n      if(!p.insert(b).second)continue;\n      static int dy[]={-1,0,0,0,1};\n      static int dx[]={0,-1,0,1,0};\n      for(int i=0;i<5;i++){\n\tint y1,x1,y2,x2,y3,x3;\n\ty1=cs.p[0][0]+dy[i];\n\tx1=cs.p[0][1]+dx[i];\n\ty2=cs.p[1][0];\n\tx2=cs.p[1][1];\n\ty3=cs.p[2][0];\n\tx3=cs.p[2][1];\n\tif(g[y1][x1]=='#')continue;\n\tif(n==1){\n\t  que.push(S{{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t}else{\n\t  for(int j=0;j<5;j++){\n\t    y2=cs.p[1][0]+dy[j];\n\t    x2=cs.p[1][1]+dx[j];\n\t    if(g[y2][x2]=='#'||y2==y1&&x2==x1||y1==cs.p[1][0]&&x1==cs.p[1][1]&&y2==cs.p[0][0]&&x2==cs.p[0][1])continue;\n\t    if(n==2){\n\t      que.push(S{{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t    }else{\n\t      for(int k=0;k<5;k++){\n\t\ty3=cs.p[2][0]+dy[k];\n\t\tx3=cs.p[2][1]+dx[k];\n\t\tif(g[y3][x3]=='#'||y3==y1&&x3==x1||y3==y2&&x3==x2||y3==cs.p[0][0]&&x3==cs.p[0][1]&&y1==cs.p[2][0]&&x1==cs.p[2][1]||y3==cs.p[1][0]&&x3==cs.p[1][1]&&y2==cs.p[2][0]&&x2==cs.p[2][1])continue;\n\t\tque.push(S{{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.front().t<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned char vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint gen;\n\ninline bool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = i == 16 ? 0 : i + 8;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = v >> j & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j & 255) &&\n\t\t\t\tp2 == (u >> i & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\t++gen;\n\tqueue<int> q;\n\tq.push(start);\n\tq.push(-1);\n\tint tm = 1;\n\tvis[start] = gen;\n\twhile(1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u < 0){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] == gen){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = gen;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(start, goal));\n\n\t\tif(gen == 255){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\tgen = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\n\nS i2s(int x){\n  return S(x/2744,x%2744);\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first*2744)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+p.first[i]-1;\n    x=x*14+p.second[i]-1;\n  }\n  return S(y,x);\n}\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%14+1);\n    x.push_back(b%14+1);\n    a/=14;b/=14;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nchar m[7530000];\nqueue<int> q;\n\nvector<int> ys,xs;\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    P r=P(ys,xs);\n    int abc=p2i(r);\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 10;\nconst ll mod=1000000007LL;\nconst int dx[]={1,0,-1,0,0};\nconst int dy[]={0,1,0,-1,0};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 16, M = 150;\nint w, h, n; \nvector<string> field;\nshort memo[M][M][M];\nint p2i[N][N];\nint i2x[M], i2y[M];\n\nusing State = tuple<int, int, int>;\nusing Elem  = tuple<int, State>;\n\ninline bool check(State pre, State cur){\n    int pp[3], cp[3];\n    tie(pp[0], pp[1], pp[2]) = pre;\n    tie(cp[0], cp[1], cp[2]) = cur;\n\n    // exchange\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(pp[i] == cp[j] and pp[j] == cp[i]){\n            return false;\n        }\n    }\n\n    // overlap\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(cp[i] == cp[j]){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(void){\n    for(;cin >> w >> h >> n, w;){\n        field = vector<string>(h);\n        cin.ignore();\n        for(auto & e : field) getline(cin, e);\n\n        i2x[0] = 0, i2y[0] = 0;\n        {\n            int cnt = 1;\n            rep(y, h){\n                rep(x, w){\n                    if(field[y][x] != '#'){\n                        p2i[y][x] = cnt;\n                        i2x[cnt] = x;\n                        i2y[cnt] = y;\n                        cnt++;\n                    }\n                    else p2i[y][x] = -1;\n                }\n            }\n        }\n        p2i[0][0] = 0;\n\n        State s = State(0, 0, 0), z = State(0, 0, 0);\n        rep(y, h){\n            rep(x, w){\n                int as, bs, cs, az, bz, cz;\n                tie(as, bs, cs) = s;\n                tie(az, bz, cz) = z;\n\n                switch(field[y][x]){\n                    case 'a': { as = p2i[y][x]; break; }\n                    case 'b': { bs = p2i[y][x]; break; }\n                    case 'c': { cs = p2i[y][x]; break; }\n                    case 'A': { az = p2i[y][x]; break; }\n                    case 'B': { bz = p2i[y][x]; break; }\n                    case 'C': { cz = p2i[y][x]; break; }\n                }\n                s = State(as, bs, cs);\n                z = State(az, bz, cz);\n            }\n        }\n\n        rep(i, M) rep(j, M) rep(k, M) memo[i][j][k] = inf;\n\n        queue<Elem> q;\n        q.push(Elem(0, s));\n\n        while(q.size()){\n            short cost; State cur;\n            tie(cost, cur) = q.front(); q.pop();\n            int ap, bp, cp; tie(ap, bp, cp) = cur;\n\n            short & ret = memo[ap][bp][cp];\n            if(ret != inf) continue;\n            ret = cost;\n\n            rep(i, 5){\n                int ax = i2x[ap] + dx[i], ay = i2y[ap] + dy[i];\n                if(p2i[ay][ax] == -1) continue;\n\n                rep(j, 5){\n                    if(n <= 1 and j <= 3) continue;\n\n                    int bx = i2x[bp] + dx[j], by = i2y[bp] + dy[j];\n                    if(p2i[by][bx] == -1) continue;\n\n                    rep(k, 5){\n                        if(n <= 2 and k <= 3) continue;\n\n                        int cx = i2x[cp] + dx[k], cy = i2y[cp] + dy[k];\n                        if(p2i[cy][cx] == -1) continue;\n\n                        State next = State(p2i[ay][ax], p2i[by][bx], p2i[cy][cx]);\n                        if(not check(cur, next)) continue;\n                        q.push(Elem(cost + 1, next));\n                    }\n                }\n            }\n        }\n\n        int az, bz, cz; tie(az, bz, cz) = z;\n        cout << memo[az][bz][cz] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint gen;\n\ninline bool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = i == 16 ? 0 : i + 8;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = v >> j & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j & 255) &&\n\t\t\t\tp2 == (u >> i & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\t++gen;\n\tqueue<int> q;\n\tq.push(start);\n\tq.push(-1);\n\tint tm = 1;\n\tvis[start] = gen;\n\twhile(1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u < 0){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] == gen){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = gen;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(start, goal));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\n#define all(c) (c).begin(),(c).end()\n#define show(x) cout << #x << \" \" << x << endl\nstruct State{int ax,ay,bx,by,cx,cy;};\nstring s[16];\nint W,H,N,dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0},inf=1e5;\nint Ax,Ay,Bx,By,Cx,Cy,ax,ay,bx,by,cx,cy;\nint d[16][16][16][16][16][16];\nbool is(int x,int y){\n\treturn (0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#');\n}\nvoid three(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) rep(bi,H) rep(bj,W) rep(ci,H) rep(cj,W) d[ai][aj][bi][bj][ci][cj]=inf;\n\td[Ax][Ay][Bx][By][Cx][Cy]=0;\n\tque.push(State{Ax,Ay,Bx,By,Cx,Cy});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\trep(bd,5){\n\t\t\t\tint nbx=st.bx+dx[bd],nby=st.by+dy[bd];\n\t\t\t\tif(!is(nbx,nby)) continue;\n\t\t\t\trep(cd,5){\n\t\t\t\t\tint ncx=st.cx+dx[cd],ncy=st.cy+dy[cd];\n\t\t\t\t\tif(!is(ncx,ncy)) continue;\n\t\t\t\t\tif(d[nax][nay][nbx][nby][ncx][ncy]!=inf) continue;\n\t\t\t\t\tif(nax==nbx&&nay==nby) continue;\n\t\t\t\t\tif(nbx==ncx&&nby==ncy) continue;\n\t\t\t\t\tif(ncx==nax&&ncy==nay) continue;\n\t\t\t\t\tif(nax==st.bx&&nay==st.by&&nbx==st.ax&&nby==st.ay) continue;\n\t\t\t\t\tif(nbx==st.cx&&nby==st.cy&&ncx==st.bx&&ncy==st.by) continue;\n\t\t\t\t\tif(ncx==st.ax&&ncy==st.ay&&nax==st.cx&&nay==st.cy) continue;\n\t\t\t\t\td[nax][nay][nbx][nby][ncx][ncy]=d[st.ax][st.ay][st.bx][st.by][st.cx][st.cy]+1;\n\t\t\t\t\tque.push(State{nax,nay,nbx,nby,ncx,ncy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid two(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) rep(bi,H) rep(bj,W) d[ai][aj][bi][bj][0][0]=inf;\n\td[Ax][Ay][Bx][By][0][0]=0;\n\tque.push(State{Ax,Ay,Bx,By,0,0});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\trep(bd,5){\n\t\t\t\tint nbx=st.bx+dx[bd],nby=st.by+dy[bd];\n\t\t\t\tif(!is(nbx,nby)) continue;\n\t\t\t\tif(d[nax][nay][nbx][nby][0][0]!=inf) continue;\n\t\t\t\tif(nax==nbx&&nay==nby) continue;\n\t\t\t\tif(nax==st.bx&&nay==st.by&&nbx==st.ax&&nby==st.ay) continue;\n\t\t\t\td[nax][nay][nbx][nby][0][0]=d[st.ax][st.ay][st.bx][st.by][0][0]+1;\n\t\t\t\tque.push(State{nax,nay,nbx,nby,0,0});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid one(){\n\tqueue<State> que;\n\trep(ai,H) rep(aj,W) d[ai][aj][0][0][0][0]=inf;\n\td[Ax][Ay][0][0][0][0]=0;\n\tque.push(State{Ax,Ay,0,0,0,0});\n\twhile(!que.empty()){\n\t\tState st=que.front();\n\t\tque.pop();\n\t\trep(ad,5){\n\t\t\tint nax=st.ax+dx[ad],nay=st.ay+dy[ad];\n\t\t\tif(!is(nax,nay)) continue;\n\t\t\tif(d[nax][nay][0][0][0][0]!=inf) continue;\n\t\t\td[nax][nay][0][0][0][0]=d[st.ax][st.ay][0][0][0][0]+1;\n\t\t\tque.push(State{nax,nay,0,0,0,0});\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d%d\\n\",&W,&H,&N);\n\t\tif(W==0) break;\n\t\trep(i,H) getline(cin,s[i]);\n\t\tax=0,ay=0,bx=0,by=0,cx=0,cy=0;\n\t\trep(i,H) rep(j,W){\n\t\t\tif(s[i][j]=='A') Ax=i,Ay=j;\n\t\t\tif(s[i][j]=='B') Bx=i,By=j;\n\t\t\tif(s[i][j]=='C') Cx=i,Cy=j;\n\t\t\tif(s[i][j]=='a') ax=i,ay=j;\n\t\t\tif(s[i][j]=='b') bx=i,by=j;\n\t\t\tif(s[i][j]=='c') cx=i,cy=j;\n\t\t}\n\t\tif(N==3) three();\n\t\tif(N==2) two();\n\t\tif(N==1) one();\n\t\tcout<<d[ax][ay][bx][by][cx][cy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(ans == inf && !q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\t//if(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return a.dist > b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist += dist[i][start[i].y][start[i].x];\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        set<uint32_t> used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nint d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=(1e4);\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n      \t  if(!check(ncy,ncx)) continue;\n      \n\t  if(!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(nay==nby&&nax==nbx) continue;\n\t  if(nay==ncy&&nax==ncx) continue;\n\t  if(nby==ncy&&nbx==ncx) continue;\n\n\t  if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\t    q.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n\t  }\n      \n\t}\n      }\n    }\n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    if(n<=1){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][0]=(char)i;\n\t  s[0][1]=char('A'+i-'a');\n\t  by=0, bx=0;\n\t}\n    }\n    \n    if(n<=2){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][2]=(char)i;\n\t  s[0][3]=char('A'+i-'a');\n\t  cy=0, cx=2;\n\t}\n      \n    }\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool wall[16*16];\nint mv[] = {0, 1, -1, 16, -16};\n\nint compress(int pa, int pb, int pc){\n\treturn (pa)|(pb<<8)|(pc<<16);\n}\n\nint solve(int start, int goal){\n\tstatic bool visit[16*16*16*16*16*16];\n\tmemset(visit, false, sizeof(visit));\n\tvisit[start] = true;\n\tvector<int> state[2]; state[0].push_back(start);\n\tfor(int res=1; ;res++){\n\t\tint cur = 1-res%2, next = res%2;\n\t\tstate[next].clear();\n\t\tfor(int i=0;i<state[cur].size();i++){\n\t\t\tint pa = state[cur][i]%256, pb = (state[cur][i]>>8)%256, pc = (state[cur][i]>>16);\n\t\t\tfor(int a=0;a<5;a++){\n\t\t\t\tint npa = pa + mv[a];\n\t\t\t\tif(wall[npa]) continue;\n\t\t\t\tfor(int b=0;b<(pb?5:1);b++){\n\t\t\t\t\tint npb = pb + mv[b];\n\t\t\t\t\tif(npb!=0){\n\t\t\t\t\t\tif(wall[npb]) continue;\n\t\t\t\t\t\tif(npa==npb) continue;\n\t\t\t\t\t\tif(npb==pa&&npa==pb) continue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=0;c<(pc?5:1);c++){\n\t\t\t\t\t\tint npc = pc + mv[c];\n\t\t\t\t\t\tif(npc!=0){\n\t\t\t\t\t\t\tif(wall[npc]) continue;\n\t\t\t\t\t\t\tif(npc==npa||npc==npb) continue;\n\t\t\t\t\t\t\tif(npc==pa&&npa==pc) continue;\n\t\t\t\t\t\t\tif(npc==pb&&npb==pc) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ns = (npa)|(npb<<8)|(npc<<16);\n\t\t\t\t\t\tif(visit[ns]) continue;\n\t\t\t\t\t\tif(ns==goal) return res;\n\t\t\t\t\t\tvisit[ns] = true;\n\t\t\t\t\t\tstate[next].push_back(ns);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint w, h, n;\n\tstring mp[16];\n\twhile(cin >> w >> h >> n, w){\n\t\tgetline(cin, mp[0]);\n\t\tfor(int i=0;i<h;i++) getline(cin, mp[i]);\n\t\tmemset(wall, false, sizeof(wall));\n\t\tint start = 0, goal = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mp[i][j]=='#') wall[16*i+j] = true;\n\t\t\t\tif(islower(mp[i][j])) start |= (16*i+j) << (8*(mp[i][j]-'a'));\n\t\t\t\tif(isupper(mp[i][j])) goal  |= (16*i+j) << (8*(mp[i][j]-'A'));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(start, goal));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[200][200][200];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nv[3];\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t}\n\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\n\nenum { A, B, C, N };\n\ninline bool ng(int current_a, int next_a, int current_b, int next_b) {\n\treturn next_a == next_b || (current_a == next_b && next_a == current_b);\n}\n\ninline int bfs(const array<int, N> &start, const array<int, N> &goal, const graph &G) {\n\tconst int V = G.size();\n\n\tvector<vector<vector<int>>> dist(V, vector<vector<int>>(V, vector<int>(V, -1)));\n\tqueue<tuple<int, int, int>> que;\n\n\tdist[start[A]][start[B]][start[C]] = 0;\n\tque.push(make_tuple(start[A], start[B], start[C]));\n\n\twhile(!que.empty()) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = que.front();\n\t\tque.pop();\n\n\t\tconst int d = dist[a][b][c];\n\n\t\tfor(const auto &to_a : G[a]) {\n\n\t\t\tfor(const auto &to_b : G[b]) {\n\t\t\t\tif(ng(a, to_a, b, to_b)) continue;\n\n\t\t\t\tfor(const auto &to_c : G[c]) {\n\t\t\t\t\tif(ng(a, to_a, c, to_c) || ng(b, to_b, c, to_c)) continue;\n\n\t\t\t\t\tif(dist[to_a][to_b][to_c] == -1) {\n\t\t\t\t\t\tif(to_a == goal[A] && to_b == goal[B] && to_c == goal[C]) return d + 1;\n\t\t\t\t\t\tdist[to_a][to_b][to_c] = d + 1;\n\t\t\t\t\t\tque.push(make_tuple(to_a, to_b, to_c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h, n; cin >> w >> h >> n && w;) {\n\t\tcin.ignore();\n\n\t\tvector<string> field(h);\n\t\tfor(auto &e : field) getline(cin, e);\n\n\t\tint num = 0;\n\t\tarray<int, N> start, goal;\n\t\tvector<vector<int>> label(h, vector<int>(w, -1));\n\n\t\tfor(int i = 1; i < h - 1; ++i) {\n\t\t\tfor(int j = 1; j < w - 1; ++j) {\n\t\t\t\tif(field[i][j] != '#') {\n\t\t\t\t\tif(islower(field[i][j])) {\n\t\t\t\t\t\tstart[field[i][j] - 'a'] = num;\n\t\t\t\t\t}\n\t\t\t\t\telse if(isupper(field[i][j])) {\n\t\t\t\t\t\tgoal[field[i][j] - 'A'] = num;\n\t\t\t\t\t}\n\t\t\t\t\tlabel[i][j] = num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = n; i < N; ++i) {\n\t\t\tstart[i] = goal[i] = num++;\n\t\t}\n\n\t\tgraph G(num);\n\t\tfor(int v = 0; v < num; ++v) G[v].emplace_back(v);\n\n\t\tfor(int i = 1; i < h - 1; ++i) {\n\t\t\tfor(int j = 1; j < w - 1; ++j) {\n\t\t\t\tif(label[i][j] == -1) continue;\n\t\t\t\tconst int v = label[i][j];\n\n\t\t\t\tif(label[i - 1][j] != -1) {\n\t\t\t\t\tconst int u = label[i - 1][j];\n\t\t\t\t\tG[v].emplace_back(u);\n\t\t\t\t\tG[u].emplace_back(v);\n\t\t\t\t}\n\t\t\t\tif(label[i][j - 1] != -1) {\n\t\t\t\t\tconst int u = label[i][j - 1];\n\t\t\t\t\tG[v].emplace_back(u);\n\t\t\t\t\tG[u].emplace_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bfs(start, goal, G) << endl;\n\t}\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=vector<string>;\n\nconst int N=3;\nusing P=pair<int,int>;\nusing Ps=array<P,N>;\n\nconst int SIZE=18;\nconst int DP_SIZE=SIZE*SIZE*SIZE*SIZE*SIZE*SIZE;\nconst int D=5;\nconst int dh[]={0,1,0,-1,0};\nconst int dw[]={0,0,1,0,-1};\n\narray<short,DP_SIZE> dp;\nPs sp,tp;\n\nvoid init(int h,int w){\n    for(int i=0;i<N;i++) sp[i]=tp[i]={h,w};\n    fill(dp.begin(),dp.end(),1e9);\n}\nint encode(P& x){return x.first+x.second*SIZE;}\nint encode(Ps& x){ return encode(x[0])+SIZE*SIZE*encode(x[1])+SIZE*SIZE*SIZE*SIZE*encode(x[2]);}\nPs decode(int x){\n    int r=1;\n    Ps res;\n    for(int i=0;i<3;i++){\n        res[i]={x/r%SIZE,x/r/SIZE%SIZE};\n        r*=SIZE*SIZE;\n    }\n    return res;\n}\nint solve(int w,int h,int n,Field f){\n    init(h,w);\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(isupper(f[i][j])){\n                tp[f[i][j]-'A']={i,j};\n            }\n            else if(islower(f[i][j])){\n                sp[f[i][j]-'a']={i,j};\n            }\n        }\n    }\n    \n    vector<vector<vector<int>>> est(N,vector<vector<int>>(h+1,vector<int>(w+1,3*(SIZE*SIZE+2))));\n    \n    for(int i=0;i<3;i++){\n        est[i][tp[i].first][tp[i].second]=0;\n        queue<pair<int,int>> que;\n        while(!que.empty()){\n            auto p=que.front(); que.pop();\n            int x=p.first,y=p.second;\n            if(f[x][y]=='#') continue;\n            for(int j=1;j<D;j++){\n                int tox=x+dh[j],toy=dw[j];\n                if(tox<h && toy<w && est[i][tox][toy]!=SIZE*SIZE+2){\n                    est[i][tox][toy]=est[i][x][y]+1;\n                    que.push({tox,toy});\n                }\n            }\n        }\n    }\n    \n    using Item=pair<short,int>;\n    priority_queue<Item,vector<Item>,greater<Item>> que;\n    auto hf=[&](Ps& p){\n        int res=0;\n        for(int i=0;i<N;i++) res=max(res,est[i][p[i].first][p[i].second]);\n        return res;\n    };\n    auto push=[&](Ps& p,int d){\n        int hv=encode(p);\n        if(d<dp[hv]){\n            dp[hv]=d;\n            int dest=d+hf(p);\n            que.push({d+hf(p),hv});\n        }\n    };\n    auto isRange=[&](Ps& p,Ps& pre){\n        for(int i=0;i<N;i++){\n            if(!(p[i].first==h && p[i].second==w || p[i].first<h && p[i].second<w && f[p[i].first][p[i].second]!='#')) return false;\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<i;j++){\n                if(p[i].first==h || p[j].first==h) continue;\n                if(p[i]==p[j]) return false;\n                if(p[i]==pre[j] && p[j]==pre[i]) return false;\n            }\n        }\n        return true;\n    };\n    auto trans=[&](Ps& p,int hv){\n        Ps np;\n        for(int i=0;i<D;i++){\n            np[0]={p[0].first+dh[i],p[0].second+dw[i]};\n            for(int j=0;j<D;j++){\n                np[1]={p[1].first+dh[j],p[1].second+dw[j]};\n                for(int k=0;k<D;k++){\n                    np[2]={p[2].first+dh[k],p[2].second+dw[k]};\n                    if(isRange(np,p)){\n                        push(np,dp[hv]+1);\n                    }\n                }\n            }\n        }\n    };\n    auto debug=[&](Ps& p){\n        cerr<<\"$Debug begin.\"<<endl;\n        for(int i=0;i<3;i++){\n            cerr<<p[i].first<<\" \"<<p[i].second<<endl;\n        }  \n        cerr<<\"$Debug end.\"<<endl;\n    };\n    push(sp,0);\n    while(!que.empty()){\n        auto ret=que.top(); que.pop();\n        int hv=ret.second;\n        Ps p=decode(hv);\n        if(ret.first>dp[hv]+hf(p)) continue;\n        // debug(p);\n        if(p==tp) return ret.first;\n        trans(p,hv);\n    }\n    throw std::runtime_error(\"Unexpected\");\n}\nint main(){\n    int w,h,n;\n    while(cin>>w>>h>>n,w){\n        string buf;\n        getline(cin,buf);\n        Field f(h);\n        for(int i=0;i<h;i++){\n            getline(cin,f[i]);\n        }\n        cout<<solve(w,h,n,f)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h - 2;\n            ret += y[i] - 1;\n            ret *= w - 2;\n            ret += x[i] - 1;\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    vector<int> sy(n), sx(n), gy(n), gx(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sy[c-'a'] = i;\n                sx[c-'a'] = j;\n            }else if('A' <= c && c <= 'C'){\n                gy[c-'A'] = i;\n                gx[c-'A'] = j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= (h-2) * (w-2);\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sy, sx, 0).toInt()] = true;\n    check[1][Data(gy, gx, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sy, sx, 0));\n    dq[1].push_back(Data(gy, gx, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.y[i] += dy[j];\n                d.x[i] += dx[j];\n\n                bool ok = true;\n                if(grid[d.y[i]][d.x[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.y[i] -= dy[j];\n                d.x[i] -= dx[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            if(check[turn^1][a])\n                return ret;\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[16][16];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nshort dp[196][196][196];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nv[3];\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t}\n\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> p;\n    bitset<3> bs;\n    Data(vector<int>& p0, bitset<3> bs0){\n        p = p0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h * w;\n            ret += p[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    string gridLine = accumulate(grid.begin(), grid.end(), string());\n    int move[] = {1, -1, w, -w};\n\n    vector<int> start(n), goal(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                start[c-'a'] = i * w + j;\n            }else if('A' <= c && c <= 'C'){\n                goal[c-'A'] = i * w + j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= h * w;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(start, 0).toInt()] = true;\n    check[1][Data(goal, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(start, 0));\n    dq[1].push_back(Data(goal, 0));\n\n    int turn = 0;\n    int m = 0;\n    int ret = 0;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.p[i] += move[j];\n\n                bool ok = true;\n                if(gridLine[d.p[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.p[k] == d.p[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.p[i] -= move[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            if(check[turn^1][a])\n                return ret;\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint w,h,n;\nchar c[22][22];\nint sy[4],sx[4],gy[4],gx[4];\nshort dist[1<<24];\nint dy[]={0,1,0,-1,0};\nint dx[]={1,0,-1,0,0};\n\n#define state(ay,ax,by,bx,cy,cx) ((ay)<<20 | (ax)<<16 | (by)<<12 | (bx)<<8 | (cy)<<4 | (cx)<<0)\n\nint main2(){\n\tfill(sy,sy+4,0);\n\tfill(sx,sx+4,0);\n\tfill(gy,gy+4,0);\n\tfill(gx,gx+4,0);\n\trep(i,h)rep(j,w){\n\t\tif(islower(c[i][j])){\n\t\t\tsy[c[i][j]-'a'] = i;\n\t\t\tsx[c[i][j]-'a'] = j;\n\t\t\tc[i][j] = ' ';\n\t\t}\n\t\tif(isupper(c[i][j])){\n\t\t\tgy[c[i][j]-'A'] = i;\n\t\t\tgx[c[i][j]-'A'] = j;\n\t\t\tc[i][j] = ' ';\n\t\t}\n\t}\n\tmemset(dist,-1,sizeof(dist));\n\tint s = state(sy[0],sx[0],sy[1],sx[1],sy[2],sx[2]);\n\tdist[s] = 0;\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(sz(Q)){\n\t\tint s = Q.front();Q.pop();\n\t\tint y[4],x[4];\n\t\ty[0] = s>>20 & 15;\n\t\tx[0] = s>>16 & 15;\n\t\ty[1] = s>>12 & 15;\n\t\tx[1] = s>> 8 & 15;\n\t\ty[2] = s>> 4 & 15;\n\t\tx[2] = s>> 0 & 15;\n\t\t\n\t\tint done=1;\n\t\trep(i,n)if(y[i] != gy[i] || x[i] != gx[i]){\n\t\t\tdone=0;break;\n\t\t}\n\t\tif(done)return cout<<dist[s]<<endl,0;\n\t\tint ny[4],nx[4],ns;\n\t\trep(dir0,5){\n\t\t\tny[0] = y[0] + dy[dir0];\n\t\t\tnx[0] = x[0] + dx[dir0];\n\t\t\tif(c[ny[0]][nx[0]]=='#')continue;\n\t\t\trep2(dir1,n==1 ? 4 : 0, 5){\n\t\t\t\tny[1] = y[1] + dy[dir1];\n\t\t\t\tnx[1] = x[1] + dx[dir1];\n\t\t\t\tif(n>=2 && c[ny[1]][nx[1]]=='#')continue;\n\t\t\t\trep2(dir2,n<=2 ? 4 : 0, 5){\n\t\t\t\t\tny[2] = y[2] + dy[dir2];\n\t\t\t\t\tnx[2] = x[2] + dx[dir2];\n\t\t\t\t\tif(n==3 && c[ny[2]][nx[2]]=='#')continue;\n\t\t\t\t\t\n\t\t\t\t\trep(i,n)rep2(j,i+1,n){\n\t\t\t\t\t\tif(ny[i]==ny[j] && nx[i]==nx[j])goto fail;\n\t\t\t\t\t\tif(ny[i]==y[j] && nx[i]==x[j]\n\t\t\t\t\t\t&& ny[j]==y[i] && nx[j]==x[i])goto fail;\n\t\t\t\t\t}\n\t\t\t\t\tns = state(ny[0],nx[0],ny[1],nx[1],ny[2],nx[2]);\n\t\t\t\t\tif(dist[ns]==-1){\n\t\t\t\t\t\tdist[ns] = dist[s]+1;\n\t\t\t\t\t\tQ.push(ns);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfail:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>w>>h>>n,w){\n\t\tgets(c[0]);\n\t\trep(i,h)gets(c[i]);\n\t\tmain2();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define INF\t(1 << 30)\n\n#define MAX_H\t(16)\n#define MAX_W\t(16)\n#define MAX_HW\t(MAX_H * MAX_W)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\n/* global variables */\n\nint w, h, n, hw, hw2;\n\n/* classes */\n\nstruct Rpos {\n  int p[3];\n\n  Rpos() {p[0] = p[1] = p[2] = 0;}\n\n  bool operator==(const Rpos r) const {\n    return p[0] == r.p[0] && p[1] == r.p[1] && p[2] == r.p[2];\n  }\n  \n  int hash() { return p[0] + p[1] * hw + p[2] * hw2; }\n  \n  string to_s() {\n    char tstr[100];\n    sprintf(tstr, \"(%d,%d,%d)\", p[0], p[1], p[2]);\n    return string(tstr);\n  }\n};\n\n/* subroutines */\n\nbool cond1(Rpos v) {\n  return \n    n == 1 ||\n    (n == 2 && v.p[0] != v.p[1]) ||\n    (n == 3 && v.p[0] != v.p[1] && v.p[1] != v.p[2] && v.p[2] != v.p[0]);\n}\n\nbool cond2(Rpos u, Rpos v) {\n  return \n    n == 1 ||\n    (n == 2 && (u.p[0] != v.p[1] || u.p[1] != v.p[0])) ||\n    (n == 3 &&\n     (u.p[0] != v.p[1] || u.p[1] != v.p[0]) &&\n     (u.p[1] != v.p[2] || u.p[2] != v.p[1]) &&\n     (u.p[2] != v.p[0] || u.p[0] != v.p[2]));\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> w >> h >> n;\n    if ((w | h | n) == 0) break;\n    //cout << w << ',' << h << ',' << n << endl;\n    \n    hw = w * h;\n    hw2 = hw * hw;\n\n    int dpos[] = {0, 1, -1, w, -w};\n\n    bool flds[MAX_HW];\n    Rpos st, gl;\n\n    for (int i = 0; i < hw; i++) flds[i] = true;\n    \n    char line[100];\n    fgets(line, 100, stdin);\n\n    for (int y = 0; y < h; y++) {\n      fgets(line, 100, stdin);\n      //printf(\"line %d: %s\", y, line);\n      \n      for (int x = 0; x < w; x++) {\n\tchar ch = line[x];\n\tint pos = y * w + x;\n\n\tif (ch == '#')\n\t  flds[pos] = false;\n\telse if (ch >= 'a' && ch <= 'z') {\n\t  int id = ch - 'a';\n\t  st.p[id] = pos;\n\t}\n\telse if (ch >= 'A' && ch <= 'Z') {\n\t  int id = ch - 'A';\n\t  gl.p[id] = pos;\n\t}\n      }\n    }\n    //p flds\n    //cout << \"[\" << n << \",\" << st.to_s() << \",\" << gl.to_s() << \")\" << endl;\n\n    map<int,int> dists;\n    dists[st.hash()] = 0;\n\n    queue<Rpos> q;\n    q.push(st);\n\n    vi mvs[3];\n\n    while (! q.empty()) {\n      Rpos u = q.front();\n      q.pop();\n\n      if (u == gl) break;\n\n      for (int i = 0; i < n; i++) {\n\tmvs[i].clear();\n\tint posi = u.p[i];\n\tfor (int di = 0; di < 5; di++) {\n\t  int pos = posi + dpos[di];\n\t  if (flds[pos]) mvs[i].push_back(pos);\n\t}\n      }\n      //p mvs\n\n      int nvd = dists[u.hash()] + 1;\n      Rpos v;\n\n      for (int mvid = 0;; mvid++) {\n\tint mvid0 = mvid;\n\tfor (int i = 0; i < n; i++) {\n\t  v.p[i] = mvs[i][mvid0 % mvs[i].size()];\n\t  mvid0 /= mvs[i].size();\n\t}\n\tif (mvid0 > 0) break;\n\n\tint vhash = v.hash();\n\tif (dists.find(vhash) == dists.end() && cond1(v) && cond2(u, v)) {\n\t  dists[vhash] = nvd;\n\t  q.push(v);\n\t}\n      }\n    }\n\n    cout << dists[gl.hash()] << endl;\n    //exit(0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: Oct 11, 2013\n *      Author: Hesham\n */\n#include<iostream>\n#include<string>\n#include<map>\n#include<ctime>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<algorithm>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<bitset>\n#include<fstream>\n#include<cmath>\n#include<cassert>\n#include <stdio.h>\n#include<ctype.h>\nusing namespace std;\nint dx[] = { 0, 0, 1, -1, 0 };\nint dy[] = { 0, 1, 0, 0, -1 };\nint w, h, n;\nstring house[16];\nstruct State {\n\tvector<int> y, x;\n\tState() {\n\t\tx.resize(3, 0);\n\t\ty.resize(3, 0);\n\t}\n\tState(vector<int>& yy, vector<int>& xx) :\n\t\t\tx(xx), y(yy) {\n\t}\n\tbool operator ==(const State& other) const {\n\t\treturn x == other.x && y == other.y;\n\t}\n};\nbool vis1[16][16][16][16][16][16];\nbool vis2[16][16][16][16][16][16];\nint dist[16][16][16][16][16][16];\n\nbool isVis(State& s, bool vis[16][16][16][16][16][16]) {\n\treturn vis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setVis(State& s, bool vis[16][16][16][16][16][16]) {\n\tvis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = true;\n}\nint getDist(State& s) {\n\treturn dist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setDist(State& s, int v) {\n\tdist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = v;\n}\n\nbool ok(int y, int x) {\n\tif (y < 0 || y == h || x < 0 || x == w)\n\t\treturn false;\n\tif (house[y][x] == '#')\n\t\treturn false;\n\treturn true;\n}\nint pushAdjs(int i, State& adj, State& curr, queue<State>& q,\n\t\tbool visA[16][16][16][16][16][16], bool visB[16][16][16][16][16][16]) {\n\tif (i == n) {\n\t\tif (isVis(adj, visA))\n\t\t\treturn -1;\n\t\tif (isVis(adj, visB))\n\t\t\treturn getDist(curr) + 1 + getDist(adj);\n\t\tsetDist(adj, getDist(curr) + 1);\n\t\tsetVis(adj, visA);\n\t\tq.push(adj);\n\t\treturn -1;\n\t}\n\tfor (int d = 0; d < 5; ++d) {\n\t\tadj.y[i] = dy[d] + curr.y[i];\n\t\tadj.x[i] = dx[d] + curr.x[i];\n\t\tif (!ok(adj.y[i], adj.x[i]))\n\t\t\tcontinue;\n\t\tbool okk = true;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (adj.y[i] == curr.y[j] && adj.x[i] == curr.x[j]&&\n\t\t\t    adj.y[j] == curr.y[i] && adj.x[j] == curr.x[i]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (adj.y[i] == adj.y[j] && adj.x[i] == adj.x[j]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!okk)\n\t\t\tcontinue;\n\t\tint cost = pushAdjs(i + 1, adj, curr, q, visA, visB);\n\t\tif (cost != -1)\n\t\t\treturn cost;\n\t}\n\treturn -1;\n}\nint meetMiddle(vector<int>& sy, vector<int>& sx, vector<int>& ty,\n\t\tvector<int>& tx) {\n\tmemset(vis1, false, sizeof vis1);\n\tmemset(vis2, false, sizeof vis2);\n\tState s(sy, sx);\n\tState t(ty, tx);\n\tsetDist(s, 0);\n\tsetDist(t, 0);\n\tsetVis(s, vis1);\n\tsetVis(t, vis2);\n\tqueue<State> q1;\n\tqueue<State> q2;\n\tq1.push(s);\n\tq2.push(t);\n\twhile (true) {\n\t\t{\n\t\t\tState curr1 = q1.front();\n\t\t\tq1.pop();\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr1, q1, vis1, vis2);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t}\n\t\t{\n\t\t\tState curr2 = q2.front();\n\t\t\tq2.pop();\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr2, q2, vis2, vis1);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//clock_t begin = clock();\n\tstring line;\n\twhile (cin >> w >> h >> n) {\n\t\tif (!w && !h && !n)\n\t\t\tbreak;\n\t\tcin.ignore();\n\t\t//cin.ignore();\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tgetline(cin, house[i]);\n\n\t\tvector<int> sx(3, 0);\n\t\tvector<int> sy(3, 0);\n\n\t\tvector<int> tx(3, 0);\n\t\tvector<int> ty(3, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (house[i][j] >= 'A' && house[i][j] <= 'C') {\n\t\t\t\t\ttx[(house[i][j] - 'A')] = j;\n\t\t\t\t\tty[(house[i][j] - 'A')] = i;\n\t\t\t\t}\n\t\t\t\tif (house[i][j] >= 'a' && house[i][j] <= 'c') {\n\t\t\t\t\tsx[(house[i][j] - 'a')] = j;\n\t\t\t\t\tsy[(house[i][j] - 'a')] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << meetMiddle(sy, sx, ty, tx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tif(!flag)continue;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\t\tbool goal=true;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(goal){\n\t\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\t}\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tshort x[3],y[3];\n\tdata(){}\n};\n\nshort dx[5]={0,1,-1,0,0};\nshort dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nshort dp[196][196][196];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.x[2]+nd.y[2]*w]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint encode(const pair<int,int> *pos, int N)\n{\n  int s = 0;\n  for (int i = 0; i < N; i++) {\n    s = 256*s + pos[i].first*16 + pos[i].second;\n  }\n  return s;\n}\n\nvoid decode(pair<int,int> *ps, int s, int N)\n{\n  for (int i = 0; i < N; i++) {\n    const int t = s % 256;\n    ps[N-i-1] = make_pair(t/16, t%16);\n    s /= 256;\n  }\n}\n\nint manhattan(const pair<int,int> *ps, const pair<int,int> *fin, int N)\n{\n  int l = 0;\n  for (int i = 0; i < N; i++) {\n    l = max(l, abs(ps[i].first - fin[i].first) + abs(ps[i].second - fin[i].second));\n  }\n  return l;\n}\n\nbool calc_next(pair<int,int> *next, int N, const char grid[16][20], const pair<int,int> *ps, int a)\n{\n  for (int i = 0; i < N; i++) {\n    static const int di[] = {-1, 1, 0, 0, 0}, dj[] = {0, 0, -1, 1, 0};\n    const int k = ps[i].first + di[a%5];\n    const int l = ps[i].second + dj[a%5];\n    a /= 5;\n    if (grid[k][l] == '#') {\n      return false;\n    }\n    next[i] = make_pair(k, l);\n  }\n  return true;\n}\n\nbool valid(const pair<int,int> *cur, const pair<int,int> *next, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (next[i] == next[j]) {\n        return false;\n      }\n      if (next[i] == cur[j] && next[j] == cur[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  char buf[100];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    pair<int,int> pos[3];\n    pair<int,int> fin[3];\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          pos[grid[i][j]-'a'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          fin[grid[i][j]-'A'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int final = encode(fin, N);\n    int A = 1;\n    for (int i = 0; i < N; i++) {\n      A *= 5;\n    }\n\n    static unsigned short dist[256*256*256];\n    fill_n(dist, 256*256*256, 1000);\n    dist[encode(pos, N)] = 0;\n    priority_queue<pair<short,int> > q;\n    q.push(make_pair(-manhattan(pos, fin, N), encode(pos, N)));\n    while (!q.empty()) {\n      const int c = -q.top().first;\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", dist[s]);\n        break;\n      }\n      decode(pos, s, N);\n      const int d = c - manhattan(pos, fin, N);\n      if (d > dist[s]) {\n        continue;\n      }\n\n      for (int a = 0; a < A; a++) {\n        pair<int,int> next[3];\n        if (!calc_next(next, N, grid, pos, a)) {\n          continue;\n        }\n        const int u = encode(next, N);\n        if (dist[s]+1 < dist[u] && valid(pos, next, N)) {\n          dist[u] = dist[s]+1;\n          q.push(make_pair(-dist[u]-manhattan(next, fin, N), u));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nbool same(const vector<int>& sx, const vector<int>& sy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == sx[j] && sy[i] == sy[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool is_swap(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 1;\n            }\n        }       \n    }\n    return 0;\n}\n\nusing ll = long long;\n\nll v2l(const pair<vector<int>, vector<int>>& v)\n{\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        res *= H * W;\n        res += v.first[i] + v.second[i] * W;\n    }\n    return res;\n}\n\npair<vector<int>, vector<int>> l2v(ll l)\n{\n    pair<vector<int>, vector<int>> v;\n    for (int i = 0; i < N; i++) {\n        int u = l % (H * W);\n        int x = u % W, y = u / W;\n        v.first.emplace_back(x);\n        v.second.emplace_back(y);\n        l /= H * W;\n    }\n    reverse(v.first.begin(), v.first.end());\n    reverse(v.second.begin(), v.second.end());\n    return v;\n}\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<ll> que;    \n    que.push(v2l(make_pair(sx, sy)));\n\n    unordered_map<ll, int> d;\n    d[v2l(make_pair(sx, sy))] = 0;    \n    \n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        auto nf = l2v(f);\n        auto csx = nf.first, csy = nf.second;\n        \n        if (reach(csx, csy, gx, gy)) {\n            return d[f];\n        }\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (same(nsx, nsy) || is_swap(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            auto next = v2l(make_pair(nsx, nsy));\n            if (d.count(next) == 0) {                \n                d[next] = d[f] + 1;               \n                que.push(next);\n            }\n        }\n    }    \n    return -1;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        cout << bfs(field, sx, sy, gx, gy) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int W, H, N;\n    vector<string> F;\n\n    bool input() {\n        cin >> W >> H >> N;\n        if (W == 0 && H == 0 && N == 0) return false;\n        string s; getline(cin, s);\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) getline(cin, F[i]);\n        return true;\n    }\n    \n    struct Point {\n        int y, x;\n        Point() {}\n        Point(int y, int x) : y(y), x(x) {}\n    };\n    bool operator==(const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }\n    bool operator<(const Point& a, const Point& b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }\n    ostream& operator<<(ostream& os, const Point& a) { return os << \"Point(\" << a.x << \",\" << a.y << \")\"; }\n\n    vector<Point> start, goal;\n\n    void init() {\n        start.resize(N);\n        goal.resize(N);\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c = F[i][j];\n                if (islower(c)) {\n                    start[ c - 'a' ] = Point(i, j);\n                } else if (isupper(c)) {\n                    goal[ c - 'A' ] = Point(i, j);\n                }\n            }\n        }\n    }\n\n    struct State {\n        vector<Point> ps;\n        int t;\n        State() {\n            ps.clear(); ps.resize(N);\n        }\n        State(const vector<Point>& ps, int t) : ps(ps), t(t) {}\n    };\n\n    const int dy[] = {-1, 0, 1, 0, 0},\n              dx[] = {0, 1, 0, -1, 0};\n\n    bool check(const State& prev, const State& next) {\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (i != j && next.ps[i] == next.ps[j]) return false;\n                if (i != j && prev.ps[i] == next.ps[j] && prev.ps[j] == next.ps[i]) return false;\n            }\n        }\n        return true;\n    }\n\n    int encode(const vector<Point>& ps);\n    static bool D[(1<<24) + 1];\n    void genNextState(const State& c, queue<State>& Q, State next, int index = 0 ) {\n        if (index == N) {\n            if (!check(c, next)) return;\n            int h = encode(next.ps);\n            if (D[h]) return;\n            D[h] = true;\n            Q.push(next);\n            return;\n        }\n        for (int i = 0; i < 5; i++) {\n            int ny = c.ps[index].y + dy[i];\n            int nx = c.ps[index].x + dx[i];\n            if (F[ny][nx] == '#') continue;\n            next.ps[index] = Point(ny, nx);\n            genNextState(c, Q, next, index + 1);\n        }\n    }\n\n    int encode(const vector<Point>& ps) {\n        int r = 0;\n        for (int i = 0; i < N; i++) {\n            const Point& p = ps[i];\n            r += (p.y << (i * 8));\n            r += (p.x << (i * 8 + 4));\n        }\n        return r;\n    }\n\n    const int INF = 1<<29;\n\n    void solve() {\n        init();\n        memset(D, 0, sizeof(D));\n        queue<State> Q;\n        Q.push(State(start, 0));\n        D[encode(start)] = true;\n        while (!Q.empty()) {\n            State c = Q.front(); Q.pop();\n            if (c.ps == goal) {\n                cout << c.t << endl;\n                break;\n            }\n            //cout << c.ps << \" t: \" << c.t  << endl;\n            State stub; stub.t = c.t + 1;\n            genNextState(c, Q, stub);\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstatic const int dy[] = { -1, 0, 1, 0, 0}, dx[] = { 0, -1, 0, 1, 0 };\n\nstruct state { int a, b, c, step; };\n\nbool used[260][260][260];\n\nint main() {\n        int w, h, n;\n        while (true) {\n                cin >> w >> h >> n;\n                cin.ignore();\n                if (n == 0) break;\n                vector<string> m(h);\n                for (int i = 0; i < h; i ++) getline(cin, m[i]);\n                int as, ag, bs = (h - 1) * w + (w - 1), bg = (h - 1) * w + (w - 1), cs = 0, cg = 0;\n                for (int i = 0; i < h; i ++) {\n                        for (int j = 0; j < w; j ++) {\n                                if (m[i][j] == 'A') as = i * w + j;\n                                if (m[i][j] == 'a') ag = i * w + j;\n                                if (m[i][j] == 'B') bs = i * w + j;\n                                if (m[i][j] == 'b') bg = i * w + j;\n                                if (m[i][j] == 'C') cs = i * w + j;\n                                if (m[i][j] == 'c') cg = i * w + j;\n                        }\n                }\n                queue<state> q;\n                memset(used, false, sizeof(used));\n                used[as][bs][cs] = true;\n                q.push((state) { as, bs, cs });\n                int ans = -1;\n                while (!q.empty()) {\n                        state now = q.front(); q.pop();\n                        if (now.a == ag && now.b == bg && now.c == cg) {\n                                ans = now.step;\n                                break;\n                        }\n                        int noway = now.a / w, nowax = now.a % w;\n                        int nowby = now.b / w, nowbx = now.b % w;\n                        int nowcy = now.c / w, nowcx = now.c % w;\n                        for (int da = 0; da < 5; da ++) {\n                                int neway = noway + dy[da], newax = nowax + dx[da];\n                                if (neway < 0 || h <= neway || newax < 0 || w <= newax) continue;\n                                if (m[neway][newax] == '#') continue;\n                                for (int db = 0; db < 5; db ++) {\n                                        int newby = nowby + dy[db], newbx = nowbx + dx[db];\n                                        if (newby < 0 || h <= newby || newbx < 0 || w <= newbx) continue;\n                                        if (n > 1) if (m[newby][newbx] == '#') continue;\n                                        for (int dc = 0; dc < 5; dc ++) {\n                                                int newcy = nowcy + dy[dc], newcx = nowcx + dx[dc];\n                                                if (newcy < 0 || h <= newcy || newcx < 0 || w <= newcx) continue;\n                                                if (n > 2) if (m[newcy][newcx] == '#') continue;\n\n                                                int newa = neway * w + newax;\n                                                int newb = newby * w + newbx;\n                                                int newc = newcy * w + newcx;\n\n                                                if (newa == newb || newa == newc || newb == newc) continue; //Rule 1.\n                                                if (newa == now.b && newb == now.a) continue; //Rule 2.\n                                                if (newa == now.c && newc == now.a) continue; //\n                                                if (newb == now.c && newc == now.b) continue; //\n\n                                                if (used[newa][newb][newc]) continue;\n                                                used[newa][newb][newc] = true;\n                                                q.push((state) { newa, newb, newc, now.step + 1 });\n                                        }\n                                }\n                        }\n                }\n                cout << ans << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,n;\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\nstring mp[20];\n\nstruct dat{\n  int y1,x1;\n  int y2,x2;\n  int y3,x3;\n};\n\n\nint D[14][14][15][14][14][15];\nqueue<dat> Q;\nvoid DD(dat &a,int b){D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1] = b;}\nint DD(const dat &a){return D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1];}\n\nbool check(const dat &a){\n  if(mp[a.y1][a.x1]=='#') return 0;\n  if(n>=2&&mp[a.y2][a.x2]=='#') return 0;\n  if(n>=3&&mp[a.y3][a.x3]=='#') return 0;\n  return DD(a)==-1;\n}\n\nvoid update(const dat &a){\n  int cost = DD(a);\n\n  for(int i=0;i<5;i++){\n    int ny1 = a.y1+dy[i], nx1 = a.x1+dx[i];\n    for(int j=0;j<5;j++){\n      int ny2 = a.y2+dy[j], nx2 = a.x2+dx[j];\n      if(n<=1) ny2 = 15,nx2 = 14;\n      for(int k=0;k<5;k++){\n\tint ny3 = a.y3+dy[k], nx3 = a.x3+dx[k];\n\tif(n<=2) ny3 = 14,nx3 = 15;\n\n\tdat nt = (dat){ny1,nx1,ny2,nx2,ny3,nx3};\n\tif(!check(nt))continue;\n\t\n\tif((ny1==ny2&&nx1==nx2) ||(ny2==ny3&&nx2==nx3) ||(ny3==ny1&&nx3==nx1))continue;//same pos\n\tif(((a.y1==ny2&&a.x1==nx2) && (a.y2==ny1&&a.x2==nx1)) || // swap positoin\n\t   ((a.y2==ny3&&a.x2==nx3) && (a.y3==ny2&&a.x3==nx2)) ||\n\t   ((a.y3==ny1&&a.x3==nx1) && (a.y1==ny3&&a.x1==nx3)) )continue;\n\t\n\tQ.push(nt);\n\tDD(nt,cost+1);\n      }\n    }\n  }\n}\n\nbool goal(const dat &s,const dat &t){\n  char a = mp[s.y1][s.x1];\n  char b = mp[s.y2][s.x2];\n  char c = mp[s.y3][s.x3];\n  char A = mp[t.y1][t.x1];\n  char B = mp[t.y2][t.x2];\n  char C = mp[t.y3][t.x3];\n  return toupper(a)==A&&(n<=1||toupper(b)==B)&&(n<=2||toupper(c)==C);\n}\n\nint bfs(dat &start){\n  memset(D,-1,sizeof(D));\n  while(!Q.empty())Q.pop();\n  Q.push(start);\n  DD(start,0);\n  \n  while(!Q.empty()){\n    dat t = Q.front();Q.pop();\n    if(goal(start,t)) return DD(t);\n    update(t);\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>w>>h>>n;\n  if(!w&&!h&&!n)break;\n  cin.ignore();\n  for(int i=0;i<h;i++)getline(cin,mp[i]),mp[i]+='#';\n  \n  dat start = (dat){15,15,15,14,14,15};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!islower(mp[i][j]))continue;\n      if(start.y1==15) start.y1=i,start.x1=j;\n      else if(start.y2==15) start.y2=i,start.x2=j;\n      else start.y3=i,start.x3=j;\n    }\n  cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d > s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P start, P goal){\n  int& dist = memo[start.first][start.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  queue<P> que;\n  que.push(goal);\n  memo[goal.first][goal.second][goal.first][goal.second] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    REP(r, 4){\n      P q = p;\n      q.first += dx[r];\n      q.second += dy[r];\n      if(!valid(q.first, q.second, W, H)) continue;\n      if(memo[q.first][q.second][goal.first][goal.second] != -1) continue;\n      memo[q.first][q.second][goal.first][goal.second] = memo[p.first][p.second][goal.first][goal.second] + 1;\n      que.push(q);\n    }\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct state{\n\tint x[3], y[3];\n\tstate(){}\n\tstate(int a, int b, int c, int d, int e, int f){\n\t\tx[0] = a, y[0] = b, x[1] = c, y[1] = d, x[2] = e, y[2] = f;\n\t}\n};\n\nint w, h, n;\nchar map[20][20];\nint sx[3], sy[3];\nint gx[3], gy[3];\nint dist[14][15][14][15][14][15];\nconst int dx[] = {1, 0, -1, 0, 0}, dy[] = {0, -1, 0, 1, 0};\n\nvoid bfs()\n{\n\tfor(int ax = 0; ax < 14; ax++){\n\t\tfor(int ay = 0; ay < 15; ay++){\n\t\t\tfor(int bx = 0; bx < 14; bx++){\n\t\t\t\tfor(int by = 0; by < 15; by++){\n\t\t\t\t\tfor(int cx = 0; cx < 14; cx++){\n\t\t\t\t\t\tfor(int cy = 0; cy < 15; cy++){\n\t\t\t\t\t\t\tdist[ax][ay][bx][by][cx][cy] = inf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdist[sx[0]][sy[0]][sx[1]][sy[1]][sx[2]][sy[2]] = 0;\n\t\n\tqueue<state> Q;\n\tQ.push( state(sx[0], sy[0], sx[1], sy[1], sx[2], sy[2]) );\n\t\n\t\n\tstate st;\n\tint x[3], y[3], nx[3], ny[3];\n\twhile(Q.size()){\n\t\tst = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < 3; i++) x[i] = st.x[i], y[i] = st.y[i];\n\t\t\n\t\tfor(int ad = 0; ad < 5; ad++){\n\t\t\tnx[0] = x[0] + dx[ad], ny[0] = y[0] + dy[ad];\n\t\t\tif(y[0] < 14 && (nx[0] < 0 || nx[0] >= w || ny[0] < 0 || ny[0] >= h)) continue;\n\t\t\tif(map[nx[0]][ny[0]] == '#') continue;\n\t\t\t\n\t\t\tfor(int bd = 0; bd < 5; bd++){\n\t\t\t\tif(y[1] == 14 && bd < 4) continue;\n\t\t\t\tnx[1] = x[1] + dx[bd], ny[1] = y[1] + dy[bd];\n\t\t\t\tif(y[1] < 14 && (nx[1] < 0 || nx[1] >= w || ny[1] < 0 || ny[1] >= h)) continue;\n\t\t\t\tif(map[nx[1]][ny[1]] == '#') continue;\n\t\t\t\t\n\t\t\t\tfor(int cd = 0; cd < 5; cd++){\n\t\t\t\t\tif(y[2] == 14 && cd < 4) continue;\n\t\t\t\t\tnx[2] = x[2] + dx[cd], ny[2] = y[2] + dy[cd];\n\t\t\t\t\tif(y[2] < 14 && (nx[2] < 0 || nx[2] >= w || ny[2] < 0 || ny[2] >= h)) continue;\n\t\t\t\t\tif(map[nx[2]][ny[2]] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(nx[0] == nx[1] && ny[0] == ny[1] && ny[1] != 14) continue;\n\t\t\t\t\tif(nx[1] == nx[2] && ny[1] == ny[2] && ny[2] != 14) continue;\n\t\t\t\t\tif(nx[2] == nx[0] && ny[2] == ny[0] && ny[0] != 14) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(nx[0] == x[1] && ny[0] == y[1] && x[0] == nx[1] && y[0] == ny[1] && ny[1] != 14) continue;\n\t\t\t\t\tif(nx[1] == x[2] && ny[1] == y[2] && x[1] == nx[2] && y[1] == ny[2] && ny[2] != 14) continue;\n\t\t\t\t\tif(nx[2] == x[0] && ny[2] == y[0] && x[2] == nx[0] && y[2] == ny[0] && ny[0] != 14) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(dist[nx[0]][ny[0]][nx[1]][ny[1]][nx[2]][ny[2]] < inf) continue;\n\t\t\t\t\tdist[nx[0]][ny[0]][nx[1]][ny[1]][nx[2]][ny[2]] = dist[x[0]][y[0]][x[1]][y[1]][x[2]][y[2]] + 1;\n\t\t\t\t\tQ.push( state(nx[0], ny[0], nx[1], ny[1], nx[2], ny[2]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> w >> h >> n;\n\t\tif(w == 0 && h == 0 && n == 0) break;\n\t\tcin.ignore();\n\t\t\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tsx[i] = gx[i] = 13;\n\t\t\tsy[i] = gy[i] = 14;\n\t\t}\n\t\t\n\t\tchar c; string s;\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tgetline(cin, s);\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tc = s[x];\n\t\t\t\tif(x == 0 || x == w-1 || y == 0 || y == h-1) continue;\n\t\t\t\tif(c >= 'a' && c <= 'c'){\n\t\t\t\t\tsx[c - 'a'] = x-1, sy[c - 'a'] = y-1;\n\t\t\t\t\tc = ' ';\n\t\t\t\t}\n\t\t\t\tif(c >= 'A' && c <= 'C'){\n\t\t\t\t\tgx[c - 'A'] = x-1, gy[c - 'A'] = y-1;\n\t\t\t\t\tc = ' ';\n\t\t\t\t}\n\t\t\t\tmap[x-1][y-1] = c;\n\t\t\t}\n\t\t}\n\t\tw -= 2, h -= 2;\n\t\t\n\t\tbfs();\n\t\tcout << dist[gx[0]][gy[0]][gx[1]][gy[1]][gx[2]][gy[2]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint h,w,n;\nchar G[MAX][MAX];\n//unsigned char ev[MAX*MAX][MAX*MAX];\n//unsigned char mincost[MAX*MAX][MAX*MAX][MAX*MAX];\nshort ev[MAX*MAX][MAX*MAX];\nshort mincost[MAX*MAX][MAX*MAX][MAX*MAX];\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint goal[3],sp[3];\nchar cc[3];\n\nstruct Pox\n{\n  int cur[3];\n  //unsigned char cost;\n  short cost;\n  Pox(int a=255,int b=255,int c=255,/*unsigned char*/short cost=1000/*255*/):cost(cost)\n  {\n    cur[0] = a, cur[1] = b, cur[2] = c;\n  }\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)cout << a[i][j];\n      cout << endl;\n    }\n  cout << endl;\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\n\nvoid initEv()\n{\n  rep(y,h*w)rep(x,h*w)ev[y][x] = 1000;//255;\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[x+y*w][x+y*w] = 0;\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  rep(i,4)\n\t    {\n\t      int nx = cx + dx[i];\n\t      int ny = cy + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t\t{\n\t\t  ev[x+y*w][nx+ny*w] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nbool fin_check(int *cur)\n{\n  rep(i,n)if(cur[i] != goal[i])return false;\n  return true;\n}\n\nvoid compute()\n{\n  /*\n  rep(i,n)\n    {\n      cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }\n  */\n  rep(i,MAX*MAX)rep(j,MAX*MAX)rep(k,MAX*MAX)mincost[i][j][k] = 1000;//(unsigned char)255;\n\n  priority_queue<Pox> Q;\n  mincost[sp[0]][sp[1]][sp[2]] = 1000;//(unsigned char)0;\n  Q.push(Pox(sp[0],sp[1],sp[2],0));\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n\n      //      cout << \"pox ( ( \" << pox.cur[0] << \" \" << pox.cur[0] % w << \",\" << pox.cur[0] / w << \") ( \" << pox.cur[1] % w << \",\" << pox.cur[1] / w << \" ) ) : \" << (int)pox.cost << \" \\n\"; \n\n      if(fin_check(pox.cur))\n\t{\n\t  cout << (int)pox.cost << endl;\n\t  return;\n\t}\n\n\n      if(n == 1)\n\t{\n\t  int x = pox.cur[0] % w;\n\t  int y = pox.cur[0] / w;\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\n\t      //cout << \"mincost[\" << pox.cur[0] << \"][0][0] = \" << (int)mincost[pox.cur[0]][0][0] << \" > \" << (pox.cost + 1) << endl;\n\n\t      if(mincost[nx+ny*w][0][0] > /*(unsigned char)*/(pox.cost + 1))\n\t\t{\n\t\t  mincost[nx+ny*w][0][0] = pox.cost + 1;\n\t\t  Pox next = Pox(nx+ny*w,0,0,pox.cost+1);\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  int x1 = pox.cur[0] % w;\n\t  int y1 = pox.cur[0] / w;\n\t  int x2 = pox.cur[1] % w;\n\t  int y2 = pox.cur[1] / w;\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx1+ny1*w,pox.cur[1],nx2+ny2*w))continue;\n\t\t  //cout << \"here : \" << (int)mincost[nx1+ny1*w][nx2+ny2*w][0] << \" > \" << pox.cost + 1 << endl;\n\n\t\t  if(mincost[nx1+ny1*w][nx2+ny2*w][0] > /*(unsigned char)*/(pox.cost + 1))\n\t\t    {\n\t\t      mincost[nx1+ny1*w][nx2+ny2*w][0] = pox.cost + 1;\n\t\t      Q.push(Pox(nx1+ny1*w,nx2+ny2*w,0,pox.cost+1));\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = pox.cur[i] % w, y[i] = pox.cur[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(pox.cur[1],nx[1]+ny[1]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\n\t\t      if(mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] > /*(unsigned char)*/(pox.cost + 1))\n\t\t\t{\n\t\t\t  mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] = pox.cost + 1;\n\t\t\t  Q.push(Pox(nx[0]+ny[0]*w,nx[1]+ny[1]*w,nx[2]+ny[2]*w,pox.cost+1));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),h|w|n)\n    {\n      rep(i,3)sp[i] = 0;\n      int cd = 0;\n      map<char,int> dex;\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    {\n\t      scanf(\"%c\",&G[i][j]);\n\t      dex[G[i][j]] = j + i * w;\n\t      if('a' <= G[i][j] && G[i][j] <= 'z')\n\t\t{\n\t\t  sp[cd] = j + i * w;\n\t\t  cc[cd++] = G[i][j];\n\t\t}\n\t    }\n\t}\n      assert(n == cd);\n      rep(i,n)goal[i] = dex['A'+cc[i]-'a'];\n\n      //print(G);\n      initEv();\n\n      compute();\n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> state;\n\nconst int dy[] = {0,-1,0,1,0}, dx[] = {0,0,1,0,-1};\n\ninline int encode(const state &x, const int &w){\n  int res = 0, k = 1;\n  for(pii p : x){\n    res += k * (p.fs*w + p.sc);\n    k <<= 8;\n  }\n  return res;\n}\n\ninline state decode(int x, const int &n, const int &w){\n  int k = 1<<8;\n  state res;\n  rep(i,n){\n    int t = x % k;\n    res.push_back(pii(t/w, t%w));\n    x >>= 8;\n  }\n  return res;\n}\n\nshort memo[1<<24];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int h,w,n;\n  string g[16];\n  while(cin >> w >> h >> n, w){\n    cin.ignore();\n\n    state start(n), end(n);\n    rep(i,h){\n      getline(cin,g[i]);\n      rep(j,w){\n\tif(islower(g[i][j]))start[g[i][j]-'a'] = pii(i,j);\n\tif(isupper(g[i][j]))end[g[i][j]-'A'] = pii(i,j);\n      }\n    }\n    int start_id = encode(start,w);\n    int end_id = encode(end,w);\n\n    memset(memo,-1,sizeof(memo));\n    memo[start_id] = 0;\n    queue<int> q; q.push(start_id);\n    \n    while(q.size()){\n      int cur_id = q.front(); q.pop();\n      state cur = decode(cur_id,n,w);\n      if(cur_id == end_id)break;\n\n      vi dir(n,0); dir[0] = 1;\n      while(dir[n-1]<5){\n\tstate nxt = cur;\n\tbool f = true;\n\tfor(int i=0;f && i<n;i++){\n\t  nxt[i].fs += dy[dir[i]], nxt[i].sc += dx[dir[i]];\n\t  if(g[nxt[i].fs][nxt[i].sc] == '#')f = false;\n\n\t  for(int j=0;f && j<i;j++){\n\t    if(nxt[i] == nxt[j])f = false;\n\t    if(nxt[i] == cur[j] && nxt[j] == cur[i])f = false;\n\t  }\n\t}\n\n\tif(f){\n\t  int nxt_id = encode(nxt, w);\n\t  if(memo[nxt_id] < 0){\n\t    memo[nxt_id] = memo[cur_id] + 1;\n\t    q.push(nxt_id);\n\t  }\n\t}\n\n\tdir[0]++;\n\tfor(int i=0;i<n-1;i++){\n\t  if(dir[i]==5)dir[i] = 0, dir[i+1]++;\n\t}\n      }\n\n    }\n    cout << memo[end_id] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<char, char> P;\n\nint W, H, N;\nbool field[16][16];\nbool reach[1 << 24];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nstruct State{\n\tarray<P, 3> cord;\n\tint cnt;\n\tState() : cnt(0) {\n\t\tcord.fill(P(0, 0));\n\t}\t\n\tint hash(){\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 3; i++) ret = (ret << 8) | (cord[i].first << 4) | cord[i].second;\n\t\treturn ret;\n\t}\n\n};\nState target;\n\nint score(const State& s){\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tans = max(ans, abs(target.cord[i].first - s.cord[i].first) + abs(target.cord[i].second - s.cord[i].second));\n\t}\n\treturn ans + s.cnt;\n}\nbool operator<(const State& ss1, const State& ss2){\n\tint s1 = score(ss1);\n\tint s2 = score(ss2);\n\tif(s1 != s2) return s2 < s1;\n\telse ss1.cord < ss2.cord;\n}\n\nostream& operator<<(ostream& os, const State& dt)  {  \n\tos << \"[\";\n\tfor(int i = 0; i < N; i++){\n\t\tos << \"(\" << dt.cord[i].first << \",\" << dt.cord[i].second << \")\";\n\t}\n\tos << dt.cnt << \"]\";\n\treturn os;  \n}  \n\nvoid dfs(priority_queue<State> &que, State &prev, int idx, State n){\n\tif(idx == N){\n\t\tif(\n\t\t\t\tN >= 2 && prev.cord[0] == n.cord[1] && prev.cord[1] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[0] == n.cord[2] && prev.cord[2] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[1] == n.cord[2] && prev.cord[2] == n.cord[1] ||\n\t\t\t\tN >= 2 && n.cord[0] == n.cord[1]  ||\n\t\t\t\tN >= 3 && n.cord[0] == n.cord[2]  ||\n\t\t\t\tN >= 3 && n.cord[1] == n.cord[2]  \n\t\t  ) return;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!field[n.cord[i].second][n.cord[i].first]) return;\n\t\t}\n\t\tn.cnt++;\n\t\tque.push(n);\n\n\t}else{\n\t\tdfs(que, prev, idx + 1, n);\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tn.cord[idx] = P(prev.cord[idx].first + dx[i], prev.cord[idx].second + dy[i]);\n\t\t\tdfs(que, prev, idx + 1, n);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H >> N, W){\n\t\tState begin;\n\t\tstring str;\n\t\tgetline(cin, str);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tgetline(cin, str);\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tchar c = str[j];\n\t\t\t\tif(c == '#') field[i][j] = false;\n\t\t\t\telse{\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t\tif('A' <= c && c <= 'C') target.cord[c - 'A'] = P(j, i);\n\t\t\t\t\telse begin.cord[c - 'a'] = P(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < (1 << 24); i++) reach[i] = false;\n\t\tpriority_queue<State> que;\n\t\tque.push(begin);\n\t\tint ans = -1;\n\t\twhile(que.size()){\n\t\t\tState s = que.top(); que.pop();\n\t\t\tif(s.cord == target.cord){\n\t\t\t\tans = s.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(reach[s.hash()]) continue;\n\t\t\treach[s.hash()] = true;\n\t\t\tdfs(que, s, 0, s);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\n\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nbool same(const vector<int>& sx, const vector<int>& sy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == sx[j] && sy[i] == sy[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool is_swap(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 1;\n            }\n        }       \n    }\n    return 0;\n}\n\nusing ll = long long;\n\nll v2u(const pair<vector<int>, vector<int>>& v)\n{\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        res *= H * W;\n        res += v.first[i] * 16 + v.second[i];\n    }\n    return res;\n}\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;    \n    que.push(make_pair(sx, sy));\n\n    unordered_map<ll, int> d;\n    d[v2u(make_pair(sx, sy))] = 0;    \n    \n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) {\n            return d[v2u(f)];\n        }\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (same(nsx, nsy) || is_swap(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            auto next = make_pair(nsx, nsy);\n            if (d.count(v2u(next)) == 0) {                \n                d[v2u(next)] = d[v2u(f)] + 1;\n                que.push(next);\n            }\n        }\n    }    \n    return -1;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        cout << bfs(field, sx, sy, gx, gy) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tbool goal=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d.y[i]!=gy[i] || d.x[i]!=gx[i])goal=false;\n\t\t}\n\t\tif(goal){\n\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]];\n\t\t}\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h;\n            ret += y[i];\n            ret *= w;\n            ret += x[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    vector<int> sy(n), sx(n), gy(n), gx(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sy[c-'a'] = i;\n                sx[c-'a'] = j;\n            }else if('A' <= c && c <= 'C'){\n                gy[c-'A'] = i;\n                gx[c-'A'] = j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= h * w;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sy, sx, 0).toInt()] = true;\n    check[1][Data(gy, gx, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sy, sx, 0));\n    dq[1].push_back(Data(gy, gx, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n        if(check[turn^1][d.toInt()])\n            return ret;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.y[i] += dy[j];\n                d.x[i] += dx[j];\n\n                bool ok = true;\n                if(grid[d.y[i]][d.x[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.y[i] -= dy[j];\n                d.x[i] -= dx[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n  \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n  \n  \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n  \narray<short, 1 << 24> dist;\n  \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n      \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n      \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n  \n    int last_hash = last.hash();\n  \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                      \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n  \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint tm0;\nvector<int> q[2];\n\nbool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = (i + 8) % 24;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = (v >> j % 24) & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j % 24 & 255) &&\n\t\t\t\tp2 == (u >> i % 24 & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\tq[0].clear();\n\tq[1].clear();\n\tq[0].push_back(start);\n\n\tint tm = tm0 + 1;\n\tvis[start] = tm;\n\twhile(1){\n\t\tif(q[0].empty()){\n\t\t\tq[0].swap(q[1]);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tint u = q[0].back();\n\t\t\tq[0].pop_back();\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\tq[1].push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tm = solve(start, goal);\n\t\tprintf(\"%d\\n\", tm - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\n\nS i2s(int x){\n  return S(x>>12,x&((1<<12)-1));\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first<<12)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*16+p.first[i];\n    x=x*16+p.second[i];\n  }\n  return S(y,x);\n}\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%16);\n    x.push_back(b%16);\n    a/=16;b/=16;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nint m[1<<26];\nqueue<int> q;\n\nvector<int> ys,xs;\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    P r=P(ys,xs);\n    int abc=p2i(r);\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nshort memo[16][16][16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint mget(vector<pair<int, int>>ps) {\n\tfor (int i = ps.size(); i < 3; ++i) {\n\t\tps.emplace_back(0, 0);\n\t}\n\treturn memo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].first][ps[2].second];\n}\nvoid mset(vector<pair<int, int>>ps,const int value) {\n\tfor (int i = ps.size(); i < 3; ++i) {\n\t\tps.emplace_back(0, 0);\n\t}\n\tmemo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].first][ps[2].second]=value;\n}\nbool check(vector<pair<int, int>>ps) {\n\tif (ps.size() == 1)return true;\n\tif (ps.size() == 3) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (abs(ps[i].first - ps[(i + 1) % 3].first) + abs(ps[i].second - ps[(i + 1) % 3].second) == 1)return false;\n\t\t}\n\t}\n\treturn true;\n}\nstruct aa {\n\tvector<pair<int, int>>coors;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tfor (size_t i = 0; i < 16; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < 16; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < 16; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (size_t l = 0; l < 16; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (size_t m = 0; m < 16; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (size_t n = 0; n < 16; n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint W, H, N; cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<pair<int, int>>s(N);\n\t\tvector<pair<int, int>>f(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse if (st[j] <= 'a'+N-1 && st[j] >= 'a') {\n\t\t\t\t\tf[st[j] - 'a'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts[st[j] - 'A'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmset(s, 0);\n\t\tqueue<aa>que;\n\t\tque.push(aa{ s, 0 });\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tconst auto from = atop.coors;\n\t\t\tconst int aturn = atop.turn;\n\t\t\tif (from == f) {\n\t\t\t\tans = aturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int>nums(N);\n\t\t\tiota(nums.begin(), nums.end(),0);\n\t\t\tdo {\n\t\t\t\t int repnum = 1;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\trepnum *= 5;\n\t\t\t\t}\n\t\t\t\tfor (int b = 0; b < repnum; ++b) {\n\t\t\t\t\tint bb = b;\n\t\t\t\t\tauto newcoors(from);\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tconst int gh = nums[i];\n\t\t\t\t\t\tconst int way = bb % 5;\n\t\t\t\t\t\tbb /= 5;\n\t\t\t\t\t\tconst int newx = (newcoors[gh].first += dx[way]);\n\t\t\t\t\t\tconst int newy = (newcoors[gh].second += dy[way]);\n\t\t\t\t\t\tif (field[newy][newx]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int op = 0; op < N; ++op) {\n\t\t\t\t\t\t\tif (op == gh)continue;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (newcoors[gh] == newcoors[op])ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (mget(newcoors)<0||mget(newcoors) > aturn + 1) {\n\t\t\t\t\t\t\tmset(newcoors, aturn + 1);\n\t\t\t\t\t\t\tque.push(aa{ newcoors,aturn + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (check(from)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (next_permutation(nums.begin(), nums.end()));\t\n\t\t\tif (que.empty()) {\n\t\t\t\tcout << 1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<math.h>\n#include<string.h>\nusing namespace std;\nconst int dx[] = { -1, 1, 0, 0 };\nconst int dy[] = { 0, 0, -1, 1 };\nint w, h, n;\nint mymap[400][10];\nint deg[400];\nint ghost[4], target[4];\nint *hash_table;\nint *dist;\nint pos_count;\nqueue<int> q1, q2;\n\nint judge1(int org1, int org2, int aft1, int aft2) {\n\tif ((aft1 == aft2) || (org1 == aft2 && org2 == aft1))\n\t\treturn 0;\n\treturn 1;\n}\n\nint judge2(int parent, int child, int flag) {\n\tif (!hash_table[child]) {\n\t\tif (flag == 1)\n\t\t\tq1.push(child);\n\t\telse\n\t\t\tq2.push(child);\n\n\t\thash_table[child] = flag;\n\t\tdist[child] = dist[parent] + 1;\n\t}\n\telse if (hash_table[child] != flag) {\n\t\tint result = dist[parent] + 1 + dist[child];\n\t\tprintf(\"%d\\n\", result);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint search(int parent, int p1, int p2, int p3, int flag) {\n\tfor (int d1 = 0; d1 < deg[p1]; d1++) {\n\t\tint c1 = mymap[p1][d1];\n\t\tif (n == 1 && judge2(parent, c1, flag))\n\t\t\treturn 1;\n\t\telse if (n > 1) {\n\t\t\tfor (int d2 = 0; d2 < deg[p2]; d2++) {\n\t\t\t\tint c2 = mymap[p2][d2];\n\t\t\t\tif (!judge1(p1, p2, c1, c2))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (n == 2 && judge2(parent, c1 + pos_count * c2, flag))\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (n == 3) {\n\t\t\t\t\tfor (int d3 = 0; d3 < deg[p3]; d3++) {\n\t\t\t\t\t\tint c3 = mymap[p3][d3];\n\t\t\t\t\t\tif (!(judge1(p1, p3, c1, c3) && judge1(p2, p3, c2, c3)))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (judge2(parent, c1 + pos_count * c2 + pos_count * pos_count * c3, flag))\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs() {\n\tint status1 = ghost[0] + ghost[1] * pos_count + ghost[2] * pos_count*pos_count;\n\tint status2 = target[0] + target[1] * pos_count + target[2] * pos_count*pos_count;\n\tq1 = queue<int>();\n\tq2 = queue<int>();\n\tq1.push(status1);\n\tq2.push(status2);\n\thash_table[status1] = 1;\n\thash_table[status2] = 2;\n\tdist[status1] = 0;\n\tdist[status2] = 0;\n\tint layer_count = 0;\n\twhile (!q1.empty() || !q2.empty()) {\n\t\twhile (!q1.empty() && (dist[status1] == layer_count)) {\n\t\t\tstatus1 = q1.front();\n\t\t\tint status11 = status1 % pos_count;\n\t\t\tint status12 = status1 / pos_count % pos_count;\n\t\t\tint status13 = status1 / pos_count / pos_count % pos_count;\n\t\t\tq1.pop();\n\t\t\tif (search(status1, status11, status12, status13, 1))\n\t\t\t\treturn 1;\n\t\t}\n\t\twhile (!q2.empty() && (dist[status2] == layer_count)) {\n\t\t\tstatus2 = q2.front();\n\t\t\tint status21 = status2 % pos_count;\n\t\t\tint status22 = status2 / pos_count % pos_count;\n\t\t\tint status23 = status2 / pos_count / pos_count % pos_count;\n\t\t\tq2.pop();\n\t\t\tif (search(status2, status21, status22, status23, 2))\n\t\t\t\treturn 1;\n\t\t}\n\t\tlayer_count++;\n\t}\n\treturn -1;\n}\n\nvoid init() {\n\tfor (int i = 0; i < 400; i++)\n\t\tdeg[i] = 0;\n}\n\nint main() {\n\twhile (scanf(\"%d%d%d\", &w, &h, &n) == 3 && n) {\n\t\tchar map[20][20];\n\t\tint map2[20][20];\n\t\tmemset(ghost, 0, sizeof(ghost));\n\t\tmemset(target, 0, sizeof(target));\n\t\tmemset(map2, -1, sizeof(map2));\n\n\t\tpos_count = 0;\n\t\tfor (int i = 0; i <= h; i++) {\n\n\t\t\tfgets(map[i], 20, stdin);\n\t\t\tif (i) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] != '#') {\n\t\t\t\t\t\t///printf(\"%d\\t\", map[i][j]);\n\t\t\t\t\t\tmymap[pos_count][0] = pos_count;\n\t\t\t\t\t\tif (map[i][j] >= 97 && map[i][j] <= 99) {\n\t\t\t\t\t\t\tghost[map[i][j] % 97] = pos_count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (map[i][j] >= 65 && map[i][j] <= 67)\n\t\t\t\t\t\t\ttarget[map[i][j] % 65] = pos_count;\n\t\t\t\t\t\tmap2[i][j] = pos_count;\n\t\t\t\t\t\tpos_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint pos_count2 = 0;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint degree = 1;\n\t\t\t\tif (map2[i][j] != -1) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint nx = i + dx[k];\n\t\t\t\t\t\tint ny = j + dy[k];\n\t\t\t\t\t\tif (map2[nx][ny] != -1) {\n\t\t\t\t\t\t\tint space_index = map2[nx][ny];\n\t\t\t\t\t\t\tmymap[pos_count2][degree++] = space_index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdeg[pos_count2++] = degree;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint size = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsize *= pos_count;\n\t\thash_table = new int[size];\n\t\tdist = new int[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\thash_table[i] = 0;\n\t\t\tdist[i] = -1;\n\t\t}\n\n\t\tbfs();\n\n\t\tdelete[] hash_table;\n\t\tdelete[] dist;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\n\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nbool same(const vector<int>& sx, const vector<int>& sy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == sx[j] && sy[i] == sy[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool is_swap(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 1;\n            }\n        }       \n    }\n    return 0;\n}\n\nusing ll = long long;\n\nll v2l(const pair<vector<int>, vector<int>>& v)\n{\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        res *= H * W;\n        res += v.first[i] + v.second[i] * W;\n    }\n    return res;\n}\n\npair<vector<int>, vector<int>> l2v(ll l)\n{\n    pair<vector<int>, vector<int>> v;\n    for (int i = 0; i < N; i++) {\n        int u = l % (H * W);\n        int x = u % W, y = u / W;\n        v.first.emplace_back(x);\n        v.second.emplace_back(y);\n        l /= H * W;\n    }\n    reverse(v.first.begin(), v.first.end());\n    reverse(v.second.begin(), v.second.end());\n    return v;\n}\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    priority_queue<pair<int, ll>, vector<pair<int, ll>>, greater<pair<int, ll>>> que;    \n    que.push(make_pair(0, v2l(make_pair(sx, sy))));\n\n    unordered_map<ll, int> d;\n    d[v2l(make_pair(sx, sy))] = 0;    \n    \n    while (!que.empty()) {\n        auto ff = que.top(); que.pop();\n        auto f = ff.second;\n        auto nf = l2v(f);\n        auto csx = nf.first, csy = nf.second;\n        \n        if (reach(csx, csy, gx, gy)) {\n            return d[f];\n        }\n\n        if (d[f] < ff.first) continue;\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (same(nsx, nsy) || is_swap(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            auto next = v2l(make_pair(nsx, nsy));\n            if (d.count(next) == 0) {                \n                d[next] = d[f] + 1;               \n                que.push(make_pair(d[next], next));\n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nshort memo[16][16][16][16][16][16];\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint mget(vector<pair<int, int>>&ps) {\n\n\treturn memo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].second][ps[3].second];\n}\nvoid mset(vector<pair<int, int>>&ps,const int value) {\n\n\tmemo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].second][ps[3].second]=value;\n}\nstruct aa {\n\tvector<pair<int, int>>coors;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tint W, H, N; cin >> W >> H >> N;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<pair<int, int>>s(3);\n\t\tvector<pair<int, int>>f(3);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse if (st[j] <= 'c' || st[j] >= 'a') {\n\t\t\t\t\tf[st[j] - 'a'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts[st[j] - 'A'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmset(s, 0);\n\t\tqueue<aa>que;\n\t\tque.push(s, 0);\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tauto from = atop.coors;\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nshort d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=(1e4);\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5) rep(j,5) rep(k,5){\n      \n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      int nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n      int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n      \n      if(!check(nay,nax)||!check(nby,nbx)||!check(ncy,ncx)) continue;\n      \n      if(!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n      if(!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n      if(!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n      \n      if(nay==nby&&nax==nbx) continue;\n      if(nay==ncy&&nax==ncx) continue;\n      if(nby==ncy&&nbx==ncx) continue;\n\n      if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\td[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\tq.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n      }\n      \n    }\n    \n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    set<char> memo;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    if(n<=1){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][0]=(char)i;\n\t  s[0][1]=char('A'+i-'a');\n\t  by=0, bx=0;\n\t}\n    }\n\n    if(n<=2){\n      for(int i='a';i<='z';i++)\n\tif(!memo.count((char)i)){\n\t  memo.insert((char)i);\n\t  s[0][2]=(char)i;\n\t  s[0][3]=char('A'+i-'a');\n\t  cy=0, cx=2;\n\t}\n      \n    }\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\nconstexpr int dx[5] = {-1, +0, +1, +0, +0};\nconstexpr int dy[5] = {+0, -1, +0, +1, +0};\n\nint W, H, N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nbool same(int x1, int y1, int x2, int y2)\n{\n    return (x1 == x2 && y1 == y2);\n}\n\nvector<int> v2l(const pair<vector<int>, vector<int>>& v)\n{\n    vector<int> p(N);    \n    for (int i = 0; i < N; i++) {\n        p[i] = v.first[i] + v.second[i] * W;  \n    }\n    return p;\n}\n\npair<vector<int>, vector<int>> l2v(const vector<int>& l)\n{\n    pair<vector<int>, vector<int>> v;\n    for (int i = 0; i < N; i++) {        \n        v.first.emplace_back(l[i] % W);\n        v.second.emplace_back(l[i] / W);\n    }\n    return v;\n}\n\nbool d[MAX_H][MAX_W][MAX_H][MAX_W][MAX_H][MAX_W];\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<vector<int>> que;\n    queue<int> qc;\n    \n    que.push(v2l(make_pair(sx, sy)));    \n    qc.push(0);\n    \n    memset(d, 0, sizeof(d));\n    d[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]] = 1;\n\n    while (!que.empty()) {\n        auto f = l2v(que.front()); que.pop();\n        int c = qc.front(); qc.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) return c;\n                \n        for (int i = 0; i < 5; i++) {            \n            int nx0 = csx[0] + dx[i], ny0 = csy[0] + dy[i];\n            if (field[ny0][nx0] == '#') continue;\n            for (int j = 0; j < 5; j++) {\n                int nx1 = csx[1] + dx[j], ny1 = csy[1] + dy[j];\n                if (field[csy[1]][csx[1]] == '#') {\n                    nx1 = csx[1]; ny1 = csy[1];\n                } else if (field[ny1][nx1] == '#') continue;\n\n                if (same(nx0, ny0, nx1, ny1)) continue;\n                if (same(nx0, ny0, csx[1], csy[1]) && same(csx[0], csy[0], nx1, ny1)) continue;                \n                \n                for (int k = 0; k < 5; k++) {\n                    int nx2 = csx[2] + dx[k], ny2 = csy[2] + dy[k];\n                    \n                    if (field[csy[2]][csx[2]] == '#') {\n                        nx2 = csx[2]; ny2 = csy[2];\n                    } else if (field[ny2][nx2] == '#') continue;\n\n                    if (same(nx0, ny0, nx2, ny2) || same(nx1, ny1, nx2, ny2)) continue;\n                    if (same(nx0, ny0, csx[2], csy[2]) && same(csx[0], csy[0], nx2, ny2)) continue;                \n                    if (same(nx1, ny1, csx[2], csy[2]) && same(csx[1], csy[1], nx2, ny2)) continue;                \n                    \n                    vector<int> nx = {nx0, nx1, nx2}, ny = {ny0, ny1, ny2}; \n                    if (!d[ny0][nx0][ny1][nx1][ny2][nx2]) {\n                        d[ny0][nx0][ny1][nx1][ny2][nx2] = 1;\n                        \n                        que.push(v2l(make_pair(nx, ny)));\n                        qc.push(c + 1);\n                    }\n                }\n            }\n        }      \n    }    \n    return 0;\n}\n\nint main()\n{\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        while (sx.size() < 3) {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (field[i][j] == '#') {\n                        sx.emplace_back(j);\n                        sy.emplace_back(i);\n                        gx.emplace_back(j);\n                        gy.emplace_back(i);\n                        goto Next;\n                    }\n                }\n            }\n            Next:;\n        }\n        N = 3;\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <map>\n#include <queue>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\n#define MAGIC_WEIGHT 1.3\nbool operator < (state_t const & a, state_t const & b) {\n    return MAGIC_WEIGHT * a.cost + a.dist > MAGIC_WEIGHT * b.cost + b.dist;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        assert (1 <= n and n <= 3);\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        array<point_t,3> start;\n        array<point_t,3> goal;\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        repeat_from (i,n,3) {\n            start[i] = start[0]; // fill with some non-wall cell\n            goal[i]  = start[0]; // use same one\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            queue<point_t> que; // bfs\n            que.push(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            while (not que.empty()) {\n                point_t p = que.front(); que.pop();\n                repeat (j,4) {\n                    auto q = p + dp[j];\n                    if (c[q.y][q.x] == '#') continue;\n                    if (dist[i][q.y][q.x] == 1000000007) {\n                        dist[i][q.y][q.x] = dist[i][p.y][p.x] + 1;\n                        que.push(q);\n                    }\n                }\n            }\n        }\n\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    if (n < 2 and j != 4) continue;\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        if (n < 3 and k != 4) continue;\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\nchar f[16][16];\nint fx,fy,N;\nint dx[] = {0, 0, -1, 1, 0};\nint dy[] = {0, -1, 0, 0, 1};\n\nclass Ghost\n{\npublic:\n\tint x[3],y[3],c;\n\tbool r;\n\t\n\tGhost(int* i, int* j, int c, bool r)\n\t:r(r),c(c)\n\t{\n\t\tfor(int k=0; k<3; k++)\n\t\t{\n\t\t\tx[k]=i[k];\n\t\t\ty[k]=j[k];\n\t\t\t\n\t\t}\n\t}\n};\n\nbool move(int x, int y, int p)\n{\n\tif(p>=N) return true;\n\tif(x<0||y<0||x>=fx||y>=fy) return false;\n\tif(f[x][y]=='#') return false;\n\t\n\treturn true;\n}\n\nbool crash(int* x, int* y, int* gx, int* gy, int p)\n{\n\tif(p<N) return false;\n\tfor(int i=0; i<p; i++)\n\tfor(int j=i+1; j<p; j++)\n\t{\n\t\tif(x[i]==x[j]&&y[i]==y[j]) return true;\n\t\tif(x[i]==gx[j]&&y[i]==gy[j]&&gx[i]==x[j]&&gy[i]==y[j]) return true;\n\t}\n\treturn false;\n}\n\nshort h[256][256][256][2];\n\nint main()\n{\t\n\twhile(scanf(\"%d%d%d\",&fx,&fy,&N), (fx||fy||N))\n\t{\n\t\tint sx[3]={0},sy[3]={0},gx[3]={0},gy[3]={0};\n\t\tmemset(h,0,sizeof(h));\n\t\t\t\n\t\tstring s;\n\t\t\n\t\tgetchar();\n\t\tfor(int i=0; i<fy; i++)\n\t\t{\n\t\t\tgetline(cin, s);\n\t\t\tfor(int j=0; j<fx; j++)\n\t\t\t{\n\t\t\t\tif(islower(s[j]))\n\t\t\t\t{\n\t\t\t\t\tsx[s[j]-'a']=j;\n\t\t\t\t\tsy[s[j]-'a']=i;\n\t\t\t\t}\n\t\t\t\tif(isupper(s[j]))\n\t\t\t\t{\n\t\t\t\t\tgx[s[j]-'A']=j;\n\t\t\t\t\tgy[s[j]-'A']=i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf[j][i]=s[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Ghost> q;\n\t\tq.push(Ghost(sx,sy,1,0));\n\t\tq.push(Ghost(gx,gy,1,1));\n\t\t\n\t\tint th[3];\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(sx[l]<<4)+sy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][0]=1;\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(gx[l]<<4)+gy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][1]=1;\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tGhost g=q.front(); q.pop();\n\t\t\t\n\t\t\tint th[3];\n\n\t\t\tfor(int l=0; l<3; l++)\n\t\t\t{\n\t\t\t\tth[l]=(g.x[l]<<4)+g.y[l];\n\t\t\t}\n\n\t\t\tif(h[th[0]][th[1]][th[2]][!g.r])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", g.c+h[th[0]][th[1]][th[2]][!g.r]-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint tx[3],ty[3];\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\ttx[i]=g.x[i];\n\t\t\t\tty[i]=g.y[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<5; i++)\n\t\t\t{\n\t\t\t\ttx[0]=g.x[0]+dx[i], ty[0]=g.y[0]+dy[i];\n\t\t\t\tif(!move(tx[0],ty[0],0))\n\t\t\t\t{\n\t\t\t\t\ttx[0]=g.x[0];\n\t\t\t\t\tty[0]=g.y[0];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<(N>1?5:1); j++)\n\t\t\t\t{\n\t\t\t\t\ttx[1]=g.x[1]+dx[j], ty[1]=g.y[1]+dy[j];\n\t\t\t\t\tif(N>=2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!move(tx[1],ty[1], 1) || (crash(tx,ty,g.x,g.y,2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[1]=g.x[1];\n\t\t\t\t\t\t\tty[1]=g.y[1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0; k<(N>2?5:1); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttx[2]=g.x[2]+dx[k], ty[2]=g.y[2]+dy[k];\n\t\t\t\t\t\tif(N>=3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!move(tx[2],ty[2], 2) || (crash(tx,ty,g.x,g.y,3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0; l<3; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tth[l]=(tx[l]<<4)+ty[l];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(h[th[0]][th[1]][th[2]][g.r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th[th[0]][th[1]][th[2]][g.r]=g.c;\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tq.push(Ghost(tx, ty, g.c+1,g.r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int W, H, N;\n    vector<string> F;\n\n    bool input() {\n        cin >> W >> H >> N;\n        if (W == 0 && H == 0 && N == 0) return false;\n        string s; getline(cin, s);\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) getline(cin, F[i]);\n        return true;\n    }\n    \n    struct Point {\n        int y, x;\n        Point() {}\n        Point(int y, int x) : y(y), x(x) {}\n    };\n    bool operator==(const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }\n    bool operator<(const Point& a, const Point& b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }\n    ostream& operator<<(ostream& os, const Point& a) { return os << \"Point(\" << a.x << \",\" << a.y << \")\"; }\n\n    array<Point, 3> start, goal;\n\n    void init() {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c = F[i][j];\n                if (islower(c)) {\n                    start[ c - 'a' ] = Point(i, j);\n                } else if (isupper(c)) {\n                    goal[ c - 'A' ] = Point(i, j);\n                }\n            }\n        }\n    }\n\n    struct State {\n        array<Point, 3> ps;\n        int t;\n        State() { }\n        State(const array<Point, 3>& ps, int t) : ps(ps), t(t) {}\n    };\n\n    const int dy[] = {-1, 0, 1, 0, 0},\n              dx[] = {0, 1, 0, -1, 0};\n\n    inline bool check(const State& prev, const State& next) {\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (next.ps[i] == next.ps[j]) return false;\n                if (prev.ps[i] == next.ps[j] && prev.ps[j] == next.ps[i]) return false;\n            }\n        }\n        return true;\n    }\n\n    inline int encode(const array<Point, 3>& ps) {\n        int r = 0;\n        for (int i = 0; i < N; i++) {\n            const Point& p = ps[i];\n            r += (p.y << (i * 8));\n            r += (p.x << (i * 8 + 4));\n        }\n        return r;\n    }\n\n    bitset<(1<<24) + 1> D;\n    void genNextState(const State& c, queue<State>& Q, State next, int index = 0 ) {\n        if (index == N) {\n            if (!check(c, next)) return;\n            int h = encode(next.ps);\n            if (D[h]) return;\n            D[h] = true;\n            Q.push(next);\n            return;\n        }\n        for (int i = 0; i < 5; i++) {\n            int ny = c.ps[index].y + dy[i];\n            int nx = c.ps[index].x + dx[i];\n            if (F[ny][nx] == '#') continue;\n            next.ps[index].y = ny;\n            next.ps[index].x = nx;\n            genNextState(c, Q, next, index + 1);\n        }\n    }\n\n    void solve() {\n        init();\n        D.reset();\n        queue<State> Q;\n        Q.push(State(start, 0));\n        D[encode(start)] = true;\n        while (!Q.empty()) {\n            State c = Q.front(); Q.pop();\n            if (c.ps == goal) {\n                cout << c.t << endl;\n                break;\n            }\n            State stub; stub.t = c.t + 1;\n            genNextState(c, Q, stub);\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[196][196][196];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nv[3];\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t}\n\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int8_t y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ int8_t(a.y + b.y), int8_t(a.x + b.x) };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { int8_t(y), int8_t(x) };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { int8_t(y), int8_t(x) };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ int8_t(h), 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ int8_t(h), 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        unordered_set<uint32_t> used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,0};\nconst int dy[8]={0,1,0,-1,0};\n\nconst int limit=1<<24;\nint dist[limit];\n\ninline int hstar(int n,int cmask,int tmask){\n\tint cy[3],cx[3],ty[3],tx[3];\n\tint ret=0;\n\trep(i,n){\n\t\tcx[i]=cmask&15;\n\t\tcmask>>=4;\n\t\tcy[i]=cmask&15;\n\t\tcmask>>=4;\n\n\t\ttx[i]=tmask&15;\n\t\ttmask>>=4;\n\t\tty[i]=tmask&15;\n\t\ttmask>>=4;\n\n\t\tchmax(ret,abs(cy[i]-ty[i])+abs(cx[i]-tx[i]));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint w,h,n;\n\t\n\twhile(cin >> w >> h >> n,n){\n\t\tint smask=0,tmask=0;\n\t\tstring board[16];\n\t\t\n\t\tcin.ignore();\n\t\trep(i,h) getline(cin,board[i]);\n\n\t\t// cout << w << \" \" << h << \" \" << n << endl;\n\t\t// rep(i,h) cout << board[i] << endl;\n\n\t\trep(i,h)rep(j,w)rep(k,3){\n\t\t\tif(board[i][j]==('a'+k)) smask|=((16*i+j)<<(8*k));\n\t\t\tif(board[i][j]==('A'+k)) tmask|=((16*i+j)<<(8*k));\n\t\t}\n\n\t\tfill(dist,dist+limit,limit);\n\t\tdist[smask]=0;\n\t\tusing state=tuple<int,int>;\n\t\tpriority_queue<state,vector<state>,greater<state>> q;\n\t\tq.push(state(0,smask));\n\n\t\twhile(!q.empty()){\n\t\t\tint cost,cmask;\n\t\t\ttie(cost,cmask)=q.top();q.pop();\n\n\t\t\tif(dist[tmask]!=limit) break;\n\n\t\t\tint cy[3],cx[3],tmp=cmask;\n\t\t\trep(i,n){\n\t\t\t\tcx[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t\tcy[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t}\n\n\t\t\tconst int all=pow<int>(5,n);\n\n\t\t\trep(mask,all){\n\t\t\t\tconst int didx[3]={mask%5,mask/5%5,mask/25};\n\t\t\t\tint ny[3],nx[3];\n\t\t\t\trep(i,n){\n\t\t\t\t\tny[i]=cy[i]+dy[didx[i]];\n\t\t\t\t\tnx[i]=cx[i]+dx[didx[i]];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n) if(board[ny[i]][nx[i]]=='#') ok=false;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==ny[j] && nx[i]==nx[j] ) ok=false;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==cy[j] && nx[i]==cx[j] && ny[j]==cy[i] && nx[j]==cx[i]) ok=false;\n\t\t\t\t\n\t\t\t\tif(ok==false) continue;\n\n\n\t\t\t\tint nmask=0;\n\t\t\t\trep(i,n) nmask|=(16*ny[i]+nx[i])<<(8*i);\n\n\t\t\t\tif(chmin(dist[nmask],dist[cmask]+1)) q.push(state(dist[nmask]+hstar(n,nmask,tmask),nmask));\t\t\n\t\t\t}\n\n\t\t}\n\t\tcout << dist[tmask] << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost += ev[p.p[i]][goal[i]];\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(35);\n      makeEv();\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost += ev[p.p[i]][goal[i]];\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(25);\n      makeEv();\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return a.dist > b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        unordered_set<uint32_t> used;\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used.insert(encode(start));\n            que.push(initial);\n        }\nint cnt = 0;\n        while (not que.empty()) {\ncnt ++;\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used.count(key)) continue;\n                        used.insert(key);\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][start[i].y][start[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n// cerr << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tshort v[3];\n\tdata(){}\n};\n\nshort dx[5]={0,1,-1,0,0};\nshort dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nint num[14][14];\nshort dp[150][150][150];\nint to[150][5];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.v[i]=num[sy[i]][sx[i]];\n\t\t}else{\n\t\t\tst.v[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.v[0]][st.v[1]][st.v[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.v[j]=to[d.v[j]][pi%5];\n\t\t\t\tif(nd.v[j]==-1){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.v[j]==nd.v[k] && d.v[k]==nd.v[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.v[j]==nd.v[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[nd.v[0]][nd.v[1]][nd.v[2]]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(nd.v[j]!=num[gy[j]][gx[j]])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.v[0]][d.v[1]][d.v[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.v[0]][nd.v[1]][nd.v[2]]=dp[d.v[0]][d.v[1]][d.v[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tint all=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==0){\n\t\t\t\t\tnum[i][j]=all++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(to,-1,sizeof(to));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==0){\n\t\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\t\tint nx=j+dx[k],ny=i+dy[k];\n\t\t\t\t\t\tif(nx<0 || nx>=w || ny<0 || ny>=h)to[num[i][j]][k]=-1;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(fie[ny][nx]==-1){\n\t\t\t\t\t\t\t\tto[num[i][j]][k]=-1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tto[num[i][j]][k]=num[ny][nx];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx2\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n  \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n  \n  \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n  \narray<short, 1 << 24> dist;\n  \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n      \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n      \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n  \n    int last_hash = last.hash();\n  \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                      \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n  \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< pair< int, int > > T;\n\nconst int vy[] = {0, 1, 0, -1, 0}, vx[] = {1, 0, -1, 0, 0};\n\nint tail;\nvector< pair< int, int > > vec[1000];\n\nint W, H, N;\nstring S[16];\nshort v[16 * 16 * 16 * 16 * 16 * 16];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W || S[y][x] == '#');\n}\n\nvoid CreateVector(int sz, vector< pair< int, int > > &vs)\n{\n  if(sz == 0) {\n    vec[tail++] = vs;\n    return;\n  }\n  for(int i = 0; i < 5; i++) {\n    int ny = vs[sz - 1].first + vy[i];\n    int nx = vs[sz - 1].second + vx[i];\n    if(isover(ny, nx)) continue;\n    vs[sz - 1].first += vy[i];\n    vs[sz - 1].second += vx[i];\n    CreateVector(sz - 1, vs);\n    vs[sz - 1].first -= vy[i];\n    vs[sz - 1].second -= vx[i];\n  }\n}\n\nint hashh(vector< pair< int, int > > &vs)\n{\n  int ret = 0;\n  for(int k = vs.size() - 1; k >= 0; k--) {\n    ret *= 16;\n    ret += vs[k].second;\n    ret *= 16;\n    ret += vs[k].first;\n  }\n  return (ret);\n}\n\nvector< pair< int, int > > hashd(int h)\n{\n  vector< pair< int, int > > vs(N);\n  int ret = 0;\n  for(auto &k : vs) {\n    vs[ret].first = h & 15;\n    h >>= 4;\n    vs[ret++].second = h & 15;\n    h >>= 4;\n  }\n  return (vs);\n}\n\nint main()\n{\n  while(cin >> W >> H >> N, W) {\n    vector< char > nums;\n    cin.ignore();\n\n    for(int i = 0; i < H; i++) {\n      getline(cin, S[i]);\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) nums.push_back(S[i][j]);\n      }\n    }\n\n    sort(begin(nums), end(nums));\n\n    vector< pair< int, int > > vs(N), ans(N);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), S[i][j]) - begin(nums);\n          vs[q] = {i, j};\n        } else if(isupper(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), tolower(S[i][j])) - begin(nums);\n          ans[q] = {i, j};\n        }\n      }\n    }\n\n\n    queue< int > que;\n    que.emplace(hashh(vs));\n    memset(v, -1, sizeof(v));\n    v[hashh(vs)] = 0;\n\n    while(!que.empty()) {\n      auto ss = que.front();\n      int cost = v[ss];\n      que.pop();\n      auto p = hashd(ss);\n      if(p == ans) {\n        cout << cost << endl;\n        break;\n      }\n\n      tail = 0;\n      CreateVector(N, p);\n      for(int z = 0; z < tail; z++) {\n        auto &beet = vec[z];\n        bool isok = true;\n        for(int i = 0; i < p.size(); i++) {\n          for(int j = 0; j < i; j++) {\n            isok &= beet[i] != p[j] || beet[j] != p[i];\n            isok &= beet[i] != beet[j];\n          }\n          if(!isok) break;\n        }\n        int hashed = hashh(beet);\n        if(isok && v[hashed] == -1) {\n          que.emplace(hashed);\n          v[hashed] = cost + 1;\n        }\n      }\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<map>\n#define MAX_W 16 + 5\n#define MAX_N 3 + 2\n#define INF 0x3f3f3f3f\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h, n;\nchar m[MAX_W][MAX_W];\nint d[MAX_N][MAX_W][MAX_W];\nint dir[MAX_N];\nmap<int, int>::iterator it;\nint x[] = {0, 1, -1, 0,  0}; //ä¸å/ä¸/ä¸/å³/å·¦\nint y[] = {0, 0,  0, 1, -1};\nint ct = 0;\n\nint hstar(int cur){\n\tint res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tint sx = (cur >> 4) & 0xf;\n\t\tint sy =  cur & 0xf;\n\t\tcur >>= 8;\n\t\tres = max(res, d[i][sx][sy]);\n\t}\n\treturn res;\n}\nint check(int cur, int *dir){\n\tint sxy[3], nxy[3], nxt = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tsxy[i] = (cur >> (i * 8)) & 0xff;\n\t\tint nx = ((sxy[i] >> 4) & 0xf) + x[dir[i]];\n\t\tint ny = (sxy[i] & 0xf) + y[dir[i]];\n\t\tnxy[i] = (nx << 4) | ny;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint nx = (nxy[i] >> 4) & 0xf;\n\t\tint ny = nxy[i] & 0xf;\n\t\tif(m[nx][ny] == '#') return 0; //hit the wall\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif((nxy[i] == nxy[j]) || (nxy[i] == sxy[j] && sxy[i] == nxy[j])) return 0; // overlap && switch\n\t\t}\n\t\tnxt |= (nxy[i] << (i * 8));\n\t}\n\treturn nxt;\n}\n// void show(int cur){\n\t// for(int i = 0; i < n; i++){\n\t\t// int sx = cur >> 4 & 0xf;\n\t\t// int sy = cur & 0xf;\n\t\t// cur >>= 8;\n\t\t// printf(\"%c : (%d, %d)\\n\", i + 'a', sx, sy);\n\t// }\n// }\nint solve(){\n\tmemset(d, 0x3f, sizeof(d));\n\t//BFS\n\tfor(int i = 0; i < n; i++){\n\t\tint sx, sy;\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tsx = j / w, sy = j % w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<P> que;\n\t\tque.push(make_pair(sx, sy));\n\t\td[i][sx][sy] = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor(int j = 1; j < 5; j++){\n\t\t\t\tint nx = p.first + x[j];\n\t\t\t\tint ny = p.second + y[j];\n\t\t\t\tif(m[nx][ny] != '#' && d[i][nx][ny] > d[i][p.first][p.second] + 1){\n\t\t\t\t\td[i][nx][ny] = d[i][p.first][p.second] + 1;\n\t\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = 0, end = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'a'){\n\t\t\t\tcur |= ((j / w) << (8 * i + 4));\n\t\t\t\tcur |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tend |= ((j / w) << (8 * i + 4));\n\t\t\t\tend |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tmap<int, int> mp;\n\tmp[cur] = 0;\n\tque.push(make_pair(hstar(cur), cur));\n\twhile(!que.empty()){\n\t\tcur = que.top().second; que.pop();\n\t\t\n\t\tif(cur == end) return mp[cur];\n\t\t\n\t\tct++;\n\t\t\n\t\tfor(int i = 0; i < 5; i++){\n\t\t    dir[0] = i;\n\t\t\tfor(int j = 0; j < (n < 2 ? 1 : 5); j++){\n\t\t\t\tdir[1] = j;\n\t\t\t\tfor(int k = 0; k < (n < 3 ? 1 : 5); k++){\n\t\t\t\t\tdir[2] = k;\n\t\t\t\t\tint nx = check(cur, dir);\n\t\t\t\t\t\n\t\t\t\t\tif(nx > 0){ //ç¢ºèªä¸ä¸æ­¥æ¯åæ³ç\n\t\t\t\t\t\tif(mp.find(nx) == mp.end() || mp[nx] > mp[cur] + 1){\n\t\t\t\t\t\t\tmp[nx] = mp[cur] + 1;\n\t\t\t\t\t\t\tque.push(make_pair(mp[nx] + hstar(nx), nx)); //d(v) + h*(v)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(scanf(\"%d %d %d\\n\", &w, &h, &n) != EOF && (w || h || n)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%[^\\n]%*c\", m[i]);\n\t\t}\n\t\tct = 0;\n\t\tcout << solve() << endl;\n\t\t//printf(\"ct = %d\\n\", ct);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<map>\n#define MAX_W 16 + 5\n#define MAX_N 3 + 2\n#define INF 0x3f3f3f3f\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h, n;\nchar m[MAX_W][MAX_W];\nint d[MAX_N][MAX_W][MAX_W];\nint x[] = {0, 1, -1, 0,  0}; //ä¸å/ä¸/ä¸/å³/å·¦\nint y[] = {0, 0,  0, 1, -1};\nint ct, limit, end;\nmap<int, int> mp;\n\nint hstar(int cur){\n\tint res = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tint sx = (cur >> 4) & 0xf;\n\t\tint sy =  cur & 0xf;\n\t\tcur >>= 8;\n\t\tres = max(res, d[i][sx][sy]);\n\t}\n\treturn res;\n}\nint check(int cur, int *dir){\n\tint sxy[3], nxy[3], nxt = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tsxy[i] = (cur >> (i * 8)) & 0xff;\n\t\tint nx = ((sxy[i] >> 4) & 0xf) + x[dir[i]];\n\t\tint ny = (sxy[i] & 0xf) + y[dir[i]];\n\t\tnxy[i] = (nx << 4) | ny;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint nx = (nxy[i] >> 4) & 0xf;\n\t\tint ny = nxy[i] & 0xf;\n\t\tif(m[nx][ny] == '#') return 0; //hit the wall\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif((nxy[i] == nxy[j]) || (nxy[i] == sxy[j] && sxy[i] == nxy[j])) return 0; // overlap && switch\n\t\t}\n\t\tnxt |= (nxy[i] << (i * 8));\n\t}\n\treturn nxt;\n}\n\nint dfs(int num, int cur){\n\tif(cur == end) return num;\n\tif(num + hstar(cur) > limit || (mp.find(cur) != mp.end() && mp[cur] <= num)) return INF;\n\t\n\tct++;\n\t\n\tmp[cur] = num;\n\t\n\tint dir[MAX_N];\n\tfor(int i = 0; i < 5; i++){\n\t\tdir[0] = i;\n\t\tfor(int j = 0; j < (n < 2 ? 1 : 5); j++){\n\t\t\tdir[1] = j;\n\t\t\tfor(int k = 0; k < (n < 3 ? 1 : 5); k++){\n\t\t\t\tdir[2] = k;\n\t\t\t\t\n\t\t\t\tint nx = check(cur, dir);\n\t\t\t\tif(nx > 0){\n\t\t\t\t\tif(dfs(num + 1, nx) < INF) return num;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\nint solve(){\n\tmemset(d, 0x3f, sizeof(d));\n\t//BFS\n\tfor(int i = 0; i < n; i++){\n\t\tint sx, sy;\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tsx = j / w, sy = j % w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<P> que;\n\t\tque.push(make_pair(sx, sy));\n\t\td[i][sx][sy] = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor(int j = 1; j < 5; j++){\n\t\t\t\tint nx = p.first + x[j];\n\t\t\t\tint ny = p.second + y[j];\n\t\t\t\tif(m[nx][ny] != '#' && d[i][nx][ny] > d[i][p.first][p.second] + 1){\n\t\t\t\t\td[i][nx][ny] = d[i][p.first][p.second] + 1;\n\t\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = 0;\n\tend = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < w * h; j++){\n\t\t\tif(m[j / w][j % w] == i + 'a'){\n\t\t\t\tcur |= ((j / w) << (8 * i + 4));\n\t\t\t\tcur |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t\tif(m[j / w][j % w] == i + 'A'){\n\t\t\t\tend |= ((j / w) << (8 * i + 4));\n\t\t\t\tend |= ((j % w) << (8 * i));\n\t\t\t}\n\t\t}\n\t}\n\tct = 0;\n\tfor(limit = hstar(cur);; limit++){\t\n\t\tmp.clear();\n\t\tif(dfs(0, cur) < INF){\n\t\t\treturn limit;\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(scanf(\"%d %d %d\\n\", &w, &h, &n) != EOF && (w || h || n)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%[^\\n]%*c\", m[i]);\n\t\t}\n\t\tct = 0;\n\t\tcout << solve() << endl;\n\t//\tprintf(\"ct = %d\\n\", ct);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#define INF 0x3f3f3f3f\n#define EPS 10e-5\n\ntypedef long long ll;\nconst int dx[]={-1,0,0,1,0},dy[]={0,1,-1,0,0};\nusing namespace std;\nint w,h,n,ter;\nchar mps[20][20];\npair<char,char> pos[3];\npair<char,char> tar[3];\nbool dp[1<<25];\nint ncs[1<<10][5];\nint nle[1<<10];\nconst int queS = 1<<22;\npair<int,int> aps[queS];\nint ans,en;\nint ecnt = 0,bcnt=0;\n\nvoid push(const pair<int,int>&a)\n{\n    aps[ecnt++] = a;\n    ecnt%=queS;\n}\n\nint solve(){\n    int hash = 0,ans=0;\n    bcnt = ecnt = 0;\n    int sa = 0;\n    for(int i=0;i<n;++i){\n        hash += pos[i].first<<(i*8+4);\n        hash += pos[i].second<<(i*8);\n        ans += tar[i].first<<(i*8+4);\n        ans += tar[i].second<<(i*8);\n    }\n    push(make_pair(hash,0));\n    while(bcnt!=ecnt){\n        pair<int,int> now = aps[bcnt++];\n        bcnt%=queS;\n\n        if(now.first==ans) {\n            sa = now.second;break;\n        }\n        if(dp[now.first]) continue;\n        dp[now.first] = true;\n        if(n==1){\n            int u = now.first&0xff;\n            for(int i = 0;i<nle[u];++i){\n                if(dp[ncs[u][i]]) continue;\n                push(make_pair(ncs[u][i],now.second+1));\n            }\n        }else if(n==2){\n            int u = now.first&0xff,v = (now.first>>8)&0xff;\n            for(int i=0;i<nle[u];++i)\n                for(int j=0;j<nle[v];++j){\n                    if(dp[ncs[u][i]+(ncs[v][j]<<8)]||ncs[u][i]==ncs[v][j]\n                            ||(ncs[u][i] == v&& ncs[v][j] == u)) continue;\n                    push(make_pair(ncs[u][i]|(ncs[v][j]<<8),now.second+1));\n                }\n        }else{\n            int u = now.first&0xff,v = (now.first>>8)&0xff,a = (now.first>>16)&0xff;\n            for(int i=0;i<nle[u];++i)\n                for(int j=0;j<nle[v];++j)\n                    for(int k=0;k<nle[a];++k){\n                        if(dp[ncs[u][i]+(ncs[v][j]<<8)+(ncs[a][k]<<16)]||\n                                ncs[u][i]==ncs[v][j]||ncs[u][i]==ncs[a][k]\n                                ||ncs[v][j]==ncs[a][k]\n                                ||(ncs[v][j]==u&&v==ncs[u][i])\n                                ||(a==ncs[u][i]&&u==ncs[a][k])\n                                ||(ncs[v][j]==a&&v==ncs[a][k])) continue;\n                        push(make_pair(ncs[u][i]|(ncs[v][j]<<8)|(ncs[a][k]<<16),now.second+1));\n                    }\n        }\n    }\n    return sa;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    while(~scanf(\"%d%d%d\\n\",&w,&h,&n)){\n        if(w==0&&h==0&&n==0) break;\n        memset(dp,0,sizeof(dp));\n        memset(pos,0,sizeof(pos));\n        memset(tar,0,sizeof(tar));\n        memset(nle,0,sizeof(nle));\n\n        for(int i=0;i<h;++i)\n        {\n            for(int j=0;j<w;++j)\n            {\n                scanf(\"%c\",mps[i]+j);\n                if(mps[i][j]!='#'&&mps[i][j]!=' '){\n                    if(islower(mps[i][j])){\n                        pos[mps[i][j]-'a'].first = i;\n                        pos[mps[i][j]-'a'].second = j;\n                    }else{\n                        tar[mps[i][j]-'A'].first = i;\n                        tar[mps[i][j]-'A'].second = j;\n                        mps[i][j] = ' ';\n                    }\n                }\n            }\n            getchar();\n        }\n\n        for(int i=1;i<h;++i){\n            for(int j=1;j<w;++j){\n                if(mps[i][j]!='#'){\n                    for(int k=0;k<4;++k){\n                        if(mps[i+dy[k]][j+dx[k]]!='#'){\n                            ncs[(i<<4)+j][nle[(i<<4)+j]++]\n                                    = (((i+dy[k])<<4)+dx[k]+j);\n                        }\n                    }\n                    ncs[(i<<4)+j][nle[(i<<4)+j]++] = (i<<4)+j;\n                }\n            }\n        }\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct state{\n\tint x[3], y[3];\n\tstate(){}\n\tstate(int a, int b, int c, int d, int e, int f){\n\t\tx[0] = a, y[0] = b, x[1] = c, y[1] = d, x[2] = e, y[2] = f;\n\t}\n};\n\nint w, h, n;\nchar map[20][20];\nint sx[3], sy[3];\nint gx[3], gy[3];\nint dist[14][15][14][15][14][15];\nconst int dx[] = {1, 0, -1, 0, 0}, dy[] = {0, -1, 0, 1, 0};\n\nvoid bfs()\n{\n\tfor(int ax = 0; ax < 14; ax++){\n\t\tfor(int ay = 0; ay < 15; ay++){\n\t\t\tfor(int bx = 0; bx < 14; bx++){\n\t\t\t\tfor(int by = 0; by < 15; by++){\n\t\t\t\t\tfor(int cx = 0; cx < 14; cx++){\n\t\t\t\t\t\tfor(int cy = 0; cy < 15; cy++){\n\t\t\t\t\t\t\tdist[ax][ay][bx][by][cx][cy] = inf;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdist[sx[0]][sy[0]][sx[1]][sy[1]][sx[2]][sy[2]] = 0;\n\t\n\tqueue<state> Q;\n\tQ.push( state(sx[0], sy[0], sx[1], sy[1], sx[2], sy[2]) );\n\t\n\t\n\tstate st;\n\tint x[3], y[3], nx[3], ny[3];\n\twhile(Q.size()){\n\t\tst = Q.front(); Q.pop();\n\t\tfor(int i = 0; i < 3; i++) x[i] = st.x[i], y[i] = st.y[i];\n\t\t\n\t\t/*for(int i = 0; i < 3; i++) cout << x[i] << \" \" << y[i] << \" \";\n\t\tcout << endl;*/\n\t\t\n\t\tfor(int ad = 0; ad < 5; ad++){\n\t\t\tnx[0] = x[0] + dx[ad], ny[0] = y[0] + dy[ad];\n\t\t\tif(y[0] < 14 && (nx[0] < 0 || nx[0] >= w || ny[0] < 0 || ny[0] >= h)) continue;\n\t\t\tif(map[nx[0]][ny[0]] == '#') continue;\n\t\t\t\n\t\t\tfor(int bd = 0; bd < 5; bd++){\n\t\t\t\tif(y[1] == 14 && bd < 4) continue;\n\t\t\t\tnx[1] = x[1] + dx[bd], ny[1] = y[1] + dy[bd];\n\t\t\t\tif(y[1] < 14 && (nx[1] < 0 || nx[1] >= w || ny[1] < 0 || ny[1] >= h)) continue;\n\t\t\t\tif(map[nx[1]][ny[1]] == '#') continue;\n\t\t\t\t\n\t\t\t\tfor(int cd = 0; cd < 5; cd++){\n\t\t\t\t\tif(y[2] == 14 && cd < 4) continue;\n\t\t\t\t\tnx[2] = x[2] + dx[cd], ny[2] = y[2] + dy[cd];\n\t\t\t\t\tif(y[2] < 14 && (nx[2] < 0 || nx[2] >= w || ny[2] < 0 || ny[2] >= h)) continue;\n\t\t\t\t\tif(map[nx[2]][ny[2]] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(nx[0] == nx[1] && ny[0] == ny[1] && ny[1] != 14) continue;\n\t\t\t\t\tif(nx[1] == nx[2] && ny[1] == ny[2] && ny[2] != 14) continue;\n\t\t\t\t\tif(nx[2] == nx[0] && ny[2] == ny[0] && ny[0] != 14) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(nx[0] == x[1] && ny[0] == y[1] && x[0] == nx[1] && y[0] == ny[1]) continue;\n\t\t\t\t\tif(nx[1] == x[2] && ny[1] == y[2] && x[1] == nx[2] && y[1] == ny[2]) continue;\n\t\t\t\t\tif(nx[2] == x[0] && ny[2] == y[0] && x[2] == nx[0] && y[2] == ny[0]) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(dist[nx[0]][ny[0]][nx[1]][ny[1]][nx[2]][ny[2]] < inf) continue;\n\t\t\t\t\tdist[nx[0]][ny[0]][nx[1]][ny[1]][nx[2]][ny[2]] = dist[x[0]][y[0]][x[1]][y[1]][x[2]][y[2]] + 1;\n\t\t\t\t\tQ.push( state(nx[0], ny[0], nx[1], ny[1], nx[2], ny[2]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> w >> h >> n;\n\t\tif(w == 0 && h == 0 && n == 0) break;\n\t\tcin.ignore();\n\t\t\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tsx[i] = gx[i] = 13;\n\t\t\tsy[i] = gy[i] = 14;\n\t\t}\n\t\t\n\t\tchar c; string s;\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tgetline(cin, s);\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tc = s[x];\n\t\t\t\tif(x == 0 || x == w-1 || y == 0 || y == h-1) continue;\n\t\t\t\tif(c >= 'a' && c <= 'c'){\n\t\t\t\t\tsx[c - 'a'] = x-1, sy[c - 'a'] = y-1;\n\t\t\t\t\tc = ' ';\n\t\t\t\t}\n\t\t\t\tif(c >= 'A' && c <= 'C'){\n\t\t\t\t\tgx[c - 'A'] = x-1, gy[c - 'A'] = y-1;\n\t\t\t\t\tc = ' ';\n\t\t\t\t}\n\t\t\t\tmap[x-1][y-1] = c;\n\t\t\t}\n\t\t}\n\t\tw -= 2, h -= 2;\n\t\t\n\t\tbfs();\n\t\tcout << dist[gx[0]][gy[0]][gx[1]][gy[1]][gx[2]][gy[2]] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 28;\nconst ll mod=1000000007LL;\nconst int dx[]={1,0,-1,0,0};\nconst int dy[]={0,1,0,-1,0};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 16, M = 150;\nint w, h, n; \nvector<string> field;\nint memo[M][M][M];\nint p2i[N][N];\nint i2x[M], i2y[M];\n\nusing State = tuple<int, int, int>;\nusing Elem  = tuple<int, State>;\n\ninline bool check(State pre, State cur){\n    int pp[3], cp[3];\n    tie(pp[0], pp[1], pp[2]) = pre;\n    tie(cp[0], cp[1], cp[2]) = cur;\n\n    // exchange\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(pp[i] == cp[j] and pp[j] == cp[i]){\n            return false;\n        }\n    }\n\n    // overlap\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(cp[i] == cp[j]){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(void){\n    for(;cin >> w >> h >> n, w;){\n        field = vector<string>(h);\n        cin.ignore();\n        for(auto & e : field) getline(cin, e);\n\n        i2x[0] = 0, i2y[0] = 0;\n        {\n            int cnt = 1;\n            rep(y, h){\n                rep(x, w){\n                    if(field[y][x] != '#'){\n                        p2i[y][x] = cnt;\n                        i2x[cnt] = x;\n                        i2y[cnt] = y;\n                        cnt++;\n                    }\n                    else p2i[y][x] = -1;\n                }\n            }\n        }\n        p2i[0][0] = 0;\n\n        State s = State(0, 0, 0), z = State(0, 0, 0);\n        rep(y, h){\n            rep(x, w){\n                int as, bs, cs, az, bz, cz;\n                tie(as, bs, cs) = s;\n                tie(az, bz, cz) = z;\n\n                switch(field[y][x]){\n                    case 'a': { as = p2i[y][x]; break; }\n                    case 'b': { bs = p2i[y][x]; break; }\n                    case 'c': { cs = p2i[y][x]; break; }\n                    case 'A': { az = p2i[y][x]; break; }\n                    case 'B': { bz = p2i[y][x]; break; }\n                    case 'C': { cz = p2i[y][x]; break; }\n                }\n                s = State(as, bs, cs);\n                z = State(az, bz, cz);\n            }\n        }\n\n        rep(i, M) rep(j, M) rep(k, M) memo[i][j][k] = inf;\n\n        queue<Elem> q;\n        q.push(Elem(0, s));\n\n        while(q.size()){\n            int cost; State cur;\n            tie(cost, cur) = q.front(); q.pop();\n            int ap, bp, cp; tie(ap, bp, cp) = cur;\n\n            int & ret = memo[ap][bp][cp];\n            if(ret != inf) continue;\n            ret = cost;\n\n            rep(i, 5){\n                int ax = i2x[ap] + dx[i], ay = i2y[ap] + dy[i];\n                if(p2i[ay][ax] == -1) continue;\n\n                rep(j, 5){\n                    if(n <= 1 and j <= 3) continue;\n\n                    int bx = i2x[bp] + dx[j], by = i2y[bp] + dy[j];\n                    if(p2i[by][bx] == -1) continue;\n\n                    rep(k, 5){\n                        if(n <= 2 and k <= 3) continue;\n\n                        int cx = i2x[cp] + dx[k], cy = i2y[cp] + dy[k];\n                        if(p2i[cy][cx] == -1) continue;\n\n                        State next = State(p2i[ay][ax], p2i[by][bx], p2i[cy][cx]);\n                        if(not check(cur, next)) continue;\n                        q.push(Elem(cost + 1, next));\n                    }\n                }\n            }\n        }\n\n        int az, bz, cz; tie(az, bz, cz) = z;\n        cout << memo[az][bz][cz] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h;\n            ret += y[i];\n            ret *= w;\n            ret += x[i];\n        }\n        return ret;\n    }\n};\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        vector<string> grid(h);\n        vector<int> sy(n), sx(n), gy(n), gx(n);\n        for(int i=0; i<h; ++i){\n            getline(cin, grid[i]);\n            for(int j=0; j<w; ++j){\n                int c = grid[i][j];\n                if('a' <= c && c <= 'c'){\n                    sy[c-'a'] = i;\n                    sx[c-'a'] = j;\n                }else if('A' <= c && c <= 'C'){\n                    gy[c-'A'] = i;\n                    gx[c-'A'] = j;\n                }\n            }\n        }\n\n        int size = 1 << n;\n        for(int i=0; i<n; ++i)\n            size *= h * w;\n\n        vector<vector<bool> > check(2, vector<bool>(size, false));\n        check[0][Data(sy, sx, 0).toInt()] = true;\n        check[1][Data(gy, gx, 0).toInt()] = true;\n        vector<deque<Data> > dq(2);\n        dq[0].push_back(Data(sy, sx, 0));\n        dq[1].push_back(Data(gy, gx, 0));\n        int turn = 0;\n        int m = 1;\n        int ret = 1;\n        for(;;){\n            if(m == 0){\n                ++ ret;\n                turn ^= 1;\n                m = dq[turn].size();\n            }\n\n            Data d = dq[turn].front();\n            dq[turn].pop_front();\n            -- m;\n            if(check[turn^1][d.toInt()]){\n                cout << ret << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                if(d.bs[i])\n                    continue;\n                d.bs[i] = true;\n                for(int j=0; j<4; ++j){\n                    d.y[i] += dy[j];\n                    d.x[i] += dx[j];\n\n                    bool ok = true;\n                    if(grid[d.y[i]][d.x[i]] == '#')\n                        ok = false;\n                    for(int k=0; k<n; ++k){\n                        if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                            ok = false;\n                    }\n\n                    if(ok){\n                        int a = d.toInt();\n                        if(!check[turn][a]){\n                            dq[turn].push_front(d);\n                            ++ m;\n                            check[turn][a] = true;\n                        }\n                    }\n\n                    d.y[i] -= dy[j];\n                    d.x[i] -= dx[j];\n                }\n                d.bs[i] = false;\n            }\n\n            d.bs = 0;\n            int a = d.toInt();\n            if(!check[turn][a]){\n                dq[turn].push_back(d);\n                check[turn][a] = true;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,n;\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\nstring mp[20];\n\nstruct dat{\n  int y1,x1;\n  int y2,x2;\n  int y3,x3;\n};\n\n\nint D[14][14][15][14][14][15];\nqueue<dat> Q;\nvoid DD(dat &a,int b){D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1] = b;}\nint DD(const dat &a){return D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1];}\n\nbool check(const dat &a){\n  if(mp[a.y1][a.x1]=='#') return 0;\n  if(n>=2&&mp[a.y2][a.x2]=='#') return 0;\n  if(n>=3&&mp[a.y3][a.x3]=='#') return 0;\n  return DD(a)==-1;\n}\n\nvoid update(const dat &a){\n  int cost = DD(a);\n\n  for(int i=0;i<5;i++){\n    int ny1 = a.y1+dy[i], nx1 = a.x1+dx[i];\n    for(int j=0;j<5;j++){\n      int ny2 = a.y2+dy[j], nx2 = a.x2+dx[j];\n      if(n<=1) ny2 = 15,nx2 = 14;\n      for(int k=0;k<5;k++){\n\tint ny3 = a.y3+dy[k], nx3 = a.x3+dx[k];\n\tif(n<=2) ny3 = 14,nx3 = 15;\n\n\tdat nt = (dat){ny1,nx1,ny2,nx2,ny3,nx3};\n\tif(!check(nt))continue;\n\t\n\tif((ny1==ny2&&nx1==nx2) ||(ny2==ny3&&nx2==nx3) ||(ny3==ny1&&nx3==nx1))continue;//same pos\n\tif(((a.y1==ny2&&a.x1==nx2) && (a.y2==ny1&&a.x2==nx1)) || // swap positoin\n\t   ((a.y2==ny3&&a.x2==nx3) && (a.y3==ny2&&a.x3==nx2)) ||\n\t   ((a.y3==ny1&&a.x3==nx1) && (a.y1==ny3&&a.x1==nx3)) )continue;\n\t\n\tQ.push(nt);\n\tDD(nt,cost+1);\n      }\n    }\n  }\n}\n\nbool goal(const dat &s,const dat &t){\n  char &a = mp[s.y1][s.x1];\n  char &b = mp[s.y2][s.x2];\n  char &c = mp[s.y3][s.x3];\n  char &A = mp[t.y1][t.x1];\n  char &B = mp[t.y2][t.x2];\n  char &C = mp[t.y3][t.x3];\n  return toupper(a)==A&&(n<=1||toupper(b)==B)&&(n<=2||toupper(c)==C);\n}\n\nint bfs(dat &start){\n  memset(D,-1,sizeof(D));\n  while(!Q.empty())Q.pop();\n  Q.push(start);\n  DD(start,0);\n  \n  while(!Q.empty()){\n    dat t = Q.front();Q.pop();\n    if(goal(start,t)) return DD(t);\n    update(t);\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>w>>h>>n;\n  if(!w&&!h&&!n)break;\n  cin.ignore();\n  for(int i=0;i<h;i++)getline(cin,mp[i]),mp[i]+='#';\n  \n  dat start = (dat){15,15,15,14,14,15};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!islower(mp[i][j]))continue;\n      if(start.y1==15) start.y1=i,start.x1=j;\n      else if(start.y2==15) start.y2=i,start.x2=j;\n      else start.y3=i,start.x3=j;\n    }\n  cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        unordered_set<uint32_t> used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tshort x[3],y[3];\n\tshort v;\n\tdata(){}\n};\n\nshort dx[5]={0,1,-1,0,0};\nshort dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nint dp[196][196][14];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tst.v=0;\n\tmemset(dp,0,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]]=1<<st.x[2];\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tdata nd=d;\n\t\tnd.v=d.v+1;\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\t\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]=d.x[j]+dx[pi%5];\n\t\t\t\tnd.y[j]=d.y[j]+dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.y[2]]>>nd.x[2] & 1)){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn d.v+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.y[2]]|=1<<nd.x[2];\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(cost >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t\twhile(!q.empty()) q.pop();\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC target \"avx\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            // c\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            h += 1;\n            if (n == 1) {\n                // b\n                c.push_back(w);\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h+1, 1 };\n                h += 1;\n            }\n            c.push_back(w);\n            h += 1;\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\twhile(!q.empty()) q.pop();\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nstruct node {\n    int ah, aw, bh, bw, ch, cw;\n    node(int _ah, int _aw, int _bh, int _bw, int _ch, int _cw) {\n        ah = _ah;\n        aw = _aw;\n        bh = _bh;\n        bw = _bw;\n        ch = _ch;\n        cw = _cw;\n    }\n    node() {\n        ah = aw = bh = bw = ch = cw = 0;\n    }\n};\nint H, W, N;\nint dp[14][14][14][14][14][14];\nint dh[5] = {0, 1, -1, 0, 0};\nint dw[5] = {0, 0, 0, 1, -1};\nstring field[14];\nstring dust;\nvoid solve() {\n    H -= 2;\n    W -= 2;\n    //cerr << H << \" \" << W << \" \" << N << endl;\n    getline(cin, dust);\n    getline(cin, dust);\n    for(int h = 0; h < H; h++) {\n        getline(cin, field[h]);\n        string tmp = field[h].substr(1, W);\n        field[h] = tmp;\n        //field[h] = field[h].substr(1, W);\n        //cerr << h << \" \" << field[h] << endl;\n    }\n    getline(cin, dust);\n    node s;\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if(field[h][w] == 'a') {\n                s.ah = h;\n                s.aw = w;\n            }\n            if(field[h][w] == 'b') {\n                s.bh = h;\n                s.bw = w;\n            }\n            if(field[h][w] == 'c') {\n                s.ch = h;\n                s.cw = w;\n            }\n        }\n    }\n    queue<node> que;\n    que.push(s);\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            for(int k = 0; k < H; k++) {\n                for(int l = 0; l < W; l++) {\n                    for(int a = 0; a < H; a++) {\n                        for(int b = 0; b < W; b++) {\n                            dp[h][w][k][l][a][b] = 1e9;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    dp[s.ah][s.aw][s.bh][s.bw][s.ch][s.cw] = 0;\n    while(!que.empty()) {\n        node now = que.front();\n        int cost = dp[now.ah][now.aw][now.bh][now.bw][now.ch][now.cw];\n        //cerr << now.ah << \" \" << now.aw << \" \" << now.bh << \" \" << now.bw << \" \" << now.ch << \" \" << now.cw << \" \" << cost << endl;\n        if(field[now.ah][now.aw] == 'A') {\n            if(N <= 1 or field[now.bh][now.bw] == 'B') {\n                if(N <= 2 or field[now.ch][now.cw] == 'C') {\n                    cout << cost << endl;\n                    break;\n                }\n            }\n        }\n        que.pop();\n        for(int ka = 0; ka < 5; ka++) {\n            int newah = now.ah + dh[ka];\n            int newaw = now.aw + dw[ka];\n            if(newah < 0 or newah >= H) continue;\n            if(newaw < 0 or newaw >= W) continue;\n            if(field[newah][newaw] == '#') continue;\n            for(int kb = 0; kb < 5; kb++) {\n                if(N <= 1 and kb >= 1) break;\n                int newbh = now.bh + dh[kb];\n                int newbw = now.bw + dw[kb];\n                if(newbh < 0 or newbh >= H) continue;\n                if(newbw < 0 or newbw >= W) continue;\n                if(N >= 2) {\n                    if(newah == newbh and newaw == newbw) continue;\n                    if(newah == now.bh and newaw == now.bw and newbh == now.ah and newbw == now.aw) continue;\n                    if(field[newbh][newbw] == '#') continue;\n                }\n                for(int kc = 0; kc < 5; kc++) {\n                    if(N <= 2 and kc >= 1) break;\n                    int newch = now.ch + dh[kc];\n                    int newcw = now.cw + dw[kc];\n                    if(newch < 0 or newch >= H) continue;\n                    if(newcw < 0 or newcw >= W) continue;\n                    if(N >= 3) {\n                        if(newah == newch and newaw == newcw) continue;\n                        if(newah == now.ch and newaw == now.cw and newch == now.ah and newcw == now.aw) continue;\n                        if(newbh == newch and newbw == newcw) continue;\n                        if(newbh == now.ch and newbw == now.cw and newch == now.bh and newcw == now.bw) continue;\n                        if(field[newch][newcw] == '#') continue;\n                    }\n                    if(chmin(dp[newah][newaw][newbh][newbw][newch][newcw], dp[now.ah][now.aw][now.bh][now.bw][now.ch][now.cw] + 1)) {\n                        node to(newah, newaw, newbh, newbw, newch, newcw);\n                        que.push(to);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H >> N) {\n        if(H == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d > s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\nbool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      if(dist[make(s.p)] < s.d) continue;\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, dist, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:\n\t\twhile(!q.empty()) q.pop();\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\n\nint toInt(vector<int>& y, vector<int>& x, bitset<3> bs){\n    int ret = bs.to_ulong();\n    for(int i=0; i<n; ++i){\n        ret *= h;\n        ret += y[i];\n        ret *= w;\n        ret += x[i];\n    }\n    return ret;\n}\n\nvoid fromInt(int a, vector<int>& y, vector<int>& x, bitset<3>& bs){\n    for(int i=n-1; i>=0; --i){\n        x[i] = a % w;\n        a /= w;\n        y[i] = a % h;\n        a /= h;\n    }\n    bs = a;\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        vector<string> grid(h);\n        vector<int> sy(n), sx(n), gy(n), gx(n);\n        for(int i=0; i<h; ++i){\n            getline(cin, grid[i]);\n            for(int j=0; j<w; ++j){\n                int c = grid[i][j];\n                if('a' <= c && c <= 'c'){\n                    sy[c-'a'] = i;\n                    sx[c-'a'] = j;\n                }else if('A' <= c && c <= 'C'){\n                    gy[c-'A'] = i;\n                    gx[c-'A'] = j;\n                }\n            }\n        }\n\n        int size = 1 << n;\n        for(int i=0; i<n; ++i)\n            size *= h * w;\n\n        vector<bool> check(size, false);\n        check[toInt(sy, sx, 0)] = true;\n        deque<int> dq;\n        dq.push_back(toInt(sy, sx, 0));\n        int m = 1;\n        int ret = 1;\n        for(;;){\n            if(m == 0){\n                ++ ret;\n                m = dq.size();\n            }\n\n            vector<int> y(n), x(n);\n            bitset<3> bs;\n            fromInt(dq.front(), y, x, bs);\n            dq.pop_front();\n            -- m;\n            if(y == gy && x == gx){\n                cout << ret << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                if(bs[i])\n                    continue;\n                bs[i] = true;\n                for(int j=0; j<4; ++j){\n                    y[i] += dy[j];\n                    x[i] += dx[j];\n\n                    bool ok = true;\n                    if(grid[y[i]][x[i]] == '#')\n                        ok = false;\n                    for(int k=0; k<n; ++k){\n                        if(k != i && y[k] == y[i] && x[k] == x[i])\n                            ok = false;\n                    }\n\n                    if(ok){\n                        int a = toInt(y, x, bs);\n                        if(!check[a]){\n                            dq.push_front(a);\n                            ++ m;\n                            check[a] = true;\n                        }\n                    }\n\n                    y[i] -= dy[j];\n                    x[i] -= dx[j];\n                }\n                bs[i] = false;\n            }\n\n            int a = toInt(y, x, 0);\n            if(!check[a]){\n                dq.push_back(a);\n                check[a] = true;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\t//if(q.size() > 100000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint tm0;\n\nbool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = (i + 8) % 24;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = (v >> j % 24) & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j % 24 & 255) &&\n\t\t\t\tp2 == (u >> i % 24 & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tint dif[5] = {0, -1, 1, -16, 16};\n\n\tqueue<int> q;\n\tq.push(start);\n\tq.push(-1);\n\tint tm = tm0 + 1;\n\tvis[start] = tm;\n\twhile(1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u < 0){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tm = solve(start, goal);\n\t\tprintf(\"%d\\n\", tm - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    int SR_LOOP = 1;\n    REP(i, N) SR_LOOP *= 5;\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, SR_LOOP){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, dist, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[16][16][16][16][16][16];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 16; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j) {\n\t\t\t\tfor (int k = 0; k < 16; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 16; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 16; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 16; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx])aok = false;\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))aok = false;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nvoid solve(int w,int h,int n){\n    vector<int >v[200];\n    int cur=0;\n    vector<vector<int>>id(h,vector<int>(w));\n    string s[h];\n    rep(i,h){\n        getline(cin,s[i]);\n        rep(j,w){\n            if(s[i][j]!='#')id[i][j]=cur++;\n        }\n    }\n    rep(i,h)rep(j,w-1){\n        if(s[i][j]!='#'&&s[i][j+1]!='#'){\n            v[id[i][j]].push_back(id[i][j+1]);\n            v[id[i][j+1]].push_back(id[i][j]);\n        }\n    }\n    rep(i,h-1)rep(j,w){\n        if(s[i][j]!='#'&&s[i+1][j]!='#'){\n            v[id[i][j]].push_back(id[i+1][j]);\n            v[id[i+1][j]].push_back(id[i][j]);\n        }\n    }\n    rep(i,cur)v[i].push_back(i);\n    int m=1;\n    int st=0,gl=0;\n    rep(i,n){\n        m*=cur;\n        rep(j,h)rep(k,w){\n            if(s[j][k]=='a'+i)st=st*cur+id[j][k];\n            if(s[j][k]=='A'+i)gl=gl*cur+id[j][k];\n        }\n    }\n    vector<int> dist(m,inf);\n    queue<int> que;\n    que.push(st);\n    dist[st]=0;\n    vector<int> pos(n),nxt(n);\n    while(que.size()){\n        int p=que.front();que.pop();\n        int pp=p;\n        rep(i,n){\n            pos[n-i-1]=pp%cur;\n            pp/=cur;\n        }\n        if(n==1){\n            for(auto to : v[pos[0]]){\n                if(dist[to]>dist[p]+1){\n                    dist[to]=dist[p]+1;\n                    que.push(to);\n                }\n            }\n        }\n        else if(n==2){\n            for(auto to0 : v[pos[0]])for(auto to1 : v[pos[1]]){\n                if(to0==to1)continue;\n                if(to0==pos[1]&&to1==pos[0])continue;\n                int nxt=to0*cur+to1;\n                if(dist[nxt]>dist[p]+1){\n                    dist[nxt]=dist[p]+1;\n                    que.push(nxt);\n                }\n            }\n        }\n        else {\n            for(auto to0 : v[pos[0]])for(auto to1 : v[pos[1]])for(auto to2 : v[pos[2]]){\n                if(to0==to1||to1==to2||to2==to0)continue;\n                if(to0==pos[1]&&to1==pos[0])continue;\n                if(to0==pos[2]&&to2==pos[0])continue;\n                if(to1==pos[2]&&to2==pos[1])continue;\n                int nxt=to0*cur*cur+to1*cur+to2;\n                if(dist[nxt]>dist[p]+1){\n                    dist[nxt]=dist[p]+1;\n                    que.push(nxt);\n                }\n            }\n        }\n    }\n    cout<<dist[gl]<<endl;\n}\n\nint main(){\n    int w,h,n;\n    while(1){\n        scanf(\"%d%d%d \",&w,&h,&n);\n        if(w==0)break;\n        solve(w,h,n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 16\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nbool d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  memset(d,0,sizeof(d));\n  \n  d[ay][ax][by][bx][cy][cx]=1;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(n==1&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==2&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==3&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(n==1) nby=0, nbx=0;\n\tif(n>=2&&!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n\t  if(n<=2) ncy=0, ncx=0;\n      \t  if(n==3&&!check(ncy,ncx)) continue;\n      \n\t  if(n>=2&&!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(n==3&&!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(n==3&&!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(n>=2&&nay==nby&&nax==nbx) continue;\n\t  if(n==3&&nay==ncy&&nax==ncx) continue;\n\t  if(n==3&&nby==ncy&&nbx==ncx) continue;\n\n\t  if(!d[nay][nax][nby][nbx][ncy][ncx]){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=1;\n\t    q.push(dat{t.cost+1,nay,nax,nby,nbx,ncy,ncx});\n\t  }\n\t  \n\t}\n      }\n    }\n  }\n  \n  while(!q.empty()) q.pop();\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n\n    ay=ax=by=bx=cy=cx=0;\n    \n    getline(cin,s[0]);\n    rep(i,h){\n      getline(cin,s[i]);\n      rep(j,w){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\n\nbool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = (i + 8) % 24;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = (v >> j % 24) & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j % 24 & 255) &&\n\t\t\t\tp2 == (u >> i % 24 & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint tm0 = 0;\n\tint w, h, n;\n\tint dif[5] = {0, -1, 1, -16, 16};\n\twhile(scanf(\"%d%d%d \", &w, &h, &n), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<int> q;\n\t\tq.push(start);\n\t\tq.push(-1);\n\t\tint tm = tm0 + 1;\n\t\tvis[start] = tm;\n\t\twhile(q.size() > 1){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tif(u < 0){\n\t\t\t\tq.push(-1);\n\t\t\t\t++tm;\n\t\t\t}\n\t\t\telse if(u == goal){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\t\tif(check(u, v)){\n\t\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", vis[goal] - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nint cost[3][16][16];\nint id[16][16];\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  int me;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;\n  }\n  void hash(int column){\n    me = 0;\n    rep(i,n){\n      me = me * 1000 + id[p[i]/column][p[i]%column]; \n    }\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<int>& S,int now,int n){\n  if ( n == now){\n    dest.data.hash(column);\n    if ( dest.legal(source) && S.find(dest.data.me) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data.me);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n\t\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<int> S;\n  first.data.hash(column);\n  S.insert(first.data.me);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    int index = 0;\n    rep(i,row)rep(j,column)id[i][j]=-1;\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n\tif (m[i][j]=='#');\n\telse id[i][j] = index++;\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n  /*\n  cout << \"bfs for \" << num<< \" th ghoast\" << endl;\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      if ( cost[num][i][j] == INF)cout << \"x  \";\n      else cout << cost[num][i][j] << \"  \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\n\nchar f[16][16];\nint fx,fy,N;\nint dx[] = {0, 0, -1, 1, 0};\nint dy[] = {0, -1, 0, 0, 1};\n\nclass Ghost\n{\npublic:\n\tint x[3],y[3],c;\n\tbool r;\n\t\n\tGhost(int* i, int* j, int c, bool r)\n\t:r(r),c(c)\n\t{\n\t\tfor(int k=0; k<3; k++)\n\t\t{\n\t\t\tx[k]=i[k];\n\t\t\ty[k]=j[k];\n\t\t\t\n\t\t}\n\t}\n};\n\nbool move(int x, int y, int p)\n{\n\tif(p>=N) return true;\n\tif(x<0||y<0||x>=fx||y>=fy) return false;\n\tif(f[x][y]=='#') return false;\n\t\n\treturn true;\n}\n\nbool crash(int* x, int* y, int* gx, int* gy, int p)\n{\n\tif(p<N) return false;\n\tfor(int i=0; i<p; i++)\n\tfor(int j=i+1; j<p; j++)\n\t{\n\t\tif(x[i]==x[j]&&y[i]==y[j]) return true;\n\t\tif(x[i]==gx[j]&&y[i]==gy[j]&&gx[i]==x[j]&&gy[i]==y[j]) return true;\n\t}\n\treturn false;\n}\n\nshort h[256][256][256][2];\n\nint main()\n{\t\n\twhile(scanf(\"%d%d%d\",&fx,&fy,&N), (fx||fy||N))\n\t{\n\t\tint sx[3]={0},sy[3]={0},gx[3]={0},gy[3]={0};\n\t\tmemset(h,0,sizeof(h));\n\t\t\t\n\t\tchar s[20];\n\t\t\n\t\tgetchar();\n\t\tfor(int i=0; i<fy; i++)\n\t\t{\n\t\t\tgets(s);\n\t\t\tfor(int j=0; j<fx; j++)\n\t\t\t{\n\t\t\t\tif(islower(s[j]))\n\t\t\t\t{\n\t\t\t\t\tsx[s[j]-'a']=j;\n\t\t\t\t\tsy[s[j]-'a']=i;\n\t\t\t\t}\n\t\t\t\tif(isupper(s[j]))\n\t\t\t\t{\n\t\t\t\t\tgx[s[j]-'A']=j;\n\t\t\t\t\tgy[s[j]-'A']=i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf[j][i]=s[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<Ghost> q;\n\t\tq.push(Ghost(sx,sy,1,0));\n\t\tq.push(Ghost(gx,gy,1,1));\n\t\t\n\t\tint th[3];\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(sx[l]<<4)+sy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][0]=1;\n\t\tfor(int l=0; l<3; l++)\n\t\t{\n\t\t\tth[l]=(gx[l]<<4)+gy[l];\n\t\t}\n\t\th[th[0]][th[1]][th[2]][1]=1;\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tGhost g=q.front(); q.pop();\n\t\t\t\n\t\t\tint th[3];\n\n\t\t\tfor(int l=0; l<3; l++)\n\t\t\t{\n\t\t\t\tth[l]=(g.x[l]<<4)+g.y[l];\n\t\t\t}\n\n\t\t\tif(h[th[0]][th[1]][th[2]][!g.r])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", g.c+h[th[0]][th[1]][th[2]][!g.r]-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint tx[3],ty[3];\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\ttx[i]=g.x[i];\n\t\t\t\tty[i]=g.y[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<5; i++)\n\t\t\t{\n\t\t\t\ttx[0]=g.x[0]+dx[i], ty[0]=g.y[0]+dy[i];\n\t\t\t\tif(!move(tx[0],ty[0],0))\n\t\t\t\t{\n\t\t\t\t\ttx[0]=g.x[0];\n\t\t\t\t\tty[0]=g.y[0];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<(N>1?5:1); j++)\n\t\t\t\t{\n\t\t\t\t\ttx[1]=g.x[1]+dx[j], ty[1]=g.y[1]+dy[j];\n\t\t\t\t\tif(N>=2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!move(tx[1],ty[1], 1) || (crash(tx,ty,g.x,g.y,2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[1]=g.x[1];\n\t\t\t\t\t\t\tty[1]=g.y[1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=0; k<(N>2?5:1); k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttx[2]=g.x[2]+dx[k], ty[2]=g.y[2]+dy[k];\n\t\t\t\t\t\tif(N>=3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(!move(tx[2],ty[2], 2) || (crash(tx,ty,g.x,g.y,3)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int l=0; l<3; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tth[l]=(tx[l]<<4)+ty[l];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(h[th[0]][th[1]][th[2]][g.r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttx[2]=g.x[2];\n\t\t\t\t\t\t\tty[2]=g.y[2];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th[th[0]][th[1]][th[2]][g.r]=g.c;\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tq.push(Ghost(tx, ty, g.c+1,g.r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return a.dist > b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist += dist[i][start[i].y][start[i].x];\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,0};\nconst int dy[8]={0,1,0,-1,0};\n\nconst int limit=1<<24;\nint dist[limit];\n\ninline int hstar(int n,int cmask,int tmask){\n\tint cy[3],cx[3],ty[3],tx[3];\n\tint ret=0;\n\trep(i,n){\n\t\tcx[i]=cmask&15;\n\t\tcmask>>=4;\n\t\tcy[i]=cmask&15;\n\t\tcmask>>=4;\n\n\t\ttx[i]=tmask&15;\n\t\ttmask>>=4;\n\t\tty[i]=tmask&15;\n\t\ttmask>>=4;\n\n\t\tchmax(ret,abs(cy[i]-ty[i])+abs(cx[i]-tx[i]));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint w,h,n;\n\t\n\twhile(cin >> w >> h >> n,n){\n\t\tint smask=0,tmask=0;\n\t\tstring board[16];\n\t\t\n\t\tcin.ignore();\n\t\trep(i,h) getline(cin,board[i]);\n\n\t\t// cout << w << \" \" << h << \" \" << n << endl;\n\t\t// rep(i,h) cout << board[i] << endl;\n\n\t\trep(i,h)rep(j,w)rep(k,3){\n\t\t\tif(board[i][j]==('a'+k)) smask|=((16*i+j)<<(8*k));\n\t\t\tif(board[i][j]==('A'+k)) tmask|=((16*i+j)<<(8*k));\n\t\t}\n\n\t\tfill(dist,dist+limit,limit);\n\t\tdist[smask]=0;\n\t\tusing state=tuple<int,int>;\n\t\tpriority_queue<state,vector<state>,greater<state>> q;\n\t\tq.push(state(0,smask));\n\n\t\twhile(!q.empty()){\n\t\t\tint cost,cmask;\n\t\t\ttie(cost,cmask)=q.top();q.pop();\n\n\t\t\tif(dist[tmask]!=limit) break;\n\n\t\t\tint cy[3],cx[3],tmp=cmask;\n\t\t\trep(i,n){\n\t\t\t\tcx[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t\tcy[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t}\n\n\t\t\tconst int all=pow<int>(5,n);\n\n\t\t\trep(mask,all){\n\t\t\t\tconst int didx[3]={mask%5,mask/5%5,mask/25};\n\t\t\t\tint ny[3],nx[3];\n\t\t\t\trep(i,n){\n\t\t\t\t\tny[i]=cy[i]+dy[didx[i]];\n\t\t\t\t\tnx[i]=cx[i]+dx[didx[i]];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n) if(board[ny[i]][nx[i]]=='#') ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==ny[j] && nx[i]==nx[j] ) ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==cy[j] && nx[i]==cx[j] && ny[j]==cy[i] && nx[j]==cx[i]) ok=false;\n\t\t\t\tif(ok==false) continue;\n\n\n\t\t\t\tint nmask=0;\n\t\t\t\trep(i,n) nmask|=(16*ny[i]+nx[i])<<(8*i);\n\n\t\t\t\tif(chmin(dist[nmask],dist[cmask]+1)) q.push(state(dist[nmask]+hstar(n,nmask,tmask),nmask));\t\t\n\t\t\t}\n\n\t\t}\n\t\tcout << dist[tmask] << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tbool goal=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d.y[i]!=gy[i] || d.x[i]!=gx[i])goal=false;\n\t\t}\n\t\tif(goal){\n\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]];\n\t\t}\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tif(!flag)continue;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return 2 * a.cost + a.dist > 2 * b.cost + b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d > s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n \nconst int MAXW = 16;\nconst int MAXH = 16;\nconst int COSTSIZE = 14;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nconst int INF = 1<<28;\n \nint W, H, N;\nstring C[MAXH];\nint cost[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nbool vis[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nint ans;\n\nstruct State {\n  vector<pair<int,int> > ps;\n  bool operator < (const State &s) const {\n    return ps < s.ps;\n  }\n};\n \nvector<pair<int,int> > npos(int i, int j) {\n  vector<pair<int,int> > v;\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(C[ni][nj] == '#') continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  return v;\n}\n \ninline void putCost(const State &s, int c) {\n  if(N == 1) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getCost(const State &s) {\n  if(N == 1) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \ninline void putVis(const State &s, bool c) {\n  if(N == 1) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getVis(const State &s) {\n  if(N == 1) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \nvoid rec(vector<vector<pair<int,int> > > &v, queue<State> &que, const State &s, State &t, int k) {\n  if(k == N) {\n    if(!getVis(t)) {\n      if(getCost(t) == INF) {\n        que.push(t);\n        putCost(t, getCost(s) + 1);\n        putVis(t, true);\n      } else {\n        ans = min(ans, getCost(t) + getCost(s) + 1);\n        putVis(t, true);\n        throw 0;\n      }\n    }\n    return;\n  }\n \n  for(int i = 0; i < v[k].size(); ++i) {\n    bool flag = true;\n    t.ps[k] = v[k][i];\n    for(int j = 0; j < k; ++j) {\n      if(t.ps[k] == t.ps[j]) {\n        flag = false;\n        break;\n      }\n      if(s.ps[k] == t.ps[j] && s.ps[j] == t.ps[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      rec(v, que, s, t, k+1);\n    }\n  }\n}\n \nbool isFinished(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    int ni = s.ps[i].first;\n    int nj = s.ps[i].second;\n    if(C[ni][nj]-'A' != i) return false;\n  }\n  return true;\n}\n \nvoid show(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s.ps[i].first << \", \" << s.ps[i].second;\n    cout << endl;\n  }\n}\n \nint bfs(State initS, bool flag = true) {\n  queue<State> que;\n  que.push(initS);\n  memset(vis, 0, sizeof(vis));\n  putCost(initS, 0);\n  putVis(initS, true);\n  while(!que.empty()) {\n    const State s = que.front();\n    que.pop();\n    if(!flag && getCost(s) >= 60) continue;\n    if(getCost(s)*2 >= ans) continue;\n    vector<vector<pair<int,int> > > v(N);\n    for(int i = 0; i < N; ++i) {\n      v[i] = npos(s.ps[i].first, s.ps[i].second);\n    }\n    State t = s;\n    rec(v, que, s, t, 0);\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> W >> H >> N && (W|H|N)) {\n    cin.ignore();\n    for(int i = 0; i < H; ++i) {\n      getline(cin, C[i]);\n    }\n    State s, t;\n    s.ps.resize(N);\n    t.ps.resize(N);\n    pair<int,int> a, b, c;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        int k;\n        k = C[i][j] - 'a';\n        if(0 <= k && k < N) {\n          s.ps[k] = make_pair(i,j);\n        }\n        k = C[i][j] - 'A';\n        if(0 <= k && k < N) {\n          t.ps[k] = make_pair(i,j);\n        }\n      }\n    }\n    fill(cost[0][0][0][0][0], cost[COSTSIZE][0][0][0][0], INF);\n    ans = INF;\n    bfs(t, false);\n    try {\n      bfs(s);\n    } catch(...) {}\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint width, height, n;\nint encode(const int x[3], const int y[3]) {\n  int ret = 0;\n  int base = 1;\n  REP(i, n) {\n    assert(x[i] > 0 && x[i] < width - 1 && y[i] > 0 && y[i] < height - 1);\n    ret += x[i] * base;\n    base *= 16;\n    ret += y[i] * base;\n    base *= 16;\n  }\n  assert(ret > 0 && ret < 16 * 16 * 16 * 16 * 16 * 16);\n  return ret;\n}\n\nvoid decode(int code, int x[3], int y[3]) {\n  REP(i, n) {\n    x[i] = code % 16;\n    code /= 16;\n    y[i] = code % 16;\n    code /= 16;\n  }\n}\n\nchar field[20][20];\nint sx[3];\nint sy[3];\nint gx[3];\nint gy[3];\nint x[3];\nint y[3];\nint nx[3];\nint ny[3];\nbool visit[16*16*16*16*16*16];\nconst int dx[5] = { 1, 0, -1, 0, 0 };\nconst int dy[5] = { 0, 1, 0, -1, 0 };\n\nint main() {\n  while (scanf(\"%d %d %d\", &width, &height, &n), width|height|n) {\n    fgets(field[0], 19, stdin);\n    MEMSET(visit, false);\n    MEMSET(field, '#');\n    {\n      REP(y, height) {\n        fgets(field[y], 19, stdin);\n        REP(x, width) {\n          if (field[y][x] == 'A') { gx[0] = x; gy[0] = y; }\n          if (field[y][x] == 'B') { gx[1] = x; gy[1] = y; }\n          if (field[y][x] == 'C') { gx[2] = x; gy[2] = y; }\n          if (field[y][x] == 'a') { sx[0] = x; sy[0] = y; }\n          if (field[y][x] == 'b') { sx[1] = x; sy[1] = y; }\n          if (field[y][x] == 'c') { sx[2] = x; sy[2] = y; }\n        }\n        //cout << field[y];\n      }\n    }\n    queue<pair<int, int> > que;\n    que.push(make_pair(encode(sx, sy), 0));\n    visit[encode(sx, sy)] = true;\n    while (!que.empty()) {\n      decode(que.front().first, x, y);\n      int cost = que.front().second;\n      que.pop();\n      //cout << x[0] << \" \" << y[0] << \" \" << x[1] << \" \" << y[1] << \" \" << cost << endl;\n      REP(i, n) {\n        if (x[i] != gx[i] || y[i] != gy[i]) { break; }\n        if (i == n - 1) {\n          printf(\"%d\\n\", cost);\n          goto next;\n        }\n      }\n      REP(dir1, 5) {\n        nx[0] = x[0] + dx[dir1];\n        ny[0] = y[0] + dy[dir1];\n        if (n >= 1 && field[ny[0]][nx[0]] == '#') { continue; }\n        REP(dir2, 5) {\n          if (n < 2 && dir2 != 4) { continue; }\n          nx[1] = x[1] + dx[dir2];\n          ny[1] = y[1] + dy[dir2];\n          if (n >= 2) {\n            if (nx[0] == nx[1] && ny[0] == ny[1]) { continue; }\n            if (x[0] == nx[1] && x[1] == nx[0] && y[0] == ny[1] && y[1] == ny[0]) { continue; }\n          }\n          if (n >= 2 && field[ny[1]][nx[1]] == '#') { continue; }\n          REP(dir3, 5) {\n            if (n < 3 && dir3 != 4) { continue; }\n            nx[2] = x[2] + dx[dir3];\n            ny[2] = y[2] + dy[dir3];\n            if (n >= 3 && field[ny[2]][nx[2]] == '#') { continue; }\n            if (n >= 3) {\n              if (nx[0] == nx[2] && ny[0] == ny[2]) { continue; }\n              if (nx[1] == nx[2] && ny[1] == ny[2]) { continue; }\n              if (x[0] == nx[2] && x[2] == nx[0] && y[0] == ny[2] && y[2] == ny[0]) { continue; }\n              if (x[1] == nx[2] && x[2] == nx[1] && y[1] == ny[2] && y[2] == ny[1]) { continue; }\n            }\n            int code = encode(nx, ny);\n            if (visit[code]) { continue; }\n            visit[code] = true;\n            que.push(make_pair(code, cost + 1));\n          }\n        }\n      }\n    }\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\n\nint toInt(vector<int>& y, vector<int>& x, bitset<3> bs){\n    int ret = bs.to_ulong();\n    for(int i=0; i<n; ++i){\n        ret *= h;\n        ret += y[i];\n        ret *= w;\n        ret += x[i];\n    }\n    return ret;\n}\n\nvoid fromInt(int a, vector<int>& y, vector<int>& x, bitset<3>& bs){\n    for(int i=n-1; i>=0; --i){\n        x[i] = a % w;\n        a /= w;\n        y[i] = a % h;\n        a /= h;\n    }\n    bs = a;\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        vector<string> grid(h);\n        vector<int> sy(n), sx(n), gy(n), gx(n);\n        for(int i=0; i<h; ++i){\n            getline(cin, grid[i]);\n            for(int j=0; j<w; ++j){\n                int c = grid[i][j];\n                if('a' <= c && c <= 'c'){\n                    sy[c-'a'] = i;\n                    sx[c-'a'] = j;\n                }else if('A' <= c && c <= 'C'){\n                    gy[c-'A'] = i;\n                    gx[c-'A'] = j;\n                }\n            }\n        }\n\n        int size = 1 << n;\n        for(int i=0; i<n; ++i)\n            size *= h * w;\n\n        vector<bool> check(size, false);\n        check[toInt(sy, sx, 0)] = true;\n        queue<int> q1, q2;\n        q1.push(toInt(sy, sx, 0));\n        int ret = 1;\n        for(;;){\n            if(q1.empty()){\n                q1.swap(q2);\n                ++ ret;\n            }\n\n            vector<int> y(n), x(n);\n            bitset<3> bs;\n            fromInt(q1.front(), y, x, bs);\n            q1.pop();\n            if(y == gy && x == gx){\n                cout << ret << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                if(bs[i])\n                    continue;\n                bs[i] = true;\n                for(int j=0; j<4; ++j){\n                    y[i] += dy[j];\n                    x[i] += dx[j];\n\n                    bool ok = true;\n                    if(grid[y[i]][x[i]] == '#')\n                        ok = false;\n                    for(int k=0; k<n; ++k){\n                        if(k != i && y[k] == y[i] && x[k] == x[i])\n                            ok = false;\n                    }\n\n                    if(ok){\n                        int a = toInt(y, x, bs);\n                        if(!check[a]){\n                            q1.push(a);\n                            check[a] = true;\n                        }\n                    }\n\n                    y[i] -= dy[j];\n                    x[i] -= dx[j];\n                }\n                bs[i] = false;\n            }\n\n            int a = toInt(y, x, 0);\n            if(!check[a]){\n                q2.push(a);\n                check[a] = true;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC target \"avx\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        set<array<point_t,3> > used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(start);\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(t)) continue;\n                        used.insert(t);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "int a[16][16][16][16];\nint b[1 << 24];\nint main(){\n  for(int i = 0; i < 16; i++) a[i][i][i][i] = i * 3;\n  for(int i = 0; i < (1 << 24); i++) b[i] = i & 0xff2;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.1 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\t//if(q.size() > 100000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[5] = {0, 0, 1, 0, -1};\nconstexpr int dy[5] = {0, 1, 0, -1, 0};\n\nshort d[256][256][256];\n\nvoid init() {\n    for(int i = 0; i < 256; ++i) {\n        for(int j = 0; j < 256; ++j) {\n            for(int k = 0; k < 256; ++k) {\n                d[i][j][k] = 10000;\n            }\n        }\n    }\n}\n\nbool move_check(int prev1, int to1, int prev2, int to2) {\n    return to1 != to2 && (prev1 != to2 || prev2 != to1);\n}\n\nint main() {\n    int w, h, n;\n    while(cin >> w >> h >> n, n) {\n        init();\n        vector<string> c(h);\n        vector<pii> cs1, cs2;\n        cin.ignore(1000, '\\n');\n        for(int i = 0; i < h; ++i) {\n            getline(cin, c[i]);\n            for(int j = 0; j < w; ++j) {\n                if('a' <= c[i][j] && c[i][j] <= 'z') {\n                    cs1.emplace_back(c[i][j], i * w + j);\n                }\n                if('A' <= c[i][j] && c[i][j] <= 'Z') {\n                    cs2.emplace_back(c[i][j], i * w + j);\n                }\n            }\n        }\n        sort(begin(cs1), end(cs1));\n        sort(begin(cs2), end(cs2));\n        array<int, 3> s = {255, 255, 255}, g = {255, 255, 255};\n        for(int i = 0; i < n; ++i) {\n            s[i] = cs1[i].second;\n            g[i] = cs2[i].second;\n        }\n\n        queue<pair<array<int, 3>, short>> que;\n        d[s[0]][s[1]][s[2]] = 0;\n        que.emplace(s, 0);\n        int res = 0;\n        while(!que.empty()) {\n            auto now = que.front().first;\n            auto cost = que.front().second;\n            que.pop();\n            if(now == g) {\n                res = cost;\n                break;\n            }\n            for(int i = 0; i < 5; ++i) {\n                int ny0 = now[0] / w + dy[i], nx0 = (now[0] % w) + dx[i];\n                if(c[ny0][nx0] == '#') {\n                    continue;\n                }\n                for(int j = 0; j < 5; ++j) {\n                    int ny1 = now[1] / w + dy[j], nx1 = (now[1] % w) + dx[j];\n                    if(n >= 2 && c[ny1][nx1] == '#') {\n                        continue;\n                    }\n                    for(int k = 0; k < 5; ++k) {\n                        int ny2 = now[2] / w + dy[k], nx2 = (now[2] % w) + dx[k];\n                        if(n == 3 && c[ny2][nx2] == '#') {\n                            continue;\n                        }\n                        array<int, 3> nxt = {ny0 * w + nx0,\n                                             (n >= 2 ? ny1 * w + nx1 : 255),\n                                             (n == 3 ? ny2 * w + nx2 : 255)};\n                        bool move_ok = true;\n                        for(int l = 0; n != 1 && l < n; ++l) {\n                            move_ok &= move_check(now[l], nxt[l], now[(l + 1) % n], nxt[(l + 1) % n]);\n                        }\n                        if(move_ok && d[nxt[0]][nxt[1]][nxt[2]] == 10000) {\n                            d[nxt[0]][nxt[1]][nxt[2]] = cost + 1;\n                            que.emplace(nxt, cost + 1);\n                        }\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n#pragma GCC target \"tune=native\"\n#pragma GCC target \"avx\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nshort dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\tdata nd=d;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nv[3];\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t}\n\t\t\tif(dp[nv[0]][nv[1]][nv[2]]==-1){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\t}\n\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=dp[d.y[0]*w+d.x[0]][d.y[1]*w+d.x[1]][d.y[2]*w+d.x[2]]+1;\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<ctime>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost = max(add_cost,ev[p.p[i]][goal[i]]);\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  //clock_t st,ed;\n  //st = clock();\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(28);//å¤§ããããã¨MLEãå°ããããã¨TLE\n      makeEv();\n      compute();\n\n    }\n\n  //ed = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << \"time : \" << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return 3 * a.cost - a.dist > 3 * b.cost - b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist += dist[i][start[i].y][start[i].x];\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nshort memo[16][16][16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint mget(vector<pair<int, int>>ps) {\n\tfor (int i = ps.size(); i < 3; ++i) {\n\t\tps.emplace_back(0, 0);\n\t}\n\treturn memo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].first][ps[2].second];\n}\nvoid mset(vector<pair<int, int>>ps,const int value) {\n\tfor (int i = ps.size(); i < 3; ++i) {\n\t\tps.emplace_back(0, 0);\n\t}\n\tmemo[ps[0].first][ps[0].second][ps[1].first][ps[1].second][ps[2].first][ps[2].second]=value;\n}\nstruct aa {\n\tvector<pair<int, int>>coors;\n\tint turn;\n};\nint main() {\n\twhile (1) {\n\t\tfor (size_t i = 0; i < 16; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < 16; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < 16; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (size_t l = 0; l < 16; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (size_t m = 0; m < 16; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (size_t n = 0; n < 16; n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint W, H, N; cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<pair<int, int>>s(N);\n\t\tvector<pair<int, int>>f(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse if (st[j] <= 'a'+N-1 && st[j] >= 'a') {\n\t\t\t\t\tf[st[j] - 'a'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ts[st[j] - 'A'] = make_pair(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmset(s, 0);\n\t\tqueue<aa>que;\n\t\tque.push(aa{ s, 0 });\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.front());\n\t\t\tque.pop();\n\t\t\tconst auto from = atop.coors;\n\t\t\tconst int aturn = atop.turn;\n\t\t\tif (from == f) {\n\t\t\t\tans = aturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int>nums(N);\n\t\t\tiota(nums.begin(), nums.end(),0);\n\t\t\tdo {\n\t\t\t\t int repnum = 1;\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\trepnum *= 5;\n\t\t\t\t}\n\t\t\t\tfor (int b = 0; b < repnum; ++b) {\n\t\t\t\t\tint bb = b;\n\t\t\t\t\tauto newcoors(from);\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\t\tconst int gh = nums[i];\n\t\t\t\t\t\tconst int way = bb % 5;\n\t\t\t\t\t\tbb /= 5;\n\t\t\t\t\t\tconst int newx = (newcoors[gh].first += dx[way]);\n\t\t\t\t\t\tconst int newy = (newcoors[gh].second += dy[way]);\n\t\t\t\t\t\tif (field[newy][newx]) {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int op = 0; op < N; ++op) {\n\t\t\t\t\t\t\tif (op == gh)continue;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (newcoors[gh] == newcoors[op])ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (mget(newcoors)<0||mget(newcoors) > aturn + 1) {\n\t\t\t\t\t\t\tmset(newcoors, aturn + 1);\n\t\t\t\t\t\t\tque.push(aa{ newcoors,aturn + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (next_permutation(nums.begin(), nums.end()));\t\n\t\t\tif (que.empty()) {\n\t\t\t\tcout << 1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tfor (int k = 0; k < 15; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 15; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 15; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 15; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx])aok = false;\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))aok = false;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<bitset>\n#include<queue>\nchar m[32][32];\nconst int dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\nstd::bitset<1<<24 >f;\ntemplate<int N>\nstruct S\n{\nvoid I2P(int a,int*x,int*y)\n{\n\tfor(int i=0;i<N;++i)\n\t{\n\t\ty[N-i-1]=a&15;\n\t\tx[N-i-1]=(a>>4)&15;\n\t\ta>>=8;\n\t}\n}\nint P2I(int*x,int*y)\n{\n\tint res=0,i;\n\tfor(i=0;i<N;++i)\n\t\tres=(res<<8)|(x[i]<<4)+y[i];\n\treturn res;\n}\nint EQ(int*x,int*y,int*gx,int*gy)\n{\n\tfor(int i=0;i<N;++i)\n\t\tif(x[i]!=gx[i]||y[i]!=gy[i])\n\t\t\treturn 0;\n\treturn 1;\n}\nvoid G(std::queue<int>&q, int*x,int*y,int*nx,int*ny,int/* i*/)\n{\n\tint i,j,k,a;\n\tfor(i=0;i<5;++i)\n\t{\n\t\tnx[0]=x[0]+dx[i];\n\t\tny[0]=y[0]+dy[i];\n\t\tif(m[ny[0]][nx[0]]=='#')continue;\n\t\tif(N==1)\n\t\t{\n\t\t\ta=P2I(nx,ny);\n\t\t\tif(!f[a])\n\t\t\t\tq.push(a);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=0;j<5;++j)\n\t\t{\n\t\t\tnx[1]=x[1]+dx[j];\n\t\t\tny[1]=y[1]+dy[j];\n\t\t\tif(m[ny[1]][nx[1]]=='#' || nx[0]==nx[1]&&ny[0]==ny[1])continue;\n\t\t\tif(x[0]==nx[1]&&y[0]==ny[1]&&x[1]==nx[0]&&y[1]==ny[0])\n\t\t\t\tcontinue;\n\t\t\tif(N==2)\n\t\t\t{\n\t\t\t\ta=P2I(nx,ny);\n\t\t\t\tif(!f[a])\n\t\t\t\t\tq.push(a);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(k=0;k<5;++k)\n\t\t\t{\n\t\t\t\tnx[2]=x[2]+dx[k];\n\t\t\t\tny[2]=y[2]+dy[k];\n\t\t\t\tif(m[ny[2]][nx[2]]=='#' || nx[0]==nx[2]&&ny[0]==ny[2] || nx[1]==nx[2]&&ny[1]==ny[2])continue;\n\t\t\t\tif(x[0]==nx[2]&&y[0]==ny[2]&&x[2]==nx[0]&&y[2]==ny[0] || \n\t\t\t\t   x[1]==nx[2]&&y[1]==ny[2]&&x[2]==nx[1]&&y[2]==ny[1])\n\t\t\t\t\tcontinue;\n\t\t\t\ta=P2I(nx,ny);\n\t\t\t\tif(!f[a])\n\t\t\t\t\tq.push(a);\n\t\t\t}\n\t\t}\n\t}\n}\nint F(int (&x)[3],int (&y)[3],int (&gx)[3],int(&gy)[3])\n{\n\tf.reset();\n\tstd::queue<int>q;\n\tq.push(P2I(x,y));\n\tq.push(-1);\n\tint a,res=0;\n\tint nx[3],ny[3];\n\tfor(;;)\n\t{\n\t\ta=q.front();\n\t\tq.pop();\n\t\tif(a<0)\n\t\t{\n\t\t\t++res;\n\t\t\tq.push(a);\n\t\t\tcontinue;\n\t\t}\n\t\tif(f[a])continue;\n\t\tf[a]=true;\n\t\tI2P(a,x,y);\n\t\tif(EQ(x,y,gx,gy))return res;\n\t\tG(q,x,y,nx,ny,0);\n\t}\n}\n};\nint main()\n{\n\tint h,w,n,i,x[3],y[3],gx[3],gy[3];\n\tchar*p;\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),n)\n\t{\n\t\tfgets(m[0],32,stdin);\n\t\tfor(i=0;i<h;++i)\n\t\t{\n\t\t\tfgets(m[i],32,stdin);\n\t\t\tfor(p=m[i];p=strpbrk(p,\"abc\");++p)\n\t\t\t{\n\t\t\t\ty[*p-'a']=i;\n\t\t\t\tx[*p-'a']=p-m[i];\n\t\t\t}\n\t\t\tfor(p=m[i];p=strpbrk(p,\"ABC\");++p)\n\t\t\t{\n\t\t\t\tgy[*p-'A']=i;\n\t\t\t\tgx[*p-'A']=p-m[i];\n\t\t\t}\n\t\t}\n\t\tint r = (n==3?S<3>().F(x,y,gx,gy):\n\t\t\t\tn==2?S<2>().F(x,y,gx,gy):\n\t\t\t\tS<1>().F(x,y,gx,gy));\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nchar str[20][20];\nint dx[]={1,0,-1,0,0};\nint dy[]={0,1,0,-1,0};\nint num[20][20];\nint bfs[130][130][130];\nint to[130][5];\nint cnt;\nstruct wolf{\n\tint a,b,c;\n\twolf(int A,int B,int C){\n\t\ta=A;b=B;c=C;\n\t}\n\twolf(){\n\t\ta=b=c=cnt;\n\t}\n};\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&b,&a,&c),a){\n\t\tgets(str[0]);\n\t\tfor(int i=0;i<a;i++)gets(str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)num[i][j]=-1;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++)if(str[i][j]!='#')num[i][j]=cnt++;\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'){\n\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\tif(0<=i+dx[k]&&i+dx[k]<a&&0<=j+dy[k]&&j+dy[k]<b&&str[i+dx[k]][j+dy[k]]!='#'){\n\t\t\t\t\tto[num[i][j]][k]=num[i+dx[k]][j+dy[k]];\n\t\t\t\t}else to[num[i][j]][k]=-1;\n\t\t\t}\n\t\t}\n\t\tqueue<wolf>Q;\n\t\twolf S;\n\t\twolf T;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='a'){S.a=num[i][j];str[i][j]='.';}\n\t\t\tif(str[i][j]=='b'){S.b=num[i][j];str[i][j]='.';}\n\t\t\tif(str[i][j]=='c'){S.c=num[i][j];str[i][j]='.';}\n\t\t\tif(str[i][j]=='A'){T.a=num[i][j];str[i][j]='.';}\n\t\t\tif(str[i][j]=='B'){T.b=num[i][j];str[i][j]='.';}\n\t\t\tif(str[i][j]=='C'){T.c=num[i][j];str[i][j]='.';}\n\t\t}\n\t\tfor(int i=0;i<=cnt;i++)for(int j=0;j<=cnt;j++)for(int k=0;k<=cnt;k++)\n\t\t\tbfs[i][j][k]=-1;\n\t\tQ.push(S);\n\t\tbfs[S.a][S.b][S.c]=0;\n\t\twhile(Q.size()&&!~bfs[T.a][T.b][T.c]){\n\t\t\twolf at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tif(!~to[at.a][i])continue;\n\t\t\t\tif(c==1){\n\t\t\t\t\tif(!~bfs[to[at.a][i]][at.b][at.c]){\n\t\t\t\t\t\tbfs[to[at.a][i]][at.b][at.c]=bfs[at.a][at.b][at.c]+1;\n\t\t\t\t\t\tQ.push(wolf(to[at.a][i],at.b,at.c));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tif(!~to[at.b][j])continue;\n\t\t\t\t\tif(c==2){\n\t\t\t\t\t\tint ta=to[at.a][i];\n\t\t\t\t\t\tint tb=to[at.b][j];\n\t\t\t\t\t\tif(!~bfs[ta][tb][at.c]&&ta!=tb&&(ta!=at.b||tb!=at.a)){\n\t\t\t\t\t\t\tbfs[ta][tb][at.c]=bfs[at.a][at.b][at.c]+1;\n\t\t\t\t\t\t\tQ.push(wolf(ta,tb,at.c));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\t\tif(!~to[at.c][k])continue;\n\t\t\t\t\t\tint ta=to[at.a][i];\n\t\t\t\t\t\tint tb=to[at.b][j];\n\t\t\t\t\t\tint tc=to[at.c][k];\n\t\t\t\t\t\tif(!~bfs[ta][tb][tc]&&ta!=tb&&ta!=tc&&tb!=tc&&(ta!=at.b||tb!=at.a)&&\n\t\t\t\t\t\t(tb!=at.c||tc!=at.b)&&(tc!=at.a||ta!=at.c)){\n\t\t\t\t\t\t\tbfs[ta][tb][tc]=bfs[at.a][at.b][at.c]+1;\n\t\t\t\t\t\t\tQ.push(wolf(ta,tb,tc));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",bfs[T.a][T.b][T.c]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,n;\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\nstring mp[20];\n\nstruct dat{\n  int y1,x1;\n  int y2,x2;\n  int y3,x3;\n};\n\n\nint D[14][14][15][15][15][15];\nqueue<dat> Q;\nvoid DD(dat &a,int b){D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1] = b;}\nint DD(const dat &a){return D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1];}\n\nbool check(const dat &a){\n  if(mp[a.y1][a.x1]=='#') return 0;\n  if(n>=2&&mp[a.y2][a.x2]=='#') return 0;\n  if(n>=3&&mp[a.y3][a.x3]=='#') return 0;\n  return DD(a)==-1;\n}\n\nvoid update(const dat &a){\n  int cost = DD(a);\n\n  for(int i=0;i<5;i++){\n    int ny1 = a.y1+dy[i], nx1 = a.x1+dx[i];\n    for(int j=0;j<5;j++){\n      int ny2 = a.y2+dy[j], nx2 = a.x2+dx[j];\n      if(n<=1) ny2 = 15,nx2 = 14;\n      for(int k=0;k<5;k++){\n\tint ny3 = a.y3+dy[k], nx3 = a.x3+dx[k];\n\tif(n<=2) ny3 = 14,nx3 = 15;\n\n\tdat nt = (dat){ny1,nx1,ny2,nx2,ny3,nx3};\n\tif(!check(nt))continue;\n\t\n\tif((ny1==ny2&&nx1==nx2) ||(ny2==ny3&&nx2==nx3) ||(ny3==ny1&&nx3==nx1))continue;//same pos\n\tif(((a.y1==ny2&&a.x1==nx2) && (a.y2==ny1&&a.x2==nx1)) || // swap positoin\n\t   ((a.y2==ny3&&a.x2==nx3) && (a.y3==ny2&&a.x3==nx2)) ||\n\t   ((a.y3==ny1&&a.x3==nx1) && (a.y1==ny3&&a.x1==nx3)) )continue;\n\t\n\tQ.push(nt);\n\tDD(nt,cost+1);\n      }\n    }\n  }\n}\n\nbool goal(const dat &s,const dat &t){\n  char a = mp[s.y1][s.x1];\n  char b = mp[s.y2][s.x2];\n  char c = mp[s.y3][s.x3];\n  char A = mp[t.y1][t.x1];\n  char B = mp[t.y2][t.x2];\n  char C = mp[t.y3][t.x3];\n  return toupper(a)==A&&(n<=1||toupper(b)==B)&&(n<=2||toupper(c)==C);\n}\n\nint bfs(dat start){\n  memset(D,-1,sizeof(D));\n  while(!Q.empty())Q.pop();\n  Q.push(start);\n  DD(start,0);\n  \n  while(!Q.empty()){\n    dat t = Q.front();Q.pop();\n    if(goal(start,t)) return DD(t);\n    update(t);\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>w>>h>>n;\n  if(!w&&!h&&!n)break;\n  cin.ignore();\n  for(int i=0;i<h;i++)getline(cin,mp[i]),mp[i]+='#';\n  \n  dat start = (dat){15,15,15,14,14,15};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!islower(mp[i][j]))continue;\n      if(start.y1==15) start.y1=i,start.x1=j;\n      else if(start.y2==15) start.y2=i,start.x2=j;\n      else start.y3=i,start.x3=j;\n    }\n  cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n \nconst int MAXW = 16;\nconst int MAXH = 16;\nconst int COSTSIZE = 14;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nconst int INF = 1<<28;\n \nint W, H, N;\nstring C[MAXH];\nint cost[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nbool vis[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nint ans;\n\nstruct State {\n  vector<pair<int,int> > ps;\n  bool operator < (const State &s) const {\n    return ps < s.ps;\n  }\n};\n \nvector<pair<int,int> > npos(int i, int j) {\n  vector<pair<int,int> > v;\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(C[ni][nj] == '#') continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  return v;\n}\n \ninline void putCost(const State &s, int c) {\n  if(N == 1) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getCost(const State &s) {\n  if(N == 1) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \ninline void putVis(const State &s, bool c) {\n  if(N == 1) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getVis(const State &s) {\n  if(N == 1) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \nvoid rec(vector<vector<pair<int,int> > > &v, queue<State> &que, const State &s, State &t, int k) {\n  if(k == N) {\n    if(!getVis(t)) {\n      if(getCost(t) == INF) {\n        que.push(t);\n        putCost(t, getCost(s) + 1);\n        putVis(t, true);\n      } else {\n        ans = min(ans, getCost(t) + getCost(s) + 1);\n        putVis(t, true);\n        throw 0;\n      }\n    }\n    return;\n  }\n \n  for(int i = 0; i < v[k].size(); ++i) {\n    bool flag = true;\n    t.ps[k] = v[k][i];\n    for(int j = 0; j < k; ++j) {\n      if(t.ps[k] == t.ps[j]) {\n        flag = false;\n        break;\n      }\n      if(s.ps[k] == t.ps[j] && s.ps[j] == t.ps[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      rec(v, que, s, t, k+1);\n    }\n  }\n}\n \nbool isFinished(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    int ni = s.ps[i].first;\n    int nj = s.ps[i].second;\n    if(C[ni][nj]-'A' != i) return false;\n  }\n  return true;\n}\n \nvoid show(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s.ps[i].first << \", \" << s.ps[i].second;\n    cout << endl;\n  }\n}\n \nint bfs(State initS, bool flag = true) {\n  queue<State> que;\n  que.push(initS);\n  memset(vis, 0, sizeof(vis));\n  putCost(initS, 0);\n  putVis(initS, true);\n  while(!que.empty()) {\n    const State s = que.front();\n    que.pop();\n    if(!flag && getCost(s) >= 70) continue;\n    if(getCost(s)*2 >= ans) continue;\n    vector<vector<pair<int,int> > > v(N);\n    for(int i = 0; i < N; ++i) {\n      v[i] = npos(s.ps[i].first, s.ps[i].second);\n    }\n    State t = s;\n    rec(v, que, s, t, 0);\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> W >> H >> N && (W|H|N)) {\n    cin.ignore();\n    for(int i = 0; i < H; ++i) {\n      getline(cin, C[i]);\n    }\n    State s, t;\n    s.ps.resize(N);\n    t.ps.resize(N);\n    pair<int,int> a, b, c;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        int k;\n        k = C[i][j] - 'a';\n        if(0 <= k && k < N) {\n          s.ps[k] = make_pair(i,j);\n        }\n        k = C[i][j] - 'A';\n        if(0 <= k && k < N) {\n          t.ps[k] = make_pair(i,j);\n        }\n      }\n    }\n    fill(cost[0][0][0][0][0], cost[COSTSIZE][0][0][0][0], INF);\n    ans = INF;\n    bfs(t, false);\n    try {\n      bfs(s);\n    } catch(...) {}\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,Hå«ã¾ãªã\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, W, H, N);\n\t\tif (!N) { break; }\n\n\t\t{\n\t\t\tstring dummy;\n\t\t\tgetline(cin, dummy);\n\t\t}\n\t\tvector<string> f;\n\t\tREP(i, H)\n\t\t{\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tf.push_back(s);\n\t\t}\n\n\t\tunion State\n\t\t{\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint xa : 4;\n\t\t\t\tuint ya : 4;\n\t\t\t\tuint xb : 4;\n\t\t\t\tuint yb : 4;\n\t\t\t\tuint xc : 4;\n\t\t\t\tuint yc : 4;\n\t\t\t};\n\t\t\tint pos;\n\t\t};\n\n\n\t\tvector<bool> visited(1 << 24);\n\n\t\tState start = {};\n\t\tState goal = {};\n\t\t{\n\t\t\tREP(y, H)REP(x, W)\n\t\t\t{\n\t\t\t\tswitch(f[y][x])\n\t\t\t\t{\n\t\t\t\tcase 'a': start.xa = x; start.ya = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase 'b': start.xb = x; start.yb = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase 'c': start.xc = x; start.yc = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase 'A': goal.xa = x; goal.ya = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase 'B': goal.xb = x; goal.yb = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase 'C': goal.xc = x; goal.yc = y; f[y][x] = '\\0'; break;\n\t\t\t\tcase ' ': f[y][x] = '\\0';  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pair<State, int>> q;\n\t\tq.push({ start, 0 });\n\t\tvisited[start.pos] = true;\n\t\tint ans = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpair<State, int> cur = q.front(); q.pop();\n\n\t\t\tif (cur.first.pos == goal.pos)\n\t\t\t{\n\t\t\t\tans = cur.second;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tState p = cur.first;\n\t\t\tState next = {};\n\t\t\tint dx[] = { 0,-1, 1, 0, 0 };\n\t\t\tint dy[] = { 0, 0, 0,-1, 1 };\n\t\t\tREP(a, 5)\n\t\t\t{\n\t\t\t\tif (f[p.ya + dy[a]][p.xa + dx[a]]) { continue; }\n\t\t\t\tnext.ya = p.ya + dy[a];\n\t\t\t\tnext.xa = p.xa + dx[a];\n\t\t\t\tif (N > 1)\n\t\t\t\t{\n\t\t\t\t\tREP(b, 5)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (f[p.yb + dy[b]][p.xb + dx[b]]) { continue; }\n\t\t\t\t\t\tnext.yb = p.yb + dy[b];\n\t\t\t\t\t\tnext.xb = p.xb + dx[b];\n\t\t\t\t\t\tif (next.xa == next.xb && next.ya == next.yb) { continue; }\n\t\t\t\t\t\tif (next.xa == p.xb && next.ya == p.yb && next.xb == p.xa && next.yb == p.ya) { continue; }\n\t\t\t\t\t\tif (N > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tREP(c, 5)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (f[p.yc + dy[c]][p.xc + dx[c]]) { continue; }\n\t\t\t\t\t\t\t\tnext.yc = p.yc + dy[c];\n\t\t\t\t\t\t\t\tnext.xc = p.xc + dx[c];\n\t\t\t\t\t\t\t\tif (next.xa == next.xc && next.ya == next.yc) { continue; }\n\t\t\t\t\t\t\t\tif (next.xb == next.xc && next.yb == next.yc) { continue; }\n\t\t\t\t\t\t\t\tif (next.xa == p.xc && next.ya == p.yc && next.xc == p.xa && next.yc == p.ya) { continue; }\n\t\t\t\t\t\t\t\tif (next.xb == p.xc && next.yb == p.yc && next.xc == p.xb && next.yc == p.yb) { continue; }\n\t\t\t\t\t\t\t\tif (!visited[next.pos])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvisited[next.pos] = true;\n\t\t\t\t\t\t\t\t\tq.push({ next, cur.second + 1 });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!visited[next.pos])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvisited[next.pos] = true;\n\t\t\t\t\t\t\t\tq.push({ next, cur.second + 1 });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!visited[next.pos])\n\t\t\t\t\t{\n\t\t\t\t\t\tvisited[next.pos] = true;\n\t\t\t\t\t\tq.push({ next, cur.second + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tWRITE(ans);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nbool wall[16*16];\nint mv[] = {0, 1, -1, 16, -16};\n\nint compress(int pa, int pb, int pc){\n\treturn (pa)|(pb<<8)|(pc<<16);\n}\n\nint solve(int start, int goal){\n\tstatic bool visit[16*16*16*16*16*16];\n\tmemset(visit, false, sizeof(visit));\n\tvisit[start] = true;\n\tvector<int> state[2]; state[0].push_back(start);\n\tfor(int res=1; ;res++){\n\t\tint cur = 1-res%2, next = res%2;\n\t\tstate[next].clear();\n\t\tfor(int i=0;i<state[cur].size();i++){\n\t\t\tint pa = state[cur][i]%256, pb = (state[cur][i]>>8)%256, pc = (state[cur][i]>>16);\n\t\t\tfor(int a=0;a<5;a++){\n\t\t\t\tint npa = pa + mv[a];\n\t\t\t\tif(wall[npa]) continue;\n\t\t\t\tfor(int b=0;b<(pb?5:1);b++){\n\t\t\t\t\tint npb = pb + mv[b];\n\t\t\t\t\tif(npb!=0){\n\t\t\t\t\t\tif(wall[npb]) continue;\n\t\t\t\t\t\tif(npa==npb) continue;\n\t\t\t\t\t\tif(npb==pa&&npa==pb) continue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=0;c<(pc?5:1);c++){\n\t\t\t\t\t\tint npc = pc + mv[c];\n\t\t\t\t\t\tif(npc!=0){\n\t\t\t\t\t\t\tif(wall[npc]) continue;\n\t\t\t\t\t\t\tif(npc==npa||npc==npb) continue;\n\t\t\t\t\t\t\tif(npc==pa&&npa==pc) continue;\n\t\t\t\t\t\t\tif(npc==pb&&npb==pc) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ns = (npa)|(npb<<8)|(npc<<16);\n\t\t\t\t\t\tif(visit[ns]) continue;\n\t\t\t\t\t\tif(ns==goal) return res;\n\t\t\t\t\t\tvisit[ns] = true;\n\t\t\t\t\t\tstate[next].push_back(ns);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint w, h, n;\n\tstring mp[16];\n\twhile(cin >> w >> h >> n, w){\n\t\tgetline(cin, mp[0]);\n\t\tfor(int i=0;i<h;i++) getline(cin, mp[i]);\n\t\tmemset(wall, false, sizeof(wall));\n\t\tint start = 0, goal = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mp[i][j]=='#') wall[16*i+j] = true;\n\t\t\t\tif(islower(mp[i][j])) start |= (16*i+j) << (8*(mp[i][j]-'a'));\n\t\t\t\tif(isupper(mp[i][j])) goal  |= (16*i+j) << (8*(mp[i][j]-'A'));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(start, goal));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Data{\n\tbool operator<(const struct Data &arg)const{\n\t\treturn total_cost > arg.total_cost;\n\t}\n\tvoid set(int arg_total_cost,bool arg_cleard_1,bool arg_cleard_2,bool arg_cleard_3){\n\t\ttotal_cost = arg_total_cost;\n\t\tcleard_1 = arg_cleard_1;\n\t\tcleard_2 = arg_cleard_2;\n\t\tcleard_3 = arg_cleard_3;\n\t}\n\tint total_cost;\n\tInfo loc_1,loc_2,loc_3;\n\tbool cleard_1,cleard_2,cleard_3;\n};\n\nInfo start_info[3],goal_info[3];\n\nstring line;\nint W,H,N;\nint min_cost1[16][16];\nint min_cost2[16][16][16][16];\nint min_cost3[16][16][16][16][16][16];\nint diff_row[5] = {-1,0,0,0,1},diff_col[5] = {0,-1,0,1,0};\nchar table[16][17];\n\n\nbool is_Same(Info a,Info b){\n\n\tif(a.row == b.row && a.col == b.col){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc3(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tfor(int e = 0; e < H; e++){\n\t\t\t\t\t\tfor(int f = 0; f < W; f++)min_cost3[a][b][c][d][e][f] = BIG_NUM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost3[start_info[0].row][start_info[0].col][start_info[1].row][start_info[1].col][start_info[2].row][start_info[2].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.loc_2 = start_info[1];\n\tfirst.loc_3 = start_info[2];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tfirst.cleard_2 = is_Same(start_info[1],goal_info[1]);\n\tfirst.cleard_3 = is_Same(start_info[2],goal_info[2]);\n\tQ.push(first);\n\n\tInfo next_loc1,next_loc2,next_loc3;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true && Q.top().cleard_2 == true && Q.top().cleard_3 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost3[Q.top().loc_1.row][Q.top().loc_1.col][Q.top().loc_2.row][Q.top().loc_2.col][Q.top().loc_3.row][Q.top().loc_3.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tnext_loc2.set(Q.top().loc_2.row+diff_row[k],Q.top().loc_2.col+diff_col[k]);\n\t\t\t\t\tif((table[next_loc2.row][next_loc2.col] == '#') || (is_Same(next_loc1,next_loc2) == true) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc1,Q.top().loc_2) == true && is_Same(next_loc2,Q.top().loc_1)))continue;\n\t\t\t\t\tfor(int p = 0; p < 5; p++){\n\n\t\t\t\t\t\tnext_loc3.set(Q.top().loc_3.row+diff_row[p],Q.top().loc_3.col+diff_col[p]);\n\t\t\t\t\t\tif((table[next_loc3.row][next_loc3.col] == '#') || (is_Same(next_loc1,next_loc3) == true) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc2,next_loc3) == true) || (is_Same(next_loc1,Q.top().loc_3) == true && is_Same(next_loc3,Q.top().loc_1)) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc2,Q.top().loc_3) == true && is_Same(next_loc3,Q.top().loc_2)))continue;\n\n\t\t\t\t\t\tif(min_cost3[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col][next_loc3.row][next_loc3.col] > Q.top().total_cost+1){\n\t\t\t\t\t\t\tmin_cost3[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col][next_loc3.row][next_loc3.col] = Q.top().total_cost+1;\n\t\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\t\t\tnew_data.loc_2 = next_loc2;\n\t\t\t\t\t\t\tnew_data.loc_3 = next_loc3;\n\t\t\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\t\t\tnew_data.cleard_2 = is_Same(next_loc2,goal_info[1]);\n\t\t\t\t\t\t\tnew_data.cleard_3 = is_Same(next_loc3,goal_info[2]);\n\t\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_cost3[goal_info[0].row][goal_info[0].col][goal_info[1].row][goal_info[1].col][goal_info[2].row][goal_info[2].col]);\n}\n\nvoid calc2(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++)min_cost2[a][b][c][d] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost2[start_info[0].row][start_info[0].col][start_info[1].row][start_info[1].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.loc_2 = start_info[1];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tfirst.cleard_2 = is_Same(start_info[1],goal_info[1]);\n\tQ.push(first);\n\n\tInfo next_loc1,next_loc2;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true && Q.top().cleard_2 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost2[Q.top().loc_1.row][Q.top().loc_1.col][Q.top().loc_2.row][Q.top().loc_2.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\n\t\t\t\t\tnext_loc2.set(Q.top().loc_2.row+diff_row[k],Q.top().loc_2.col+diff_col[k]);\n\t\t\t\t\tif((table[next_loc2.row][next_loc2.col] == '#') || (is_Same(next_loc1,next_loc2) == true) ||\n\t\t\t\t\t\t\t(is_Same(next_loc1,Q.top().loc_2) == true && is_Same(next_loc2,Q.top().loc_1)))continue;\n\n\t\t\t\t\tif(min_cost2[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col] > Q.top().total_cost+1){\n\t\t\t\t\t\tmin_cost2[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col] = Q.top().total_cost+1;\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\t\tnew_data.loc_2 = next_loc2;\n\t\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\t\tnew_data.cleard_2 = is_Same(next_loc2,goal_info[1]);\n\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_cost2[goal_info[0].row][goal_info[0].col][goal_info[1].row][goal_info[1].col]);\n}\n\nvoid calc1(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tmin_cost1[a][b] = BIG_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost1[start_info[0].row][start_info[0].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tQ.push(first);\n\n\tInfo next_loc1;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost1[Q.top().loc_1.row][Q.top().loc_1.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\n\t\t\t\tif(min_cost1[next_loc1.row][next_loc1.col] > Q.top().total_cost+1){\n\t\t\t\t\tmin_cost1[next_loc1.row][next_loc1.col] = Q.top().total_cost+1;\n\t\t\t\t\tData new_data;\n\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\tQ.push(new_data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min_cost1[goal_info[0].row][goal_info[0].col]);\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tgetline(cin,line);\n\t\tfor(int col = 0; col < W; col++)table[row][col] = line[col];\n\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tswitch(table[row][col]){\n\t\t\tcase 'a':\n\t\t\t\tstart_info[0].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tstart_info[1].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tstart_info[2].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tgoal_info[0].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tgoal_info[1].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tgoal_info[2].set(row,col);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch(N){\n\tcase 1:\n\t\tcalc1();\n\t\tbreak;\n\tcase 2:\n\t\tcalc2();\n\t\tbreak;\n\tcase 3:\n\t\tcalc3();\n\t\tbreak;\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&W,&H,&N);\n\t\tif(W == 0 && H == 0 && N == 0)break;\n\n\t\tgetchar();\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 14\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nint d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=INF;\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(n==1&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==2&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==3&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(n==1) nby=0, nbx=0;\n\tif(n>=2&&!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n\t  if(n<=2) ncy=0, ncx=0;\n      \t  if(n==3&&!check(ncy,ncx)) continue;\n      \n\t  if(n>=2&&!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(n==3&&!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(n==3&&!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(n>=2&&nay==nby&&nax==nbx) continue;\n\t  if(n==3&&nay==ncy&&nax==ncx) continue;\n\t  if(n==3&&nby==ncy&&nbx==ncx) continue;\n\n\t  if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\t    q.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n\t  }\n      \n\t}\n      }\n    }\n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n\n    ay=ax=by=bx=cy=cx=0;\n    \n    getline(cin,s[0]);\n    rep(i,h) getline(cin,s[i]);\n    \n    for(int i=0;i<h-2;i++){\n      s[i]=s[i+1];\n      s[i]=s[i].substr(1,w-2);\n      rep(j,w-2){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    h-=2;\n    w-=2;\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int short\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 10;\nconst ll mod=1000000007LL;\nconst int dx[]={1,0,-1,0,0};\nconst int dy[]={0,1,0,-1,0};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 16, M = 150;\nint w, h, n; \nvector<string> field;\nshort memo[M][M][M];\nint p2i[N][N];\nint i2x[M], i2y[M];\n\nusing State = tuple<int, int, int>;\nusing Elem  = tuple<int, State>;\n\ninline bool check(State pre, State cur){\n    int pp[3], cp[3];\n    tie(pp[0], pp[1], pp[2]) = pre;\n    tie(cp[0], cp[1], cp[2]) = cur;\n\n    // exchange\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(pp[i] == cp[j] and pp[j] == cp[i]){\n            return false;\n        }\n    }\n\n    // overlap\n    rep(i, 3){\n        int j = (i + 1) % 3;\n        if(i >= n or j >= n) continue;\n\n        if(cp[i] == cp[j]){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nsigned main(void){\n    for(;cin >> w >> h >> n, w;){\n        field = vector<string>(h);\n        cin.ignore();\n        for(auto & e : field) getline(cin, e);\n\n        i2x[0] = 0, i2y[0] = 0;\n        {\n            int cnt = 1;\n            rep(y, h){\n                rep(x, w){\n                    if(field[y][x] != '#'){\n                        p2i[y][x] = cnt;\n                        i2x[cnt] = x;\n                        i2y[cnt] = y;\n                        cnt++;\n                    }\n                    else p2i[y][x] = -1;\n                }\n            }\n        }\n        p2i[0][0] = 0;\n\n        State s = State(0, 0, 0), z = State(0, 0, 0);\n        rep(y, h){\n            rep(x, w){\n                int as, bs, cs, az, bz, cz;\n                tie(as, bs, cs) = s;\n                tie(az, bz, cz) = z;\n\n                switch(field[y][x]){\n                    case 'a': { as = p2i[y][x]; break; }\n                    case 'b': { bs = p2i[y][x]; break; }\n                    case 'c': { cs = p2i[y][x]; break; }\n                    case 'A': { az = p2i[y][x]; break; }\n                    case 'B': { bz = p2i[y][x]; break; }\n                    case 'C': { cz = p2i[y][x]; break; }\n                }\n                s = State(as, bs, cs);\n                z = State(az, bz, cz);\n            }\n        }\n\n        rep(i, M) rep(j, M) rep(k, M) memo[i][j][k] = inf;\n\n        queue<Elem> q;\n        q.push(Elem(0, s));\n\n        while(q.size()){\n            short cost; State cur;\n            tie(cost, cur) = q.front(); q.pop();\n            int ap, bp, cp; tie(ap, bp, cp) = cur;\n\n            short & ret = memo[ap][bp][cp];\n            if(ret != inf) continue;\n            ret = cost;\n\n            rep(i, 5){\n                int ax = i2x[ap] + dx[i], ay = i2y[ap] + dy[i];\n                if(p2i[ay][ax] == -1) continue;\n\n                rep(j, 5){\n                    if(n <= 1 and j <= 3) continue;\n\n                    int bx = i2x[bp] + dx[j], by = i2y[bp] + dy[j];\n                    if(p2i[by][bx] == -1) continue;\n\n                    rep(k, 5){\n                        if(n <= 2 and k <= 3) continue;\n\n                        int cx = i2x[cp] + dx[k], cy = i2y[cp] + dy[k];\n                        if(p2i[cy][cx] == -1) continue;\n\n                        State next = State(p2i[ay][ax], p2i[by][bx], p2i[cy][cx]);\n                        if(not check(cur, next)) continue;\n                        q.push(Elem(cost + 1, next));\n                    }\n                }\n            }\n        }\n\n        int az, bz, cz; tie(az, bz, cz) = z;\n        cout << memo[az][bz][cz] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cctype>\n#include <cstring>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\n\nconstexpr int dx[] = {-1, +0, +1, +0};\nconstexpr int dy[] = {+0, -1, +0, +1};\n\nint H, W, N;\nint dist[MAX_H][MAX_W][MAX_H][MAX_W];\n\nvoid bfs(const vector<int>& gx, const vector<int>& gy,\n         const vector<string>& field)\n{\n    memset(dist, 1, sizeof(dist));\n            \n    queue<tuple<int, int, int>> que;\n    for (int i = 0; i < N; i++) {\n        que.push(make_tuple(i, gx[i], gy[i]));\n        dist[gy[i]][gx[i]][gy[i]][gx[i]] = 0;   \n    }\n    \n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        int idx = get<0>(f), x = get<1>(f), y = get<2>(f);\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n                    \n            if (field[ny][nx] == '#') continue;\n\n            if (dist[gy[idx]][gx[idx]][y][x] + 1 < dist[gy[idx]][gx[idx]][ny][nx]) {\n                dist[gy[idx]][gx[idx]][ny][nx] = dist[gy[idx]][gx[idx]][y][x] + 1;\n                que.push(make_tuple(idx, nx, ny));\n            }\n        }\n    }\n}\n\nusing ll = long long;\n\nll v2l(const pair<vector<int>, vector<int>>& v)\n{\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        res += (v.first[i] + v.second[i] * W) * pow(H * W, i);\n    }\n    return res;\n}\n\npair<vector<int>, vector<int>> l2v(ll l)\n{\n    pair<vector<int>, vector<int>> v;\n    for (int i = 0; i < N; i++) {\n        int u = l % (H * W);\n        int x = u % W, y = u / W;\n        v.first.emplace_back(x);\n        v.second.emplace_back(y);\n        l /= (H * W);\n    }\n    return v;\n}\n\nbool valid(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 0;\n            }\n            if (nsx[i] == nsx[j] && nsy[i] == nsy[j]) {\n                return 0;\n            }\n        }       \n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nconst int LIMIT = 78;\n\nint bfs(const vector<string>& field,\n         const vector<int>& sx, const vector<int>& sy,\n         const vector<int>& gx,  const vector<int>& gy)\n{\n    ll s = v2l(make_pair(sx, sy));\n    \n    queue<ll> que;   \n    que.push(s);\n\n    unordered_map<ll, int> d;\n    d[s] = 0;        \n    \n    while (!que.empty()) {\n        ll f = que.front(); que.pop();\n        auto nf = l2v(f);\n        vector<int> csx = nf.first, csy = nf.second;\n        \n        int max_dist = 0, sum_dist = 0;\n        for (int i = 0; i < N; i++) {\n            max_dist = max(max_dist, dist[gy[i]][gx[i]][csy[i]][csx[i]]);\n            sum_dist += dist[gy[i]][gx[i]][csy[i]][csx[i]];\n        }\n        if (sum_dist == 0) return d[f];\n        if (d[f] + max_dist > LIMIT) continue;\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (!valid(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            ll next = v2l(make_pair(nsx, nsy));\n            if (d.count(next) == 0) {                \n                d[next] = d[f] + 1;                \n                que.push(next);\n            }\n        }\n    }    \n    return 0;\n}\n\nint main()\n{       \n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();        \n        \n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n        \n        bfs(gx, gy, field);\n        cout << bfs(field, sx, sy, gx, gy) << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost += ev[p.p[i]][goal[i]];\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(55);\n      makeEv();\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,n;\nshort dx[]={0,0,0,1,-1};\nshort dy[]={0,1,-1,0,0};\nstring mp[20];\n\nstruct dat{\n  short y1,x1;\n  short y2,x2;\n  short y3,x3;\n};\n\n\nshort D[14][14][15][15][15][15];\nqueue<dat> Q;\nvoid DD(dat &a,short b){D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1] = b;}\nshort DD(const dat &a){return D[a.y1-1][a.x1-1][a.y2-1][a.x2-1][a.y3-1][a.x3-1];}\n\nbool check(const dat &a){\n  if(mp[a.y1][a.x1]=='#') return 0;\n  if(n>=2&&mp[a.y2][a.x2]=='#') return 0;\n  if(n>=3&&mp[a.y3][a.x3]=='#') return 0;\n  return DD(a)==-1;\n}\n\nvoid update(const dat &a){\n  short cost = DD(a);\n\n  for(int i=0;i<5;i++){\n    short ny1 = a.y1+dy[i], nx1 = a.x1+dx[i];\n    for(int j=0;j<5;j++){\n      short ny2 = a.y2+dy[j], nx2 = a.x2+dx[j];\n      if(n<=1) ny2 = 15,nx2 = 14;\n      for(int k=0;k<5;k++){\n\tshort ny3 = a.y3+dy[k], nx3 = a.x3+dx[k];\n\tif(n<=2) ny3 = 14,nx3 = 15;\n\n\tdat nt = (dat){ny1,nx1,ny2,nx2,ny3,nx3};\n\tif(!check(nt))continue;\n\t\n\tif((ny1==ny2&&nx1==nx2) ||(ny2==ny3&&nx2==nx3) ||(ny3==ny1&&nx3==nx1))continue;//same pos\n\tif(((a.y1==ny2&&a.x1==nx2) && (a.y2==ny1&&a.x2==nx1)) || // swap positoin\n\t   ((a.y2==ny3&&a.x2==nx3) && (a.y3==ny2&&a.x3==nx2)) ||\n\t   ((a.y3==ny1&&a.x3==nx1) && (a.y1==ny3&&a.x1==nx3)) )continue;\n\t\n\tQ.push(nt);\n\tDD(nt,cost+1);\n      }\n    }\n  }\n}\n\nbool goal(const dat &s,const dat &t){\n  char a = mp[s.y1][s.x1];\n  char b = mp[s.y2][s.x2];\n  char c = mp[s.y3][s.x3];\n  char A = mp[t.y1][t.x1];\n  char B = mp[t.y2][t.x2];\n  char C = mp[t.y3][t.x3];\n  return toupper(a)==A&&(n<=1||toupper(b)==B)&&(n<=2||toupper(c)==C);\n}\n\nint bfs(dat start){\n  memset(D,-1,sizeof(D));\n  while(!Q.empty())Q.pop();\n  Q.push(start);\n  DD(start,0);\n  \n  while(!Q.empty()){\n    dat t = Q.front();Q.pop();\n    if(goal(start,t)) return DD(t);\n    update(t);\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>w>>h>>n;\n  if(!w&&!h&&!n)break;\n  cin.ignore();\n  for(int i=0;i<h;i++)getline(cin,mp[i]),mp[i]+='#';\n  \n  dat start = (dat){15,15,15,14,14,15};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!islower(mp[i][j]))continue;\n      if(start.y1==15) start.y1=i,start.x1=j;\n      else if(start.y2==15) start.y2=i,start.x2=j;\n      else start.y3=i,start.x3=j;\n    }\n  cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tint x[3],y[3];\n\tint v;\n\tdata(){}\n};\n\nint dx[5]={0,1,-1,0,0};\nint dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nint fie[16][16];\nint sx[3],sy[3];\nint gx[3],gy[3];\nbool dp[256][256][256];\nint move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tst.v=0;\n\tmemset(dp,false,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]*w+st.x[2]]=true;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tdata nd=d;\n\t\t\tnd.v=d.v+1;\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]+=dx[pi%5];\n\t\t\t\tnd.y[j]+=dy[pi%5];\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t\tif(flag && fie[nd.y[j]][nd.x[j]]==-1)flag=false;\n\t\t\t}\n\t\t\tif(!flag)continue;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tint nv[3];\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tnv[j]=nd.x[j]+nd.y[j]*w;\n\t\t\t\t}\n\t\t\t\tif(!dp[nv[0]][nv[1]][nv[2]]){\n\t\t\t\t\tbool goal=true;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(goal){\n\t\t\t\t\t\treturn d.v+1;\n\t\t\t\t\t}\n\t\t\t\t\tdp[nv[0]][nv[1]][nv[2]]=true;\n\t\t\t\t\tque.push(nd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i][j]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j;\n\t\t\t\t\tsy[(str-'A')]=i;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j;\n\t\t\t\t\tgy[(str-'a')]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n#pragma GCC target \"tune=native\"\n#pragma GCC target \"avx\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\n\nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n\narray<short, 1 << 24> dist;\n\nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n    \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n    \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n\n    int last_hash = last.hash();\n\n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                    \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {0,0}, {-1,0}, {1,0}, {0,1}, {0,-1} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        unordered_set<uint32_t> used;\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used.insert(encode(start));\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i, 5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j, n >= 2 ? 5 : 1) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k, n >= 3 ? 5 : 1) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used.count(encode(t))) continue;\n                        used.insert(encode(t));\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\t//v = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\ts.clear();\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\twhile(!q.empty()) q.pop();\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\t//free(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tchar x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint h,w,n;\nchar G[MAX][MAX];\nshort ev[MAX*MAX][MAX*MAX];\nshort mincost[MAX*MAX][MAX*MAX][MAX*MAX];\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint goal[3],sp[3];\nchar cc[3];\n\nstruct Pox\n{\n  int cur[3];\n  short cost;\n  Pox(int a=255,int b=255,int c=255,short cost=1000):cost(cost)\n  {\n    cur[0] = a, cur[1] = b, cur[2] = c;\n  }\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nbool fin_check(int *cur)\n{\n  rep(i,n)if(cur[i] != goal[i])return false;\n  return true;\n}\n\nvoid compute()\n{\n  rep(i,MAX*MAX)rep(j,MAX*MAX)rep(k,MAX*MAX)mincost[i][j][k] = 1000;\n\n  priority_queue<Pox> Q;\n  mincost[sp[0]][sp[1]][sp[2]] = 1000;\n  Q.push(Pox(sp[0],sp[1],sp[2],0));\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n\n      if(fin_check(pox.cur))\n\t{\n\t  cout << (int)pox.cost << endl;\n\t  return;\n\t}\n\n\n      if(n == 1)\n\t{\n\t  int x = pox.cur[0] % w;\n\t  int y = pox.cur[0] / w;\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\n\n\t      if(mincost[nx+ny*w][0][0] > (pox.cost + 1))\n\t\t{\n\t\t  mincost[nx+ny*w][0][0] = pox.cost + 1;\n\t\t  Pox next = Pox(nx+ny*w,0,0,pox.cost+1);\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  int x1 = pox.cur[0] % w;\n\t  int y1 = pox.cur[0] / w;\n\t  int x2 = pox.cur[1] % w;\n\t  int y2 = pox.cur[1] / w;\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx1+ny1*w,pox.cur[1],nx2+ny2*w))continue;\n\n\t\t  if(mincost[nx1+ny1*w][nx2+ny2*w][0] > (pox.cost + 1))\n\t\t    {\n\t\t      mincost[nx1+ny1*w][nx2+ny2*w][0] = pox.cost + 1;\n\t\t      Q.push(Pox(nx1+ny1*w,nx2+ny2*w,0,pox.cost+1));\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = pox.cur[i] % w, y[i] = pox.cur[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(pox.cur[1],nx[1]+ny[1]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\n\t\t      if(mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] > (pox.cost + 1))\n\t\t\t{\n\t\t\t  mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] = pox.cost + 1;\n\t\t\t  Q.push(Pox(nx[0]+ny[0]*w,nx[1]+ny[1]*w,nx[2]+ny[2]*w,pox.cost+1));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),h|w|n)\n    {\n      rep(i,3)sp[i] = 0;\n      int cd = 0;\n      map<char,int> dex;\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    {\n\t      scanf(\"%c\",&G[i][j]);\n\t      dex[G[i][j]] = j + i * w;\n\t      if('a' <= G[i][j] && G[i][j] <= 'z')\n\t\t{\n\t\t  sp[cd] = j + i * w;\n\t\t  cc[cd++] = G[i][j];\n\t\t}\n\t    }\n\t}\n      assert(n == cd);\n      rep(i,n)goal[i] = dex['A'+cc[i]-'a'];\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: Oct 11, 2013\n *      Author: Hesham\n */\n#include<iostream>\n#include<string>\n#include<map>\n#include<ctime>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<algorithm>\n#include<sstream>\n#include<iomanip>\n#include<cstring>\n#include<bitset>\n#include<fstream>\n#include<cmath>\n#include<cassert>\n#include <stdio.h>\n#include<ctype.h>\nusing namespace std;\nint dx[] = { 0, 0, 1, -1, 0 };\nint dy[] = { 0, 1, 0, 0, -1 };\nint w, h, n;\nstring house[16];\nstruct State {\n\tvector<int> y, x;\n\tState() {\n\t\tx.resize(3, 0);\n\t\ty.resize(3, 0);\n\t}\n\tState(vector<int>& yy, vector<int>& xx) :\n\t\t\tx(xx), y(yy) {\n\t}\n\tbool operator ==(const State& other) const {\n\t\treturn x == other.x && y == other.y;\n\t}\n};\nbool vis1[16][16][16][16][16][16];\nbool vis2[16][16][16][16][16][16];\nshort dist[16][16][16][16][16][16];\n\nbool isVis(State& s, bool vis[16][16][16][16][16][16]) {\n\treturn vis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setVis(State& s, bool vis[16][16][16][16][16][16]) {\n\tvis[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = true;\n}\nint getDist(State& s) {\n\treturn dist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]];\n}\nvoid setDist(State& s, int v) {\n\tdist[s.x[0]][s.x[1]][s.x[2]][s.y[0]][s.y[1]][s.y[2]] = v;\n}\n\nbool ok(int y, int x) {\n\tif (y < 0 || y == h || x < 0 || x == w)\n\t\treturn false;\n\tif (house[y][x] == '#')\n\t\treturn false;\n\treturn true;\n}\nint pushAdjs(int i, State& adj, State& curr, queue<State>& q,\n\t\tbool visA[16][16][16][16][16][16], bool visB[16][16][16][16][16][16]) {\n\tif (i == n) {\n\t\tif (isVis(adj, visA))\n\t\t\treturn -1;\n\t\tif (isVis(adj, visB))\n\t\t\treturn getDist(curr) + 1 + getDist(adj);\n\t\tsetDist(adj, getDist(curr) + 1);\n\t\tsetVis(adj, visA);\n\t\tq.push(adj);\n\t\treturn -1;\n\t}\n\tfor (int d = 0; d < 5; ++d) {\n\t\tadj.y[i] = dy[d] + curr.y[i];\n\t\tadj.x[i] = dx[d] + curr.x[i];\n\t\tif (!ok(adj.y[i], adj.x[i]))\n\t\t\tcontinue;\n\t\tbool okk = true;\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (adj.y[i] == curr.y[j] && adj.x[i] == curr.x[j]&&\n\t\t\t    adj.y[j] == curr.y[i] && adj.x[j] == curr.x[i]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (adj.y[i] == adj.y[j] && adj.x[i] == adj.x[j]) {\n\t\t\t\tokk = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!okk)\n\t\t\tcontinue;\n\t\tint cost = pushAdjs(i + 1, adj, curr, q, visA, visB);\n\t\tif (cost != -1)\n\t\t\treturn cost;\n\t}\n\treturn -1;\n}\nint meetMiddle(vector<int>& sy, vector<int>& sx, vector<int>& ty,\n\t\tvector<int>& tx) {\n\tmemset(vis1, false, sizeof vis1);\n\tmemset(vis2, false, sizeof vis2);\n\tState s(sy, sx);\n\tState t(ty, tx);\n\tsetDist(s, 0);\n\tsetDist(t, 0);\n\tsetVis(s, vis1);\n\tsetVis(t, vis2);\n\tqueue<State> q1;\n\tqueue<State> q2;\n\tq1.push(s);\n\tq2.push(t);\n\twhile (true) {\n\t\t{\n\t\t\tState curr1 = q1.front();\n\t\t\tq1.pop();\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr1, q1, vis1, vis2);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t}\n\t\t{\n\t\t\tState curr2 = q2.front();\n\t\t\tq2.pop();\n\t\t\tState adj;\n\t\t\tint cost = pushAdjs(0, adj, curr2, q2, vis2, vis1);\n\t\t\tif (cost != -1)\n\t\t\t\treturn cost;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//clock_t begin = clock();\n\tstring line;\n\twhile (cin >> w >> h >> n) {\n\t\tif (!w && !h && !n)\n\t\t\tbreak;\n\t\tcin.ignore();\n\t\t//cin.ignore();\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tgetline(cin, house[i]);\n\n\t\tvector<int> sx(3, 0);\n\t\tvector<int> sy(3, 0);\n\n\t\tvector<int> tx(3, 0);\n\t\tvector<int> ty(3, 0);\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (house[i][j] >= 'A' && house[i][j] <= 'C') {\n\t\t\t\t\ttx[(house[i][j] - 'A')] = j;\n\t\t\t\t\tty[(house[i][j] - 'A')] = i;\n\t\t\t\t}\n\t\t\t\tif (house[i][j] >= 'a' && house[i][j] <= 'c') {\n\t\t\t\t\tsx[(house[i][j] - 'a')] = j;\n\t\t\t\t\tsy[(house[i][j] - 'a')] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << meetMiddle(sy, sx, ty, tx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,0};\nconst int dy[8]={0,1,0,-1,0};\n\nconst int limit=1<<24;\nusing S=short int;\nS dist[limit];\n\ninline int hstar(int n,int cmask,int tmask){\n\tint cy[3],cx[3],ty[3],tx[3];\n\tint ret=0;\n\trep(i,n){\n\t\tcx[i]=cmask&15;\n\t\tcmask>>=4;\n\t\tcy[i]=cmask&15;\n\t\tcmask>>=4;\n\n\t\ttx[i]=tmask&15;\n\t\ttmask>>=4;\n\t\tty[i]=tmask&15;\n\t\ttmask>>=4;\n\n\t\tchmax(ret,abs(cy[i]-ty[i])+abs(cx[i]-tx[i]));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint w,h,n;\n\t\n\twhile(cin >> w >> h >> n,n){\n\t\tint smask=0,tmask=0;\n\t\tstring board[16];\n\t\t\n\t\tcin.ignore();\n\t\trep(i,h) getline(cin,board[i]);\n\n\t\t// cout << w << \" \" << h << \" \" << n << endl;\n\t\t// rep(i,h) cout << board[i] << endl;\n\n\t\trep(i,h)rep(j,w)rep(k,3){\n\t\t\tif(board[i][j]==('a'+k)) smask|=((16*i+j)<<(8*k));\n\t\t\tif(board[i][j]==('A'+k)) tmask|=((16*i+j)<<(8*k));\n\t\t}\n\n\t\tfill(dist,dist+limit,30000);\n\t\tdist[smask]=0;\n\t\tusing state=tuple<S,int>;\n\t\tpriority_queue<state,vector<state>,greater<state>> q;\n\t\tq.push(state(0,smask));\n\n\t\twhile(!q.empty()){\n\t\t\tint cost,cmask;\n\t\t\ttie(cost,cmask)=q.top();q.pop();\n\n\t\t\tif(dist[tmask]!=30000) break;\n\n\t\t\tint cy[3],cx[3],tmp=cmask;\n\t\t\trep(i,n){\n\t\t\t\tcx[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t\tcy[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t}\n\n\t\t\tconst int all=pow<int>(5,n);\n\n\t\t\trep(mask,all){\n\t\t\t\tconst int didx[3]={mask%5,mask/5%5,mask/25};\n\t\t\t\tint ny[3],nx[3];\n\t\t\t\trep(i,n){\n\t\t\t\t\tny[i]=cy[i]+dy[didx[i]];\n\t\t\t\t\tnx[i]=cx[i]+dx[didx[i]];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n) if(board[ny[i]][nx[i]]=='#') ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==ny[j] && nx[i]==nx[j] ) ok=false;\n\t\t\t\tif(ok==false) continue;\n\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==cy[j] && nx[i]==cx[j] && ny[j]==cy[i] && nx[j]==cx[i]) ok=false;\n\t\t\t\tif(ok==false) continue;\n\n\n\t\t\t\tint nmask=0;\n\t\t\t\trep(i,n) nmask|=(16*ny[i]+nx[i])<<(8*i);\n\n\t\t\t\tif(chmin<S>(dist[nmask],dist[cmask]+1)) q.push(state(dist[nmask]+hstar(n,nmask,tmask),nmask));\t\t\n\t\t\t}\n\n\t\t}\n\t\tcout << dist[tmask] << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= 16;\n            ret += y[i];\n            ret *= 16;\n            ret += x[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    vector<int> sy(n), sx(n), gy(n), gx(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sy[c-'a'] = i;\n                sx[c-'a'] = j;\n            }else if('A' <= c && c <= 'C'){\n                gy[c-'A'] = i;\n                gx[c-'A'] = j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= 16 * 16;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sy, sx, 0).toInt()] = true;\n    check[1][Data(gy, gx, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sy, sx, 0));\n    dq[1].push_back(Data(gy, gx, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.y[i] += dy[j];\n                d.x[i] += dx[j];\n\n                bool ok = true;\n                if(grid[d.y[i]][d.x[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.y[i] -= dy[j];\n                d.x[i] -= dx[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            if(check[turn^1][a])\n                return ret;\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\n\nconstexpr int dx[4] = {-1, +0, +1, +0};\nconstexpr int dy[4] = {+0, -1, +0, +1};\n\nint N;\n\nbool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvector<int> get_dirs(int x)\n{\n    vector<int> res;\n    while ((int)res.size() != N) {\n        res.emplace_back(x % 5);\n        x /= 5;\n    }    \n    return res;\n}\n\nbool same(const vector<int>& sx, const vector<int>& sy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == sx[j] && sy[i] == sy[j]) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool is_swap(const vector<int>& sx,  const vector<int>& sy,\n             const vector<int>& nsx, const vector<int>& nsy)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (sx[i] == nsx[j] && sy[i] == nsy[j] &&\n                sx[j] == nsx[i] && sy[j] == nsy[i]) {\n                return 1;\n            }\n        }       \n    }\n    return 0;\n}\n\nvoid print(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        cout << i << \" \" << sx[i] << \" \" << sy[i] << \" \" << gx[i] << \" \" << gy[i] << endl;  \n    }\n    cout << endl;\n}\n\nusing ull = unsigned long long;\n\nclass Hash {\n  public:\n    size_t operator () (const pair<vector<int>, vector<int>>& v) const\n    {\n        const ull B = 100000007LL;\n        ull r = 0;\n        for (int i = 0; i < N; i++) {            \n            r = r * B + (v.first[i] * 16 + v.second[i]);\n        }\n        return r;\n    }\n};\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;    \n    que.push(make_pair(sx, sy));\n\n    unordered_map<pair<vector<int>, vector<int>>, int, Hash> d;\n    d[make_pair(sx, sy)] = 0;    \n    \n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        auto csx = f.first, csy = f.second;\n        \n        if (reach(csx, csy, gx, gy)) {\n            return d[f];\n        }\n        \n        for (int i = 0; i < pow(5, N) - 1; i++) {\n            vector<int> nsx = csx, nsy = csy, nd = get_dirs(i);\n            bool can_move = 1;\n            for (int j = 0; j < N; j++) {\n                if (nd[j] == 4) continue;\n                int nx = csx[j] + dx[nd[j]], ny = csy[j] + dy[nd[j]];                                \n                if (field[ny][nx] == '#') {\n                    can_move = 0;\n                    break;\n                }                \n                nsx[j] = nx; nsy[j] = ny;\n            }\n            if (same(nsx, nsy) || is_swap(csx, csy, nsx, nsy)) {\n                can_move = 0;\n            }            \n            if (!can_move) continue;\n            \n            auto next = make_pair(nsx, nsy);\n            if (d.count(next) == 0) {\n                d[next] = d[f] + 1;\n                que.push(next);\n            }\n        }\n    }    \n    return -1;\n}\n\nint main()\n{\n    int W, H;\n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        cout << bfs(field, sx, sy, gx, gy) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool v[256*256*256];\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.1 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\nS i2s(int x){\n  return S(x/2744,x%2744);\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first*2744)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+p.first[i]-1;\n    x=x*14+p.second[i]-1;\n  }\n  return S(y,x);\n}\n\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%14+1);\n    x.push_back(b%14+1);\n    a/=14;b/=14;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nint m[7530000];\nqueue<int> q;\n\nvector<int> ys,xs;\n\nint calc(){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+ys[i]-1;\n    x=x*14+xs[i]-1;\n  }\n  return s2i(S(y,x));\n}\n\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    int abc=calc();\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000;\nconst int MAX_W = 16;\nconst int dy[] = {1,-1,0,0,0}, dx[] = {0,0,1,-1,0};\n\nint W, H, N;\nint GY[3], GX[3], SY[3], SX[3];\nchar board[MAX_W][MAX_W + 1];\nint distFromGoal[3][MAX_W][MAX_W];\nunsigned short dist[MAX_W][MAX_W][MAX_W][MAX_W][MAX_W][MAX_W];\n\nstruct State {\n\tunsigned short dist;\n\tint y[3], x[3];\n\n\tState(){}\n\tState(unsigned short dist, int y_[3], int x_[3]):\n\t\tdist(dist)\n\t{\n\t\tmemcpy(y, y_, sizeof(y));\n\t\tmemcpy(x, x_, sizeof(x));\n\t}\n};\n\nbool operator> (const State& lhs, const State& rhs) {\n\treturn lhs.dist > rhs.dist;\n}\n\ninline int getDist(int y0, int x0, int id) {\n\treturn distFromGoal[id][y0][x0];\n}\n\ninline int getDist(int y[3], int x[3]) {\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tans = max(ans, getDist(y[i], x[i], i));\n\t}\n\treturn ans;\n}\n\nbool init() {\n\tscanf(\"%d%d%d \", &W, &H, &N);\n\tfor (int i = 0; i < H; ++i ) {\n\t\tscanf(\"%[^\\n]%*c\", board[i]);\n\t}\n\treturn H > 0;\n}\n\nvoid dfs(int y[3], int x[3], int ny[3], int nx[3], int depth, int d, priority_queue<State, vector<State>, greater<State> > &que) {\n\tif (depth == N) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (ny[i] == ny[j] && nx[i] == nx[j]) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tif (y[i] == ny[j] && x[i] == nx[j] && y[j] == ny[i] && x[j] == nx[i]) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst int nd = d - getDist(y, x) + getDist(ny, nx) + 1;\n\t\tif (nd < dist[ny[0]][nx[0]][ny[1]][nx[1]][ny[2]][nx[2]]) {\n\t\t\tdist[ny[0]][nx[0]][ny[1]][nx[1]][ny[2]][nx[2]] = nd;\n\t\t\tque.push(State(nd, ny, nx));\n\t\t}\n\n\t\treturn ;\n\t}\n\tfor (int k = 0; k < 5; ++k) {\n\t\tny[depth] = y[depth] + dy[k], nx[depth] = x[depth] + dx[k];\n\t\tif ( 0 <= ny[depth] && ny[depth] < H && 0 <= nx[depth] && nx[depth] < W && board[ny[depth]][nx[depth]] != '#') {\n\t\t\tdfs(y, x, ny, nx, depth + 1, d, que);\n\t\t}\n\t}\n}\n\n\nint solve() {\n\t\n\tmemset(GY, 0, sizeof(GY));\n\tmemset(GX, 0, sizeof(GX));\n\tmemset(SY, 0, sizeof(SY));\n\tmemset(SX, 0, sizeof(SX));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (isupper(board[i][j])) {\n\t\t\t\tconst int id = board[i][j] - 'A';\n\t\t\t\tGY[id] = i;\n\t\t\t\tGX[id] = j;\n\t\t\t\tboard[i][j] = ' ';\n\t\t\t}\n\t\t\tif (islower(board[i][j])) {\n\t\t\t\tconst int id = board[i][j] - 'a';\n\t\t\t\tSY[id] = i;\n\t\t\t\tSX[id] = j;\n\t\t\t\tboard[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (int k = 0; k < N; ++k) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfill(distFromGoal[k][i], distFromGoal[k][i] + W, INF);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tqueue<pair<int,int> > que;\n\t\tque.push(make_pair(GY[i], GX[i]));\n\t\tdistFromGoal[i][GY[i]][GX[i]] = 0;\n\t\tfor (;!que.empty();) {\n\t\t\tpair<int,int> tp = que.front(); que.pop();\n\t\t\tconst int y = tp.first, x = tp.second;\n\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\tconst int ny = y + dy[k], nx = x + dx[k];\n\t\t\t\tif ( 0 <= ny && ny < H && 0 <= nx && nx < W && board[ny][nx] != '#' && distFromGoal[i][ny][nx] == INF) {\n\t\t\t\t\tdistFromGoal[i][ny][nx] = distFromGoal[i][y][x] + 1;\n\t\t\t\t\tque.push(make_pair(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tmemset(dist, ~0, sizeof(dist));\n\tpriority_queue<State, vector<State>, greater<State> > que;\n\tint initValue = getDist(SY, SX);\n\tque.push(State(initValue, SY, SX));\n\tdist[SY[0]][SX[0]][SY[1]][SX[1]][SY[2]][SX[2]] = initValue;\n\n\tfor (;!que.empty();) {\n\t\tState tp = que.top(); que.pop();\n\t\tint y[3], x[3];\n\t\tmemcpy(y, tp.y, sizeof(y));\n\t\tmemcpy(x, tp.x, sizeof(x));\n\t\tif (dist[y[0]][x[0]][y[1]][x[1]][y[2]][x[2]] < tp.dist) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t{\n\t\t\tbool cut = true;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) if (i != j) {\n\t\t\t\t\tcut &= distFromGoal[i][y[i]][x[i]] < distFromGoal[i][y[j]][x[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cut) {\n\t\t\t\treturn int(tp.dist);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint ny[3], nx[3];\n\t\tmemcpy(ny, tp.y, sizeof(ny));\n\t\tmemcpy(nx, tp.x, sizeof(nx));\n\t\tdfs(y, x, ny, nx, 0, tp.dist, que);\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\tfor (;init();) {\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\n//bool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\t//v = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\t//memset(v, 0, sizeof(v));\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\ts.clear();\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\twhile(!q.empty()) q.pop();\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\t//free(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long  ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nbool isalf(char t) {\n\tif ('a' <= t && t <= 'z')return true;\n\treturn false;\n}\nbool isAlf(char t) {\n\tif ('A' <= t && t <= 'Z')return true;\n\treturn false;\n}\n\nint h, w, n;\nbool used[256][256][256];\nchar mp[16][16];\nvoid solve() {\n\tint sx[3] = {}, sy[3] = {}, gx[3] = {}, gy[3] = {};\n\tstring s; getline(cin, s);\n\trep(i, h) {\n\t\tgetline(cin, s);\n\t\trep(j, w) {\n\t\t\tmp[i][j] = s[j];\n\t\t\tif (isalf(s[j])) {\n\t\t\t\tint z = s[j] - 'a';\n\t\t\t\tsx[z] = i, sy[z] = j;\n\t\t\t}\n\t\t\telse if (isAlf(s[j])) {\n\t\t\t\tint z = s[j] - 'A';\n\t\t\t\tgx[z] = i, gy[z] = j;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<vec> q;\n\trep(i, h*w)rep(j, h*w)rep(k, h*w)used[i][j][k] = false;\n\tint cs[3];\n\tint cg[3];\n\trep(i, 3)cs[i] = sx[i] * w + sy[i];\n\trep(i, 3)cg[i] = gx[i] * w + gy[i];\n\t//rep(i, c)cout << cs[i] << endl;\n\tused[cs[0]][cs[1]][cs[2]] = true;\n\tq.push({ cs[0] , cs[1], cs[2] });\n\tint tmp = 0;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\trep(aa, len) {\n\t\t\tvec v = q.front(); q.pop();\n\t\t\tif (v == vec{cg[0], cg[1], cg[2]}) {\n\t\t\t\tcout << tmp << endl; return;\n\t\t\t}\n\t\t\tint nx[3], ny[3],nz[3];\n\t\t\trep(i, 9) {\n\t\t\t\tif (i % 2 == 0 && i != 4)continue;\n\t\t\t\tnx[0] = v[0] / w + i%3 - 1;\n\t\t\t\tny[0] = v[0] % w + i/3 - 1;\n\t\t\t\tnz[0] = nx[0] * w + ny[0];\n\t\t\t\tif (mp[nx[0]][ny[0]] == '#')continue;\n\t\t\t\tif (n == 1) {\n\t\t\t\t\tif (used[nz[0]][0][0])continue;\n\t\t\t\t\tused[nz[0]][0][0] = true;\n\t\t\t\t\tq.push({ nz[0],0,0 });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(j, 9) {\n\t\t\t\t\tif (j % 2 == 0 && j != 4)continue;\n\t\t\t\t\tnx[1] = v[1] / w + j % 3 - 1;\n\t\t\t\t\tny[1] = v[1] % w + j / 3 - 1;\n\t\t\t\t\tnz[1] = nx[1] * w + ny[1];\n\t\t\t\t\tif (mp[nx[1]][ny[1]] == '#')continue;\n\t\t\t\t\tif (nz[0] == nz[1])continue;\n\t\t\t\t\tif (nz[0] == v[1] && v[0] == nz[1])continue;\n\t\t\t\t\tif (n == 2) {\n\t\t\t\t\t\tif (used[nz[0]][nz[1]][0])continue;\n\t\t\t\t\t\tused[nz[0]][nz[1]][0] = true;\n\t\t\t\t\t\tq.push({ nz[0],nz[1],0 });\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trep(k, 9) {\n\t\t\t\t\t\tif (k % 2 == 0 && k != 4)continue;\n\t\t\t\t\t\tnx[2] = v[2] / w + k % 3 - 1;\n\t\t\t\t\t\tny[2] = v[2] % w + k / 3 - 1;\n\t\t\t\t\t\tnz[2] = nx[2] * w + ny[2];\n\t\t\t\t\t\tif (mp[nx[2]][ny[2]] == '#')continue;\n\t\t\t\t\t\t\tif (used[nz[0]][nz[1]][nz[2]])continue;\n\t\t\t\t\t\t\tif (nz[0] == nz[2]||nz[1]==nz[2])continue;\n\t\t\t\t\t\t\tif (nz[0] == v[2] && v[0] == nz[2])continue;\n\t\t\t\t\t\t\tif (nz[1] == v[2] && v[1] == nz[2])continue;\n\t\t\t\t\t\t\tused[nz[0]][nz[1]][nz[2]] = true;\n\t\t\t\t\t\t\tq.push({ nz[0],nz[1],nz[2] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp++;\n\t}\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\twhile (cin >> w>>h>>n,n)solve();\n\t//solve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h;\n            ret += y[i];\n            ret *= w;\n            ret += x[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    vector<int> sy(n), sx(n), gy(n), gx(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sy[c-'a'] = i;\n                sx[c-'a'] = j;\n            }else if('A' <= c && c <= 'C'){\n                gy[c-'A'] = i;\n                gx[c-'A'] = j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= h * w;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sy, sx, 0).toInt()] = true;\n    check[1][Data(gy, gx, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sy, sx, 0));\n    dq[1].push_back(Data(gy, gx, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.y[i] += dy[j];\n                d.x[i] += dx[j];\n\n                bool ok = true;\n                if(grid[d.y[i]][d.x[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.y[i] -= dy[j];\n                d.x[i] -= dx[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            if(check[turn^1][a])\n                return ret;\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\nS i2s(int x){\n  return S(x/2744,x%2744);\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first*2744)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+p.first[i]-1;\n    x=x*14+p.second[i]-1;\n  }\n  return S(y,x);\n}\n\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%14+1);\n    x.push_back(b%14+1);\n    a/=14;b/=14;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nchar m[7530000];\nqueue<int> q;\n\nvector<int> ys,xs;\n\nint calc(){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*14+ys[i]-1;\n    x=x*14+xs[i]-1;\n  }\n  return s2i(S(y,x));\n}\n\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    int abc=calc();\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint h,w,n;\nchar G[MAX][MAX];\n//unsigned char ev[MAX*MAX][MAX*MAX];\n//unsigned char mincost[MAX*MAX][MAX*MAX][MAX*MAX];\nshort ev[MAX*MAX][MAX*MAX];\nshort mincost[MAX*MAX][MAX*MAX][MAX*MAX];\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint goal[3],sp[3];\nchar cc[3];\n\nstruct Pox\n{\n  int cur[3];\n  //unsigned char cost;\n  short cost;\n  Pox(int a=255,int b=255,int c=255,/*unsigned char*/short cost=1000/*255*/):cost(cost)\n  {\n    cur[0] = a, cur[1] = b, cur[2] = c;\n  }\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)cout << a[i][j];\n      cout << endl;\n    }\n  cout << endl;\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\n\nvoid initEv()\n{\n  rep(y,h*w)rep(x,h*w)ev[y][x] = 1000;//255;\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[x+y*w][x+y*w] = 0;\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  rep(i,4)\n\t    {\n\t      int nx = cx + dx[i];\n\t      int ny = cy + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t\t{\n\t\t  ev[x+y*w][nx+ny*w] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nbool fin_check(int *cur)\n{\n  rep(i,n)if(cur[i] != goal[i])return false;\n  return true;\n}\n\nvoid compute()\n{\n  /*\n  rep(i,n)\n    {\n      cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }\n  */\n  rep(i,MAX*MAX)rep(j,MAX*MAX)rep(k,MAX*MAX)mincost[i][j][k] = 1000;//(unsigned char)255;\n\n  priority_queue<Pox> Q;\n  mincost[sp[0]][sp[1]][sp[2]] = 1000;//(unsigned char)0;\n  Q.push(Pox(sp[0],sp[1],sp[2],0));\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n\n      //      cout << \"pox ( ( \" << pox.cur[0] << \" \" << pox.cur[0] % w << \",\" << pox.cur[0] / w << \") ( \" << pox.cur[1] % w << \",\" << pox.cur[1] / w << \" ) ) : \" << (int)pox.cost << \" \\n\"; \n\n      if(fin_check(pox.cur))\n\t{\n\t  cout << (int)pox.cost << endl;\n\t  return;\n\t}\n\n\n      if(n == 1)\n\t{\n\t  int x = pox.cur[0] % w;\n\t  int y = pox.cur[0] / w;\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\n\t      //cout << \"mincost[\" << pox.cur[0] << \"][0][0] = \" << (int)mincost[pox.cur[0]][0][0] << \" > \" << (pox.cost + 1) << endl;\n\n\t      if(mincost[nx+ny*w][0][0] > /*(unsigned char)*/(pox.cost + 1))\n\t\t{\n\t\t  mincost[nx+ny*w][0][0] = pox.cost + 1;\n\t\t  Pox next = Pox(nx+ny*w,0,0,pox.cost+1);\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  int x1 = pox.cur[0] % w;\n\t  int y1 = pox.cur[0] / w;\n\t  int x2 = pox.cur[1] % w;\n\t  int y2 = pox.cur[1] / w;\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx1+ny1*w,pox.cur[1],nx2+ny2*w))continue;\n\t\t  //cout << \"here : \" << (int)mincost[nx1+ny1*w][nx2+ny2*w][0] << \" > \" << pox.cost + 1 << endl;\n\n\t\t  if(mincost[nx1+ny1*w][nx2+ny2*w][0] > /*(unsigned char)*/(pox.cost + 1))\n\t\t    {\n\t\t      mincost[nx1+ny1*w][nx2+ny2*w][0] = pox.cost + 1;\n\t\t      Q.push(Pox(nx1+ny1*w,nx2+ny2*w,0,pox.cost+1));\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = pox.cur[i] % w, y[i] = pox.cur[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(pox.cur[0],nx[0]+ny[0]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(pox.cur[1],nx[1]+ny[1]*w,pox.cur[2],nx[2]+ny[2]*w))continue;\n\n\t\t      if(mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] > /*(unsigned char)*/(pox.cost + 1))\n\t\t\t{\n\t\t\t  mincost[nx[0]+ny[0]*w][nx[1]+ny[1]*w][nx[2]+ny[2]*w] = pox.cost + 1;\n\t\t\t  Q.push(Pox(nx[0]+ny[0]*w,nx[1]+ny[1]*w,nx[2]+ny[2]*w,pox.cost+1));\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d %d\",&w,&h,&n),h|w|n)\n    {\n      rep(i,3)sp[i] = 0;\n      int cd = 0;\n      map<char,int> dex;\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    {\n\t      scanf(\"%c\",&G[i][j]);\n\t      dex[G[i][j]] = j + i * w;\n\t      if('a' <= G[i][j] && G[i][j] <= 'z')\n\t\t{\n\t\t  sp[cd] = j + i * w;\n\t\t  cc[cd++] = G[i][j];\n\t\t}\n\t    }\n\t}\n      assert(n == cd);\n      rep(i,n)goal[i] = dex['A'+cc[i]-'a'];\n\n      //print(G);\n      initEv();\n\n      compute();\n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nint cost[3][16][16];\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;;\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    return cnt+h > a.cnt + a.h;\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<ghost>& S,int now,int n){\n  if ( n == now){\n    if ( dest.legal(source) && S.find(dest.data) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n\t\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<ghost> S;\n  S.insert(ini);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n  /*\n  cout << \"bfs for \" << num<< \" th ghoast\" << endl;\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      if ( cost[num][i][j] == INF)cout << \"x  \";\n      else cout << cost[num][i][j] << \"  \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tint an = xs.size();\n\tfor (int i = 0; i < 3 - an; ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tfor (int k = 0; k < 15; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 15; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 15; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 15; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx])aok = false;\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))aok = false;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 14\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct dat{\n  int cost, ay, ax, by, bx, cy, cx; \n};\n\nint w, h, n;\nint d[N][N][N][N][N][N];\nstring s[16];\nint ay, ax, by, bx, cy, cx;\nint dy[5]={-1,0,1,0,0};\nint dx[5]={0,1,0,-1,0};\n\nqueue<dat> q;\n\nbool check(int nay, int nax){\n  if(nay<0||nax<0||h<=nay||w<=nax) return false;\n  if(s[nay][nax]=='#') return false;\n  return true;\n}\n\nbool check2(int Ay,int Ax,int By,int Bx,int ai,int bi){\n  \n  if(Ay==By){\n    if(Ax+1==Bx&&ai==1&&bi==3) return false;\n    if(Bx+1==Ax&&bi==1&&ai==3) return false;\n  }\n  \n  if(Ax==Bx){\n    if(Ay+1==By&&ai==2&&bi==0) return false;\n    if(By+1==Ay&&bi==2&&ai==0) return false;\n  }\n  \n  return true;\n}\n\nint bnf(){\n  \n  rep(i,N) rep(j,N)\n    rep(k,N) rep(l,N)\n    rep(m,N) rep(o,N)\n    d[i][j][k][l][m][o]=INF;\n  \n  d[ay][ax][by][bx][cy][cx]=0;\n  q.push(dat{0,ay,ax,by,bx,cy,cx});\n  \n  int res;\n  \n  while(!q.empty()){\n    \n    dat t=q.front(); q.pop();\n    \n    if(n==1&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==2&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    if(n==3&&s[t.ay][t.ax]=='A'+s[ay][ax]-'a'&&\n       s[t.by][t.bx]=='A'+s[by][bx]-'a'&&\n       s[t.cy][t.cx]=='A'+s[cy][cx]-'a'){\n      res=t.cost;\n      break;\n    }\n    \n    rep(i,5){\n      int nay=dy[i]+t.ay, nax=dx[i]+t.ax;\n      if(!check(nay,nax)) continue;\n      \n      rep(j,5){\n\tint nby=dy[j]+t.by, nbx=dx[j]+t.bx;\n\tif(n==1) nby=0, nbx=0;\n\tif(n>=2&&!check(nby,nbx)) continue;\n\t\n\trep(k,5){\n\t  \n\t  int ncy=dy[k]+t.cy, ncx=dx[k]+t.cx;\n\t  if(n<=2) ncy=0, ncx=0;\n      \t  if(n==3&&!check(ncy,ncx)) continue;\n      \n\t  if(n>=2&&!check2(t.ay,t.ax,t.by,t.bx,i,j)) continue;\n\t  if(n==3&&!check2(t.ay,t.ax,t.cy,t.cx,i,k)) continue;\n\t  if(n==3&&!check2(t.by,t.bx,t.cy,t.cx,j,k)) continue;\n\t  \n\t  if(n>=2&&nay==nby&&nax==nbx) continue;\n\t  if(n==3&&nay==ncy&&nax==ncx) continue;\n\t  if(n==3&&nby==ncy&&nbx==ncx) continue;\n\n\t  if(d[nay][nax][nby][nbx][ncy][ncx]>d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1){\n\t    d[nay][nax][nby][nbx][ncy][ncx]=d[t.ay][t.ax][t.by][t.bx][t.cy][t.cx]+1;\n\t    q.push(dat{d[nay][nax][nby][nbx][ncy][ncx],nay,nax,nby,nbx,ncy,ncx});\n\t  }\n      \n\t}\n      }\n    }\n  }\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>w>>h>>n;\n    if(!w&&!h&&!n) break;\n    \n    unordered_set<char> memo;\n\n    ay=ax=by=bx=cy=cx=0;\n    \n    getline(cin,s[0]);\n    rep(i,h) getline(cin,s[i]);\n    \n    for(int i=0;i<h-2;i++){\n      s[i]=s[i+1];\n      s[i]=s[i].substr(1,w-2);\n      rep(j,w-2){\n\tchar c=s[i][j];\n\tif('a'<=c&&c<='z'&&!memo.count(c)){\n\t  if(memo.size()==0) ay=i, ax=j;\n\t  if(memo.size()==1) by=i, bx=j;\n\t  if(memo.size()==2) cy=i, cx=j;\n\t  memo.insert(c);\n\t}\n      }\n    }\n    \n    h-=2;\n    w-=2;\n    \n    cout<<bnf()<<endl;\n      \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< pair< int, int > > T;\n\nconst int vy[] = {0, 1, 0, -1, 0}, vx[] = {1, 0, -1, 0, 0};\n\nvector< vector< pair< int, int > > > vec;\n\nint W, H, N;\nstring S[16];\nint v[16 * 16 * 16 * 16 * 16 * 16];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W || S[y][x] == '#');\n}\n\nvoid CreateVector(int sz, vector< pair< int, int > > &vs)\n{\n  if(sz == 0) {\n    vec.push_back(vs);\n    return;\n  }\n  for(int i = 0; i < 5; i++) {\n    int ny = vs[sz - 1].first + vy[i];\n    int nx = vs[sz - 1].second + vx[i];\n    if(isover(ny, nx)) continue;\n    vs[sz - 1].first += vy[i];\n    vs[sz - 1].second += vx[i];\n    CreateVector(sz - 1, vs);\n    vs[sz - 1].first -= vy[i];\n    vs[sz - 1].second -= vx[i];\n  }\n}\n\nint hashh(vector< pair< int, int > > &vs)\n{\n  int ret = 0;\n  for(int k = vs.size() - 1; k >= 0; k--) {\n    ret *= 16;\n    ret += vs[k].second;\n    ret *= 16;\n    ret += vs[k].first;\n  }\n  return (ret);\n}\n\nvector< pair< int, int > > hashd(int h)\n{\n  vector< pair< int, int > > vs(N);\n  int ret = 0;\n  for(auto &k : vs) {\n    vs[ret].first = h & 15;\n    h >>= 4;\n    vs[ret++].second = h & 15;\n    h >>= 4;\n  }\n  return (vs);\n}\n\nint main()\n{\n  while(cin >> W >> H >> N, W) {\n    vector< char > nums;\n    cin.ignore();\n\n    for(int i = 0; i < H; i++) {\n      getline(cin, S[i]);\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) nums.push_back(S[i][j]);\n      }\n    }\n\n    sort(begin(nums), end(nums));\n\n    vector< pair< int, int > > vs(N), ans(N);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), S[i][j]) - begin(nums);\n          vs[q] = {i, j};\n        } else if(isupper(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), tolower(S[i][j])) - begin(nums);\n          ans[q] = {i, j};\n        }\n      }\n    }\n\n\n    queue< int > que;\n    que.emplace(hashh(vs));\n    memset(v, -1, sizeof(v));\n    v[hashh(vs)] = 0;\n\n    while(!que.empty()) {\n      auto ss = que.front();\n      int cost = v[ss];\n      que.pop();\n      auto p = hashd(ss);\n      if(p == ans) {\n        cout << cost << endl;\n        break;\n      }\n\n      vec.clear();\n      CreateVector(N, p);\n      for(auto &beet : vec) {\n        bool isok = true;\n        for(int i = 0; i < p.size(); i++) {\n          for(int j = 0; j < i; j++) {\n            isok &= beet[i] != p[j] || beet[j] != p[i];\n            isok &= beet[i] != beet[j];\n          }\n        }\n        int hashed = hashh(beet);\n        if(isok && v[hashed] == -1) {\n          que.emplace(hashed);\n          v[hashed] = cost + 1;\n        }\n      }\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint tm0;\n\ninline bool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = i == 16 ? 0 : i + 8;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = v >> j & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j & 255) &&\n\t\t\t\tp2 == (u >> i & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\tqueue<int> q;\n\tq.push(start);\n\tq.push(-1);\n\tint tm = tm0 + 1;\n\tvis[start] = tm;\n\twhile(1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u < 0){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tm = solve(start, goal);\n\t\tprintf(\"%d\\n\", tm - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\n\nS i2s(int x){\n  return S(x>>12,x&((1<<12)-1));\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first<<12)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*16+p.first[i];\n    x=x*16+p.second[i];\n  }\n  return S(y,x);\n}\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%16);\n    x.push_back(b%16);\n    a/=16;b/=16;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nbool m[1<<26];\nqueue<int> q;\n\nvector<int> ys,xs;\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    P r=P(ys,xs);\n    int abc=p2i(r);\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct data{\n\tshort x[3],y[3];\n\tshort v;\n\tdata(){}\n};\n\nshort dx[5]={0,1,-1,0,0};\nshort dy[5]={0,0,0,1,-1};\n\nint n,w,h;\nshort fie[14][14];\nshort sx[3],sy[3];\nshort gx[3],gy[3];\nshort dp[196][196][14];\nshort move[3]={5,25,125};\n\nint solve(){\n\tqueue<data> que;\n\tdata st;\n\tfor(int i=0;i<3;i++){\n\t\tif(i<n){\n\t\t\tst.x[i]=sx[i];\n\t\t\tst.y[i]=sy[i];\n\t\t}else{\n\t\t\tst.x[i]=0;\n\t\t\tst.y[i]=0;\n\t\t}\n\t}\n\tst.v=0;\n\tmemset(dp,0,sizeof(dp));\n\tque.push(st);\n\tdp[st.y[0]*w+st.x[0]][st.y[1]*w+st.x[1]][st.y[2]]=1<<st.x[2];\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tdata nd=d;\n\t\tnd.v=d.v+1;\n\t\tfor(int i=1;i<move[n-1];i++){\n\t\t\tif(false){\n\t\t\t\tbye:\n\t\t\t\ti++;\n\t\t\t\tif(i==move[n-1])break;\n\t\t\t}\n\t\t\t\n\t\t\tint pi=i;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tnd.x[j]=d.x[j]+dx[pi%5];\n\t\t\t\tnd.y[j]=d.y[j]+dy[pi%5];\n\t\t\t\tif(nd.x[j]<0 || nd.x[j]>=w || nd.y[j]<0 || nd.y[j]>=h){\n\t\t\t\t\tgoto bye;\n\t\t\t\t}\n\t\t\t\tif(fie[nd.y[j]][nd.x[j]]==-1)goto bye;\n\t\t\t\tpi/=5;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\t\tif(d.x[j]==nd.x[k] && d.y[j]==nd.y[k] && d.x[k]==nd.x[j] && d.y[k]==nd.y[j]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t\tif(nd.x[j]==nd.x[k] && nd.y[j]==nd.y[k]){\n\t\t\t\t\t\tgoto bye;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!(dp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.y[2]]>>nd.x[2] & 1)){\n\t\t\t\tbool goal=true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(nd.y[i]!=gy[i] || nd.x[i]!=gx[i])goal=false;\n\t\t\t\t}\n\t\t\t\tif(goal){\n\t\t\t\t\treturn d.v+1;\n\t\t\t\t}\n\t\t\t\tdp[nd.x[0]+nd.y[0]*w][nd.x[1]+nd.y[1]*w][nd.y[2]]|=1<<nd.x[2];\n\t\t\t\tque.push(nd);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&w,&h,&n);\n\t\tif(w==0 && h==0 && n==0)break;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar str;\n\t\t\t\tscanf(\"%c\",&str);\n\t\t\t\tif(i==0 || j==0 || i==h-1 || j==w-1)continue;\n\t\t\t\tif(str=='#'){\n\t\t\t\t\tfie[i-1][j-1]=-1;\n\t\t\t\t}\n\t\t\t\tif(str>='A' && str<='C'){\n\t\t\t\t\tsx[(str-'A')]=j-1;\n\t\t\t\t\tsy[(str-'A')]=i-1;\n\t\t\t\t}\n\t\t\t\tif(str>='a' && str<='c'){\n\t\t\t\t\tgx[(str-'a')]=j-1;\n\t\t\t\t\tgy[(str-'a')]=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tw-=2;\n\t\th-=2;\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,0};\nconst int dy[8]={0,1,0,-1,0};\n\nconst int limit=1<<24;\n\ninline int hstar(int n,int cmask,int tmask){\n\tint cy[3],cx[3],ty[3],tx[3];\n\tint ret=0;\n\trep(i,n){\n\t\tcx[i]=cmask&15;\n\t\tcmask>>=4;\n\t\tcy[i]=cmask&15;\n\t\tcmask>>=4;\n\n\t\ttx[i]=tmask&15;\n\t\ttmask>>=4;\n\t\tty[i]=tmask&15;\n\t\ttmask>>=4;\n\n\t\tchmax(ret,abs(cy[i]-ty[i])+abs(cx[i]-tx[i]));\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint w,h,n;\n\t\n\twhile(cin >> w >> h >> n,n){\n\t\tint smask=0,tmask=0;\n\t\tstring board[16];\n\t\t\n\t\tcin.ignore();\n\t\trep(i,h) getline(cin,board[i]);\n\n\t\t// cout << w << \" \" << h << \" \" << n << endl;\n\t\t// rep(i,h) cout << board[i] << endl;\n\n\t\trep(i,h)rep(j,w)rep(k,3){\n\t\t\tif(board[i][j]==('a'+k)) smask|=((16*i+j)<<(8*k));\n\t\t\tif(board[i][j]==('A'+k)) tmask|=((16*i+j)<<(8*k));\n\t\t}\n\n\t\tmap<int,int> dist;\n\t\tdist[smask]=0,dist[tmask]=limit;\n\t\tusing state=tuple<int,int>;\n\t\tpriority_queue<state,vector<state>,greater<state>> q;\n\t\tq.push(state(0,smask));\n\n\t\twhile(!q.empty()){\n\t\t\tint cost,cmask;\n\t\t\ttie(cost,cmask)=q.top();q.pop();\n\n\t\t\tif(dist[tmask]!=limit) break;\n\n\t\t\tint cy[3],cx[3],tmp=cmask;\n\t\t\trep(i,n){\n\t\t\t\tcx[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t\tcy[i]=tmp&15;\n\t\t\t\ttmp>>=4;\n\t\t\t}\n\n\t\t\tconst int all=pow<int>(5,n);\n\n\t\t\trep(mask,all){\n\t\t\t\tconst int didx[3]={mask%5,mask/5%5,mask/25};\n\t\t\t\tint ny[3],nx[3];\n\t\t\t\trep(i,n){\n\t\t\t\t\tny[i]=cy[i]+dy[didx[i]];\n\t\t\t\t\tnx[i]=cx[i]+dx[didx[i]];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,n) if(board[ny[i]][nx[i]]=='#') ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==ny[j] && nx[i]==nx[j] ) ok=false;\n\t\t\t\tif(ok==false) continue;\n\t\t\t\trep(i,n)rep(j,i) if(ny[i]==cy[j] && nx[i]==cx[j] && ny[j]==cy[i] && nx[j]==cx[i]) ok=false;\n\t\t\t\tif(ok==false) continue;\n\n\n\t\t\t\tint nmask=0;\n\t\t\t\trep(i,n) nmask|=(16*ny[i]+nx[i])<<(8*i);\n\n\t\t\t\tif(dist.find(nmask)==end(dist)) dist[nmask]=limit;\n\t\t\t\tif(chmin(dist[nmask],dist[cmask]+1)) q.push(state(dist[nmask]+hstar(n,nmask,tmask),nmask));\t\t\n\t\t\t}\n\n\t\t}\n\t\tcout << dist[tmask] << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nP goal[MAX_N];\nP start[MAX_N];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\nvoid add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nvoid move(State& s, const State& prev, int k, map<int, int>& dist, priority_queue<State>& que){\n  if(k == 0) s.d++;\n  if(k == N){\n    if(!valid(s, prev)) return;\n    int h = 0;\n    REP(i, N){\n      h = max(h, calc_distance(s.p[i], goal[i]));\n    }\n    s.f = s.d + h;\n    add(s, que);\n  }else{\n    REP(r, 5){\n      if(valid(s.p[k].first + dx[r], s.p[k].second + dy[r], W, H)){\n        s.p[k].first += dx[r];\n        s.p[k].second += dy[r];\n        move(s, prev, k + 1, dist, que);\n        s.p[k].first -= dx[r];\n        s.p[k].second -= dy[r];\n      }\n    }\n  }\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 200;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n    //  print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      State ss = s;\n\n      move(s, ss, 0, dist, que);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint encode(const pair<int,int> *pos, int N)\n{\n  int s = 0;\n  for (int i = 0; i < N; i++) {\n    s = 256*s + pos[i].first*16 + pos[i].second;\n  }\n  return s;\n}\n\nvoid decode(pair<int,int> *ps, int s, int N)\n{\n  for (int i = 0; i < N; i++) {\n    const int t = s % 256;\n    ps[N-i-1] = make_pair(t/16, t%16);\n    s /= 256;\n  }\n}\n\nint manhattan(const pair<int,int> *ps, const pair<int,int> *fin, int N)\n{\n  int l = 0;\n  for (int i = 0; i < N; i++) {\n    l = max(l, abs(ps[i].first - fin[i].first) + abs(ps[i].second - fin[i].second));\n  }\n  return l;\n}\n\nbool calc_next(pair<int,int> *next, int N, const char grid[16][20], const pair<int,int> *ps, int a)\n{\n  for (int i = 0; i < N; i++) {\n    static const int di[] = {-1, 1, 0, 0, 0}, dj[] = {0, 0, -1, 1, 0};\n    const int k = ps[i].first + di[a%5];\n    const int l = ps[i].second + dj[a%5];\n    a /= 5;\n    if (grid[k][l] == '#') {\n      return false;\n    }\n    next[i] = make_pair(k, l);\n  }\n  return true;\n}\n\nbool valid(const pair<int,int> *cur, const pair<int,int> *next, int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; j < N; j++) {\n      if (next[i] == next[j]) {\n        return false;\n      }\n      if (next[i] == cur[j] && next[j] == cur[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint get(int s, const unsigned char *d1, const map<int,short>& d2)\n{\n  int d = d1[s];\n  if (d == 255) {\n    return 1000;\n  } else if (d == 254) {\n    return d2.find(s)->second;\n  } else {\n    return d;\n  }\n}\n\nvoid set(int s, unsigned char *d1, map<int,short>& d2, int d)\n{\n  if (d >= 254) {\n    d1[s] = 254;\n    d2[s] = d;\n  } else {\n    d1[s] = d;\n  }\n}\n\nint main()\n{\n  char buf[100];\n  while (fgets(buf, sizeof buf, stdin)) {\n    int W, H, N;\n    sscanf(buf, \"%d %d %d\", &W, &H, &N);\n    if (N == 0) {\n      break;\n    }\n    char grid[16][20];\n    pair<int,int> pos[3];\n    pair<int,int> fin[3];\n    for (int i = 0; i < H; i++) {\n      fgets(grid[i], 20, stdin);\n      for (int j = 0; j < W; j++) {\n        if ('a' <= grid[i][j] && grid[i][j] <= 'c') {\n          pos[grid[i][j]-'a'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        } else if ('A' <= grid[i][j] && grid[i][j] <= 'C') {\n          fin[grid[i][j]-'A'] = make_pair(i, j);\n          grid[i][j] = ' ';\n        }\n      }\n    }\n    const int final = encode(fin, N);\n    int A = 1;\n    for (int i = 0; i < N; i++) {\n      A *= 5;\n    }\n\n    static unsigned char dist[256*256*256];\n    fill_n(dist, 256*256*256, 255);\n    map<int,short> dist2;\n    dist[encode(pos, N)] = 0;\n    priority_queue<pair<short,int> > q;\n    q.push(make_pair(-manhattan(pos, fin, N), encode(pos, N)));\n    while (!q.empty()) {\n      const int c = -q.top().first;\n      const int s = q.top().second;\n      q.pop();\n      if (s == final) {\n        printf(\"%d\\n\", c);\n        break;\n      }\n      decode(pos, s, N);\n      const int d = c - manhattan(pos, fin, N);\n      const int d2 = get(s, dist, dist2);\n      if (d > d2) {\n        continue;\n      }\n\n      for (int a = 0; a < A; a++) {\n        pair<int,int> next[3];\n        if (!calc_next(next, N, grid, pos, a)) {\n          continue;\n        }\n        const int u = encode(next, N);\n        const int du = get(u, dist, dist2);\n        if (d+1 < du && valid(pos, next, N)) {\n          set(u, dist, dist2, d+1);\n          q.push(make_pair(-d-1-manhattan(next, fin, N), u));\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nbool *v;\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16], ans;\nstring in[20];\npriority_queue<ll> q;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\tll tmp = 0;\n\t\tbool goal = 1;\n\t\trep(i,n){\n\t\t\ttmp = max(tmp, (ll)dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]]);\n\t\t\tif(gy[i] != ny[i] || gx[i] != nx[i]) goal = 0;\n\t\t}\n\t\tif(goal){\n\t\t\tans = min(ans, cost);\n\t\t\treturn;\n\t\t}\n\t\ttmp += cost;\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!v[tmp & (1<<8*n) - 1]) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\trep(i,c) if(ny[i] == ny[c] && nx[i] == nx[c]) goto NEXT;\n\t\trep(i,c) if(ny[i] == y[c] && nx[i] == x[c] &&\n\t\t\t\t ny[c] == y[i] && nx[c] == x[i]) goto NEXT;\n\t\t\n\t\tpush(cost, c+1);\n\t\tNEXT:;\n\t}\n}\n\nint main()\n{\n\tv = (bool*)malloc(256*256*256);\n\t\n\twhile(cin >> w >> h >> n, w){\n\t\tmemset(v, 0, sizeof(v));\n\t\tq = priority_queue<ll>();\n\t\t\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp = max(tmp, (ll)dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]]);\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\tans = inf;\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(v[state]) continue;\n\t\t\tv[state] = 1;\n\t\t\t\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(cost >= ans - 1 || tmp >> 10 >= ans) break;\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << (ans == inf ? -1 : ans) << endl;\n\t}\n\t\n\tfree(v);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< pair< int, int > > T;\n\nconst int vy[] = {0, 1, 0, -1, 0}, vx[] = {1, 0, -1, 0, 0};\n\nint tail;\nvector< pair< int, int > > vec[1000];\n\nint W, H, N;\nstring S[16];\nint v[16 * 16 * 16 * 16 * 16 * 16];\n\nbool isover(int y, int x)\n{\n  return (y < 0 || y >= H || x < 0 || x >= W || S[y][x] == '#');\n}\n\nvoid CreateVector(int sz, vector< pair< int, int > > &vs)\n{\n  if(sz == 0) {\n    vec[tail++] = vs;\n    return;\n  }\n  for(int i = 0; i < 5; i++) {\n    int ny = vs[sz - 1].first + vy[i];\n    int nx = vs[sz - 1].second + vx[i];\n    if(isover(ny, nx)) continue;\n    vs[sz - 1].first += vy[i];\n    vs[sz - 1].second += vx[i];\n    CreateVector(sz - 1, vs);\n    vs[sz - 1].first -= vy[i];\n    vs[sz - 1].second -= vx[i];\n  }\n}\n\nint hashh(vector< pair< int, int > > &vs)\n{\n  int ret = 0;\n  for(int k = vs.size() - 1; k >= 0; k--) {\n    ret *= 16;\n    ret += vs[k].second;\n    ret *= 16;\n    ret += vs[k].first;\n  }\n  return (ret);\n}\n\nvector< pair< int, int > > hashd(int h)\n{\n  vector< pair< int, int > > vs(N);\n  int ret = 0;\n  for(auto &k : vs) {\n    vs[ret].first = h & 15;\n    h >>= 4;\n    vs[ret++].second = h & 15;\n    h >>= 4;\n  }\n  return (vs);\n}\n\nint main()\n{\n  while(cin >> W >> H >> N, W) {\n    vector< char > nums;\n    cin.ignore();\n\n    for(int i = 0; i < H; i++) {\n      getline(cin, S[i]);\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) nums.push_back(S[i][j]);\n      }\n    }\n\n    sort(begin(nums), end(nums));\n\n    vector< pair< int, int > > vs(N), ans(N);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(islower(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), S[i][j]) - begin(nums);\n          vs[q] = {i, j};\n        } else if(isupper(S[i][j])) {\n          auto q = lower_bound(begin(nums), end(nums), tolower(S[i][j])) - begin(nums);\n          ans[q] = {i, j};\n        }\n      }\n    }\n\n\n    queue< int > que;\n    que.emplace(hashh(vs));\n    memset(v, -1, sizeof(v));\n    v[hashh(vs)] = 0;\n\n    while(!que.empty()) {\n      auto ss = que.front();\n      int cost = v[ss];\n      que.pop();\n      auto p = hashd(ss);\n      if(p == ans) {\n        cout << cost << endl;\n        break;\n      }\n\n      tail = 0;\n      CreateVector(N, p);\n      for(int z = 0; z < tail; z++) {\n        auto &beet = vec[z];\n        bool isok = true;\n        for(int i = 0; i < p.size(); i++) {\n          for(int j = 0; j < i; j++) {\n            isok &= beet[i] != p[j] || beet[j] != p[i];\n            isok &= beet[i] != beet[j];\n          }\n          if(!isok) break;\n        }\n        int hashed = hashh(beet);\n        if(isok && v[hashed] == -1) {\n          que.emplace(hashed);\n          v[hashed] = cost + 1;\n        }\n      }\n    }\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned char dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P start, P goal){\n  int& dist = memo[start.first][start.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  queue<P> que;\n  que.push(goal);\n  memo[goal.first][goal.second][goal.first][goal.second] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    REP(r, 4){\n      P q = p;\n      q.first += dx[r];\n      q.second += dy[r];\n      if(!valid(q.first, q.second, W, H)) continue;\n      if(memo[q.first][q.second][goal.first][goal.second] != -1) continue;\n      memo[q.first][q.second][goal.first][goal.second] = memo[p.first][p.second][goal.first][goal.second] + 1;\n      que.push(q);\n    }\n  }\n  assert(dist != -1);\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 255;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return a.cost + a.dist > b.cost + b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\n\nint toInt(vector<int>& y, vector<int>& x, bitset<3> bs){\n    int ret = bs.to_ulong();\n    for(int i=0; i<n; ++i){\n        ret *= h;\n        ret += y[i];\n        ret *= w;\n        ret += x[i];\n    }\n    return ret;\n}\n\nvoid fromInt(int a, vector<int>& y, vector<int>& x, bitset<3>& bs){\n    for(int i=n-1; i>=0; --i){\n        x[i] = a % w;\n        a /= w;\n        y[i] = a % h;\n        a /= h;\n    }\n    bs = a;\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        vector<string> grid(h);\n        vector<int> sy(n), sx(n), gy(n), gx(n);\n        for(int i=0; i<h; ++i){\n            getline(cin, grid[i]);\n            for(int j=0; j<w; ++j){\n                int c = grid[i][j];\n                if('a' <= c && c <= 'c'){\n                    sy[c-'a'] = i;\n                    sx[c-'a'] = j;\n                }else if('A' <= c && c <= 'C'){\n                    gy[c-'A'] = i;\n                    gx[c-'A'] = j;\n                }\n            }\n        }\n\n        int size = 1 << n;\n        for(int i=0; i<n; ++i)\n            size *= h * w;\n\n        vector<bool> check(size, false);\n        check[toInt(sy, sx, 0)] = true;\n        queue<int> q1, q2;\n        q1.push(toInt(sy, sx, 0));\n        int ret = 1;\n        for(;;){\n            if(q1.empty()){\n                swap(q1, q2);\n                ++ ret;\n            }\n\n            vector<int> y(n), x(n);\n            bitset<3> bs;\n            fromInt(q1.front(), y, x, bs);\n            q1.pop();\n            if(y == gy && x == gx){\n                cout << ret << endl;\n                break;\n            }\n\n            for(int i=0; i<n; ++i){\n                if(bs[i])\n                    continue;\n                bs[i] = true;\n                for(int j=0; j<4; ++j){\n                    y[i] += dy[j];\n                    x[i] += dx[j];\n\n                    bool ok = true;\n                    if(grid[y[i]][x[i]] == '#')\n                        ok = false;\n                    for(int k=0; k<n; ++k){\n                        if(k != i && y[k] == y[i] && x[k] == x[i])\n                            ok = false;\n                    }\n\n                    if(ok){\n                        int a = toInt(y, x, bs);\n                        if(!check[a]){\n                            q1.push(a);\n                            check[a] = true;\n                        }\n                    }\n\n                    y[i] -= dy[j];\n                    x[i] -= dx[j];\n                }\n                bs[i] = false;\n            }\n\n            int a = toInt(y, x, 0);\n            if(!check[a]){\n                q2.push(a);\n                check[a] = true;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 16;\nconstexpr int dx[5] = {-1, +0, +1, +0, +0};\nconstexpr int dy[5] = {+0, -1, +0, +1, +0};\n\nint W, H, N;\n\ninline bool reach(const vector<int>& sx, const vector<int>& sy,\n           const vector<int>& gx, const vector<int>& gy)\n{\n    for (int i = 0; i < N; i++) {\n        if (sx[i] != gx[i] || sy[i] != gy[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\ninline bool same(int& x1, int& y1, int& x2, int& y2)\n{\n    return (x1 == x2 && y1 == y2);\n}\n\nbool d[MAX_H][MAX_W][MAX_H][MAX_W][MAX_H][MAX_W];\n\nint bfs(const vector<string>& field,\n        const vector<int>& sx, const vector<int>& sy,\n        const vector<int>& gx, const vector<int>& gy)\n{\n    queue<pair<vector<int>, vector<int>>> que;\n    queue<int> qc;\n    \n    que.push(make_pair(sx, sy));    \n    qc.push(0);\n    \n    memset(d, 0, sizeof(d));\n    d[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]] = 1;\n\n    while (!que.empty()) {\n        auto f = que.front(); que.pop();\n        int c = qc.front(); qc.pop();\n        auto& cx = f.first;\n        auto& cy = f.second;\n        \n        if (reach(cx, cy, gx, gy)) return c;\n                \n        for (int i = 0; i < 5; i++) {            \n            int nx0 = cx[0] + dx[i], ny0 = cy[0] + dy[i];            \n            \n            if (field[ny0][nx0] == '#') continue;\n            if (N == 1) {\n                if (!d[ny0][nx0][cy[1]][cx[1]][cy[2]][cx[2]]) {\n                    d[ny0][nx0][cy[1]][cx[1]][cy[2]][cx[2]] = 1;\n                    \n                    vector<int> nx = {nx0, cx[1], cx[2]}, ny = {ny0, cy[1], cy[2]};                     \n                    que.push(make_pair(nx, ny));                    \n                    qc.push(c + 1);\n                }\n                continue;\n            }\n            \n            for (int j = 0; j < 5; j++) {                \n                int nx1 = cx[1] + dx[j], ny1 = cy[1] + dy[j];\n                if (field[ny1][nx1] == '#') continue;\n                if (same(nx0, ny0, nx1, ny1)) continue;\n                if (same(nx0, ny0, cx[1], cy[1]) && same(cx[0], cy[0], nx1, ny1)) continue;                \n                \n                if (N == 2) {\n                    if (!d[ny0][nx0][ny1][nx1][cy[2]][cx[2]]) {\n                        d[ny0][nx0][ny1][nx1][cy[2]][cx[2]] = 1;\n                        \n                        vector<int> nx = {nx0, nx1, cx[2]}, ny = {ny0, ny1, cy[2]};                     \n                        que.push(make_pair(nx, ny));                    \n                        qc.push(c + 1);\n                    }   \n                    continue;\n                }\n                \n                for (int k = 0; k < 5; k++) {\n                    int nx2 = cx[2] + dx[k], ny2 = cy[2] + dy[k];\n                    \n                    if (field[ny2][nx2] == '#') continue;\n                    if (same(nx0, ny0, nx2, ny2) || same(nx1, ny1, nx2, ny2)) continue;\n                    if (same(nx0, ny0, cx[2], cy[2]) && same(cx[0], cy[0], nx2, ny2)) continue;                \n                    if (same(nx1, ny1, cx[2], cy[2]) && same(cx[1], cy[1], nx2, ny2)) continue;                \n\n                    if (!d[ny0][nx0][ny1][nx1][ny2][nx2]) {\n                        d[ny0][nx0][ny1][nx1][ny2][nx2] = 1;\n                        vector<int> nx = {nx0, nx1, nx2}, ny = {ny0, ny1, ny2};                     \n                        que.push(make_pair(nx, ny));\n                        qc.push(c + 1);\n                    }\n                }\n            }\n        }      \n    }    \n    return -1;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while (cin >> W >> H >> N, W > 0) {\n        vector<string> field(H);\n        vector<int> sx(N), sy(N), gx(N), gy(N);\n        cin.ignore();\n        for (int i = 0; i < H; i++) {\n            getline(cin, field[i]);\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == ' ') {\n                    field[i][j] = '.';\n                } else if (islower(field[i][j])) {\n                    sx[field[i][j] - 'a'] = j;\n                    sy[field[i][j] - 'a'] = i;\n                    field[i][j] = '.';\n                } else if (isupper(field[i][j])) {\n                    gx[field[i][j] - 'A'] = j;\n                    gy[field[i][j] - 'A'] = i;\n                    field[i][j] = '.';\n                }\n            }\n        }\n\n        while (sx.size() < 3) {\n            sx.emplace_back(0);\n            sy.emplace_back(0);\n            gx.emplace_back(0);\n            gy.emplace_back(0);\n        }\n        cout << bfs(field, sx, sy, gx, gy) << endl; \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nstruct State{\n    int pa,pb,pc;\n};\n\nconst int N = 16*16;\nconst int INF = 19191919;\nint dp[N][N][N];\n\nint solve(int w, int h, int n){\n    cin.ignore();\n    vector<string> f(h);\n    rep(i,h) getline(cin, f[i]);\n\n    auto cv = [&](pi p){\n        return p.fi*w+p.se;\n    };\n\n    int sa=0,sb=0,sc=0,ga=0,gb=0,gc=0;\n    rep(i,h)rep(j,w){\n        if(f[i][j]=='a') sa = cv({i,j});\n        if(f[i][j]=='b') sb = cv({i,j});\n        if(f[i][j]=='c') sc = cv({i,j});\n        if(f[i][j]=='A') ga = cv({i,j});\n        if(f[i][j]=='B') gb = cv({i,j});\n        if(f[i][j]=='C') gc = cv({i,j});\n    }\n\n    auto cand = [&](int p){\n        int y = p/w, x = p%w;\n\n        vector<int> ret;\n        ret.pb(p);\n\n        rep(d,4){\n            int ny = y+dy[d], nx = x+dx[d];\n            if(0<=ny && ny<h && 0<=nx && nx<w && f[ny][nx]!='#') ret.pb(cv({ny,nx}));\n        }\n        return ret;\n    };\n\n    rep(i,N)rep(j,N)rep(k,N) dp[i][j][k] = INF;\n    dp[sa][sb][sc] = 0;\n    queue<State> que;\n    que.push({sa,sb,sc});\n    while(!que.empty()){\n        State now = que.front();\n        que.pop();\n\n        vector<int> da = cand(now.pa), db = cand(now.pb), dc = cand(now.pc);\n\n        for(int A:da)for(int B:db)for(int C:dc){\n            if(B != 0){\n                if(B == A) continue;\n                if(now.pa == B && now.pb == A) continue;\n            }\n            if(C != 0){\n                if(C == A || C == B) continue;\n                if(now.pa == C && now.pc == A) continue;\n                if(now.pb == C && now.pc == B) continue;\n            }\n\n            if(dp[A][B][C] > dp[now.pa][now.pb][now.pc]+1){\n                dp[A][B][C] = dp[now.pa][now.pb][now.pc]+1;\n                if(A==ga && B==gb && C==gc) return dp[A][B][C];\n                que.push({A,B,C});\n            }\n        }\n    }\n    assert(false);\n}\n\nint main(){\n    int w,h,n;\n    while(cin >>w >>h >>n,w){\n        cout << solve(w,h,n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d < s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\ninline int make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nunsigned short dist[1 << 24];\ninline void add(const State& s, priority_queue<State>& que){\n  int k = make(s.p);\n  if(dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\ninline bool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\ninline bool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\ninline bool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P start, P goal){\n  int& dist = memo[start.first][start.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  queue<P> que;\n  que.push(goal);\n  memo[goal.first][goal.second][goal.first][goal.second] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    REP(r, 4){\n      P q = p;\n      q.first += dx[r];\n      q.second += dy[r];\n      if(!valid(q.first, q.second, W, H)) continue;\n      if(memo[q.first][q.second][goal.first][goal.second] != -1) continue;\n      memo[q.first][q.second][goal.first][goal.second] = memo[p.first][p.second][goal.first][goal.second] + 1;\n      que.push(q);\n    }\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    REP(i, 1 << 24) dist[i] = 16 * 16 * 3;\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    priority_queue<State> que;\n    State init(start, 0, 1);\n    add(init, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(s.d == s.f){\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        assert(h < INF);\n        add(next, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 32767\n\n\nstruct Info{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Data{\n\tbool operator<(const struct Data &arg)const{\n\t\treturn total_cost > arg.total_cost;\n\t}\n\tvoid set(short arg_total_cost,bool arg_cleard_1,bool arg_cleard_2,bool arg_cleard_3){\n\t\ttotal_cost = arg_total_cost;\n\t\tcleard_1 = arg_cleard_1;\n\t\tcleard_2 = arg_cleard_2;\n\t\tcleard_3 = arg_cleard_3;\n\t}\n\tshort total_cost;\n\tInfo loc_1,loc_2,loc_3;\n\tbool cleard_1,cleard_2,cleard_3;\n};\n\nInfo start_info[3],goal_info[3];\n\nstring line;\nint W,H,N;\nshort min_cost1[16][16];\nshort min_cost2[16][16][16][16];\nshort min_cost3[16][16][16][16][16][16];\nint diff_row[5] = {-1,0,0,0,1},diff_col[5] = {0,-1,0,1,0};\nchar table[16][17];\n\n\nbool is_Same(Info a,Info b){\n\n\tif(a.row == b.row && a.col == b.col){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid calc3(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tfor(int e = 0; e < H; e++){\n\t\t\t\t\t\tfor(int f = 0; f < W; f++)min_cost3[a][b][c][d][e][f] = BIG_NUM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost3[start_info[0].row][start_info[0].col][start_info[1].row][start_info[1].col][start_info[2].row][start_info[2].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.loc_2 = start_info[1];\n\tfirst.loc_3 = start_info[2];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tfirst.cleard_2 = is_Same(start_info[1],goal_info[1]);\n\tfirst.cleard_3 = is_Same(start_info[2],goal_info[2]);\n\tQ.push(first);\n\n\tInfo next_loc1,next_loc2,next_loc3;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true && Q.top().cleard_2 == true && Q.top().cleard_3 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost3[Q.top().loc_1.row][Q.top().loc_1.col][Q.top().loc_2.row][Q.top().loc_2.col][Q.top().loc_3.row][Q.top().loc_3.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tnext_loc2.set(Q.top().loc_2.row+diff_row[k],Q.top().loc_2.col+diff_col[k]);\n\t\t\t\t\tif((table[next_loc2.row][next_loc2.col] == '#') || (is_Same(next_loc1,next_loc2) == true) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc1,Q.top().loc_2) == true && is_Same(next_loc2,Q.top().loc_1)))continue;\n\t\t\t\t\tfor(int p = 0; p < 5; p++){\n\n\t\t\t\t\t\tnext_loc3.set(Q.top().loc_3.row+diff_row[p],Q.top().loc_3.col+diff_col[p]);\n\t\t\t\t\t\tif((table[next_loc3.row][next_loc3.col] == '#') || (is_Same(next_loc1,next_loc3) == true) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc2,next_loc3) == true) || (is_Same(next_loc1,Q.top().loc_3) == true && is_Same(next_loc3,Q.top().loc_1)) ||\n\t\t\t\t\t\t\t\t(is_Same(next_loc2,Q.top().loc_3) == true && is_Same(next_loc3,Q.top().loc_2)))continue;\n\n\t\t\t\t\t\tif(min_cost3[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col][next_loc3.row][next_loc3.col] > Q.top().total_cost+1){\n\t\t\t\t\t\t\tmin_cost3[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col][next_loc3.row][next_loc3.col] = Q.top().total_cost+1;\n\t\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\t\t\tnew_data.loc_2 = next_loc2;\n\t\t\t\t\t\t\tnew_data.loc_3 = next_loc3;\n\t\t\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\t\t\tnew_data.cleard_2 = is_Same(next_loc2,goal_info[1]);\n\t\t\t\t\t\t\tnew_data.cleard_3 = is_Same(next_loc3,goal_info[2]);\n\t\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_cost3[goal_info[0].row][goal_info[0].col][goal_info[1].row][goal_info[1].col][goal_info[2].row][goal_info[2].col]);\n}\n\nvoid calc2(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++)min_cost2[a][b][c][d] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost2[start_info[0].row][start_info[0].col][start_info[1].row][start_info[1].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.loc_2 = start_info[1];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tfirst.cleard_2 = is_Same(start_info[1],goal_info[1]);\n\tQ.push(first);\n\n\tInfo next_loc1,next_loc2;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true && Q.top().cleard_2 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost2[Q.top().loc_1.row][Q.top().loc_1.col][Q.top().loc_2.row][Q.top().loc_2.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\n\t\t\t\t\tnext_loc2.set(Q.top().loc_2.row+diff_row[k],Q.top().loc_2.col+diff_col[k]);\n\t\t\t\t\tif((table[next_loc2.row][next_loc2.col] == '#') || (is_Same(next_loc1,next_loc2) == true) ||\n\t\t\t\t\t\t\t(is_Same(next_loc1,Q.top().loc_2) == true && is_Same(next_loc2,Q.top().loc_1)))continue;\n\n\t\t\t\t\tif(min_cost2[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col] > Q.top().total_cost+1){\n\t\t\t\t\t\tmin_cost2[next_loc1.row][next_loc1.col][next_loc2.row][next_loc2.col] = Q.top().total_cost+1;\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\t\tnew_data.loc_2 = next_loc2;\n\t\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\t\tnew_data.cleard_2 = is_Same(next_loc2,goal_info[1]);\n\t\t\t\t\t\tQ.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_cost2[goal_info[0].row][goal_info[0].col][goal_info[1].row][goal_info[1].col]);\n}\n\nvoid calc1(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tmin_cost1[a][b] = BIG_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<Data> Q;\n\tmin_cost1[start_info[0].row][start_info[0].col] = 0;\n\tData first;\n\tfirst.total_cost = 0;\n\tfirst.loc_1 = start_info[0];\n\tfirst.cleard_1 = is_Same(start_info[0],goal_info[0]);\n\tQ.push(first);\n\n\tInfo next_loc1;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().cleard_1 == true){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().total_cost > min_cost1[Q.top().loc_1.row][Q.top().loc_1.col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_loc1.set(Q.top().loc_1.row+diff_row[i],Q.top().loc_1.col+diff_col[i]);\n\t\t\t\tif(table[next_loc1.row][next_loc1.col] == '#')continue;\n\n\t\t\t\tif(min_cost1[next_loc1.row][next_loc1.col] > Q.top().total_cost+1){\n\t\t\t\t\tmin_cost1[next_loc1.row][next_loc1.col] = Q.top().total_cost+1;\n\t\t\t\t\tData new_data;\n\t\t\t\t\tnew_data.loc_1 = next_loc1;\n\t\t\t\t\tnew_data.total_cost = Q.top().total_cost+1;\n\t\t\t\t\tnew_data.cleard_1 = is_Same(next_loc1,goal_info[0]);\n\t\t\t\t\tQ.push(new_data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min_cost1[goal_info[0].row][goal_info[0].col]);\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tgetline(cin,line);\n\t\tfor(int col = 0; col < W; col++)table[row][col] = line[col];\n\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tswitch(table[row][col]){\n\t\t\tcase 'a':\n\t\t\t\tstart_info[0].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tstart_info[1].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tstart_info[2].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\tgoal_info[0].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tgoal_info[1].set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tgoal_info[2].set(row,col);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch(N){\n\tcase 1:\n\t\tcalc1();\n\t\tbreak;\n\tcase 2:\n\t\tcalc2();\n\t\tbreak;\n\tcase 3:\n\t\tcalc3();\n\t\tbreak;\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&W,&H,&N);\n\t\tif(W == 0 && H == 0 && N == 0)break;\n\n\t\tgetchar();\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 100000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<ctime>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost = max(add_cost,ev[p.p[i]][goal[i]]);\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  //clock_t st,ed;\n  //st = clock();\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(28);//å¤§ããããã¨MLEãå°ããããã¨TLE\n      makeEv();\n      compute();\n\n    }\n\n  //ed = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << \"time : \" << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint memo[15][15][15][15][15][15];\nint dist[16][16][16][16];\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\nint W, H, N;\n\nvector<int>gx;\nvector<int>gy;\nstruct aa {\n\tvector<int>xs;\n\tvector<int>ys;\n\tint time;\n\tint geta()const {\n\t\tint a = time;\n\t\tint amin = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tamin=max(amin, dist[ys[i]][xs[i]][gy[i]][gx[i]]);\n\t\t}\n\t\treturn a+amin;\n\t}\n};\nclass Compare {\npublic:\n\t//aa?????????????????Â¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.geta() > r.geta();\n\t}\n};\nint getmemo(vector<int>xs, vector<int>ys) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\treturn memo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]];\n}\nvoid setmemo(vector<int>xs, vector<int>ys, const int value) {\n\tfor (int i = 0; i < 3 - xs.size(); ++i) {\n\t\txs.push_back(0);\n\t\tys.push_back(0);\n\t}\n\tmemo[xs[0]][xs[1]][xs[2]][ys[0]][ys[1]][ys[2]] = value;\n}\nbool check(const vector<int>&axs, const vector<int>&ays, vector<int>&bxs, vector<int>&bys) {\n\tint time;\n\tif (bxs.size() == 1)time = 0;\n\telse if (bxs.size() == 2)time = 1;\n\telse time = 3;\n\tfor (int i = 0; i < time; ++i) {\n\t\tint a = i;\n\t\tint b = (i + 1) % 3;\n\t\tif (axs[a] == bxs[b] && ays[a] == bys[b]&&axs[b]==bxs[a]&&ays[b]==bys[a]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (bxs[a] == bxs[b] && bys[a] == bys[b]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tfor (int k = 0; k < 15; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 15; ++l) {\n\t\t\t\t\t\tdist[i][j][k][l] = 1e9;\n\t\t\t\t\t\tfor (int m = 0; m < 15; ++m) {\n\t\t\t\t\t\t\tfor (int n = 0; n < 15; ++n) {\n\t\t\t\t\t\t\t\tmemo[i][j][k][l][m][n] = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}cin >> W >> H >> N;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H, vector<int>(W));\n\t\tvector<int>sx(3);\n\t\tvector<int>sy(3);\n\t\tgx.clear();\n\t\tgy.clear();\n\t\tgx.resize(N);\n\t\tgy.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tgetline(cin, st);\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] >= 'a'&&st[j] <= 'c') {\n\t\t\t\t\tsx[st[j] - 'a'] = j;\n\t\t\t\t\tsy[st[j] - 'a'] = i;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == ' ') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx[st[j] - 'A'] = j;\n\t\t\t\t\tgy[st[j] - 'A'] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H - 1; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i + 1][j]) {\n\t\t\t\t\tdist[i][j][i + 1][j] = 1;\n\t\t\t\t\tdist[i+1][j][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W-1; ++j) {\n\t\t\t\tif (!field[i][j] && !field[i][j+1]) {\n\t\t\t\t\tdist[i][j][i][j + 1] = 1;\n\t\t\t\t\tdist[i][j+1][i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tdist[i % 16][i / 16][i % 16][i / 16] = 0;\n\t\t\t\n\t\t}\n\t\tfor (int k = 0; k < 256; ++k) {\n\t\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\tdist[i % 16][i / 16][j % 16][j / 16] = min(dist[i % 16][i / 16][j % 16][j / 16], dist[i % 16][i / 16][k % 16][k / 16] + dist[k % 16][k / 16][j % 16][j / 16]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa,vector<aa>,Compare>que;\n\t\tque.push(aa{ sx,sy,0 });\n\t\tsetmemo(sx, sy, 0);\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t//cout << atop.geta();\n\t\t\tvector<int>nowxs(atop.xs);\n\t\t\tvector<int>nowys(atop.ys);\n\t\t\tif (nowxs == gx&&nowys == gy) {\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa a =que.top();\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//cout << a.geta() << endl;\n\t\t\t\t}\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 125; ++i) {\n\t\t\t\tint n(i);\n\t\t\t\tvector<int>nexxs, nexys;\n\t\t\t\tbool aok = true;\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tconst int way = n % 5;\n\t\t\t\t\tn /= 5;\n\t\t\t\t\tconst int nexx = nowxs[j] + dx[way];\n\t\t\t\t\tconst int nexy = nowys[j] + dy[way];\n\t\t\t\t\tif (field[nexy][nexx])aok = false;\n\t\t\t\t\tnexxs.push_back(nowxs[j] + dx[way]);\n\t\t\t\t\tnexys.push_back(nowys[j] + dy[way]);\n\t\t\t\t}\n\t\t\t\tif (!check(nowxs, nowys, nexxs, nexys))aok = false;\n\t\t\t\tif (aok) {\n\t\t\t\t\tif (getmemo(nexxs, nexys) > atop.time + 1) {\n\t\t\t\t\t\tsetmemo(nexxs, nexys, atop.time + 1);\n\t\t\t\t\t\tque.push(aa{ nexxs,nexys,atop.time + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define SIZE 16\n#define INF (1 << 21)\nint dx[]={0,0,1,-1,0};\nint dy[]={1,-1,0,0,0};\nshort cost[3][16][16];\nstring m[16];\nvoid bfs(int row,int column,int num,int ini);\nclass ghost{\npublic:\n  int p[3],n;\n  bool operator<(const ghost & a)const{\n    for(int i=0;i<3;i++){\n      if ( p[i] == a.p[i])continue;\n      else return p[i] < a.p[i];\n    }\n    return false;;\n  }\n  int calc(int column){\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,cost[i][p[i]/column][p[i]%column]);\n    }\n    return ret;\n  }\n};\n\nclass state{\npublic:\n  ghost data;\n  int cnt,h;\n  bool operator<(const state & a)const{\n    return cnt+h > a.cnt + a.h;\n    if ( cnt+h == a.cnt+a.h)return cnt > a.cnt;\n    return cnt+h > a.cnt+a.h;\n  }\n  bool move(int num,int direc,int row,int column){\n    int x= data.p[num]%column,y=data.p[num]/column;\n    int nex = x+dx[direc],ney =y+dy[direc];\n    if ( nex < 0 || ney<0 || nex >=column || ney>=row||m[ney][nex]=='#')return false;\n    data.p[num]=nex+ney*column;\n    return true;\n  }\n  bool legal(const state & source){\n    for(int i=0;i<data.n;i++){\n      for(int j=0;j<data.n;j++){\n\tif ( i == j)continue;\n\tif ( data.p[i] == data.p[j])return false;\n\tif ( data.p[i] == source.data.p[j] && \n\t     data.p[j] == source.data.p[i])return false;\n      }\n    }\n    return true;\n  }\n};\n\nvoid dfs(int row,int column,priority_queue<state> &Q,const state &source,\n\t state  dest,set<ghost>& S,int now,int n){\n  if ( n == now){\n    if ( dest.legal(source) && S.find(dest.data) == S.end()){\n      dest.h = dest.data.calc(column);\n      dest.cnt++;\n      S.insert(dest.data);\n      Q.push(dest);\n    }\n    return;\n  }\n  state temp = dest;\n  int chx,chy;\n  for(int i=0;i<5;i++){\n    dest = temp;\n    if (dest.move(now,i,row,column));\n    else continue;\n    dfs(row,column,Q,source,dest,S,now+1,n);\n\t\n  }\n}\n\n\nint a_star(int row,int column,ghost ini){\n  state first = {ini,0,ini.calc(column)};\n  priority_queue<state> Q;\n  set<ghost> S;\n  S.insert(ini);\n  Q.push(first);\n  while(!Q.empty()){\n    state now = Q.top();\n    Q.pop();\n    if (now.h == 0)return now.cnt;\n    dfs(row,column,Q,now,now,S,0,ini.n);\n  }\n  return -1;\n}\n\n\n\nmain(){\n  int column,row,n;\n  while(cin >> column >> row >> n && n ){\n    cin.ignore();\n    for(int i=0;i<row;i++){\n      getline(cin,m[i]);\n    }// end for taking inputdat a\n    ghost ini;\n    ini.n = n;\n    for(int i=0;i<row;i++){\n      for(int j=0;j<column;j++){\n\tif ( isupper(m[i][j])){\n\t  bfs(row,column,m[i][j]-'A',i*column+j);\n\t}else if ( islower(m[i][j])){\n\t  ini.p[m[i][j]-'a'] = i*column+j;\n\t}\n      }\n    }//end for initialization loop\n\n    cout << a_star(row,column,ini) << endl;\n  }\n}\n\n\n\nvoid bfs(int row,int column,int num,int ini){\n  queue<int> Q;\n  Q.push(ini);\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      cost[num][i][j] = INF;\n    }\n  }\n  cost[num][ini/column][ini%column]=0;\n  while(!Q.empty()){\n    int now = Q.front();\n    int x=now%column,y=now/column;\n    Q.pop();\n    for(int i=0;i<4;i++){\n      int nex = x+dx[i],ney = y+dy[i];\n      if ( nex < 0 || ney < 0 || nex >=column || ney >=row || m[ney][nex]=='#')\n\tcontinue;\n      if ( cost[num][y][x] +1 < cost[num][ney][nex]){\n\tcost[num][ney][nex]=cost[num][y][x]+1;\n\tQ.push(ney*column+nex);\n      }\n    }\n  }\n  /*\n  cout << \"bfs for \" << num<< \" th ghoast\" << endl;\n  for(int i=0;i<row;i++){\n    for(int j=0;j<column;j++){\n      if ( cost[num][i][j] == INF)cout << \"x  \";\n      else cout << cost[num][i][j] << \"  \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\nusing namespace std;\n \nconst int MAXW = 16;\nconst int MAXH = 16;\nconst int COSTSIZE = 14;\nconst int di[] = {0,1,0,-1,0};\nconst int dj[] = {1,0,-1,0,0};\nconst int INF = 1<<28;\n \nint W, H, N;\nstring C[MAXH];\nint cost[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nbool vis[COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE][COSTSIZE];\nint ans;\n\nstruct State {\n  vector<pair<int,int> > ps;\n  bool operator < (const State &s) const {\n    return ps < s.ps;\n  }\n};\n \nvector<pair<int,int> > npos(int i, int j) {\n  vector<pair<int,int> > v;\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(C[ni][nj] == '#') continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  return v;\n}\n \ninline void putCost(const State &s, int c) {\n  if(N == 1) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getCost(const State &s) {\n  if(N == 1) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return cost[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \ninline void putVis(const State &s, bool c) {\n  if(N == 1) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0] = c;\n  } else if(N == 2) {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0] = c;\n  } else {\n    vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1] = c;\n  }\n}\n \ninline int getVis(const State &s) {\n  if(N == 1) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][0][0][0][0];\n  } else if(N == 2) {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][0][0];\n  } else {\n    return vis[s.ps[0].first-1][s.ps[0].second-1][s.ps[1].first-1][s.ps[1].second-1][s.ps[2].first-1][s.ps[2].second-1];\n  }\n}\n \nvoid rec(vector<vector<pair<int,int> > > &v, queue<State> &que, const State &s, State &t, int k) {\n  if(k == N) {\n    if(!getVis(t)) {\n      if(getCost(t) == INF) {\n        que.push(t);\n        putCost(t, getCost(s) + 1);\n        putVis(t, true);\n      } else {\n        ans = min(ans, getCost(t) + getCost(s) + 1);\n        putVis(t, true);\n        throw 0;\n      }\n    }\n    return;\n  }\n \n  for(int i = 0; i < v[k].size(); ++i) {\n    bool flag = true;\n    t.ps[k] = v[k][i];\n    for(int j = 0; j < k; ++j) {\n      if(t.ps[k] == t.ps[j]) {\n        flag = false;\n        break;\n      }\n      if(s.ps[k] == t.ps[j] && s.ps[j] == t.ps[k]) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      rec(v, que, s, t, k+1);\n    }\n  }\n}\n \nbool isFinished(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    int ni = s.ps[i].first;\n    int nj = s.ps[i].second;\n    if(C[ni][nj]-'A' != i) return false;\n  }\n  return true;\n}\n \nvoid show(const State &s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s.ps[i].first << \", \" << s.ps[i].second;\n    cout << endl;\n  }\n}\n \nint bfs(State initS, bool flag = true) {\n  queue<State> que;\n  que.push(initS);\n  memset(vis, 0, sizeof(vis));\n  putCost(initS, 0);\n  putVis(initS, true);\n  while(!que.empty()) {\n    const State s = que.front();\n    que.pop();\n    if(!flag && getCost(s) >= 75) continue;\n    if(getCost(s)*2 >= ans) continue;\n    vector<vector<pair<int,int> > > v(N);\n    for(int i = 0; i < N; ++i) {\n      v[i] = npos(s.ps[i].first, s.ps[i].second);\n    }\n    State t = s;\n    rec(v, que, s, t, 0);\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> W >> H >> N && (W|H|N)) {\n    cin.ignore();\n    for(int i = 0; i < H; ++i) {\n      getline(cin, C[i]);\n    }\n    State s, t;\n    s.ps.resize(N);\n    t.ps.resize(N);\n    pair<int,int> a, b, c;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        int k;\n        k = C[i][j] - 'a';\n        if(0 <= k && k < N) {\n          s.ps[k] = make_pair(i,j);\n        }\n        k = C[i][j] - 'A';\n        if(0 <= k && k < N) {\n          t.ps[k] = make_pair(i,j);\n        }\n      }\n    }\n    fill(cost[0][0][0][0][0], cost[COSTSIZE][0][0][0][0], INF);\n    ans = INF;\n    bfs(t, false);\n    try {\n      bfs(s);\n    } catch(...) {}\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint W, H, N;\nbool field[16][16];\nbool reach[1 << 24];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nstruct State{\n\tarray<P, 3> cord;\n\tint cnt;\n\tState() : cnt(0) {\n\t\tcord.fill(P(0, 0));\n\t}\t\n\tint hash(){\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 3; i++) ret = (ret << 8) | (cord[i].first << 4) | cord[i].second;\n\t\treturn ret;\n\t}\n\n};\nState target;\n\nint score(const State& s){\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tans = max(ans, abs(target.cord[i].first - s.cord[i].first) + abs(target.cord[i].second - s.cord[i].second));\n\t}\n\treturn ans + s.cnt;\n}\nbool operator<(const State& ss1, const State& ss2){\n\tint s1 = score(ss1);\n\tint s2 = score(ss2);\n\tif(s1 != s2) return s2 < s1;\n\telse ss1.cord < ss2.cord;\n}\n\nostream& operator<<(ostream& os, const State& dt)  {  \n\tos << \"[\";\n\tfor(int i = 0; i < N; i++){\n\t\tos << \"(\" << dt.cord[i].first << \",\" << dt.cord[i].second << \")\";\n\t}\n\tos << dt.cnt << \"]\";\n\treturn os;  \n}  \n\nvoid dfs(priority_queue<State> &que, State &prev, int idx, State n){\n\tif(idx == N){\n\t\tif(\n\t\t\t\tN >= 2 && prev.cord[0] == n.cord[1] && prev.cord[1] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[0] == n.cord[2] && prev.cord[2] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[1] == n.cord[2] && prev.cord[2] == n.cord[1] ||\n\t\t\t\tN >= 2 && n.cord[0] == n.cord[1]  ||\n\t\t\t\tN >= 3 && n.cord[0] == n.cord[2]  ||\n\t\t\t\tN >= 3 && n.cord[1] == n.cord[2]  \n\t\t  ) return;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!field[n.cord[i].second][n.cord[i].first]) return;\n\t\t}\n\t\tn.cnt++;\n\t\tque.push(n);\n\n\t}else{\n\t\tdfs(que, prev, idx + 1, n);\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tn.cord[idx] = P(prev.cord[idx].first + dx[i], prev.cord[idx].second + dy[i]);\n\t\t\tdfs(que, prev, idx + 1, n);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H >> N, W){\n\t\tState begin;\n\t\tstring str;\n\t\tgetline(cin, str);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tgetline(cin, str);\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tchar c = str[j];\n\t\t\t\tif(c == '#') field[i][j] = false;\n\t\t\t\telse{\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t\tif('A' <= c && c <= 'C') target.cord[c - 'A'] = P(j, i);\n\t\t\t\t\telse begin.cord[c - 'a'] = P(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < (1 << 24); i++) reach[i] = false;\n\t\tpriority_queue<State> que;\n\t\tque.push(begin);\n\t\tint ans = -1;\n\t\twhile(que.size()){\n\t\t\tState s = que.top(); que.pop();\n\t\t\tif(s.cord == target.cord){\n\t\t\t\tans = s.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(reach[s.hash()]) continue;\n\t\t\treach[s.hash()] = true;\n\t\t\tdfs(que, s, 0, s);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tint x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1 && v[X] <= d + 1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[5] = {1, 0, -1, 0, 0};\nint dy[5] = {0, 1, 0, -1, 0};\ntypedef pair<int, int> P;\nconst int MAX_L = 16;\nconst int MAX_N = 3;\nstruct State{\n  P p[MAX_N];\n  int d, f;\n  State(P pp[MAX_N], int dd, int hh){\n    REP(i, MAX_N) p[i] = pp[i];\n    d = dd;\n    f = dd + hh;\n  }\n  bool operator < (const State& s) const {\n    if(f != s.f) return f > s.f;\n    return d > s.d;\n  }\n};\nint W, H, N;\nstring grid[MAX_L];\nint make(const P p[MAX_N]){\n  int res = 0;\n  REP(i, N) {\n    res = res << 8 | (p[i].first << 4) | p[i].second;\n  }\n  return res;\n}\nvoid add(const State& s, map<int, int>& dist, priority_queue<State>& que){\n  int k = make(s.p);\n  if(!dist.count(k) || dist[k] > s.d){\n    dist[k] = s.d;\n    que.push(s);\n  }\n}\nbool equal(P p[MAX_N], P q[MAX_N]){\n  REP(i, N) if(p[i] != q[i]) return false;\n  return true;\n}\nbool valid(int x, int y, int W, int H){\n  return (x >= 0 && y >= 0 && x < W && y < H) && grid[y][x] != '#';\n}\nbool valid(const State& s, const State& prev){\n  REP(i, N) if(!valid(s.p[i].first, s.p[i].second, W, H)) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == s.p[j]) return false;\n  FOR(i, 0, N) FOR(j, i + 1, N) if(s.p[i] == prev.p[j] && s.p[j] == prev.p[i]) return false;\n  return true;\n}\nint memo[16][16][16][16];\nint calc_distance(P p, P goal){\n  if(!valid(p.first, p.second, W, H)) return INF;\n  if(p == goal) return 0;\n  int& dist = memo[p.first][p.second][goal.first][goal.second];\n  if(dist != -1) return dist;\n  dist = INF;\n  REP(r, 4){\n    P q = p;\n    q.first += dx[r];\n    q.second += dy[r];\n    dist = min(dist, calc_distance(q, goal) + 1);\n  }\n  return dist;\n}\nvoid print(State s){\n  printf(\"d = %d h = %d f = %d \", s.d, s.f - s.d, s.f);\n  REP(i, N) printf(\"(%d, %d) \", s.p[i].first, s.p[i].second);\n  cout << endl;\n}\nint main(){\n  while(cin >> W >> H >> N && N){\n    memset(memo, -1, sizeof memo);\n    cin.ignore();\n    REP(y, H) getline(cin, grid[y]);\n    P goal[MAX_N];\n    P start[MAX_N];\n    REP(y, H)REP(x, W){\n      if(islower(grid[y][x])){\n        int k = grid[y][x] - 'a';\n        grid[y][x] = ' ';\n        start[k] = P(x, y);\n      }\n      if(isupper(grid[y][x])){\n        int k = grid[y][x] - 'A';\n        grid[y][x] = ' ';\n        goal[k] = P(x, y);\n      }\n    }\n    map<int, int> dist;\n    priority_queue<State> que;\n    State init(start, 0, 0);\n    add(init, dist, que);\n    while(!que.empty()){\n      State s = que.top(); que.pop();\n      //print(s);\n      if(equal(s.p, goal)) {\n        cout << s.d << endl;\n        break;\n      }\n      REP(SR, 5 * 5 * 5){\n        int R = SR;\n        State next = s;\n        REP(i, N){\n          int r = R % 5;\n          R /= 5;\n          next.p[i].first += dx[r];\n          next.p[i].second += dy[r];\n        }\n        if(!valid(next, s)) continue;\n        next.d ++;\n        int h = 0;\n        REP(i, N){\n          h = max(h, calc_distance(next.p[i], goal[i]));\n        }\n        next.f = next.d + h;\n        add(next, dist, que);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,vector<int> > P;\ntypedef pair<int,int> S;\n\nint w,h,n;\nstring s[20];\nint ax[]={1,-1,0,0,0};\nint ay[]={0,0,1,-1,0};\n\n\nS i2s(int x){\n  return S(x>>12,x&((1<<12)-1));\n}\nint s2i(const S& s){\n  //cout<<s.first<<\" \"<<s.second<<\":\"<<(s.first<<13)+s.second<<endl;\n  return (s.first<<12)+s.second;\n}\nS p2s(const P& p){\n  int y=0,x=0;\n  for(int i=n-1;i>=0;i--){\n    y=y*16+p.first[i];\n    x=x*16+p.second[i];\n  }\n  return S(y,x);\n}\nP s2p(const S& s){\n  vector<int> y,x;\n  int a=s.first,b=s.second;\n  for(int i=0;i<n;i++){\n    y.push_back(a%16);\n    x.push_back(b%16);\n    a/=16;b/=16;\n  }\n  return P(y,x);\n}\n\nint p2i(const P& p){\n  return s2i(p2s(p));\n}\nP i2p(int x){\n  return s2p(i2s(x));\n}\n\n\nshort m[1<<26];\nqueue<int> q;\n\nvector<int> ys,xs;\nvoid dfs(int d,P& p,int xyz){\n  if(d==n){\n    P r=P(ys,xs);\n    int abc=p2i(r);\n    if(~m[abc]) return;\n    m[abc]=m[xyz]+1;\n    q.push(abc);\n    return;\n  }\n  for(int k=0;k<5;k++){\n    int ny=p.first[d]+ay[k],nx=p.second[d]+ax[k];\n    if(ny<0||h<=ny||nx<0||w<=nx) continue;\n    if(s[ny][nx]=='#') continue;\n    bool f=0;\n    for(int j=0;j<d;j++){\n      f|=(ys[j]==ny&&xs[j]==nx);\n      f|=(ys[j]==p.first[d]&&xs[j]==p.second[d])&&\n\t (ny==p.first[j]&&nx==p.second[j]);\n    }\n    if(f) continue;\n    ys.push_back(ny);\n    xs.push_back(nx);\n    dfs(d+1,p,xyz);\n    ys.pop_back();\n    xs.pop_back();\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h>>n,w||h||n){\n    cin.ignore();\n    for(int i=0;i<h;i++) getline(cin,s[i]);\n    vector<int> yt(n),xt(n);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(islower(s[i][j])){\n\t  yt[s[i][j]-'a']=i;\n\t  xt[s[i][j]-'a']=j;\n\t}\n    memset(m,-1,sizeof(m));\n    while(!q.empty()) q.pop();\n    q.push(p2i(P(yt,xt)));\n    m[p2i(P(yt,xt))]=0;\n    int ans=-1;\n    while(!q.empty()){\n      int xyz=q.front();q.pop();\n      P p=i2p(xyz);\n      //cout<<xyz<<\":\"<<m[xyz]<<endl;\n      //for(int i=0;i<n;i++) cout<<p.first[i]<<\" \"<<p.second[i]<<endl;\n      bool flg=1;\n      for(int i=0;i<n;i++)\n\tflg&=(s[p.first[i]][p.second[i]]=='A'+i);\n      if(flg){\n\tans=m[xyz];\n\tbreak;\n      }\n      dfs(0,p,xyz);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 16 * 16 + 2;\n//const int IINF = INT_MAX;\nconst short IINF = 230;\nstruct Data {\n  int p[3],cost;\n  \n  bool operator < ( const Data &data ) const {\n    return cost > data.cost;\n  }\n};\n\n\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint w,h,n,gn,sn;\nchar c[20][20];\nshort mindist[MAX][MAX][MAX];\n\nint gs[3],sp[3];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nbool isValidMove(Data cur,Data next){\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == next.p[j] ) return false;\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == cur.p[j] && next.p[j] == cur.p[i] ) return false;\n  return true;\n}\n\nvoid printState(Data cur){\n  rep(i,h){\n    rep(j,w){\n      bool f = false;\n      rep(k,sn) if( cur.p[k] == j + i*w ) {\n\tcout << (char)('a'+k);\n\tf = true;\n\tbreak;\n      }\n      if( f ) continue;\n      cout << c[i][j];\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nvoid dfs(priority_queue<Data> &Q,int cur,Data state,int mask,Data prev){\n  if( cur >= sn ) {\n\n    if( isValidMove(prev,state) ) {\n\n      int A=MAX-1,B=MAX-1,C=MAX-1;\n      if( sn >= 1 ) A = state.p[0];\n      if( sn >= 2 ) B = state.p[1];\n      if( sn >= 3 ) C = state.p[2];\n      if( mindist[A][B][C] > state.cost ) {\n\tmindist[A][B][C] = state.cost;\n\tQ.push(state);\n      }\n\n    }\n    return;\n  }\n  if( !( ( mask >> cur ) & 1 ) ) {\n    dfs(Q,cur+1,state,mask,prev);\n    return;\n  }\n  int x = state.p[cur] % w, y = state.p[cur] / w;\n  rep(i,5){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( c[ny][nx] == '#' ) continue;\n    state.p[cur] = nx + ny * w;\n    dfs(Q,cur+1,state,mask,prev);\n  }\n  state.p[cur] = x + y * w;\n}\n\nvoid pushNextState(priority_queue<Data> &Q,int mask,int cost,Data cdata){\n  Data state = cdata;\n  ++state.cost;\n  dfs(Q,0,state,mask,cdata);\n}\n\n\n\nvoid compute(){\n  rep(i,MAX)rep(j,MAX)rep(k,MAX) mindist[i][j][k] = IINF;\n  gn = 0;\n  rep(i,h) rep(j,w) if( 'A' <= c[i][j] && c[i][j] <= 'C' ) {\n    gs[c[i][j]-'A'] = j + i * w;\n    c[i][j] = '.';\n    ++gn;\n  }\n\n  sn = 0;\n  rep(i,h) rep(j,w) if( 'a' <= c[i][j] && c[i][j] <= 'c' ) {\n    sp[c[i][j]-'a'] = j + i * w;\n    c[i][j] = '.';\n    ++sn;\n  }\n  priority_queue<Data> Q;\n  {\n    Data data;\n    data.cost = 0;\n    rep(i,sn) data.p[i] = sp[i];\n    Q.push(data);\n  }\n  bool found = false;\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n\n    bool fin = true;\n    rep(i,gn) if( gs[i] != data.p[i] ) {\n      fin = false;\n      break;\n    }\n    if( fin ) {\n      found = true;\n\n      printf(\"%d\\n\",data.cost);\n      return;\n    }\n    rep(mask,(1<<sn)){\n      pushNextState(Q,mask,data.cost,data);\n    }\n    \n  }\n  assert(found);\n}\n\nint main(){\n  while( cin >> w >> h >> n, w|h|n ){\n    cin.ignore();\n    rep(i,h) {\n      string s;\n      getline(cin,s);\n      rep(j,w) {\n\tif( s[j] == ' ' ) s[j] = '.';\n\tc[i][j] = s[j];\n      }\n    }\n\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cctype>\n\nusing namespace std;\n\nstruct S{\n  int p[3][2];\n  int t;\n};\n\nint main(){\n  for(int w,h,n;cin>>w>>h>>n,w;){\n    cin.ignore();\n    char g[16][16];\n    S is={{},0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin.get(g[i][j]);\n\tif(islower(g[i][j])){\n\t  auto x=g[i][j]-'a';\n\t  is.p[x][0]=i;\n\t  is.p[x][1]=j;\n\t}\n      }\n      cin.ignore();\n    }\n    queue<S> que;\n    que.push(is);\n    set<int> p;\n    for(;;){\n      S cs=que.front();\n      bool f=false;\n      for(int i=0;i<n;i++){\n\tf|=g[cs.p[i][0]][cs.p[i][1]]!='A'+i;\n      }\n      if(!f)break;\n      que.pop();\n      int b=0;\n      for(int i=0;i<n;i++){\n\tb=b<<8|cs.p[i][0]<<4|cs.p[i][1];\n      }\n      if(!p.insert(b).second)continue;\n      static int dy[]={-1,0,0,0,1};\n      static int dx[]={0,-1,0,1,0};\n      for(int i=0;i<5;i++){\n\tint y1,x1,y2,x2,y3,x3;\n\ty1=cs.p[0][0]+dy[i];\n\tx1=cs.p[0][1]+dx[i];\n\ty2=cs.p[1][0];\n\tx2=cs.p[1][1];\n\ty3=cs.p[2][0];\n\tx3=cs.p[2][1];\n\tif(g[y1][x1]=='#')continue;\n\tif(n==1){\n\t  que.push({y1,x1,y2,x2,y3,x3,cs.t+1});\n\t}else{\n\t  for(int j=0;j<5;j++){\n\t    y2=cs.p[1][0]+dy[j];\n\t    x2=cs.p[1][1]+dx[j];\n\t    if(g[y2][x2]=='#'||y2==y1&&x2==x1||y1==cs.p[1][0]&&x1==cs.p[1][1]&&y2==cs.p[0][0]&&x2==cs.p[0][1])continue;\n\t    if(n==2){\n\t      que.push({y1,x1,y2,x2,y3,x3,cs.t+1});\n\t    }else{\n\t      for(int k=0;k<5;k++){\n\t\ty3=cs.p[2][0]+dy[k];\n\t\tx3=cs.p[2][1]+dx[k];\n\t\tif(g[y3][x3]=='#'||y3==y1&&x3==x1||y3==y2&&x3==x2||y3==cs.p[0][0]&&x3==cs.p[0][1]&&y1==cs.p[2][0]&&x1==cs.p[2][1]||y3==cs.p[1][0]&&x3==cs.p[1][1]&&y2==cs.p[2][0]&&x2==cs.p[2][1])continue;\n\t\tque.push({y1,x1,y2,x2,y3,x3,cs.t+1});\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.front().t<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[] = {-1, 0, 1, 0, 0}, dx[] = {0, -1, 0, 1, 0};\nint w, h, n, gx[3], gy[3], y[3], x[3], nx[3], ny[3];\nint dist[16*16][16*16];\nstring in[20];\npriority_queue<ll> q;\nset<int> s;\n\nvoid push(int cost, int c){\n\tif(c == n){\n\t\trep(i,n) rep(j,i){\n\t\t\tif(ny[i] == ny[j] && nx[i] == nx[j]) return;\n\t\t\tif(ny[i] == y[j] && nx[i] == x[j] &&\n\t\t\t\t ny[j] == y[i] && nx[j] == x[i]) return;\n\t\t}\n\t\tll tmp = cost;\n\t\trep(i,n) tmp += dist[ny[i]*w + nx[i]][gy[i]*w + gx[i]];\n\t\ttmp <<= 10;\n\t\ttmp += cost;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += ny[i] << 4 | nx[i];\n\t\t}\n\t\tif(!s.count(tmp & (1<<8*n) - 1)) q.push(-tmp);\n\t\treturn;\n\t}\n\trep(d,5){\n\t\tny[c] = y[c] + dy[d];\n\t\tnx[c] = x[c] + dx[d];\n\t\tif(ny[c] < 0 || ny[c] >= h || nx[c] < 0 || nx[c] >= w) continue;\n\t\tif(in[ny[c]][nx[c]] == '#') continue;\n\t\tpush(cost, c+1);\n\t}\n}\n\nint main()\n{\n\twhile(cin >> w >> h >> n, w){\n\t\tcin.ignore();\n\t\tint sx[3], sy[3];\n\t\trep(i,h){\n\t\t\tgetline(cin, in[i]);\n\t\t\trep(j,w) if(isalpha(in[i][j])){\n\t\t\t\tint k = tolower(in[i][j]) - 'a';\n\t\t\t\tif(islower(in[i][j])) sy[k] = i, sx[k] = j;\n\t\t\t\telse gy[k] = i, gx[k] = j;\n\t\t\t}\n\t\t}\n\t\trep(i,h*w){\n\t\t\trep(j,h*w) dist[i][j] = i == j ? 0 : inf;\n\t\t\trep(d,4){\n\t\t\t\tint ny = i / w + dy[d], nx = i % w + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i][ny*w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k,h*w) rep(i,h*w) rep(j,h*w)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tq = priority_queue<ll>();\n\t\ts.clear();\n\t\t\n\t\tll tmp = 0;\n\t\trep(i,n) tmp += dist[sy[i]*w + sx[i]][gy[i]*w + gx[i]];\n\t\ttmp <<= 10;\n\t\trep(i,n){\n\t\t\ttmp <<= 8;\n\t\t\ttmp += sy[i] << 4 | sx[i];\n\t\t}\n\t\tq.push(-tmp);\n\t\t\n\t\twhile(!q.empty()){\n\t\t\ttmp = -q.top(); q.pop();\n\t\t\tint state = tmp & (1<<8*n) - 1;\n\t\t\tif(s.count(state)) continue;\n\t\t\ts.insert(state);\n\t\t\t\n\t\t\tbool ok = 1;\n\t\t\tfor(int i = n-1; i >= 0; i--){\n\t\t\t\ty[i] = tmp >> 4 & 15;\n\t\t\t\tx[i] = tmp & 15;\n\t\t\t\ttmp >>= 8;\n\t\t\t\tif(y[i] != gy[i] || x[i] != gx[i]) ok = 0;\n\t\t\t}\n\t\t\tint cost = tmp & (1<<10) - 1;\n\t\t\tif(ok){\n\t\t\t\tcout << cost << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t\tpush(cost+1, 0);\n\t\t}\n\t\t\n\t\tcout << -1 << endl;\n\t\tEND:;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[3][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tunsigned char x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[i][s.y[i]][s.x[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S& ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int l = 0; l < n; l++) {\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push(make_pair(gx[l], gy[l]));\n\t\t\t\t\tdist[l][gy[l]][gx[l]] = 0;\n\t\t\t\t\twhile(q.size()) {\n\t\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\t\tif(dist[l][ny][nx] != -1) continue;\n\t\t\t\t\t\t\tdist[l][ny][nx] = dist[l][y][x] + 1;\n\t\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t\tif(q.size() > 10000) q.pop();\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<ctime>\n#include<deque>\n#include<cstdlib>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 17\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\n\nint dx[] = {+0,+1,+0,-1,0};\nint dy[] = {+1,+0,-1,+0,0};\n\nstruct P\n{\n  int p[3],cost;\n  char c[3];\n  P(int cost=inf):cost(cost){ p[0] = p[1] = p[2] = inf; }\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nmap<ull,int> mincostR,mincost;\nint w,h,n;\nchar G[MAX][MAX],cc[3];\nchar initialD[MAX][MAX];\null hash[MAX][MAX],tmp[MAX][MAX];\nint ev[MAX*MAX][MAX*MAX];//A*ç¨è©ä¾¡å¤\nint pp[3],dex=0;\nint goal[3];\n\null getHash(char a[MAX][MAX])\n{\n  const ull B1 = 9973;\n  const ull B2 = 1000000007;\n\n  ull t1 = 1;\n  rep(i,w)t1 *= B1;\n\n  rep(i,h)\n    {\n      ull e = 0;\n      rep(j,w)e = e * B1 + a[i][j];\n\n      for(int j=0;j+w<=w;j++)\n\t{\n\t  tmp[i][j] = e;\n\t  if(j+w<w)e = e * B1 - t1 * a[i][j] + a[i][j+w];\n\t}\n    }\n\n  ull t2 = 1;\n  rep(i,h)t2 *= B2;\n\n  for(int j=0;j+w<=w;j++)\n    {\n      ull e = 0;\n      rep(i,w) e = e * B2 + tmp[i][j];\n\n      for(int i=0;i+h<=h;i++)\n\t{\n\t  hash[i][j] = e;\n\t  if(i+h<h)e = e * B2 - t2 * tmp[i][j] + tmp[i+h][j];\n\t}\n    }\n  return hash[0][0];\n}\n\nbool isValidMove(int p11,int p12,int p21,int p22)\n{\n  if(p12 == p22)return false;//visited same point\n  if(p12 == p21 && p11 == p22)return false;//cross\n\n  return true;\n}\n\nvoid print(char a[MAX][MAX])\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  cout << a[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid preComputing(int depth)\n{\n  mincostR.clear();\n  //char initialD[MAX][MAX];\n  //int pp[n],dex=0,cc[n];\n  dex = 0;\n  rep(i,h)rep(j,w)\n    {\n      initialD[i][j] = G[i][j];\n      if('A' <= initialD[i][j] && initialD[i][j] <= 'Z')initialD[i][j] = (char)('a'+initialD[i][j]-'A');\n      else if('a' <= initialD[i][j] && initialD[i][j] <= 'z')initialD[i][j] = ' ';\n      if('a' <= initialD[i][j] && initialD[i][j] <= 'z')\n\t{\n\t  pp[dex] = i * w + j,cc[dex] = initialD[i][j];\n\t  //cout << \"pre pp[\" << dex << \"] = \" << pp[dex] % w << \",\" << pp[dex] / w << endl;\n\t  //cout << \"pre cc[\" << dex << \"] = \" << cc[dex] << endl;\n\t  dex++;\n\t}\n    }\n\n  assert(dex == n);\n  mincostR[getHash(initialD)] = 0;\n  rep(i,n)\n    {\n      int x = pp[i] % w;\n      int y = pp[i] / w;\n      initialD[y][x] = (char)('A'+initialD[y][x]-'a');\n    }\n\n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      //cout << p.cost << \" >= \" << depth << endl;\n      if(p.cost >= depth)return;\n\n      /*\n      char store[n];\n      int x[n],y[n];\n      rep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n      rep(i,n)store[i] = initialD[y[i]][x[i]];\n      rep(i,n)initialD[y[i]][x[i]] = p.c[i];\n      cout << \"cost : \" << p.cost << endl;\n      print(initialD);\n      rep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t{\n\t\t  mincostR[hsh] = p.cost + 1;\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  //cout << \"go next : \" << endl;\n\t\t  //print(initialD);\n\t\t  //cout << \"}}}}}}}}}}}}\" << endl;\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincostR.find(hsh) == mincostR.end())\n\t\t    {\n\t\t      //cout << \"yes,go next\\n\";\n\t\t      mincostR[hsh] = p.cost + 1;\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t  //else cout << \"no continue\" << endl;\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\t\t      if(mincostR.find(hsh) == mincostR.end())\n\t\t\t{\n\t\t\t  mincostR[hsh] = p.cost + 1;\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  \n}\n\n\nvoid makeEv()\n{\n  rep(y,MAX*MAX)rep(x,MAX*MAX)ev[y][x] = inf;\n\n  /*\n  rep(y,h)rep(x,w)\n    {\n      deque<ii> deq;\n      deq.push_back(ii(x+y*w,0));\n      ev[y*w+x][y*w+x] = 0;\n      //cout << \"cur ( \" << x << \",\" << y << \")\\n\";\n      while(!deq.empty())\n\t{\n\t  ii state = deq.front(); deq.pop_front();\n\t  int cx = state.first % w;\n\t  int cy = state.first / w;\n\t  //cout << \"state(\" << state.first%w << \",\" << state.first/w << \" : \" << state.second << \")\\n\";\n\t  rep(j,4)\n\t    {\n\t      int nx = cx + dx[j];\n\t      int ny = cy + dy[j];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(ev[cy*w+cx][ny*w+nx] > state.second + 1)\n\t\t{\n \t\t  ev[cy*w+cx][ny*w+nx] = state.second + 1;\n\t\t  deq.push_back(ii(nx+ny*w,state.second+1));\n\t\t}\n\t    }\n\t}\n    }\n  */\n\n  //int x = 1,y = 3;\n  rep(y,h)rep(x,w)\n    {\n\n  deque<ii> deq;\n  deq.push_back(ii(x+y*w,0));\n  ev[x+y*w][x+y*w] = 0;\n  while(!deq.empty())\n    {\n      ii state = deq.front(); deq.pop_front();\n      int cx = state.first % w;\n      int cy = state.first / w;\n      rep(i,4)\n\t{\n\t  int nx = cx + dx[i];\n\t  int ny = cy + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(G[ny][nx] == '#')continue;\n\t  if(ev[x+y*w][nx+ny*w] > state.second + 1)\n\t    {\n\t      ev[x+y*w][nx+ny*w] = state.second + 1;\n\t      deq.push_back(ii(nx+ny*w,state.second+1));\n\t    }\n\t}\n    }\n\n\n    }\n\n}\n\nvoid compute()\n{\n  mincost.clear();\n\n  dex = 0;\n  rep(y,h)rep(x,w)\n    if('a' <= G[y][x] && G[y][x] <= 'z')\n      pp[dex] = x + y * w,cc[dex++] = G[y][x]; \n\n\n  rep(i,n)\n    {\n      char c = cc[i];\n      c = (char)('A'+c-'a');\n      map<char,int> index;\n      rep(y,h)rep(x,w)index[G[y][x]] = y * w + x;\n      goal[i] = index[c];\n      //cout << \"pp = \" << pp[i]%w << \",\" << pp[i]/w << endl;\n      //cout << cc[i] << \" c = \" << c << endl;\n      //cout << \"goal[\" << i << \"] = \" << goal[i] % w << \",\" << goal[i] / w << endl;\n    }    \n\n  \n  priority_queue<P> Q;\n  {\n    P prep = P(0);\n    rep(i,dex)prep.p[i] = pp[i],prep.c[i] = cc[i];\n    Q.push(prep);\n  }\n\n  int ans = inf;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      int add_cost = 0;\n      rep(i,n)\n\t{\n\t  add_cost = max(add_cost,ev[p.p[i]][goal[i]]);\n\t  //cout << \"e[\"<<p.p[i]%w << \",\" <<p.p[i]/w<<\"][\"<<goal[i]%w << \",\" << goal[i]/w<<\"] = \" << ev[p.p[i]][goal[i]] << endl;\n\t}\n      //cout << p.cost << \" + \" << add_cost << \" >= \" << ans << endl;\n      if(p.cost+add_cost >= ans)continue;\n\n\n      /*\n\tchar store[n];\n\tint x[n],y[n];\n\trep(i,n)x[i] = p.p[i] % w,y[i] = p.p[i] / w;\n\trep(i,n)store[i] = initialD[y[i]][x[i]];\n\trep(i,n)initialD[y[i]][x[i]] = p.c[i];\n\tcout << \"cost : \" << p.cost << endl;\n\tprint(initialD);\n\trep(i,n)initialD[y[i]][x[i]] = store[i];\n      */\n\n      if(n == 1)\n\t{\n\t  int x = p.p[0] % w;\n\t  int y = p.p[0] / w;\n\t  char c = p.c[0];\n\t  rep(i,5)\n\t    {\n\t      int nx = x + dx[i];\n\t      int ny = y + dy[i];\n\t      if(!( 0 <= nx && nx < w && 0 <= ny && ny < h ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      \n\t      char store = initialD[ny][nx];\n\t      initialD[ny][nx] = c;\n\t      ull hsh = getHash(initialD);\n\t      initialD[ny][nx] = store;\n\t      if(mincost.find(hsh) == mincost.end())\n\t\t{\n\t\t  mincost[hsh] = p.cost + 1;\n\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t    {\n\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t      continue;\n\t\t    }\n\t\t  P next = P(p.cost+1);\n\t\t  next.p[0] = nx + ny * w;\n\t\t  next.c[0] = c;\n\t\t  Q.push(next);\n\t\t}\n\t    }\n\t}\n      else if(n == 2)\n\t{\n\t  assert(p.p[0] != inf && p.p[1] != inf);\n\t  int x1 = p.p[0] % w;\n\t  int y1 = p.p[0] / w;\n\t  int x2 = p.p[1] % w;\n\t  int y2 = p.p[1] / w;\n\t  assert(G[y1][x1] != '#' && G[y2][x2] != '#');\n\n\t  rep(i,5)\n\t    {\n\t      int nx1 = x1 + dx[i];\n\t      int ny1 = y1 + dy[i];\n\t      if(!( 0 <= nx1 && nx1 < w && 0 <= ny1 && ny1 < h ))continue;\n\t      if(G[ny1][nx1] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  int nx2 = x2 + dx[j];\n\t\t  int ny2 = y2 + dy[j];\n\t\t  if(!( 0 <= nx2 && nx2 < w && 0 <= ny2 && ny2 < h ))continue;\n\t\t  if(G[ny2][nx2] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx1+ny1*w,p.p[1],nx2+ny2*w))continue;\n\n\t\t  char store1 = initialD[ny1][nx1],store2 = initialD[ny2][nx2];\n\t\t  initialD[ny1][nx1] = p.c[0];\n\t\t  initialD[ny2][nx2] = p.c[1];\n\t\t  ull hsh = getHash(initialD);\n\t\t  initialD[ny1][nx1] = store1;\n\t\t  initialD[ny2][nx2] = store2;\n\n\t\t  if(mincost.find(hsh) == mincost.end())\n\t\t    {\n\t\t      mincost[hsh] = p.cost + 1;\n\t\t      if(mincostR.find(hsh) != mincostR.end())\n\t\t\t{\n\t\t\t  ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t  continue;\n\t\t\t}\n\t\t      P next = P(p.cost+1);\n\t\t      next.p[0] = nx1 + ny1 * w;\n\t\t      next.p[1] = nx2 + ny2 * w;\n\t\t      rep(k,2)next.c[k] = p.c[k];//MUDA\n\t\t      Q.push(next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if(n == 3)\n\t{\n\n\t  int x[3],y[3],nx[3],ny[3];\n\t  rep(i,3)x[i] = p.p[i] % w, y[i] = p.p[i] / w;\n\n\t  rep(i,5)\n\t    {\n\t      nx[0] = x[0] + dx[i];\n\t      ny[0] = y[0] + dy[i];\n\t      if(!( 0 <= nx[0] && nx[0] < w && 0 <= ny[0] && ny[0] < h ))continue;\n\t      if(G[ny[0]][nx[0]] == '#')continue;\n\n\t      rep(j,5)\n\t\t{\n\t\t  nx[1] = x[1] + dx[j];\n\t\t  ny[1] = y[1] + dy[j];\n\t\t  if(!( 0 <= nx[1] && nx[1] < w && 0 <= ny[1] && ny[1] < h ))continue;\n\t\t  if(G[ny[1]][nx[1]] == '#')continue;\n\t\t  if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[1],nx[1]+ny[1]*w))continue;\n\n\t\t  rep(k,5)\n\t\t    {\n\t\t      nx[2] = x[2] + dx[k];\n\t\t      ny[2] = y[2] + dy[k];\n\t\t      if(!( 0 <= nx[2] && nx[2] < w && 0 <= ny[2] && ny[2] < h ))continue;\n\t\t      if(G[ny[2]][nx[2]] == '#')continue;\n\t\t      if(!isValidMove(p.p[0],nx[0]+ny[0]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\t\t      if(!isValidMove(p.p[1],nx[1]+ny[1]*w,p.p[2],nx[2]+ny[2]*w))continue;\n\n\t\t      char store[3];\n\t\t      rep(l,3)store[l] = initialD[ny[l]][nx[l]];\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = p.c[l];\n\t\t      ull hsh = getHash(initialD);\n\t\t      rep(l,3)initialD[ny[l]][nx[l]] = store[l];\n\n\t\t      if(mincost.find(hsh) == mincost.end())\n\t\t\t{\n\t\t\t  mincost[hsh] = p.cost + 1;\n\t\t\t  if(mincostR.find(hsh) != mincostR.end())\n\t\t\t    {\n\t\t\t      ans = min(ans,p.cost+1+mincostR[hsh]);\n\t\t\t      continue;\n\t\t\t    }\n\t\t\t  P next = P(p.cost + 1);\n\t\t\t  rep(l,3)next.p[l] = nx[l] + ny[l] * w,next.c[l] = p.c[l];\n\t\t\t  Q.push(next);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n    }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl; \n}\n\nint main()\n{\n  //clock_t st,ed;\n  //st = clock();\n  while(scanf(\"%d %d %d\",&w,&h,&n),w|h|n)\n    {\n      rep(i,h)\n\t{\n\t  getchar();\n\t  rep(j,w)\n\t    scanf(\"%c\",&G[i][j]);\n\t}\n      preComputing(25);//å¤§ããããã¨MLEãå°ããããã¨TLE\n      makeEv();\n      compute();\n\n    }\n\n  //ed = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << \"time : \" << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dy[5]={0,-1,0,1,0};\nint dx[5]={0,0,1,0,-1};\nint H,W,N;\nstring str;\nchar t[16][16];\nint d[14][14][14][14][14][14];\nint sy[3],sx[3],ty[3],tx[3];\n\nstruct state{\n  int y0,x0,y1,x1,y2,x2;\n};\n\nint solve(){\n  state s;\n  s.y0=sy[0];s.x0=sx[0];\n  s.y1=sy[1];s.x1=sx[1];\n  s.y2=sy[2];s.x2=sx[2];\n  \n  for(int i=0;i<H-2;i++)\n    for(int j=0;j<W-2;j++)\n      for(int i2=0;i2<H-2;i2++)\n        for(int j2=0;j2<W-2;j2++)\n          for(int i3=0;i3<H-2;i3++)\n            for(int j3=0;j3<W-2;j3++)\n              d[i][j][i2][j2][i3][j3]=1e9;\n  \n  d[s.y0][s.x0][s.y1][s.x1][s.y2][s.x2]=0;\n  \n  queue< state > Q;\n  \n  Q.push(s);\n\n  while(!Q.empty()){\n    //if(Tc++ >10) break;\n    \n    s=Q.front();Q.pop();\n    \n    int cost=d[s.y0][s.x0][s.y1][s.x1][s.y2][s.x2];\n\n    int y0=s.y0,x0=s.x0;\n    int y1=s.y1,x1=s.x1;\n    int y2=s.y2,x2=s.x2;\n    /*\n    cout<<cost<<' '<<y0<<' '<<x0<<' '<<y1<<' '<<x1<<endl;\n    for(int i=0;i<H-1;i++){\n      for(int j=0;j<W-1;j++){\n        if(i==y0&&j==x0)cout<<'a';\n        else if(i==y1&&j==x1)cout<<'b';\n        else if(i==y2&&j==x2)cout<<'c';\n        else if('a'<=t[i][j]&&t[i][j]<='c')cout<<' ';\n        else if('A'<=t[i][j]&&t[i][j]<='C')cout<<' ';\n        else cout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    bool flg=true;\n\n    if(s.y0!=ty[0])flg=false;\n    if(s.x0!=tx[0])flg=false;\n    if(s.y1!=ty[1]&&N>=2)flg=false;\n    if(s.x1!=tx[1]&&N>=2)flg=false;\n    if(s.y2!=ty[2]&&N>=3)flg=false;\n    if(s.x2!=tx[2]&&N>=3)flg=false;\n    if(flg)return cost;\n    \n    \n    for(int i=0;i<5;i++){\n      if(N==1&&i==0)continue;\n      int ny0=s.y0+dy[i];\n      int nx0=s.x0+dx[i];\n      if(ny0 < 0 || nx0 < 0 || ny0 >=H-2 || nx0 >=W-2 )continue;\n      if(t[ny0][nx0]=='#')continue;\n      \n      for(int j=0;j<5;j++){\n        if(N==1&&j>0)continue;\n        int ny1=s.y1+dy[j];\n        int nx1=s.x1+dx[j];\n        if(ny1 < 0 || nx1 < 0 || ny1 >=H-2 || nx1 >=W-2 )continue;\n        if(t[ny1][nx1]=='#')continue;\n        \n        for(int k=0;k<5;k++){\n          if(N<=2&&k>0)continue;\n          int ny2=s.y2+dy[k];\n          int nx2=s.x2+dx[k];\n          if(ny2 < 0 || nx2 < 0 || ny2 >=H-2 || nx2 >=W-2 )continue;\n          if(t[ny2][nx2]=='#')continue;\n          \n          if( ny0 == ny1 && nx0 == nx1 &&N>=2)   continue; \n          if( ny1 == ny2 && nx1 == nx2 &&N==3)   continue;\n          if( ny2 == ny0 && nx2 == nx0 &&N==3)   continue;\n          \n\n          if( ny0 == s.y1 && nx0 == s.x1 &&\n              ny1 == s.y0 && nx1 == s.x0 &&N>=2)continue;\n          \n\n          if( ny1 == s.y2 && nx1 == s.x2 &&\n              ny2 == s.y1 && nx2 == s.x1 &&N==3)continue;\n\n          if( ny2 == s.y0 && nx2 == s.x0 &&\n              ny0 == s.y2 && nx0 == s.x2 &&N==3)continue;\n          /*\n          if(ny0==1 && nx0==1 && ny1==1 && nx1==2){\n            cout<<y0<<' '<<x0<<' '<<y1<<' '<<x1<<' '<<'!'<<endl;\n          }\n          */\n          if( d[ny0][nx0][ny1][nx1][ny2][nx2]>cost+1){\n            d[ny0][nx0][ny1][nx1][ny2][nx2]=cost+1;\n            Q.push( (state){ny0,nx0,ny1,nx1,ny2,nx2} );\n          }\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>W>>H>>N;\n    if(H==0&&W==0&&N==0)break;\n    cin.ignore();\n\n    for(int i=0;i<3;i++)\n      sy[i]=sx[i]=ty[i]=tx[i]=0;\n    \n    for(int i=0;i<H;i++){\n      getline(cin,str);\n      for(int j=0;j<W;j++){\n        if(i>0&&j>0){\n          t[i-1][j-1]=str[j];\n          if('a'<=str[j]&&str[j]<='c'){\n            sy[ str[j]-'a' ]=i-1;\n            sx[ str[j]-'a' ]=j-1;\n          }\n          if('A'<=str[j]&&str[j]<='C'){\n            ty[ str[j]-'A' ]=i-1;\n            tx[ str[j]-'A' ]=j-1;\n          }\n        }\n      }\n    }\n\n\n        \n    cout<<solve()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<bitset>\n#include<queue>\nchar m[32][32];\nint dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\nstd::bitset<1<<24 >f;\ntemplate<int N>\nstruct S\n{\nvoid I2P(int a,int*x,int*y)\n{\n\tfor(int i=0;i<N;++i)\n\t{\n\t\ty[N-i-1]=a&15;\n\t\tx[N-i-1]=(a>>4)&15;\n\t\ta>>=8;\n\t}\n}\nint P2I(int*x,int*y)\n{\n\tint res=0,i;\n\tfor(i=0;i<N;++i)\n\t\tres=(res<<8)|(x[i]<<4)+y[i];\n\treturn res;\n}\nint EQ(int*x,int*y,int*gx,int*gy)\n{\n\tfor(int i=0;i<N;++i)\n\t\tif(x[i]-gx[i]||y[i]-gy[i])\n\t\t\treturn 0;\n\treturn 1;\n}\nvoid G(std::queue<int>&q, int*x,int*y,int*nx,int*ny,int i)\n{\n\tint j,k;\n\tif(i==N)\n\t{\n\t\tint a=P2I(nx,ny);\n\t\tif(f[a])return;\n\t\tfor(j=0;j<N;++j)\n\t\t\tfor(k=j+1;k<N;++k)\n\t\t\t\tif(x[j]==nx[k]&&y[j]==ny[k]&&\n\t\t\t\t   x[k]==nx[j]&&y[k]==ny[j])\n\t\t\t\t\treturn;\n\t\tq.push(a);\n\t}\n\telse\n\t\tfor(k=0;k<5;++k)\n\t\t{\n\t\t\tnx[i]=x[i]+dx[k];\n\t\t\tny[i]=y[i]+dy[k];\n\t\t\tif(m[ny[i]][nx[i]]=='#')\n\t\t\t\tcontinue;\n\t\t\tfor(j=0;j<i;++j)\n\t\t\t\tif(nx[i]==nx[j]&&ny[i]==ny[j])\n\t\t\t\t\tgoto END;\n\t\t\tG(q,x,y,nx,ny,i+1);\n\t\t\tEND:;\n\t\t}\n}\nint F(int (&x)[3],int (&y)[3],int (&gx)[3],int(&gy)[3])\n{\n\tf.reset();\n\tstd::queue<int>q;\n\tq.push(P2I(x,y));\n\tq.push(-1);\n\tint a,res=0;\n\tint nx[3],ny[3];\n\tfor(;;)\n\t{\n\t\ta=q.front();\n\t\tq.pop();\n\t\tif(a<0)\n\t\t{\n\t\t\t++res;\n\t\t\tq.push(a);\n\t\t\tcontinue;\n\t\t}\n\t\tif(f[a])continue;\n\t\tf[a]=true;\n\t\tI2P(a,x,y);\n\t\tif(EQ(x,y,gx,gy))return res;\n\t\tG(q,x,y,nx,ny,0);\n\t}\n}\n};\nint main()\n{\n\tint h,w,n,i,x[3],y[3],gx[3],gy[3];\n\tchar*p;\n\twhile(scanf(\"%d%d%d\",&w,&h,&n),n)\n\t{\n\t\tfgets(m[0],32,stdin);\n\t\tfor(i=0;i<h;++i)\n\t\t{\n\t\t\tfgets(m[i],32,stdin);\n\t\t\tfor(p=m[i];p=strpbrk(p,\"abc\");++p)\n\t\t\t{\n\t\t\t\ty[*p-'a']=i;\n\t\t\t\tx[*p-'a']=p-m[i];\n\t\t\t}\n\t\t\tfor(p=m[i];p=strpbrk(p,\"ABC\");++p)\n\t\t\t{\n\t\t\t\tgy[*p-'A']=i;\n\t\t\t\tgx[*p-'A']=p-m[i];\n\t\t\t}\n\t\t}\n\t\tint r = (n==3?S<3>().F(x,y,gx,gy):\n\t\t\t\tn==2?S<2>().F(x,y,gx,gy):\n\t\t\t\tS<1>().F(x,y,gx,gy));\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 16 * 16 + 2;\nconst int IINF = INT_MAX;\n\nstruct Data {\n  int p[3],cost;\n  \n  bool operator < ( const Data &data ) const {\n    return cost > data.cost;\n  }\n};\n\nint dx[] = {0,1,0,-1,0};\nint dy[] = {1,0,-1,0,0};\nint w,h,n,gn,sn;\nchar c[20][20];\nint mindist[MAX][MAX][MAX];\nint gs[3],sp[3];\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nbool isValidMove(Data cur,Data next){\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == next.p[j] ) return false;\n  rep(i,sn) REP(j,i+1,sn) if( next.p[i] == cur.p[j] && next.p[j] == cur.p[i] ) return false;\n  return true;\n}\n\nvoid printState(Data cur){\n  rep(i,h){\n    rep(j,w){\n      bool f = false;\n      rep(k,sn) if( cur.p[k] == j + i*w ) {\n\tcout << (char)('a'+k);\n\tf = true;\n\tbreak;\n      }\n      if( f ) continue;\n      cout << c[i][j];\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nvoid dfs(priority_queue<Data> &Q,int cur,Data state,int mask,Data prev){\n  if( cur >= sn ) {\n\n    if( isValidMove(prev,state) ) {\n\n      int A=MAX-1,B=MAX-1,C=MAX-1;\n      if( sn >= 1 ) A = state.p[0];\n      if( sn >= 2 ) B = state.p[1];\n      if( sn >= 3 ) C = state.p[2];\n      if( mindist[A][B][C] > state.cost ) {\n\tmindist[A][B][C] = state.cost;\n\tQ.push(state);\n      }\n\n    }\n    return;\n  }\n  if( !( ( mask >> cur ) & 1 ) ) {\n    dfs(Q,cur+1,state,mask,prev);\n    return;\n  }\n  int x = state.p[cur] % w, y = state.p[cur] / w;\n  rep(i,5){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( c[ny][nx] == '#' ) continue;\n    state.p[cur] = nx + ny * w;\n    dfs(Q,cur+1,state,mask,prev);\n  }\n  state.p[cur] = x + y * w;\n}\n\nvoid pushNextState(priority_queue<Data> &Q,int mask,int cost,Data cdata){\n  Data state = cdata;\n  ++state.cost;\n  dfs(Q,0,state,mask,cdata);\n}\n\n\n\nvoid compute(){\n  rep(i,MAX)rep(j,MAX)rep(k,MAX) mindist[i][j][k] = IINF;\n  gn = 0;\n  rep(i,h) rep(j,w) if( 'A' <= c[i][j] && c[i][j] <= 'C' ) {\n    gs[c[i][j]-'A'] = j + i * w;\n    c[i][j] = '.';\n    ++gn;\n  }\n\n  sn = 0;\n  rep(i,h) rep(j,w) if( 'a' <= c[i][j] && c[i][j] <= 'c' ) {\n    sp[c[i][j]-'a'] = j + i * w;\n    c[i][j] = '.';\n    ++sn;\n  }\n  priority_queue<Data> Q;\n  {\n    Data data;\n    data.cost = 0;\n    rep(i,sn) data.p[i] = sp[i];\n    Q.push(data);\n  }\n  bool found = false;\n  while( !Q.empty() ){\n    Data data = Q.top(); Q.pop();\n\n    bool fin = true;\n    rep(i,gn) if( gs[i] != data.p[i] ) {\n      fin = false;\n      break;\n    }\n    if( fin ) {\n      found = true;\n\n      printf(\"%d\\n\",data.cost);\n      return;\n    }\n    rep(mask,(1<<sn)){\n      pushNextState(Q,mask,data.cost,data);\n    }\n    \n  }\n  assert(found);\n}\n\nint main(){\n  while( cin >> w >> h >> n, w|h|n ){\n    cin.ignore();\n    rep(i,h) {\n      string s;\n      getline(cin,s);\n      rep(j,w) {\n\tif( s[j] == ' ' ) s[j] = '.';\n\tc[i][j] = s[j];\n      }\n    }\n\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w,h,n;\nstring b[16];\nint sx[3],sy[3],gx[3],gy[3];\nint v[1<<24];\n\nint dx[5] = {0,1,0,-1,0}, dy[5] = {0,0,1,0,-1};\n\nstruct S{\n\tint x[3], y[3];\n};\n\nint conv(S s){\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s){\n\tfor(int i = 0; i < n; i++){\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y){\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps){\n\tfor(int i = 0; i < n; i++){\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s){\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++){\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tcout << temp[i] <<endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S ps, vector<S>& res){\n\tif(i == n){\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++){\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i+1, ns, ps, res);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h >> n, w | h | n){\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++){\t\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\t\t\n\t\tmemset(v, -1, sizeof v);\n\t\t\n\t\tqueue<S> q;\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()){\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\t\t\t\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)){\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0,s,s,NS);\n\t\t\tfor(S ns : NS){\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint W, H, N;\nbool field[16][16];\nbool reach[1 << 24];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nstruct State{\n\tarray<P, 3> cord;\n\tint cnt;\n\tState() : cnt(0) {\n\t\tcord.fill(P(0, 0));\n\t}\t\n\tint hash(){\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 3; i++) ret = (ret << 8) | (cord[i].first << 4) | cord[i].second;\n\t\treturn ret;\n\t}\n};\n\nostream& operator<<(ostream& os, const State& dt)  {  \n\tos << \"[\";\n\tfor(int i = 0; i < N; i++){\n\t\tos << \"(\" << dt.cord[i].first << \",\" << dt.cord[i].second << \")\";\n\t}\n\tos << dt.cnt << \"]\";\n\treturn os;  \n}  \n\nvoid dfs(queue<State> &que, State &prev, int idx, State n){\n\tif(idx == N){\n\t\tif(\n\t\t\t\tN >= 2 && prev.cord[0] == n.cord[1] && prev.cord[1] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[0] == n.cord[2] && prev.cord[2] == n.cord[0] ||\n\t\t\t\tN >= 3 && prev.cord[1] == n.cord[2] && prev.cord[2] == n.cord[1] ||\n\t\t\t\tN >= 2 && n.cord[0] == n.cord[1]  ||\n\t\t\t\tN >= 3 && n.cord[0] == n.cord[2]  ||\n\t\t\t\tN >= 3 && n.cord[1] == n.cord[2]  \n\t\t  ) return;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!field[n.cord[i].second][n.cord[i].first]) return;\n\t\t}\n\t\tn.cnt++;\n\t\tque.push(n);\n\n\t}else{\n\t\tdfs(que, prev, idx + 1, n);\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tn.cord[idx] = P(prev.cord[idx].first + dx[i], prev.cord[idx].second + dy[i]);\n\t\t\tdfs(que, prev, idx + 1, n);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H >> N, W){\n\t\tState begin, end;\n\t\tstring str;\n\t\tgetline(cin, str);\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tgetline(cin, str);\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tchar c = str[j];\n\t\t\t\tif(c == '#') field[i][j] = false;\n\t\t\t\telse{\n\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t\tif('A' <= c && c <= 'C') end.cord[c - 'A'] = P(j, i);\n\t\t\t\t\telse begin.cord[c - 'a'] = P(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < (1 << 24); i++) reach[i] = false;\n\t\tqueue<State> que;\n\t\tque.push(begin);\n\t\tint ans = -1;\n\t\twhile(que.size()){\n\t\t\tState s = que.front(); que.pop();\n\t\t\tif(s.cord == end.cord){\n\t\t\t\tans = s.cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(reach[s.hash()]) continue;\n\t\t\treach[s.hash()] = true;\n\t\t\tdfs(que, s, 0, s);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int short int\nusing namespace std;\n\nstruct P{\n  int ay,ax,by,bx,cy,cx,cost;\n  P(int a1,int a2,int b1,int b2,int c1,int c2,int c){\n    ax=a1;ay=a2;\n    bx=b1;by=b2;\n    cx=c1;cy=c2;\n    cost=c;\n  }\n};\n\nint h,w,n,gx[3],gy[3],sx[3],sy[3];\nstring s[14],iranai;\nbool used[14][14][14][14][14][14];\nint dx[]={1,0,-1,0,0};\nint dy[]={0,1,0,-1,0};\n\nint BFS(){\n  memset(used,0,sizeof(used));\n  queue<P>q;\n  q.push(P(sx[0],sy[0],sx[1],sy[1],sx[2],sy[2],0));\n  used[sy[0]][sx[0]][sy[1]][sx[1]][sy[2]][sx[2]]=1;\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    int ay=p.ay;\n    int ax=p.ax;\n    int by=p.by;\n    int bx=p.bx;\n    int cy=p.cy;\n    int cx=p.cx;\n    int cost=p.cost;\n    if(ay==gy[0]&&ax==gx[0]&&by==gy[1]&&bx==gx[1]&&cy==gy[2]&&cx==gx[2])return cost;\n    for(int i=0;i<5;i++){\n      int Ay=ay+dy[i];\n      int Ax=ax+dx[i];\n      if(Ay<0||Ax<0||Ay>=h||Ax>=w)continue;\n      if(s[Ay][Ax]=='#')continue;\n      if(n>=2){\n\n        for(int j=0;j<5;j++){\n          int By=by+dy[j];\n          int Bx=bx+dx[j];\n          if(By<0||Bx<0||By>=h||Bx>=w)continue;\n          if(s[By][Bx]=='#')continue;\n          if(n>=3){\n\n            for(int j=0;j<5;j++){\n              int Cy=cy+dy[j];\n              int Cx=cx+dx[j];\n              if(Cy<0||Cx<0||Cy>=h||Cx>=w)continue;\n              if(s[Cy][Cx]=='#')continue;\n              if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n              if(Cx==bx&&Cy==by&&Bx==cx&&By==cy)continue;\n              if(Ax==cx&&Ay==cy&&Cx==ax&&Cy==ay)continue;\n              if(Ax==Bx&&Ay==By)continue;\n              if(Ax==Cx&&Ay==Cy)continue;\n              if(Cx==Bx&&Cy==By)continue;\n              if(!used[Ay][Ax][By][Bx][Cy][Cx]){\n                used[Ay][Ax][By][Bx][Cy][Cx]=1;\n                q.push(P(Ax,Ay,Bx,By,Cx,Cy,cost+1));\n              }\n            }\n\n          }\n          else{\n            if(Ax==bx&&Ay==by&&Bx==ax&&By==ay)continue;\n            if(Ax==Bx&&Ay==By)continue;\n            if(!used[Ay][Ax][By][Bx][cy][cx]){\n              used[Ay][Ax][By][Bx][cy][cx]=1;\n              q.push(P(Ax,Ay,Bx,By,cx,cy,cost+1));\n            }\n          }\n        }\n\n      }\n      else{\n        if(!used[Ay][Ax][by][bx][cy][cx]){\n          used[Ay][Ax][by][bx][cy][cx]=1;\n          q.push(P(Ax,Ay,bx,by,cx,cy,cost+1));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  while(cin>>w>>h>>n,n){\n    memset(sy,0,sizeof(sy));\n    memset(sx,0,sizeof(sx));\n    memset(gx,0,sizeof(gx));\n    memset(gy,0,sizeof(gy));\n    getline(cin,s[0]);\n    getline(cin,s[0]);\n    r(i,h-2)getline(cin,s[i]);\n    getline(cin,iranai);\n    h-=2;w-=2;\n    r(i,h)s[i].erase(s[i].begin(),s[i].begin()+1);\n    r(i,h)s[i].erase(s[i].begin()+w);\n    r(i,h)r(j,w){\n      if(s[i][j]=='a')sy[0]=i,sx[0]=j;\n      if(s[i][j]=='b')sy[1]=i,sx[1]=j;\n      if(s[i][j]=='c')sy[2]=i,sx[2]=j;\n      if(s[i][j]=='A')gy[0]=i,gx[0]=j;\n      if(s[i][j]=='B')gy[1]=i,gx[1]=j;\n      if(s[i][j]=='C')gy[2]=i,gx[2]=j;\n    }\n    cout<<BFS()<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nint v[1 << 24];\nint dist[16][16][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tchar x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[s.y[i]][s.x[i]][gy[i]][gx[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\tq.push(make_pair(j, i));\n\t\t\t\tdist[i][j][i][j] = 0;\n\t\t\t\twhile(q.size()) {\n\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\tif(dist[i][j][ny][nx] != -1) continue;\n\t\t\t\t\t\tdist[i][j][ny][nx] = dist[i][j][y][x] + 1;\n\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\nint w, h, n;\nstring b[16];\nint sx[3], sy[3], gx[3], gy[3];\nshort v[1 << 24];\nshort dist[16][16][16][16];\n\nint dx[5] = { 0, 1, 0, -1, 0 }, dy[5] = { 0, 0, 1, 0, -1 };\n\nstruct S {\n\tint x[3], y[3];\n\tfloat h;\n\tbool operator < (const S& s) const { return h > s.h; }\n};\n\nfloat calcH(S& s) {\n\tfloat ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = max(ret, (float)dist[s.y[i]][s.x[i]][gy[i]][gx[i]]);\n\t}\n\treturn 1.3 * ret;\n}\n\n\nint conv(S s) {\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.x[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tret = ret * 16 + s.y[i];\n\t}\n\treturn ret;\n}\n\nbool check(S s) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s.x[i] != gx[i] || s.y[i] != gy[i]) return false;\n\t}\n\treturn true;\n}\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool valid(S s, S ps) {\n\tfor(int i = 0; i < n; i++) {\n\t\tif(!in(s.x[i], s.y[i])) return false;\n\t\tif(b[s.y[i]][s.x[i]] == '#') return false;\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tif(s.x[i] == s.x[j] && s.y[i] == s.y[j]) return false;\n\t\t\tif(ps.x[j] == s.x[i] && ps.y[j] == s.y[i] &&\n\t\t\t\tps.x[i] == s.x[j] && ps.y[i] == s.y[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid view(S s) {\n\tstring temp[16];\n\tfor(int i = 0; i < h; i++) {\n\t\ttemp[i] = b[i];\n\t}\n\tfor(int i = 0; i < n; i++) {\n\t\ttemp[s.y[i]][s.x[i]] = 'a' + i;\n\t}\n\tfor(int i = 0; i < h; i++) {\n\t\tcout << temp[i] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid makeNS(int i, S s, S ps, vector<S>& res) {\n\tif(i == n) {\n\t\tif(valid(s, ps)) res.push_back(s);\n\t\treturn;\n\t}\n\tfor(int k = 0; k < 5; k++) {\n\t\tS ns = s;\n\t\tns.x[i] += dx[k];\n\t\tns.y[i] += dy[k];\n\t\tmakeNS(i + 1, ns, ps, res);\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h >> n, w | h | n) {\n\t\tcin.ignore();\n\t\tS s;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tgetline(cin, b[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == 'a') s.x[0] = j, s.y[0] = i;\n\t\t\t\tif(b[i][j] == 'b') s.x[1] = j, s.y[1] = i;\n\t\t\t\tif(b[i][j] == 'c') s.x[2] = j, s.y[2] = i;\n\t\t\t\tif(b[i][j] == 'A') gx[0] = j, gy[0] = i;\n\t\t\t\tif(b[i][j] == 'B') gx[1] = j, gy[1] = i;\n\t\t\t\tif(b[i][j] == 'C') gx[2] = j, gy[2] = i;\n\t\t\t\tif(b[i][j] == 'a' || b[i][j] == 'b' || b[i][j] == 'c') b[i][j] = ' ';\n\t\t\t}\n\t\t\t//cout << b[i] << endl;\n\t\t}\n\n\t\tmemset(dist, -1, sizeof dist);\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(b[i][j] == '#') continue;\n\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\tq.push(make_pair(j, i));\n\t\t\t\tdist[i][j][i][j] = 0;\n\t\t\t\twhile(q.size()) {\n\t\t\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int k = 1; k < 5; k++) {\n\t\t\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\t\t\tif(b[ny][nx] == '#') continue;\n\t\t\t\t\t\tif(dist[i][j][ny][nx] != -1) continue;\n\t\t\t\t\t\tdist[i][j][ny][nx] = dist[i][j][y][x] + 1;\n\t\t\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(v, -1, sizeof v);\n\n\t\tpriority_queue<S> q;\n\t\ts.h = calcH(s);\n\t\tq.push(s);\n\t\tv[conv(s)] = 0;\n\t\tint ans = -1;\n\t\twhile(q.size()) {\n\t\t\ts = q.top();\n\t\t\tq.pop();\n\t\t\tint d = v[conv(s)];\n\n\t\t\t//cout << conv(s)  << \" \" << d << endl;\n\t\t\t//view(s);\n\t\t\tif(check(s)) {\n\t\t\t\tans = d;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvector<S> NS;\n\t\t\tmakeNS(0, s, s, NS);\n\t\t\tfor(S ns : NS) {\n\t\t\t\tint X = conv(ns);\n\t\t\t\tif(v[X] != -1) continue;\n\t\t\t\tv[X] = d + 1;\n\t\t\t\tns.h = calcH(ns) + d + 1;\n\t\t\t\tq.push(ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint h, w, n;\nvector<string> grid;\n\nclass Data\n{\npublic:\n    vector<int> y, x;\n    bitset<3> bs;\n    Data(vector<int>& y0, vector<int>& x0, bitset<3> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n    int toInt(){\n        int ret = bs.to_ulong();\n        for(int i=0; i<n; ++i){\n            ret *= h;\n            ret += y[i];\n            ret *= w;\n            ret += x[i];\n        }\n        return ret;\n    }\n};\n\nint solve()\n{\n    vector<int> sy(n), sx(n), gy(n), gx(n);\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            int c = grid[i][j];\n            if('a' <= c && c <= 'c'){\n                sy[c-'a'] = i;\n                sx[c-'a'] = j;\n            }else if('A' <= c && c <= 'C'){\n                gy[c-'A'] = i;\n                gx[c-'A'] = j;\n            }\n        }\n    }\n\n    int size = 1 << n;\n    for(int i=0; i<n; ++i)\n        size *= h * w;\n\n    vector<vector<bool> > check(2, vector<bool>(size, false));\n    check[0][Data(sy, sx, 0).toInt()] = true;\n    check[1][Data(gy, gx, 0).toInt()] = true;\n    vector<deque<Data> > dq(2);\n    dq[0].push_back(Data(sy, sx, 0));\n    dq[1].push_back(Data(gy, gx, 0));\n\n    int turn = 0;\n    int m = 1;\n    int ret = 1;\n    for(;;){\n        if(m == 0){\n            ++ ret;\n            turn ^= 1;\n            m = dq[turn].size();\n        }\n\n        Data d = dq[turn].front();\n        dq[turn].pop_front();\n        -- m;\n\n        for(int i=0; i<n; ++i){\n            if(d.bs[i])\n                continue;\n            d.bs[i] = true;\n            for(int j=0; j<4; ++j){\n                d.y[i] += dy[j];\n                d.x[i] += dx[j];\n\n                bool ok = true;\n                if(grid[d.y[i]][d.x[i]] == '#')\n                    ok = false;\n                for(int k=0; k<n; ++k){\n                    if(k != i && d.y[k] == d.y[i] && d.x[k] == d.x[i])\n                        ok = false;\n                }\n\n                if(ok){\n                    Data d2 = d;\n                    d2.bs = 0;\n                    if(check[turn^1][d2.toInt()])\n                        return ret;\n\n                    int a = d.toInt();\n                    if(!check[turn][a]){\n                        dq[turn].push_front(d);\n                        ++ m;\n                        check[turn][a] = true;\n                    }\n                }\n\n                d.y[i] -= dy[j];\n                d.x[i] -= dx[j];\n            }\n            d.bs[i] = false;\n        }\n\n        d.bs = 0;\n        int a = d.toInt();\n        if(!check[turn][a]){\n            dq[turn].push_back(d);\n            check[turn][a] = true;\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h >> n;\n        if(w == 0)\n            return 0;\n        cin.ignore();\n\n        grid.resize(h);\n        for(int i=0; i<h; ++i)\n            getline(cin, grid[i]);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cctype>\n\nusing namespace std;\n\nstruct S{\n  int p[3][2];\n  int t;\n};\n\nint main(){\n  for(int w,h,n;cin>>w>>h>>n,w;){\n    cin.ignore();\n    char g[16][16];\n    S is={{},0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin.get(g[i][j]);\n\tif(islower(g[i][j])){\n\t  auto x=g[i][j]-'a';\n\t  is.p[x][0]=i;\n\t  is.p[x][1]=j;\n\t}\n      }\n      cin.ignore();\n    }\n    queue<S> que;\n    que.push(is);\n    set<int> p;\n    for(;;){\n      S cs=que.front();\n      bool f=false;\n      for(int i=0;i<n;i++){\n\tf|=g[cs.p[i][0]][cs.p[i][1]]!='A'+i;\n      }\n      if(!f)break;\n      que.pop();\n      int b=0;\n      for(int i=0;i<n;i++){\n\tb=b<<8|cs.p[i][0]<<4|cs.p[i][1];\n      }\n      if(!p.insert(b).second)continue;\n      static int dy[]={-1,0,0,0,1};\n      static int dx[]={0,-1,0,1,0};\n      for(int i=0;i<5;i++){\n\tint y1,x1,y2,x2,y3,x3;\n\ty1=cs.p[0][0]+dy[i];\n\tx1=cs.p[0][1]+dx[i];\n\ty2=cs.p[1][0];\n\tx2=cs.p[1][1];\n\ty3=cs.p[2][0];\n\tx3=cs.p[2][1];\n\tif(g[y1][x1]=='#')continue;\n\tif(n==1){\n\t  que.push({{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t}else{\n\t  for(int j=0;j<5;j++){\n\t    y2=cs.p[1][0]+dy[j];\n\t    x2=cs.p[1][1]+dx[j];\n\t    if(g[y2][x2]=='#'||y2==y1&&x2==x1||y1==cs.p[1][0]&&x1==cs.p[1][1]&&y2==cs.p[0][0]&&x2==cs.p[0][1])continue;\n\t    if(n==2){\n\t      que.push({{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t    }else{\n\t      for(int k=0;k<5;k++){\n\t\ty3=cs.p[2][0]+dy[k];\n\t\tx3=cs.p[2][1]+dx[k];\n\t\tif(g[y3][x3]=='#'||y3==y1&&x3==x1||y3==y2&&x3==x2||y3==cs.p[0][0]&&x3==cs.p[0][1]&&y1==cs.p[2][0]&&x1==cs.p[2][1]||y3==cs.p[1][0]&&x3==cs.p[1][1]&&y2==cs.p[2][0]&&x2==cs.p[2][1])continue;\n\t\tque.push({{y1,x1,y2,x2,y3,x3},cs.t+1});\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.front().t<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nunsigned short vis[1 << 24];\nchar c[16][20];\nbool wall[256];\nint tm0;\n\ninline bool check(int u, int v){\n\tfor(int i = 0; i < 24; i += 8){\n\t\tint p1 = v >> i & 255;\n\t\tif(p1){\n\t\t\tint j = i == 16 ? 0 : i + 8;\n\t\t\tif(wall[p1]){ return false; }\n\t\t\tint p2 = (v >> j % 24) & 255;\n\t\t\tif(p1 == p2){ return false; }\n\t\t\tif(\n\t\t\t\tp1 == (u >> j % 24 & 255) &&\n\t\t\t\tp2 == (u >> i % 24 & 255)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint solve(int start, int goal){\n\tconst int dif[5] = {0, -1, 1, -16, 16};\n\n\tqueue<int> q;\n\tq.push(start);\n\tq.push(-1);\n\tint tm = tm0 + 1;\n\tvis[start] = tm;\n\twhile(1){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tif(u < 0){\n\t\t\tq.push(-1);\n\t\t\t++tm;\n\t\t}\n\t\telse{\n\t\t\tfor(int i1 = u & 255 ? 4 : 0; i1 >= 0; --i1)\n\t\t\tfor(int i2 = u >> 8 & 255 ? 4 : 0; i2 >= 0; --i2)\n\t\t\tfor(int i3 = u >> 16 ? 4 : 0; i3 >= 0; --i3){\n\t\t\t\tint v = u + dif[i1] + (dif[i2] << 8) + (dif[i3] << 16);\n\t\t\t\tif(vis[v] > tm0){ continue; }\n\t\t\t\tif(check(u, v)){\n\t\t\t\t\tif(v == goal){ return tm; }\n\t\t\t\t\tvis[v] = tm;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d%*d \", &w, &h), w){\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfgets(c[i], 20, stdin);\n\t\t}\n\n\t\tint goal = 0;\n\t\tint start = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(c[i][j] == '#'){\n\t\t\t\t\twall[i << 4 | j] = true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twall[i << 4 | j] = false;\n\t\t\t\t\tif(isupper(c[i][j])){\n\t\t\t\t\t\tgoal |= (i << 4 | j) << (c[i][j] - 'A') * 8;\n\t\t\t\t\t}\n\t\t\t\t\telse if(islower(c[i][j])){\n\t\t\t\t\t\tstart |= (i << 4 | j) << (c[i][j] - 'a') * 8;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint tm = solve(start, goal);\n\t\tprintf(\"%d\\n\", tm - tm0);\n\n\t\ttm0 = tm + 1;\n\t\tif(tm0 > 55000){\n\t\t\tmemset(vis, 0, sizeof vis);\n\t\t\ttm0 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n    int dist;\n};\nbool operator < (state_t const & a, state_t const & b) {\n    return 3 * a.cost + a.dist > 3 * b.cost + b.dist;\n}\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 19) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            // c\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                // b\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        vector<vector<int> > dist[3]; // from goal\n        repeat (i,3) {\n            dist[i].resize(h, vector<int>(w, 1000000007));\n            // bfs\n            vector<point_t> cur, nxt;\n            nxt.push_back(goal[i]);\n            dist[i][goal[i].y][goal[i].x] = 0;\n            int l = 1;\n            while (not nxt.empty()) {\n                cur.clear();\n                cur.swap(nxt);\n                for (auto p : cur) {\n                    repeat (j,4) {\n                        auto q = p + dp[j];\n                        if (c[q.y][q.x] == '#') continue;\n                        if (l < dist[i][q.y][q.x]) {\n                            dist[i][q.y][q.x] = l;\n                            nxt.push_back(q);\n                        }\n                    }\n                }\n                ++ l;\n            }\n        }\n\n        map<point_t,int> ix;\n        repeat (y,h) repeat (x,w) {\n            if (c[y][x] != '#') {\n                int i = ix.size();\n                ix[(point_t){ y, x }] = i;\n            }\n        }\n        vector<vector<vector<bool> > > used(ix.size(), vector<vector<bool> >(ix.size(), vector<bool>(ix.size())));\n\n        priority_queue<state_t> que; {\n            state_t initial = { start, 0, 0 };\n            repeat (i,3) initial.dist += dist[i][start[i].y][start[i].x];\n            used[ix[start[0]]][ix[start[1]]][ix[start[2]]] = true;\n            que.push(initial);\n        }\n        while (not que.empty()) {\n            state_t st = que.top(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        if (used[ix[t[0]]][ix[t[1]]][ix[t[2]]]) continue;\n                        used[ix[t[0]]][ix[t[1]]][ix[t[2]]] = true;\n                        tt.dist = 0;\n                        repeat (i,3) tt.dist = max(tt.dist, dist[i][t[i].y][t[i].x]);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <cctype>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat_reverse(i,n) for (int i = (n)-1; (i) >= 0; --(i))\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\ntypedef long long ll;\nusing namespace std;\n\nstruct point_t {\n    int y, x;\n};\npoint_t operator + (point_t const & a, point_t const & b) {\n    return (point_t){ a.y + b.y, a.x + b.x };\n}\nbool operator == (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) == make_pair(b.y, b.x);\n}\nbool operator < (point_t const & a, point_t const & b) {\n    return make_pair(a.y, a.x) < make_pair(b.y, b.x);\n}\nstatic point_t dp[5] = { {-1,0}, {1,0}, {0,1}, {0,-1}, {0,0} };\n\nstruct state_t {\n    array<point_t,3> a;\n    int cost;\n};\nuint32_t encode(array<point_t,3> const & s) {\n    uint32_t q = 0;\n    for (point_t p : s) {\n        q = (q * 18) + p.y;\n        q = (q * 16) + p.x;\n    }\n    return q;\n}\nbool is_valid_move(int i, int j, array<point_t,3> const & s, array<point_t,3> const & t) {\n    if (t[i] == t[j]) return false;\n    if (t[i] == s[j] and t[j] == s[i]) return false;\n    return true;\n}\n\nint main() {\n    while (true) {\n        int w, h, n; cin >> w >> h >> n; cin.ignore();\n        if (w == 0 and h == 0 and n == 0) break;\n        vector<string> c(h);\n        repeat (i,h) getline(cin, c[i]);\n\n        assert (1 <= n and n <= 3);\n        array<point_t,3> start, goal;\n        repeat (y,h) repeat (x,w) {\n            if (islower(c[y][x])) {\n                start[c[y][x] - 'a'] = { y, x };\n            } else if (isupper(c[y][x])) {\n                goal[c[y][x] - 'A'] = { y, x };\n            }\n        }\n        if (n == 1 or n == 2) {\n            assert (4 <= w);\n            string w = c.back();\n            c.push_back(w);\n            c.back()[2] = '.';\n            start[2] = goal[2] = (point_t){ h, 2 };\n            if (n == 1) {\n                c.back()[1] = '.';\n                start[1] = goal[1] = (point_t){ h, 1 };\n            }\n            c.push_back(w);\n            h += 2;\n        }\n\n        unordered_set<uint32_t> used[3];\n        queue<state_t> que; {\n            state_t initial = { start, 0 };\n            used[0].insert(encode(start));\n            que.push(initial);\n        }\n        int cost = 0;\n//int cnt = 0;\n        while (not que.empty()) {\n//cnt++;\n            state_t st = que.front(); que.pop();\n            array<point_t,3> & s = st.a;\n            if (s == goal) {\n                cout << st.cost << endl;\n                break;\n            }\n            if (st.cost != cost) {\n                assert (st.cost == cost + 1);\n                cost = st.cost;\n                used[2].clear();\n                used[2].swap(used[1]);\n                used[1].swap(used[0]);\n            }\n            state_t tt = st;\n            tt.cost += 1;\n            array<point_t,3> & t = tt.a;\n            repeat (i,5) { // a\n                t[0] = s[0] + dp[i];\n                if (c[t[0].y][t[0].x] == '#') continue;\n                repeat (j,5) { // b\n                    t[1] = s[1] + dp[j];\n                    if (c[t[1].y][t[1].x] == '#') continue;\n                    if (not is_valid_move(0, 1, s, t)) continue;\n                    repeat (k,5) { // c\n                        t[2] = s[2] + dp[k];\n                        if (c[t[2].y][t[2].x] == '#') continue;\n                        if (not is_valid_move(1, 2, s, t)) continue;\n                        if (not is_valid_move(2, 0, s, t)) continue;\n                        uint32_t key = encode(t);\n                        if (used[0].count(key)) continue;\n                        if (used[1].count(key)) continue;\n                        if (used[2].count(key)) continue;\n                        used[0].insert(key);\n                        que.push(tt);\n                    }\n                }\n            }\n        }\n//cerr << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cctype>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int p[3][2];\n  int t;\n};\n\nint main(){\n  for(int w,h,n;cin>>w>>h>>n,w;){\n    cin.ignore();\n    char g[16][16];\n    S is={{},0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin.get(g[i][j]);\n\tif(islower(g[i][j])){\n\t  auto x=g[i][j]-'a';\n\t  is.p[x][0]=i;\n\t  is.p[x][1]=j;\n\t}\n      }\n      cin.ignore();\n    }\n    queue<S> que;\n    que.push(is);\n    static bool p[1<<24];\n    fill(begin(p),end(p),false);\n    for(;;){\n      S cs=que.front();\n      bool f=false;\n      for(int i=0;i<n;i++){\n\tf|=g[cs.p[i][0]][cs.p[i][1]]!='A'+i;\n      }\n      if(!f)break;\n      que.pop();\n      // int b=0;\n      // for(int i=0;i<n;i++){\n      // \tb=b<<8|cs.p[i][0]<<4|cs.p[i][1];\n      // }\n      // if(!p.insert(b).second)continue;\n      static int dy[]={-1,0,0,0,1};\n      static int dx[]={0,-1,0,1,0};\n      for(int i=0;i<5;i++){\n\tint y1,x1,y2,x2,y3,x3;\n\tauto enqueue=[&](){\n\t  S ns{{y1,x1,y2,x2,y3,x3},cs.t+1};\n\t  int b=0;\n\t  for(int i=0;i<n;i++){\n\t    b=b<<8|ns.p[i][0]<<4|ns.p[i][1];\n\t  }\n\t  if(!p[b]++){\n\t    que.push(ns);\n\t  }\n\t};\n\ty1=cs.p[0][0]+dy[i];\n\tx1=cs.p[0][1]+dx[i];\n\ty2=cs.p[1][0];\n\tx2=cs.p[1][1];\n\ty3=cs.p[2][0];\n\tx3=cs.p[2][1];\n\tif(g[y1][x1]=='#')continue;\n\tif(n==1){\n\t  enqueue();\n\t}else{\n\t  for(int j=0;j<5;j++){\n\t    y2=cs.p[1][0]+dy[j];\n\t    x2=cs.p[1][1]+dx[j];\n\t    if(g[y2][x2]=='#'||y2==y1&&x2==x1||y1==cs.p[1][0]&&x1==cs.p[1][1]&&y2==cs.p[0][0]&&x2==cs.p[0][1])continue;\n\t    if(n==2){\n\t      enqueue();\n\t    }else{\n\t      for(int k=0;k<5;k++){\n\t\ty3=cs.p[2][0]+dy[k];\n\t\tx3=cs.p[2][1]+dx[k];\n\t\tif(g[y3][x3]=='#'||y3==y1&&x3==x1||y3==y2&&x3==x2||y3==cs.p[0][0]&&x3==cs.p[0][1]&&y1==cs.p[2][0]&&x1==cs.p[2][1]||y3==cs.p[1][0]&&x3==cs.p[1][1]&&y2==cs.p[2][0]&&x2==cs.p[2][1])continue;\n\t\tenqueue();\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.front().t<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nbool wall[16*16];\nint mv[] = {0, 1, -1, 16, -16};\n\nint compress(int pa, int pb, int pc){\n\treturn (pa)|(pb<<8)|(pc<<16);\n}\n\nint solve(int start, int goal){\n\tstatic bool visit[16*16*16*16*16*16];\n\tmemset(visit, false, sizeof(visit));\n\tvisit[start] = true;\n\tvector<int> state[2]; state[0].push_back(start);\n\tfor(int res=1; ;res++){\n\t\tint cur = 1-res%2, next = res%2;\n\t\tstate[next].clear();\n\t\tfor(int i=0;i<state[cur].size();i++){\n\t\t\tint pa = state[cur][i]%256, pb = (state[cur][i]>>8)%256, pc = (state[cur][i]>>16);\n\t\t\tfor(int a=0;a<5;a++){\n\t\t\t\tint npa = pa + mv[a];\n\t\t\t\tif(wall[npa]) continue;\n\t\t\t\tfor(int b=0;b<(pb?5:1);b++){\n\t\t\t\t\tint npb = pb + mv[b];\n\t\t\t\t\tif(npb!=0){\n\t\t\t\t\t\tif(wall[npb]) continue;\n\t\t\t\t\t\tif(npa==npb) continue;\n\t\t\t\t\t\tif(npb==pa&&npa==pb) continue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int c=0;c<(pc?5:1);c++){\n\t\t\t\t\t\tint npc = pc + mv[c];\n\t\t\t\t\t\tif(npc!=0){\n\t\t\t\t\t\t\tif(wall[npc]) continue;\n\t\t\t\t\t\t\tif(npc==npa||npc==npb) continue;\n\t\t\t\t\t\t\tif(npc==pa&&npa==pc) continue;\n\t\t\t\t\t\t\tif(npc==pb&&npb==pc) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ns = (npa)|(npb<<8)|(npc<<16);\n\t\t\t\t\t\tif(visit[ns]) continue;\n\t\t\t\t\t\tif(ns==goal) return res;\n\t\t\t\t\t\tvisit[ns] = true;\n\t\t\t\t\t\tstate[next].push_back(ns);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint w, h, n;\n\tstring mp[16];\n\twhile(cin >> w >> h >> n, w){\n\t\tgetline(cin, mp[0]);\n\t\tfor(int i=0;i<h;i++) getline(cin, mp[i]);\n\t\tmemset(wall, false, sizeof(wall));\n\t\tint start = 0, goal = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mp[i][j]=='#') wall[16*i+j] = true;\n\t\t\t\tif(islower(mp[i][j])) start |= (16*i+j) << (8*(mp[i][j]-'a'));\n\t\t\t\tif(isupper(mp[i][j])) goal  |= (16*i+j) << (8*(mp[i][j]-'A'));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(start, goal));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC target \"tune=native\"\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n \nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n \n \nstruct State {\n    array<int, 3> xs, ys;\n    State() {\n        fill(all(xs), 0);\n        fill(all(ys), 0);\n    }\n    int hash() {\n        int a = 0;\n        rep(i, 3) a = a | (xs[i] << (4 * i));\n        rep(i, 3) a = a | (ys[i] << (4 * i + 4 * 3));\n        return a;\n    }\n};\n \narray<short, 1 << 24> dist;\n \nbool solve() {\n    int W, H, N; \n    vector<string> G;    \n    cin >> W >> H >> N;\n    if(W == 0) return false;\n    cin.ignore();\n    rep(i, H) {\n        string s; getline(cin, s);\n        G.push_back(s);\n    }\n    State init, last;    \n     \n    rep(y, H) rep(x, W) {\n        int i = G[y][x] - 'a';\n        int j = G[y][x] - 'A';\n        if(0 <= i and i < N) {\n            init.ys[i] = y;\n            init.xs[i] = x;\n        }\n        if(0 <= j and j < N) {\n            last.ys[j] = y;\n            last.xs[j] = x;\n        }\n    }\n     \n    auto on_field = [&] (int y, int x) {\n        return 0 <= y and y < H and 0 <= x and x < W and G[y][x] !='#';\n    };\n    auto move = [&] (State &s, int idx, int dir) {\n        s.xs[idx] += dx[dir];\n        s.ys[idx] += dy[dir];\n        return on_field(s.ys[idx], s.xs[idx]);\n    };\n    auto same = [&] (State &s, int i) {\n        rep(j, i) {\n            if(s.ys[i] == s.ys[j] and s.xs[i] == s.xs[j]) return true;\n        }\n        return false;\n    };\n    auto swapped = [&] (State &n, State &p) {\n        rep(i, N) rep(j, N) if(i != j) {\n            if((n.ys[j] == p.ys[i] and\n                n.xs[j] == p.xs[i]) and\n               (n.ys[i] == p.ys[j] and\n                n.xs[i] == p.xs[j])) return true;\n        }\n        return false;\n    };\n \n    int last_hash = last.hash();\n \n    queue<State> que;\n    fill(all(dist), -1);\n    que.push(init);\n    dist[init.hash()] = 0;\n    while(que.size()) {\n        State now = que.front(); que.pop();\n        int nh = now.hash();\n        rep(i, 5) {\n            State nxt1 = now;\n            if(not move(nxt1, 0, i)) continue;\n            rep(j, 5) {\n                State nxt2 = nxt1;\n                if(N >= 2 and not move(nxt2, 1, j)) continue;\n                if(N >= 2 and same(nxt2, 1)) continue;\n                rep(k, 5) {\n                    State nxt3 = nxt2;\n                    if(N >= 3 and not move(nxt3, 2, k)) continue;\n                    if(N >= 3 and same(nxt3, 2)) continue;\n                     \n                    if(not swapped(nxt3, now)) {\n                        int h = nxt3.hash();\n                        if(last_hash == h) {\n                            cout << dist[nh] + 1 << endl;\n                            return 1;\n                        }\n                        if(dist[h] < 0) {\n                            dist[h] = dist[nh] + 1;\n                            que.push(nxt3);\n                        }\n                    }                    \n                }\n            }\n        }\n    }\n    assert(0);\n    return 1;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1281 The Morning after Halloween\n// 2018.3.3 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint  w, h;\nchar map[18][18];\nint  n;\nchar sr[3], sc[3], gr[3], gc[3];\nchar r[3], c[3], nr[3], nc[3];\nint  mv[5][2] = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\nshort mk[16][16][16][16][16][16];\n\n#define QMAX 300000\ntypedef struct { char r[3], c[3]; short t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short t)\n{\n\tint i, j, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tfor (j = 0; j < n; j++) que[i].r[j] = nr[j], que[i].c[j] = nc[j]; \n\tque[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint check(int i, int j)\n{\n\tif (nr[i] == nr[j] && nc[i] == nc[j]) return 1;\n\tif (r[i] == nr[j] && c[i] == nc[j] && r[j] == nr[i] && c[j] == nc[i]) return 1;\n\treturn 0;\n}\n\nvoid _enq(int t)\n{\n\tif (t < mk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]]) {\n\t\tmk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]] = t;\n\t\tenq(t);\n\t}\n}\n\nint dijkstra()\n{\n\tint i, j, k, t;\n\n\tmemset(mk, 0x55, sizeof(mk));\n\tfor (i = n; i < 3; i++) r[i] = c[i] = nr[i] = nc[i] = 0;\n\tfor (i = 0; i < n; i++) nr[i] = sr[i], nc[i] = sc[i];\n\tqsize = 0;\n\tmk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]] = 0;\n\tenq(0);\n\n\twhile (qsize) {\n\t\tfor (i = 0; i < n; i++) r[i] = que[0].r[i], c[i] = que[0].c[i];\n\t\tt = que[0].t, deq();\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (i == n) return t;\n\t\t\tif (gr[i] != r[i] || gc[i] != c[i]) break;\n\t\t}\n\n\t\tif (mk[r[0]][c[0]][r[1]][c[1]][r[2]][c[2]] < t) continue;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tnr[0] = r[0] + mv[i][0], nc[0] = c[0] + mv[i][1];\n\t\t\tif (map[nr[0]][nc[0]] == '#') continue;\n\n\t\tif (n >= 2) for (j = 0; j < 5; j++) {\n\t\t\tnr[1] = r[1] + mv[j][0], nc[1] = c[1] + mv[j][1];\n\t\t\tif (map[nr[1]][nc[1]] == '#' || check(0, 1)) continue;\n\n\t\tif (n == 3) for (k = 0; k < 5; k++) {\n\t\t\tnr[2] = r[2] + mv[k][0], nc[2] = c[2] + mv[k][1];\n\t\t\tif (map[nr[2]][nc[2]] == '#' || check(0, 2) || check(1,2)) continue;\n\t\t\t_enq(t+1);\n\t\t} else _enq(t+1);\n\t\t} else _enq(t+1);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, r, c;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 20, stdin) && *buf != '0') {\n\t\tsscanf(buf, \"%d%d%d\", &w, &h, &n);\n\t\tfor (i = n; i < 3; i++) sr[i] = sc[i] = gr[i] = gc[i] = 0;\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfgets(p=map[r], 18, stdin);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (isalpha(*p)) {\n\t\t\t\t\tif (islower(*p)) sr[*p-'a'] = r, sc[*p-'a'] = c;\n\t\t\t\t\telse             gr[*p-'A'] = r, gc[*p-'A'] = c;\n\t\t\t\t\t*p = ' ';\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1281 The Morning after Halloween\n// 2018.3.3 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint  w, h;\nchar map[18][18];\nint  n;\nchar sr[3], sc[3], gr[3], gc[3];\nchar r[3], c[3], nr[3], nc[3];\nint  mv[5][2] = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\nshort mk[16][16][16][16][16][16];\n\n#define QMAX 300000\ntypedef struct { char r[3], c[3]; short t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short t)\n{\n\tint i, j, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tfor (j = 0; j < n; j++) que[i].r[j] = nr[j], que[i].c[j] = nc[j]; \n\tque[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint check(int i, int j)\n{\n\tif (nr[i] == nr[j] && nc[i] == nc[j]) return 1;\n\tif (r[i] == nr[j] && c[i] == nc[j] && r[j] == nr[i] && c[j] == nc[i]) return 1;\n\treturn 0;\n}\n\nvoid _enq(int t)\n{\n\tif (t < mk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]]) {\n\t\tmk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]] = t;\n\t\tenq(t);\n\t}\n}\n\nint dijkstra()\n{\n\tint i, j, k, t;\n\n\tmemset(mk, 0x55, sizeof(mk));\n\tfor (i = n; i < 3; i++) r[i] = c[i] = nr[i] = nc[i] = 0;\n\tfor (i = 0; i < n; i++) nr[i] = sr[i], nc[i] = sc[i];\n\tqsize = 0;\n\tmk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]] = 0;\n\tenq(0);\n\n\twhile (qsize) {\n\t\tfor (i = 0; i < n; i++) r[i] = que[0].r[i], c[i] = que[0].c[i];\n\t\tt = que[0].t, deq();\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (i == n) return t;\n\t\t\tif (gr[i] != r[i] || gc[i] != c[i]) break;\n\t\t}\n\n\t\tif (mk[r[0]][c[0]][r[1]][c[1]][r[2]][c[2]] < t) continue;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tnr[0] = r[0] + mv[i][0], nc[0] = c[0] + mv[i][1];\n\t\t\tif (map[nr[0]][nc[0]] == '#') continue;\n\n\t\tif (n >= 2) for (j = 0; j < 5; j++) {\n\t\t\tnr[1] = r[1] + mv[j][0], nc[1] = c[1] + mv[j][1];\n\t\t\tif (map[nr[1]][nc[1]] == '#' || check(0, 1)) continue;\n\n\t\tif (n == 3) for (k = 0; k < 5; k++) {\n\t\t\tnr[2] = r[2] + mv[k][0], nc[2] = c[2] + mv[k][1];\n\t\t\tif (map[nr[2]][nc[2]] == '#' || check(0, 2) || check(1,2)) continue;\n\t\t\t_enq(t+1);\n\t\t} else _enq(t+1);\n\t\t} else _enq(t+1);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, r, c;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 20, stdin) && *buf != '0') {\n\t\tsscanf(buf, \"%d%d%d\", &w, &h, &n);\n\t\tfor (i = n; i < 3; i++) sr[i] = sc[i] = gr[i] = gc[i] = 0;\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfgets(p=map[r], 18, stdin);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (isalpha(*p)) {\n\t\t\t\t\tif (islower(*p)) gr[*p-'a'] = r, gc[*p-'a'] = c;\n\t\t\t\t\telse             sr[*p-'A'] = r, sc[*p-'A'] = c;\n\t\t\t\t\t*p = ' ';\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1281 The Morning after Halloween\n// 2018.3.3 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint  w, h;\nchar map[18][18];\nint  n;\nchar sr[3], sc[3], gr[3], gc[3];\nchar r[3], c[3], nr[3], nc[3];\nint  mv[5][2] = {{0,0},{-1,0},{0,1},{1,0},{0,-1}};\nshort mk[16][16][16][16][16][16];\n\n#define QMAX 300000\ntypedef struct { char r[3], c[3]; short t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short t)\n{\n\tint i, j, min;\n\tQUE qt;\n\n\tif (t >= mk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]]) return;\n\tmk[nr[0]][nc[0]][nr[1]][nc[1]][nr[2]][nc[2]] = t;\n\n\ti = qsize++;\n\tfor (j = 0; j < n; j++) que[i].r[j] = nr[j], que[i].c[j] = nc[j]; \n\tque[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint check(int i, int j)\n{\n\tif (nr[i] == nr[j] && nc[i] == nc[j]) return 1;\n\tif (r[i] == nr[j] && c[i] == nc[j] && r[j] == nr[i] && c[j] == nc[i]) return 1;\n\treturn 0;\n}\n\nint dijkstra()\n{\n\tint i, j, k, t, nt;\n\n\tmemset(mk, 0x55, sizeof(mk));\n\tfor (i = n; i < 3; i++) r[i] = c[i] = nr[i] = nc[i] = 0;\n\tfor (i = 0; i < n; i++) nr[i] = sr[i], nc[i] = sc[i];\n\tqsize = 0;\n\tenq(0);\n\n\twhile (qsize) {\n\t\tfor (i = 0; i < n; i++) r[i] = que[0].r[i], c[i] = que[0].c[i];\n\t\tt = que[0].t, nt = t+1, deq();\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (i == n) return t;\n\t\t\tif (gr[i] != r[i] || gc[i] != c[i]) break;\n\t\t}\n\n\t\tif (mk[r[0]][c[0]][r[1]][c[1]][r[2]][c[2]] < t) continue;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tif (!i) nr[0] = r[0], nc[0] = c[0];\n\t\t\telse {\n\t\t\t\tnr[0] = r[0] + mv[i][0], nc[0] = c[0] + mv[i][1];\n\t\t\t\tif (map[nr[0]][nc[0]] == '#') continue;\n\t\t\t}\n\n\t\tif (n >= 2) for (j = 0; j < 5; j++) {\n\t\t\tif (!j) nr[1] = r[1], nc[1] = c[1];\n\t\t\telse {\n\t\t\t\tnr[1] = r[1] + mv[j][0], nc[1] = c[1] + mv[j][1];\n\t\t\t\tif (map[nr[1]][nc[1]] == '#') continue;\n\t\t\t}\n\t\t\tif (check(0, 1)) continue;\n\n\t\tif (n == 3) for (k = 0; k < 5; k++) {\n\t\t\tif (!k) nr[2] = r[2], nc[2] = c[2];\n\t\t\telse {\n\t\t\t\tnr[2] = r[2] + mv[k][0], nc[2] = c[2] + mv[k][1];\n\t\t\t\tif (map[nr[2]][nc[2]] == '#') continue;\n\t\t\t}\n\t\t\tif (check(1,2) || check(0,2)) continue;\n\t\t\tenq(nt);\n\t\t} else enq(nt);\n\t\t} else enq(nt);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, r, c;\n\tchar buf[20], *p;\n\n\twhile (fgets(buf, 20, stdin) && *buf != '0') {\n\t\tsscanf(buf, \"%d%d%d\", &w, &h, &n);\n\t\tfor (i = n; i < 3; i++) sr[i] = sc[i] = gr[i] = gc[i] = 0;\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfgets(p=map[r], 18, stdin);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (isalpha(*p)) {\n\t\t\t\t\tif (islower(*p)) gr[*p-'a'] = r, gc[*p-'a'] = c;\n\t\t\t\t\telse             sr[*p-'A'] = r, sc[*p-'A'] = c;\n\t\t\t\t\t*p = ' ';\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dijkstra());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tboolean[][] u = new boolean[256][256];\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu[SA][SB] = true;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&!u[NA][NB]){\n\t\t\t\t\t\tu[NA][NB] = true;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tfor(byte[][]a:u)for(byte[]b:a)Arrays.fill(b, (byte)0);\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = 1;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]==0){\n\t\t\t\t\t\tu[NA][NB][NC] = 1;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tu = new byte[256][256][256];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<DA&&db<DB&&dc<DC)continue;\n\t\t\t\t\t\tif(sda<DA&&sdb<DB&&sdc<DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+10<MAX)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N;\n\tchar[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tshort INF = 1<<13;\n\tshort[][][] dist;\n\tint[] si, sj, gi, gj;\n\t\n\tint one(){\n\t\tfor(int i=0;i<w*h;i++)dist[0][0][i]=INF;\n\t\tdist[0][0][si[0]*w+sj[0]] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(si[0]*w+sj[0]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll();\n\t\t\tint i = V/w, j = V%w;\n\t\t\tif(i==gi[0]&&j==gj[0])return dist[0][0][V];\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(map[ni][nj]==' '&&dist[0][0][ni*w+nj]==INF){\n\t\t\t\t\tdist[0][0][ni*w+nj] = (short) (dist[0][0][V]+1);\n\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint two(){\n\t\tint M = w*h;\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)dist[i][j][0]=INF;\n\t\tdist[si[0]*w+sj[0]][si[1]*w+sj[1]][0] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add((si[0]*w+sj[0])*M+si[1]*w+sj[1]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/M, VB = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1])return dist[VA][VB][0];\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1];\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1];\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(Ai==Bi&&Aj==Bj)continue;\n\t\t\t\t\tif(Ai==bi&&Aj==bj&&Bi==ai&&Bj==aj)continue;\n\t\t\t\t\tint PA = Ai*w+Aj, PB = Bi*w+Bj;\n\t\t\t\t\tif(dist[PA][PB][0]!=INF)continue;\n\t\t\t\t\tdist[PA][PB][0] = (short) (dist[VA][VB][0]+1);\n\t\t\t\t\tq.add(PA*M+PB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint three(){\n\t\tint M = w*h, MM = w*h*w*h, SA = si[0]*w+sj[0], SB = si[1]*w+sj[1], SC = si[2]*w+sj[2];\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)dist[i][j][k]=INF;\n\t\tdist[SA][SB][SC] = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(SA*MM+SB*M+SC);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/MM, VB = (V%MM)/M, VC = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w, ci = VC/w, cj = VC%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1]&&ci==gi[2]&&cj==gj[2])return dist[VA][VB][VC];\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1], PA = Ai*w+Aj;\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1], PB = Bi*w+Bj;\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(PA==PB)continue;\n\t\t\t\t\tif(PA==VB&&PB==VA)continue;\n\t\t\t\t\tfor(int k2=0;k2<5;k2++){\n\t\t\t\t\t\tint Ci = ci+d[k2][0], Cj = cj+d[k2][1], PC = Ci*w+Cj;\n\t\t\t\t\t\tif(map[Ci][Cj]=='#')continue;\n\t\t\t\t\t\tif(PA==PC||PB==PC)continue;\n\t\t\t\t\t\tif(PA==VC&&PC==VA || PB==VC&&PC==VB)continue;\n\t\t\t\t\t\tif(dist[PA][PB][PC]!=INF)continue;\n\t\t\t\t\t\tdist[PA][PB][PC] = (short) (dist[VA][VB][VC]+1);\n\t\t\t\t\t\tq.add(PA*MM+PB*M+PC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new short[256][256][256];\n\t\tsi = new int[3]; sj = new int[3]; gi = new int[3]; gj = new int[3];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.nextLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(Character.isLowerCase(map[i][j])){\n\t\t\t\t\t\tsi[map[i][j]-'a'] = i; sj[map[i][j]-'a'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse if(Character.isUpperCase(map[i][j])){\n\t\t\t\t\t\tgi[map[i][j]-'A'] = i; gj[map[i][j]-'A'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(55<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n//\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<DA&&db<DB&&dc<DC)continue;\n\t\t\t\t\t\tif(sda<DA&&sdb<DB&&sdc<DC)continue;\n//\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n//\t\t\t\t\t\tif(max<MAX)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<DA&&db<DB&&dc<DC)continue;\n\t\t\t\t\t\tif(sda<DA&&sdb<DB&&sdc<DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+6<MAX)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<DA&&db<DB&&dc<DC)continue;\n\t\t\t\t\t\tif(sda<DA&&sdb<DB&&sdc<DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(50<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tint w, h, N;\n\tchar[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte INF = Byte.MAX_VALUE, MIN = Byte.MIN_VALUE;\n\tbyte[][][] dist;\n\tint[] si, sj, gi, gj;\n\t\n\tint one(){\n\t\tfor(int i=0;i<w*h;i++)dist[0][0][i]=INF;\n\t\tdist[0][0][si[0]*w+sj[0]] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(si[0]*w+sj[0]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll();\n\t\t\tint i = V/w, j = V%w;\n\t\t\tif(i==gi[0]&&j==gj[0])return (int)dist[0][0][V] + 128;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(map[ni][nj]==' '&&dist[0][0][ni*w+nj]==INF){\n\t\t\t\t\tdist[0][0][ni*w+nj] = (byte) (dist[0][0][V]+1);\n\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint two(){\n\t\tint M = w*h;\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)dist[i][j][0]=INF;\n\t\tdist[si[0]*w+sj[0]][si[1]*w+sj[1]][0] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add((si[0]*w+sj[0])*M+si[1]*w+sj[1]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/M, VB = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1])return (int)dist[VA][VB][0] + 128;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1];\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1];\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(Ai==Bi&&Aj==Bj)continue;\n\t\t\t\t\tif(Ai==bi&&Aj==bj&&Bi==ai&&Bj==aj)continue;\n\t\t\t\t\tint PA = Ai*w+Aj, PB = Bi*w+Bj;\n\t\t\t\t\tif(dist[PA][PB][0]!=INF)continue;\n\t\t\t\t\tdist[PA][PB][0] = (byte) (dist[VA][VB][0]+1);\n\t\t\t\t\tq.add(PA*M+PB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint three(){\n\t\tint M = w*h, MM = w*h*w*h, SA = si[0]*w+sj[0], SB = si[1]*w+sj[1], SC = si[2]*w+sj[2];\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)dist[i][j][k]=INF;\n\t\tdist[SA][SB][SC] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(SA*MM+SB*M+SC);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/MM, VB = (V%MM)/M, VC = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w, ci = VC/w, cj = VC%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1]&&ci==gi[2]&&cj==gj[2])return (int)dist[VA][VB][VC] + 128;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1], PA = Ai*w+Aj;\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1], PB = Bi*w+Bj;\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(PA==PB)continue;\n\t\t\t\t\tif(PA==VB&&PB==VA)continue;\n\t\t\t\t\tfor(int k2=0;k2<5;k2++){\n\t\t\t\t\t\tint Ci = ci+d[k2][0], Cj = cj+d[k2][1], PC = Ci*w+Cj;\n\t\t\t\t\t\tif(map[Ci][Cj]=='#')continue;\n\t\t\t\t\t\tif(PA==PC||PB==PC)continue;\n\t\t\t\t\t\tif(PA==VC&&PC==VA || PB==VC&&PC==VB)continue;\n\t\t\t\t\t\tif(dist[PA][PB][PC]!=INF)continue;\n\t\t\t\t\t\tdist[PA][PB][PC] = (byte) (dist[VA][VB][VC]+1);\n\t\t\t\t\t\tq.add(PA*MM+PB*M+PC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new byte[256][256][256];\n\t\tsi = new int[3]; sj = new int[3]; gi = new int[3]; gj = new int[3];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.nextLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(Character.isLowerCase(map[i][j])){\n\t\t\t\t\t\tsi[map[i][j]-'a'] = i; sj[map[i][j]-'a'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse if(Character.isUpperCase(map[i][j])){\n\t\t\t\t\t\tgi[map[i][j]-'A'] = i; gj[map[i][j]-'A'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(70<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tint W, H, N;\n\tint[][] field = new int[16][16];\n\n\tint[] dx = {0, 1, 0, -1, 0};\n\tint[] dy = {1, 0, -1, 0, 0};\n\n\tshort[][][] bfs = new short[16*16][16*16][16*16];\n\tQueue<int[]> Q = new ArrayDeque<>();\n\tpublic void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif(W == 0) break;\n\t\t\tint[] begin = new int[3];\n\t\t\tint[] end = new int[3];\n\t\t\tint idx = 1;\n\t\t\tsc.nextLine();\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tString str = sc.nextLine();\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tchar c = str.charAt(j);\n\t\t\t\t\tif(c == '#') field[i][j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j] = idx++;\n\t\t\t\t\t\tif('A' <= c && c <= 'C') end[c - 'A'] = field[i][j];\n\t\t\t\t\t\telse if('a' <= c && c <= 'c') begin[c - 'a'] = field[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tGraph graph = new Graph(idx);\n\t\t\tgraph.addEdge(0, 0, 1);\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(field[i][j] > 0){\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\t\t\tif(field[i + dy[k]][j + dx[k]] > 0){\n\t\t\t\t\t\t\t\tgraph.addEdge(field[i][j], field[i + dy[k]][j + dx[k]], 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < idx; i++){\n\t\t\t\tfor(int j = 0; j < idx; j++){\n\t\t\t\t\tfor(int k = 0; k < idx; k++){\n\t\t\t\t\t\tbfs[i][j][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tQ.clear();\n\t\t\tQ.add(begin);\n\t\t\tbfs[begin[0]][begin[1]][begin[2]] = 0;\n\t\t\tLOOP:\n\t\t\twhile(!Q.isEmpty()){\n\t\t\t\tint[] t = Q.poll();\n\t\t\t\tfor(Edge e0 : graph.nodes[t[0]]){\n\t\t\t\t\tfor(Edge e1 : graph.nodes[t[1]]){\n\t\t\t\t\t\tfor(Edge e2 : graph.nodes[t[2]]){\n\t\t\t\t\t\t\tint n0 = e0.to.idx;\n\t\t\t\t\t\t\tint n1 = e1.to.idx;\n\t\t\t\t\t\t\tint n2 = e2.to.idx;\n\t\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\tbfs[n0][n1][n2] != -1 ||\n\t\t\t\t\t\t\t\tN >= 2 && t[0] == n1 && t[1] == n0 ||\n\t\t\t\t\t\t\t\tN >= 3 && t[0] == n2 && t[2] == n0 ||\n\t\t\t\t\t\t\t\tN >= 3 && t[1] == n2 && t[2] == n1 ||\n\t\t\t\t\t\t\t\tN >= 2 && n0 == n1 ||\n\t\t\t\t\t\t\t\tN >= 3 && n0 == n2 ||\n\t\t\t\t\t\t\t\tN >= 3 && n1 == n2\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//System.err.printf(\"(%d,%d,%d)=>(%d,%d,%d)\\n\",t[0],t[1],t[2],n0,n1,n2);\n\t\t\t\t\t\t\tbfs[n0][n1][n2] = (short)(bfs[t[0]][t[1]][t[2]] + 1);\n\t\t\t\t\t\t\tif(n0 == end[0] && n1 == end[1] && n2 == end[2]) break LOOP;\n\t\t\t\t\t\t\tQ.add(new int[]{n0,n1,n2});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bfs[end[0]][end[1]][end[2]]);\n\t\t\t\n\t\t}\n\t}\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n\nclass Graph{\n\tNode[] nodes;\n\tpublic Graph(int n){\n\t\tnodes = new Node[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnodes[i] = new Node(i);\n\t\t}\n\t}\n\tpublic void addEdge(int from, int to, int weight){\n\t\tnodes[from].add(new Edge(nodes[from], nodes[to], weight));\n\t}\n\tpublic void addBiEdge(int n1, int n2, int weight){\n\t\taddEdge(n1, n2, weight);\n\t\taddEdge(n2, n1, weight);\n\t}\n}\n\nclass Node extends ArrayList<Edge>{\n\tint idx;\n\tpublic Node(int idx){\n\t\tthis.idx = idx;\n\t}\n\t\n}\n\nclass Edge{\n\tNode from;\n\tNode to;\n\tint weight;\n\tpublic Edge(Node from, Node to, int weight){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.weight = weight;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(57<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tboolean[][] u = new boolean[h][w];\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tu[si][sj] = true;\n\t\tl.add(new int[]{si, sj});\n\t\tint res = 0;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[] a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tif(gi==pi&&gj==pj){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&!u[ni][nj]){\n\t\t\t\t\t\tu[ni][nj] = true; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(58<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(60<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\tint w, h, N;\n\tchar[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte INF = Byte.MAX_VALUE, MIN = Byte.MIN_VALUE;\n\t//shortÂ^ÂÃ256^3ÂÃÂÂÂÂÂÂÂÃ°ÂÃÂÃ©ÂÃMLEÂÃÂÃÂÃÂÃÂÂµÂÃÂÂ¤ÂÃÂÃbyteÂÃÂKÂ}ÂÂ\n\t//unsignedÂÂÂÃÂlÂÃ°ÂlÂÂ¦ÂÃ©ÂKÂvÂÂªÂÂ ÂÃ© -2^7Â`2^7-1 -> 0Â`2^8-1 ÂÃÂÃÂÃ¨128ÂÃ°ÂÂ«ÂÂ¹ÂÃÂÂ¢ÂÂ¢\n\tbyte[][][] dist;\n\tint[] si, sj, gi, gj;\n\t\n\tint one(){\n\t\tfor(int i=0;i<w*h;i++)dist[0][0][i]=INF;\n\t\tdist[0][0][si[0]*w+sj[0]] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(si[0]*w+sj[0]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll();\n\t\t\tint i = V/w, j = V%w;\n\t\t\tif(i==gi[0]&&j==gj[0])return (int)dist[0][0][V] + 128;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(map[ni][nj]==' '&&dist[0][0][ni*w+nj]==INF){\n\t\t\t\t\tdist[0][0][ni*w+nj] = (byte) (dist[0][0][V]+1);\n\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint two(){\n\t\tint M = w*h;\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)dist[i][j][0]=INF;\n\t\tdist[si[0]*w+sj[0]][si[1]*w+sj[1]][0] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add((si[0]*w+sj[0])*M+si[1]*w+sj[1]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/M, VB = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1])return (int)dist[VA][VB][0] + 128;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1];\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1];\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(Ai==Bi&&Aj==Bj)continue;\n\t\t\t\t\tif(Ai==bi&&Aj==bj&&Bi==ai&&Bj==aj)continue;\n\t\t\t\t\tint PA = Ai*w+Aj, PB = Bi*w+Bj;\n\t\t\t\t\tif(dist[PA][PB][0]!=INF)continue;\n\t\t\t\t\tdist[PA][PB][0] = (byte) (dist[VA][VB][0]+1);\n\t\t\t\t\tq.add(PA*M+PB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint three(){\n\t\tint FIX = 0;\n\t\tint M = w*h, MM = w*h*w*h, SA = si[0]*w+sj[0], SB = si[1]*w+sj[1], SC = si[2]*w+sj[2];\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)dist[i][j][k]=INF;\n\t\tdist[SA][SB][SC] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(SA*MM+SB*M+SC);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/MM, VB = (V%MM)/M, VC = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w, ci = VC/w, cj = VC%w;\n\t\t\t//ÂÂÂÂ¦ÂÂª2^8ÂÃÂÃ£ÂÃÂÃÂÃ©ÂÃªÂÂÂÃÂÂ½ÂÃÂÃÂÃÂÂ\n\t\t\t//ÂJÂEÂÂÂgÂÃ°MINÂÃÂÂÂZÂbÂgÂÂµÂAÂÂ»ÂÃÂÃÂÃÂJÂEÂÂÂgÂÂµÂÂ½ÂÂªÂÃ°FIXÂÃÂÃÂÃÂÃÂÂ¨ÂÂ«ÂAÂÂÂÂ¦ÂÃ°ÂÃÂÂ·ÂÃÂÂ«ÂÃÂÂ«ÂÂµÂÂ±ÂÃ\n\t\t\tif(dist[VA][VB][VC]==INF-1){\n\t\t\t\tFIX = dist[VA][VB][VC] + 128;\n\t\t\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)if(dist[i][j][k]!=INF)dist[i][j][k]=MIN;\n\t\t\t}\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1]&&ci==gi[2]&&cj==gj[2])return (int)dist[VA][VB][VC] + 128 + FIX;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1], PA = Ai*w+Aj;\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1], PB = Bi*w+Bj;\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(PA==PB)continue;\n\t\t\t\t\tif(PA==VB&&PB==VA)continue;\n\t\t\t\t\tfor(int k2=0;k2<5;k2++){\n\t\t\t\t\t\tint Ci = ci+d[k2][0], Cj = cj+d[k2][1], PC = Ci*w+Cj;\n\t\t\t\t\t\tif(map[Ci][Cj]=='#')continue;\n\t\t\t\t\t\tif(PA==PC||PB==PC)continue;\n\t\t\t\t\t\tif(PA==VC&&PC==VA || PB==VC&&PC==VB)continue;\n\t\t\t\t\t\tif(dist[PA][PB][PC]!=INF)continue;\n\t\t\t\t\t\tdist[PA][PB][PC] = (byte) (dist[VA][VB][VC]+1);\n\t\t\t\t\t\tq.add(PA*MM+PB*M+PC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new byte[256][256][256];\n\t\tsi = new int[3]; sj = new int[3]; gi = new int[3]; gj = new int[3];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.nextLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(Character.isLowerCase(map[i][j])){\n\t\t\t\t\t\tsi[map[i][j]-'a'] = i; sj[map[i][j]-'a'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse if(Character.isUpperCase(map[i][j])){\n\t\t\t\t\t\tgi[map[i][j]-'A'] = i; gj[map[i][j]-'A'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tint W, H, N;\n\tint[][] field = new int[16][16];\n\n\tint[] dx = {0, 1, 0, -1, 0};\n\tint[] dy = {1, 0, -1, 0, 0};\n\n\tshort[][][] bfs = new short[16*16][16*16][16*16];\n\tint[][] graph = new int[16*16][6];\n\tQueue<int[]> Q = new ArrayDeque<>();\n\tpublic void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif(W == 0) break;\n\t\t\tint[] begin = new int[3];\n\t\t\tint[] end = new int[3];\n\t\t\tint idx = 1;\n\t\t\tsc.nextLine();\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tString str = sc.nextLine();\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tchar c = str.charAt(j);\n\t\t\t\t\tif(c == '#') field[i][j] = 0;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j] = idx++;\n\t\t\t\t\t\tif('A' <= c && c <= 'C') end[c - 'A'] = field[i][j];\n\t\t\t\t\t\telse if('a' <= c && c <= 'c') begin[c - 'a'] = field[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraph[0][0] = 0;\n\t\t\tgraph[0][1] = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(field[i][j] > 0){\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\t\t\tif(field[i + dy[k]][j + dx[k]] > 0){\n\t\t\t\t\t\t\t\tgraph[field[i][j]][cnt++] = field[i + dy[k]][j + dx[k]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgraph[field[i][j]][cnt] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < idx; i++){\n\t\t\t\tfor(int j = 0; j < idx; j++){\n\t\t\t\t\tfor(int k = 0; k < idx; k++){\n\t\t\t\t\t\tbfs[i][j][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tQ.clear();\n\t\t\tQ.add(begin);\n\t\t\tbfs[begin[0]][begin[1]][begin[2]] = 0;\n\t\t\tLOOP:\n\t\t\twhile(!Q.isEmpty()){\n\t\t\t\tint[] t = Q.poll();\n\t\t\t\tfor(int i = 0; graph[t[0]][i] != -1; i++){\n\t\t\t\t\tfor(int j = 0; graph[t[1]][j] != -1; j++){\n\t\t\t\t\t\tfor(int k = 0; graph[t[2]][k] != -1; k++){\n\t\t\t\t\t\t\tint n0 = graph[t[0]][i];\n\t\t\t\t\t\t\tint n1 = graph[t[1]][j];\n\t\t\t\t\t\t\tint n2 = graph[t[2]][k];\n\t\t\t\t\t\t\tif(\n\t\t\t\t\t\t\t\tbfs[n0][n1][n2] != -1 ||\n\t\t\t\t\t\t\t\tN >= 2 && t[0] == n1 && t[1] == n0 ||\n\t\t\t\t\t\t\t\tN >= 3 && t[0] == n2 && t[2] == n0 ||\n\t\t\t\t\t\t\t\tN >= 3 && t[1] == n2 && t[2] == n1 ||\n\t\t\t\t\t\t\t\tN >= 2 && n0 == n1 ||\n\t\t\t\t\t\t\t\tN >= 3 && n0 == n2 ||\n\t\t\t\t\t\t\t\tN >= 3 && n1 == n2\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbfs[n0][n1][n2] = (short)(bfs[t[0]][t[1]][t[2]] + 1);\n\t\t\t\t\t\t\tif(n0 == end[0] && n1 == end[1] && n2 == end[2]) break LOOP;\n\t\t\t\t\t\t\tQ.add(new int[]{n0,n1,n2});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bfs[end[0]][end[1]][end[2]]);\n\t\t\t\n\t\t}\n\t}\n\tprivate static PrintWriter out;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N, X = 16, Y = 256, YY = 256*256;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte[][][] u;\n\tbyte[][] u2;\n\tbyte f2, f3;\n\tchar[][] map;\n\t\n\tint one(){\n\t\tint si = 0, sj = 0, gi = 0, gj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; si = i; sj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gi = i; gj = j;\n\t\t\t}\n\t\t}\n\t\tint[][] dist = new int[h][w];\n\t\tbfs(dist, gi, gj);\n\t\treturn dist[si][sj];\n\t}\n\t\n\tint two(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, GA = gai*X+gaj, GB = gbi*X+gbj;\n\t\tu2[SA][SB] = f2;\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*Y+SB);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/Y, B = x%Y;\n\t\t\t\tif(A==GA&&B==GB){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X;\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj;\n\t\t\t\t\tif((NA==B&&NB==A)||NA==NB)continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&u2[NA][NB]!=f2){\n\t\t\t\t\t\tu2[NA][NB] = f2;\n\t\t\t\t\t\tnext.add(NA*Y+NB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint three(){\n\t\tint ai = 0, aj = 0, bi = 0, bj = 0, ci = 0, cj = 0, gai = 0, gaj = 0, gbi = 0, gbj = 0, gci = 0, gcj = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(map[i][j]=='a'){\n\t\t\t\tmap[i][j] = ' '; ai = i; aj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='A'){\n\t\t\t\tmap[i][j] = ' '; gai = i; gaj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='b'){\n\t\t\t\tmap[i][j] = ' '; bi = i; bj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='B'){\n\t\t\t\tmap[i][j] = ' '; gbi = i; gbj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='c'){\n\t\t\t\tmap[i][j] = ' '; ci = i; cj = j;\n\t\t\t}\n\t\t\tif(map[i][j]=='C'){\n\t\t\t\tmap[i][j] = ' '; gci = i; gcj = j;\n\t\t\t}\n\t\t}\n\t\tint SA = ai*X+aj, SB = bi*X+bj, SC = ci*X+cj, GA = gai*X+gaj, GB = gbi*X+gbj, GC = gci*X+gcj;\n\t\tu[SA][SB][SC] = f3;\n\t\tint[][] dA = new int[h][w], dB = new int[h][w], dC = new int[h][w];\n\t\tbfs(dA, gai, gaj); bfs(dB, gbi, gbj); bfs(dC, gci, gcj);\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\tSystem.out.printf(\"%3d\", dA[i][j]==1<<29?0:dA[i][j]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tint sda = dA[ai][aj], sdb = dB[bi][bj], sdc = dC[ci][cj];\n\t\tint max = Math.max(sda, Math.max(sdb, sdc));\n\t\tList<Integer> l = new ArrayList<Integer>();\n\t\tint res = 0;\n\t\tl.add(SA*YY+SB*Y+SC);\n\t\twhile(!l.isEmpty()){\n\t\t\tList<Integer> next = new ArrayList<Integer>();\n\t\t\tfor(int x:l){\n\t\t\t\tint A = x/YY, B = (x%YY)/Y, C = x%Y;\n\t\t\t\tif(A==GA&&B==GB&&C==GC){\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tint pai = A/X, paj = A%X, pbi = B/X, pbj = B%X, pci = C/X, pcj = C%X;\n\t\t\t\tint da = dA[pai][paj], db = dB[pbi][pbj], dc = dC[pci][pcj];\n\t\t\t\tfor(int ka=0;ka<5;ka++)for(int kb=0;kb<5;kb++)for(int kc=0;kc<5;kc++){\n\t\t\t\t\tint nai = pai+d[ka][0], naj = paj+d[ka][1], nbi = pbi+d[kb][0], nbj = pbj+d[kb][1], nci = pci+d[kc][0], ncj = pcj+d[kc][1];\n\t\t\t\t\tint NA = nai*X+naj, NB = nbi*X+nbj, NC = nci*X+ncj;\n\t\t\t\t\tif(NA==NC||NB==NC||NA==NB)continue;\n\t\t\t\t\tif((NA==B&&NB==A)||(NA==C&&NC==A)||(NB==C&&NC==B))continue;\n\t\t\t\t\tif(map[nai][naj]==' '&&map[nbi][nbj]==' '&&map[nci][ncj]==' '&&u[NA][NB][NC]!=f3){\n\t\t\t\t\t\tint DA = dA[nai][naj], DB = dB[nbi][nbj], DC = dC[nci][ncj];\n\t\t\t\t\t\tif(da<=DA&&db<=DB&&dc<=DC)continue;\n\t\t\t\t\t\tif(sda<=DA&&sdb<=DB&&sdc<=DC)continue;\n\t\t\t\t\t\tint MAX = Math.max(DA, Math.max(DB, DC));\n\t\t\t\t\t\tif(max+4<MAX)continue;\n\t\t\t\t\t\tif(59<res&&da+db+dc<=DA+DB+DC)continue;\n\t\t\t\t\t\tu[NA][NB][NC] = f3;\n\t\t\t\t\t\tnext.add(NA*YY+NB*Y+NC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres++;\n\t\t\tl = next;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid bfs(int[][] dist, int si, int sj){\n\t\tfor(int[]a:dist)Arrays.fill(a, 1<<29);\n\t\tdist[si][sj] = 0;\n\t\tList<int[]> l = new ArrayList<int[]>();\n\t\tl.add(new int[]{si, sj});\n\t\tint step = 1;\n\t\twhile(!l.isEmpty()){\n\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\tfor(int[]a:l){\n\t\t\t\tint pi = a[0], pj = a[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(map[ni][nj]==' '&&step<dist[ni][nj]){\n\t\t\t\t\t\tdist[ni][nj] = step; next.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = next;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tu2 = new byte[256][256];\n\t\tu = new byte[256][256][256];\n\t\tf2 = f3 = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n//\t\t\tsc.nextLine();\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tf2++; f3++;\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.nextLine().toCharArray();\n\t\t\tsb.append((N==1?one():N==2?two():three())+\"\\n\");\n//\t\t\tSystem.out.println(System.currentTimeMillis()-T);\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//The Morning after Halloween\npublic class Main{\n\n\tint w, h, N;\n\tchar[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1},{0,0}};\n\tbyte INF = Byte.MAX_VALUE, MIN = Byte.MIN_VALUE;\n\tbyte[][][] dist;\n\tint[] si, sj, gi, gj;\n\t\n\tint one(){\n\t\tfor(int i=0;i<w*h;i++)dist[0][0][i]=INF;\n\t\tdist[0][0][si[0]*w+sj[0]] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(si[0]*w+sj[0]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll();\n\t\t\tint i = V/w, j = V%w;\n\t\t\tif(i==gi[0]&&j==gj[0])return (int)dist[0][0][V] + 128;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\t\tif(map[ni][nj]==' '&&dist[0][0][ni*w+nj]==INF){\n\t\t\t\t\tdist[0][0][ni*w+nj] = (byte) (dist[0][0][V]+1);\n\t\t\t\t\tq.add(ni*w+nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint two(){\n\t\tint M = w*h;\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)dist[i][j][0]=INF;\n\t\tdist[si[0]*w+sj[0]][si[1]*w+sj[1]][0] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add((si[0]*w+sj[0])*M+si[1]*w+sj[1]);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/M, VB = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w;\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1])return (int)dist[VA][VB][0] + 128;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1];\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1];\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(Ai==Bi&&Aj==Bj)continue;\n\t\t\t\t\tif(Ai==bi&&Aj==bj&&Bi==ai&&Bj==aj)continue;\n\t\t\t\t\tint PA = Ai*w+Aj, PB = Bi*w+Bj;\n\t\t\t\t\tif(dist[PA][PB][0]!=INF)continue;\n\t\t\t\t\tdist[PA][PB][0] = (byte) (dist[VA][VB][0]+1);\n\t\t\t\t\tq.add(PA*M+PB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint three(){\n\t\tint FIX = 0;\n\t\tint M = w*h, MM = w*h*w*h, SA = si[0]*w+sj[0], SB = si[1]*w+sj[1], SC = si[2]*w+sj[2];\n\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)dist[i][j][k]=INF;\n\t\tdist[SA][SB][SC] = MIN;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(SA*MM+SB*M+SC);\n\t\twhile(!q.isEmpty()){\n\t\t\tint V = q.poll(), VA = V/MM, VB = (V%MM)/M, VC = V%M;\n\t\t\tint ai = VA/w, aj = VA%w, bi = VB/w, bj = VB%w, ci = VC/w, cj = VC%w;\n\t\t\tif(dist[VA][VB][VC]==INF-1){\n\t\t\t\tFIX = dist[VA][VB][VC] + 128;\n\t\t\t\tfor(int i=0;i<M;i++)for(int j=0;j<M;j++)for(int k=0;k<M;k++)if(dist[i][j][k]!=INF)dist[i][j][k]=MIN;\n\t\t\t}\n\t\t\tif(ai==gi[0]&&aj==gj[0]&&bi==gi[1]&&bj==gj[1]&&ci==gi[2]&&cj==gj[2])return (int)dist[VA][VB][VC] + 128 + FIX;\n\t\t\tfor(int k0=0;k0<5;k0++){\n\t\t\t\tint Ai = ai+d[k0][0], Aj = aj+d[k0][1], PA = Ai*w+Aj;\n\t\t\t\tif(map[Ai][Aj]=='#')continue;\n\t\t\t\tfor(int k1=0;k1<5;k1++){\n\t\t\t\t\tint Bi = bi+d[k1][0], Bj = bj+d[k1][1], PB = Bi*w+Bj;\n\t\t\t\t\tif(map[Bi][Bj]=='#')continue;\n\t\t\t\t\tif(PA==PB)continue;\n\t\t\t\t\tif(PA==VB&&PB==VA)continue;\n\t\t\t\t\tfor(int k2=0;k2<5;k2++){\n\t\t\t\t\t\tint Ci = ci+d[k2][0], Cj = cj+d[k2][1], PC = Ci*w+Cj;\n\t\t\t\t\t\tif(map[Ci][Cj]=='#')continue;\n\t\t\t\t\t\tif(PA==PC||PB==PC)continue;\n\t\t\t\t\t\tif(PA==VC&&PC==VA || PB==VC&&PC==VB)continue;\n\t\t\t\t\t\tif(dist[PA][PB][PC]!=INF)continue;\n\t\t\t\t\t\tdist[PA][PB][PC] = (byte) (dist[VA][VB][VC]+1);\n\t\t\t\t\t\tq.add(PA*MM+PB*M+PC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new byte[256][256][256];\n\t\tsi = new int[3]; sj = new int[3]; gi = new int[3]; gj = new int[3];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); N = sc.nextInt();\n\t\t\tif((w|h|N)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.nextLine().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(Character.isLowerCase(map[i][j])){\n\t\t\t\t\t\tsi[map[i][j]-'a'] = i; sj[map[i][j]-'a'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse if(Character.isUpperCase(map[i][j])){\n\t\t\t\t\t\tgi[map[i][j]-'A'] = i; gj[map[i][j]-'A'] = j; map[i][j] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(N==1?one():N==2?two():three());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from heapq import heappush, heappop\n    from itertools import product\n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        w, h, n = map(int, file_input.readline().split())\n        if w == 0:\n            break\n        \n        h -= 2\n        w -= 2\n        \n        m = \"\" # one dimension map\n        m_size = h * w\n        file_input.readline()\n        for i in range(h):\n            m += file_input.readline()[1:w+1]\n        file_input.readline()\n        \n        adj = [[i] for i in range(m_size)]\n        start = []\n        goal = []\n        for i, t in enumerate(zip(m, adj)):\n            c, a = t\n            if c == '#':\n                continue\n            row = i // w\n            col = i % w\n            if row > 0 and m[i - w] != '#':\n                a.append(i - w)\n            if row < (h - 1) and m[i + w] != '#':\n                a.append(i + w)\n            if col > 0 and m[i - 1] != '#':\n                a.append(i - 1)\n            if col < (w - 1) and m[i + 1] != '#':\n                a.append(i + 1)\n            if c.islower():\n                start.append(i)\n                goal.append(m.index(c.upper()))\n        start = tuple(start)\n        goal = tuple(goal)\n        \n        if n == 1:\n            # Bidirectional search using breadth-first search\n            start = start[0]\n            goal = goal[0]\n            memo = [set(), set()] # 0: forward, 1: backward\n            memo[0].add(start)\n            memo[1].add(goal)\n            step = {start: 0, goal: 0}\n            s = 0\n            state = [(start, 0), (goal, 1)]\n            \n            while state:\n                t_state = state[:]\n                state.clear()\n                s += 1\n                for pos, d in t_state:\n                    for next_pos in adj[pos]:\n                        if next_pos in memo[d]:\n                            continue\n                        if next_pos in memo[not d]:\n                            print(s + step[next_pos])\n                            t_state.clear()\n                            state.clear()\n                            break\n                        state.append((next_pos, d))\n                        memo[d].add(next_pos)\n                        step[next_pos] = s\n            continue\n        \n        # Calculation of single path cost for A* algorithm\n        path_cost = [[0] * m_size for i in range(n)]\n        for g, p_c in zip(goal, path_cost):\n            for i, p in enumerate(m):\n                if p == '#' or i == g:\n                    continue\n                # Bidirectional search using breadth-first search\n                memo = [set(), set()] # 0: forward, 1: backward\n                memo[0].add(i)\n                memo[1].add(g)\n                step = {i: 0, g: 0}\n                s = 0\n                state = [(i, 0), (g, 1)]\n                \n                while state:\n                    t_state = state[:]\n                    state.clear()\n                    s += 1\n                    for pos, d in t_state:\n                        for next_pos in adj[pos]:\n                            if next_pos in memo[d]:\n                                continue\n                            if next_pos in memo[not d]:\n                                p_c[i] = s + step[next_pos]\n                                t_state.clear()\n                                state.clear()\n                                break\n                            state.append((next_pos, d))\n                            memo[d].add(next_pos)\n                            step[next_pos] = s\n        \n        # A* algorithm\n        h_cost = max(p_c[s] for s, p_c in zip(start, path_cost))\n        \n        if n == 2:\n            if start == goal:\n                print(0)\n                continue\n            state = (h_cost, start)\n            q = [state]\n            step = [[0 for j in range(m_size)] for i in range(m_size)]\n            step[start[0]][start[1]] = 1\n            pc1, pc2 = path_cost\n            \n            while q:\n                h_cost, pos = heappop(q)\n                p1, p2 = pos\n                if pos == goal:\n                    print(step[p1][p2] - 1)\n                    break\n                \n                nps1, nps2 = adj[pos[0]], adj[pos[1]]\n                for np1, np2 in product(nps1, nps2):\n                    if step[np1][np2] or np1 == np2 or pos == (np2, np1):\n                        continue\n                    s = step[p1][p2]\n                    new_h_cost = s + max(pc1[np1], pc2[np2])\n                    new_state = (new_h_cost, (np1, np2))\n                    heappush(q, new_state)\n                    step[np1][np2] = s + 1\n            continue\n        \n        if n == 3:\n            if start == goal:\n                print(0)\n                continue\n            state = (h_cost, start)\n            q = [state]\n            step = [[[0 for k in range(m_size)] for j in range(m_size)] for i in range(m_size)]\n            step[start[0]][start[1]][start[2]] = 1\n            pc1, pc2, pc3 = path_cost\n            \n            while q:\n                h_cost, pos = heappop(q)\n                p1, p2, p3 = pos\n                if pos == goal:\n                    print(step[p1][p2][p3] - 1)\n                    break\n                \n                nps1, nps2, nps3 = adj[p1], adj[p2], adj[p3]\n                for np1, np2, np3 in product(nps1, nps2, nps3):\n                    if step[np1][np2][np3] or \\\n                    np1 == np2 or np2 == np3 or np3 == np1 or \\\n                    (p1, p2) == (np2, np1) or (p3, p1) == (np1, np3) or \\\n                    (p2, p3) == (np3, np2):\n                        continue\n                    s = step[p1][p2][p3]\n                    new_h_cost = s + max(pc1[np1], pc2[np2], pc3[np3])\n                    new_state = (new_h_cost, (np1, np2, np3))\n                    heappush(q, new_state)\n                    step[np1][np2][np3] = s + 1\n            continue\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    W, H, N = map(int, readline().split())\n    if W == H == N == 0:\n        return False\n    MP = [[0]*W for i in range(H)]\n\n    S = [(i-2, i-2) for i in range(3)]\n    T = [(i-2, i-2) for i in range(3)]\n    for i in range(H):\n        s = readline().strip()\n        for j, c in enumerate(s):\n            if c == '#':\n                MP[i][j] = 1\n            elif c != ' ':\n                idx = \"abcABC\".find(c)\n                if idx < 3:\n                    S[idx] = (j, i)\n                else:\n                    T[idx-3] = (j, i)\n\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    que = deque([S[0] + (0,)])\n    MM = {S[0]: 0, (-1, -1): -2, (0, 0): -1}\n    sx, sy = S[0]\n    U = [[0]*W for i in range(H)]\n    U[sy][sx] = 1\n    G = [[0]]\n    cur = 1\n    while que:\n        x, y, v = que.popleft()\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if MP[ny][nx] or U[ny][nx]:\n                continue\n            U[ny][nx] = 1\n            MM[nx, ny] = cur\n            que.append((nx, ny, cur))\n            G.append([cur, v])\n            G[v].append(cur)\n            cur += 1\n    MM[-1, -1] = len(G); G.append([len(G)])\n    MM[0, 0] = len(G); G.append([len(G)])\n    a0 = MM[S[0]]; b0 = MM[S[1]]; c0 = MM[S[2]]\n    a1 = MM[T[0]]; b1 = MM[T[1]]; c1 = MM[T[2]]\n\n    L = cur+2\n    def check(s):\n        que = deque([s])\n        D = [-1]*L\n        D[s] = 0\n        while que:\n            v = que.popleft()\n            nd = D[v]+1\n            for w in G[v]:\n                if D[w] != -1:\n                    continue\n                D[w] = nd\n                que.append(w)\n        return D\n\n    D1 = check(a1); D2 = check(b1); D3 = check(c1)\n    INF = 10**18\n\n    hcost = max(D1[a0], D2[b0], D3[c0])\n    D = {(a0, b0, c0): 0}\n    que = [(hcost, 0, a0, b0, c0)]\n    g_key = (a1, b1, c1)\n    push = heappush; pop = heappop\n    while que:\n        hcost, cost, a, b, c = pop(que)\n        key = (a, b, c)\n        if key == g_key:\n            break\n        if D[key] < cost:\n            continue\n        nd = cost+1\n        for na in G[a]:\n            d1 = D1[na]\n            for nb in G[b]:\n                if na == nb or (nb == a and na == b):\n                    continue\n                d2 = D2[nb]\n                for nc in G[c]:\n                    if na == nc or nb == nc or (nc == a and na == c) or (nc == b and nb == c):\n                        continue\n                    n_key = (na, nb, nc)\n                    if nd < D.get(n_key, INF):\n                        D[n_key] = nd\n                        hcost = max(d1, d2, D3[nc]) + nd\n                        push(que, (hcost, nd, na, nb, nc))\n    write(\"%d\\n\" % D[g_key])\n    return True\nwhile solve():\n    ...\n"
  }
]