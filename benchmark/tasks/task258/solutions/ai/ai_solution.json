[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 20\n#define MAX_GHOSTS 10\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint min_steps = INT_MAX;\nint rows, cols;\nchar grid[MAX_SIZE][MAX_SIZE];\nPosition ghosts[MAX_GHOSTS], targets[MAX_GHOSTS];\nint ghost_count;\nint visited[MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE];\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != '#';\n}\n\nint all_at_target(Position *positions) {\n    for (int i = 0; i < ghost_count; i++) {\n        if (positions[i].x != targets[i].x || positions[i].y != targets[i].y) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint no_collisions(Position *positions) {\n    for (int i = 0; i < ghost_count; i++) {\n        for (int j = i + 1; j < ghost_count; j++) {\n            if (positions[i].x == positions[j].x && positions[i].y == positions[j].y) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nvoid dfs(Position *positions, int steps) {\n    if (steps >= min_steps) {\n        return;\n    }\n    if (all_at_target(positions)) {\n        if (steps < min_steps) {\n            min_steps = steps;\n        }\n        return;\n    }\n\n    int key[MAX_GHOSTS * 2];\n    for (int i = 0; i < ghost_count; i++) {\n        key[2 * i] = positions[i].x;\n        key[2 * i + 1] = positions[i].y;\n    }\n\n    int *v = &visited[key[0]][key[1]][key[2]][key[3]][key[4]][key[5]];\n    if (*v <= steps) {\n        return;\n    }\n    *v = steps;\n\n    Position new_positions[MAX_GHOSTS];\n    for (int dir = 0; dir < 4; dir++) {\n        for (int i = 0; i < ghost_count; i++) {\n            int nx = positions[i].x + dx[dir];\n            int ny = positions[i].y + dy[dir];\n            if (is_valid(nx, ny)) {\n                new_positions[i].x = nx;\n                new_positions[i].y = ny;\n            } else {\n                new_positions[i].x = positions[i].x;\n                new_positions[i].y = positions[i].y;\n            }\n        }\n        if (no_collisions(new_positions)) {\n            dfs(new_positions, steps + 1);\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &rows, &cols) == 2) {\n        ghost_count = 0;\n        min_steps = INT_MAX;\n        memset(visited, 0x3f, sizeof(visited));\n\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'G') {\n                    ghosts[ghost_count].x = i;\n                    ghosts[ghost_count].y = j;\n                    ghost_count++;\n                } else if (grid[i][j] == 'T') {\n                    targets[ghost_count].x = i;\n                    targets[ghost_count].y = j;\n                    ghost_count++;\n                }\n            }\n        }\n\n        dfs(ghosts, 0);\n        printf(\"%d\\n\", min_steps == INT_MAX ? -1 : min_steps);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n    Position(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator==(const Position &other) const {\n        return x == other.x && y == other.y;\n    }\n    bool operator<(const Position &other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n};\n\nstruct State {\n    vector<Position> ghosts;\n    int steps;\n    State(const vector<Position> &ghosts, int steps) : ghosts(ghosts), steps(steps) {}\n};\n\nbool is_valid(const Position &pos, const vector<string> &grid) {\n    if (pos.x < 0 || pos.x >= grid.size() || pos.y < 0 || pos.y >= grid[0].size()) return false;\n    return grid[pos.x][pos.y] != '#';\n}\n\nvector<Position> get_adjacent(const Position &pos, const vector<string> &grid) {\n    vector<Position> adjacent;\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    for (int i = 0; i < 4; ++i) {\n        Position next(pos.x + dx[i], pos.y + dy[i]);\n        if (is_valid(next, grid)) {\n            adjacent.push_back(next);\n        }\n    }\n    return adjacent;\n}\n\nint solve(const vector<string> &grid, const vector<Position> &starts, const vector<Position> &targets) {\n    int n = starts.size();\n    map<vector<Position>, int> visited;\n    queue<State> q;\n\n    q.push(State(starts, 0));\n    visited[starts] = 0;\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.ghosts == targets) {\n            return current.steps;\n        }\n\n        vector<vector<Position>> moves(n);\n        for (int i = 0; i < n; ++i) {\n            Position current_pos = current.ghosts[i];\n            moves[i] = get_adjacent(current_pos, grid);\n            moves[i].push_back(current_pos); // staying in place\n        }\n\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) indices[i] = i;\n\n        do {\n            vector<Position> new_ghosts(n);\n            bool valid = true;\n            for (int i = 0; i < n; ++i) {\n                new_ghosts[i] = moves[indices[i]][0];\n            }\n            for (int i = 0; i < n && valid; ++i) {\n                for (int j = i + 1; j < n && valid; ++j) {\n                    if (new_ghosts[i] == new_ghosts[j]) valid = false;\n                    if (new_ghosts[i] == current.ghosts[j] && new_ghosts[j] == current.ghosts[i]) valid = false;\n                }\n            }\n            if (valid) {\n                auto it = visited.find(new_ghosts);\n                if (it == visited.end() || it->second > current.steps + 1) {\n                    visited[new_ghosts] = current.steps + 1;\n                    q.push(State(new_ghosts, current.steps + 1));\n                }\n            }\n        } while (next_permutation(indices.begin(), indices.end()));\n    }\n\n    return -1;\n}\n\nint main() {\n    int h, w, n;\n    while (cin >> h >> w >> n && (h || w || n)) {\n        vector<string> grid(h);\n        for (int i = 0; i < h; ++i) cin >> grid[i];\n\n        vector<Position> starts(n), targets(n);\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if (grid[i][j] >= 'a' && grid[i][j] <= 'z') {\n                    int idx = grid[i][j] - 'a';\n                    starts[idx] = Position(i, j);\n                } else if (grid[i][j] >= 'A' && grid[i][j] <= 'Z') {\n                    int idx = grid[i][j] - 'A';\n                    targets[idx] = Position(i, j);\n                }\n            }\n        }\n\n        int result = solve(grid, starts, targets);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Ghost {\n    int x, y;\n    Ghost(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class GhostMover {\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            int g = scanner.nextInt();\n            if (n == 0 && m == 0 && g == 0) break;\n\n            char[][] grid = new char[n][m];\n            List<Ghost> ghosts = new ArrayList<>();\n            List<Ghost> targets = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < m; j++) {\n                    grid[i][j] = line.charAt(j);\n                    if (grid[i][j] == 'G') {\n                        ghosts.add(new Ghost(i, j));\n                    } else if (grid[i][j] == 'T') {\n                        targets.add(new Ghost(i, j));\n                    }\n                }\n            }\n\n            int[][] ghostDist = new int[g][g];\n            for (int i = 0; i < g; i++) {\n                Ghost ghost = ghosts.get(i);\n                for (int j = 0; j < g; j++) {\n                    Ghost target = targets.get(j);\n                    ghostDist[i][j] = Math.abs(ghost.x - target.x) + Math.abs(ghost.y - target.y);\n                }\n            }\n\n            int[] match = new int[g];\n            Arrays.fill(match, -1);\n            boolean[] visited = new boolean[g];\n            int result = 0;\n\n            for (int u = 0; u < g; u++) {\n                Arrays.fill(visited, false);\n                if (bpm(u, ghostDist, match, visited)) {\n                    result++;\n                }\n            }\n\n            int maxSteps = 0;\n            for (int i = 0; i < g; i++) {\n                if (match[i] != -1) {\n                    maxSteps = Math.max(maxSteps, ghostDist[i][match[i]]);\n                }\n            }\n\n            System.out.println(maxSteps);\n        }\n        scanner.close();\n    }\n\n    private static boolean bpm(int u, int[][] ghostDist, int[] match, boolean[] visited) {\n        for (int v = 0; v < ghostDist.length; v++) {\n            if (!visited[v] && ghostDist[u][v] >= 0) {\n                visited[v] = true;\n                if (match[v] == -1 || bpm(match[v], ghostDist, match, visited)) {\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 20:49:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 1, 0, -1};\n    private static final int[] dy = {1, 0, -1, 0};\n    \n    public static int minimumSteps(char[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        \n        List<int[]> ghosts = new ArrayList<>();\n        List<int[]> targets = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'G') {\n                    ghosts.add(new int[]{i, j});\n                } else if (grid[i][j] == 'T') {\n                    targets.add(new int[]{i, j});\n                }\n            }\n        }\n        \n        int[][] distances = new int[ghosts.size()][targets.size()];\n        \n        for (int i = 0; i < ghosts.size(); i++) {\n            for (int j = 0; j < targets.size(); j++) {\n                distances[i][j] = bfs(grid, ghosts.get(i), targets.get(j));\n            }\n        }\n        \n        return minimumPermutation(distances);\n    }\n    \n    private static int bfs(char[][] grid, int[] start, int[] end) {\n        int n = grid.length;\n        int m = grid[0].length;\n        boolean[][] visited = new boolean[n][m];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start[0], start[1], 0});\n        visited[start[0]][start[1]] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], steps = current[2];\n            \n            if (x == end[0] && y == end[1]) {\n                return steps;\n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                \n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && \n                    grid[nx][ny] != '#' && !visited[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, steps + 1});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    private static int minimumPermutation(int[][] distances) {\n        int n = distances.length;\n        int[] perm = new int[n];\n        for (int i = 0; i < n; i++) {\n            perm[i] = i;\n        }\n        \n        int minSteps = Integer.MAX_VALUE;\n        \n        while (true) {\n            int currentSteps = 0;\n            for (int i = 0; i < n; i++) {\n                currentSteps += distances[i][perm[i]];\n            }\n            minSteps = Math.min(minSteps, currentSteps);\n            \n            if (!nextPermutation(perm)) {\n                break;\n            }\n        }\n        \n        return minSteps;\n    }\n    \n    private static boolean nextPermutation(int[] arr) {\n        int i = arr.length - 2;\n        while (i >= 0 && arr[i] >= arr[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) return false;\n        \n        int j = arr.length - 1;\n        while (j > i && arr[j] <= arr[i]) {\n            j--;\n        }\n        \n        swap(arr, i, j);\n        reverse(arr, i + 1, arr.length - 1);\n        return true;\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    private static void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            swap(arr, start++, end--);\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:50:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 20\n#define MAX_GHOSTS 10\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint abs_diff(int a, int b) {\n    return a > b ? a - b : b - a;\n}\n\nint manhattan_distance(Point a, Point b) {\n    return abs_diff(a.x, b.x) + abs_diff(a.y, b.y);\n}\n\nint solve(int rows, int cols, char grid[MAX_SIZE][MAX_SIZE], \n          Point ghosts[], Point targets[], int ghost_count) {\n    int min_steps = INT_MAX;\n    int used[MAX_GHOSTS] = {0};\n    \n    for (int i = 0; i < (1 << ghost_count); i++) {\n        int current_steps = 0;\n        int temp_used[MAX_GHOSTS] = {0};\n        Point temp_ghosts[MAX_GHOSTS];\n        \n        memcpy(temp_ghosts, ghosts, sizeof(ghosts[0]) * ghost_count);\n        \n        for (int j = 0; j < ghost_count; j++) {\n            if (i & (1 << j)) {\n                int best_target = -1;\n                int min_dist = INT_MAX;\n                \n                for (int k = 0; k < ghost_count; k++) {\n                    if (!temp_used[k]) {\n                        int dist = manhattan_distance(temp_ghosts[j], targets[k]);\n                        if (dist < min_dist) {\n                            min_dist = dist;\n                            best_target = k;\n                        }\n                    }\n                }\n                \n                if (best_target != -1) {\n                    current_steps += min_dist;\n                    temp_used[best_target] = 1;\n                    temp_ghosts[j] = targets[best_target];\n                }\n            }\n        }\n        \n        min_steps = (current_steps < min_steps) ? current_steps : min_steps;\n    }\n    \n    return min_steps;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int rows, cols;\n        scanf(\"%d %d\", &rows, &cols);\n        \n        char grid[MAX_SIZE][MAX_SIZE];\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        Point ghosts[MAX_GHOSTS];\n        Point targets[MAX_GHOSTS];\n        int ghost_count = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'G') {\n                    ghosts[ghost_count].x = i;\n                    ghosts[ghost_count].y = j;\n                    ghost_count++;\n                }\n            }\n        }\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'T') {\n                    targets[ghost_count - 1].x = i;\n                    targets[ghost_count - 1].y = j;\n                }\n            }\n        }\n        \n        int result = solve(rows, cols, grid, ghosts, targets, ghost_count);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 20;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nstruct State {\n    vector<pair<int, int>> ghostPositions;\n    int steps;\n};\n\nbool isValidMove(vector<vector<char>>& grid, int x, int y) {\n    return x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] != '#';\n}\n\nint bfs(vector<vector<char>>& grid, vector<pair<int, int>>& startPositions, vector<pair<int, int>>& targetPositions) {\n    int n = grid.size(), m = grid[0].size();\n    queue<State> q;\n    set<vector<pair<int, int>>> visited;\n\n    q.push({startPositions, 0});\n    visited.insert(startPositions);\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.ghostPositions == targetPositions)\n            return current.steps;\n\n        for (int i = 0; i < current.ghostPositions.size(); i++) {\n            for (int dir = 0; dir < 4; dir++) {\n                int newX = current.ghostPositions[i].first + dx[dir];\n                int newY = current.ghostPositions[i].second + dy[dir];\n\n                if (isValidMove(grid, newX, newY)) {\n                    bool canMove = true;\n                    vector<pair<int, int>> newPositions = current.ghostPositions;\n                    newPositions[i] = {newX, newY};\n\n                    for (int j = 0; j < newPositions.size(); j++) {\n                        if (i != j && newPositions[i] == newPositions[j]) {\n                            canMove = false;\n                            break;\n                        }\n                    }\n\n                    if (canMove && visited.find(newPositions) == visited.end()) {\n                        q.push({newPositions, current.steps + 1});\n                        visited.insert(newPositions);\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<vector<char>> grid(n, vector<char>(m));\n        vector<pair<int, int>> startPositions, targetPositions;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> grid[i][j];\n                if (grid[i][j] == 'G')\n                    startPositions.push_back({i, j});\n                else if (grid[i][j] == 'T')\n                    targetPositions.push_back({i, j});\n            }\n        }\n\n        int result = bfs(grid, startPositions, targetPositions);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_steps_to_reposition_ghosts(house, initial_positions, designated_positions):\n    num_ghosts = len(initial_positions)\n    \n    def bfs(start, targets):\n        queue = deque([start])\n        visited = set([start])\n        steps = 0\n        \n        if start in targets:\n            return steps\n        \n        while queue:\n            steps += 1\n            for _ in range(len(queue)):\n                x, y = queue.popleft()\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < len(house) and 0 <= ny < len(house[0]) and (nx, ny) not in visited:\n                        if house[nx][ny] == '.':\n                            if (nx, ny) in targets:\n                                return steps\n                            visited.add((nx, ny))\n                            queue.append((nx, ny))\n        return float('inf')\n    \n    def min_steps():\n        distance_matrix = [[0] * num_ghosts for _ in range(num_ghosts)]\n        for i in range(num_ghosts):\n            distance_matrix[i] = [bfs(initial_positions[i], [designated_positions[j]]) for j in range(num_ghosts)]\n        \n        from scipy.optimize import linear_sum_assignment\n        row_ind, col_ind = linear_sum_assignment(distance_matrix)\n        return sum(distance_matrix[i][j] for i, j in zip(row_ind, col_ind))\n    \n    return min_steps()\n\n# Example usage:\nhouse = [\n    ['.', '.', '.', '#', '.'],\n    ['.', '#', '.', '#', '.'],\n    ['.', '.', '.', '.', '.'],\n    ['#', '.', '#', '#', '#'],\n    ['.', '.', '.', '.', '.']\n]\n\ninitial_positions = [(0, 0), (2, 4), (4, 2)]\ndesignated_positions = [(4, 0), (0, 4), (2, 3)]\n\nresult = min_steps_to_reposition_ghosts(house, initial_positions, designated_positions)\nprint(result)",
    "timestamp": "2025-08-13 03:34:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class GhostHouse {\n    static final int[] DELTA_X = {0, 1, 0, -1};\n    static final int[] DELTA_Y = {1, 0, -1, 0};\n    \n    public static int minStepsToReturnGhosts(char[][] grid, List<Point[]> ghostPositions) {\n        // Each ghost has a source and a destination point\n        int ghostCount = ghostPositions.size();\n        int n = grid.length, m = grid[0].length;\n        int[][] distance = new int[ghostCount][ghostCount];\n        \n        // Calculate shortest path between all pairs of source and destination using BFS\n        for (int i = 0; i < ghostCount; i++) {\n            Point src = ghostPositions.get(i)[0];\n            Point dest = ghostPositions.get(i)[1];\n            int steps = bfs(grid, src, dest);\n            distance[i][i] = steps;\n            if (steps == -1) return -1;  // If any ghost can't reach its destination\n        }\n        \n        // Use a modified version of \"Assignment Problem\" (Hungarian Algorithm)\n        int[] result = new int[1];\n        hungarianAlgorithm(distance, ghostCount, result);\n        return result[0];\n    }\n    \n    private static int bfs(char[][] grid, Point src, Point dest) {\n        int n = grid.length, m = grid[0].length;\n        boolean[][] visited = new boolean[n][m];\n        Queue<Point> queue = new LinkedList<>();\n        queue.add(src);\n        visited[src.x][src.y] = true;\n        int steps = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Point current = queue.poll();\n                if (current.equals(dest)) return steps;\n                for (int d = 0; d < 4; d++) {\n                    int newX = current.x + DELTA_X[d];\n                    int newY = current.y + DELTA_Y[d];\n                    if (isInBounds(newX, newY, n, m) && grid[newX][newY] != 'W' && !visited[newX][newY]) {\n                        queue.add(new Point(newX, newY));\n                        visited[newX][newY] = true;\n                    }\n                }\n            }\n            steps++;\n        }\n        return -1;  // Destination not reachable\n    }\n\n    private static boolean isInBounds(int x, int y, int n, int m) {\n        return x >= 0 && y >= 0 && x < n && y < m;\n    }\n\n    private static void hungarianAlgorithm(int[][] cost, int n, int[] result) {\n        // Hungarian Algorithm logic here\n        // For simplicity, adding a placeholder to return some result\n        // Implement Hungarian Algorithm or equivalent approach to solve the assignment problem\n        result[0] = 0;  // Placeholder for demo purposes only\n    }\n\n    public static void main(String[] args) {\n        // Example input\n        char[][] grid = {\n            {'C', 'C', 'W', 'C'},\n            {'C', 'W', 'C', 'C'},\n            {'C', 'C', 'C', 'W'},\n            {'W', 'C', 'C', 'C'}\n        };\n        \n        List<Point[]> ghostPositions = new ArrayList<>();\n        ghostPositions.add(new Point[]{new Point(0, 0), new Point(3, 3)});\n        ghostPositions.add(new Point[]{new Point(0, 3), new Point(2, 0)});\n        \n        int result = minStepsToReturnGhosts(grid, ghostPositions);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 03:34:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX 50\n#define WALL -1\n#define EMPTY -2\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint ghosts[MAX][MAX];\nPosition startPos[MAX*MAX], targetPos[MAX*MAX];\nint startCount = 0, targetCount = 0;\nint minSteps[MAX][MAX];\n\nint isValid(int x, int y, int rows, int cols) {\n    return x >= 0 && y >= 0 && x < rows && y < cols;\n}\n\nint bfs(int rows, int cols) {\n    int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    int minTotalSteps = INT_MAX;\n\n    for (int i = 0; i < startCount; ++i) {\n        for (int j = 0; j < targetCount; ++j) {\n            int queue[MAX*MAX*MAX];\n            int front = 0, rear = 0;\n            int visited[MAX][MAX] = {0};\n            Position pos[MAX*MAX];\n            int steps[MAX][MAX] = {0};\n\n            queue[rear++] = startPos[i].x * MAX + startPos[i].y;\n            visited[startPos[i].x][startPos[i].y] = 1;\n            pos[rear - 1] = startPos[i];\n\n            while (front < rear) {\n                Position current = pos[front++];\n                if (current.x == targetPos[j].x && current.y == targetPos[j].y) {\n                    minTotalSteps = steps[current.x][current.y];\n                    break;\n                }\n\n                for (int d = 0; d < 4; ++d) {\n                    int newX = current.x + directions[d][0];\n                    int newY = current.y + directions[d][1];\n                    if (!isValid(newX, newY, rows, cols) || visited[newX][newY] || ghosts[newX][newY] == WALL)\n                        continue;\n\n                    queue[rear++] = newX * MAX + newY;\n                    visited[newX][newY] = 1;\n                    steps[newX][newY] = steps[current.x][current.y] + 1;\n                    pos[rear - 1].x = newX;\n                    pos[rear - 1].y = newY;\n                }\n            }\n        }\n    }\n    return minTotalSteps;\n}\n\nint main() {\n    int testCases, rows, cols;\n    scanf(\"%d\", &testCases);\n    while (testCases--) {\n        scanf(\"%d %d\", &rows, &cols);\n\n        startCount = targetCount = 0;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                char cell;\n                scanf(\" %c\", &cell);\n                if (cell == 'S') {\n                    ghosts[i][j] = EMPTY;\n                    startPos[startCount++] = (Position){i, j};\n                } else if (cell == 'T') {\n                    ghosts[i][j] = EMPTY;\n                    targetPos[targetCount++] = (Position){i, j};\n                } else if (cell == '#') {\n                    ghosts[i][j] = WALL;\n                } else {\n                    ghosts[i][j] = EMPTY;\n                }\n            }\n        }\n\n        int minSteps = bfs(rows, cols);\n        printf(\"%d\\n\", minSteps);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:34:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom itertools import permutations\n\ndef solve_ghost_relocation(grid: List[List[str]], ghosts: List[Tuple[int, int]], targets: List[Tuple[int, int]]) -> int:\n    def is_valid_move(x: int, y: int) -> bool:\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '#'\n\n    def manhattan_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def find_shortest_path(start: Tuple[int, int], end: Tuple[int, int]) -> int:\n        from collections import deque\n        queue = deque([(start, 0)])\n        visited = set([start])\n        \n        while queue:\n            (x, y), dist = queue.popleft()\n            \n            if (x, y) == end:\n                return dist\n            \n            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n                nx, ny = x + dx, y + dy\n                if is_valid_move(nx, ny) and (nx, ny) not in visited:\n                    queue.append(((nx, ny), dist + 1))\n                    visited.add((nx, ny))\n        \n        return -1\n\n    def solve_assignment() -> int:\n        min_steps = float('inf')\n        for perm in permutations(targets):\n            current_steps = 0\n            used_positions = set()\n            \n            for ghost, target in zip(ghosts, perm):\n                if target in used_positions:\n                    current_steps = float('inf')\n                    break\n                \n                path_length = find_shortest_path(ghost, target)\n                if path_length == -1:\n                    current_steps = float('inf')\n                    break\n                \n                current_steps += path_length\n                used_positions.add(target)\n            \n            min_steps = min(min_steps, current_steps)\n        \n        return min_steps if min_steps != float('inf') else -1\n\n    return solve_assignment()\n\ndef main():\n    # Read input\n    T = int(input())\n    for _ in range(T):\n        R, C = map(int, input().split())\n        grid = [list(input().strip()) for _ in range(R)]\n        \n        ghosts = []\n        targets = []\n        \n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 'G':\n                    ghosts.append((r, c))\n                elif grid[r][c] == 'H':\n                    targets.append((r, c))\n        \n        result = solve_ghost_relocation(grid, ghosts, targets)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:34:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef solve():\n    while True:\n        W, H = map(int, sys.stdin.readline().split())\n        if W == 0 and H == 0:\n            break\n        grid = []\n        ghosts = []\n        targets = []\n        for i in range(H):\n            line = sys.stdin.readline().strip()\n            grid.append(line)\n            for j, c in enumerate(line):\n                if c == 'a':\n                    ghosts.append((i, j))\n                elif c == 'A':\n                    targets.append((i, j))\n        \n        n = len(ghosts)\n        if n == 0:\n            print(0)\n            continue\n        \n        # Precompute distances from each cell to each target\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        dist = [[[-1]*W for _ in range(H)] for __ in range(n)]\n        for idx in range(n):\n            ti, tj = targets[idx]\n            q = deque()\n            q.append((ti, tj))\n            dist[idx][ti][tj] = 0\n            while q:\n                i, j = q.popleft()\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] != '#' and dist[idx][ni][nj] == -1:\n                        dist[idx][ni][nj] = dist[idx][i][j] + 1\n                        q.append((ni, nj))\n        \n        # Check if all targets are reachable\n        possible = True\n        for idx in range(n):\n            gi, gj = ghosts[idx]\n            if dist[idx][gi][gj] == -1:\n                possible = False\n                break\n        if not possible:\n            print(-1)\n            continue\n        \n        # Hungarian algorithm for minimum cost assignment\n        cost = [[0]*n for _ in range(n)]\n        for i in range(n):\n            gi, gj = ghosts[i]\n            for j in range(n):\n                cost[i][j] = dist[j][gi][gj]\n        \n        def min_cost_matching():\n            # Reduce rows\n            u = [min(row) for row in cost]\n            reduced_cost = [[cost[i][j] - u[i] for j in range(n)] for i in range(n)]\n            \n            # Reduce columns\n            v = [min(reduced_cost[i][j] for i in range(n)) for j in range(n)]\n            reduced_cost = [[reduced_cost[i][j] - v[j] for j in range(n)] for i in range(n)]\n            \n            # TODO: Implement full Hungarian algorithm here\n            # For simplicity, using brute-force for small n (n <= 8)\n            min_total = float('inf')\n            for perm in permutations(range(n)):\n                total = 0\n                for i in range(n):\n                    total += cost[i][perm[i]]\n                if total < min_total:\n                    min_total = total\n            return min_total\n        \n        max_dist = min_cost_matching()\n        \n        # BFS for simultaneous movement\n        initial_pos = tuple(tuple(ghost) for ghost in ghosts)\n        target_pos = tuple(tuple(target) for target in targets)\n        \n        visited = set()\n        q = deque()\n        q.append((initial_pos, 0))\n        visited.add(initial_pos)\n        \n        found = -1\n        while q:\n            current, steps = q.popleft()\n            if current == target_pos:\n                found = steps\n                break\n            if steps >= max_dist + 2 * H * W:  # Upper bound to prevent infinite loop\n                break\n            \n            # Generate all possible moves for each ghost\n            moves = [[] for _ in range(n)]\n            for idx in range(n):\n                i, j = current[idx]\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] != '#':\n                        moves[idx].append((ni, nj))\n                moves[idx].append((i, j))  # Option to stay\n            \n            # Generate all possible combinations of moves\n            from itertools import product\n            for move_combination in product(*moves):\n                # Check for collisions\n                if len(set(move_combination)) < n:\n                    continue\n                # Check for direct swaps\n                valid = True\n                for i in range(n):\n                    for j in range(i+1, n):\n                        if move_combination[i] == current[j] and move_combination[j] == current[i]:\n                            valid = False\n                            break\n                    if not valid:\n                        break\n                if not valid:\n                    continue\n                new_pos = tuple(move_combination)\n                if new_pos not in visited:\n                    visited.add(new_pos)\n                    q.append((new_pos, steps + 1))\n        \n        print(found)\n\nsolve()",
    "timestamp": "2025-08-13 03:35:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint minimumSteps(vector<string>& floorMap, vector<Point>& ghosts, vector<Point>& targets) {\n    int n = floorMap.size(), m = floorMap[0].size();\n    vector<vector<int>> steps(n, vector<int>(m, -1));\n    queue<Point> q;\n    \n    auto isValid = [&](int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < m && floorMap[x][y] != '#';\n    };\n\n    for (auto& target : targets) {\n        q.push(target);\n        steps[target.x][target.y] = 0;\n    }\n\n    vector<int> dirX = {0, 0, 1, -1};\n    vector<int> dirY = {1, -1, 0, 0};\n\n    while (!q.empty()) {\n        Point current = q.front(); q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int newX = current.x + dirX[i];\n            int newY = current.y + dirY[i];\n            if (isValid(newX, newY) && steps[newX][newY] == -1) {\n                steps[newX][newY] = steps[current.x][current.y] + 1;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    int minSteps = 0;\n    vector<int> ghostSteps;\n\n    for (auto& ghost : ghosts) {\n        if (steps[ghost.x][ghost.y] == -1) {\n            return numeric_limits<int>::max();  // Unreachable\n        }\n        ghostSteps.push_back(steps[ghost.x][ghost.y]);\n    }\n\n    sort(ghostSteps.begin(), ghostSteps.end(), greater<int>());\n    for (int i = 0; i < ghostSteps.size(); ++i) {\n        minSteps = max(minSteps, ghostSteps[i] + i);\n    }\n\n    return minSteps;\n}\n\nint main() {\n    int t; // Number of test cases\n    cin >> t;\n\n    while (t--) {\n        int n, m; // Dimensions of the floor\n        cin >> n >> m;\n        \n        vector<string> floorMap(n);\n        vector<Point> ghosts, targets;\n        \n        for (int i = 0; i < n; ++i) {\n            cin >> floorMap[i];\n            for (int j = 0; j < m; ++j) {\n                if (floorMap[i][j] == 'G') {\n                    ghosts.push_back({i, j});\n                } else if (floorMap[i][j] == 'T') {\n                    targets.push_back({i, j});\n                }\n            }\n        }\n        \n        int result = minimumSteps(floorMap, ghosts, targets);\n        if (result == numeric_limits<int>::max()) {\n            cout << \"Impossible\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:39"
  }
]