[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nvector <int> dv;\nvector <int> av;\nvector <int> bv;\nint mn, mx;\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nvoid reconstruct(int x1, int y1, int c1, int x2, int y2, int c2) {\n  puts(\"Possible\");\n  cerr << x1 << \" \" << y1 << \" \" << c1 << \" \" << x2 << \" \" << y2 << \" \" << c2 << endl;\n  int mxX = max(x1, x2);\n  int mxY = max(y1, y2);\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= mxX; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= mxY; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  addEdge(2 + x1, n - 1 - y1, c1);\n\n  if (x2 != -1) {\n    addEdge(2 + x2, n - 1 - y2, c2);\n  }\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  exit(0);\n}\n\nvoid go(int x1, int y1, int c1, int pos) {\n  if (pos == sz(dv)) {\n    reconstruct(x1, y1, c1, -1, -1, -1);\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 == dv[pos] || dv[pos] == mx) {\n    go(x1, y1, c1, pos + 1);\n  }\n  for (int x2 = 0; x2 <= 100; x2++) {\n    if (av[pos] * x2 > dv[pos]) {\n      continue;\n    }\n    for (int y2 = 0; y2 <= 100; y2++) {\n      if (av[pos] * x2 + bv[pos] * y2 > dv[pos]) {\n        continue;\n      }\n      if (x2 == 0 && y2 == 0 && dv[pos] != mx) {\n        continue;\n      }\n      int c2 = dv[pos] - (av[pos] * x2 + bv[pos] * y2);\n      bool good = true;\n      for (int i = pos; i < sz(dv); i++) {\n        if (!(x2 * av[i] + y2 * bv[i] + c2 == dv[i] || \n              x1 * av[i] + y1 * bv[i] + c1 == dv[i] ||\n              dv[i] == mx)) {\n          good = false;\n          break;\n        }\n        if (x1 * av[i] + y1 * bv[i] + c1 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      for (int i = 0; i < pos; i++) {\n        if (x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        reconstruct(x1, y1, c1, x2, y2, c2);\n      }\n    }\n  }\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  mx = -1, mn = 105;\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n      mn = min(mn, d[i][j]);\n      mx = max(mx, d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      if (j > 0 && d[i][j] < d[i][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n      if (i > 0 && d[i][j] < d[i - 1][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  if (mn == mx) {\n    puts(\"Possible\");\n    cout << 2 << \" \" << 1 << endl;\n    cout << 1 << \" \" << 2 << \" \" << mx << endl;\n    cout << 1 << \" \" << 2 << endl;\n    return 0;\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      dv.push_back(d[i][j]);\n      av.push_back(i + 1);\n      bv.push_back(j + 1);\n    }\n  }\n\n  for (int x1 = 0; x1 <= 100; x1++) {\n    if (1 * x1 > d[0][0]) {\n      continue;\n    }\n    for (int y1 = 0; y1 <= 100; y1++) {\n      if (1 * x1 + 1 * y1 > d[0][0]) {\n        continue;\n      }\n      if (x1 == 0 && y1 == 0 && d[0][0] != mx) {\n        continue;\n      }\n      int c1 = d[0][0] - x1 - y1;\n      go(x1, y1, c1, 0);\n    }\n  }\n\n  puts(\"Impossible\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\nclass GRAPH \n{\n\tpublic:\n\t\tint to[MAXM],next[MAXM],weight[MAXM];\n\t\tint head[MAXN];\n\t\tint cnt;\n\t\t\n\tGRAPH()\n\t{\n\t\tcnt=1;\n\t} \n\t\n\tvoid add(int x,int y,int z)\n\t{\n\t\tnext[cnt]=head[x];\n\t\tweight[cnt]=z;\n\t\tto[cnt]=y;\n\t\thead[x]=cnt++;\n\t}\n};\n\nGRAPH g;\n\nint n,m;\nint a[12][12],b[12][12],c[12][12];\n\nint main()\n{\n\t//WRT(ceil(111.0));\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tDRPT(k,n,i)\n\t\t\t\ta[i][j]=max(a[i][j],(int)ceil(((DB)c[k][j]-c[i][j])/(k-i)));\n\t\t\tDRPT(k,i-1,-1)\n\t\t\t\tif (ceil(((DB)c[k][j]-c[i][j])/(k-i))<a[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\n\t\t\tDRPT(k,m,j)\n\t\t\t\tb[i][j]=max(b[i][j],(int)ceil(((DB)c[i][k]-c[i][j])/(k-j)));\n\t\t\tDRPT(k,j-1,-1)\n\t\t\t\tif (ceil(((DB)c[i][k]-c[i][j])/(k-j))<b[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t}\n\t//RPT(i,1,n+1)\n\t//\tRPT(j,1,m+1)\n\t//\t\tcout<<i<<' '<<j<<' '<<a[i][j]<<' '<<b[i][j]<<endl;\n\tcout<<\"Possible\"<<endl;\n\tcout<<200<<' '<<198+m*n<<endl;\n\tRPT(i,1,100)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,101,200)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tcout<<a[i][j]+1<<' '<<b[i][j]+101<<' '<<c[i][j]-i*a[i][j]-j*b[i][j]<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define Fordown(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n\tint x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nint main () {\n\tputs(\"Impossible\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 301\nll d[N][N];\nll g[M+10][M+10];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif((g[x][y]!=-1)||(c<0||c>100)||x<0||y<0){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#define LL long long\n#define Re register int\nusing namespace std;\nconst int N=103,M=13;\nint n,m,d[13][13],f[103][103];\ninline void in(Re &x){\n    int f=0;x=0;char c=getchar();\n    while(c<'0'||c>'9')f|=c=='-',c=getchar();\n    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    x=f?-x:x;\n}\nint main(){\n//\tfreopen(\"123.txt\",\"r\",stdin);\n\tin(n),in(m);\n\tfor(Re i=1;i<=n;++i)\n\t\tfor(Re j=1;j<=n;++j)\n\t\t\tin(d[i][j]);\n\tfor(Re i=0;i<=100;++i)\n\t\tfor(Re j=0;j<=100;++j)\n\t\t\tfor(Re x=1;x<=n;++x)\n\t\t\t\tfor(Re y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(Re x=1;x<=n;++x)\n\t\tfor(Re y=1;y<=m;++y){\n\t\t\tRe dis=2e9;\n\t\t\tfor(Re i=0;i<=100;++i)\n\t\t\t\tfor(Re j=0;j<=100;++j)\n\t\t\t\t\tdis=min(dis,f[i][j]+i*x+j*y);\n\t\t\tif(dis!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n    for(Re i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n    for(Re i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n    for(Re i=0;i<=100;i++)\n        for(Re j=0;j<=100;j++)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    puts(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N], ox[N], oy[N], m;\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tif (f[i][j] >= 0) ox[++m] = i, oy[m] = j;\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\", 200 + m);\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d %d %d\\n\", ox[i] ? ox[i] : 201, oy[i] ? 100 + oy[i] : 202,\n\t\t\t   f[ox[i]][oy[i]]);\n\tputs(\"201 202\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 110\n#define N 100\n#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)\nint d[M][M], f[M][M];\nint main() {\n\tcin.tie(0);\n\tint n, m; cin >> n >> m;\n\trep(i, 1, n) rep(j, 1, m) {\n\t\tcin >> d[i][j];\n\t}\n\trep(i, 0, N) rep(j, 0, N) {\n\t\tf[i][j] = 0;\n\t\trep(k, 1, n) rep(w, 1, m) {\n\t\t\tf[i][j] = max(f[i][j], d[k][w] - i * k - j * w);\n\t\t}\n\t}\n\trep(i, 1, n) rep(j, 1, m) {\n\t\tint t = 1000;\n\t\trep(k, 0, N) rep(w, 0, N) {\n\t\t\tt = min(t, f[k][w] + i * k + j * w);\n\t\t}\n\t\tif(t != d[i][j]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", N + N + 2, N + N + (N + 1) * (N + 1));\n\trep(i, 1, N) {\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\t}\n\trep(i, 0, N) rep(j, 0, N) {\n\t\tprintf(\"%d %d %d\\n\", i + 1, N + N + 2 - j, f[i][j]);\n\t}\n\tprintf(\"1 %d\\n\", N + N + 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint d[11][11];\nint mx[110][110];\n\nint main() {\n\tint A,B;\n\tscanf(\"%d %d\", &A, &B);\n\tfor (int i=1;i<=A;i++) {\n\t\tfor (int j=1;j<=B;j++) {\n\t\t\tscanf(\"%d\", &d[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t// x간선 i개, y간선 j개\n\t\t\t\n\t\t\tfor (int x = 1; x <= A; x++) {\n\t\t\t\tfor (int y = 1; y <= B; y++) {\n\t\t\t\t\tmx[i][j] = max(mx[i][j], d[x][y] - x*i - y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tfor (int x = 1; x <= A; x++) {\n\t\tfor (int y = 1; y <= B; y++) {\n\n\t\t\tint mi = 100 + 1;\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tmi = min(mi, mx[i][j] + x*i + y*j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mi != d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvector<int> a, b;\n\tfor(int i=1;i<=101;i++)\n\t\ta.push_back(i);\n\tfor(int i=102;i<=202;i++)\n\t\tb.push_back(i);\n\n\tint n, m;\n\tn = 202;\n\tm = 100*2 + 101*101;\n\tint S = a[0], T = b.back();\n\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < 100; i++) {\n\t\tprintf(\"%d %d X\\n\", a[i], a[i+1]);\n\t\tprintf(\"%d %d Y\\n\", b[i], b[i+1]);\n\t}\n\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tprintf(\"%d %d %d\\n\", a[i], b[j], mx[i][100-j]);\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", S, T);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx=0,idy=0;\n\t\trep0(x,101) rep0(y,101){\n\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\tidx=i,idy=j;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tadd(idx,idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    REP(i,N-1) cout << 299-i << \" \" << 300-i << \" Y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint A, B;\n\tcin >> A >> B;\n\tvector<vector<int> >d(A + 1, vector<int>(B + 1, 0));\n\tvector<vector<int> >noneed(A + 1, vector<int>(B + 1, 0));\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool f;\n\tint mn = 100;\n\tint sc = 0;\n\tint xx, yy;\n\tint xmax = 0;\n\tbool ok = true;\n\tvector<pair<pair<int, int>, int> > vp;\n\tfor (int a = 1; a <= A; a++) {\n\t\tfor (int b = 1; b <= B; b++) {\n\t\t\tif (noneed[a][b] == 0) {\n\t\t\t\txx = -1;\n\t\t\t\tmn = 10000;\n\t\t\t\tfor (int x = 0; x <= 100; x++) {\n\t\t\t\t\tfor (int y = 0; y <= 100; y++) {\n\t\t\t\t\t\tint z = d[a][b] - x*a - y*b;\n\t\t\t\t\t\tif (z < 0)break;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tsc = 0;\n\t\t\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\t\t\tif (d[a2][b2] > x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (noneed[a2][b2] == 0 && d[a2][b2] == x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\t\tsc--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tif (mn > sc) {\n\t\t\t\t\t\t\t\tmn = sc;\n\t\t\t\t\t\t\t\txx = x;\n\t\t\t\t\t\t\t\tyy = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (xx == -1) {\n\t\t\t\t\tcerr << a << \" \" << b << endl;\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\tif (d[a2][b2] == xx*a2 + yy*b2 + d[a][b] - xx*a - yy*b) {\n\t\t\t\t\t\t\tnoneed[a2][b2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txmax = max(xx, xmax);\n\t\t\t\tvp.push_back(make_pair(make_pair(xx, yy), d[a][b] - xx*a - yy*b));\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif (ok) {\n\t\tint v = 0;\n\t\tsort(vp.begin(), vp.end());\n\t\tvector<int> ymax(xmax + 1, -1);\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\tymax[vp[i].first.first] = max(ymax[vp[i].first.first], vp[i].first.second);\n\t\t\t//cerr << vp[i].first.first << \" \" << vp[i].first.second << \" \" << vp[i].second << endl;\n\t\t}\n\t\tmap<pair<int, int>, int> mp;\n\t\tvector<pair<pair<int, int>, int> >ed;\n\t\tmp[make_pair(0, 0)] = 0;\n\t\tfor (int i = 0; i < xmax; i++) {\n\t\t\tv++;\n\t\t\ted.push_back(make_pair(make_pair(v, v - 1), -1));\n\t\t\tmp[make_pair(v, 0)] = v;\n\t\t}\n\t\tfor (int i = 0; i <= xmax; i++) {\n\t\t\tfor (int j = 0; j < ymax[i]; j++) {\n\t\t\t\tv++;\n\t\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(i, j)], v), -2));\n\t\t\t\tmp[make_pair(i, j + 1)] = v;\n\t\t\t}\n\t\t}\n\t\tv++;\n\t\tint fc = v;\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(vp[i].first.first, vp[i].first.second)], fc), vp[i].second));\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\n\t\tcout << fc + 1 << \" \" << (int)ed.size() << endl;\n\t\tfor (int i = 0; i < ed.size(); i++) {\n\t\t\tcout << ed[i].first.first + 1 << \" \" << ed[i].first.second + 1 << \" \";\n\t\t\tif (ed[i].second == -1) {\n\t\t\t\tcout << \"X\" << endl;\n\t\t\t}\n\t\t\telse if (ed[i].second == -2) {\n\t\t\t\tcout << \"Y\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << ed[i].second << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << \" \" << fc + 1 << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N], ox[N], oy[N], m;\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tf[i][j] = 0;\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tif (f[i][j]) ox[++m] = i, oy[m] = j;\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"200 %d\\n\", 200 + m);\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d %d %d\\n\", ox[i] ? ox[i] : 201, oy[i] ? 100 + oy[i] : 202,\n\t\t\t   f[ox[i]][oy[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  rep(l, 101) rep(m, 101) {\n    reps(x, 1, a+1) reps(y, 1, b+1) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) chmin(e, l*x+m*y+n[l][m]);\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << \" \" <<  'Y' << endl;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl;\n  cout << 1 << \" \" << 102 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint G[11][11], a[11][11], b[11][11];\n\nint main(void)\n{\n    int A, B, ok = 1;\n    scanf(\"%d %d\", &A, &B);\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            scanf(\"%d\", &G[i][j]);\n    for(int i = 1; i <= A; i++)\n    for(int j = 1; j <= B; j++)\n    {\n        int ma = 0, mb = 0;\n        for(int k = i + 1; k <= A; k++)\n        {\n            if(G[k][j] < G[i][j]) ok = 0;\n            ma = max(ma, (G[k][j] - G[i][j] + k - i - 1) / (k - i));\n        }\n        for(int k = j + 1; k <= B; k++)\n        {\n            if(G[i][k] < G[i][j]) ok = 0;\n            mb = max(mb, (G[i][k] - G[i][j] + k - j - 1) / (k - j));\n        }\n        if(i * ma + j * mb > G[i][j]) ok = 0;\n        else a[i][j] = ma, b[i][j] = mb;\n    }\n    if(!ok) puts(\"Impossible\");\n    else\n    {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 200 + A * B, 198 + 2 * A * B);\n        for(int i = 1; i < 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n        for(int i = 101; i < 200; i++) printf(\"%d %d Y\\n\", i, i + 1);\n        for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n        printf(\"%d %d %d\\n%d %d %d\\n\", a[i][j] + 1, 200 + (i - 1) * B + j, 0, 200 + (i - 1) * B + j, 200 - b[i][j], G[i][j] - i * a[i][j] - j * b[i][j]);\n        printf(\"1 100\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nconst int N = 11;\n\nint a, b, d[N][N], delta[101][101];\nbool ok[N][N];\n\nint main()\n{\n    scanf(\"%d%d\", &a, &b);\n    int cnt = 0, left = a * b;\n    for (int i = 1; i <= a; ++ i) {\n        for (int j = 1; j <= b; ++ j) {\n            scanf(\"%d\", d[i] + j);\n            cnt = std::max(cnt, d[i][j]);\n        }\n    }\n    for (int i = 0; i <= cnt; ++ i) {\n        for (int j = 0; j <= cnt; ++ j) {\n            int& dt = delta[i][j];\n            dt = 0;\n            for (int x = 1; x <= a; ++ x) {\n                for (int y = 1; y <= b; ++ y) {\n                    dt = std::max(dt, d[x][y] - i * x - j * y);\n                }\n            }\n            for (int x = 1; x <= a; ++ x) {\n                for (int y = 1; y <= b; ++ y) {\n                    if (dt + i * x + j * y == d[x][y]) {\n                        left -= !ok[x][y];\n                        ok[x][y] = true;\n                    }\n                }\n            }\n        }\n    }\n    if (left) {\n        puts(\"Impossible\");\n    } else {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 2 * (cnt + 1), (cnt + 1) * (cnt + 1));\n\n        for (int i = 0; i < cnt; ++ i) {\n            printf(\"%d %d X\\n\", i + 1, i + 2);\n            printf(\"%d %d Y\\n\", i + cnt + 3, i + cnt + 2);\n        }\n        for (int i = 0; i <= cnt; ++ i) {\n            for (int j = 0; j <= cnt; ++ j) {\n                printf(\"%d %d %d\\n\", i + 1, j + cnt + 2, delta[i][j]);\n            }\n        }\n        printf(\"%d %d\\n\", 1, cnt + 2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\t\t\td[0] = 0;\n\t\t\tpriority_queue<p>Q;\n\t\t\tQ.push({0,0});\n\t\t\twhile (Q.size()) {\n\t\t\t\tp t = Q.top(); Q.pop();\n\t\t\t\tif (d[t.second] < t.first)continue;\n\t\t\t\tfor (P u : V) {\n\t\t\t\t\tif (u.second.first == t.second) {\n\t\t\t\t\t\tint h = 0;\n\t\t\t\t\t\tif (u.first >= 0) {\n\t\t\t\t\t\t\th = u.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (u.first == -1) {\n\t\t\t\t\t\t\th = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse h = j + 1;\n\t\t\t\t\t\tif (d[u.second.second] > t.first + h) {\n\t\t\t\t\t\t\td[u.second.second] = t.first + h;\n\t\t\t\t\t\t\tQ.push({ u.second.second,t.first + h });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << d[201] << \"#\" << endl;\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first+1 << \" \" << i.second.second + 1 << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \" \" << i.first<< endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N], ma[12][12];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n        ma[i][j] = 1e9;\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        ma[i][j] = min(ma[i][j], cx * i + cy * j + c[cx][cy]);\n    }\n\n    FOR(i,1,a) FOR(j,1,b){\n        if (ma[i][j] != d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    REP(i,N-1) cout << 299-i << \" \" << 300-i << \" Y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int A,B;cin>>A>>B;\n  vector<vll> d(A,vll(B));\n  repeat(i,A){\n    repeat(j,B){\n      cin>>d[i][j];\n    }\n  }\n  vector<vll> f(110,vll(110,0));\n  repeat(a,101){\n    repeat(b,101){\n      repeat(x,A){\n        repeat(y,B){\n          f[a][b]=max(f[a][b],d[x][y]-a*(x+1)-b*(y+1));\n        }\n      }\n    }\n  }\n  vector<vll> D(A,vll(B,INF));\n  bool isok=true;\n  repeat(x,A){\n    repeat(y,B){\n      repeat(a,101){\n        repeat(b,101){\n          D[x][y]=min(D[x][y],a*(x+1)+b*(y+1)+f[a][b]);\n        }\n      }\n      isok &= D[x][y]==d[x][y];\n    }\n  }\n  if(!isok){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  repeat(i,100){\n    cout << i+1 << \" \" << i+2 << \" X\" << endl;\n  }\n  repeat(i,100){\n    cout << i+102 << \" \" << i+103 << \" Y\" << endl;\n  }\n  repeat(i,101){\n    repeat(j,101){\n      cout << i+1 << \" \" << 202-j << \" \"<< f[i][j] << endl;\n    }\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?(d[a][j]-d[i][j]+a-i-1)/(a-i):0;\n\t\t\tll y = j<b?(d[i][b]-d[i][j]+b-j-1)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(int i=(x),i##_max_for_repmacro=(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int A,B;\n    cin >> A >> B;\n    vector<vector<int>> d(A,vector<int>(B));\n    rep(i,0,A) rep(j,0,B) cin >> d[i][j];\n\n    int N=202,M=101*101,S=0,T=N-1;\n    static int f[101][101]={};\n    rep(i,0,101) rep(j,0,101){\n        int ma=0;\n        rep(x,0,A) rep(y,0,B) ma=max(ma,d[x][y]-(x+1)*i-(y+1)*(100-j));\n        f[i][j]=ma;\n    }\n\n    auto min_dist=[&](int x,int y){\n        int dist[202];\n        fill_n((int*)dist,202,inf);\n        dist[0]=0;\n        rep(i,0,202){\n            rep(j,0,101) rep(k,0,101) dist[k+101]=min(dist[k+101],dist[j]+f[j][k]);\n            rep(j,0,100) dist[j+1]=min(dist[j+1],dist[j]+x);\n            rep(j,0,100) dist[j+1+101]=min(dist[j+1+101],dist[j+101]+y);\n        }\n        return dist[201];\n    };\n\n    rep(x,1,A+1) rep(y,1,B+1) if(min_dist(x,y)!=d[x-1][y-1]){\n        cout << \"Impossible\" << endl;\n        return;\n    }\n\n    cout << \"Possible\" << endl;\n    cout << N << \" \" << M << endl;\n    rep(i,0,101) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    rep(i,0,101) cout << i+1+101 << \" \" << i+2+101 << \" Y\" << endl;\n    rep(i,0,101) rep(j,0,101) cout << i+1 << \" \" << j+101 << \" \" << f[i][j] << endl;\n    cout << S+1 << \" \" << T+1 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int S = 198, T = 199;\n\txv.push_back(S);\n\tFOR(i, 99) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, 99) yv.push_back(i + 99);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int,int,int>> vp;\n\tFOR(i, 100) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(i, a) FOR(j, b) {\n\t\tint minad = 12345;\n\t\tint cxw = minx[i][j], cyw = miny[i][j];\n\t\tfor (int w = minx[i][j]; w <= 100; w++) {\n\t\t\tfor (int z = miny[i][j]; z <= 100; z++) {\n\t\t\t\tint xw = w * (i + 1);\n\t\t\t\tint yw = z * (j + 1);\n\t\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\t\tif (additional < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (additional < minad) {\n\t\t\t\t\tminad = additional;\n\t\t\t\t\tcxw = w;\n\t\t\t\t\tcyw = z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minad == 12345) {\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t\tint from = xv[cxw], to = yv[100 - cyw];\n\t\t// printf(\"%d %d %d\\n\", cxw, cyw, minad);\n\t\tvp.emplace_back(from, to, minad);\n\t}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(200);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", 200, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S , T);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?(d[a][j]-d[i][j]+a-i)/(a-i):0;\n\t\t\tll y = j<b?(d[i][b]-d[i][j]+b-j)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[15][15];\nint f[105][105];\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int na, nb;\n   cin >> na >> nb;\n   for (int i = 1; i <= na; ++i) {\n      for (int j = 1; j <= nb; ++j) {\n         cin >> d[i][j];\n      }\n   }\n   for (int nx = 0; nx < 105; ++nx) {\n      for (int ny = 0; ny < 105; ++ny) {\n         for (int i = 1; i <= na; ++i) {\n            for (int j = 1; j <= nb; ++j) {\n               f[nx][ny] = max(f[nx][ny], d[i][j] - i * nx - j * ny);\n            }\n         }\n      }\n   }\n   for (int i = 1; i <= na; ++i) {\n      for (int j = 1; j <= nb; ++j) {\n         bool found = false;\n         for (int nx = 0; nx < 105; ++nx) {\n            for (int ny = 0; ny < 105; ++ny) {\n               if (f[nx][ny] + i * nx + j * ny == d[i][j]) {\n                  found = true;\n               }\n            }\n         }\n         if (!found) {\n            cout << \"Impossible\\n\";\n            return 0;\n         }\n      }\n   }\n   cout << \"Possible\\n\";\n   cout << 210 << \" \" << 11233 << \"\\n\";\n   for (int i = 0; i < 104; ++i) {\n      cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n      cout << i + 107 << \" \" << i + 106 << \" Y\\n\";\n   }\n   for (int nx = 0; nx < 105; ++nx) {\n      for (int ny = 0; ny < 105; ++ny) {\n         cout << nx + 1 << \" \" << ny + 106 << \" \" << f[nx][ny] << \"\\n\";\n      }\n   } \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=105;\nint d[15][15];\nint cd[15][15];\nint f[maxn][maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int A,B;\n    cin>>A>>B;\n    for(int i=1;i<=A;i++)\n    {\n        for(int j=1;j<=B;j++)\n            cin>>d[i][j];\n    }\n    for(int a=0;a<maxn;a++)\n    {\n        for(int b=0;b<maxn;b++)\n        {\n            for(int x=1;x<=A;x++)\n            {\n                for(int y=1;y<=B;y++)\n                    f[a][b]=max(f[a][b],d[x][y]-a*x-b*y);\n            }\n        }\n    }\n    memset(cd,0x3f,sizeof(cd));\n    for(int a=0;a<maxn;a++)\n    {\n        for(int b=0;b<maxn;b++)\n        {\n            for(int x=1;x<=A;x++)\n            {\n                for(int y=1;y<=B;y++)\n                    cd[x][y]=min(cd[x][y],a*x+b*y+f[a][b]);\n            }\n        }\n    }\n    bool ok=1;\n    for(int i=1;i<=A;i++)\n        for(int j=1;j<=B;j++)\n            if(cd[i][j]!=d[i][j])ok=0;\n    if(!ok) cout<<\"Impossible\\n\";\n    else{\n        cout<<\"Possible\\n\";\n        cout<<maxn*2<<\" \"<<2*maxn-2+maxn*maxn<<'\\n';\n        for(int i=1;i<maxn;i++)\n            cout<<i<<\" \"<<i+1<<\" X\\n\";\n        for(int i=maxn+1;i<maxn+maxn;i++)\n            cout<<i<<\" \"<<i+1<<\" Y\\n\";\n        for(int i=1;i<=maxn;i++)\n        {\n            for(int j=maxn+1;j<=maxn*2;j++)\n            {\n                cout<<i<<\" \"<<j<<\" \"<<f[i-1][2*maxn-j]<<'\\n';\n            }\n        }\n        cout<<1<<\" \"<<maxn+maxn<<'\\n';\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << n-1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n\n\nusing namespace std;\n\nint d[15][15];\nint N;\nint g[305][305];\nVI vy, vx;\n\nint check[15][15];\n\nint main () {\n\tmake2(A, B);\n\tFOR(i,0,A) FOR(j,0,B) {\n\t\tmake(x); d[i+1][j+1] = x;\n\t}\n\tvector<pair<PII, int > > v;\n\tFOR(a,0,101) FOR(b,0,101) {\n\t\tint c = -1000;\n\t\tFOR(x,1,A+1) FOR(y,1,B+1) {\n\t\t\tc = max(c, d[x][y]-a*x-b*y);\n\t\t}\n\t\tif (c < 0) continue;\n\t\tv.pb(mp(mp(a,b),c));\n\t}\n\tN = 2;\n\tFOR(i,0,305) FOR(j,0,305) g[i][j] = -3;\n\tint maxa = 0;\n\tint maxb = 0;\n\tFORE(i, v) maxa = max(maxa, i->st.st);\n\tFORE(i, v) maxb = max(maxb, i->st.nd);\n\tint S = 0; vx.pb(S);\n\tint T = 1; vy.pb(T);\n\tint act = 2;\n\tFOR(i,0,maxa) {\n\t\tg[vx.back()][act] = -1;\n\t\tg[act][vx.back()] = -1;\n\t\tvx.pb(act); \n\t\tact++;\n\t}\n\tFOR(i,0,maxb) {\n\t\tg[vy.back()][act] = -2;\n\t\tg[act][vy.back()] = -2;\n\t\tvy.pb(act); \n\t\tact++;\n\t}\n\tbool ok = true;\n\tFORE(i,v) {\n\t\tint a = i->st.st;\n\t\tint b = i->st.nd;\n\t\tint c = i->nd;\n\t\tg[vx[a]][vy[b]] = c;\n\t\tg[vy[b]][vx[a]] = c;\n\t\tFOR(ii,1,A+1) FOR(jj,1,B+1) {\n\t\t\tif (ii*a +jj*b + c == d[ii][jj]) check[ii][jj] = 1; \n\t\t\tif (ii*a +jj*b + c < d[ii][jj]) ok = false;\n\t\t}\n\t}\n\tFOR(i,1,A+1) FOR(j,1,B+1) {\n\t\tif (check[i][j] != 1 || !ok) {\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tint m = 0;\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] != -3) m++;\n\t}\n\tprintf(\"%d %d\\n\", act, m);\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] == -1) {\n\t\t\tprintf(\"%d %d X\\n\", i+1, j+1);\n\t\t}\n\t\telse if (g[i][j] == -2) {\n\t\t\tprintf(\"%d %d Y\\n\", i+1, j+1);\n\t\t} else if (g[i][j] >= 0) {\n\t\t\tprintf(\"%d %d %d\\n\", i+1, j+1, g[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 2\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct change_path{\n    int slope, upper;\n};\n\nchange_path slope_and_upper(int nums_size, int nums[]){\n    change_path ans;\n    ans.slope = nums[1] - nums[0];\n    int need_slope = ans.slope;\n    for(int i = 1; i < nums_size; i++){\n        if(nums[i] == nums[i - 1]){\n            need_slope = 0;\n            ans.upper = nums[i];\n        }\n        if(nums[1] - nums[0] != need_slope){\n            cout << \"Impossible\" << endl;\n            exit(0);\n        }\n    }\n    if(need_slope){\n        ans.upper = -1;\n    }\n    return ans;\n}\n\nint main(){\n    int A, B;\n    cin >> A >> B;\n    int distances[A][B];\n    for(int i = 0; i < A; i++){\n        for(int j = 0; j < B; j++){\n            cin >> distances[i][j];\n        }\n    }\n    if(A == 1 && B == 1){\n        cout << \"2 1\" << endl;\n        cout << \"1 2 \" << distances[0][0] << endl;\n        cout << \"1 2\" << endl;\n    }else if(A == 1){\n        change_path straight_graph\n    }\n    change_path change_pathes[A];\n    for(int i = 0; i < A; i++){\n        change_pathes[i] = slope_and_upper(B, distances[i]);\n    }\n    int slope_of_slope;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"Impossible\");\n\telse\n\t{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + (A+1)*(B+1));\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a <= A; ++a)\n\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[20][20];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 1000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint A, B;\nint D[15][15];\nint f[105][105];\n\nint main(){\n\n  cin >> A >> B;\n  rep(i,A){\n    rep(j,B){\n      cin >> D[i][j];\n    }\n  }\n\n  rep(a,101){\n    rep(b,101){\n      rep(x,A){\n        rep(y,B){\n          f[a][b] = max(f[a][b], D[x][y] - (x+1)*a - (y+1)*b);\n        }\n      }\n    }\n  }\n\n  rep(x,A){\n    rep(y,B){\n      int mn = 1000000000;\n      rep(a,101){\n        rep(b,101){\n          mn = min(mn, (x+1)*a + f[a][b] + (y+1)*b);\n        }\n      }\n      if(D[x][y] != mn){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  \n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i,100){\n    cout << i << \" \" << i+1 << \" X\" << endl;\n  }\n  rep(i,100){\n    cout << 101+i << \" \" << 101+i+1 << \" Y\" << endl;\n  }\n  rep(i,101){\n    rep(j,101){\n      cout << i << \" \" << 201-j << \" \" << f[i][j] << endl;\n    }\n  }\n  \n  cout << 0 << \" \" << 201 << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + N << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\tcout << 1 << \" \" << 200 + N << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ARC089E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 330;\n\nint n, A, B, d[MAX_N][MAX_N], f[MAX_N][MAX_N];\n\nint main()\n{\n    scanf(\"%d%d\", &A, &B);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n            scanf(\"%d\", &d[i][j]);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            for (int p = 1; p <= A; p++)\n                for (int q = 1; q <= B; q++)\n                    f[i][j] = max(f[i][j], d[p][q] - i * p - j * q);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n        {\n            int dist = 1e9;\n            for (int p = 0; p <= 100; p++)\n                for (int q = 0; q <= 100; q++)\n                    dist = min(dist, f[p][q] + i * p + j * q);\n            if (dist != d[i][j])\n                puts(\"Impossible\"), exit(0);\n        }\n    puts(\"Possible\"), puts(\"202 10401\");\n    for (int i = 1; i <= 100; i++)\n        printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i < 202; i++)\n        printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,n)\tfor(int i=0;i<(int)n;i++)\n#define FOB(i,n)\tfor(int i=n;i>=1;i--)\n#define MP(x,y)\tmake_pair((x),(y))\n#define ii pair<int, int>\n#define lli long long int\n#define ulli unsigned long long int\n#define lili pair<lli, lli>\n#ifdef EBUG\n#define DBG\tif(1)\n#else\n#define DBG\tif(0)\n#endif\n#define SIZE(x) int(x.size())\nconst int infinity = 2000000999 / 2;\nconst long long int inff = 4000000000000000999;\n\ntypedef complex<long double> point;\n\ntemplate<class T>\nT get() {\n    T a;\n    cin >> a;\n    return a;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const pair<T, U> &par) {\n    out << \"[\" << par.first << \";\" << par.second << \"]\";\n    return out;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& out, const set<T> &cont){\n    out << \"{\";\n    for (const auto &x:cont) out << x << \", \";\n    out << \"}\";\n    return out;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const map<T,U> &cont){\n    out << \"{\";\n    for (const auto &x:cont) out << x << \", \";\n    out << \"}\"; return out;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  FOR(i, v.size()){\n    if(i) out << \" \";\n    out << v[i];\n  }\n  out << endl;\n  return out;\n}\n\nbool ccw(point p, point a, point b){\n  if((conj(a - p) * (b - p)).imag() <= 0) return(0);\n  else return(1);\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    cout.sync_with_stdio(false);\n    \n    int a = get<int>();\n    int b = get<int>();\n    \n    vector<vector<int> > D(a, vector<int>(b));\n    int mx = 0;\n    FOR(i, a){\n        FOR(j, b) D[i][j] = get<int>();\n        FOR(j, b) mx = max(mx, D[i][j]);\n    }\n    \n    vector<vector<int> > minc(mx + 1, vector<int>(mx + 1, 0));\n    \n    FOR(i, mx + 1){\n        FOR(j, mx + 1){\n            FOR(l, a){\n                FOR(y, b){\n                    DBG cout << \"Pri : \" << i << \" * \" << l + 1 << \" + \" << j << \" * \" << y + 1 << \" + c = \" << D[l][y];\n                    minc[i][j] = max(minc[i][j], D[l][y] - (l + 1) * i - (y + 1) * j);\n                    DBG cout << \" => minc: \" << minc[i][j] << endl;\n                }\n            }\n        }\n    }\n    \n    DBG cout << \" \" << minc;\n    \n    vector<vector<ii> > ktore(a, vector<ii>(b, make_pair(-1, -1)));\n    set<ii> used;\n    \n    FOR(i, mx + 1){\n        FOR(j, mx + 1){\n            FOR(l, a){\n                FOR(y, b){\n                    if(minc[i][j] == D[l][y] - (l + 1) * i - (y + 1) * j){\n                        if(ktore[l][y].first == -1 || ktore[l][y].second + ktore[l][y].first > j + i){\n                            ktore[l][y] = {i, j};\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    FOR(i, a){\n        FOR(j, b){\n            if(ktore[i][j].first < 0){\n                DBG cout << \"Neda sa pripradit :( \" << i << \" a \" << j << endl;\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            DBG cout << \"Plati, ze \" << ktore[i][j] << \" x \" << i + 1 << \" | \" << j + 1 << \" bude rovne \" << endl;\n            used.insert(ktore[i][j]);\n        }\n    }\n    \n//     cout << \"Possible\" << endl;\n    int maxi = (--used.end())->first;\n    int n = maxi + 1;\n    vector<pair<ii, int> > hrany;\n    FOR(i, maxi){\n        hrany.push_back({{i, i + 1}, -1});\n    }\n    vector<int> mxs(maxi + 1, 0);\n    vector<vector<int> > M(maxi + 1);\n    for(ii a : used){\n        mxs[a.first] = max(mxs[a.first], a.second);\n        M[a.first].push_back(a.second);\n    }\n    \n    int yps = 0;\n    \n    FOR(i, maxi + 1){\n        yps += mxs[i];\n        DBG cout << \"yps += \" << mxs[i] << endl;\n    }\n    \n    n += yps;\n    \n    n ++;\n    \n    if(n <= 300) cout << \"Possible\" << endl;\n    else{\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    \n    int v = maxi + 1;\n    \n    FOR(i, maxi + 1){\n        int f = v;\n        int last = i;\n        FOR(j, mxs[i]){\n            hrany.push_back({{last, v}, -2});\n            last = v;\n            v ++;\n        }\n        \n        for(int a : M[i]){\n            if(!a){\n                hrany.push_back({{i, n - 1}, minc[i][a]});\n            }\n            else{\n                if(f + a - 1 != n - 1) hrany.push_back({{f + a - 1, n - 1}, minc[i][a]});\n            }\n        }\n        \n    }\n    \n    cout << n << \" \" << hrany.size() << endl;\n    for(auto e : hrany){\n        cout << e.first.first + 1 << \" \" << e.first.second + 1 << \" \";\n        if(e.second < 0) cout << (e.second == -1 ? \"X\" : \"Y\") << endl;\n        else cout << e.second << endl;\n    }\n    \n    cout << 1 << \" \" << n << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 502;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[N],st2[N],st3[N];\nbool mrk[N];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=1; t=2;\n\trep(a,0,16) rep(b,0,16) {\n\t\tint mx=0;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-a*i-b*j);\n\t\tC[a][b]=mx; dy[a][b]=++sz;\n\t\trep(i,1,n) rep(j,1,m) ok[i][j]|=(d[i][j]-a*i-b*j==mx);\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\trep(a,0,16) rep(b,0,16) {\n\t\tif (dy[a][b]&&dy[a+1][b]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a+1][b]; st3[tot]=1;}\n\t\tif (dy[a][b]&&dy[a][b+1]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a][b+1]; st3[tot]=2;}\n\t}\n\trep(a,0,16) rep(b,0,16) if (dy[a][b]) {\n\t\ttot++; st1[tot]=dy[a][b]; st2[tot]=t;\n\t\tmrk[tot]=1; st3[tot]=C[a][b];\n\t}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[0][1]; st3[tot]=2;}\n\tif (dy[1][0]) {tot++; st1[tot]=s; st2[tot]=dy[1][0]; st3[tot]=1;}\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",sz,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"1 2\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            v.push_back(F{i, j, k});\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n    int s = 0;\n    int t = 299;\n    vector<pii> e;\n    vector<int> c;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i, i + 1));\n        c.push_back(INT_MIN);\n    }\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i + YY, i + 1 + YY));\n        c.push_back(INT_MIN + 1);\n    }\n\n    for (const auto &f : v) {\n        e.push_back(make_pair(f.a, YY));\n        c.push_back(0);\n        e.push_back(make_pair(YY + f.b, t));\n        c.push_back(f.c);\n    }\n    cout << \"Possible\" << \"\\n\";\n    cout << t + 1 << \" \" << e.size() << \"\\n\";\n    for (int i = 0; i < e.size(); ++i) {\n        cout << e[i].first + 1 << \" \" << e[i].second + 1 << \" \";\n        if (c[i] == INT_MIN) {\n            cout << \"X\";\n        } else if (c[i] == INT_MIN + 1) {\n            cout << \"Y\";\n        } else {\n            cout << c[i];\n        }\n        cout << \"\\n\";\n    }\n    cout << s + 1 << \" \" << t + 1 << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint a, b;\nint d[11][11];\nint val[11][11];\n\nusing edge = tuple<int, int, int>;\nvector<edge> graph;\n\nusing edge2 = tuple<int, int, char>;\nvector<edge2> graph2;\n\nvoid trial(int alimit, int blimit) {\n\tgraph.clear();\n\tgraph2.clear();\n\trep(i, a)rep(j, b) val[i][j] = 1010;\n\n\tconst int n = alimit * blimit + 1;\n\tconst int s = 0, t = n - 1;\n\n\trep(ca, alimit)rep(cb, blimit) {\n\t\tint tmp[11][11];\n\t\trep(x, a)rep(y, b) tmp[x][y] = ca * (x + 1) + cb * (y + 1);\n\t\tint cmax = 0;\n\t\trep(x, a)rep(y, b) chmax(cmax, d[x][y] - tmp[x][y]);\n\t\tif (cmax > 100) continue;\n\n\t\trep(x, a)rep(y, b) chmin(val[x][y], tmp[x][y] +  cmax);\n\t\tconst int idx = blimit * ca + cb;\n\t\tgraph.push_back(edge(idx, t, cmax));\n\t}\n\n\trep(ca, alimit - 1) {\n\t\tgraph2.push_back(edge(blimit * ca, blimit * (ca + 1), 'X'));\n\t}\n\n\trep(ca, alimit)rep(cb, blimit - 1) {\n\t\tgraph2.push_back(edge(blimit * ca + cb , blimit * ca + cb + 1, 'Y'));\n\t}\n\n\trep(x, a)rep(y, b) if (val[x][y] != d[x][y]) return;\n\n\tputs(\"Possible\");\n\tconst int m = graph.size() + graph2.size();\n\tcout << n << \" \" << m << endl;\n\tfor (auto &it : graph) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tfor (auto &it : graph2) {\n\t\tint a, b;\n\t\tchar  c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tcout << s + 1 << \" \" << t + 1 << endl;\n\texit(0);\n}\n\n\nint main(void) {\n\tcin >> a >> b;\n\trep(i, a)rep(j, b) cin >> d[i][j];\n\n\trep(one, 1, 18) {\n\t\tconst int other = 299 / one;\n\t\ttrial(one, other);\n\t\ttrial(other, one);\n\t}\n\n\n\tputs(\"Impossible\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint d[11][11];\nbool marked[11][11];\nint n, m;\n\nint verif(int x, int y, int add)\n{\n    int ans(0);\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (x * i + y * j + add == d[i][j] && !marked[i][j])\n                ans++;\n            else if (x * i + y * j + add < d[i][j])\n                ans = -1e9;\n        }\n    }\n    return ans;\n}\nvoid mark(int x, int y, int add)\n{\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (x * i + y * j + add == d[i][j])\n                marked[i][j] = 1;\n        }\n    }\n}\n\nstruct Edge { int x, y, cost; };\n\nvector <Edge> ans;\nvector <int> lantx, lanty;\nint s, dest;\nint cnt;\n\nvoid mk_lant(vector <int> & lant, int l)\n{\n    while (lant.size() <= l)\n        lant.push_back(++cnt);\n}\n\nvoid mk_choice(int x, int y, int simple)\n{\n    if (x < y) {\n        mk_lant(lanty, y);\n        int last(lanty[y]);\n        while (x--) {\n            ans.push_back((Edge) { last, ++cnt, -1 });\n            last = cnt;\n        }\n        while (simple > 0) {\n            ans.push_back((Edge) { last, ++cnt, (simple > 100 ? 100 : simple) });\n            last = cnt;\n            simple -= 100;\n        }\n        if (last == lanty[y])\n            ans.push_back((Edge) { last, dest, 0 });\n        else {\n            cnt--;\n            ans.back().y = dest;\n        }\n    }\n    else {\n        mk_lant(lantx, x);\n        int last(lantx[x]);\n        while (y--) {\n            ans.push_back((Edge) { last, ++cnt, -2 });\n            last = cnt;\n        }\n        while (simple > 0) {\n            ans.push_back((Edge) { last, ++cnt, (simple > 100 ? 100 : simple) });\n            last = cnt;\n            simple -= 100;\n        }\n        if (last == lantx[x])\n            ans.push_back((Edge) { last, dest, 0 });\n        else {\n            cnt--;\n            ans.back().y = dest;\n        }\n    }\n}\n\nint main()\n{\n    s = 1, dest = 2;\n    cnt = 2;\n    lantx.push_back(s);\n    lanty.push_back(s);\n    cin >> n >> m;\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++)\n            cin >> d[i][j];\n    }\n\n    bool pus(1);\n    int best(0), x, y, add;\n    while (pus) {\n        pus = 0;\n        best = 0;\n        for (int i(0); i <= 100; i++) {\n            for (int j(0); j <= 100; j++) {\n                for (int k(0); k <= 100; k++) {\n                    int q = verif(i, j, k);\n                    if (q > best)\n                        best = q, x = i, y = j, add = k;\n                }\n            }\n        }\n        if (best) {\n            pus = 1;\n            mk_choice(x, y, add);\n            mark(x, y, add);\n        }\n    }\n\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (!marked[i][j]) {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n\n    cout << ans.size() + lantx.size() - 1 + lanty.size() - 1 << '\\n';\n    for (int i(1); i < lantx.size(); i++)\n        cout << lantx[i - 1] << ' ' << lantx[i] << \" X\\n\";\n    for (int i(1); i < lanty.size(); i++)\n        cout << lanty[i - 1] << ' ' << lanty[i] << \" Y\\n\";\n\n    for (auto i : ans) {\n        cout << i.x << ' ' << i.y << ' ';\n        if (i.cost >= 0)\n            cout << i.cost << '\\n';\n        else\n            cout << (i.cost == -1 ? 'X' : 'Y') << '\\n';\n    }\n    cout << s << ' ' << dest << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tii=jj=-1;\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0,fff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1,fff=1;\n\t\t\t\tif (fff)ii=i,jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 300, link = 101, inf = ~0U >> 2;\n\nint a, b, d[11][11], d2[11][11];\nint n, m, x[link + 1], y[link + 1];\npair<pair<int, int>, int> edge[1000000];\n\nvoid AddEdge(int u, int v, int c) {\n  edge[m++] = {{u, v}, c};\n}\n\nint main(void) {\n  scanf(\"%d%d\", &a, &b);\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      scanf(\"%d\", d[i] + j);\n    }\n  }\n  n = 2;\n  x[0] = 0;\n  for (int i = 1; i <= link; ++i) {\n    x[i] = n++;\n    AddEdge(x[i - 1], x[i], inf + 1);\n  }\n  y[0] = 1;\n  for (int i = 1; i <= link; ++i) {\n    y[i] = n++;\n    AddEdge(y[i], y[i - 1], inf + 2);\n  }\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      d2[i][j] = inf;\n    }\n  }\n  for (int dx = 0; dx <= link; ++dx) {\n    for (int dy = 0; dy <= link; ++dy) {\n      int delta = -inf;\n      for (int i = 1; i <= a; ++i) {\n        for (int j = 1; j <= b; ++j) {\n          delta = max(delta, d[i][j] - dx * i - dy * j);\n        }\n      }\n      AddEdge(x[dx], y[dy], delta);\n      for (int i = 1; i <= a; ++i) {\n        for (int j = 1; j <= b; ++j) {\n          d2[i][j] = min(d2[i][j], dx * i + dy * j + delta);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      if (d2[i][j] != d[i][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", edge[i].first.first + 1, edge[i].first.second + 1);\n    if (edge[i].second == inf + 1) {\n      puts(\"X\");\n    } else if (edge[i].second == inf + 2) {\n      puts(\"Y\");\n    } else {\n      printf(\"%d\\n\", edge[i].second);\n    }\n  }\n  puts(\"1 2\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nconst int X = 123123;\nconst int Y = 321321;\n\nint A, B;\nint D[10][10];\nint N;\nint down[101], up[101];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> A >> B;\n  rep(x, A) rep(y, B) cin >> D[x][y];\n  bool ok = true;\n  rep(x, A) rep(y, B-1) if (D[x][y] > D[x][y+1]) ok = false;\n  rep(x, A-1) rep(y, B) if (D[x][y] > D[x+1][y]) ok = false;\n  if (!ok) {\n    cout << \"Impossible\\n\";\n    return 0;\n  }\n  vector<P2> edges;\n  int s = 0, t = 1;\n  N = 2;\n  down[0] = s;\n  up[0] = t;\n  for (int i=1; i<=100; i++) {\n    down[i] = N++;\n    edges.pb(P2(P(down[i-1], down[i]), X));\n  }\n  for (int i=1; i<=100; i++) {\n    up[i] = N++;\n    edges.pb(P2(P(up[i], up[i-1]), Y));\n  }\n  vector<P2> vs;\n  for (int a=0; a<=100; a++) {\n    for (int b=0; b<=100; b++) {\n      int c = 0;\n      for (int x=1; x<=A; x++) {\n        for (int y=1; y<=B; y++) {\n          c = max(c, D[x-1][y-1]-a*x-b*y);\n        }\n      }\n      vs.pb(P2(P(a, b), c));\n      edges.pb(P2(P(down[a], up[b]), c));\n    }\n  }\n  for (int x=1; x<=A; x++) {\n    for (int y=1; y<=B; y++) {\n      int dist = INF;\n      for (P2 p : vs) {\n        int a = p._1._1, b = p._1._2, c = p._2;\n        dist = min(dist, a*x+b*y+c);\n      }\n      if (dist != D[x-1][y-1]) {\n        cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\\n\";\n  cout << N << \" \" << edges.size() << \"\\n\";\n  for (P2 p : edges) {\n    cout << p._1._1+1 << \" \" << p._1._2+1 << \" \";\n    int w = p._2;\n    if (w == X) cout << \"X\\n\";\n    else if (w == Y) cout << \"Y\\n\";\n    else cout << w << \"\\n\";\n  }\n  cout << \"1 2\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(101, vector<int>(101, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 0; i < a; ++i) {\n      for (int j = 0; j < b; ++j) {\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[a][b] - a * k + b * l);\n          }\n        }\n      }\n    }\n    for (int i = 0; i < a; ++i) {\n      for (int j = 0; j < b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            minDistance = min(minDistance, a * k + b * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[a][b]) impossible();\n      }\n    }\n    cout << \"202 10401\" << endl;\n    for (int k = 0; k <= 100; ++k) {\n      for (int l = 0; l <= 100; ++l) {\n        cout << k + 1 << ' ' << 102 + l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < 100; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + 102 << ' ' << i + 103 << \" Y\" << endl;\n    }\n\n    cout << \"1 202\" << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b;\nint v[20][20];\nbool taken[20][20];\nvector<pair<int, int> > adj[110];\nbool taken2[101][101];\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &v[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tif (taken2[i][j]) break;\n\t\t\t\tif (i + j + k > 100) break;\n\t\t\t\tbool works = true;\n\t\t\t\tbool canhelp = false;\n\t\t\t\tfor (int x = 1; x <= a && works; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k < v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworks = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i * x + j * y + k == v[x][y] && !taken[x][y]) canhelp = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!works) continue;\n\t\t\t\tif (!canhelp) continue;\n\t\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k == v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttaken[x][y] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttaken2[i][j] = true;\n\t\t\t\tadj[i].emplace_back(j, k);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tif (!taken[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint constant = a*b;\n\t// 1 = sink\n\t// 2 - 101 = that many xs\n\t// 102 - 201 = that many ys\n\t// 202 (2*constant + 2) sink\n\tprintf(\"Possible\\n\");\n\tvector<pair<pair<int, int> , char> > out;\n\tvector<pair<pair<int, int> , int> > out2;\n\tprintf(\"%d \", 2*constant+2);\n\tfor (int i = 1; i <= constant; i++)\n\t{\n\t\tout.emplace_back(make_pair(i, i+1), 'X');\n\t//\tprintf(\"%d %d X\\n\", i, i+1);\n\t\tout.emplace_back(make_pair(i+constant+1, i+constant+2), 'Y');\n\t//\tprintf(\"%d %d Y\\n\", i+constant+1, i + constant+2);\n\t}\n\tfor (int i = 0; i <= constant; i++)\n\t{\n\t\tfor (auto a : adj[i])\n\t\t{\n\t\t\tint y = a.first;\n\t\t\ty = constant-y;\n\t\t\t// 0 if 100\n\t\t\ty += constant+2;\n\t\t\tint wei = a.second;\n\t\t\tout2.emplace_back(make_pair(i+1, y), wei);\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", out.size() + out2.size());\n\tfor (auto a : out) printf(\"%d %d %c\\n\", a.first.first, a.first.second, a.second);\n\tfor (auto a : out2) printf(\"%d %d %d\\n\", a.first.first, a.first.second, a.second);\n\tprintf(\"%d %d\\n\", 1, 2*constant+2);\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint c[102][102];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, a, b);\n\tMAT(int, d, a, b);\n\tREP(ai, 101) REP(bi, 101) REP(x, a) REP(y, b) {\n\t\tCHMAX(c[ai][bi], d[x][y] - ai * (x + 1) - bi * (y + 1));\n\t}\n\tREP(x, a) REP(y, b) {\n\t\tint dist = INFINT;\n\t\tREP(ai, 101) REP(bi, 101) {\n\t\t\tCHMIN(dist, ai * (x + 1) + bi * (y + 1) + c[ai][bi]);\n\t\t}\n\t\tif (dist != d[x][y]) {\n\t\t\tOUT(\"Impossible\")BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tOUT(\"Possible\")BR;\n\tOUT(\"202 10401\")BR;\n\tREP(i, 100) {\n\t\tOUT(i + 1)SP OUT(i + 2)SP OUT('X')BR;\n\t\tOUT(i + 2 + 101)SP OUT(i + 1 + 101)SP OUT('Y')BR;\n\t}\n\tREP(i, 101) REP(j, 101) {\n\t\tOUT(i + 1)SP OUT(j + 1 + 101)SP OUT(c[i][j])BR;\n\t}\n\tOUT(\"1 101\")BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define min(a,b) ((a)<(b)? (a):(b))\n#define max(a,b) ((a)>(b)? (a):(b))\nint d[15][15],f[105][105];\nint main() {\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tscanf(\"%d\",&d[x][y]);\n\t\t}\t\n\t}\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tfor(register int x=1;x<=n;++x) {\n\t\t\t\tfor(register int y=1;y<=m;++y) {\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(f[i][j]>0) printf(\"%d \",f[i][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n//\tgetchar();getchar();\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tint minn=105;\n\t\t\tfor(register int i=0;i<=100;++i) {\n\t\t\t\tfor(register int j=0;j<=100;++j) {\n\t\t\t\t\tminn=min(minn,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minn!=d[x][y])  {printf(\"Impossible\\n\");return 0;}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(register int x=1;x<=100;++x) printf(\"%d %d X\\n\",x,x+1);\n\tfor(register int x=101;x<=201;++x) printf(\"%d %d Y\\n\",x,x+1);\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint A,B,cnt,d[11][11];\nbool b[11][11];\nstruct edge{\n\tint s,t,w;\n\tedge():s(0),t(0),w(0){}\n\tedge(int s,int t,int w):s(s),t(t),w(w){}\n}es[40005];\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';f=c=='-'?-1:1,c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0',c=getchar());\n\treturn x*f;\n}\nint main(){\n\tA=read();B=read();\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\td[i][j]=read();\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tint maxw=0;\n\t\t\tfor(int k=1;k<=A;k++)\n\t\t\t\tfor(int l=1;l<=B;l++)\n\t\t\t\t\tmaxw=max(maxw,d[k][l]-k*i-l*j);\n\t\t\tes[++cnt]=edge(i+1,202-j,maxw);\n\t\t\tfor(int k=1;k<=A;k++)\n\t\t\t\tfor(int l=1;l<=B;l++)\n\t\t\t\t\tif(d[k][l]==k*i+l*j+maxw)b[k][l]=1;\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tif(!b[i][j])return 0*puts(\"Impossible\");\n\tprintf(\"Possible\\n202 %d\\n\",cnt+200);\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n%d %d Y\\n\",i,i+1,i+101,i+102);\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d %d\\n\",es[i].s,es[i].t,es[i].w);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint A, B;\n\tint d[20][20];\n\n\tcin >> A >> B;\n\trep(i,A) rep(j,B) cin >> d[i][j];\n\n\tvector<pair<pii,int>> v;\n\tbool ok[20][20] = {};\n\trep(a,101) rep(b,101) rrep(c,101){\n\t\tbool f = true, check = false;\n\t\trep(i,A) rep(j,B){\n\t\t\tint s = a*(i+1) + b*(j+1) + c;\n\t\t\tif( d[i][j] > s ) f = false;\n\t\t\tif( d[i][j] == s ){\n\t\t\t\tok[i][j] = true;\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tif(f && check) v.emplace_back(pii(a,b), c);\n\t\tif(!f) break;\n\t}\n\n\tbool ans = true;\n\trep(i,A) rep(j,B) if( !ok[i][j] ) ans = false;\n\n\tif( !ans ){\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\n\tvector<pair<pii,int>> edge;\n\trep(i,100) edge.emplace_back( pii(i+1,i+2), -1 );\n\trep(i,100) edge.emplace_back( pii(200+i,200+i+1), -2 );\n\tint cnt = 0, pos = 203;\n\tfor(auto p: v){\n\t\tint a = p.X.X;\n\t\tint b = p.X.Y;\n\t\tint c = p.Y;\n\t\tedge.emplace_back( pii(a+1, 300-b), c );\n\t\t// if( a >= b ){\n\t\t// \tedge.emplace_back( pii(a+1,pos), -2 );\n\t\t// \trep(i,b-1){\n\t\t// \t\tedge.emplace_back( pii(pos,pos+1), -2 );\n\t\t// \t\tpos++;\n\t\t// \t}\n\t\t// \tedge.emplace_back( pii(pos,300), c );\n\t\t// }else{\n\t\t// \tedge.emplace_back( pii(102+b,pos), -1 );\n\t\t// \trep(i,a-1){\n\t\t// \t\tedge.emplace_back( pii(pos,pos+1), -1 );\n\t\t// \t\tpos++;\n\t\t// \t}\n\t\t// \tedge.emplace_back( pii(pos,300), c );\n\t\t// }\n\t}\n\n\tcout << 300 << \" \" << edge.size() << endl;\n\tfor(auto t: edge){\n\t\tcout << t.X.X << \" \" << t.X.Y << \" \";\n\t\tif( t.Y == -1 ) cout << \"X\" << endl;\n\t\telse if( t.Y == -2 ) cout << \"Y\" << endl;\n\t\telse cout << t.Y << endl;\n\t}\n\tcout << 1 << \" \" << 300 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,n)\tfor(int i=0;i<(int)n;i++)\n#define FOB(i,n)\tfor(int i=n;i>=1;i--)\n#define MP(x,y)\tmake_pair((x),(y))\n#define ii pair<int, int>\n#define lli long long int\n#define ulli unsigned long long int\n#define lili pair<lli, lli>\n#ifdef EBUG\n#define DBG\tif(1)\n#else\n#define DBG\tif(0)\n#endif\n#define SIZE(x) int(x.size())\nconst int infinity = 2000000999 / 2;\nconst long long int inff = 4000000000000000999;\n\ntypedef complex<long double> point;\n\ntemplate<class T>\nT get() {\n    T a;\n    cin >> a;\n    return a;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const pair<T, U> &par) {\n    out << \"[\" << par.first << \";\" << par.second << \"]\";\n    return out;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& out, const set<T> &cont){\n    out << \"{\";\n    for (const auto &x:cont) out << x << \", \";\n    out << \"}\";\n    return out;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& out, const map<T,U> &cont){\n    out << \"{\";\n    for (const auto &x:cont) out << x << \", \";\n    out << \"}\"; return out;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  FOR(i, v.size()){\n    if(i) out << \" \";\n    out << v[i];\n  }\n  out << endl;\n  return out;\n}\n\nbool ccw(point p, point a, point b){\n  if((conj(a - p) * (b - p)).imag() <= 0) return(0);\n  else return(1);\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    cout.sync_with_stdio(false);\n    \n    int a = get<int>();\n    int b = get<int>();\n    \n    vector<vector<int> > D(a, vector<int>(b));\n    int mx = 0;\n    FOR(i, a){\n        FOR(j, b) D[i][j] = get<int>();\n        FOR(j, b) mx = max(mx, D[i][j]);\n    }\n    \n    vector<vector<int> > minc(mx + 1, vector<int>(mx + 1, 0));\n    \n    FOR(i, mx + 1){\n        FOR(j, mx + 1){\n            FOR(l, a){\n                FOR(y, b){\n                    DBG cout << \"Pri : \" << i << \" * \" << l + 1 << \" + \" << j << \" * \" << y + 1 << \" + c = \" << D[l][y];\n                    minc[i][j] = max(minc[i][j], D[l][y] - (l + 1) * i - (y + 1) * j);\n                    DBG cout << \" => minc: \" << minc[i][j] << endl;\n                }\n            }\n        }\n    }\n    \n    DBG cout << \" \" << minc;\n    \n    vector<vector<ii> > ktore(a, vector<ii>(b, make_pair(-1, -1)));\n    set<ii> used;\n    \n    FOR(i, mx + 1){\n        FOR(j, mx + 1){\n            FOR(l, a){\n                FOR(y, b){\n                    if(minc[i][j] == D[l][y] - (l + 1) * i - (y + 1) * j){\n                        if(ktore[l][y].first == -1 || ktore[l][y].second + ktore[l][y].first > j + i){\n                            ktore[l][y] = {i, j};\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    FOR(i, a){\n        FOR(j, b){\n            if(ktore[i][j].first < 0){\n                DBG cout << \"Neda sa pripradit :( \" << i << \" a \" << j << endl;\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            DBG cout << \"Plati, ze \" << ktore[i][j] << \" x \" << i + 1 << \" | \" << j + 1 << \" budde rovne \" << endl;\n            used.insert(ktore[i][j]);\n        }\n    }\n    \n//     cout << \"Possible\" << endl;\n    int maxi = (--used.end())->first;\n    int n = maxi;\n    vector<pair<ii, int> > hrany;\n    FOR(i, maxi){\n        hrany.push_back({{i, i + 1}, -1});\n    }\n    vector<int> mxs(maxi + 1, 0);\n    vector<vector<int> > M(maxi + 1);\n    for(ii a : used){\n        mxs[a.first] = max(mxs[a.first], a.second);\n        M[a.first].push_back(a.second);\n    }\n    \n    int yps = 0;\n    \n    FOR(i, maxi + 1){\n        yps += mxs[i];\n        DBG cout << \"yps += \" << mxs[i] << endl;\n    }\n    \n    n += yps;\n    \n    n ++;\n    \n    if(n <= 300) cout << \"Possible\" << endl;\n    else{\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    \n    int v = maxi + 1;\n    \n    FOR(i, maxi + 1){\n        int f = v;\n        int last = i;\n        FOR(j, mxs[i]){\n            hrany.push_back({{last, v}, -2});\n            last = v;\n            v ++;\n        }\n        \n        for(int a : M[i]){\n            if(!a){\n                hrany.push_back({{i, n - 1}, minc[i][a]});\n            }\n            else{\n                if(f + a - 1 != n - 1) hrany.push_back({{f + a - 1, n - 1}, minc[i][a]});\n            }\n        }\n        \n    }\n    \n    cout << n << \" \" << hrany.size() << endl;\n    for(auto e : hrany){\n        cout << e.first.first + 1 << \" \" << e.first.second + 1 << \" \";\n        if(e.second < 0) cout << (e.second == -1 ? \"X\" : \"Y\") << endl;\n        else cout << e.second << endl;\n    }\n    \n    cout << 1 << \" \" << n << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 0; i < 100; i++) {\n        adj[ X(i) ].push_back(pii(X(i + 1), -1));\n    }\n    for(int i = 100; i >= 1; i--) {\n        adj[ Y(i) ].push_back(pii(Y(i - 1), -2));\n    }\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"%d\\n\", V);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                if(w == -1) printf(\"%d %d X\\n\", u + 1, v + 1);\n                else if(w == -2) printf(\"%d %d Y\\n\", u + 1, v + 1);\n                else printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n            }\n        }\n    }\n    \n    printf(\"%d %d\", src + 1, snk + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << 1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nnamespace QiFeng233{\n\tconst int maxn=310,matsiz=20,inf=0x3f3f3f3f;\n\tint A,B,d[matsiz][matsiz],f[maxn][maxn];\n\tint max(int a,int b){\n\t\treturn a>b?a:b;\t\t\n\t}\n\tint min(int a,int b){\n\t\treturn a<b?a:b;\n\t}\n\tvoid solve(){\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tfor(int i=1;i<=A;++i)\n\t\t\tfor(int j=1;j<=B;++j)\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\tfor(int i=0;i<=100;++i)\n\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\tfor(int x=1;x<=A;++x)\n\t\t\t\t\tfor(int y=1;y<=B;++y)\n\t\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\tfor(int x=1;x<=A;++x)\n\t\t\tfor(int y=1;y<=B;++y){\n\t\t\t\tint dxy=inf;\n\t\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\t\tdxy=min(dxy,i*x+j*y+f[i][j]);\n\t\t\t\tif(dxy!=d[x][y]){\n\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"202 10401\\n\");\n\t\tfor(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\t\tfor(int i=101;i<=201;++i)printf(\"%d %d Y\\n\",i,i+1);\n\t\tfor(int i=0;i<=100;++i)\n\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\tprintf(\"%d %d %d\\n\",1+i,202-j,f[i][j]);\n\t\tprintf(\"1 202\\n\");\n\t}\n}\nsigned main(){\n\tQiFeng233::solve();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?102+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",id(100,1),10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(100-j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",1,id(100,1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, m;\n\nint me[100][100];\nint D[11][11];\n\nint main()\n{\n\tread(n, m);\n\tfor(int i=0; i<=99; ++i) for(int j=0; j<=99; ++j) me[i][j] = 0;\n\t\n\tfor(int i=1; i<=n; ++i) for(int j=1; j<=m; ++j){\n\t\tint d; read(d);\n\t\tD[i][j]=d;\n\t\tfor(int a=0; a<=99; ++a) for(int b=0; b<=99; ++b){\n\t\t\tme[a][b] = max(me[a][b], d - i*a - j*b);\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=n; ++i) for(int j=1; j<=m; ++j){\n\t\tint cd = 1e9;\n\t\tfor(int a=0; a<=99; ++a) for(int b=0; b<=99; ++b){\n\t\t\tcd = min(cd, me[a][b] + i*a + j*b);\n\t\t}\n\t\tif(cd != D[i][j]){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 200, 100*100 + 99*2);\n\tfor(int i=2; i<=100; ++i) printf(\"%d %d X\\n\", i-1, i);\n\tfor(int i=101; i<200; ++i) printf(\"%d %d Y\\n\", i+1, i);\n\tfor(int a=0; a<=99; ++a) for(int b=0; b<=99; ++b){\n\t\tprintf(\"%d %d %d\\n\", 1+a, 101+b, me[a][b]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" x\" << endl;\n    REP(i,N-1) cout << 300-i << \" \" << 299-i << \" y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            v.push_back(F{i, j, k});\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n    int s = 0;\n    int t = 299;\n    vector<pii> e;\n    vector<int> c;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i, i + 1));\n        c.push_back(INT_MIN);\n    }\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i + YY, i + 1 + YY));\n        c.push_back(INT_MIN + 1);\n    }\n\n    for (const auto &f : v) {\n        e.push_back(make_pair(f.a, YY));\n        c.push_back(0);\n        e.push_back(make_pair(YY + f.b, t));\n        c.push_back(f.c);\n    }\n    cout << t + 1 << \" \" << e.size() << \"\\n\";\n    for (int i = 0; i < e.size(); ++i) {\n        cout << e[i].first + 1 << \" \" << e[i].second + 1 << \" \";\n        if (c[i] == INT_MIN) {\n            cout << \"X\";\n        } else if (c[i] == INT_MIN + 1) {\n            cout << \"Y\";\n        } else {\n            cout << c[i];\n        }\n        cout << \"\\n\";\n    }\n    cout << s + 1 << \" \" << t + 1 << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e5+10;\nconst int M=4e3+10;\n\nint n1,n2,w[12][12];\n\n\nint gw[205][205];\n\n\nvoid buildgraph(){\n        for(int u1=0;u1<=100;u1++)\n                for(int u2=0;u2<=100;u2++){\n                        int& rwei=gw[u1][201-u2];\n                        for(int w1=1;w1<=n1;w1++)\n                                for(int w2=1;w2<=n2;w2++)\n                                        rwei=max(rwei,w[w1][w2]-u1*w1-u2*w2);\n                }\n}\nint d[205];\nint dijkstra(int w1,int w2){\n        d[100]=200;\n        for(int i=101;i<=201;i++){\n                d[i]=d[i-1]+w2;\n                for(int u1=0;u1<=100;u1++) d[i]=min(d[i],gw[u1][i]+u1*w1);\n        }\n        return d[201];\n}\nint main(){\n        cin>>n1>>n2;\n        for(int i=1;i<=n1;i++)\n                for(int j=1;j<=n2;j++) cin>>w[i][j];\n        buildgraph();\n        for(int w1=1;w1<=n1;w1++)\n                for(int w2=1;w2<=n2;w2++){\n                        if (dijkstra(w1,w2)!=w[w1][w2]) {\n                                cout<<\"Impossible\";\n                                return 0;\n                        }\n        }\n        cout<<\"Possible\\n202 10401\\n\";\n        for(int i=1;i<=100;i++) cout<<i<<\" \"<<i+1<<\" X\\n\";\n        for(int i=102;i<=201;i++) cout<<i<<\" \"<<i+1<<\" Y\\n\";\n        for(int i=0;i<=100;i++)\n                for(int j=101;j<=201;j++) cout<<i+1<<\" \"<<j+1<<\" \"<<gw[i][j]<<'\\n';\n        cout<<\"1 202\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint A, B;\nint D[15][15], C[110][110];\nconst int N = 100;\nconst int V = (N+1)*2;\nconst int E = (N+1)*(N+1) + 2*N;\nconst int S = V-1, T = V;\n \nsigned main() {\n    cin >> A >> B;\n    repq(i,1,A) repq(j,1,B) cin >> D[i][j];\n\n    repq(a,0,N) repq(b,0,N) {\n        repq(x,1,A) repq(y,1,B) chmax(C[a][b], D[x][y] - a*x - b*y);\n    }\n\n    repq(x,1,A) repq(y,1,B) {\n        int cost = INF;\n        repq(a,0,N) repq(b,0,N) chmin(cost, a*x + b*y + C[a][b]);\n        if(cost != D[x][y]) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    printf(\"%lld %lld\\n\", V, E);\n    printf(\"%lld %lld X\\n\", S, 1LL);\n    printf(\"%lld %lld Y\\n\", S-1, T);\n    rep(i,1,N) printf(\"%lld %lld X\\n\", i, i+1);\n    rep(i,1,N) printf(\"%lld %lld Y\\n\", N+i, N+i+1);\n\n    repq(a,0,N) repq(b,0,N) {\n        int u = (a ? a   : S);\n        int v = (b ? S-b : T);\n        printf(\"%lld %lld %lld\\n\", u, v, C[a][b]);\n    }\n    printf(\"%lld %lld\\n\", S, T);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep(i,1,a){\n\t\tint mn=inf;\n\t\trep(j,2,b){\n\t\t\tint diff=d[i][j]-d[i][j-1];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\trep(j,1,b){\n\t\tint mn=inf;\n\t\trep(i,2,a){\n\t\t\tint diff=d[i][j]-d[i-1][j];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,102,200) add(i,i-1,inf+2);\n\trep(i,1,a){\n\t\trep(j,1,b){\n\t\t\tint kx=(i==a?0:d[i+1][j]-d[i][j]);\n\t\t\tint ky=(j==b?0:d[i][j+1]-d[i][j]);\n\t\t\tint idx=(!kx?s:kx),idy=(!ky?t:100+ky);\n\t\t\tint val=d[i][j]-kx*i-ky*j;\n\t\t\tadd(idx,idy,val);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"201 202\\n\");\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * a + (k + 1) * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 2, unus - (j + 2), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nbool P[101][101][101]; // X, Y, 1;\nstruct e {\n    int from, to, cost;\n};\n\nstruct edge {int to; ll cost;};\nstruct node {int pos; ll cost;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nvector<ll> dijkstra(vector<vector<edge>> &G, int root){\n    vector<ll> ret(G.size(), inf);\n    priority_queue<node> pq;\n    pq.push({root, 0});\n    while (!pq.empty()) {\n        node t = pq.top();\n        pq.pop();\n        \n        if (ret[t.pos] == inf) ret[t.pos] = t.cost;\n        else continue;\n        \n        for (edge e : G[t.pos]) {\n            pq.push({e.to, t.cost + e.cost});\n        }\n    }\n    return ret;\n}\n\n\nconst int N = 3;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> D(A, vector<int> (B));\n    rep(i, A) rep(j, B) cin >> D[i][j];\n    rep(i, N) rep(j, N) rep(k, 101) P[i][j][k] = 1;\n    rep(i, N) rep(j, N) rep(k, 101){\n        rep(a, A) rep(b, B){\n            if(D[a][b] > (a + 1) * i + (b + 1) * j + k) P[i][j][k] = 0;\n        }\n    }\n    \n    vector<e> ret;\n    rep(i, N) rep(j, N){\n        rep(k, 101) {\n            if(P[i][j][k]){\n                ret.pb({i, N * 2 + 1 - j, k});\n                break;\n            }\n        }\n    }\n    \n    rep(a, A) rep(b, B){\n        vector<vector<edge>> G(N * 2 + 2);\n        rep(i, N) G[i].pb({i + 1, a + 1});\n        rep(i, N) G[i + N + 1].pb({i + N + 2, b + 1});\n        for(auto e: ret) {\n            G[e.from].pb({e.to, e.cost});\n        }\n        \n        auto dist = dijkstra(G, 0);\n        if(dist[N * 2 + 1] != D[a][b]){\n            output(\"Impossible\");\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << N * 2 + 2 << \" \" << N * 2 + (int)ret.size() << endl;\n    \n    rep(i, N){\n        cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n    }\n    rep(i, N){\n        cout << i + N + 1 << \" \" << i + N + 2 << \" \" << \"Y\" << endl;\n    }\n    \n    for(auto e: ret) {\n        cout << e.from << \" \" << e.to << \" \" << e.cost << endl;\n    }\n    cout << 0 << \" \" << N * 2 + 1 << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t\tii=i;jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+a*b<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconstexpr int N = 100;\nconstexpr int INF = 1 << 30;\n\nvoid solve() {\n    int a, b;\n    std::cin >> a >> b;\n\n    auto ds = vec(a + 1, vec(b + 1, 0));\n    for (int x = 1; x <= a; ++x) {\n        for (int y = 1; y <= b; ++y) {\n            std::cin >> ds[x][y];\n        }\n    }\n\n    auto graph = vec(N + 1, vec(N + 1, 0));\n    for (int x = 1; x <= a; ++x) {\n        for (int y = 1; y <= b; ++y) {\n            auto d = ds[x][y];\n\n            for (int i = 0; i <= N; ++i) {\n                for (int j = 0; j <= N; ++j) {\n                    graph[i][j] = std::max(graph[i][j], d - x * i - y * j);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= a; ++x) {\n        for (int y = 1; y <= b; ++y) {\n            int dmin = INF;\n            for (int i = 0; i <= N; ++i) {\n                for (int j = 0; j <= N; ++j) {\n                    dmin = std::min(dmin, graph[i][j] + x * i + y * j);\n                }\n            }\n\n            if (dmin != ds[x][y]) {\n                std::cout << \"Impossible\" << std::endl;\n                return;\n            }\n        }\n    }\n\n    std::cout << \"Possible\" << std::endl;\n\n    std::cout << (N + 1) * 2 << \" \" << N * 2 + (N + 1) * (N + 1) << std::endl;\n    for (int v = 1; v <= N; ++v) {\n        std::cout << v << \" \" << v + 1 << \" X\" << std::endl;\n    }\n    for (int v = 1; v <= N; ++v) {\n        std::cout << N + 1 + v + 1 << \" \" << N + 1 + v << \" Y\" << std::endl;\n    }\n\n    for (int u = 0; u <= N; ++u) {\n        for (int v = 0; v <= N; ++v) {\n            std::cout << u + 1 << \" \" << N + 1 + v + 1 << \" \"\n                      << graph[u][v] << std::endl;\n        }\n    }\n\n    std::cout << 1 << \" \" << N + 2 << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip> // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple> // get<n>(xxx)\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set> // S.insert(M);\n// if (S.find(key) != S.end()) { }\n// for (auto it=S.begin(); it != S.end(); it++) { }\n// auto it = S.lower_bound(M);\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib> // atoi(xxx)\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n// insert #if<tab> by my emacs. #if DEBUG == 1 ... #end\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint A, B;\nint d[100][100];\nbool ok[100][100];\ntypedef tuple<int, int, int> path;\nvector<path> V;\n\nvoid answer() {\n  cout << 204 << \" \" << V.size() << endl;\n  for (auto x : V) {\n    cout << get<0>(x) << \" \" << get<1>(x) << \" \";\n    if (get<2>(x) == -1) {\n      cout << \"X\" << endl;\n    } else if (get<2>(x) == -2) {\n      cout << \"Y\" << endl;\n    } else {\n      cout << get<2>(x) << endl;\n    }\n  }\n  cout << 1 << \" \" << 204 << endl;\n}\n\nvoid add(int i, int j, int a) {\n  V.push_back(make_tuple(i+1, 204-j, a));\n}\n\nint main () {\n  cin >> A >> B;\n  for (auto i = 1; i <= A; ++i) {\n    for (auto j = 1; j <= B; ++j) {\n      cin >> d[i][j];\n      ok[i][j] = false;\n    }\n  }\n  for (auto i = 1; i <= 101; ++i) {\n    V.push_back(make_tuple(i, i+1, -1));\n  }\n  for (auto i = 103; i <= 203; ++i) {\n    V.push_back(make_tuple(i, i+1, -2));\n  }\n  for (auto i = 0; i <= 101; ++i) {\n    for (auto j = 0; j <= 101; ++j) {\n      int a = 0;\n      for (auto X = 1; X <= A; ++X) {\n        for (auto Y = 1; Y <= B; ++Y) {\n          a = max(a, d[X][Y] - i * X - j * Y);\n        }\n      }\n      add(i, j, a);\n      for (auto X = 1; X <= A; ++X) {\n        for (auto Y = 1; Y <= B; ++Y) {\n          if (d[X][Y] == a + i * X + j * Y) {\n            ok[X][Y] = true;\n          }\n        }\n      }\n    }\n  }\n  for (auto X = 1; X <= A; ++X) {\n    for (auto Y = 1; Y <= B; ++Y) {\n      if (!ok[X][Y]) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  answer();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 1002, M = 500000;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[M],st2[M],st3[M],a[N],b[N];\nbool mrk[M];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=210; t=211;\n\tif (n==1&&m==1) {\n\t\tputs(\"Possible\");\n\t\tprintf(\"2 1\\n\");\n\t\tprintf(\"1 2 %d\\n\",d[1][1]);\n\t\tprintf(\"1 2\");\n\t\treturn 0;\n\t}\n\t\n\t\n\trep(A,0,100) rep(B,0,100) {\n\t\tint mx=0;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-A*i-B*j);\n\t\trep(i,1,n) rep(j,1,m) if (d[i][j]-A*i-B*j==mx) ok[i][j]=1;\n\t\tC[A][B]=mx;\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\t\n\t\n\trep(i,0,100) a[i]=++sz;\n\trep(i,0,100) b[i]=++sz;\n\tst1[++tot]=s; st2[tot]=a[0]; st3[tot]=0;\n\tst1[++tot]=b[0]; st2[tot]=t; st3[tot]=0;\n\trep(i,0,99) {st1[++tot]=a[i]; st2[tot]=a[i+1]; st3[tot]=1; mrk[tot]=1;}\n\trep(i,0,99) {st1[++tot]=b[i+1]; st2[tot]=b[i]; st3[tot]=2; mrk[tot]=1;}\t\n\trep(i,0,100) rep(j,0,100) {st1[++tot]=a[i]; st2[tot]=b[j]; st3[tot]=C[i][j];}\n\t\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",211,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (!mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"210 211\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){ for (ll o=63, x=-1;;){ ll m=(o+x)/2; if (a<(1LL<<m))o=m; else x=m; if (o-x==1)return x; } }\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvdd Gauss_jordan(vvdd &A, vdd &b){\n\tll n = A.size();\n\tvvdd B(n, vdd(n+1));\n\tREP(i, n) REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n){\n\t\tll pivot = i;\n\t\tREPS(j, i, n-1) if (abs(B[pivot][i])<abs(B[j][i])) pivot=j;\n\t\tswap(B[i], B[pivot]);\n\t\tif (abs(B[i][i]) < EPS) return vdd();//解がないor一意でない\n\t\tREPS(j, i+1, n) B[i][j] /= B[i][i];\n\t\tREP(j, n) if (j!=i) REPS(k, i+1, n) B[j][k] -= B[j][i] * B[i][k];\n\t}\n\tvdd x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn move(x);\n}\n\n\nvoid solve()\n{\n\tll A, B;  cin >> A >> B;\n\tvector<vector<ll>> D = cinvv<ll>(A, B);\n\trep(i, 0, A-1){\n\t\tD[i].push_back(D[i].back());\n\t}\n\tD.emplace_back();\n\trep(j, 0, B-1){\n\t\tD[A].push_back(D[A-1][j]);\n\t}\n\tD[A].push_back(D[A].back());\n\n\tauto DD = [&](ll i, ll j)->ll&{\n\t\treturn D[i-1][j-1];\n\t};\n\n\tset<tll> buf;\n\n\trep(i, 1, A)rep(j, 1, B){\n\t\tvector<tuple<ll, ll, ll, ll, ll,ll>> tmp;\n\n\t\trep(k, 1, B){\n\t\t\ttmp.emplace_back(i,j, i,j+1, i+1,k);\n\t\t}\n\t\trep(k, 1, A){\n\t\t\ttmp.emplace_back(i,j, i+1,j, k,j+1);\n\t\t}\n\t\tif (j>=2) { tmp.emplace_back(i, j, i+1, j+1, i, j-1); }\n\t\tif (i>=2) { tmp.emplace_back(i, j, i+1, j+1, i-1, j); }\n\n\t\tbool kai=false;\n\t\tEACH(e, tmp){\n\t\t\tll I,J,II,JJ,III,JJJ;  tie(I, J, II, JJ,III,JJJ) = e;\n\t\t\tvvdd AA ={\n\t\t\t\t{(dd)I,  (dd)J,  1.},\n\t\t\t\t{(dd)II, (dd)JJ, 1.},\n\t\t\t\t{(dd)III,(dd)JJJ,1.}\n\t\t\t};\n\t\t\tvdd bb ={(dd)DD(I,J), (dd)DD(II,JJ), (dd)DD(III,JJJ)};\n\t\t\tvdd x = Gauss_jordan(AA, bb);\n\t\t\tif (x.empty()) continue;\n\t\t\tll a = (ll)(x[0]+.01);\n\t\t\tll b = (ll)(x[1]+.01);\n\t\t\tll c = (ll)(x[2]+.01);\n\t\t\tif (abs((dd)a-x[0])>EPS) continue;\n\t\t\tif (abs((dd)b-x[1])>EPS) continue;\n\t\t\tif (abs((dd)c-x[2])>EPS) continue;\n\t\t\tif (a<0 || b<0 || c<0) continue;\n\n\t\t\tbool isOK = true;\n\t\t\trep(ii, 1, A)rep(jj, 1, B){\n\t\t\t\tll f = a*ii+b*jj+c;\n\t\t\t\tif (DD(ii, jj) > f) isOK=false;\n\t\t\t}\n\t\t\tif (!isOK) continue;\n\t\t\tbuf.emplace(a, b, c);\n\t\t\tkai=true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!kai) bye(\"Impossible\");\n\t}\n\n\t//グラフ構成\n\tcout << \"Possible\" << '\\n';\n\tll N = 200;\n\tll M = 198+sz(buf);\n\tcout << N << \" \" << M << '\\n';\n\trep(i, 1, 99){\n\t\tcout << i << \" \" << i+1 << \" X\" << '\\n';\n\t}\n\trep(i, 101, 199){\n\t\tcout << i << \" \" << i+1 << \" Y\" << '\\n';\n\t}\n\tEACH(e, buf){\n\t\tll a; ll b; ll c;  tie(a, b, c) = e;\n\t\tcout << (a+1) << \" \" << (200-b) << \" \" << c << '\\n';\n\t}\n\tcout << \"1 200\" << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,inf);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tconst int v=150;\n\t\n\tint a,b;cin>>a>>b;\n\t\n\tvvc<int> lw(v,vi(v,0));\n\tvvc<int> buf(a+1,vi(b+1,0));\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint d;cin>>d;\n\t\tbuf[x][y]=d;\n\t\trep(i,v)rep(j,v){\n\t\t\tchmax(lw[i][j],d-i*x-(v-1-j)*y);\n\t\t}\n\t}\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint n=v*2;\n\t\tstruct E{int to,cost;};\n\t\tvvc<E> g(n);\n\t\trep(i,v-1)\n\t\t\tg[i].pb(E{i+1,x});\n\t\trep(i,v-1)\n\t\t\tg[v+i].pb(E{v+i+1,y});\n\t\trep(i,v)rep(j,v)\n\t\t\tg[i].pb(E{v+j,lw[i][j]});\n\t\tint d=dijkstra(g,0)[n-1];\n\t\tif(d!=buf[x][y]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\t\n\tint n=v*2;\n\tprint(n,2);\n\tprint((n-1)*2+v*v);\n\trep(i,v-1){\n\t\tcout<<i+1<<\" \"<<i+1+1<<\" X\\n\";\n\t}\n\trep(i,v-1){\n\t\tcout<<v+i+1<<\" \"<<v+i+1+1<<\" Y\\n\";\n\t}\n\trep(i,v)rep(j,v)\n\t\tcout<<i+1<<\" \"<<v+j+1<<\" \"<<lw[i][j]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n/*\nstruct point\n{\nlong long dist; long long name;\nbool operator<(const point& rhs) const {\nreturn dist > rhs.dist;\n}\n};\n*/\n\nll d[20][20];\nll color[20][20] = {};\nll a, b;\n\nvll ansx, ansy, ansc;\nll cnt = 2;\nll edge = 0;\nll flag = 0;\n\nbool check(ll i, ll j) {\n\tif (color[i][j] == 1) {\n\t\treturn 0;\n\t}\n\tll x = d[i + 1][j] - d[i][j];\n\tll y = d[i][j + 1] - d[i][j];\n\tll c = d[i][j] - x * i - y * j;\n\tcnt += ((c != 0) + x + y - 1);\n\tedge += (c != 0) + x + y;\n\tif (min({ x,y,c }) < 0) {\n\t\treturn 1;\n\t}\n\tREP(i_, 1, a) {\n\t\tREP(j_, 1, b) {\n\t\t\tif (d[i_][j_] == x * i_ + y * j_ + c) {\n\t\t\t\tcolor[i_][j_] = 1;\n\t\t\t}\n\t\t\telse if (d[i_][j_] > x*i_ + y * j_ + c) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tansx.push_back(x);\n\tansy.push_back(y);\n\tansc.push_back(c);\n\treturn 0;\n}\n\nint main() {\n\tcin >> a >> b;\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tREP(i, 1, a + 1) {\n\t\td[i][b + 1] = d[i][b];\n\t}REP(j, 1, b + 1) {\n\t\td[a + 1][j] = d[a][j];\n\t}\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tif(check(i, j)){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tll max_x = 0, max_y = 0;\n\tREP(i, 0, SIZE(ansx) - 1) {\n\t\tmax_x = max(max_x, ansx[i]);\n\t\tmax_y = max(max_y, ansy[i]);\n\t}\n\tll ver = max_x + max_y + 2;\n\tll edge = max_x + max_y + SIZE(ansx);\n\tcout << ver << \" \" << edge << endl;\n\tll cnt = 1;\n\tREP(i, 1, max_x) {\n\t\tcout << cnt << \" \" << cnt + 1 << \" X\" << endl;\n\t\tcnt++;\n\t}\n\tcnt++;\n\tREP(j, 1, max_y) {\n\t\tcout << cnt << \" \" << cnt + 1 << \" Y\" << endl;\n\t\tcnt++;\n\t}\n\tREP(i, 0, SIZE(ansx) - 1) {\n\t\tll x = ansx[i];\n\t\tll y = ansy[i];\n\t\tll c = ansc[i];\n\t\tcout << 1 + x << \" \" << ver - y << \" \" <<c << endl;\n\t}\n\tcout << 1 << \" \" << ver << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> d(A+1, vector<int>(B+1));\n    for(int i=1; i<=A; i++)\n        for(int j=1; j<=B; j++)\n            cin >> d[i][j];\n    vector<vector<int>> f(101, vector<int>(101, 0));\n    for(int a=0; a<=100; a++)\n        for(int b=0; b<=100; b++)\n            for(int x=1; x<=A; x++)\n                for(int y=1; y<=B; y++)\n                    f[a][b] = max(f[a][b], d[x][y]-a*x-b*y);\n\n    for(int x=1; x<=A; x++)\n        for(int y=1; y<=B; y++){\n            int tmp = 1<<30;\n            for(int a=0; a<=100; a++)\n                for(int b=0; b<=100; b++)\n                    tmp = min(tmp, f[a][b]+a*x+b*y);\n            if(tmp != d[x][y]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n\n    cout << \"Possible\" << endl;\n    int N = 202;\n    int M = 200 + 101*101;\n    vector<tuple<int, int, int>> edges;\n    for(int i=0; i<99; i++)\n        edges.push_back(make_tuple(i, i+1, -1));\n    for(int i=101; i<N-1; i++)\n        edges.push_back(make_tuple(i, i+1, -2));\n    for(int i=0; i<=100; i++)\n        for(int j=0; j<=100; j++)\n            edges.push_back(make_tuple(i, 201-j, f[i][j]));\n    cout << N << \" \" << M << endl;\n    for(auto e : edges){\n        int u, v, c;\n        tie(u, v, c) = e;\n        cout << u << \" \" << v << \" \";\n        if(c == -1) cout << \"X\" << endl;\n        else if(c == -2) cout << \"Y\" << endl;\n        else cout << c << endl;\n    }\n    cout << 1 << \" \" << N << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=210;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint A,B,n,D[N][N],d[N][N],G[N][N];\nint main()\n{\n\tfile();\n\tread(A),read(B);\n\tn=100;\n\tFor(i,1,A)For(j,1,B)read(d[i][j]);\n\tFor(i,0,n)\n\t\tFor(j,0,n)\n\t\t\tFor(a,1,A)\n\t\t\t\tFor(b,1,B)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"(%d %d %d %d) %d\\n\",i,j,a,b,d[a][b]-a*i-b*j);\n\t\t\t\t\tchkmax(D[i][j],d[a][b]-a*i-b*j);\n\t\t\t\t}\n\tFor(a,1,A)\n\t\tFor(b,1,B)\n\t\t{\n\t\t\tG[a][b]=inf;\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tchkmin(G[a][b],D[i][j]+a*i+b*j);\n\t\t\tif(G[a][b]!=d[a][b]){puts(\"Impossible\");exit(0);}\n\t\t}\n\tputs(\"Possible\");\n\tn=101;\n\tprintf(\"%d %d\\n\",2*n,n*n+2*n-2);\n\tFor(i,2,n)printf(\"%d %d %c\\n\",i-1,i,'X');\n\tFor(i,2,n)printf(\"%d %d %c\\n\",n+i,n+i-1,'Y');\n\tFor(i,1,n)For(j,1,n)printf(\"%d %d %d\\n\",i,j+n,D[i-1][j-1]);\n\tprintf(\"%d %d\\n\",1,n+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << \"202 10201\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tvvi c(110,vi(110));\n\trep(i,110)rep(j,110){\n\t\tint ma=0;\n\t\trep(k,n)rep(l,m)ma=max(ma,in[k][l]-i*(k+1)-j*(l+1));\n\t\tc[i][109-j]=ma;\n\t}\n\tbool h=true;\n\trep(i,n)rep(j,m){\n\t\tint mi=inf;\n\t\trep(k,110)rep(l,110)mi=min(mi,(i+1)*k+(j+1)*l+c[k][109-l]);\n\t\tif(mi!=in[i][j])h=false;\n\t}\n\t\n\tif(!h)cout<<\"Impossible\"<<endl;\n\telse{\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<\"220 \"<<218+110*110<<endl;\n\t\trep(i,109)cout<<1+i<<\" \"<<2+i<<\" X\"<<endl;\n\t\trep(i,109)cout<<219-i<<\" \"<<220-i<<\" Y\"<<endl;\n\t\trep(i,110)rep(j,110){\n\t\t\tcout<<1+i<<\" \"<<111+j<<\" \"<<c[i][j]<<endl;\n\t\t}\n\t\tcout<<\"1 220\"<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + H*W << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\tcout << 1 << \" \" << 201 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\t\t\td[0] = 0;\n\t\t\tpriority_queue<p>Q;\n\t\t\tQ.push({0,0});\n\t\t\twhile (Q.size()) {\n\t\t\t\tp t = Q.top(); Q.pop();\n\t\t\t\tif (d[t.second] < t.first)continue;\n\t\t\t\tfor (P u : V) {\n\t\t\t\t\tif (u.second.first == t.second) {\n\t\t\t\t\t\tint h = 0;\n\t\t\t\t\t\tif (u.first >= 0) {\n\t\t\t\t\t\t\th = u.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (u.first == -1) {\n\t\t\t\t\t\t\th = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { h = j + 1; }\n\t\t\t\t\t\tif (d[u.second.second] > t.first + h) {\n\t\t\t\t\t\t\td[u.second.second] = t.first + h;\n\t\t\t\t\t\t\tQ.push({t.first+h,u.second.second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first+1 << \" \" << i.second.second + 1 << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \" \" << i.first<< endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <iostream> \n#include <algorithm> \n#include <string> \n#include <vector> \n#include <stack> \n#include <queue> \n#include <deque> \n#include <set> \n#include <map> \n#include <tuple> \n  \nusing namespace std; \n  \nstruct lin \n{ \n    // aX + bY + c \n    int a, b, c; \n    bool operator <(const lin &l) const\n    { \n        return make_tuple(a, b, c) < make_tuple(l.a, l.b, l.c); \n    } \n    bool operator ==(const lin &l) const\n    { \n        return a == l.a && b == l.b; \n    } \n}; \n  \nvector<lin> res; \nint arr[15][15]; \n  \nint main() \n{ \n    //freopen(\"in\", \"r\", stdin); \n    //freopen(\"out\", \"w\", stdout); \n  \n    int p, q, i, j; \n    scanf(\"%d%d\", &p, &q); \n    for(i = 1; i <= p; i++) \n        for(j = 1; j <= q; j++) \n            scanf(\"%d\", &arr[i][j]); \n  \n    for(i = 1; i <= p; i++) \n    { \n        vector<pair<int, int>> tmp; \n        for(j = 1; j < q; j++) \n            tmp.push_back({ arr[i][j + 1] - arr[i][j], arr[i][j] - j * (arr[i][j + 1] - arr[i][j]) }); \n        if(q == 1) \n            tmp.push_back({ 0, arr[i][q] }); \n  \n        for(auto &l : tmp) \n        { \n            int t; \n            for(t = l.second / i; t >= 1; t--) \n            { \n                bool ok = 1; \n                for(int x = 1; x <= p; x++) \n                { \n                    for(int y = 1; y <= q; y++) \n                    { \n                        if(x * t + y * l.first + l.second - t * i < arr[x][y]) \n                        { \n                            ok = 0; \n                            break; \n                        } \n                    } \n                    if(!ok) \n                        break; \n                } \n                if(ok) \n                    break; \n            } \n            res.push_back({ t, l.first, l.second - t * i }); \n        } \n    } \n  \n    sort(res.begin(), res.end()); \n    res.erase(unique(res.begin(), res.end()), res.end()); \n  \n    int mxa, mxb; \n    mxa = mxb = 0; \n    for(lin &l : res) \n    { \n        if(l.a < 0 || l.b < 0 || l.c < 0 || l.c > 100) \n        { \n            printf(\"Impossible\\n\"); \n            return 0; \n        } \n  \n        mxa = max(mxa, l.a); \n        mxb = max(mxb, l.b); \n    } \n    if(mxa + mxb + 2 > 300) \n    { \n        printf(\"Impossible\\n\"); \n        return 0; \n    } \n  \n    for(i = 1; i <= p; i++) \n    { \n        for(j = 1; j <= q; j++) \n        { \n            int mn = 101; \n            for(lin &l : res) \n                mn = min(mn, l.a * i + l.b * j + l.c); \n  \n            if(mn != arr[i][j]) \n            { \n                printf(\"Impossible\\n\"); \n                return 0; \n            } \n        } \n    } \n  \n    int n, m; \n    n = mxa + mxb + 2; \n    m = mxa + mxb + (int)res.size(); \n  \n    printf(\"Possible\\n\"); \n    printf(\"%d %d\\n\", n, m); \n  \n    for(i = 1; i <= mxa; i++) \n        printf(\"%d %d X\\n\", i, i + 1); \n  \n    for(i = 1; i <= mxb; i++) \n        printf(\"%d %d Y\\n\", mxa + i + 1, mxa + i + 2); \n  \n    for(lin &l : res) \n        printf(\"%d %d %d\\n\", l.a + 1, mxa + mxb + 2 - l.b, l.c); \n  \n    printf(\"%d %d\\n\", 1, n); \n  \n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100&&k<100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + H * W << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\tcout << 1 << \" \" << 201 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int A, B;\n    cin >> A >> B;\n\n    vvi d(A + 1, vi(B + 1));\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++)\n            cin >> d[i][j];\n    }\n\n    vvi c(101, vi(101));\n    for (int xc = 0; xc <= 100; xc++) {\n        for (int yc = 0; yc <= 100; yc++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[xc][yc] = max(c[xc][yc], d[x][y] - xc * x - yc * y);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int sp = INT_MAX;\n            for (int xc = 0; xc <= 100; xc++) {\n                for (int yc = 0; yc <= 100; yc++) {\n                    sp = min(sp, xc * x + yc * y + c[xc][yc]);\n                }\n            }\n            if (sp != d[x][y]) { cout << \"Impossible\\n\"; return 0; }\n        }\n    }\n\n    int SRC = 1, XL = SRC + 1, YL = XL + 101, SNK = YL + 101;\n    int V = SNK, E = 101 + 101 + 101 * 101;\n\n    cout << \"Possible\\n\";\n    cout << V << \" \" << E << \"\\n\";\n    for (int xc = 0; xc <= 100; xc++)\n        cout << (xc ? XL + xc - 1 : SRC) << \" \" << (XL + xc) << \" X\\n\";\n    for (int yc = 0; yc <= 100; yc++)\n        cout << (YL + yc) << \" \" << (yc + 1 <= 100 ? YL + yc + 1 : SNK) << \" Y\\n\";\n    for (int xc = 0; xc <= 100; xc++)\n        for (int yc = 0; yc <= 100; yc++)\n            cout << (XL + xc) << \" \" << (YL + yc) << \" \" << c[xc][yc] << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nvector <int> dv;\nvector <int> av;\nvector <int> bv;\nint mn, mx;\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nvoid reconstruct(int x1, int y1, int c1, int x2, int y2, int c2) {\n  puts(\"Possible\");\n  // cerr << x1 << \" \" << y1 << \" \" << c1 << \" \" << x2 << \" \" << y2 << \" \" << c2 << endl;\n  int mxX = max(x1, x2);\n  int mxY = max(y1, y2);\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= mxX; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= mxY; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  addEdge(2 + x1, n - 1 - y1, c1);\n\n  if (x2 != -1) {\n    addEdge(2 + x2, n - 1 - y2, c2);\n  }\n\n  addEdge(1, n, mx);\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  exit(0);\n}\n\nvoid go(int x1, int y1, int c1, int pos) {\n  if (pos == sz(dv)) {\n    reconstruct(x1, y1, c1, -1, -1, -1);\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 < dv[pos]) {\n    return;\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 == dv[pos] || dv[pos] == mx) {\n    go(x1, y1, c1, pos + 1);\n  }\n  for (int x2 = 0; x2 <= 100; x2++) {\n    if (av[pos] * x2 > dv[pos]) {\n      continue;\n    }\n    for (int y2 = 0; y2 <= 100; y2++) {\n      if (av[pos] * x2 + bv[pos] * y2 > dv[pos]) {\n        continue;\n      }\n      // if (x2 == 0 && y2 == 0 && dv[pos] != mx) {\n      //   continue;\n      // }\n      int c2 = dv[pos] - (av[pos] * x2 + bv[pos] * y2);\n      bool good = true;\n      for (int i = pos; i < sz(dv); i++) {\n        if (!(x2 * av[i] + y2 * bv[i] + c2 == dv[i] || \n              x1 * av[i] + y1 * bv[i] + c1 == dv[i] ||\n              dv[i] == mx)) {\n          good = false;\n          break;\n        }\n        if (x1 * av[i] + y1 * bv[i] + c1 < dv[i] || x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (!good) {\n        continue;\n      }\n      for (int i = 0; i < pos; i++) {\n        if (x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        reconstruct(x1, y1, c1, x2, y2, c2);\n      }\n    }\n  }\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  mx = -1, mn = 105;\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n      mn = min(mn, d[i][j]);\n      mx = max(mx, d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      if (j > 0 && d[i][j] < d[i][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n      if (i > 0 && d[i][j] < d[i - 1][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  if (mn == mx) {\n    puts(\"Possible\");\n    cout << 2 << \" \" << 1 << endl;\n    cout << 1 << \" \" << 2 << \" \" << mx << endl;\n    cout << 1 << \" \" << 2 << endl;\n    return 0;\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      dv.push_back(d[i][j]);\n      av.push_back(i + 1);\n      bv.push_back(j + 1);\n    }\n  }\n\n  for (int x1 = 0; x1 <= 100; x1++) {\n    if (1 * x1 > d[0][0]) {\n      continue;\n    }\n    for (int y1 = 0; y1 <= 100; y1++) {\n      if (1 * x1 + 1 * y1 > d[0][0]) {\n        continue;\n      }\n      if (x1 == 0 && y1 == 0 && d[0][0] != mx) {\n        continue;\n      }\n      int c1 = d[0][0] - x1 - y1;\n      go(x1, y1, c1, 0);\n    }\n  }\n\n  puts(\"Impossible\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, m;\n\nconst int Z = 100;\n\nint me[Z][Z];\nint D[11][11];\n\nint main()\n{\n\tread(n, m);\n\t\n\tfor(int i=1; i<=n; ++i) for(int j=1; j<=m; ++j){\n\t\tint d; read(d);\n\t\tD[i][j]=d;\n\t\tfor(int a=0; a<=Z-1; ++a) for(int b=0; b<=Z-1; ++b){\n\t\t\tme[a][b] = max(me[a][b], d - i*a - j*b);\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=n; ++i) for(int j=1; j<=m; ++j){\n\t\tint cd = 1e9;\n\t\tfor(int a=0; a<=Z-1; ++a) for(int b=0; b<=Z-1; ++b){\n\t\t\tcd = min(cd, me[a][b] + i*a + j*b);\n\t\t}\n\t\tif(cd != D[i][j]){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", Z*2, Z*Z + (Z-1)*2);\n\tfor(int i=2; i<=Z; ++i) printf(\"%d %d X\\n\", i-1, i);\n\tfor(int i=Z+1; i<Z*2; ++i) printf(\"%d %d Y\\n\", i+1, i);\n\tfor(int a=0; a<=Z-1; ++a) for(int b=0; b<=Z-1; ++b){\n\t\tprintf(\"%d %d %d\\n\", 1+a, Z+1+b, me[a][b]);\n\t}\n\tprintf(\"%d %d\\n\", 1, Z+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MAXN 15\n#define MAXT 100\n\nconst int inf=0x3f3f3f3f;\n\nint n,m,d[MAXN][MAXN],f[MAXT+5][MAXT+5];\n\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=MAXT;i++){\n        for(int j=0;j<=MAXT;j++){\n            int mx=0;\n            for(int ii=1;ii<=n;ii++){\n                for(int jj=1;jj<=m;jj++){\n                    if(mx<d[ii][jj]-ii*i-jj*j)\n                        mx=d[ii][jj]-ii*i-jj*j;\n                }\n            }\n            f[i][j]=mx;\n        }\n    }\n    int psb=1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            int mn=inf;\n            for(int ii=0;ii<=MAXT;ii++){\n                for(int jj=0;jj<=MAXT;jj++){\n                    if(mn>f[ii][jj]+ii*i+jj*j)\n                        mn=f[ii][jj]+ii*i+jj*j;\n                }\n            }\n            if(d[i][j]!=mn){\n                psb=0;\n                break;\n            }\n        }\n        if(!psb){\n            break;\n        }\n    }\n    if(!psb){\n        printf(\"Impossible\\n\");\n    }\n    else{\n        printf(\"Possible\\n\");\n        printf(\"%d %d\\n\",2*MAXT+4,2*MAXT+4+MAXT*MAXT);\n        printf(\"%d %d 0\\n\",2*MAXT+3,1);\n        printf(\"%d %d 0\\n\",2*MAXT+3,MAXT+2);\n        printf(\"%d %d 0\\n\",MAXT+1,2*MAXT+4);\n        printf(\"%d %d 0\\n\",2*MAXT+2,2*MAXT+4);\n        for(int i=1;i<=MAXT;i++){\n            printf(\"%d %d X\\n\",i,i+1);\n        }\n        for(int j=1;j<=MAXT;j++){\n            printf(\"%d %d Y\\n\",MAXT+1+j,MAXT+1+j+1);\n        }\n        for(int i=0;i<=MAXT;i++){\n            for(int j=0;j<=MAXT;j++){\n                printf(\"%d %d %d\\n\",i+1,2*MAXT+2-j,f[i][j]);\n            }\n        }\n        printf(\"%d %d\\n\",2*MAXT+3,2*MAXT+4);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY){\n\t\t\tint Now = 0;\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tNow = max(Now, D[X][Y] - numX * X - numY * Y);\n\t\t\tF[numX][numY] = Now;\n\t\t}\n\tM = 200;\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J])\n\t\t\t\t++M;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossilble\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J){\n\t\t\tif(F[I][100 - J]){\n\t\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\t\t\t}\n\t\t}\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef std::pair<int,int> P;\n#define mk std::make_pair\n#define fr first\n#define sc second\ninline int in()\n{\n\tint k=0;char ch=gt;bool p=1;\n\twhile(ch<'-')ch=gt;if(ch=='-')ch=gt,p=0;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn p?k:-k;\n}\nconst int N=105;\nint f[N][N],d[N][N];\nint main()\n{\n\tint n=in(),m=in();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\td[i][j]=in();\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tfor(int a=1;a<=n;++a)\n\t\t\t\tfor(int b=1;b<=m;++b)\n\t\t\t\t\tf[i][j]=std::max(f[i][j],d[a][b]-a*i-b*j);\n\tfor(int a=1;a<=n;++a)\n\t\tfor(int b=1;b<=m;++b)\n\t\t{\n\t\t\tint mi=1e9;\n\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\tmi=std::min(mi,f[i][j]+a*i+b*j);\n\t\t\tif(mi!=d[a][b])return puts(\"Impossible\"),0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=1;i<=100;++i)printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int S = 198, T = 199;\n\txv.push_back(S);\n\tFOR(i, 99) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, 99) yv.push_back(i + 99);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int, int, int>> vp;\n\tFOR(i, 100) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(i, a) FOR(j, b) {\n\t\tint minad = 12345;\n\t\tint cxw = minx[i][j], cyw = miny[i][j];\n\t\tfor (int w = minx[i][j]; w <= 100; w++) {\n\t\t\tfor (int z = miny[i][j]; z <= 100; z++) {\n\t\t\t\tint xw = w * (i + 1);\n\t\t\t\tint yw = z * (j + 1);\n\t\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\t\tif (additional < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (additional < minad) {\n\t\t\t\t\tminad = additional;\n\t\t\t\t\tcxw = w;\n\t\t\t\t\tcyw = z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minad == 12345) {\n\t\t\tok = false;\n\t\t\tcontinue;\n\t\t}\n\t\tint from = xv[cxw], to = yv[100 - cyw];\n\t\t// printf(\"%d %d %d\\n\", cxw, cyw, minad);\n\t\tvp.emplace_back(from, to, minad);\n\t}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(200);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", 200, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S + 1, T + 1);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[550];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 550; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 110;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = 1<<29;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  if (chmin(se, tse)) {\n\t\t\t\tdx = tdx, dy = tdy, se = tse;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (dx == -1) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\t/*\n\t\tint p = se / 100;\n\t\tint q = se % 100;\n\t\tG.resize(G.size() + p);\n\t\tG[dx].push_back(pint(t-dy, se));\n\t\t*/\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\t\n\t\tputs(\"Possible\");\n\n\t\tset<pair<int,pint> > S;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (auto e : G[i]) {\n\t\t\tS.insert(make_pair(i, e));\n\t\t  }\n\t\t}\n\t\t\n\t\tcout << G.size() << \" \" << S.size() << endl;\n\t\tfor (set<pair<int,pint> >::iterator it = S.begin(); it != S.end(); ++it) {\n\t\t  int from = (*it).first;\n\t\t  int to = (*it).second.first;\n\t\t  int w = (*it).second.second;\n\t\t  cout << from+1 << \" \" << to+1 << \" \";\n\t\t  if (w == -1) cout << \"X\";\n\t\t  else if (w == -2) cout << \"Y\";\n\t\t  else cout << w;\n\t\t  cout << endl;\n\t\t}\n\t\tcout << s+1 << \" \" << t+1 << endl;\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      f[i][j] = inf;\n      rep(x, a){\n        rep(y, b){\n          chmin(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n      if(f[i][j] < 0)f[i][j] = 0;\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"201 10400\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<=200;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,201-j,f[i][j]);\n\tprintf(\"1 201\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint A, B;\nint d[20][20];\n\nint N, M;\nint cost[101][101];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> A >> B;\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) cin >> d[x][y];\n\n    N = 202;\n    M = 41004;\n\n    rep(i, 101) rep(j, 101) FOR(x, 1, A + 1) FOR(y, 1, B + 1)\n        chmax(cost[i][j], d[x][y] - i * x - j * y);\n\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) {\n        int mn = 1 << 30;\n        rep(i, 101) rep(j, 101) chmin(mn, x * i + y * j + cost[i][j]);\n        if(mn != d[x][y]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    cout << N << \" \" << M << \"\\n\";\n\n    rep(i, 100) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    rep(j, 100) cout << A + j + 2 << \" \" << A + j + 3 << \" Y\\n\";\n\n    rep(i, 101) rep(j, 101) cout << i + 1 << \" \" << N - j << \" \" << cost[i][j]\n                                 << \"\\n\";\n\n    cout << \"1 \" << N << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY){\n\t\t\tint Now = 0;\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tNow = max(Now, D[X][Y] - numX * X - numY * Y);\n\t\t\tF[numX][numY] = Now;\n\t\t}\n\tM = 200;\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J])\n\t\t\t\t++M;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J){\n\t\t\tif(F[I][100 - J]){\n\t\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\t\t\t}\n\t\t}\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\n#define mp make_pair\n#define pb push_back\n#define ld long double\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\n#define piii pair<pii,pii>\n#define precise cout<<fixed<<setprecision(10)\n#define st first\n#define nd second\n#define ins insert\n#define vi vector<int>\n#define BOOST ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\nusing namespace std;\nconst int MAX=105;\nconst int inf=1e9+9;\nint tab[MAX][MAX];\nint f[MAX][MAX];\nint32_t main()\n{\n  BOOST;\n  int n,m;\n  cin>>n>>m;\n  for (int i=1;i<=n;i++)\n  \tfor (int j=1;j<=m;j++)\n  \t\tcin>>tab[i][j];\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n       for (int k=1;k<=n;k++)\n         for (int l=1;l<=m;l++)\n           f[i][j]=max(f[i][j],tab[k][l]-i*k-j*l);\n           \n  for (int i=1;i<=n;i++)\n    for (int j=1;j<=m;j++)\n    {\n    \tint mini=inf;\n    \tfor (int k=0;k<=100;k++)\n    \t  for (int l=0;l<=100;l++)\n    \t    mini=min(mini,f[k][l]+i*k+j*l);\n    \tif (mini!=tab[i][j])cout<<\"Impossible\",exit(0);\n    }\n   \n    cout<<\"Possible\\n\";\n  cout<<\"202 \"<<\"10401\\n\";\n  for (int i=1;i<=100;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"X\"<<\"\\n\";\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n      cout<<i+1<<\" \"<<202-j<<\" \"<<f[i][j]<<\"\\n\";\n  for (int i=101;i<=201;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"Y\"<<\"\\n\";\n  cout<<\"1 \"<<\"202\";\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint n,m,cnt,ans;\nint w[110][110],v[110][110];\nbool flag=1,fl;\nint main()\n{\n\t//freopen(\"ans.txt\",\"w\",stdout);\n\tint i,s,a,b,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\tfor(s=1;s<=m;s++)\n\t{\n\t\tscanf(\"%d\",&w[i][s]);\n\t\tfor(k=0;k<=100;k++)\n\t\tfor(j=0;j<=100;j++)v[k][j]=max(v[k][j],w[i][s]-i*k-s*j);\n\t}\n\tfor(i=1;i<=n && flag;i++)\n\tfor(s=1;s<=m && flag;s++)\n\t{\n\t\tfl=0;\n\t\tfor(k=0;k<=100 && !fl;k++)\n\t\tfor(j=0;j<=100 && !fl;j++)\n\t\t\tif(v[k][j]+i*k+s*j==w[i][s])fl=1;\n\t\tif(!fl)flag=0;\n\t}\n\tif(!flag){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n202 41004\\n\");\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1),printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(i=0;i<=100;i++)\n\tfor(s=0;s<=100;s++)printf(\"%d %d %d\\n\",1+i,102+s,v[i][s]);\n\tprintf(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define max(a, b) (((a)<(b))?b:a)\n#define min(a, b) ((a>b)?b:a)\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pi 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define maxlg 18\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\n#define maxn 2006\nint a,b;\nint d[26][26];\nint f[105][105];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n    \n#endif\n    cin>>a>>b;\n    rep (i,0,a)\n        rep (j,0,b)\n            cin>>d[i+1][j+1];\n\n    rep (i,0,100+1)\n        rep (j,0,100+1)\n            rep (x,1,a+1)\n                rep (y,1,b+1) {\n                    f[i][j] = max(f[i][j],d[x][y]-i*x-j*y);\n                }\n\n    rep (x,1,a+1)\n        rep (y,1,b+1) {\n            int dist = 1e9;\n            rep (i,0,100+1)\n                rep (j,0,100+1) {\n                    dist= min(dist,f[i][j]+i*x +j*y);\n                }\n            if (dist!=d[x][y]){\n                cout<<\"Impossible\";\n                return 0;\n            }\n        }\n    cout<<\"Possible\\n\";\n    vector<string>  ans;\n    rep (i,1,102) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" X\\n\");\n        rep (j,102,203) {\n            ans.push_back(to_string(i)+ \" \"+to_string(j)+\" \"+ to_string(f[i-1][202-j])+\"\\n\");\n        }\n    }\n    rep (i,102,203) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" Y\\n\");\n    }\n    cout<<202<<\" \"<<ans.size()<<endl;\n    rep (i,0,ans.size()) {\n        cout<<ans[i];\n    }\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ 0,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\n\t\t}\n\t}\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tfreopen(\"tmp.out\",\"w\",stdout);\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"201 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<202;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int inf = (1 << 30) - 1;\nconstexpr int d_max = 100;\nconstexpr int V = 2 * (d_max + 1);\nconstexpr int S = 0, T = V - 1;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  std::array<std::array<int, d_max + 1>, d_max + 1> cost{};\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      for (int a: range(0, d_max + 1)) {\n        for (int b: range(0, d_max + 1)) {\n          chmax(cost[a][b], dist[i][j] - (i + 1) * a - (j + 1) * b);\n        }\n      }\n    }\n  }\n  std::array<std::pair<int, int>, d_max> Xs{};\n  std::array<std::pair<int, int>, d_max> Ys{};\n  for (int i: range(0, d_max)) {\n    Xs[i] = { i, i + 1 };\n    Ys[i] = { V - i - 2, V - i - 1 };\n  }\n  auto calc = [&](int x, int y) {\n    std::array<std::vector<std::pair<int, int>>, V> graph{};\n    for (int i: range(0, d_max)) {\n      graph[Xs[i].first].emplace_back(Xs[i].second, x);\n      graph[Ys[i].first].emplace_back(Ys[i].second, y);\n    }\n    for (int i: range(0, d_max + 1)) {\n      for (int j: range(0, d_max + 1)) {\n        if (cost[i][j] <= d_max) {\n          graph[i].emplace_back(V - j - 1, cost[i][j]);\n        }\n      }\n    }\n    std::array<int, V> length{};\n    length.fill(inf);\n    length[S] = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(length[S], S);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > length[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(length[e.first], length[v] + e.second)) {\n          que.emplace(length[e.first], e.first);\n        }\n      }\n    }\n    return length[T];\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (dist[i][j] != calc(i + 1, j + 1)) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  std::cout << \"Possible\\n\";\n  int E = 2 * d_max;\n  for (const auto &arr: cost) {\n    for (auto x: arr) {\n      if (x <= d_max) {\n        ++E;\n      }\n    }\n  }\n  std::cout << V << ' ' << E << '\\n';\n  for (auto e: Xs) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" X\\n\";\n  }\n  for (auto e: Ys) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (cost[i][j] <= d_max) {\n        std::cout << i + 1 << ' ' << V - j << ' ' << cost[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << S + 1 << ' ' << T + 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Ralif Rakhmatullin\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cstring>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<valarray>\n#include<iterator>\n#include<list>\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define S second\n#define ld long double\n#define F first\n#define y1 LOL\n#define ld long double\n#define pb push_back\n#define len length\n#define sz size\n#define beg begin\nconst ll INF = (ll)1e18 + 123;\nconst int inf=(int)2e9 + 123; \nconst int mod=1e9+7;\nusing namespace std;\nint n, A, B, d[21][21], f[111][111];\nint main(){\n\tunsigned int FOR;\n \tasm(\"rdtsc\" : \"=A\"(FOR));\n  \tsrand(FOR);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout.tie(0);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i ++){\n\t\tfor(int j = 1; j <= B; j ++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tint n = 1;\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tfor(int a = 1; a <= A; a ++){\n\t\t\t\tfor(int b = 1; b <= B; b ++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[a][b] - a * i - b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int a = 1; a <= A; a ++){\n\t\tfor(int b = 1; b <= B; b ++){\n\t\t\tint res = inf;\n\t\t\tfor(int i = 0; i <= 100; i ++){\n\t\t\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\t\t\tres = min(res, f[i][j] + a * i + b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res != d[a][b]){\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tint s = 1, t = 202;\n\tcout << t << \" \" << 101 * 101 + 200 << endl;\n\tfor(int i = 2; i <= 101; i ++){\n\t\tcout << i - 1 << \" \" << i << \" X\\n\";\n\t}\n\tfor(int i = 103; i <= t; i ++){\n\t\tcout << i - 1 << \" \" << i << \" Y\\n\";\n\t}\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tcout << i + 1 << \" \" << t - j << \" \" << f[i][j] << endl;\n\t\t}\n\t}\n\tcout << s << \" \" << t;\n\treturn 0;\n}                     "
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll A, B;\n    cin >> A >> B;\n    vector<vector<ll>> d(A + 1, vector<ll>(B + 1));\n    for (ll i = 1; i <= A; i++) {\n        for (ll j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    constexpr ll MAX = 100;\n    vector<vector<ll>> f(MAX + 1, vector<ll>(MAX + 1, 0));\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            for (ll x = 1; x <= A; x++) {\n                for (ll y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n\n    for (ll x = 1; x <= A; x++) {\n        for (ll y = 1; y <= B; y++) {\n            ll D = LLONG_MAX;\n            for (ll a = 0; a <= MAX; a++) {\n                for (ll b = 0; b <= MAX; b++) {\n                    D = min(D, x * a + y * b + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    const ll N = (MAX + 1) * 2;\n    const ll M = MAX * (MAX + 2) + 2 * MAX + 1;\n    cout << N << \" \" << M << endl;\n    for (ll i = 1; i <= MAX; i++) {\n        cout << i << ' ' << i + 1 << \" X\" << endl;\n    }\n    for (ll i = 1; i <= MAX; i++) {\n        cout << i + MAX + 1 << ' ' << i + MAX + 2 << \" Y\" << endl;\n    }\n\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            cout << a + 1 << ' ' << b + 102 << ' ' << f[a][MAX - b] << endl;\n        }\n    }\n\n    cout << \"1 202\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=101;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,2*maxn-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x_max;\n  int y_max;\n  cin >> x_max >> y_max;\n\n  auto d_matrix = Make2DVector(x_max + 1, y_max + 1, 0);\n  for (int x = 1; x <= x_max; x++) {\n    for (int y = 1; y <= y_max; y++) {\n      cin >> d_matrix[x][y];\n    }\n  }\n\n  auto c_matrix = Make2DVector(100 + 1, 100 + 1, 0);\n  for (int a = 0; a <= 100; a++) {\n    for (int b = 0; b <= 100; b++) {\n      for (int x = 1; x <= x_max; x++) {\n        for (int y = 1; y <= y_max; y++) {\n          UpdateMax(c_matrix[a][b], d_matrix[x][y] - a * x - b * y);\n        }\n      }\n    }\n  }\n\n  auto check_fn = [&]() -> bool {\n    for (int x = 1; x <= x_max; x++) {\n      for (int y = 1; y <= y_max; y++) {\n        int d = INT32_MAX;\n        for (int a = 0; a <= 100; a++) {\n          for (int b = 0; b <= 100; b++) {\n            UpdateMin(d, a * x + b * y + c_matrix[a][b]);\n          }\n        }\n        // cout << d << endl;\n        if (d > d_matrix[x][y]) return false;\n      }\n    }\n    return true;\n  };\n\n  if (!check_fn()) {\n    cout << \"Impossible\" << endl;\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 100 + 100 + 101 * 101 << endl;\n  for (int i = 0; i <= 100; i++) {\n    cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n  }\n  for (int i = 0; i <= 100; i++) {\n    cout << 101 + i << \" \" << 101 + i + 1 << \" \" << \"Y\" << endl;\n  }\n  for (int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      cout << 1 + a << \" \" << 202 - b << \" \" << c_matrix[a][b] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define max(a,b) ((a>b)?a:b)\n#define min(a,b) ((a<b)?a:b)\nusing namespace std;\nnamespace fio {\n\tstreambuf* in = cin.rdbuf();\n\tchar bb[1000000], * s = bb, * t = bb;\n#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)\n\tinline int read() {\n\t\tint x = 0;\n\t\tchar ch = gc();\n\t\twhile (ch < 48)ch = gc();\n\t\twhile (ch >= 48)x = x * 10 + ch - 48, ch = gc();\n\t\treturn x;\n\t}\n}using fio::read;\nint n, m;\nint arr[15][15];\nint dp[305][305];\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++)for (int u = 1; u <= m; u++)arr[i][u] = read();\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)for (int x = 1; x <= n; x++)for (int y = 1; y <= m; y++)dp[i][u] = max(dp[i][u], arr[x][y] - i * x - u * y);\n\tfor (int x = 0; x <= n; x++)for (int y = 0, now = 0x7fffffff; y <= m; now = 0x7fffffff, y++) {\n\t\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)\n\t\t\tnow = min(now, dp[i][u] + i * x + u * y);\n\t\tif (now != arr[x][y])cout << \"Impossible\", exit(0);\n\t}\n\tputs(\"Possible\"), puts(\"202 10401\");\n\tfor (int i = 1; i <= 201; i++)if (i != 101)cout << i << ' ' << i + 1 << ' ' << (i <= 100 ? 'X' : 'Y') << endl;\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)printf(\"%d %d %d\\n\", i + 1, 202 - u, dp[i][u]);\n\tcout << 1 << ' ' << 202;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  std::cout << \"Possible\\n\";\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, d[102][102], a, b, ok[102][102];\nstruct skrr {\n  int i, j, c;\n} v[20002];\n\nint main()\n{\n  cin >> a >> b;\n  for (int i = 1; i <= a; i++)\n    for (int j = 1; j <= b; j++)\n      cin >> d[i][j];\n  for (int i = 0; i <= 100; i++)\n    for (int j = 0; j <= 100; j++) {\n      int mx = 0;\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          mx = max (mx, d[x][y] - i * x - j * y);\n      v[++m] = {i + 1, 202 - j, mx};\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          if (mx + i * x + j * y == d[x][y])\n            ok[x][y] = 1;\n    }\n  for (int x = 1; x <= a; x++)\n    for (int y = 1; y <= b; y++)\n    if (!ok[x][y]) {\n      cout << \"Impossible\";\n      return 0;\n    }\n  cout << \"Possible\\n\";\n  cout << \"202 \" << m + 200 << \"\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i << \" \" << i + 1 << \" X\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i + 101 << \" \" << i + 102 << \" Y\\n\";\n  for (int i = 1; i <= m; i++)\n    cout << v[i].i << \" \" << v[i].j << \" \" << v[i].c << \"\\n\";\n  cout << \"1 202\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=210;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\nint A,B,n,D[N][N],d[N][N],G[N][N];\nint main()\n{\n\tfile();\n\tread(A),read(B);\n\tn=101;\n\tFor(i,1,A)For(j,1,B)read(d[i][j]);\n\tFor(i,1,n)\n\t\tFor(j,1,n)\n\t\t\tFor(a,1,A)\n\t\t\t\tFor(b,1,B)\n\t\t\t\t\tchkmax(D[i][j],d[a][b]-a*(i-1)-b*(j-1));\n\tFor(a,1,A)\n\t\tFor(b,1,B)\n\t\t{\n\t\t\tG[a][b]=inf;\n\t\t\tFor(i,1,n)\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tchkmin(G[a][b],D[i][j]+a*(i-1)+b*(j-1));\n\t\t\tif(G[a][b]!=d[a][b]){puts(\"Impossible\");exit(0);}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",2*n,n*n+2*n-2);\n\tFor(i,2,n)printf(\"%d %d %c\\n\",i-1,i,'X');\n\tFor(i,2,n)printf(\"%d %d %c\\n\",n+i-1,n+i,'Y');\n\tFor(i,1,n)For(j,1,n)printf(\"%d %d %d\\n\",i,j+n,D[i][j]);\n\tprintf(\"%d %d\\n\",1,2*n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nconst int MAXA = 17;\n\nint D[MAXA][MAXA], C[MAXA][MAXA];\nvector <pair <PII, int> > E;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint a, b, n = 202;\n\tcin >> a >> b;\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tcin >> D[i][j];\n\t\tC[i][j] = INF;\n\t}\n\tREP(c1, 101)\n\t\tREP(c2, 101)\n\t\tREP(c3, 101)\n\t{\n\t\tbool ok = true, s = false;\n\t\tFOR(i, 1, a + 1)\n\t\t\tFOR(j, 1, b + 1)\n\t\t{\n\t\t\tint d = c1 * i + c2 * j + c3;\n\t\t\tif (d < D[i][j])\n\t\t\t\tok = false;\n\t\t\tif (d == D[i][j] && C[i][j] > D[i][j])\n\t\t\t\ts = true;\n\t\t}\n\t\tif (ok && s)\n\t\t{\n\t\t\tFOR(i, 1, a + 1)\n\t\t\t\tFOR(j, 1, b + 1)\n\t\t\t\tC[i][j] = min(C[i][j], c1 * i + c2 * j + c3);\n\t\t\tE.push_back(MP(MP(c1 + 1, n - c2), c3));\n\t\t}\n\t}\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tif (C[i][j] > D[i][j])\n\t\t{\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << SZ(E) + n - 2 << '\\n';\n\tREP(i, (n - 2) / 2)\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\tREP(i, (n - 2) / 2)\n\t\tcout << n - i << ' ' << n - i - 1 << \" Y\\n\";\n\tREP(i, SZ(E))\n\t\tcout << E[i].first.first << ' ' << E[i].first.second << ' ' << E[i].second << '\\n';\n\tcout << \"1 \" << n << endl;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 << \" \" << 10200 << \"\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<=100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int Y = 105;\n\tconst int S = Y * 2 - 2, T = Y * 2 - 1;\n\txv.push_back(S);\n\tFOR(i, Y - 1) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, Y - 1) yv.push_back(i + Y - 1);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int, int, int>> vp;\n\tFOR(i, Y) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(w, Y) FOR(z, Y) {\n\t\tif (w + z >= Y) continue;\n\t\tint maxdiff = -10000;\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tint xw = w * (i + 1);\n\t\t\tint yw = z * (j + 1);\n\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\tchmax(maxdiff, additional);\n\t\t}\n\t\tif (maxdiff >= 0) {\n\t\t\tint from = xv[w], to = yv[Y - z];\n\t\t\t// printf(\"%dx + %dy + %d\\n\", w, z, maxdiff);\n\t\t\tvp.emplace_back(from, to, maxdiff);\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(T + 1);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", T + 1, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S + 1, T + 1);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool flg[101][101][101];\n\nint main()\n{\n    cin.tie(0);\n\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> bd(a, vector<int>(b));\n\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            cin >> bd[i][j];\n        }\n    }\n\n    memset(flg, 0, sizeof(flg));\n    bool possible = true;\n    for (int x = 1; x <= a; x++) {\n        for (int y = 1; y <= b; y++) {\n            int t = bd[x - 1][y - 1];\n            bool ok = false;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    for (int c = 0; c <= 100; c++) {\n                        if (flg[a][b][c])\n                            continue;\n\n                        if (a * x + b * y + c == t) {\n                            ok = true;\n                        }\n\n                        if (a * x + b * y + c < t) {\n                            flg[a][b][c] = true;\n                        }\n                    }\n                }\n            }\n            if (!ok) {\n                possible = false;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    cout << \"Possible\" << endl;\n\n    map<pair<int, int>, int> es;\n    es[make_pair(100, 101)] = 100;\n    for (int i = 0; i < 100; i++) {\n        es[make_pair(i, i + 1)] = -1;\n        es[make_pair(101 + i, 101 + i + 1)] = -2;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            for (int c = 0; c <= 100; c++) {\n                if (flg[a][b][c]) {\n                    es[make_pair(a, 101 + b)] = c;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << 202 << \" \" << es.size() << endl;\n\n    for (auto& it : es) {\n        cout << it.first.first + 1 << \" \" << it.first.second + 1 << \" \";\n        if (it.second == -1) {\n            cout << \"X\";\n        } else if (it.second == -2) {\n            cout << \"Y\";\n        } else {\n            cout << it.second;\n        }\n        cout << endl;\n    }\n\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint d[11][11];\nint val[11][11];\n\nusing edge = tuple<int, int, int>;\nvector<edge> graph;\n\nusing edge2 = tuple<int, int, char>;\nvector<edge2> graph2;\n\n\nint main(void) {\n\tint a, b;\n\tcin >> a >> b;\n\n\trep(i, a)rep(j, b) cin >> d[i][j];\n\trep(i, a)rep(j, b) val[i][j] = 1010;\n\n\tconst int total = 15;\n\tconst int n = total * total + 1;\n\tconst int s = 0, t = n - 1;\n\n\trep(ca, total)rep(cb, total) {\n\t\tint tmp[11][11];\n\t\trep(x, a)rep(y, b) tmp[x][y] = ca * (x + 1) + cb * (y + 1);\n\t\tint cmax = 0;\n\t\trep(x, a)rep(y, b) chmax(cmax, d[x][y] - tmp[x][y]);\n\t\tif (cmax > 100) continue;\n\t\t\n\t\t/*\t\n\t\trep(x, a){\n\t\t\trep(y, b) cerr << tmp[x][y] << \" \";\n\t\t\tcerr << endl;\n\t\t}\n\t\t*/\n\n\t\t//cerr << cmax << endl;\n\n\t\t//cerr << ca << \" \" << cb << endl;\n\t\trep(x, a)rep(y, b) chmin(val[x][y], tmp[x][y] +  cmax);\n\t\tconst int idx = total * ca + cb;\n\t\tgraph.push_back(edge(idx, t, cmax));\n\t}\n\n\trep(ca, total - 1) {\n\t\tgraph2.push_back(edge(total * ca, total * (ca + 1), 'X'));\n\t}\n\n\trep(ca, total)rep(cb, total - 1) {\n\t\tgraph2.push_back(edge(total * ca + cb , total * ca + cb + 1, 'Y'));\n\t}\n\n\n\trep(x, a)rep(y, b) {\n\t\t//cerr << val[x][y] << \" \" << d[x][y] << endl;\n\t\tif (val[x][y] != d[x][y]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tconst int m = graph.size() + graph2.size();\n\tcout << n << \" \" << m << endl;\n\tfor (auto &it : graph) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tfor (auto &it : graph2) {\n\t\tint a, b;\n\t\tchar  c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tcout << s + 1 << \" \" << t + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint A, B;\nint d[11][11];\nbool flag[11][11];\nvector<pair<pair<int, int>, int>> out;\nmap<pair<int, int>, int>tmp;\n\n#define PAPAPAPAPAPA 1\n\nint main(void)\n{\n\tcin >> A >> B;\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int xk = 0; xk <= 100; ++xk) {\n\t\tfor (int yk = 0; yk <= 100; ++yk) {\n\t\t\tint small = INT_MIN;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\t//if (flag[i][j])continue;\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tsmall = max(small, d[i][j] - val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (small < 0)continue;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tif (small == d[i][j] - val) {\n\t\t\t\t\t\tif (!flag[i][j]) {\n\t\t\t\t\t\t\tflag[i][j] = true;\n\t\t\t\t\t\t\tint from = 0 + xk;\n\t\t\t\t\t\t\tint to = 201 - yk;\n\t\t\t\t\t\t\tif (tmp.count({ from,to })) {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = min(tmp[{from, to}], small);//バグの可能性あり\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = small;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(small <= 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tif (!flag[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tfor (auto tm : tmp) {\n\t\tout.push_back(tm);\n\t}\n\tout.push_back({ { 202,0 },0 });\n\tout.push_back({ { 202,101 },0 });\n\tout.push_back({ { 100,203 },0 });\n\tout.push_back({ { 201,203 },0 });\n\tfor (int i = 0; i < 100; ++i) {\n\t\tout.push_back({ { i,i + 1 },-1 });\n\t\tout.push_back({ { i + 101,i + 102 },-2 });\n\t}\n\tcout << 204 << \" \" << (int)out.size() << endl;\n\tfor (auto elm : out) {\n\t\tcout << elm.first.first + 1 << \" \" << elm.first.second + 1 << \" \";\n#if PAPAPAPAPAPA\n\t\tif (elm.second == -1) {\n\t\t\tcout << \"A\\n\";\n\t\t}\n\t\telse if (elm.second == -2) {\n\t\t\tcout << \"B\\n\";\n\t\t}\n\t\telse {\n#endif\n\t\t\tcout << elm.second << endl;\n#if PAPAPAPAPAPA\n\t\t}\n#endif\n\t}\n\tcout << \"203 204\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint A,B;\nint C[12][12];\nint D[101][101];\nint DX[12][12];\nint DY[12][12];\nint NV;\nint V[303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(V);\n\t\n\tcin>>A>>B;\n\tfor(x=1;x<=A;x++) {\n\t\tfor(y=1;y<=B;y++) {\n\t\t\tcin>>C[x][y];\n\t\t}\n\t}\n\t\n\tvector<int> Xs,Ys;\n\tNV=1;\n\tXs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV][NV+1]=-2;\n\t\tNV++;\n\t\tXs.push_back(NV);\n\t}\n\tNV++;\n\tYs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV+1][NV]=-3;\n\t\tNV++;\n\t\tYs.push_back(NV);\n\t}\n\treverse(ALL(Ys));\n\t\n\tfor(x=0;x<=100;x++) {\n\t\tfor(y=0;y<=100;y++) {\n\t\t\tint ret=0;\n\t\t\tfor(i=1;i<=A;i++) {\n\t\t\t\tfor(j=1;j<=B;j++) {\n\t\t\t\t\tret=max(ret,C[i][j]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tD[x][y]=ret;\n\t\t\tV[Xs[x]][Ys[y]]=ret;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=A;i++) {\n\t\tfor(j=1;j<=B;j++) {\n\t\t\tint mi=1010;\n\t\t\tfor(x=0;x<=100;x++) {\n\t\t\t\tfor(y=0;y<=100;y++) {\n\t\t\t\t\tmi=min(mi,x*i+j*y+D[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi!=C[i][j]) return _P(\"Impossible\\n\");\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\t\n\tint cnt=0;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) cnt++;\n\tcout<<\"Possible\"<<endl;\n\tcout<<NV<<\" \"<<cnt<<endl;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) {\n\t\tcout<<x<<\" \"<<y<<\" \";\n\t\tif(V[x][y]==-2) cout<<\"X\"<<endl;\n\t\tif(V[x][y]==-3) cout<<\"Y\"<<endl;\n\t\tif(V[x][y]>=0) cout<<V[x][y]<<endl;\n\t}\n\tcout<<Xs[0]<<\" \"<<Ys[0]<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Open(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n#define rg  register\n#define LL long long\nusing namespace std;\nconst int MAXN=666;\nconst int INF=0x3f3f3f3f;\nint A,B;\nint d[MAXN][MAXN],f[MAXN][MAXN];\n\ntemplate <typename T> inline void in(T &a) {\n\tT ch = getchar(), f = 1;\n\tfor(a = 0; !isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n\tfor( ; isdigit(ch); ch = getchar()) a = (a << 3) + (a << 1) + ch - '0';\n\ta *= f;\n}\n\ntemplate <typename T> inline void print(T x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x > 9) print(x / 10);\n\tputchar(x % 10 + '0');\n}\n//f[i][j]=max{d[x][y]-i*x-j*y}\n//表示从S到T的路径上有i个x和j个y时其余边的最小可能长度\n//d[x][y]=min{f[i][j]+i*x+j*y}\n\nsigned main(){\n\tin(A),in(B);\n\t\n\tfor(rg int i=1;i<=A;i++){\n\t\tfor(rg int j=1;j<=B;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t} \n    \n    for(rg int i=0;i<=100;i++){\n    \tfor(rg int j=0;j<=100;j++){\n    \t\tfor(rg int x=1;x<=A;x++){\n\t\t\t\tfor(rg int y=1;y<=B;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint now=INF;\n\tfor(rg int x=1;x<=A;x++){\n\t\tfor(rg int y=1;y<=B;y++){\n\t\t\tnow=INF;\n\t\t\tfor(rg int i=0;i<=100;i++){\n\t\t\t\tfor(rg int j=0;j<=100;j++)\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+j*y);\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(rg int i=1;i<=100;i++)\n    \tprintf(\"%d %d X\\n\",i,i+1);\n    for(rg int i=102;i<=201;i++)\n    \tprintf(\"%d %d Y\\n\",i,i+1);\n    for(rg int i=0;i<=100;i++){\n    \tfor(rg int j=0;j<=100;j++)\n    \t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}\n/*\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<numeric>\n#include<bitset>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define MOD 1000000007\n#define EPS 1e-9\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int A,B;\n    cin >> A >> B;\n    int d[A+1][B+1], f[101][101], dmax = 0;\n    reppp(i, 1, A+1) reppp(j, 1, B+1){\n        cin >> d[i][j];\n        dmax = max(dmax, d[i][j]);\n    }\n\n    repp(a, dmax+1) repp(b, dmax+1){\n        int m = 0;\n        reppp(x, 1, A+1) reppp(y, 1, B+1){\n            m = max(m, d[x][y] - x*a - y*b);\n        }\n        f[a][b] = max(0, m);\n    }\n\n    reppp(x, 1, A+1) reppp(y, 1, B+1){\n        int shortest = INT_MAX;\n        repp(a, dmax+1) repp(b, dmax+1){\n            shortest = min(shortest, x*a + y*b + f[a][b]);\n        }\n        if(d[x][y] != shortest){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", (dmax+1)*2, (dmax+1)*(dmax+1) + 2*dmax);\n    reppp(n, 1, dmax+1) printf(\"%d %d X\\n\", n, n+1);\n    reppp(n, dmax+2, 2*dmax+2) printf(\"%d %d Y\\n\", n, n+1);\n    repp(a, dmax+1) repp(b, dmax+1) printf(\"%d %d %d\\n\", a+1, 2*dmax+2-b, f[a][b]);\n    printf(\"1 %d\\n\", 2*dmax+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint A, B, D[10][10];\nint C[101][101];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> A >> B;\n    rep(x, 0, A) rep(y, 0, B) cin >> D[x][y];\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        rep(i, 0, 101) rep(j, 0, 101) chmax(C[i][j], D[a][b] - i * x - j * y);\n    }\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        int d = inf;\n        rep(i, 0, 101) rep(j, 0, 101) chmin(d, i * a + j * y + C[i][j]);\n        if (d != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return;\n        }\n    }\n\n    vector<tuple<int, int, int>> edges;\n    rep(i, 0, 100) edges.push_back(make_tuple(i, i + 1, -1));\n    rep(i, 0, 100) edges.push_back(make_tuple(101 + i, 101 + i + 1, -2));\n    rep(i, 0, 101) rep(j, 0, 101) edges.push_back(make_tuple(i, 201 - j, C[i][j]));\n\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\", edges.size());\n    fore(t, edges) {\n        int a, b, c;\n        tie(a, b, c) = t;\n        a++; b++;\n        if (c == -1) printf(\"%d %d X\\n\", a, b);\n        else if (c == -2) printf(\"%d %d X\\n\", a, b);\n        else printf(\"%d %d %d\\n\", a, b, c);\n    }\n    printf(\"1 202\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint A,B,tot,d[15][15];\nbool mp[205][205];\nstruct edge{int i,j,x;};\nedge tg[15][15],e[23333];\nint main(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor (int i=1;i<=A;i++)\n\t\tfor (int j=1;j<=B;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\ttg[i][j].i=-1;\n\t\t}\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int x=0;x<=100;x++){\n\t\t\t\tbool fl=0;\n\t\t\t\tfor (int k=1;k<=A&&!fl;k++)\n\t\t\t\t\tfor (int l=1;l<=B&&!fl;l++)\n\t\t\t\t\t\tif (i*k+j*l+x<d[k][l])\n\t\t\t\t\t\t\tfl=1;\n\t\t\t\tif (fl) continue;\n\t\t\t\tfor (int k=1;k<=A&&!fl;k++)\n\t\t\t\t\tfor (int l=1;l<=B&&!fl;l++)\n\t\t\t\t\t\tif (i*k+j*l+x==d[k][l])\n\t\t\t\t\t\t\ttg[k][l]=(edge){i,j,x};\n\t\t\t}\n\tfor (int i=1;i<=100;i++)\n\t\te[++tot]=(edge){i,i+1,-1};\n\tfor (int i=102;i<=201;i++)\n\t\te[++tot]=(edge){i,i+1,-2};\n\tfor (int i=1;i<=A;i++)\n\t\tfor (int j=1;j<=B;j++){\n\t\t\tif (tg[i][j].i==-1){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!mp[tg[i][j].i][tg[i][j].j])\n\t\t\t\te[++tot]=(edge){1+tg[i][j].i,202-tg[i][j].j,tg[i][j].x};\n\t\t\tmp[tg[i][j].i][tg[i][j].j]=1;\n\t\t}\n\tprintf(\"%d %d\\n\",202,tot);\n\tfor (int i=1;i<=tot;i++){\n\t\tprintf(\"%d %d \",e[i].i,e[i].j);\n\t\tif (e[i].x==-1) printf(\"X\\n\");\n\t\telse if (e[i].x==-2) printf(\"Y\\n\");\n\t\telse printf(\"%d\\n\",e[i].x);\n\t}\n\tprintf(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ll long long\nconst int INF = 1000 * 1000 * 1000;\nconst ll LINF = (ll)INF * INF;\nint A , B;\nint d[11][11];\nint f[101][101];\nint dist[202];\n\nint main()\n{\n\t//freopen(\"input.txt\" , \"r\" , stdin);\n\t//freopen(\"output.txt\" , \"w\" , stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i++)\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\tfor(int a = 0; a <= 100; a++)\n\t\tfor(int b = 0; b <= 100; b++)\n\t\t{\n\t\t\tfor(int x = 1; x <= A; x++)\n\t\t\t\tfor(int y = 1; y <= B; y++)\n\t\t\t\t{\n\t\t\t\t\tf[a][b] = max(f[a][b] , d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t}\n\tbool good = true;\n\tfor(int x = 1; x <= A; x++)\n\t\tfor(int y = 1; y <= B; y++)\n\t\t{\n\t\t\tfor(int i = 0; i < 202; i++)\n\t\t\t\tdist[i] = INF;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tdist[i] = x * i;\n\t\t\tfor(int i = 100; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif(i != 100)\n\t\t\t\t\tdist[i + 101] = dist[i + 1 + 101] + y;\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist[i + 101] = min(dist[i + 101] , f[j][i] + dist[j]);\n\t\t\t}\n\t\t\tif(dist[101] != d[x][y])\n\t\t\t\tgood = false;\n\t\t}\n\n\tif(good)\n\t{\n\t\tprintf(\"Possible\\n\");\n\t\tint n = 202;\n\t\tprintf(\"%d %d\\n\" , n ,  (n - 2) + n * n / 4);\n\t\tfor(int i = 1; i <= 100; i++)\n\t\t{\n\t\t\tprintf(\"%d %d X\\n\" , i - 1 + 1 , i + 1);\n\t\t\tprintf(\"%d %d Y\\n\" , i + 101 + 1 , i + 101 - 1 + 1);\n\t\t}\n\t\tfor(int i = 0; i <= 100; i++)\n\t\t{\n\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\" , i + 1 , j + 101 + 1 , f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nint main(void){\n  int n = 100;\n  int a, b;\n  int f = 1;\n  cin >> a >> b;\n  vector<vi> d(a, vi(b));\n  vector<vi> finished(a, vi(b, 0));\n  REP(i, a) REP(j, b) cin >> d[i][j];\n  vector<vector<pii> > g(2 * n + 2);\n  REP(i, n + 1) {\n    REP(j, n + 1) {\n      int min_cost = 0;\n      REP(k, a) {\n        REP(l, b) {\n          int x = k * i + l * j;\n          int y = x - d[k][l];\n          if(y < 0) min_cost = max(min_cost, -y);\n        }\n      }\n      g[i+10].push_back(pii(220 - j, min_cost));\n      REP(k, a) {\n        REP(l, b){\n          if(k * i + l * j + min_cost == d[k][l]) finished[k][l] = 1;\n        }\n      }\n    }\n  }\n  REP(i, a) REP(j, b) if(!finished[i][j]) f = 0;\n\n  if(!f) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  int m = 2 * n + 2;\n  REP(i, g.size()) m += g[i].size();\n  cout << \"300 \" << m << endl;\n  cout << \"1 10 0\" << endl;\n  cout << \"220 2 0\" << endl;\n  REP(i, 100) {\n    cout << i + 10 << \" \" << i + 11 << \" X\" << endl;\n    cout << i + 120 << \" \" << i + 121 << \" Y\" << endl;\n  }\n  REP(i, g.size()) {\n    REP(j, g[i].size()) {\n      cout << i << \" \" << g[i][j].first << \" \" << g[i][j].second << endl;\n    }\n  }\n  cout << \"1 2\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "解説読んだ\nXをa回Yをb回通るルートの中で最短距離となるルートはX,Yが変化しても変わらないの、なるほど"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 505\n#define MAXN 149\n#define INF 1000000000\nusing namespace std;\nint n,m,f[M][M],g[M][M],S,T;\nint read(){\n\tchar c=getchar();int ans=0;\n    while (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans;\n}\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n\tn=read(),m=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++) f[i][j]=read();\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tfor (register int k=1;k<=n;k++)\n\t\t\t\tfor (register int l=1;l<=m;l++)\n\t\t\t\t\tg[i][j]=max(g[i][j],f[k][l]-k*i-l*j);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++){\n\t\t\tint now=INF;\n\t\t\tfor (register int k=0;k<=MAXN;k++)\n\t\t\t\tfor (register int l=0;l<=MAXN;l++)\n\t\t\t\t\tnow=min(now,k*i+l*j+g[k][l]);\n\t\t\tif (now!=f[i][j]){printf(\"Impossible\");return 0;}\n\t\t}\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tif (g[i][j]>100){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n%d %d\\n\",MAXN+MAXN+2,(MAXN+1)*(MAXN+1)+2*MAXN);\n\tS=1,T=MAXN+MAXN+2;\n\tfor (register int i=1;i<=MAXN;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (register int i=MAXN+2;i<=MAXN+MAXN+1;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,T-j,g[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    //freopen(\"inp.in\", \"r\", stdin);\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n    vector< vector<int> > constraints(A+1, vector<int>(B+1,-1));\n    for(int i=1; i<=A; i++)\n    {\n        for(int j=1; j<=B; j++)\n        {\n            scanf(\"%d\", &constraints[i][j]);\n        }\n    }\n    int nb_nodes=202;\n    vector< vector<int> > adjacency_matrix(nb_nodes, vector<int>(nb_nodes, -1));\n    for(int i=1; i<=A; i++)\n    {\n        for(int j=1; j<=B; j++)\n        {\n            int use1=-1;\n            int use2=-1;\n            for(int k1=0; k1<=100 && use1==-1; k1++)\n            {\n                for(int k2=0; k2<=100 && i*k1+j*k2 <= constraints[i][j] && use1==-1; k2++)\n                {\n                    bool ok=true;\n                    int t=constraints[i][j]-i*k1-j*k2;\n                    for(int l=1; l<=A && ok; l++)\n                    {\n                        for(int m=1; m<=B && ok; m++)\n                        {\n                            if(!(k1*l+k2*m+t >= constraints[l][m])) ok=false;\n                        }\n                    }\n                    if(!ok) continue;\n                    use1=k1;\n                    use2=k2;\n                }\n            }\n            //cerr << use1 << \" \" << use2 << endl;\n            if(use1==-1)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            int t=constraints[i][j]-i*use1-j*use2;\n            adjacency_matrix[use1][201-use2]=t;\n        }\n    }\n    int extra=0;\n    for(int i=0; i<nb_nodes; i++)\n    {\n        for(int j=0; j<nb_nodes; j++)\n        {\n            if(adjacency_matrix[i][j] != -1) extra++;\n        }\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\", 200+extra);\n    for(int i=0; i<=99; i++)\n    {\n        printf(\"%d %d x\\n\", i+1, i+2);\n    }\n    for(int i=101; i<=200; i++)\n    {\n        printf(\"%d %d y\\n\", i+1, i+2);\n    }\n    for(int i=0; i<nb_nodes; i++)\n    {\n        for(int j=0; j<nb_nodes; j++)\n        {\n            if(adjacency_matrix[i][j] != -1)\n            {\n                printf(\"%d %d %d\\n\", i+1, j+1, adjacency_matrix[i][j]);\n            }\n        }\n    }\n    printf(\"%d %d\\n\", 1, 202);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\n#define int long long\n\nconst int MOD = 1e9 + 7;\n\nint a, b;\nint d[50][50];\nint go[200][200];\n\nsigned main()\n{\n    //freopen(\"input_02.txt\", \"r\", stdin);\n    //freopen(\"output_02.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            int max_c = -1e9;\n            for (int x = 1; x <= a; x++)\n            {\n                for (int y = 1; y <= b; y++)\n                {\n                    int moved = i * x + j * y;\n                    int add = d[x][y] - moved;\n                    max_c = max(max_c, add);\n                }\n            }\n            if (max_c <= 100 && 0 <= max_c)\n            {\n                go[i][j] = max_c;\n            }\n            else\n            {\n                go[i][j] = 1e9;\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (x * i + go[i][j] + y * j < d[i][j])\n                    {\n                        go[i][j] = 1e9;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            int min_c = 1e9;\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (min_c > i * x + go[i][j] + j * y)\n                    {\n                        min_c = i * x + go[i][j] + j * y;\n                    }\n                }\n            }\n            if (min_c != d[x][y])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    int cnt = 0;\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j]) cnt++;\n        }\n    }\n    cout << 202 << \" \" << cnt << \"\\n\";\n    for (int i = 0; i < 100; i++)\n    {\n        cout << i + 1 << \" \" << i + 2 << \" \" << 'X' << \"\\n\";\n    }\n    for (int j = 0; j < 100; j++)\n    {\n        cout << 202 - j - 1 << \" \" << 202 - j << \" \" << 'Y' << \"\\n\";\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j])\n            {\n                cout << i + 1 << \" \" << 202 - j << \" \" << go[i][j] << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << 202 << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <functional>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include <array>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(1, A + 1))\n        RDV(d[i] + 1, d[i] + B + 1);\n\n    vector<pair<int, int>> adj[300];\n    set<int> adj2[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(1, A + 1))\n        for(int j: RG(1, B + 1))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    if(x * i + y * j > d[i][j])\n                        continue;\n\n                    bool check = true;\n                    for(int ii = 1; ii <= A && check; ii++)\n                        for(int jj: RG(1, B + 1))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else if(adj2[xx + 1].insert(202 - yy).second)\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n\n\n\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FORD(i,a,b) for(int i=a;i>=b;i--)\n#define FORL(i,x) for(int i=head[x];i;i=nxt[i])\n#define clr(x,y) memset(x,y,sizeof(x))\n#define in(a) a=read()\n#define out(a) printf(\"%d\\n\",a)\ninline ll read(){\n    char c=getchar();ll f=1,x=0;\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9')x=x*10+(c-'0'),c=getchar();\n    return x*f;\n}\n#define mod 1000000007\nvoid MOD(int &x){if(x>=mod)x-=mod;}\n#define maxn 100010\n#define inf (1<<30)\n\nint d[110][110],f[110][110];\nint main(){\n\tint n,m;\n\tin(n);in(m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tin(d[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tbool flag=0;\n\t\t\tfor(int i=0;i<=100;i++)\n\t\t\t\tfor(int j=0;j<=100;j++)\n\t\t\t\t\tif(f[i][j]+i*x+j*y==d[x][y])\n\t\t\t\t\t\tflag=1;\n\t\t\tif(!flag){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<' '<<200+101*101<<endl;\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1); \n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i,202-j,f[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A, B;\nconst int N = 15;\nint dx[N][N], nw[N][N];\nint V[N][N];\nconst int INF = 1e9 + 7;\nvector <int> Ai, Bi, Ci;\nvoid add_edge(int a, int b, int c)\n{\n    Ai.push_back(a);\n    Bi.push_back(b);\n    Ci.push_back(c);\n}\nint main()\n{\n    cin >> A >> B;\n    for (int a = 1; a <= A; ++ a)\n        for (int b = 1; b <= B; ++ b)\n            cin >> dx[a][b], nw[a][b] = INF;\n    for (int i = 1; i <= 100; ++ i)\n        add_edge(i, i + 1, -1);\n    for (int i = 1; i <= 100; ++ i)\n        add_edge(101 + i, 101 + i + 1, -2);\n    for (int i = 0; i <= 100; ++ i)\n        for (int j = 0; j <= 100; ++ j)\n        {\n            int d = -INF;\n            for (int a = 1; a <= A; ++ a)\n                for (int b = 1; b <= B; ++ b)\n                    d = max(d, dx[a][b] - (i * a + j * b));\n            if (d >= 0 && d <= 100)\n            {\n                add_edge(i + 1, 202 - j, d);\n                for (int a = 1; a <= A; ++ a)\n                    for (int b = 1; b <= B; ++ b)\n                        nw[a][b] = min(nw[a][b], i * a + j * b + d);\n            }\n        }\n    for (int a = 1; a <= A; ++ a)\n        for (int b = 1; b <= B; ++ b)\n            if (nw[a][b] != dx[a][b])\n                return cout << \"Impossible\" << endl, 0;\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << Ci.size() << endl;\n    for (int i = 0; i < Ci.size(); ++ i)\n    {\n        cout << Ai[i] << \" \" << Bi[i] << \" \";\n        if (Ci[i] == -1) cout << \"X\" << endl;\n        else if (Ci[i] == -2) cout << \"Y\" << endl;\n        else cout << Ci[i] << endl;\n    }\n    cout << 1 << \" \" << 202 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define AB_MAX 12\n#define N_MAX 102\n\nusing namespace std;\n\nint A, B;\n\nint d[AB_MAX][AB_MAX];\n\nint a[N_MAX][N_MAX];\n\nint n;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> A >> B;\n    bool ok = true;\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n        {\n            cin >> d[i][j];\n            if(d[i][j] < d[i - 1][j] || d[i][j] < d[i][j - 1])\n                ok = false;\n        }\n    if(ok == false)\n    {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    n = 101;\n    for(int i = 0; i <= n; i++)\n        for(int j = 0; j <= n; j++)\n        {\n            for(int x = 1; x <= A; x++)\n                for(int y = 1; y <= B; y++)\n                    a[i][j] = max(a[i][j], d[x][y] - x * i - y * j);\n        }\n    for(int x = 1; x <= A; x++)\n        for(int y = 1; y <= B; y++)\n        {\n            int mi = 1e9+1;\n            for(int i = 0; i <= n; i++)\n                for(int j = 0; j <= n; j++)\n                    mi = min(mi, a[i][j] + x * i + y * j);\n            if(mi != d[x][y])\n            {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n        }\n    int cntX = 101;\n    int cntY = 101;\n    cout << \"Possible\\n\";\n    cout << cntX + cntY + 2 << \" \" << cntX - 1 + cntY - 1 + cntX * cntY + 2 << \"\\n\";\n    for(int i = 2; i < cntX + 1; i++)\n        cout << i << \" \" << i + 1 << \" X\\n\";\n    for(int i = 2; i < cntY + 1; i++)\n        cout << cntX + i << \" \" << cntX + i + 1 << \" Y\\n\";\n    cout << \"1 2 0\\n\";\n    for(int i = 2; i <= cntX + 1; i++)\n        for(int j = 2; j <= cntY + 1; j++)\n            cout << i << \" \" << cntX + j << \" \" << a[i - 2][cntY - j + 1] << \"\\n\";\n    cout << cntX + cntY + 1 << \" \" << cntX + cntY + 2 << \" 0\\n\";\n    cout << 1 << \" \" << cntX + cntY + 2 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?102+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",id(100,1),10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(100-j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",1,id(100,1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\tvector<vector<ll>> d(A+1, vector<ll>(B+1));\n\tfor (int i = 1;i <= A;i++)\n\t\tfor (int j = 1;j <= B;j++)\n\t\t\tcin >> d[i][j];\n\tvector<vector<ll>> e(101, vector<ll>(101, 0));\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++)\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\te[ua][ub] = max(e[ua][ub], d[a][b] - (a * ua + b * ub));\n\tbool ok = true;\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++) {\n\t\t\tbool nowok = false;\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\tif (e[ua][ub] + a * ua + b * ub == d[a][b])\n\t\t\t\t\t\tnowok = true;\n\t\t\tok &= nowok;\n\t\t}\n\tif (!ok)\n\t\tcout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << \"202 \" << 101 * 101 + 100 + 100 << endl;\n\t\tfor (int i = 1;i <= 100;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t\tfor (int i = 102;i <= 201;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"Y\" << endl;\n\t\tfor (int ua = 0;ua <= 100;ua++)\n\t\t\tfor (int ub = 0;ub <= 100;ub++)\n\t\t\t\tcout << ua + 1 << \" \" << 202 - ub << \" \" << min(100LL, e[ua][ub]) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111;\nint d[maxn][maxn]; // d[x][y] = min x * a + y * b + f[a][b]\nint f[maxn][maxn]; // f[a][b] = max x * a + y * b - d[x][y]\nint S[maxn], T[maxn];\nint main(){\n\tint A, B;\n\tcin >> A >> B;\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tcin >> d[x][y];\n\t\t\tfor(int a = 0; a < maxn; a++){\n\t\t\t\tfor(int b = 0; b < maxn; b++){\n\t\t\t\t\tf[a][b] = max(f[a][b], -(x * a + y * b - d[x][y]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tint mi = 1<<30;\n\t\t\tfor(int a = 0; a < maxn; a++){\n\t\t\t\tfor(int b = 0; b < maxn; b++){\n\t\t\t\t\tmi = min(mi, x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi != d[x][y]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tint nds = 1;\n\tfor(int i = 0; i < maxn; i++){\n\t\tS[i] = nds++;\n\t\tT[i] = nds++;\n\t}\n\tcout << 2 * maxn << \" \" << 2 * maxn - 2 + maxn * maxn << endl;\n\tfor(int i = 0; i < maxn - 1; i++){\n\t\tcout << S[i] << \" \" << S[i + 1] << \" X\" << endl;\n\t}\n\tfor(int i = maxn - 1; i > 0; i--){\n\t\tcout << T[i] << \" \" << T[i - 1] << \" Y\" << endl; \n\t}\n\tfor(int a = 0; a < maxn; a++){\n\t\tfor(int b = 0; b < maxn; b++){\n\t\t\tcout << S[a] << \" \" << T[b] << \" \" << f[a][b] << endl;\n\t\t}\n\t}\n\tcout << S[0] << \" \" << T[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=15;\nconst int M=105; \nconst int t=100;\nint m,n,d[N][N],f[M][M],p;\nint read()\n{\tchar x=getchar();\n\twhile(x<48||x>57) x=getchar();\n\tint ans=0;\n\twhile(x>=48&&x<=57)\n\t{\tans=(ans<<1)+(ans<<3)+(x^48);\n\t\tx=getchar();\n\t}\n\treturn ans;\n}\nint main()\n{\tm=read();n=read();\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=n;j++)\n\td[i][j]=read();\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\t{\tp=0x7ffffff;\n\t\tfor(int i=0;i<=t;i++)\n\t\tfor(int j=0;j<=t;j++)\n\t\tp=min(p,i*x+j*y+f[i][j]);\n\t\tif(p!=d[x][y]) {printf(\"Impossible\\n\");return 0;}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(int i=1;i<=t;i++)\n\t{\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+102);\n\t}\n\tfor(int i=1;i<=t;i++)\n\tfor(int j=1;j<=t;j++)\n\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint c[102][102];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, a, b);\n\tMAT(int, d, a, b);\n\tREP(ai, 101) REP(bi, 101) REP(x, a) REP(y, b) {\n\t\tCHMAX(c[ai][bi], d[x][y] - ai * (x + 1) - bi * (y + 1));\n\t}\n\tREP(x, a) REP(y, b) {\n\t\tint dist = INFINT;\n\t\tREP(ai, 101) REP(bi, 101) {\n\t\t\tCHMIN(dist, ai * (x + 1) + bi * (y + 1) + c[ai][bi]);\n\t\t}\n\t\tif (dist != d[x][y]) {\n\t\t\tOUT(\"Impossible\")BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tOUT(\"Possible\")BR;\n\tOUT(\"202 10401\")BR;\n\tREP(i, 100) {\n\t\tOUT(i + 1)SP OUT(i + 2)SP OUT('X')BR;\n\t\tOUT(i + 1 + 101)SP OUT(i + 101)SP OUT('Y')BR;\n\t}\n\tREP(i, 101) REP(j, 101) {\n\t\tOUT(i + 1)SP OUT(j + 1 + 101)SP OUT(c[i][j])BR;\n\t}\n\tOUT(\"1 101\")BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmin(a,b) a=min(a,b);\n#define chmax(a,b) a=max(a,b);\n#define H 11\n#define N 110\nll d[H][H],z[N][N],h,w;\nint main(){\n  cin>>h>>w;\n  for(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n    cin>>d[i][j];\n  }\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n    z[i][j]=0;\n    for(int a=1;a<=h;a++)for(int b=1;b<=w;b++){\n      chmax(z[i][j],d[a][b]-i*a-j*b);\n    }\n  }\n  bool ok=1; ll cnt=0;\n  for(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n    ll mi=1e9;\n    for(int a=0;a<N;a++)for(int b=0;b<N;b++){\n      if(z[a][b]>100)continue; cnt++;\n      chmin(mi,z[a][b]+a*i+b*j);\n    }\n    if(mi!=d[i][j])ok=0;\n  }\n  cnt=cnt/h/w;\n  if(ok==0){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  cout<<2*N<<\" \"<<cnt<<endl;\n  for(int i=1;i<N;i++)cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n  for(int i=N+1;i<2*N;i++)cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n  for(int a=0;a<N;a++)for(int b=0;b<N;b++){\n    if(z[a][b]>100)continue;\n    cout<<a+1<<\" \"<<2*N-b<<\" \"<<z[a][b]<<endl;\n  }\n  cout<<1<<\" \"<<2*N<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            func mn={101, 101, 102};\n            for(int ix = 0; ix <= 100; ix++)\n            {\n                for(int iy = 0; iy <= 100; iy++)\n                {\n                    int cost = ix*i + iy*j;\n                    if(cost > d[i][j]) continue;\n                    int kk = d[i][j] - cost;\n                    //if(kk > mn.k) continue;\n                    if(ix+iy > mn.xc + mn.yc) continue;\n                    bool flag=true;\n                    for(int ita = 1; ita <= a; ita++)\n                    {\n                        for(int itb = 1; itb <= b; itb++)\n                        {\n                            if(ix*ita + iy*itb + kk < d[ita][itb])\n                            {\n                                flag=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(flag)\n                    {\n                        mn={ix, iy, kk};\n                    }\n                }\n            }\n            if(mn.xc==101)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb(mn);\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    if(nodes>300) exit(7);\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n    times(A-1, x) times(B, y) {\n        if(D[x][y] > D[x+1][y]) {\n            cout << \"Impossible\" ln;\n            dbg(x+1);\n            return;\n        }\n    }\n    times(A, x) times(B-1, y) {\n        if(D[x][y] > D[x][y+1]) {\n            cout << \"Impossible\" ln;\n            dbg(y+1);\n            return;\n        }\n    }\n\n\n    WI dx(A,VI(B)), dy(A,VI(B)), c(A,VI(B));\n    times(A, x) times(B, y) {\n        dx[x][y] = //max(\n            //x < A-1 ? D[x+1][y] - D[x][y] : 0,\n            x > 0   ? D[x][y] - D[x-1][y] : 0;\n        //);\n        dy[x][y] = //max(\n            y < B-1 ? D[x][y+1] - D[x][y] : dy[x][y-1];\n            //y > 0   ? D[x][y] - D[x][y-1] : 0\n        //);\n        c[x][y] = D[x][y] - dx[x][y] * (x + 1) - dy[x][y] * (y + 1);\n        if((x == 0 or x == A-1 or y == 0 or y == B-1) and c[x][y] < 0) {\n            dx[x][y] = 0;\n            dy[x][y] = 0;\n            c[x][y] = D[x][y];\n        }\n        if(dx[x][y] < 0 or dy[x][y] < 0 or c[x][y] < 0) {\n            cout << \"Impossible\" ln;\n            db(x); db(y); db(dx[x][y]); db(dy[x][y]); dbg(c[x][y]);\n            return;\n        }\n    }\n\n    upto(1, A-1, x) upto(0, B-1, y) {\n        if((x == 0   or dx[x][y] != dx[x-1][y] or dy[x][y] != dy[x-1][y] or c[x][y] != c[x-1][y]) and\n           (x == A-1 or dx[x][y] != dx[x+1][y] or dy[x][y] != dy[x+1][y] or c[x][y] != c[x+1][y]) and\n           (D[x][y] == dx[x-1][y] * (x+1) + dy[x-1][y] * (y+1) + c[x-1][y])) {\n            dx[x][y] = dx[x-1][y];\n            dy[x][y] = dy[x-1][y];\n            c[x][y] = c[x-1][y];\n        }\n    }\n    if(debug) times(A, x) { times(B, y) {\n        cerr << \"(\" << dx[x][y] << \",\" << dy[x][y] << \",\" << c[x][y] << \") \";\n    } cerr ln; }\n\n    /*times(A-1, x) {\n        int y = B-1;\n        if(D[x][y] == dx[x][y-1] * (x+1) + dy[x][y-1] * (y+1) + c[x][y-1]) {\n            dx[x][y] = dx[x][y-1];\n            dy[x][y] = dy[x][y-1];\n            c[x][y] = c[x][y-1];\n        } else {\n            dx[x][y] = 0;\n            dy[x][y] = 0;\n            c[x][y] = D[x][y];\n        }\n    }\n    times(B, y) {\n        int x = A-1;\n        if(D[x][y] == dx[x-1][y] * (x+1) + dy[x-1][y] * (y+1) + c[x-1][y]) {\n            dx[x][y] = dx[x-1][y];\n            dy[x][y] = dy[x-1][y];\n            c[x][y] = c[x-1][y];\n        } else {\n            dx[x][y] = 0;\n            dy[x][y] = 0;\n            c[x][y] = D[x][y];\n        }\n    }\n    if(debug) times(A, x) { times(B, y) {\n        cerr << \"(\" << dx[x][y] << \",\" << dy[x][y] << \",\" << c[x][y] << \") \";\n    } cerr ln; }*/\n\n    int mx = 0, my = 0;\n    times(A, x) times(B, y) {\n        mx = max(mx, dx[x][y]);\n        my = max(my, dy[x][y]);\n    }\n    int N = mx+1+my+1;\n    if(N > 300) {\n        cout << \"Impossible\" ln;\n        dbg(2);\n        return;\n    }\n    vector<map<int, int>> path(N);\n    times(mx, i) path[i][i+1] = -1;\n    times(my, i) path[mx+1+i][mx+1+i+1] = -2;\n    times(A, x) times(B, y) {\n        path[dx[x][y]][mx+1+dy[x][y]] = c[x][y];\n    }\n    int M = 0;\n    times(N, i) M += path[i].size();\n    cout << \"Possible\" ln << N sp << M ln;\n    times(N, i) for(PI p : path[i]) {\n        if(p.second == -1)\n            cout << i+1 sp << p.first+1 sp << \"X\" ln;\n        else if(p.second == -2)\n            cout << i+1 sp << p.first+1 sp << \"Y\" ln;\n        else\n            cout << i+1 sp << p.first+1 sp << p.second ln;\n    }\n    cout << 1 sp << mx+1+1 ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[191][111];\nint l[110][199];\nint j[111];\n\nlong long x,y,z,mod=1000000007;\n//string r,r1;\nchar r[1];\n\nP u[10];\nqueue<P> q;\n//stack<int> s;\nmap<int,int> p;\nvector<int> v;\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&a,&b);\n  for(int t=1;t<=a;t++)\n    for(int w=1;w<=b;w++)\n    {\n      scanf(\"%d\",&l[t][w]);\n      for(int i=0;i*t<=l[t][w];i++)\n      for(int j=0;i*t+j*w<=l[t][w];j++)\n      o[i][j]=max(o[i][j],l[t][w]-i*t-j*w);\n    }\n  for(int t=1;t<=a;t++)\n  for(int w=1;w<=b;w++)\n  {\n    int p=mod;\n    for(int i=0;i*t<=l[t][w];i++)\n    for(int j=0;i*t+j*w<=l[t][w];j++)\n    p=min(p,i*t+j*w+o[i][j]);\n    if(p!=l[t][w])\n    {\n      puts(\"Impossible\");\n      return 0;\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d %d\\n\",100+100+2,100+100+(100+1)*(100+1));\n  for(int t=1;t<=100;t++)\n    printf(\"%d %d X\\n\",t,t+1);\n  for(int t=100+2;t<200+2;t++)\n    printf(\"%d %d Y\\n\",t,t+1);\n  for(int i=1,t=0;i<=100+1;t++,i++)\n  for(int j=200+2,w=0;j>=100+2;j--,w++)\n    printf(\"%d %d %d\\n\",i,j,o[t][w]);\n  printf(\"1 %d\",200+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,a,b;\nint d[11][11];\nvector<P> G[3][205];\nint f[105][105];\nint dp[205];\n\nint dijk(int ac,int bc){\n\tfor(int i=0;i<202;i++){\n\t\tdp[i]=INF;\n\t}\n\tdp[0]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint v=q.second;\n\t\tif(q.first>dp[v])continue;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<G[i][v].size();j++){\n\t\t\t\tint co=G[i][v][j].second;\n\t\t\t\tif(i==1)co=ac;\n\t\t\t\tif(i==2)co=bc;\n\t\t\t\tif(co+q.first<dp[G[i][v][j].first]){\n\t\t\t\t\tdp[G[i][v][j].first]=co+q.first;\n\t\t\t\t\tque.push(P(co+q.first,G[i][v][j].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d %d %d\\n\",ac,bc,dp[201]);\n\treturn dp[201];\n}\n\nint main(void){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<100;i++){\n\t\tG[1][i].push_back(P(i+1,-1));\n\t}\n\tfor(int i=101;i<201;i++){\n\t\tG[2][i].push_back(P(i+1,-1));\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tfor(int l=0;l<b;l++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[k][l]-(k+1)*i-(l+1)*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tG[0][i].push_back(P(201-j,f[i][j]));\n\t\t}\n\t}\n\tbool flag=true;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(dijk(i+1,j+1)!=d[i][j])flag=false;\n\t\t}\n\t}\n\tif(flag){\n\t\tprintf(\"Possible\\n\");\n\t\tint siz=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<202;j++){\n\t\t\t\tsiz+=G[i][j].size();\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",202,siz);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<202;j++){\n\t\t\t\tfor(int k=0;k<G[i][j].size();k++){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tprintf(\"%d %d %d\\n\",j+1,G[i][j][k].first+1,G[i][j][k].second);\n\t\t\t\t\t}else if(i==1){\n\t\t\t\t\t\tprintf(\"%d %d X\\n\",j+1,G[i][j][k].first+1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tprintf(\"%d %d Y\\n\",j+1,G[i][j][k].first+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",1,202);\n\t}else{\n\t\tprintf(\"Impossible\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n\nint main(){\n\tint a,b;\n\tint d[12][12];\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=1;j<=b;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\t\n\tbool ok[12][12];\n\tmemset(ok,0,sizeof ok);\n\tfor(int s=0;s<=100;s++){\n\t\tfor(int t=0;t<=100;t++){\n\t\t\tint u=0;\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tchmax(u,d[i][j]-s*i-t*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tif(u==d[i][j]-s*i-t*j)ok[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++){\n\t\tfor(int j=1;j<=b;j++){\n\t\t\tif(!ok[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,200+101*101);\n\tfor(int i=0;i<100;i++){\n\t\tprintf(\"%d %d X\\n\",1+i,1+i+1);\n\t\tprintf(\"%d %d Y\\n\",102+i+1,102+i);\n\t}\n\tfor(int s=0;s<=100;s++){\n\t\tfor(int t=0;t<=100;t++){\n\t\t\tint u=0;\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tchmax(u,d[i][j]-s*i-t*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tif(u==d[i][j]-s*i-t*j)ok[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d %d %d\\n\",s+1,t+102,u);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,102);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+(ans[i].c!=0);\n\t\tnumn+=ans[i].a+ans[i].b+(ans[i].c!=0)-1;\n\t}\n\tnumn+=2;\n\tif (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tif (ans[i].c) printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'Y'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'X'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\tfor (int c=0;c<=s-a-b&&c<=100;c++)\n\t\t\t\t{\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint a, b;\nconst int maxN = 15;\nint d[maxN][maxN];\nbool ok[maxN][maxN];\nint val[maxN][maxN];\nint vert[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n    int sz = 1;\n    for (int cnt1 = 0; cnt1 < maxN; cnt1++) {\n        for (int cnt2 = 0; cnt2 < maxN; cnt2++) {\n            vert[cnt1][cnt2] = sz++;\n            int at_least_t = 0;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    at_least_t = max(at_least_t, d[j][k] - j * cnt1 - k * cnt2);\n                }\n            }\n            val[cnt1][cnt2] = at_least_t;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    int p = at_least_t + j * cnt1 + k * cnt2;\n                    assert(p >= d[j][k]);\n                    if (p == d[j][k]) ok[j][k] = true;\n                }\n            }\n        }\n    }\n    for (int j = 1; j <= a; j++) {\n        for (int k = 1; k <= b; k++) {\n            if (!ok[j][k]) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << '\\n';\n    vector < pair < pair < int, int >, int > > edges;\n    int T = sz;\n    for (int i = 0; i < maxN; i++) {\n        for (int j = 0; j < maxN; j++) {\n            edges.emplace_back(make_pair(vert[i][j], T), val[i][j]);\n            if (i + 1 < maxN) {\n                edges.emplace_back(make_pair(vert[i][j], vert[i + 1][j]), -1);\n            }\n            if (j + 1 < maxN) {\n                edges.emplace_back(make_pair(vert[i][j], vert[i][j + 1]), -2);\n            }\n        }\n    }\n    cout << sz << \" \" << edges.size() << '\\n';\n    for (auto it : edges) {\n        cout << it.first.first << \" \" << it.first.second << \" \";\n        if (it.second == -1) cout << 'X' << '\\n';\n        else if (it.second == -2) cout << 'Y' << '\\n';\n        else cout << it.second << '\\n';\n    }\n    cout << 1 << \" \" << sz << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n#define N 305\n#define db double\n#define ll long long\nint A,B,dist[12][12],f[N][N],d;\nint cal(int a,int b)\n{\n\tint res=0;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) res=max(res,dist[i][j]-i*a-j*b);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) scanf(\"%d\",&dist[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++) f[i][j]=cal(i,j);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\td=1e9;\n\t\t\tfor(int i2=0;i2<=100;i2++)\n\t\t\t\tfor(int j2=0;j2<=100;j2++)\n\t\t\t\t\td=min(d,f[i2][j2]+i*i2+j*j2);\n\t\t\tif(d^dist[i][j]) {puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"202 10401\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)//if(f[i][j])\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\tfor(int i=1;i<=100;i++) printf(\"%d %d Y\\n\",102+i,101+i);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nnamespace QiFeng233{\n\tconst int maxn=310,matsiz=20,inf=0x3f3f3f3f;\n\tint A,B,d[matsiz][matsiz],f[maxn][maxn];\n\tint max(int a,int b){\n\t\treturn a>b?a:b;\t\t\n\t}\n\tint min(int a,int b){\n\t\treturn a<b?a:b;\n\t}\n\tvoid solve(){\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tfor(int i=1;i<=A;++i)\n\t\t\tfor(int j=1;j<=B;++j)\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\tfor(int i=0;i<=100;++i)\n\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\tfor(int x=1;x<=A;++x)\n\t\t\t\t\tfor(int y=1;y<=B;++y)\n\t\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\tfor(int x=1;x<=A;++x)\n\t\t\tfor(int y=1;y<=B;++y){\n\t\t\t\tint dxy=inf;\n\t\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\t\tdxy=min(dxy,i*x+j*y+f[i][j]);\n\t\t\t\tif(dxy!=d[x][y]){\n\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"202 10401\\n\");\n\t\tfor(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\t\tfor(int i=102;i<=201;++i)printf(\"%d %d Y\\n\",i,i+1);\n\t\tfor(int i=0;i<=100;++i)\n\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\tprintf(\"%d %d %d\\n\",1+i,202-j,f[i][j]);\n\t\tprintf(\"1 202\\n\");\n\t}\n}\nsigned main(){\n\tQiFeng233::solve();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      rep(x, a){\n        rep(y, b){\n          chmin(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n      if(f[i][j] < 0)f[i][j] = 0;\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10 + 5;\n\nint n, m, d[N][N], f[105][105];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 101 * 101);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %dY\\n\", i + 1, i + 2, 102 + i, 103 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<map>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nint A,B;\nint dis[15][15];\nint ed[105][105];\nint main()\n{\n\tread(A);\n\tread(B);\n\tmemset(ed,-23,sizeof(ed));\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tread(dis[i][j]);\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\ted[a][b]=max(ed[a][b],dis[i][j]-a*i-b*j);\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tlong long ans=12345678987654321ll;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tans=min(ans,1ll*a*i+b*j+ed[a][b]);\n\t\t\tif(ans!=dis[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tcout<<202<<' '<<101*101+200<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i-1<<' '<<i<<\" X\"<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i+101<<' '<<i+101-1<<\" Y\"<<endl;\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tcout<<i<<' '<<j+101<<' '<<ed[i][j]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define reg register\n#define MAXN 101\n#define MAXI 11\nusing namespace std;\n\nint dis[MAXI][MAXI];\nint f[MAXN][MAXN];\nint n,m;\n\ninline int max(int a,int b)\n{return(a>b?a:b);}\n\ninline int min(int a,int b)\n{return(a<b?a:b);}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&dis[i][j]);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tfor(reg int px=1;px<=n;px++)\n\t\t\t\tfor(reg int py=1;py<=m;py++)\n\t\t\t\t\tf[i][j]=max(f[i][j],dis[px][py]-i*px-j*py);\n\tfor(reg int px=1;px<=n;px++)\n\t\tfor(reg int py=1;py<=m;py++)\n\t\t{\n\t\t\tint tmp=2147483647;\n\t\t\tfor(reg int i=0;i<=100;i++)\n\t\t\t\tfor(reg int j=0;j<=100;j++)\n\t\t\t\t\ttmp=min(tmp,f[i][j]+i*px+j*py);\n\t\t\tif(tmp!=dis[px][py])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(reg int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(reg int i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",1+i,202-j,f[i][j]);\n\tprintf(\"1 202\");\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            if (k >= 0 && k < T) {\n                v.push_back(F{i, j, k});\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    const int N = 300;\n    int t = N - 1;\n    int dd[N][N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dd[i][j] = INT_MAX;\n        }\n    }\n    for (int i = 0; i < T; ++i) {\n        dd[i][i + 1] = -1;\n    }\n\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        dd[i + YY][i + 1 + YY] = -2;\n    }\n\n    for (const auto &f : v) {\n        dd[f.a][YY] = min(dd[f.a][YY], 0);\n        dd[YY + f.b][t] = min(dd[YY + f.b][t], f.c);\n    }\n\n    cout << \"Possible\" << \"\\n\";\n    int esize = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                esize++;\n            }\n        }\n    }\n    cout << t + 1 << \" \" << esize << \"\\n\";\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                cout << i + 1 << \" \" << j + 1 << \" \";\n                if (dd[i][j] >= 0) {\n                    cout << dd[i][j];\n                } else if (dd[i][j] == -1) {\n                    cout << \"X\";\n                } else {\n                    cout << \"Y\";\n                }\n                cout << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << N << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint To[10005], Next[10005], Head[305], W[10005], S, T, Cnt, Dis[305], M;\nbool Vis[305];\nstruct Node{\n\tint X, V;\n\tbool operator < (const Node &B)const\n\t{\n\t\treturn V > B.V;\n\t}\n};\ninline void Insert(int U, int V, int Val)\n{\n\tTo[++Cnt] = V, Next[Cnt] = Head[U], Head[U] = Cnt, W[Cnt] = Val;\n}\npriority_queue<Node>Q;\ninline int Dij(int X, int Y)\n{\n\tmemset(Dis, 0x3f, sizeof(Dis));\n\tmemset(Vis, 0, sizeof(Vis));\n\tDis[S] = 0;\n\tQ.push((Node){S, 0});\n\tint U, V;\n\twhile(!Q.empty()){\n\t\tU = Q.top().X;\n\t\tQ.pop();\n\t\tif(Vis[U])continue;\n\t\tVis[U] = true;\n\t\tfor(int I = Head[U], Val, V; I; I = Next[I]){\n\t\t\tVal = (W[I] == -1) ? X : (W[I] == -2) ? Y : W[I];\n\t\t\tV = To[I];\n\t\t\tif(Dis[U] + Val < Dis[V]){\n\t\t\t\tDis[V] = Dis[U] + Val;\n\t\t\t\tQ.push((Node){V, Dis[V]});\n\t\t\t}\n\t\t}\n\t}\n\treturn Dis[T];\n}\nint main()\n{\n\tmemset(F, -1, sizeof(F));\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\tfor(int I = 1; I <= 100; ++I)\n\t\tInsert(I, I + 1, -1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tInsert(I, I + 1, -2);\n\tM = 200;\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1)\n\t\t\t\tInsert(1 + I, 102 + J, F[I][100 - J]), ++M;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\tif(Dij(X, Y) != D[X][Y]){cout<<Dij(X, Y)<<endl;puts(\"Impossilble\"); return 0;}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1){\n\t\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\t\t\t}\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 200\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint A,B,d[35][35],b[35][35],m;\nstruct edge{int x,y,w;}e[MN*MN+5];\nint main()\n{\n    A=read();B=read();\n    for(int i=1;i<=A;++i) for(int j=1;j<=B;++j) d[i][j]=read();\n    for(int i=0;i<=100;++i) for(int j=0;j<=100;++j)\n    {\n        int mn=0;\n        for(int k=1;k<=A;++k) for(int l=1;l<=B;++l) mn=max(mn,d[k][l]-k*i-l*j);\n        e[++m]=(edge){i+1,202-j,mn};\n        for(int k=1;k<=A;++k) for(int l=1;l<=B;++l) if(k*i+j*l+mn==d[k][l]) b[k][l]=1;\n    }\n    for(int i=1;i<=A;++i) for(int j=1;j<=B;++j) if(!b[i][j]) return 0*puts(\"Impossible\");\n    printf(\"Possible\\n%d %d\\n\",202,m+200);\n    for(int i=1;i<=100;++i) printf(\"%d %d x\\n\",i,i+1),printf(\"%d %d y\\n\",i+101,i+102);\n    for(int i=1;i<=m;++i) printf(\"%d %d %d\\n\",e[i].x,e[i].y,e[i].w);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct edge {\n\tint from,to,weight;\n} e[100009];int en;\nvoid adde(int a,int b,int w) {\n\te[en].from = a;\n\te[en].to = b;\n\te[en].weight = w;\n\t++en;\n}\nint arr[13][13];\nint main()\n{\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i = 1;i <= 99;++i) adde(i,i+1,-10002);\n\tfor(int i = 1;i <= 99;++i) adde(100+i,101+i,-10001);\n\tfor(int i = 1;i <= a;++i) {\n\t\tfor(int j = 1;j <= b;++j) {\n\t\t\tscanf(\"%d\",&arr[i][j]);\n\t\t\tif(j >= 2 && arr[i][j] - arr[i][j-1] > arr[i][j-1] - arr[i][j-2]) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(i >= 2 && arr[i][j] - arr[i-1][j] > arr[i-1][j] - arr[i-2][j]) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = std::max(arr[i+1][j] - arr[i][j],0),y = std::max(arr[i][j+1] - arr[i][j],0),z = arr[i][j] - x - y;\n\t\t\tadde(1+x,200-y,z);\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",300,en);\n\tfor(int i = 0;i < en;++i) {\n\t\tprintf(\"%d %d \",e[i].from,e[i].to);\n\t\tif(e[i].weight == -10002)\n\t\t\tprintf(\"X\\n\");\n\t\telse if(e[i].weight == -10001)\n\t\t\tprintf(\"Y\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",e[i].weight);\n\t}\n\tprintf(\"%d %d\\n\",1,200);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint A, B;\nint D[20][20];\nint E[MAX_N], F[MAX_N], C[MAX_N];\n\nvoid add_edge(int a, int b, int c) {\n\tE[N] = a; F[N] = b; C[N] = c;\n\tN++;\n}\n\nvoid solve() {\n\tcin >> A >> B;\n\trep(i, 0, A) {\n\t\trep(j, 0, B) {\n\t\t\tcin >> D[i][j];\n\t\t}\n\t}\n\trep(x, 1, A + 1) {\n\t\trep(y, 1, B + 1) {\n\t\t\tbool found = false;\n\t\t\trep(a, 0, 100 + 1) {\n\t\t\t\trep(b, 0, 100 + 1) {\n\t\t\t\t\tint c = D[x - 1][y - 1] - (a * x + b * y);\n\t\t\t\t\tif(c < 0 || c > 100 || found) continue;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\trep(i, 1, A + 1) {\n\t\t\t\t\t\trep(j, 1, B + 1) {\n\t\t\t\t\t\t\tif(D[i - 1][j - 1] > a * i + b * j + c) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tadd_edge(a, 201 - b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) {\n\t\t\t\tcout << \"Impossible\" << \"\\n\"; return;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, 100) {\n\t\tadd_edge(i, i + 1, 101);\n\t\tadd_edge(101 + i, 102 + i, 102);\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 202 << \" \" << N << \"\\n\";\n\trep(i, 0, N) {\n\t\tif(C[i] == 101) cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << \"X\\n\";\n\t\telse if(C[i] == 102) cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << \"Y\\n\";\n\t\telse cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << C[i] << \"\\n\";\n\t}\n\tcout << 1 << \" \" << 202 << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint a, b; cin >> a >> b;\n\tvector<vi> v(a, vi(b));\n\trep(i, a) rep(j, b) cin >> v[i][j];\n\t\n\tvector<vi> dist(101, vi(101));\n\tfor(int i = 1; i <= a; i++) for(int j = 1; j <= b; j++){\n\t\t//x = i, y = jとしたとき\n\t\t//ki + lj + dist[k][l] >= v[i][j]\n\t\trep(k, 101) rep(l, 101){\n\t\t\tdist[k][l] = max(dist[k][l], v[i-1][j-1] - k * i - l * j);\n\t\t}\n\t}\n\tfor(int i = 1; i <= a; i++) for(int j = 1; j <= b; j++){\n\t\tint mn = inf;\n\t\trep(k, 101) rep(l, 101){\n\t\t\tmn = min(mn, k * i + l * j + dist[k][l]);\n\t\t}\n\t\tif(mn != v[i-1][j-1]){\n\t\t\tdbg(i, j, mn, v[i-1][j-1]);\n\t\t\tdbg(dist[1][0]);\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint m = 200 + 101 * 101;\n\t\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << m << endl;\n\trep(i, 100) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n\trep(i, 100) cout << i+102 << \" \" << i+103 << \" Y\" << endl;\n\trep(i, 101) rep(j, 101){\n\t\tcout << i+1 << \" \" << 202-j << \" \" << dist[i][j] << endl;\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[11][11];\nint f[101][101];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint A,B;\n\tcin>>A>>B;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tcin>>d[i][j];\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tf[a][b]=max(d[i][j]-i*a-j*b,f[a][b]);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tbool sw=false;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tif(f[a][b]+a*i+b*j==d[i][j])\n\t\t\t\t\t\tsw=true;\n\t\t\tif(!sw){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<101*101+200<<endl;\n\tcout<<201<<' '<<1<<\" X\\n\";\n\tfor(int i=1;i<100;i++)\n\t\tcout<<i<<' '<<i+1<<\" X\\n\";\n\tfor(int i=101;i<200;i++)\n\t\tcout<<i<<' '<<i+1<<\" Y\\n\";\n\tcout<<200<<' '<<202<<\" Y\\n\";\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tif(i==0)\n\t\t\t\tcout<<201;\n\t\t\telse\n\t\t\t\tcout<<i;\n\t\t\tcout<<' ';\n\t\t\tif(j==0)\n\t\t\t\tcout<<202<<' ';\n\t\t\telse\n\t\t\t\tcout<<201-j<<' ';\n\t\t\tcout<<f[i][j]<<'\\n';\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint d[11][11];\nint w[102][102];\n\nint main(){\n  int a,b;\n  cin>>a>>b;\n  rep(i,a) rep(j,b) cin>>d[i][j];\n\n  rep(i,101) rep(j,101){\n    // i*x + j*y + w[i][j] >= d[k][l] for all k,l\n    w[i][j] = 0;\n    rep(k,a) rep(l,b) w[i][j] = max(w[i][j], d[k][l] - i*(k+1) - j*(l+1));\n  }\n\n  rep(k,a) rep(l,b){\n    int tmp = INF;\n    rep(i,101) rep(j,101){\n      tmp = min(tmp, w[i][j] + i*(k+1) + j*(l+1));\n    }\n    if(tmp != d[k][l]){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Possible\\n\";\n  cout << \"202 10401\\n\";\n\n  rep(i,1,101) cout << i << \" \" << i+1 << \" X\\n\";\n  rep(i,102,202) cout << i << \" \" << i+1 << \" Y\\n\";\n  rep(i,101) rep(j,101){\n    cout << i+1 << \" \" << 202-j << \" \" << w[i][j] << \"\\n\";\n  }\n\n  cout << \"1 202\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 502;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[N],st2[N],st3[N];\nbool mrk[N];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=1; t=2;\n\trep(a,0,20) rep(b,0,20) {\n\t\tint mx=-1;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-a*i-b*j); if (mx==-1) continue;\n\t\tif (sz==300) break; C[a][b]=mx; dy[a][b]=++sz;\n\t\trep(i,1,n) rep(j,1,m) ok[i][j]|=(d[i][j]-a*i-b*j==mx);\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\trep(a,0,20) rep(b,0,20) {\n\t\tif (dy[a][b]&&dy[a+1][b]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a+1][b]; st3[tot]=1;}\n\t\tif (dy[a][b]&&dy[a][b+1]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a][b+1]; st3[tot]=2;}\n\t}\n\trep(a,0,20) rep(b,0,20) if (dy[a][b]) {\n\t\ttot++; st1[tot]=dy[a][b]; st2[tot]=t;\n\t\tmrk[tot]=1; st3[tot]=C[a][b];\n\t}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[0][1]; st3[tot]=2;}\n\tif (dy[1][0]) {tot++; st1[tot]=s; st2[tot]=dy[1][0]; st3[tot]=1;}\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",sz,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"1 2\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nmain() {\n    INT(n, m);\n    VV(int, a, n, m);\n    int N = 101;\n    vv(int, d, N + 1, N + 1);\n    vv(bool, ok, n, m);\n    rep(x, N + 1) {\n        rep(y, N + 1) {\n            rep(i, n) rep(j, m) { chmax(d[x][y], a[i][j] - (i + 1) * x - (j + 1) * y); }\n            rep(i, n) rep(j, m) if(a[i][j] == d[x][y] + (i + 1) * x + (j + 1) * y) ok[i][j] = true;\n            // cout << d[x][y] << \" \";\n        }\n        // cout << endl;\n    }\n    rep(i, n) rep(j, m) {\n        if(!ok[i][j]) {\n            cout << \"Impossible\\n\";\n            exit(0);\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << N * 2 + 2 << \" \" << N * 2 + 1 + (N + 1) * (N + 1) << endl;\n    rep2(i, 1, N) cout << i << \" \" << i + 1 << \" \" << 'X' << endl;\n    cout << N + 1 << \" \" << N + 2 << \" \" << 0 << endl;\n    rep2(i, N + 2, N * 2 + 1) cout << i << \" \" << i + 1 << \" \" << 'Y' << endl;\n    rep(i, N + 1) rep(j, N + 1) {\n        int t = 1 + i, s = N * 2 + 2 - j;\n        cout << t << \" \" << s << \" \" << d[i][j] << endl;\n    }\n    cout << 1 << \" \" << N * 2 + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[11][11];\nint c[111][111];\n\nint main(){\n    int A, B; scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++) for(int j=1;j<=B;j++) scanf(\"%d\",&d[i][j]);\n\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) c[i][j] = -1;\n\n    for(int x=1;x<=A;x++) for(int y=1;y<=B;y++){\n        bool found = false;\n        for(int a=0;a<=100;a++){\n            for(int b=0;b<=100;b++){\n                int curC = d[x][y] - x*a - y*b;\n                if(0<=curC && curC<=100){\n                    bool cur = true;\n                    for(int xx=1;xx<=A;xx++){\n                        for(int yy=1;yy<=B;yy++){\n                            if(curC + xx*a + yy*b < d[xx][yy]){\n                                cur = false;\n                                break;\n                            }\n                        }\n                        if(!cur) break;\n                    }\n                    if(cur){\n                        found = true;\n                        c[a][b] = curC;\n                        break;\n                    }\n                }\n            }\n            if(found) break;\n        }\n        if(!found) return !printf(\"Impossible\\n\");\n    }\n\n    printf(\"Possible\\n\");\n\n    int xMax = 0, yMax = 0;\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) if(c[i][j]>=0){\n        xMax = max(xMax, i);\n        yMax = max(yMax, j);\n    }\n    int N = xMax + yMax + 2;\n\n    int M = N - 2;\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) if(c[i][j] >= 0) M++;\n\n    printf(\"%d %d\\n\", N, M);\n    for(int i=1;i<=xMax;i++) printf(\"%d %d X\\n\", i, i+1);\n    for(int i=0;i<yMax;i++) printf(\"%d %d Y\\n\", N-i-1, N-i);\n\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) if(c[i][j] >= 0)\n        printf(\"%d %d %d\\n\", 1+i, N-j, c[i][j]);\n\n    printf(\"1 %d\\n\", N);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007\n#define lson(v) ((v)<<1)\n#define rson(v) (((v)<<1)^1)\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\ntypedef pair < pii , int > p3i;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint A,B,arr[15][15];\nvector < p3i > paths;\nint main(){\n    // inputing start\n    scanf(\"%d%d\",&A,&B);\n\tint xb,x2,x3,x4,x5,mmax=0,mmay=0;\n\tfor(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tscanf(\"%d\",&arr[xb][x2]);\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    for(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tint a=xb+1,b=x2+1,k=arr[xb][x2],maxy=105,miny=0;\n\t\t\tfor(x5=0;x5<=105;++x5){\n\t\t\t\tmaxy=105;miny=0;\n\t\t\t\tfor(x3=0;x3<A;++x3){\n\t\t\t\t\tfor(x4=0;x4<B;++x4){\n\t\t\t\t\t\tint n=x3+1,m=x4+1,c=arr[x3][x4],coe=m-b,val=c-k-x5*(n-a);\n\t\t\t\t\t\tif(x3==xb && x4==x2){\n\t\t\t\t\t\t\tn=-a;m=-b;c=-k;\n\t\t\t\t\t\t\tval=c-k-x5*(n-a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe*val<0){\n\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(val==0){\n\t\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\t\tUMIN(maxy,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe==0){\n\t\t\t\t\t\t\tif(val>0){\n\t\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\tUMIN(maxy,(-val)/(-coe));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe>0){\n\t\t\t\t\t\t\tUMAX(miny,(val+coe-1)/coe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(miny<=maxy){\n\t\t\t\t\tif(k-x5*a-miny*b<0) continue;\n\t\t\t\t\tpaths.push_back(mpr(mpr(x5,miny),k-x5*a-miny*b));\n\t\t\t\t\tUMAX(mmax,x5);\n\t\t\t\t\tUMAX(mmay,miny);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x5>105){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\tax+by+z=k\n\t\t\t *  -ax-by>=-k\n\t\t\t\tz=k-ax-by\n\t\t\t\tnx+my+k-ax-by>=c\n\t\t\t\t(n-a)x+(m-b)y>=c-k  \n\t\t\t\tcoe*y>=val  \n\t\t\t\tor\n\t\t\t\t-coe*y<=-val  */\n\t\t}\n\t}\n\tsort(paths.begin(),paths.end());\n\tpaths.erase(unique(paths.begin(),paths.end()),paths.end());\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",mmax+1+mmay+1,mmax+mmay+(int)paths.size());\n\tfor(xb=0;xb<mmax;++xb){\n\t\tprintf(\"%d %d x\\n\",xb+1,xb+2);\n\t}\n\tfor(xb=mmay-1;xb>=0;--xb){\n\t\tprintf(\"%d %d y\\n\",mmax+xb+3,mmax+xb+2);\n\t}\n\tfor(xb=0;xb<paths.size();++xb){\n\t\tprintf(\"%d %d %d\\n\",paths[xb].first.first+1,paths[xb].first.second+mmax+2,paths[xb].second);\n\t}\n\tprintf(\"%d %d\\n\",1,mmax+2);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ll long long\nconst int INF = 1000 * 1000 * 1000;\nconst ll LINF = (ll)INF * INF;\nint A , B;\nint d[11][11];\nint f[101][101];\nint dist[202];\n\nint main()\n{\n\t//freopen(\"input.txt\" , \"r\" , stdin);\n\t//freopen(\"output.txt\" , \"w\" , stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i++)\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\tfor(int a = 0; a <= 100; a++)\n\t\tfor(int b = 0; b <= 100; b++)\n\t\t{\n\t\t\tfor(int x = 1; x <= A; x++)\n\t\t\t\tfor(int y = 1; y <= B; y++)\n\t\t\t\t{\n\t\t\t\t\tf[a][b] = max(f[a][b] , d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t}\n\tbool good = true;\n\tfor(int x = 1; x <= A; x++)\n\t\tfor(int y = 1; y <= B; y++)\n\t\t{\n\t\t\tfor(int i = 0; i < 202; i++)\n\t\t\t\tdist[i] = INF;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tdist[i] = x * i;\n\t\t\tfor(int i = 100; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif(i != 100)\n\t\t\t\t\tdist[i + 101] = dist[i + 1 + 101] + y;\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist[i + 101] = min(dist[i + 101] , f[j][i] + dist[j]);\n\t\t\t}\n\t\t\tif(dist[101] != d[x][y])\n\t\t\t\tgood = false;\n\t\t}\n\n\tif(good)\n\t{\n\t\tprintf(\"Possible\\n\");\n\t\tint n = 202;\n\t\tprintf(\"%d %d\\n\" , (n - 2) + n * n / 4);\n\t\tfor(int i = 1; i <= 100; i++)\n\t\t{\n\t\t\tprintf(\"%d %d X\\n\" , i - 1 , i);\n\t\t\tprintf(\"%d %d Y\\n\" , i + 101 , i + 101 - 1);\n\t\t}\n\t\tfor(int i = 0; i <= 100; i++)\n\t\t{\n\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\" , i , j + 101 , f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 101;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint A, B;\nint d[N][N];\nint ga[N][N];\nint gb[N][N];\nint gc[N][N];\nbool us[N][N][N];\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> A >> B;\n        for(int i = 1; i <= A; i++){\n                for(int j = 1; j <= B; j++){\n                        cin >> d[i][j];\n                        ga[i][j] = -1;\n                }\n        }\n        vector < int > a, b, c;\n        for(int x = 0; x <= 100; x++){\n                for(int y = 0; y <= 100; y++){\n                        for(int z = 0; z <= 100; z++){\n                                bool good = true;\n                                for(int i = 1; i <= A && good; i++){\n                                        for(int j = 1; j <= B; j++){\n                                                if(i * x + j * y + z < d[i][j]){\n                                                        good = false;\n                                                        break;\n                                                }\n                                        }\n                                }\n                                if(good){\n                                        for(int i = 1; i <= A; i++){\n                                                for(int j = 1; j <= B; j++){\n                                                        if(i * x + j * y + z == d[i][j]){\n                                                                ga[i][j] = x;\n                                                                gb[i][j] = y;\n                                                                gc[i][j] = z;\n                                                        }\n                                                }\n                                        }\n                                }\n                        }\n                }\n        }\n        int res = 1;\n        for(int i = 1; i <= A; i++){\n                for(int j = 1; j <= B; j++){\n                        if(ga[i][j] == -1){\n                                cout << \"Impossible\" << \"\\n\";\n                                return 0;\n                        }\n                        int x = ga[i][j], y = gb[i][j], z = gc[i][j];\n                        if(!us[x][y][z]){\n                                us[x][y][z] = 1;\n                                a.push_back(x);\n                                b.push_back(y);\n                                c.push_back(z);\n                        }\n                }\n        }\n\n        int G = 2;\n        vector < pair < pair < int, int >, int > > E;\n        for(int i = 0; i < a.size(); i++){\n                int s = 1;\n                for(int j = 0; j < a[i]; j++){\n                        G += 1;\n                        E.push_back({{s, G}, -1});\n                        s = G;\n                }\n                for(int j = 0; j < b[i]; j++){\n                        G += 1;\n                        E.push_back({{s, G}, -2});\n                        s = G;\n                }\n                E.push_back({{s, 2}, c[i]});\n        }\n        cout << \"Possible\" << \"\\n\";\n        cout << G << \" \" << E.size() << \"\\n\";\n        for(auto p: E){\n                cout << p.fi.fi << ' ' << p.fi.se << ' ';\n                if(p.se == -1){\n                        cout << \"X\\n\";\n                } else if(p.se == -2){\n                        cout << \"Y\\n\";\n                } else{\n                        cout << p.se << \"\\n\";\n                }\n        }\n        cout << \"1 2\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << n-1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "//全力前進　Yosoro！\n//AT3877 \n#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n    int a,b,c;\n}ans[310];\nvoid print()\n{\n    int numn=0,numm=0;\n    for (int i=1;i<=sum;i++)\n    {\n        numm+=ans[i].a+ans[i].b+1;\n        numn+=ans[i].a+ans[i].b;\n    }\n    numn+=2;\n    if (numn>300) {while(1);printf(\"Impossible\\n\");return;}\n    printf(\"Possible\\n\");\n    printf(\"%d %d\\n\",numn,numm);\n    int t=1,pre=1;\n    for (int i=1;i<=sum;i++)\n    {\n        pre=1;\n        printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n        for (int j=1;j<=ans[i].a;j++)\n        {\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].a&&ans[i].b==0)?numn:++t,'X'),pre=t;\n        }\n        for (int j=1;j<=ans[i].b;j++)\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\n    }\n    printf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%d\",&d[i][j]);\n    for (int s=0;s<=300;s++)\n        for (int a=0;a<=s&&a<=100;a++)\n            for (int b=0;b<=s-a&&b<=100;b++)\n                {\n                    int c=s-a-b;\n                    bool p=0,q=0;\n                    int now=0;\n                    for (int i=1;i<=n;i++)\n                    {\n                        for (int j=1;j<=m;j++)\n                        {\n                            if (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n                            else if (a*i+b*j+c<d[i][j]) {p=1;break;}\n                        }\n                        if (p==1) break;\n                    }\n                    if ((!p)&&q) \n                    {\n                        for (int i=1;i<=now;i++)\n                            vis[pa[i]][pb[i]]=1;\n                        tot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n                        if (tot==n*m){print();return 0;}\n                    }\n                }\n    printf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible1\\n\";\n        return 0;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  std::cout << \"Possible\\n\";\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\n#define B cerr<<\"Break Point\"<<endl;\n\nconstexpr int N=15;\nconstexpr int M=105;\n\nint n,m;\nint d[N][N];\nint f[M][M];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=m;++j)\n            scanf(\"%d\",&d[i][j]);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            for(int x=1;x<=n;++x)\n                for(int y=1;y<=m;++y)\n                    f[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n    for(int x=1;x<=n;++x)\n        for(int y=1;y<=m;++y)\n        {\n            int nowdis=1e9;\n            for(int i=0;i<=100;++i)\n                for(int j=0;j<=100;++j)\n                    nowdis=min(nowdis,f[i][j]+i*x+j*y);\n            if(nowdis!=d[x][y])\n            {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    printf(\"%d %d\\n\",202,10401);\n    for(int i=1;i<=100;++i) printf(\"%d %d X\\n\",i,i+1);\n    for(int i=102;i<=201;++i) printf(\"%d %d Y\\n\",i,i+1);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    printf(\"%d %d\\n\",1,202);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 2005\nusing namespace std;\nint a,b,tot;\nint d[maxn][maxn];\nint dis[maxn][maxn];\nint head[maxn],nex[maxn*maxn],to[maxn*maxn];\nstring val[maxn*maxn];\nvoid add(int x,int y,string z)\n{\n\tto[++tot]=y; val[tot]=z; nex[tot]=head[x]; head[x]=tot;\n}\nint main()\n{\n\tmemset(dis,0x3f,sizeof(dis));\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\n\tfor(int i=1;i<=100;i++)\n\t\tadd(i,i+1,\"X\");\n\n\tfor(int i=102;i<=201;i++)\n\t\tadd(i,i+1,\"Y\");\n\t\n//\tcerr<<\"+2\"<<endl;\n\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint z=0;\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\tz=max(z,d[k][o]-k*i-o*j);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr<<\"its \"<<i<<\" \"<<j<<endl;\n\t\t\tadd(i+1,202-j,to_string(z));\n\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\tdis[k][o]=min(dis[k][o],z+i*k+o*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcerr<<\"+1\"<<endl;\n\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\tif(dis[i][j]!=d[i][j])\n\t\t{\n//\t\t\tcerr<<d[i][j]<<' '<<dis[i][j]<<endl;\n\t\t\treturn printf(\"Impossible\\n\"),0;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,tot);\n\tfor(int i=1;i<=101;i++)\n\t{\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t{\n\t\t\tcout<<i<<\" \"<<to[j]<<\" \"<<val[j]<<endl;\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int A, B;\n    cin >> A >> B;\n\n    vvi d(A + 1, vi(B + 1));\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++)\n            cin >> d[i][j];\n    }\n\n    vvi c(101, vi(101));\n    for (int xc = 0; xc <= 100; xc++) {\n        for (int yc = 0; yc <= 100; yc++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[xc][yc] = max(c[xc][yc], d[x][y] - xc * x - yc * y);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int sp = INT_MAX;\n            for (int xc = 0; xc <= 100; xc++) {\n                for (int yc = 0; yc <= 100; yc++) {\n                    sp = min(sp, xc * x + yc * y + c[xc][yc]);\n                }\n            }\n            if (sp != d[x][y]) { cout << \"Impossible\\n\"; return 0; }\n        }\n    }\n\n    int XL = 1, YL = XL + 101, SNK = YL + 101;\n    int V = SNK, E = 100 + 100 + 101 * 101 + 101;\n\n    cout << \"Possible\\n\";\n    cout << V << \" \" << E << \"\\n\";\n    for (int xc = 1; xc <= 100; xc++)\n        cout << (XL + xc - 1) << \" \" << (XL + xc) << \" X\\n\";\n    for (int yc = 0; yc < 100; yc++)\n        cout << (YL + yc) << \" \" << (YL + yc + 1) << \" Y\\n\";\n    for (int xc = 0; xc <= 100; xc++)\n        for (int yc = 0; yc <= 100; yc++)\n            cout << (XL + xc) << \" \" << (YL + yc) << \" \" << c[xc][yc] << \"\\n\";\n    for (int yc = 0; yc <= 100; yc++)\n        cout << (YL + yc) << \" \" << SNK << \" 0\\n\";\n    cout << 1 << \" \" << SNK << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "Possible\n202 202\n1 2 X\n2 3 X\n3 4 X\n4 5 X\n5 6 X\n6 7 X\n7 8 X\n8 9 X\n9 10 X\n10 11 X\n11 12 X\n12 13 X\n13 14 X\n14 15 X\n15 16 X\n16 17 X\n17 18 X\n18 19 X\n19 20 X\n20 21 X\n21 22 X\n22 23 X\n23 24 X\n24 25 X\n25 26 X\n26 27 X\n27 28 X\n28 29 X\n29 30 X\n30 31 X\n31 32 X\n32 33 X\n33 34 X\n34 35 X\n35 36 X\n36 37 X\n37 38 X\n38 39 X\n39 40 X\n40 41 X\n41 42 X\n42 43 X\n43 44 X\n44 45 X\n45 46 X\n46 47 X\n47 48 X\n48 49 X\n49 50 X\n50 51 X\n51 52 X\n52 53 X\n53 54 X\n54 55 X\n55 56 X\n56 57 X\n57 58 X\n58 59 X\n59 60 X\n60 61 X\n61 62 X\n62 63 X\n63 64 X\n64 65 X\n65 66 X\n66 67 X\n67 68 X\n68 69 X\n69 70 X\n70 71 X\n71 72 X\n72 73 X\n73 74 X\n74 75 X\n75 76 X\n76 77 X\n77 78 X\n78 79 X\n79 80 X\n80 81 X\n81 82 X\n82 83 X\n83 84 X\n84 85 X\n85 86 X\n86 87 X\n87 88 X\n88 89 X\n89 90 X\n90 91 X\n91 92 X\n92 93 X\n93 94 X\n94 95 X\n95 96 X\n96 97 X\n97 98 X\n98 99 X\n99 100 X\n100 101 X\n102 103 Y\n103 104 Y\n104 105 Y\n105 106 Y\n106 107 Y\n107 108 Y\n108 109 Y\n109 110 Y\n110 111 Y\n111 112 Y\n112 113 Y\n113 114 Y\n114 115 Y\n115 116 Y\n116 117 Y\n117 118 Y\n118 119 Y\n119 120 Y\n120 121 Y\n121 122 Y\n122 123 Y\n123 124 Y\n124 125 Y\n125 126 Y\n126 127 Y\n127 128 Y\n128 129 Y\n129 130 Y\n130 131 Y\n131 132 Y\n132 133 Y\n133 134 Y\n134 135 Y\n135 136 Y\n136 137 Y\n137 138 Y\n138 139 Y\n139 140 Y\n140 141 Y\n141 142 Y\n142 143 Y\n143 144 Y\n144 145 Y\n145 146 Y\n146 147 Y\n147 148 Y\n148 149 Y\n149 150 Y\n150 151 Y\n151 152 Y\n152 153 Y\n153 154 Y\n154 155 Y\n155 156 Y\n156 157 Y\n157 158 Y\n158 159 Y\n159 160 Y\n160 161 Y\n161 162 Y\n162 163 Y\n163 164 Y\n164 165 Y\n165 166 Y\n166 167 Y\n167 168 Y\n168 169 Y\n169 170 Y\n170 171 Y\n171 172 Y\n172 173 Y\n173 174 Y\n174 175 Y\n175 176 Y\n176 177 Y\n177 178 Y\n178 179 Y\n179 180 Y\n180 181 Y\n181 182 Y\n182 183 Y\n183 184 Y\n184 185 Y\n185 186 Y\n186 187 Y\n187 188 Y\n188 189 Y\n189 190 Y\n190 191 Y\n191 192 Y\n192 193 Y\n193 194 Y\n194 195 Y\n195 196 Y\n196 197 Y\n197 198 Y\n198 199 Y\n199 200 Y\n200 201 Y\n201 202 Y\n1 201 0\n3 202 0\n1 202\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int y=1;y<B;y++){\n        int b = d[A][y+1] - d[A][y];\n        int c = d[A][y] - b*y;\n        if (b >= 0 && c >= 0 && c <= 100)C[0][b] = min(C[0][b],c);\n    }\n    for(int x=1;x<A;x++){\n        int a = d[x+1][B] - d[x][B];\n        int c = d[x][B] - a*x;\n        if (a >= 0 && c >= 0 && c <= 100)C[a][0] = min(C[a][0],c);\n    }\n    C[0][0] = min(C[0][0], d[A][B]);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nvector<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\tread(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = 1;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i + 1 < 50; ++i) {\n\t\tedge.pb({{lenXY[i], s}, -1});\n\t\tedge.pb({{s, lenXY[i + 1]}, -2});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 99; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.pb({{lenX[i], lenX[i + 1]}, -1});\n\t\tedge.pb({{lenY[i], lenY[i + 1]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.pb({{lenXY[Y[i][j]], lenX[X[i][j] - Y[i][j]]}, d[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.pb({{lenXY[X[i][j]], lenY[Y[i][j] - X[i][j]]}, d[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        cout << \"Possible\" << endl;\n        cout << n << \" \" << edges.size() << endl;\n        each(e, edges) {\n            cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <tuple>\nusing namespace std;\n\nint A, B, d[100][100], e[100][100]; bool used[100][100]; vector<tuple<int, int, int>>X;\n\nint main() {\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) cin >> d[i][j];\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tif (used[i][j] == true) continue;\n\t\t\tbool flag2 = false;\n\t\t\tfor (int k = 0; k <= 100; k++) {\n\t\t\t\tint P1 = i*k; if (P1 > d[i][j]) continue;\n\t\t\t\tfor (int l = 0; l <= 100; l++) {\n\t\t\t\t\tint P2 = j*l; if (P1 + P2 > d[i][j]) continue;\n\t\t\t\t\tint X1 = i, X2 = j, X3 = d[i][j] - P1 - P2;\n\t\t\t\t\t\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int m = 1; m <= A; m++) {\n\t\t\t\t\t\tfor (int n = 1; n <= B; n++) {\n\t\t\t\t\t\t\tint K = m*X1 + n*X2 + X3;\n\t\t\t\t\t\t\tif (d[m][n] > K) { flag = false; break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == false) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag == true) {\n\t\t\t\t\t\tX.push_back(make_tuple(X1, X2, X3));\n\t\t\t\t\t\tfor (int m = 1; m <= A; m++) {\n\t\t\t\t\t\t\tfor (int n = 1; n <= B; n++) {\n\t\t\t\t\t\t\t\tint K = m*X1 + n*X2 + X3;\n\t\t\t\t\t\t\t\tif (d[m][n] == K) used[m][n] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2 == true) break;\n\t\t\t}\n\t\t\tif (flag2 == false) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tvector<tuple<int, int, string>>G;\n\tfor (int i = 1; i <= 100; i++) G.push_back(make_tuple(i, i + 1, \"X\"));\n\tfor (int i = 102; i <= 201; i++) G.push_back(make_tuple(i, i + 1, \"Y\"));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tG.push_back(make_tuple(get<0>(X[i]) + 1, 202 - get<1>(X[i]), to_string(get<2>(X[i]))));\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << \"202 \" << G.size() << endl;\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tcout << get<0>(G[i]) << \" \" << get<1>(G[i]) << \" \" << get<2>(G[i]) << endl;\n\t}\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\n#define mp make_pair\n#define pb push_back\n#define ld long double\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\n#define piii pair<pii,pii>\n#define precise cout<<fixed<<setprecision(10)\n#define st first\n#define nd second\n#define ins insert\n#define vi vector<int>\n#define BOOST ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\nusing namespace std;\nconst int MAX=105;\nconst int inf=1e9+9;\nint tab[MAX][MAX];\nint f[MAX][MAX];\nint32_t main()\n{\n  BOOST;\n  int n,m;\n  cin>>n>>m;\n  for (int i=1;i<=n;i++)\n  \tfor (int j=1;j<=m;j++)\n  \t\tcin>>tab[i][j];\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n       for (int k=1;k<=n;k++)\n         for (int l=1;l<=m;l++)\n           f[i][j]=max(f[i][j],tab[k][l]-i*k-j*l);\n           \n  for (int i=1;i<=n;i++)\n    for (int j=1;j<=m;j++)\n    {\n    \tint mini=inf;\n    \tfor (int k=0;k<=100;k++)\n    \t  for (int l=0;l<=100;l++)\n    \t    mini=min(mini,f[k][l]+i*k+j*l);\n    \tif (mini!=tab[i][j])cout<<\"Impossible\",exit(0);\n    }\n   \n    cout<<\"Possible\\n\";\n  cout<<\"202 \"<<\"10401\\n\";\n  for (int i=1;i<=100;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"X\"<<\"\\n\";\n  for (int i=102;i<=201;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"Y\"<<\"\\n\";\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n      cout<<i+1<<\" \"<<202-j<<\" \"<<f[i][j]<<\"\\n\";\n  cout<<\"1 \"<<\"202\";\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nconst int MAXA = 17;\n\nint D[MAXA][MAXA], C[MAXA][MAXA];\nvector <pair <PII, int> > E;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint a, b, n = 202;\n\tcin >> a >> b;\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tcin >> D[i][j];\n\t\tC[i][j] = INF;\n\t}\n\tREP(c1, 101)\n\t\tREP(c2, 101)\n\t\tREP(c3, 101)\n\t{\n\t\tbool ok = true, s = false;\n\t\tFOR(i, 1, a + 1)\n\t\t\tFOR(j, 1, b + 1)\n\t\t{\n\t\t\tint d = c1 * i + c2 * j + c3;\n\t\t\tif (d < D[i][j])\n\t\t\t\tok = false;\n\t\t\tif (d == D[i][j] && C[i][j] > D[i][j])\n\t\t\t\ts = true;\n\t\t}\n\t\tif (ok && s)\n\t\t{\n\t\t\tFOR(i, 1, a + 1)\n\t\t\t\tFOR(j, 1, b + 1)\n\t\t\t\tC[i][j] = min(C[i][j], c1 * i + c2 * j + c3);\n\t\t\tE.push_back(MP(MP(c1 + 1, n - c2), c3));\n\t\t}\n\t}\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tif (C[i][j] > D[i][j])\n\t\t{\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << SZ(E) + n - 2 << '\\n';\n\tREP(i, (n - 2) / 2)\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\tREP(i, (n - 2) / 2)\n\t\tcout << n - i - 1 << ' ' << n - i << \" Y\\n\";\n\tREP(i, SZ(E))\n\t\tcout << E[i].first.first << ' ' << E[i].first.second << ' ' << E[i].second << '\\n';\n\tcout << \"1 \" << n << endl;\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing K = long double;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define SIZE(a) ((int)(a).size())\n\nconst int N = 15;\nconst int M = 105;\n\nint n = 204, m;\nvector<tuple<int,int,int>> edges; \n\nint a, b, d[N][N];\nint used[N][N];\nint was[M][M];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> a >> b;\n\tfor (int i = 1; i <= a; ++i) {\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tfor (int r = 0; r <= 100; ++r) {\n\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\tif (was[x][y]) continue;\n\t\t\t\tint failed = 0;\n\t\t\t\tfor (int i = 1; i <= a; ++i) {\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (r + x*i + y*j < d[i][j]) {\n\t\t\t\t\t\t\tfailed = 1;\n\t\t\t\t\t\t\tgoto fin;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfin:\n\t\t\t\tif (!failed) {\n\t\t\t\t\tedges.emplace_back(2 + x, 103 + y, r);\n\t\t\t\t\twas[x][y] = 1;\n\t\t\t\t\tfor (int i = 1; i <= a; ++i) {\n\t\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\t\tif (r + x*i + y*j == d[i][j]) {\n\t\t\t\t\t\t\t\tused[i][j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= a; ++i) {\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tif (!used[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\n\tcout << n << ' ' << SIZE(edges)+202 << '\\n';\n\tcout << 1 << ' ' << 2 << ' ' << 0 << '\\n';\n\tcout << 103 << ' ' << 204 << ' ' << 0 << '\\n';\n\tfor (int i = 2; i <= 101; ++i) {\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 103; i <= 202; ++i) {\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (auto& item : edges) {\n\t\tint x, y, c;\n\t\ttie(x, y, c) = item;\n\t\tcout << x << ' ' << y << ' ' << c << '\\n';\n\t}\n\tcout << 1 << ' ' << 204 << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint A,B,cnt,d[11][11];\nbool b[11][11];\nstruct edge{\n\tint s,t,w;\n\tedge():s(0),t(0),w(0){}\n\tedge(int s,int t,int w):s(s),t(t),w(w){}\n}es[40005];\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';f=c=='-'?-1:1,c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0',c=getchar());\n\treturn x*f;\n}\nint main(){\n\tA=read();B=read();\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\td[i][j]=read();\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tint maxw=0;\n\t\t\tfor(int k=1;k<=A;k++)\n\t\t\t\tfor(int l=1;l<=B;l++)\n\t\t\t\t\tmaxw=max(maxw,d[k][l]-k*i-l*j);\n\t\t\tes[++cnt]=edge(i+1,202-j,maxw);\n\t\t\tfor(int k=1;k<=A;k++)\n\t\t\t\tfor(int l=1;l<=B;l++)\n\t\t\t\t\tif(d[k][l]==k*i+l*j+maxw)b[k][l]=1;\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tif(!b[i][j])return 0*puts(\"Impossible\");\n\tprintf(\"Possible\\n202 %d\\n\",cnt+200);\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n%d %d Y\\n\",i,i+1,i+101,i+102);\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d %d\\n\",es[i].s,es[i].t,es[i].w);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<b;++i)\n#define fj(a,b) for(int j=a;j<b;++j)\n#define pb push_back\n#define mp make_pair\ntypedef pair<int, int> pii;\n/////////////////////\n\nint const N = 41;\nint const INF = 1e9 + 41;\n\nint a, b;\nint d[N][N], w[N][N];\n\nstruct Edge{\n\tint x, y, c;\n\tbool f;\n\tEdge(){};\n\tEdge(int x, int y, int c, bool f) :\n\t\tx(x), y(y), c(c), f(f) {};\n};\n\nvector<Edge> e;\n\nvoid bad(){\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid pushedge(int x, int y, int c, bool f){\n\te.pb(Edge(x, y, c, f));\n}\n\nvoid solve(){\n\tfi(1, 101){\n\t\tpushedge(i, i+1, 'X', false);\n\t}\n\tfi(102, 201){\n\t\tpushedge(i, i+1, 'Y', false);\n\t}\n\tfi(0, 101) fj(0, 101){\n\t\tint v = 0;\n\t\tint y = -1, x = -1;\n\t\tfor(int i1=0;i1<a;++i1) for(int j1=0;j1<b;++j1){\n\t\t\tint c = d[i1][j1] - (i1 + 1) * i - (j1 + 1) * j;\n\t\t\tif(v < c){\n\t\t\t\tv = c;\n\t\t\t\ty = i1;\n\t\t\t\tx = j1;\n\t\t\t}\n\t\t}\n\t\tint v0 = INF;\n\t\tfor(int i1=0;i1<a;++i1) for(int j1=0;j1<b;++j1){\n\t\t\tif(w[i1][j1]) continue;\n\t\t\tint c = (i1 + 1) * i + (j1 + 1) * j + v;\n\t\t\tint v1 = d[i1][j1] - (i1 + 1) * i - (j1 + 1) * j;\n\t\t\tif(c <= d[i1][j1]){\n\t\t\t\tif(v0 > v1){\n\t\t\t\t\tv0 = v1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v0 < INF){\n\t\t\tpushedge(1+i, 201-j, v0, true);\n\t\t\tfor(int i1=0;i1<a;++i1) for(int j1=0;j1<b;++j1){\n\t\t\t\tif(w[i1][j1]) continue;\n\t\t\t\tint c = (i1 + 1) * i + (j1 + 1) * j + v;\n\t\t\t\tint v1 = d[i1][j1] - (i1 + 1) * i - (j1 + 1) * j;\n\t\t\t\tif(c <= d[i1][j1]){\n\t\t\t\t\tif(v0 == v1){\n\t\t\t\t\t\tw[i1][j1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << 1+i << \" \" << 201-j << \" \" << y1 << \" \" << x1 << \" \" << v0 << endl;\n\t\t}\n\t}\n\tfi(0, a) fj(0, b) if(!w[i][j]) bad();\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%d %d\",&a,&b);\n\tfi(0, a) fj(0, b) scanf(\"%d\",&d[i][j]);\n\n\tsolve();\n\n\tprintf(\"Possible\\n\");\n\tprintf(\"201 %d\\n\",sz(e));\n\tfi(0, sz(e)){\n\t\tif(e[i].f) printf(\"%d %d %d\\n\",e[i].x,e[i].y,e[i].c);\n\t\telse printf(\"%d %d %c\\n\",e[i].x,e[i].y,(char)e[i].c);\n\t}\n\tprintf(\"1 201\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int INF = numeric_limits<int>::max();\n\nconstexpr int MAX_N = 105;\n\nint A, B, D[10][10];\n\nint F[MAX_N][MAX_N];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 0; j < A; ++j) {\n        for (int k = 0; k < B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    for (int j = 0; j < MAX_N; ++j) for (int k = 0; k < MAX_N; ++k) {\n        for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n            F[j][k] = max(F[j][k], D[j][k] - (a+1) * j - (b+1) * k);\n        }\n    }\n\n    for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n        int min_dist = INF;\n        for (int j = 0; j < MAX_N; ++j) {\n            for (int k = 0; k < MAX_N; ++k) {\n                min_dist = min(min_dist, (a+1) * j + (b+1) * k + F[j][k]);\n            }\n        }\n        if (min_dist != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", 2*MAX_N, 2*(MAX_N-1) + MAX_N*MAX_N);\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d X\\n\", (j+1), (j+2));\n    }\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d Y\\n\", MAX_N+(j+1), MAX_N+(j+2));\n    }\n    for (int j = 0; j < MAX_N; ++j) {\n        for (int k = 0; k < MAX_N; ++k) {\n            printf(\"%d %d %d\\n\", (j+1), MAX_N+(k+1), F[j][k]);\n        }\n    }\n    printf(\"%d %d\\n\", 1, 2*MAX_N);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=1e2+10;\nint d[maxn][maxn],f[maxn][maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\nint main(){\n\tint i,j,k,l,m,n;\n\tint a,b;\n\ta=read();b=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\td[i][j]=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tf[k][l]=max(f[k][l],d[i][j]-i*k-j*l);\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++){\n\t\t\tint dis=INF;\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tdis=min(dis,f[k][l]+i*k+j*l);\n\t\t\tif(dis!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tn=202,m=101*101+200;\n\tprintf(\"%d %d\\n\",n,m);\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;i++)\n\t\tfor(j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC089E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 330;\n\nint n, A, B, d[MAX_N][MAX_N], f[MAX_N][MAX_N];\n\nint main()\n{\n    scanf(\"%d%d\", &A, &B);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n            scanf(\"%d\", &d[i][j]);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            for (int p = 1; p <= A; p++)\n                for (int q = 1; q <= B; q++)\n                    f[i][j] = max(0, d[p][q] - i * p - j * q);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n        {\n            int dist = 1e9;\n            for (int p = 0; p <= 100; p++)\n                for (int q = 0; q <= 100; q++)\n                    dist = min(dist, f[p][q] + i * p + j * q);\n            if (dist != d[i][j])\n                puts(\"Impossible\"), exit(0);\n        }\n    puts(\"Possible\"), puts(\"202 10401\");\n    for (int i = 1; i <= 100; i++)\n        printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i < 202; i++)\n        printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\n#define int ll\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nsigned main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll f = 100;\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < f; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < f; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= f; i++) {\n\t\tfor (int j = 0; j <= f; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= f; x++) {\n\t\tfor (int y = 1; y <= f; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n        if(p==1&&q==0) {db(x); db(y); dbg(D[x][y] - p * (x+1) - q * (y+1));}\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << 101*2 sp << 100*2+101*101 ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nvoid ng(){\n\tcout << \"Impossible\" << endl;\n\texit(0);\n}\n\n#define INF (1<<29)\n\nint a, b;\nint d[108][108];\nint c[108][108];\n\nint main(){\n\tcin >> a >> b;\n\tfor(int i = 1;i <= a;i++){\n\t\tfor(int j = 1;j <= b;j++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0;i <= 100;i++){\n\t\tfor(int j = 0;j <= 100;j++){\n\t\t\tfor(int x = 1;x <= a;x++){\n\t\t\t\tfor(int y = 1;y <= b;y++){\n\t\t\t\t\tc[i][j] = max(c[i][j], d[x][y] - x*i - y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 1;x <= a;x++){\n\t\tfor(int y = 1;y <= b;y++){\n\t\t\tint dist = INF;\n\t\t\tfor(int i = 0;i <= 100;i++){\n\t\t\t\tfor(int j = 0;j <= 100;j++){\n\t\t\t\t\tdist = min(dist, c[i][j] + x*i+y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist != d[x][y])ng();\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << 101*101 + 200 << endl;\n\tfor(int i = 0;i <= 100;i++){\n\t\tint u = i+1;\n\t\tfor(int j = 0;j <= 100;j++){\n\t\t\tint v = j + 102;\n\t\t\tcout << u << \" \" << v << \" \" << c[i][j] << endl;\n\t\t}\n\t}\n\tfor(int i = 0;i < 100;i++){\n\t\tint u = i + 1;\n\t\tint v = u + 1;\n\t\tcout << u << \" \" << v << \" \" << \"X\" << endl;\n\t}\n\t\n\tfor(int i = 0;i < 100;i++){\n\t\tint v = i + 102;\n\t\tint u = v + 1;\n\t\tcout << u << \" \" << v << \" \" << \"Y\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n\n// This solution is written after the author read the editorial.\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int a, b;\n  cin >> a >> b;\n  vector<VI> d(a, VI(b));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      cin >> d[i][j];\n    }\n  }\n  vector<VI> f(101, VI(101, 0));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      REP(v, 0, 101) {\n\tREP(w, 0, 101) {\n\t  f[v][w] = max(f[v][w], d[i][j] - (i + 1) * v - (j + 1) * w);\n\t}\n      }\n    }\n  }\n  vector<VI> nd(a, VI(b, 1e8));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      REP(v, 0, 101) {\n\tREP(w, 0, 101) {\n\t  nd[i][j] = min(nd[i][j], f[v][w] + (i + 1) * v + (j + 1) * w);\n\t}\n      }\n    }\n  }\n  bool ok = true;\n  if (nd != d) {\n    ok = false;\n  }\n  if (ok) {\n    REP(i, 0, 101) {\n      REP(j, 0, 101) {\n\tif (f[i][j] < 0 || f[i][j] > 100) {\n\t  ok = false;\n\t}\n      }\n    }\n  }\n  if (ok) {\n    cout << \"Possible\\n\";\n    int n = 202;\n    int m = 101 * 101 + 2 * 100;\n    cout << n << \" \" << m << \"\\n\";\n    REP(i, 0, 100) {\n      cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    }\n    REP(i, 0, 100) {\n      cout << i + 103 << \" \" << i + 102 << \" Y\\n\";\n    }\n    REP(i, 0, 101) {\n      REP(j, 0, 101) {\n\tcout << i + 1 << \" \" << j + 102 << \" \" << f[i][j] << \"\\n\";\n      }\n    }\n    cout << 1 << \" \" << 102 << \"\\n\";\n  } else {\n    cout << \"Impossible\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++){\n\t\t\tassert(b[k][l]+k*i+l*j>=a[i][j]);\n\t\t\tif(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\t}\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tassert(0);\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <vector>\n#include <iterator>\n#include <utility>\n#include <functional>\n#include <cstdio>\n#include <map>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(A))\n        RDV(d[i], d[i] + B);\n\n    vector<pair<int, int>> adj[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(A))\n        for(int j: RG(B))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    bool check = true;\n                    for(int ii = 0; ii <= A && check; ii++)\n                        for(int jj: RG(B))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor (int i = 0; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, i + 103, i + 102);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, j + 102, d[i][j]);\n\tputs(\"1 102\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<sys/time.h>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int ri()\n{\n\tregister int x=0;register bool f=0;register char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();};\n\treturn f?-x:x;\n}\nvoid wi(int x)\n{\n\tif(x<0)\tx=-x,putchar('-');\n\tif(x>9)\twi(x/10);\n\tputchar('0'+x%10);\n}\nconst int N=105;\nint c[N][N],d[15][15];\nbool judge(int a,int b)\n{\n    int i,j,k,l;\n    for(i=1;i<=a;i++)\n        for(j=1;j<=b;j++)\n\t{\n            int dist=1e9;\n            for(k=0;k<=100;k++)\n                for(l=0;l<=100;l++)\n                    dist=min(dist,i*k+j*l+c[k][l]);\n            if(dist!=d[i][j]) return 0;\n        }\n    return 1;\n}\nint main()\n{\n    int a,b,i,j,k,l;\n    a=ri(),b=ri();\n    for(i=1;i<=a;i++)\n        for(j=1;j<=b;j++)\n            d[i][j]=ri();\n    for(i=1;i<=a;i++) \n        for(j=1;j<=b;j++) \n            for(k=0;k<=100;k++) \n                for(l=0;l<=100;l++)\n                    c[k][l]=max(c[k][l],d[i][j]-i*k-j*l);\n    if(judge(a,b))\n    {\n        puts(\"Possible\");\n\tprintf(\"%d %d\\n\",200,101*101+200);\n        for(i=1;i<=100;i++)\n\t    printf(\"%d %d X\\n\",i,i+1);\n        for(i=102;i<202;i++)\n\t    printf(\"%d %d Y\\n\",i+1,i);\n        for(i=0;i<=100;i++)\n            for(j=0;j<=100;j++)\n\t\tprintf(\"%d %d %d\\n\",i+1,j+102,c[i][j]);\n\tprintf(\"%d %d\\n\",1,102);\n    }\n    else\tputs(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct edge{\n  int f,t,w;\n};\n\nll A,B;\nll f[101][101];\nll dist[202][202];\nll d[10][10];\nvector<edge> es;\n\nint main(){\n  cin>>A>>B;\n  rep(i,A)rep(j,B)cin>>d[i][j];\n\n  rep(i,101)rep(j,101){\n    rep(a,A)rep(b,B){\n      maxch(f[i][j],d[a][b]-i*(a+1)-j*(b+1));\n    }\n  }\n\n  int S=0,T=201;\n  rep(a,A)rep(b,B){\n    rep(i,202)rep(j,202)dist[i][j]=(i==j?0:INF);\n    rep(i,100)dist[i][i+1]=a+1;\n    repl(i,101,201)dist[i][i+1]=b+1;\n    rep(i,101)repl(j,101,202)dist[i][j]=f[i][201-j];\n    rep(k,202)rep(i,202)rep(j,202)minch(dist[i][j],dist[i][k]+dist[k][j]);\n    if(dist[S][T]!=d[a][b]){\n      cout<<\"Impossible\"<<endl;\n      return 0;\n    }\n  }\n  cout<<\"Possible\"<<endl;\n  rep(i,100)es.push_back((edge){i,i+1,-1});\n  repl(i,101,201)es.push_back((edge){i,i+1,-2});\n  rep(i,101)repl(j,101,202)es.push_back((edge){i,j,f[i][201-j]});\n  cout<<202<<\" \"<<es.size()<<endl;\n  rep(i,es.size()){\n    cout<<es[i].f+1<<\" \"<<es[i].t+1<<\" \";\n    if(es[i].w==-1)cout<<\"X\";\n    else if(es[i].w==-2)cout<<\"Y\";\n    else cout<<es[i].w;\n    cout<<endl;\n  }\n  cout<<S+1<<\" \"<<T+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  const int sizeG = 100;\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(sizeG + 1, vector<int>(sizeG + 1, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        for (int k = 0; k <= sizeG; ++k) {\n          for (int l = 0; l <= sizeG; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[i][j] - i * k - j * l);\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= sizeG; ++k) {\n          for (int l = 0; l <= sizeG; ++l) {\n            minDistance = min(minDistance, i * k + j * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[i][j]) impossible();\n      }\n    }\n    cout << \"Possible\" << endl;\n    cout << sizeG * 2 + 2 << ' ' << (sizeG + 1) * (sizeG + 1) + 2 * sizeG << endl;\n    for (int k = 0; k <= sizeG; ++k) {\n      for (int l = 0; l <= sizeG; ++l) {\n        cout << k + 1 << ' ' << sizeG * 2 + 2 - l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < sizeG; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + sizeG + 2 << ' ' << i + sizeG + 3 << \" Y\" << endl;\n    }\n\n    cout << 1 << ' ' << sizeG * 2 + 2 << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=1e2+10;\nint d[maxn][maxn],f[maxn][maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\nint main(){\n\tint i,j,k,l,m,n;\n\tint a,b;\n\ta=read();b=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\td[i][j]=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tf[k][l]=max(f[k][l],d[i][j]-i*k-j*l);\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++){\n\t\t\tint dis=INF;\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tdis=min(dis,f[k][l]+i*k+j*l);\n\t\t\tif(dis!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tn=202,m=101*101+200;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,m);\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;i++)\n\t\tfor(j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N 123\n\nint a[11][11];\nint d[N + 1][N + 1];\n\nint main() {\n\tint i, j, k, l, m, n, t;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) scanf(\"%d\", &a[i][j]);\n\tfor (i = 0; i <= N; i++) for (j = 0; j <= N; j++) {\n\t\tt = 0;\n\t\tfor (k = 1; k <= n; k++) for (l = 1; l <= m; l++) {\n\t\t\tif (a[k][l] - i * k - j * l >= t) {\n\t\t\t\tt = a[k][l] - i * k - j * l;\n\t\t\t}\n\t\t}\n\t\td[i][j] = t;\n\t}\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) {\n\t\tt = 999;\n\t\tfor (k = 0; k <= N; k++) for (l = 0; l <= N; l++) {\n\t\t\tif (d[k][l] + i * k + j * l <= t) {\n\t\t\t\tt = d[k][l] + i * k + j * l;\n\t\t\t}\n\t\t}\n\t\tif (t != a[i][j]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", (N + 1) * 2, N * 2 + (N + 1) * (N + 1));\n\tfor (i = 0; i < N; i++) {\n\t\tprintf(\"%d %d X\\n\", i + 1, i + 2);\n\t\tprintf(\"%d %d Y\\n\", N + N + 1 - i, N + N + 2 - i);\n\t}\n\tfor (i = 0; i <= N; i++) for (j = 0; j <= N; j++) printf(\"%d %d %d\\n\", i + 1, N + N + 2 - j, d[i][j]);\n\tprintf(\"1 %d\\n\", N + N + 2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\nconstexpr int D_MAX = 100;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x_max;\n  int y_max;\n  cin >> x_max >> y_max;\n\n  auto d_matrix = Make2DVector(x_max + 1, y_max + 1, 0);\n  for (int x = 1; x <= x_max; x++) {\n    for (int y = 1; y <= y_max; y++) {\n      cin >> d_matrix[x][y];\n    }\n  }\n\n  auto c_matrix = Make2DVector(D_MAX + 1, D_MAX + 1, 0);\n  for (int a = 0; a <= D_MAX; a++) {\n    for (int b = 0; b <= D_MAX; b++) {\n      for (int x = 1; x <= x_max; x++) {\n        for (int y = 1; y <= y_max; y++) {\n          UpdateMax(c_matrix[a][b], d_matrix[x][y] - a * x - b * y);\n        }\n      }\n    }\n  }\n\n  auto check_fn = [&]() -> bool {\n    for (int x = 1; x <= x_max; x++) {\n      for (int y = 1; y <= y_max; y++) {\n        int d = INT32_MAX;\n        for (int a = 0; a <= D_MAX; a++) {\n          for (int b = 0; b <= D_MAX; b++) {\n            UpdateMin(d, a * x + b * y + c_matrix[a][b]);\n          }\n        }\n        // cout << d << endl;\n        if (d > d_matrix[x][y]) return false;\n      }\n    }\n    return true;\n  };\n\n  if (!check_fn()) {\n    cout << \"Impossible\" << endl;\n    return;\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 2 * D_MAX + 2 << \" \" << D_MAX + D_MAX + (D_MAX + 1) * (D_MAX + 1) << endl;\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << 1 + i << \" \" << 1 + i + 1 << \" \" << \"X\" << endl;\n  }\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << D_MAX + 1 + 1 + i << \" \" << D_MAX + 1 + 1 + i + 1 << \" \" << \"Y\" << endl;\n  }\n  for (int a = 0; a <= D_MAX; a++) {\n    for(int b = 0; b <= D_MAX; b++) {\n      cout << 1 + a << \" \" << 2 * D_MAX + 2 - b << \" \" << c_matrix[a][b] << endl;\n    }\n  }\n  cout << 1 << \" \" << 2 * D_MAX + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<pair<int, int>, int> > ans;\nmap<pair<int, int>, int> res;\nint d[15][15];\nint a, b;\n\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++) scanf(\"%d\", d[i]+j);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++)\n\t{\n\t\tbool done = false;\n\t\tint nA = 0, nB = 0, c = 0;\n\t\tfor (;nA*i <= d[i][j];nA++)\n\t\t{\n\t\t\tfor (nB=0;nA*i+nB*j <= d[i][j];nB++)\n\t\t\t{\n\t\t\t\tc = d[i][j]-nA*i-nB*j;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int x = 1;x <= a;x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1;y <= b;y++) if (nA*x+nB*y+c < d[x][y])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ok) break;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (done) break;\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tres[make_pair(nA, nB)] = c;\n\t}\n\tfor (int i = 1;i <= a;i++) ans.emplace_back(make_pair(i-1, i), -1);\n\tfor (int i = 0;i <= a;i++) for (int j = 1;j <= b;j++) ans.emplace_back(make_pair((j-1)*(a+1)+i, j*(a+1)+i), -2);\n\tfor (auto u: res) ans.emplace_back(make_pair(u.first.second*(a+1)+u.first.first, 299), u.second);\n\tprintf(\"Possible\\n300 %ld\\n\", ans.size());\n\tfor (auto u: ans)\n\t{\n\t\tprintf(\"%d %d \", u.first.first+1, u.first.second+1);\n\t\tif (u.second >= 0) printf(\"%d\\n\", u.second);\n\t\telse if (u.second == -1) printf(\"X\\n\");\n\t\telse printf(\"Y\\n\");\n\t}\n\tprintf(\"1 300\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(int)(n); ++i)\n#define maxn 100005\nstruct edge{\n    int x, y, c;\n    edge(int _x, int _y, int _c):x(_x), y(_y), c(_c){}\n};\nint d[10][10], b[10][10];\nint a[100][100];\nint hit_i[100][100][10];\nint hit_j[100][100][10];\nint hit[100][100];\nbool need[100][100];\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> d[i][j];\n    }\n    rep(s,100)rep(t,100){\n        rep(i,n)rep(j,m){\n            a[s][t] = max(d[i][j] - (i + 1) * s - (j + 1) * t, a[s][t]);\n        }\n    }\n    // rep(s, 100){\n    //     rep(t, 100) cout << a[s][t] << ' ';\n    //     cout << endl;\n    // }\n    rep(i,n)rep(j,m){\n        b[i][j] = 1000000;\n        rep(s,100)rep(t,100){\n            b[i][j] = min(b[i][j], (i + 1) * s + (j + 1) * t + a[s][t]);\n            if((i + 1) * s + (j + 1) * t + a[s][t] == d[i][j]){\n                hit_i[s][t][i]  = 1;\n                hit_j[s][t][j]  = 1;\n                hit[s][t] += 1;\n            }\n        }\n        if(b[i][j] > d[i][j]){\n            cout << \"Impossible\" << endl;\n            return;\n        }\n    }\n\n\n    if (n == 1 && m == 1){\n        need[0][0] = 1;\n    }\n\n    if (n == 1 && m > 1){\n        rep(s, 100)rep(t, 100){\n            if (hit[s][t] < 2) continue;\n            if (s > 0) continue;\n            need[s][t] = 1;\n        }\n    }\n\n    if (n > 1 && m == 1){\n        rep(s, 100)rep(t, 100){\n            if (hit[s][t] < 2) continue;\n            if (t > 0) continue;\n            need[s][t] = 1;\n        }\n    }\n\n    if (n > 1 && m > 1){\n        rep(s, 100)rep(t, 100){\n            if (hit[s][t] < 3) continue;\n            int cnt = 0;\n            rep(i, n) cnt += hit_i[s][t][i];\n            if (cnt < 2) continue;\n            cnt = 0;\n            rep(j, m) cnt += hit_j[s][t][j];\n            if (cnt < 2) continue;\n            need[s][t] = 1;\n        }        \n    }\n\n    int S, T, node;\n    S = 1;\n    T = 2;\n    node = 3;\n    vector<edge> e; e.clear();\n    rep(s,100)rep(t,100) if(need[s][t]){\n        // s X + t Y + a[s][t]\n        vector<int> v;\n        v.clear();\n        rep(_, s) v.push_back(-2);\n        rep(_, t) v.push_back(-1);\n        rep(_, a[s][t] / 100) v.push_back(100);\n        if(a[s][t] % 100 > 0) v.push_back(a[s][t] % 100);\n        int last = S;\n        rep(i, v.size()){\n            if (i == v.size() - 1) e.push_back(edge(last, T, v[i]));\n            else{\n                e.push_back(edge(last, node, v[i]));\n                last = node;\n                node ++;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << node - 1 << ' ' << e.size() << endl;\n    for(auto p: e){\n        cout << p.x << ' ' << p.y << ' ';\n        if(p.c == -2) cout << 'X'; else\n        if(p.c == -1) cout << 'Y'; else\n        cout << p.c;\n        cout << endl;\n    }\n    cout << \"1 2\" <<endl;\n}\n\nint main(int argc, char const *argv[]) {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=105;\ninline int read()\n{\n\tint s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint n,m;\nint d[15][15],f[N][N];\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\td[i][j]=read();\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-y*j);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int y=1;y<=m;y++)\n\t\t{\n\t\t\tint now=100000;\n\t\t\tfor(int i=0;i<=100;i++)\n\t\t\t\tfor(int j=0;j<=100;j++)\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+y*j);\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i=1;i<101;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 10;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    REP(i,N-1) cout << 300-i << \" \" << 299-i << \" Y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int INF = 1 << 29;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nvector< T > dijkstra(WeightedGraph< T > &g, int s) {\n  const auto INF = numeric_limits< T >::max();\n  vector< T > dist(g.size(), INF);\n\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  dist[s] = 0;\n  que.emplace(dist[s], s);\n  while(!que.empty()) {\n    T cost;\n    int idx;\n    tie(cost, idx) = que.top();\n    que.pop();\n    if(dist[idx] < cost) continue;\n    for(auto &e : g[idx]) {\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}\n\n\nint main() {\n  int A, B, D[10][10];\n  cin >> A >> B;\n  for(int i = 0; i < A; i++) {\n    for(int j = 0; j < B; j++) {\n      cin >> D[i][j];\n    }\n  }\n\n  int F[101][101] = {{}};\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      for(int c = 0; c < A; c++) {\n        for(int d = 0; d < B; d++) {\n          F[a][b] = max(0, D[c][d] - a * (c + 1) - b * (d + 1));\n        }\n      }\n    }\n  }\n\n  for(int c = 1; c <= A; c++) {\n    for(int d = 1; d <= B; d++) {\n      WeightedGraph< int > g(202);\n      for(int a = 0; a <= 99; a++) {\n        g[a].emplace_back(a + 1, c);\n        g[a + 102].emplace_back(a + 101, d);\n      }\n      for(int a = 0; a <= 100; a++) {\n        for(int b = 0; b <= 100; b++) {\n          g[a].emplace_back(b + 101, F[a][b]);\n        }\n      }\n      if(dijkstra(g, 0)[101] != D[c - 1][d - 1]) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n\n\n  Edges< int > edges;\n  for(int a = 0; a <= 99; a++) {\n    edges.emplace_back(a, a + 1, -1);\n    edges.emplace_back(a + 102, a + 101, -2);\n  }\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      edges.emplace_back(a, b + 101, F[a][b]);\n    }\n  }\n  cout << 202 << \" \" << edges.size() << endl;\n  for(auto &e : edges) {\n    cout << e.src + 1 << \" \" << e.to + 1 << \" \";\n    if(e.cost == -1) cout << \"X\" << endl;\n    else if(e.cost == -2) cout << \"Y\" << endl;\n    else cout << e.cost << endl;\n  }\n  cout << 1 << \" \" << 102 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tmemset(f, -1, sizeof f);\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tf[i][j] = std::max(f[i][j], 0);\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i ? i : 201, j ? j : 202, d[i][j]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "                                    #include <bits/stdc++.h>\n                                    #include<iostream>\n                                    #include<cstdio>\n                                    #include<vector>\n                                    #include<queue>\n                                    #include<map>\n                                    #include<cstring>\n                                    #include<string>\n                                    #include <math.h>\n                                    #include<algorithm>\n                                //    #include <boost/multiprecision/cpp_int.hpp>\n                                    #include<functional>\n                          #define int long long\n                                    #define inf  1000000007\n                                    #define pa pair<int,int>\n                                    #define ll long long\n                                    #define pal pair<double,pa>\n                                    #define ppa pair<pa,int>\n                                    #define ppap pair<int,pa>\n                                    #define ssa pair<string,int>\n                                    #define  mp make_pair\n                                    #define  pb push_back\n                                    #define EPS (1e-10)\n                                    #define equals(a,b) (fabs((a)-(b))<EPS)\n                             \n                                    using namespace std;\n                          \n                                    class Point{\n                                    \tpublic:\n                                    \tdouble x,y;\n                                    \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                    \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                    \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                    \tdouble absv() {return sqrt(norm());}\n                                    \tdouble norm() {return x*x+y*y;}\n                                    \tbool operator < (const Point &p) const{\n                                    \t\treturn x != p.x ? x<p.x: y<p.y;\n                                    \t}\n                                    \tbool operator == (const Point &p) const{\n                                    \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    \t}\n                                    };\n                                    typedef Point Vector;\n                             \n                                    struct Segment{\n                                    Point p1,p2;\n                                    };\n                                     double dot(Vector a,Vector b){\n                                    \treturn a.x*b.x+a.y*b.y;\n                                    }\n                                    double cross(Vector a,Vector b){\n                                    \treturn a.x*b.y-a.y*b.x;\n                                    }\n                                \n        bool parareru(Point a,Point b,Point c,Point d){\n        //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        \treturn abs(cross(a-b,d-c))<EPS;\n        }\n        double distance_ls_p(Point a, Point b, Point c) {\n          if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n          if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n          return abs(cross(b-a, c-a)) / (b-a).absv();\n        }\n        bool is_intersected_ls(Segment a,Segment b) {\n        \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n        //\t\tcout<<\"sss\"<<endl;\n        \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n        \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n        \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n        \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n        \t\treturn false;\n        \t}\n          else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n        }\n         \n        double segment_dis(Segment a,Segment b){\n        \tif(is_intersected_ls(a,b))return 0;\n        \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n        \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        \treturn r;\n        }\n        Point intersection_ls(Segment a, Segment b) {\n          Point ba = b.p2-b.p1;\n          double d1 = abs(cross(ba, a.p1-b.p1));\n          double d2 = abs(cross(ba, a.p2-b.p1));\n          double t = d1 / (d1 + d2);\n         \n          return a.p1 + (a.p2-a.p1) * t;\n        }\n         \n                        string itos( int i ) {\n                        ostringstream s ;\n                        s << i ;\n                        return s.str() ;\n                        }\n                         \n                        int gcd(int v,int b){\n                        \tif(v>b) return gcd(b,v);\n                        \tif(v==b) return b;\n                        \tif(b%v==0) return v;\n                        \treturn gcd(v,b%v);\n                        }\n         \n                        double distans(double x1,double y1,double x2,double y2){\n                        \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        \treturn sqrt(rr);\n                        \t\n                        }\n                        /*\n        int pr[100010];\n        //int inv[100010];\n        */ \n        int beki(int wa,int rr,int warukazu){\n        \tif(rr==0) return 1ll;\n        \tif(rr==1) return wa%warukazu;\n        \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        \tint zx=beki(wa,rr/2,warukazu);\n        \treturn (zx*zx)%warukazu;\n        }\n          /*\n        void gya(){\n        \tpr[0]=1;\n        \tfor(int i=1;i<100010;i++){\n        \t\tpr[i]=(pr[i-1]*i)%inf;\n        \t}\n        \tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n        \t\n        }\n         \n        */\n         //sort(ve.begin(),ve.end(),greater<int>());\n                                 //----------------kokomade tenpure------------\n        //vector<double> ans(100000000),ans2(100000000);\n        /*\n        int par[200100],ranks[200100],kosuu[200100];     \n         \n        void shoki(int n){\n        \tfor(int i=0;i<n;i++){\n        \t\tpar[i]=i;\n        \t\tranks[i]=0;\n        \t\tkosuu[i]=1;\n        \t}\n        }\n         \n        int root(int x){\n        \treturn par[x]==x ? x : par[x]=root(par[x]);\n        }\n         \n        bool same(int x,int y){\n        return root(x)==root(y);\n        }\n         \n        void unite(int x,int y){\n         x=root(x);\n         y=root(y);\n        \tint xx=kosuu[x],yy=kosuu[y];\n         if(x==y) return;\n        \tif(ranks[x]<ranks[y]){\n        \t\tpar[x]=y;\n        \t\tkosuu[y]=yy+xx;\n        \t}\n         else {\n        \tpar[y]=x;\n        \tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n         \tkosuu[x]=yy+xx;\n         }\n        \treturn;\n        }\n*/\nint a,b;\nint d[11][11];\n        signed main(){\n\n        \tcin>>a>>b;\n        \t\n        \tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++)cin>>d[i][j];\n        \t\n        \tfor(int i=2;i<=a;i++)for(int j=2;j<=b;j++){\n        \t\t\n        \t\tif(d[i][j]<d[i-1][j] || d[i][j]<d[i][j-1]){\n        \t\t\n        \t\tcout<<\"Impossible\"<<endl;\n        \t\t\treturn 0;\n        \t\t}\n        \t}\n        \texit(1);\n        \treturn 0;\n        }\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nint n, m, d[N][N], f[N][N];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t{\n\t\t\tint dist = INT_MAX;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist = min(dist, f[i][j] + i * x + j * y);\n\t\t\tif(d[x][y] != dist) return (cout << \"Impossible\" << endl) && 0; \n\t\t}\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\tfor(int i = 1; i < 101; i++) cout << i << ' ' << i + 1 << 'X' << endl;\n\tfor(int i = 102; i < 202; i++) cout << i << ' ' << i + 1 << 'Y' << endl;\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tcout << i + 1 << ' ' << 202 - j << ' ' << f[i][j] << endl;\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nconst int inf = 1e9;\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint A, B;\nint d[15][15];\nint f[105][105];\nvector<edge> G[305];\nint dist[305];\nint S, T;\n\nvoid dijkstra(int x, int y)\n{\n\tfor(int i = 1; i <= T; i++) dist[i] = inf;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tdist[S] = 0;\n\tQ.push(make_pair(0, S));\n\t\n\tint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint c = G[v][i].cost;\n\t\t\tif(G[v][i].cost == -1) c = x;\n\t\t\tif(G[v][i].cost == -2) c = y;\n\t\t\tif(dist[G[v][i].to] > d + c){\n\t\t\t\tdist[G[v][i].to] = d + c;\n\t\t\t\tQ.push(make_pair(dist[G[v][i].to], G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> A >> B;\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tcin >> d[x][y];\n\t\t}\n\t}\n\t\n\tfor(int a = 0; a <= 100; a++){\n\t\tfor(int b = 0; b <= 100; b++){\n\t\t\tint val = 0;\n\t\t\tfor(int x = 1; x <= A; x++){\n\t\t\t\tfor(int y = 1; y <= B; y++){\n\t\t\t\t\tval = max(val, d[x][y] - a*x - b*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[a][b] = val;\n\t\t}\n\t}\n\t\n\t/*for(int a = 0; a <= 2; a++){\n\t\tfor(int b = 0; b <= 2; b++){\n\t\t\tcout << f[a][b] << \" \";\n\t\t}\n\t\tcout << endl; \n\t}*/\n\t\n\tS = 201, T = 202;\n\tG[S].push_back(edge(1, -1)), G[101].push_back(edge(T, -2));\n\tfor(int i = 1; i < 100; i++) G[i].push_back(edge(i+1, -1));\n\tfor(int i = 200; i > 101; i--) G[i].push_back(edge(i-1, -2));\n\tfor(int a = 0; a <= 100; a++){\n\t\tfor(int b = 0; b <= 100; b++){\n\t\t\tint s = a, t = b+100;\n\t\t\tif(s == 0) s = S;\n\t\t\tif(t == 100) t = T;\n\t\t\tG[s].push_back(edge(t, f[a][b]));\n\t\t}\n\t}\n\t\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tdijkstra(x, y);\n\t\t\tif(dist[T] != d[x][y]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << 200+101*101 << endl;\n\tfor(int i = 1; i <= T; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tcout << i << \" \" << G[i][j].to << \" \";\n\t\t\tif(G[i][j].cost == -1) cout << \"X\" << endl;\n\t\t\telse if(G[i][j].cost == -2) cout << \"Y\" << endl;\n\t\t\telse cout << G[i][j].cost << endl;\n\t\t}\n\t}\n\tcout << S << \" \" << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint A,B;\nint d[15][15];\nint f[105][105],tot,gx[105],gy[105],S,T;\npii p[305 * 305];\nint val[305 * 305],cnt;\nint check(int x,int y) {\n    int res = 1000000;\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    res = min(res,f[i][j] + i * x + j * y);\n\t}\n    }\n    return res;\n}\nvoid Solve() {\n    read(A);read(B);\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    read(d[i][j]);\n\t}\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    for(int k = 1 ; k <= A ; ++k) {\n\t\tfor(int h = 1 ; h <= B ; ++h) {\n\t\t    f[i][j] = max(f[i][j],d[k][h] - k * i - h * j);\n\t\t}\n\t    }\n\t} \n    }\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    if(check(i,j) != d[i][j]) {\n\t\tputs(\"Impossible\");\n\t\treturn;\n\t    }\n\t}\n    }\n    puts(\"Possible\");\n    S = ++tot;\n    gx[0] = S;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgx[i] = ++tot;\n\tp[++cnt] = mp(gx[i - 1],gx[i]);\n\tval[cnt] = -2;\n    }\n    T = ++tot;\n    gy[0] = T;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgy[i] = ++tot;\n\tp[++cnt] = mp(gy[i],gy[i - 1]);\n\tval[cnt] = -1;\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    p[++cnt] = mp(gx[i],gy[j]);\n\t    val[cnt] = f[i][j];\n\t}\n    }\n    out(tot);space;out(cnt);enter;\n    for(int i = 1 ; i <= cnt ; ++i) {\n\tout(p[i].fi);space;out(p[i].se);space;\n\tif(val[i] < 0) {\n\t    if(val[i] == -1) {puts(\"X\");}\n\t    else puts(\"Y\");\n\t}\n\telse {out(val[i]);enter;}\n    }\n    out(S);space;out(T);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=71;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*k);\n\tchmax(D[k],d[i][j]-(j+1)*k);\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(E[k],d[i][j]-(N-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(N-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[idx(k)].emplace_back(t,C[k]);\n    G[idy(k)].emplace_back(t,D[k]);\n    G[z].emplace_back(idx(k),E[k]);\n    G[z].emplace_back(idy(k),F[k]);\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      //cout<<dist<<\" \"<<d[i][j]<<endl;\n      flg&=(dist==d[i][j]);\n      assert(dist>=d[i][j]);\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <queue>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 17;\nconst int Maxm = 305;\nconst int Inf = 1000000000;\n\nint A, B;\nint D[Maxn][Maxn];\nint mn[Maxn][Maxn];\nint N;\nvector <ii> neigh[Maxm];\nint dist[Maxm];\n\nint getFirst(int r, int c)\n{\n\treturn r * Maxn + c + 1;\n}\n\nint Get(int v, int t, int X, int Y)\n{\n\t//printf(\"(%d, %d, %d, %d)\\n\", v, t, X, Y);\n\tfill(dist, dist + Maxm, Inf); dist[v] = 0;\n\tpriority_queue <ii> Q; Q.push(ii(-dist[v], v));\n\twhile (!Q.empty()) {\n\t\tint v = Q.top().second, d = -Q.top().first; Q.pop();\n\t\tif (dist[v] != d) continue;\n\t//\tprintf(\"v = %d, d = %d\\n\", v, d);\n\t\tif (t == v) return d;\n\t\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\t\tii u = neigh[v][i];\n\t\t\tif (u.second == -1) u.second = X;\n\t\t\tif (u.second == -2) u.second = Y;\n\t\t\t//printf(\"u = (%d, %d)  d = %d\\n\", u.first, u.second, dist[u.first]);\n\t\t\tif (d + u.second < dist[u.first]) {\n\t\t\t\tdist[u.first] = d + u.second;\n\t\t\t\tQ.push(ii(-dist[u.first], u.first));\n\t\t\t}\n\t\t}\n\t}\n\treturn Inf;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &A, &B);\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tscanf(\"%d\", &D[i][j]);\n\t\t\tfor (int koefi = 0; koefi < Maxn; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < Maxn; koefj++)\n\t\t\t\t\tmn[koefi][koefj] = max(mn[koefi][koefj], D[i][j] - koefi * (i + 1) - koefj * (j + 1));\n\t\t}\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (int koefi = 0; koefi < Maxn && !ok; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < Maxn && !ok; koefj++)\n\t\t\t\t\tok = koefi * (i + 1) + koefj * (j + 1) + mn[koefi][koefj] == D[i][j];\n\t\t\tif (!ok) { printf(\"Impossible\\n\"); return 0; }\n\t\t}\n\tN = Maxn * Maxn + 1;\n\tfor (int i = 0; i < Maxn; i++)\n\t\tfor (int j = 0; j < Maxn; j++) {\n\t\t\tneigh[getFirst(i, j)].push_back(ii(N, mn[i][j]));\n\t\t\tif (j + 1 < Maxn)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i, j + 1), -2));\n\t\t\tif (i + 1 < Maxn)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i + 1, j), -1));\n\t\t}\n\tint M = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tM += neigh[i].size();\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tint g = Get(getFirst(0, 0), N, i + 1, j + 1);\n\t\t\tif (D[i][j] != g) assert(false);\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", N, M);\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 0; j < neigh[i].size(); j++) {\n\t\t\tprintf(\"%d %d \", i, neigh[i][j].first);\n\t\t\tif (neigh[i][j].second == -1) printf(\"X\\n\");\n\t\t\telse if (neigh[i][j].second == -2) printf(\"Y\\n\");\n\t\t\telse printf(\"%d\\n\", neigh[i][j].second);\n\t\t}\n\tprintf(\"%d %d\\n\", getFirst(0, 0), N);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int inf=0x3f3f3f3f;\nint n,m,A,B,d[15][15],f[105][105];\nint main(){\n\tA=read(),B=read();\n\tREP(i,1,A)\n\t\tREP(j,1,B)\n\t\t\td[i][j]=read();\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tREP(x,1,A)\n\t\t\t\tREP(y,1,B)\n\t\t\t\t\tchkmax(f[i][j],d[x][y]-i*x-j*y);\n\tREP(x,1,A)\n\t\tREP(y,1,B){\n\t\t\tint dis=inf;\n\t\t\tREP(i,0,100)\n\t\t\t\tREP(j,0,100)\n\t\t\t\t\tchkmin(dis,f[i][j]+i*x+j*y);\n\t\t\tif(dis>d[x][y])return puts(\"Impossible\"),0;\n\t\t}\n\tn=202,m=10401;\n\tputs(\"Possible\");\n\twrite(n,' '),write(m,'\\n');\n\tREP(i,2,n/2)\n\t\tprintf(\"%d %d X\\n\",i-1,i);\n\tREP(i,n/2+2,n)\n\t\tprintf(\"%d %d Y\\n\",i-1,i);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",1+i,n-j,f[i][j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint d[20][20];\nint dd[20][20][2];\nint used[110][110];\nint adder[20][20];\n\nint main()\n{\n  int i,j,a,b,k,l,ss,tt,n,st1,st2,b1,b2,o,p,prev;\n  vector<pair<pair<int,int>,int> > ans;\n  scanf(\"%d%d\",&a,&b);\n  for (i=1;i<=a;i++)\n    for (j=1;j<=b;j++)\n    {\n      scanf(\"%d\",&d[i][j]);\n    }\n  memset(dd,-1,sizeof(dd));\n  \n  for (i=1;i<=a;i++)\n    for (j=1;j<=b;j++)\n    {\n      b1=0;\n      for (k=0;k<110;k++)\n      {\n        for (l=0;l<110;l++)\n        {\n          if (k*i+l*j>d[i][j]) continue;\n          b2=1;\n          adder[i][j]=d[i][j]-k*i-l*j;\n          for (o=1;o<=a;o++)\n            for (p=1;p<=b;p++)\n              if (adder[i][j]+o*k+p*l<d[o][p]) b2=0;\n          if (b2==0) continue;\n          b1=1;\n          dd[i][j][0]=k;\n          dd[i][j][1]=l;\n          break;\n        }\n        if (b1==1) break;\n      }\n      if (b1==0)\n      {\n        printf(\"Impossible\\n\");\n        return 0;\n      }\n    }\n  printf(\"Possible\\n\");\n  ans.clear();\n  ss=0;\n  st1=0;\n  n=1;\n  prev=0;\n  for (i=0;i<110;i++)\n  {\n    ans.push_back(make_pair(make_pair(prev,n),-1));\n    prev=n;\n    n++;\n  }\n  tt=n;\n  st2=n;\n  prev=n;\n  n++;\n  for (j=0;j<110;j++)\n  {\n    ans.push_back(make_pair(make_pair(n,prev),-2));\n    prev=n;\n    n++;\n  }\n  memset(used,0,sizeof(used));\n  //cout<<dd[1][1][0]<<\" \"<<dd[1][1][1]<<\" \"<<adder[1][1]<<endl;\n  for (i=1;i<=a;i++)\n    for (j=1;j<=b;j++)\n    {\n      if (used[dd[i][j][0]][dd[i][j][1]]==0)\n      {\n        used[dd[i][j][0]][dd[i][j][1]]=1;\n        ans.push_back(make_pair(make_pair(st1+dd[i][j][0],st2+dd[i][j][1]),adder[i][j]));\n      }\n    }\n  printf(\"%d %d\\n\",n,(int)ans.size());\n  for (i=0;i<ans.size();i++)\n  {\n    printf(\"%d %d \",ans[i].first.first+1,ans[i].first.second+1);\n    if (ans[i].second==-1) printf(\"X\\n\");\n    else if (ans[i].second==-2) printf(\"Y\\n\");\n    else printf(\"%d\\n\",ans[i].second);\n  }\n  printf(\"%d %d\\n\",ss+1,tt+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint d[10][10];\nint c[101][101];\n\nint main(){\n\tint a,b;\n\tcin >> a >> b;\n\n\tfor(int i=0; i<a; i++)\n\t\tfor(int j=0; j<b; j++)\n\t\t\tcin >> d[i][j];\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tint res = 0;\n\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tif(res < d[i-1][j-1] - kx*i - ky*j)\n\t\t\t\t\t\tres = d[i-1][j-1] - kx*i - ky*j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc[kx][ky] = res;\n\t\t}\n\t}\n\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++){\n\t\t\tint res = 100;\n\n\t\t\tfor(int kx=0; kx<=100; kx++)\n\t\t\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\t\t\tif(res > kx*i + ky*j + c[kx][ky])\n\t\t\t\t\t\tres = kx*i + ky*j + c[kx][ky];\n\t\t\t\t}\n\n\t\t\tif(res != d[i-1][j-1]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t}\n\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\n\tfor(int i=1;i<=100;i++){\n\t\tcout << i <<\"  \"<< i+1 <<\" X\"<<endl;\n\t\tcout << i+101 <<\" \"<< i+102 <<\" Y\"<<endl;\n\t}\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tcout << kx+1 <<\" \"<<202 - ky<<\" \"<< c[kx][ky] <<endl;\n\t\t}\n\t}\n\n\tcout << \"1 202\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Ralif Rakhmatullin\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cstring>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<valarray>\n#include<iterator>\n#include<list>\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define S second\n#define ld long double\n#define F first\n#define y1 LOL\n#define ld long double\n#define pb push_back\n#define len length\n#define sz size\n#define beg begin\nconst ll INF = (ll)1e18 + 123;\nconst int inf=(int)2e9 + 123; \nconst int mod=1e9+7;\nusing namespace std;\nint n, A, B, d[21][21], f[111][111];\nint main(){\n\tunsigned int FOR;\n \tasm(\"rdtsc\" : \"=A\"(FOR));\n  \tsrand(FOR);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout.tie(0);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i ++){\n\t\tfor(int j = 1; j <= B; j ++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tint n = 1;\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tfor(int a = 1; a <= A; a ++){\n\t\t\t\tfor(int b = 1; b <= B; b ++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[a][b] - a * i - b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int a = 1; a <= A; a ++){\n\t\tfor(int b = 1; b <= B; b ++){\n\t\t\tint res = inf;\n\t\t\tfor(int i = 0; i <= 100; i ++){\n\t\t\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\t\t\tres = min(res, f[i][j] + a * i + b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res != d[a][b]){\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tint s = 1, t = 202;\n\tcout << t << \" \" << 101 * 101 + 200 << endl;\n\tfor(int i = 2; i <= 101; i ++){\n\t\tcout << i - 1 << \" \" << i << \" X\\n\";\n\t}\n\tfor(int i = 102; i <= t; i ++){\n\t\tcout << i - 1 << \" \" << i << \" Y\\n\";\n\t}\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tcout << i + 1 << \" \" << t - j << \" \" << f[i][j] << endl;\n\t\t}\n\t}\n\tcout << s << \" \" << t;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint c[12][12],g[12][12];\nint u[1200000],v[1200000],w[1200000];\nint i,j,k,m,n,x,y,z;\nbool b;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&g[i][j]);\n\tfor (x=0;x<=100;x++)\n\t\tfor (y=0;y<=100;y++)\n\t\t\tfor (z=0;z<=100;z++)\n\t\t\t{\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z<g[i][j])\n\t\t\t\t\t\t\tb=true;\n\t\t\t\tif (b)\n\t\t\t\t\tcontinue;\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z==g[i][j])\n\t\t\t\t\t\t\tb=true,c[i][j]=1;\n\t\t\t\tif (! b)\n\t\t\t\t\tcontinue;\n\t\t\t\tk++,u[k]=x,v[k]=y,w[k]=z;\n\t\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tif (! c[i][j])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,k+200);\n\tfor (i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor (i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor (i=1;i<=k;i++)\n\t\tprintf(\"%d %d %d\\n\",1+u[i],202-v[i],w[i]);\n\tprintf(\"%d %d\\n\",1,202);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\nint main(int argc, char const *argv[]) {\n  // aX + bY + c = d11 不可能な(a, b, c)がわかる\n  // 10000条件×10000試行\n  // 不可能なものを削る\n\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n  vector<tp> use;\n  for(ll i=0;i<=99;i++){\n    for(ll j=0;j<=100;j++){\n      for(ll k=0;k<=100;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        nxt:;\n      }\n    }\n  }\n\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n  throw runtime_error(\"error\");\n  std::cout << \"Possible\" << '\\n';\n\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 210;\nint d[N][N];\n\nstruct Edge {\n    int u, v;\n    string c;\n};  \n\nint f[N][N];\n\nint g[N][N];\n\n//change to 100!\nconst int LEN = 100;\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int A, B;\n    cin >> A >> B;\n    for (int i = 1; i <= A; ++i)\n        for (int j = 1; j <= B; ++j)\n            cin >> d[i][j];    \n\n    int S = 1;\n    int T = 2;\n    int ptr = 3;\n    vector <Edge> ans;\n\n    int lx = ptr;\n    ans.app({S, ptr, \"X\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"X\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"X\"});\n    int rx = ptr - 1;\n\n    \n    int ly = ptr;\n    ans.app({S, ptr, \"Y\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"Y\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"Y\"});\n    int ry = ptr - 1;\n    \n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) {\n            for (int x = 0; x <= 100; ++x) {\n                for (int y = 0; y <= 100; ++y) {\n\n                    int have = x * i + y * j;\n                    if (have < d[i][j]) {\n                        f[x][y] = max(f[x][y], d[i][j] - have);\n                    }   \n                \n                }   \n            }   \n        }   \n    }   \n\n    for (int x = 0; x <= LEN/2; ++x) {\n        for (int y = 0; y <= LEN/2; ++y) {\n\n            int u = lx + x - 1;\n            if (x == 0)\n                u = S;\n\n            int v = ry - y + 1;\n            if (y == 0)\n                v = T;\n\n            ans.app({u, v, to_string(f[x][y])});\n        }   \n    }   \n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            const int INF = 1e9+7;\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    g[i][j] = INF;\n            for (auto e : ans) {\n                if (e.c == \"X\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], x);\n                }   \n                else if (e.c == \"Y\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], y);\n                }\n                else {\n                    g[e.u][e.v] = min(g[e.u][e.v], stoi(e.c));\n                }   \n            }\n            \n            for (int k = 0; k < N; ++k)\n                for (int u = 0; u < N; ++u)\n                    for (int v = 0; v < N; ++v)\n                        g[u][v] = min(g[u][v], g[u][k]+g[k][v]);       \n\n            if (g[S][T] != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                exit(0);\n            }   \n        }\n    }    \n\n    cout << \"Possible\" << endl;\n    for (auto e : ans)\n        cout << e.u << ' ' << e.v << ' ' << e.c << endl;\n    cout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tfreopen(\"tmp.out\",\"w\",stdout);\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"202 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<202;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=101;\nint qa,qb,qr[11][11],mp[N+1][N+1];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nbool jdg(){\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tint res=1e9;\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapn(res,(k-1)*i+(N-l)*j+mp[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(res>=qr[i][j]);\n\t\t\tif(res>qr[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tqa=nxi(),qb=nxi();\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tconst int v=qr[i][j]=nxi();\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapx(mp[k][l],v-i*(k-1)-j*(N-l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!jdg()){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N<<1,N*N+2*(N-1));\n\tfor(int i=1; i<N; ++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+N,i+N+1);\n\t}\n\tfor(int i=1; i<=N; ++i){\n\t\tfor(int j=1; j<=N; ++j){\n\t\t\tprintf(\"%d %d %d\\n\",i,j+N,mp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define min(a,b) ((a)<(b)? (a):(b))\n#define max(a,b) ((a)>(b)? (a):(b))\nint d[15][15],f[305][305];\nint main() {\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tscanf(\"%d\",&d[x][y]);\n\t\t}\t\n\t}\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tfor(register int x=1;x<=n;++x) {\n\t\t\t\tfor(register int y=1;y<=m;++y) {\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(f[i][j]>0) printf(\"%d \",f[i][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n//\tgetchar();getchar();\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tint minn=105;\n\t\t\tfor(register int i=0;i<=100;++i) {\n\t\t\t\tfor(register int j=0;j<=100;++j) {\n\t\t\t\t\tminn=min(minn,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minn!=d[x][y])  {printf(\"Impossible\\n\");return 0;}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(register int x=1;x<=100;++x) printf(\"%d %d X\\n\",x,x+1);\n\tfor(register int x=102;x<=201;++x) printf(\"%d %d Y\\n\",x,x+1);\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n //https://pitsbuffersolution.com/compro/atcoder/arc089e.php\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint A,B;\nint d[11][11];\nconst int C = 81;\nint S = 1 , T = 2 * C;\nint N = T , M = 2 * (C-1) + C * C;\nint e[C][C];\n \nint main(){\n\tcin >> A >> B;\n\trepp(i,1,A+1) repp(j,1,B+1) cin >> d[i][j];\n\trepp(i,0,C) repp(j,0,C){\n\t\trepp(x,1,A+1) repp(y,1,B+1) e[i][j] = max(e[i][j] , d[x][y]-i*x-j*y);\n\t}\n\trepp(x,1,A+1) repp(y,1,B+1){\n\t\tint z = C;\n\t\trepp(i,0,C) repp(j,0,C) z = min(z,e[i][j]+i*x+j*y);\n\t\tif(z != d[x][y]) return cout << \"Impossible\" << endl , 0;\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << N << ' ' << M << endl;\n\trepp(i,1,C){\n\t\tcout << i << ' ' << i+1 << \" X\" << endl;\n\t\tcout << C+i << ' ' << C+i+1 << \" Y\" << endl;\n\t}\n\trepp(i,0,C) repp(j,0,C) cout << i+1 << ' ' << N-j << ' ' << e[i][j] << endl;\n\tcout << S << ' ' << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nbool P[101][101][101]; // X, Y, 1;\nstruct e {\n    int from, to, cost;\n};\n\nstruct edge {int to; ll cost;};\nstruct node {int pos; ll cost;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nvector<ll> dijkstra(vector<vector<edge>> &G, int root){\n    vector<ll> ret(G.size(), inf);\n    priority_queue<node> pq;\n    pq.push({root, 0});\n    while (!pq.empty()) {\n        node t = pq.top();\n        pq.pop();\n        \n        if (ret[t.pos] == inf) ret[t.pos] = t.cost;\n        else continue;\n        \n        for (edge e : G[t.pos]) {\n            pq.push({e.to, t.cost + e.cost});\n        }\n    }\n    return ret;\n}\n\n\nconst int N = 101;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> D(A, vector<int> (B));\n    rep(i, A) rep(j, B) cin >> D[i][j];\n    rep(i, N) rep(j, N) rep(k, N) P[i][j][k] = 1;\n    rep(i, N) rep(j, N) rep(k, N){\n        rep(a, A) rep(b, B){\n            if(D[a][b] > (a + 1) * i + (b + 1) * j + k) P[i][j][k] = 0;\n        }\n    }\n    \n    vector<e> ret;\n    rep(i, N) rep(j, N){\n        rep(k, N) {\n            if(P[i][j][k]){\n                ret.pb({i, 201 - j, k});\n                break;\n            }\n        }\n    }\n    \n    rep(a, A) rep(b, B){\n        vector<vector<edge>> G(202);\n        rep(i, N) G[i].pb({i + 1, a + 1});\n        rep(i, N) G[i + N].pb({i + N + 1, b + 1});\n        for(auto e: ret) {\n            G[e.from].pb({e.to, e.cost});\n        }\n        \n        auto dist = dijkstra(G, 0);\n        if(dist[201] != D[a][b]){\n            output(\"Impossible\");\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 200 + (int)ret.size() << endl;\n    \n    rep(i, N){\n        cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n    }\n    rep(i, N){\n        cout << i + N << \" \" << i + N + 1 << \" \" << \"Y\" << endl;\n    }\n    \n    for(auto e: ret) {\n        cout << e.from << \" \" << e.to << \" \" << e.cost << endl;\n    }\n    cout << 0 << \" \" << 201 << endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i<<\" \"<<j<<\":\"<<dist<<\":\"<<d[i][j]<<endl;\n\tassert(0);\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint c[102][102];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, a, b);\n\tMAT(int, d, a, b);\n\tREP(ai, 101) REP(bi, 101) REP(x, a) REP(y, b) {\n\t\tCHMAX(c[ai][bi], d[x][y] - ai * (x + 1) - bi * (y + 1));\n\t}\n\tREP(x, a) REP(y, b) {\n\t\tint dist = INFINT;\n\t\tREP(ai, 101) REP(bi, 101) {\n\t\t\tCHMIN(dist, ai * (x + 1) + bi * (y + 1) + c[ai][bi]);\n\t\t}\n\t\tif (dist != d[x][y]) {\n\t\t\tOUT(\"Impossible\")BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tOUT(\"Possible\")BR;\n\tOUT(\"202 10401\")BR;\n\tREP(i, 100) {\n\t\tOUT(i + 1)SP OUT(i + 2)SP OUT('X')BR;\n\t\tOUT(i + 2 + 101)SP OUT(i + 1 + 101)SP OUT('Y')BR;\n\t}\n\tREP(i, 101) REP(j, 101) {\n\t\tOUT(i + 1)SP OUT(j + 1 + 101)SP OUT(c[i][j])BR;\n\t}\n\tOUT(\"1 101\")BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define CLR(t, v) memset(t, (v), sizeof(t))\ntemplate <class T1, class T2>ostream &operator<<(ostream &os, const pair<T1, T2> &a){  return os << \"(\" << a.first << \",\" << a.second << \")\";}\ntemplate <class T>void pv(T a, T b){  for (T i = a; i != b; ++i)    cout << (*i) << \" \";  cout << endl;}\ntemplate <class T>void chmin(T &a, const T &b){  if (a > b)    a = b;}\ntemplate <class T>void chmax(T &a, const T &b){  if (a < b)    a = b;}\n\nint nextInt(){  int x;  scanf(\"%d\", &x);  return x;}\n\nconst int INF = 1000000;\nconst int K = 100;\n\nint D[105][105];\nint C[105][105];\n\nstruct E {\n  int from, to, cost;\n};\n\nint main2() {\n  int A = nextInt();\n  int B = nextInt();\n  REP(x, A) REP(y, B) D[x+1][y+1] = nextInt();\n\n  REP(i, K+1) REP(j, K+1) {\n    int c = 0;\n    for (int x = 1; x <= A; x++) for (int y = 1; y <= B; y++) {\n      chmax(c, D[x][y] - i*x - j*y);\n    }\n    C[i][j] = c;\n  }\n\n  bool possible = true;\n  for (int x = 1; x <= A; x++) for (int y = 1; y <= B; y++) {\n    int d = INF;\n    REP(i, K+1) REP(j, K+1) {\n      chmin(d, i*x + j*y + C[i][j]);\n    }\n    if (D[x][y] != d) possible = false;\n  }\n\n  if (possible) {\n    vector<E> es;\n    REP(i, K) es.push_back({i, i+1, -1});\n    REP(j, K) es.push_back({299-j-1, 299-j, -2});\n    REP(i, K) REP(j, K) {\n      es.push_back({i, 299-j, C[i][j]});\n    }\n    cout << 300 << \" \" << es.size() << endl;\n    for (auto e : es) {\n      cout << (e.from+1) << \" \" << (e.to + 1) << \" \";\n      if      (e.cost == -1) cout << \"X\";\n      else if (e.cost == -2) cout << \"Y\";\n      else                   cout << e.cost;\n      cout << endl;\n    }\n    cout << 1 << \" \" << 300 << endl;\n\n  } else {\n    cout << \"Impossible\" << endl;\n  }\n  return 0;\n}\n\nint main() {\n  for (; !cin.eof(); cin >> ws) main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n  ll v, dist;\n};\n\nstruct state {\n  ll v, cost;\n\n  bool operator>(const state s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n  vector<ll> dp(E.size(), INF);\n  priority_queue<state, vector<state>, greater<state> > q;\n  q.push((state) { S, 0 });\n\n  while(!q.empty()) {\n    ll v = q.top().v, cost = q.top().cost;\n    q.pop();\n\n    if(dp[v] <= cost) continue;\n    dp[v] = cost;\n\n    REP(i, 0, E[v].size()) {\n      ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n      if(dp[nv] > ncost) q.push((state) { nv, ncost });\n    }\n  }\n\n  return dp;\n}\n\nint main(void) {\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct data { ll p, q, r; };\n  vector<data> e;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(p, 0, 101) REP(q, 0, 101) REP(r, 0, 100 + 1) {\n    bool f = true;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      ll v = p * x + q * y + r;\n      f = f && D[x][y] <= v;\n    }\n    if(!f) continue;\n    ll cnt = 0;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      ll v = p * x + q * y + r;\n      if(!ok[x][y] && D[x][y] == v) {\n        ok[x][y] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) e.push_back((data) { p, q, r });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  ll N = 202, M = 200 + e.size(), S = 1, T = 102;\n  cout << \"Possible\" << endl;\n  cout << N << \" \" << M << endl;\n  REP(i, S, S + 100) cout << i << \" \" << i + 1 << \" X\" << endl;\n  REP(i, T, T + 100) cout << i + 1 << \" \" << i << \" Y\" << endl;\n  REP(i, 0, e.size()) cout << S + e[i].p << \" \" << T + e[i].q << \" \" << e[i].r << endl;\n  cout << S << \" \" << T << endl;\n\n  REP(x, 1, A + 1) REP(y, 1, B + 1) {\n    vector< vector<edge> > E(N + 1);\n    REP(i, S, S + 100) E[i].push_back((edge) { i + 1, x });\n    REP(i, T, T + 100) E[i + 1].push_back((edge) { i, y });\n    REP(i, 0, e.size()) E[S + e[i].p].push_back((edge) { T + e[i].q, e[i].r });\n    ll d = dijkstra(E, S)[T];\n    assert(d == D[x][y]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A, B, N, M, S, T, d[15][15];\nint adj[102][102];\nint dist[204];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i){\n\t\tfor (int j = 1; j <= B; ++j){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tS = 1;\n\tT = 202;\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 1; k <= A; ++k){\n\t\t\t\tfor (int l = 1; l <= B; ++l){\n\t\t\t\t\tmaxi = max(maxi,d[k][l]-k*i-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj[i][j] = maxi;\n\t\t\tif (maxi > 100){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 1; k <= A; ++k){\n\t\tfor (int l = 1; l <= B; ++l){\n\t\t\tdist[1] = 0;\n\t\t\tfor (int i = 1; i <= 100; ++i){\n\t\t\t\tdist[i+1] = dist[i] + k;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 100; ++i){\n\t\t\t\tint mini = 1e9;\n\t\t\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\t\t\tmini = min(mini,adj[j][100-i]+dist[j+1]);\n\t\t\t\t}\n\t\t\t\tif (i > 0){\n\t\t\t\t\tmini = min(mini,dist[102+i-1]+l);\n\t\t\t\t}\n\t\t\t\tdist[102+i] = mini;\n\t\t\t}\n\t\t\t//cout << dist[202] << ' ';\n\t\t\tif (dist[202] != d[k][l]){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t//cout << '\\n';\n\t}\n\tN = 202;\n\tM = 100+100+(101*101);\n\tcout << \"Possible\\n\";\n\tcout << N << ' ' << M << '\\n';\n\tfor (int i = 1; i <= 100; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 102; i <= 201; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tcout << i+1 << ' ' << j+102 << ' ' << adj[i][100-j] << '\\n';\n\t\t}\n\t}\n\tcout << S << ' ' << T << '\\n';\n\tcout << flush;\n\t//for (int i = 1; i < 1e9; ++i){for (int j = 0; j < 1e9; ++j){}}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=105;\ninline int read()\n{\n\tint s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint n,m;\nint d[15][15],f[N][N];\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\td[i][j]=read();\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-y*j);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int y=1;y<=m;y++)\n\t\t{\n\t\t\tint now=100000;\n\t\t\tfor(int i=0;i<=100;i++)\n\t\t\t\tfor(int j=0;j<=100;j++)\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+y*j);\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i=1;i<101;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=1;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = 0, y = 0;\n\t\t\tfor(int k = i; k <= a; k++) for(int l = j; l <= b; l++){\n\t\t\t\tif(k>i) chmax(x, (d[k][j]-d[i][j]+k-i-1)/(k-i));\n\t\t\t\tif(l>j) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t}\n\n\t\t\t//for(int k = j+1; k <= b; k++) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t//ll x = i<a?(d[a][j]-d[i][j]+a-i)/(a-i):0;\n\t\t\t//ll y = j<b?(d[i][b]-d[i][j]+b-j)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint A,B;\nint D[11][11];\n\nvector<int>X,Y,Z;\n\nsigned main(){\n    cin>>A>>B;\n    for(int i=1;i<=A;i++)for(int j=1;j<=B;j++)cin>>D[i][j];\n\n    rep(i,100){\n        X.pb(i);Y.pb(i+1);Z.pb(-1);\n        X.pb(i+100);Y.pb(i+1+100);Z.pb(-2);\n    }\n    int S=0,T=200;\n\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            bool flag=false;\n            for(int k=0;k<=100;k++)for(int l=0;l<=100;l++){\n                if(flag)continue;\n                if(k*i+l*j>D[i][j])continue;\n                int m=D[i][j]-k*i-l*j;\n                bool ok=true;\n                for(int x=1;x<=A;x++)for(int y=1;y<=B;y++)if(k*x+l*y+m<D[x][y])ok=false;\n                if(!ok)continue;\n                flag=true;\n\n                bool latte=false;\n                rep(w,X.size())if(X[w]==k&&Y[w]==200-l)latte=true;\n                if(!latte){X.pb(k);Y.pb(200-l);Z.pb(m);}\n\n            }\n            if(!flag){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"Possible\"<<endl;\n\n\n\n    cout<<201<<\" \"<<X.size()<<endl;\n    rep(i,X.size()){\n        cout<<X[i]+1<<\" \"<<Y[i]+1<<\" \";\n        if(Z[i]==-1)cout<<\"X\"<<endl;\n        else if(Z[i]==-2)cout<<\"Y\"<<endl;\n        else cout<<Z[i]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      vector<Int> dp1(100,INF),dp2(100,INF);\n      for(Int k=100-1;k>=0;k--){\n\tdp1[k]=C[k];\n\tdp2[k]=D[k];\n\tif(k+1<100){\n\t  chmin(dp1[k],dp1[k+1]+i);\n\t  chmin(dp2[k],dp2[k+1]+j);\n\t}\n      }\n      for(Int k=0;k<100;k++){\n\tfor(Int l=0;l<100;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*(k+1)+dp2[l]));\n\t  chmax(F[k][l],d[i][j]-((j+1)*(k+1)+dp1[l]));\n\t}\n      }\n    }\n  }\n  \n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  for(Int k=0;k<100;k++){\n    for(Int l=0;l<100;l++){\n      //if(E[k][l]) cout<<k<<\" \"<<l<<\":E:\"<<E[k][l]<<endl;\n      //if(F[k][l]) cout<<k<<\" \"<<l<<\":F:\"<<F[k][l]<<endl;\n      \n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 150;\nconst int M = (int) 20;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nconst int nx[4] = {0, 0, -1, 1};\nconst int ny[4] = {1, -1, 0, 0};\n\nint A, B;\nint d[N][N];\nint f[N][N];\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n  //    freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> A >> B;\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      cin >> d[i][j];\n    }\n  }\n  for (int a = 0; a < N; a++) {\n    for (int b = 0; b < N; b++) {\n      for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++) {\n          f[a][b] = max(f[a][b], d[i][j] - i * a - j * b);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      bool cur = false;\n      for (int a = 0; a < N; a++) {\n        for (int b = 0; b < N; b++) {\n          if (d[i][j] == f[a][b] + a * i + b * j) {\n            cur = true;\n          }\n        }\n      }\n      if (!cur) {\n        cout << \"Impossible\";\n        return 0;\n      }\n    }\n  }\n  cout << 200 << ' ' << 100 * 100 + 99 * 2 << endl;\n  for (int a = 0; a + 1 < 100; a++) {\n    cout << a + 1 << ' ' << a + 2 << \" X\\n\";\n  }\n  for (int b = 0; b + 1 < 100; b++) {\n    cout << b + 1 << ' ' << b + 2 << \" Y\\n\";\n  }\n  for (int a = 0; a < 100; a++) {\n    for (int b = 0; b < 100; b++) {\n      cout << a + 1 << ' ' << 100 + 100 - b << ' ' << f[a][b] << \"\\n\";\n    }\n  }\n  cout << 1 << ' ' << 200;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\nconst int MOD = 1e9 + 7;\n\nint a, b;\nint d[50][50];\nint go[200][200];\n\nsigned main()\n{\n    //freopen(\"input_02.txt\", \"r\", stdin);\n    //freopen(\"output_02.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for (int i = 0; i <= 50; i++)\n    {\n        for (int j = 0; j <= 50; j++)\n        {\n            int max_c = -1e9;\n            for (int x = 1; x <= a; x++)\n            {\n                for (int y = 1; y <= b; y++)\n                {\n                    int moved = i * x + j * y;\n                    int add = d[x][y] - moved;\n                    max_c = max(max_c, add);\n                }\n            }\n            if (max_c <= 100 && 0 <= max_c)\n            {\n                go[i][j] = max_c;\n            }\n            else\n            {\n                go[i][j] = 1e9;\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            for (int i = 0; i <= 50; i++)\n            {\n                for (int j = 0; j <= 50; j++)\n                {\n                    if (x * i + go[i][j] + y * j < d[x][y])\n                    {\n                        go[i][j] = 1e9;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            int min_c = 1e9;\n            for (int i = 0; i <= 50; i++)\n            {\n                for (int j = 0; j <= 50; j++)\n                {\n                    if (min_c > i * x + go[i][j] + j * y)\n                    {\n                        min_c = i * x + go[i][j] + j * y;\n                    }\n                }\n            }\n            if (min_c != d[x][y])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    int cnt = 0;\n    for (int i = 0; i <= 50; i++)\n    {\n        for (int j = 0; j <= 50; j++)\n        {\n            if (go[i][j] <= 50 && 0 <= go[i][j]) cnt++;\n        }\n    }\n    cout << 102 << \" \" << cnt + 100 << \"\\n\";\n    for (int i = 0; i < 50; i++)\n    {\n        cout << i + 1 << \" \" << i + 2 << \" \" << 'X' << \"\\n\";\n    }\n    for (int j = 0; j < 50; j++)\n    {\n        cout << 102 - j - 1 << \" \" << 102 - j << \" \" << 'Y' << \"\\n\";\n    }\n    for (int i = 0; i <= 50; i++)\n    {\n        for (int j = 0; j <= 50; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j])\n            {\n                cout << i + 1 << \" \" << 102 - j << \" \" << go[i][j] << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << 102 << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\n#include<bitset>\nusing namespace std;\n#define pb push_back\n#define x0 fuckcjb\n#define x1 fuckshb\n#define y0 fucksub\n#define y1 fuckjtjl\nstruct edges\n{\n\tint x,y,z;\n};\nint d[15][15];\nbool vis[20][20];\nint tot,n,idx[120],idy[120],S,T,A,B;\nvector<edges> edge;\nvoid check()\n{\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(!vis[i][j])\n\t\t\t{\n\t\t\tputs(\"Impossible\");\n\t\t\texit(0);\n\t\t}\n\t\t}\n\t}\n}\nint get(int p,int q)\n{\n\tint c=-1000000;\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tc=max(c,d[i][j]-i*p-j*q);\n\t\t}\n\t}\n\tif(c<0)\n\t{\n\t\treturn -3;\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(d[i][j]-i*p-j*q==c)\n\t\t\t{\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\nvoid add(int x,int y,int z)\n{\n\tif(z==-3)\n\t{\n\t\treturn;\n\t}\n\tedge.push_back({x,y,z});\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tS=1;T=2;tot=2;\n\tidx[0]=S;idy[0]=T;\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tidx[i]=++tot;\n\t\tidy[i]=++tot;\n\t}\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tadd(idx[i-1],idx[i],-1);\n\t\tadd(idy[i],idy[i-1],-2);\n\t}\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tadd(idx[i],idy[j],get(i,j));\n\t\t}\n\t}\n\tcheck();\n\tputs(\"Possible\");\n\tint cnt=edge.size();\n\tprintf(\"%d %d\\n\",tot,cnt);\n\tfor(int i=0;i<cnt;i++)\n\t{\n\t\tprintf(\"%d %d \",edge[i].x,edge[i].y);\n\t\tif(edge[i].z>=0)\n\t\t{\n\t\t\tprintf(\"%d\\n\",edge[i].z);\n\t\t}\n\t\telse if(edge[i].z==-1)\n\t\t{\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"Y\");\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\n#define int ll\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nsigned main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll f = 100;\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < f; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < f; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= f; i++) {\n\t\tfor (int j = 0; j <= f; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= f; i++) {\n\t\t\t\tfor (int t = 0; t <= f; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << 200 << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i << \" \" << i + 1 << \" X\" << endl;\n        cout << i + 100 << \" \" << i + 101 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            cout << xuse << \" \" << 200 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"0 200\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing K = long double;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define SIZE(a) ((int)(a).size())\n\nconst int N = 15;\nconst int M = 105;\n\nint n = 204, m;\nvector<tuple<int,int,int>> edges; \n\nint a, b, d[N][N];\nint used[N][N];\nint was[M][M];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> a >> b;\n\tfor (int i = 1; i <= a; ++i) {\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tfor (int r = 0; r <= 100; ++r) {\n\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\tif (was[x][y]) continue;\n\t\t\t\tint failed = 0;\n\t\t\t\tfor (int i = 1; i <= a; ++i) {\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (r + x*i + y*j < d[i][j]) {\n\t\t\t\t\t\t\tfailed = 1;\n\t\t\t\t\t\t\tgoto fin;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfin:\n\t\t\t\tif (!failed) {\n\t\t\t\t\tedges.emplace_back(2 + x, 103 + y, r);\n\t\t\t\t\twas[x][y] = 1;\n\t\t\t\t\tfor (int i = 1; i <= a; ++i) {\n\t\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\t\tif (r + x*i + y*j == d[i][j]) {\n\t\t\t\t\t\t\t\tused[i][j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= a; ++i) {\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tif (!used[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\n\tcout << n << ' ' << SIZE(edges)+202 << '\\n';\n\tcout << 1 << ' ' << 2 << ' ' << 0 << '\\n';\n\tcout << 103 << ' ' << 204 << ' ' << 0 << '\\n';\n\tfor (int i = 2; i <= 101; ++i) {\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 103; i <= 202; ++i) {\n\t\tcout << i+1 << ' ' << i << ' ' << 'Y' << '\\n';\n\t}\n\tfor (auto& item : edges) {\n\t\tint x, y, c;\n\t\ttie(x, y, c) = item;\n\t\tcout << x << ' ' << y << ' ' << c << '\\n';\n\t}\n\tcout << 1 << ' ' << 204 << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint d[11][11];\nint val[11][11];\n\nusing edge = tuple<int, int, int>;\nvector<edge> graph;\n\nusing edge2 = tuple<int, int, char>;\nvector<edge2> graph2;\n\n\nint main(void) {\n\tint a, b;\n\tcin >> a >> b;\n\n\trep(i, a)rep(j, b) cin >> d[i][j];\n\trep(i, a)rep(j, b) val[i][j] = 1010;\n\n\tconst int total = 2;\n\tconst int n = total * total + 1;\n\tconst int s = 0, t = n - 1;\n\n\trep(ca, total)rep(cb, total) {\n\t\tint tmp[11][11];\n\t\trep(x, a)rep(y, b) tmp[x][y] = ca * (x + 1) + cb * (y + 1);\n\t\tint cmax = 0;\n\t\trep(x, a)rep(y, b) chmax(cmax, d[x][y] - tmp[x][y]);\n\t\tif (cmax > 100) continue;\n\t\t\n\t\t/*\t\n\t\trep(x, a){\n\t\t\trep(y, b) cerr << tmp[x][y] << \" \";\n\t\t\tcerr << endl;\n\t\t}\n\t\t*/\n\n\t\t//cerr << cmax << endl;\n\n\t\t//cerr << ca << \" \" << cb << endl;\n\t\trep(x, a)rep(y, b) chmin(val[x][y], tmp[x][y] +  cmax);\n\t\tconst int idx = total * ca + cb;\n\t\tgraph.push_back(edge(idx, t, cmax));\n\t}\n\n\trep(ca, total - 1) {\n\t\tgraph2.push_back(edge(total * ca, total * (ca + 1), 'X'));\n\t}\n\n\trep(ca, total)rep(cb, total - 1) {\n\t\tgraph2.push_back(edge(total * ca + cb , total * ca + cb + 1, 'Y'));\n\t}\n\n\n\trep(x, a)rep(y, b) {\n\t\t//cerr << val[x][y] << \" \" << d[x][y] << endl;\n\t\tif (val[x][y] != d[x][y]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tconst int m = graph.size() + graph2.size();\n\tcout << n << \" \" << m << endl;\n\tfor (auto &it : graph) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tfor (auto &it : graph2) {\n\t\tint a, b;\n\t\tchar  c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tcout << s + 1 << \" \" << t + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#define LL long long\n#define Re register int\nusing namespace std;\nconst int N=103,M=13;\nint n,m,d[13][13],f[103][103];\ninline void in(Re &x){\n    int f=0;x=0;char c=getchar();\n    while(c<'0'||c>'9')f|=c=='-',c=getchar();\n    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    x=f?-x:x;\n}\nint main(){\n//\tfreopen(\"123.txt\",\"r\",stdin);\n\tin(n),in(m);\n\tfor(Re i=1;i<=n;++i)\n\t\tfor(Re j=1;j<=m;++j)\n\t\t\tin(d[i][j]);\n\tfor(Re i=0;i<=100;++i)\n\t\tfor(Re j=0;j<=100;++j)\n\t\t\tfor(Re x=1;x<=n;++x)\n\t\t\t\tfor(Re y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(Re x=1;x<=n;++x)\n\t\tfor(Re y=1;y<=m;++y){\n\t\t\tRe dis=2e9;\n\t\t\tfor(Re i=0;i<=100;++i)\n\t\t\t\tfor(Re j=0;j<=100;++j)\n\t\t\t\t\tdis=min(dis,f[i][j]+i*x+j*y);\n\t\t\tif(dis!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n    for(Re i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n    for(Re i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n    for(Re i=0;i<=100;i++)\n        for(Re j=0;j<=100;j++)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    puts(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            rep(k,i+1,a){\n                Max(dx,(d[k][j]-d[i][j]+k-i-1)/(k-i));\n            }\n            rep(l,j+1,b){\n                Max(dy,(d[i][l]-d[i][j]+l-j-1)/(l-j));\n            }\n            vector<pipi> w;\n            rep(k,dx,100){\n                rep(l,dy,100){\n                    int rrr=0;\n                    rep(ii,i+1,a){\n                        rep(jj,j+1,b){\n                            int sa=k*(ii-i)+l*(jj-j);\n                            if(d[i][j]+sa<d[ii][jj]){\n                                rrr=1;\n                                break;\n                            }\n                        }\n                        if(rrr)break;\n                    }\n                    if(rrr==0){\n                        w.push_back({(i+1)*k+(j+1)*l,{k,l}});\n                    }\n                }\n            }\n            sort(w.begin(),w.end());\n            dx=w[0].second.first;\n            dy=w[0].second.second;\n            //cout<<dx<<\" \"<<dy<<endl;\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<map>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nint A,B;\nint dis[15][15];\nint ed[105][105];\nint main()\n{\n\tread(A);\n\tread(B);\n\tmemset(ed,0,sizeof(ed));\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tread(dis[i][j]);\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\ted[a][b]=max(ed[a][b],dis[i][j]-a*i-b*j);\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tlong long ans=12345678987654321ll;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tans=min(ans,1ll*a*i+b*j+ed[a][b]);\n\t\t\tif(ans!=dis[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tcout<<202<<' '<<101*101+200<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i<<' '<<i+1<<\" X\"<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i+101+1<<' '<<i+101<<\" Y\"<<endl;\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tcout<<i+1<<' '<<j+101+1<<' '<<ed[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n\nint n, m, a[10][10];\nint S, T, id;\nvector<II> vres;\n\nvoid add(int x, int y, int z) {\n\tvres.push_back(II(z, ii(x + 1, 200 - y)));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 200, id = 200;\n\tfor (int i = 1; i < 100; ++i) vres.push_back(II(-1, ii(i, i + 1)));\n\tfor (int i = 101; i < 200; ++i) vres.push_back(II(-2, ii(i, i + 1)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tsort(vres.begin(), vres.end());\n\tvres.erase(unique(vres.begin(), vres.end()), vres.end());\n\tcout << \"Possible\\n\";\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.se.fi << ' ' << i.se.se << ' ';\n\t\tif (i.fi == -1) cout << \"X\\n\";\n\t\tif (i.fi == -2) cout << \"Y\\n\";\n\t\tif (i.fi >= 0) cout << i.fi << '\\n';\n\t}\n\tcout << S << ' ' << T;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int INF = numeric_limits<int>::max();\n\nconstexpr int MAX_N = 105;\n\nint A, B, D[11][11];\n\nint F[MAX_N][MAX_N];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 0; j < A; ++j) {\n        for (int k = 0; k < B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    for (int j = 0; j < MAX_N; ++j) for (int k = 0; k < MAX_N; ++k) {\n        for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n            F[j][k] = max(F[j][k], D[a][b] - (a+1) * j - (b+1) * k);\n        }\n    }\n\n    for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n        int min_dist = INF;\n        for (int j = 0; j < MAX_N; ++j) {\n            for (int k = 0; k < MAX_N; ++k) {\n                min_dist = min(min_dist, (a+1) * j + (b+1) * k + F[j][k]);\n            }\n        }\n        if (min_dist != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", 2*MAX_N, 2*(MAX_N-1) + MAX_N*MAX_N);\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d X\\n\", (j+1), (j+2));\n    }\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d Y\\n\", MAX_N+(j+1), MAX_N+(j+2));\n    }\n    for (int j = 0; j < MAX_N; ++j) {\n        for (int k = 0; k < MAX_N; ++k) {\n            printf(\"%d %d %d\\n\", (j+1), 2*MAX_N-k, F[j][k]);\n        }\n    }\n    printf(\"%d %d\\n\", 1, 2*MAX_N);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tvvi c(n+1,vi(m+1,100));\n\trep(i,n+1)rep(j,m+1){\n\t\tint ma=0;\n\t\trep(k,n)rep(l,m)ma=max(ma,in[k][l]-i*(k+1)-j*(l+1));\n\t\tc[i][m-j]=ma;\n\t}\n\tbool h=true;\n\trep(i,n)rep(j,m){\n\t\tint mi=inf;\n\t\trep(k,n+1)rep(l,m+1)mi=min(mi,(i+1)*k+(j+1)*l+c[k][m-l]);\n\t\tif(mi!=in[i][j])h=false;\n\t}\n\t\n\tif(!h)cout<<\"Impossible\"<<endl;\n\telse{\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<n+1+m+1<<\" \"<<n+m+(n+1)*(m+1)<<endl;\n\t\trep(i,n)cout<<1+i<<\" \"<<2+i<<\" X\"<<endl;\n\t\trep(i,m)cout<<n+m+1-i<<\" \"<<n+m+2-i<<\" Y\"<<endl;\n\t\trep(i,n+1)rep(j,m+1){\n\t\t\tcout<<1+i<<\" \"<<n+2+j<<\" \"<<c[i][j]<<endl;\n\t\t}\n\t\tcout<<\"1 \"<<n+m+2<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\n\nvoid Set(int a, int b)\n{\n\tint d = D[a - 1][b - 1];\n\n\tint min_f = 999;\n\tint min_i;\n\tint min_j;\n\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tint f = d - ((i * a) + ((100 - j) * b));\n\t\t\tif (f == F[i][j])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (f >= 0 && F[i][j] > 100)\n\t\t\t{\n\t\t\t\tif (min_f > f)\n\t\t\t\t{\n\t\t\t\t\tmin_f = f;\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (min_f > 100)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\telse\n\t{\n\t\tF[min_i][min_j] = min_f;\n\t}\n}\n\nbool Check(int a,int b)\n{\n\tint d = D[a - 1][b - 1];\n\tint min = INT_MAX;\n\tREP(i, 101)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tint m = (i * a) + ((100 - j) * b) + F[i][j];\n\t\t\tmin = MIN(m, min);\n\t\t}\n\t}\n\tif (min == d)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\n\tREP(i, 101) REP(j, 101) F[i][j] = 1000;\n\n\tfor(int a = A - 1; a >= 0; a--)\n\t{\n\t\tfor (int b = B - 1; b >= 0; b--)\n\t\t{\n\t\t\tSet(a + 1, b + 1);\n\t\t}\n\t}\n\n\tint m = 200;\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tif (!Check(a + 1, b + 1))\n\t\t\t{\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << m << endl;\n\t\n\tREP(i, 100)\n\t{\n\t\tcout << i << \" \" << (i + 1) << \" X\"  << endl;\n\t}\n\tREP(i, 100)\n\t{\n\t\tcout << (101 + i) << \" \" << (101 + i + 1) << \" Y\" << endl;\n\t}\n\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tcout << a << \" \" << (101 + b) << \" \" << F[a][b] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"0 201\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid solve(){\n  int A,B;\n  cin >> A >> B;\n\n  vector<vector<int>> d(A,vector<int>(B));\n  REP(i,A) REP(j,B) cin >> d[i][j];\n  \n  int s = 1, t = 300;\n  mat e(A,vec(B,LINF));\n  vector<T> ans; \n  REP2(i,100) REP2(j,100){\n    int f = 0;\n    REP(a,A) REP(b,B){\n      chmax(f,d[a][b]-(a+1)*i-(b+1)*j);\n    }\n    assert(f <= 100);\n    REP(a,A) REP(b,B){\n      chmin(e[a][b],(a+1)*i+(b+1)*j+f);\n    }\n    ans.emplace_back(i+1,300-j,f);\n  }\n\n  REP(i,A) REP(j,B){\n    if(d[i][j]!=e[i][j]){\n      cout << \"Impossible\" << endl;\n      return;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 300 SP 200+ans.size() << endl;\n  REP(i,100) cout << i+1 SP i+2 << \"X\" << endl;\n  REP(i,100) cout << 200+i SP 201+i << \"Y\" << endl;\n  REP(i,ans.size()){\n    int x,y,z;\n    tie(x,y,z) = ans[i];\n    cout << x SP y SP z << endl;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint d[10][10];\nint c[101][101];\n\nint main(){\n\tint a,b;\n\tcin >> a >> b;\n\n\tfor(int i=0; i<a; i++)\n\t\tfor(int j=0; j<b; j++)\n\t\t\tcin >> d[i][j];\n\n\tfor(int i=0; i<a; i++){\n\t\tfor(int j=1; j<b;j++){\n\t\t\tif(d[i][j-1] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(j!=b-1 && d[i][j-1] + d[i][j+1] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0; j<b; j++){\n\t\tfor(int i=1; i<a;i++){\n\t\t\tif(d[i-1][j] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(i!=a-1 && d[i-1][j] + d[i+1][j] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\n\tfor(int i=1;i<=100;i++){\n\t\tcout << i <<\"  \"<< i+1 <<\" X\"<<endl;\n\t\tcout << i+101 <<\" \"<< i+102 <<\" Y\"<<endl;\n\t}\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tint res = 100;\n\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\t\tif(res > d[i][j] - kx*i - ky*j)\n\t\t\t\t\t\tres = d[i][j] - kx*i - ky*j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res < 1)\n\t\t\t\tres = 1;\n\n\t\t\tcout << kx+1 <<\" \"<<202 - ky<<\" \"<<res<<endl;\n\t\t}\n\t}\n\n\n\tcout << \"1 202\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2;\nint x,y,d[105][105],f[105][105];\nint main()\n{\n    scanf(\"%d%d\",&x,&y);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j)\n            scanf(\"%d\",&d[i][j]);\n    for (int a=0;a<=maxn;++a)\n        for (int b=0;b<=maxn;++b)\n            for (int i=1;i<=x;++i)\n                for (int j=1;j<=y;++j)\n                    f[a][b]=max(f[a][b],d[i][j]-a*i-b*j);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j) {\n            int dis=10000000;\n            for (int a=0;a<=maxn;++a)\n                for (int b=0;b<=maxn;++b)\n                    dis=min(dis,f[a][b]+a*i+b*j);\n            if (dis!=d[i][j]) return 0*puts(\"Impossible\");\n        }\n    puts(\"Possible\");\n    for (int i=1;i<=maxn;++i) printf(\"%d %d X\\n\",i,1+i);\n    for (int i=1;i<=maxn;++i) printf(\"%d %d Y\\n\",maxn+1+i,maxn+2+i);\n    for (int i=1;i<=maxn+1;++i)\n        for (int j=1;j<=maxn+1;++j)\n            printf(\"%d %d %d\\n\",i,maxn+maxn+3-j,f[i-1][j-1]);\n    printf(\"%d %d\\n\",1,maxn+maxn+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll X, Y; cin >> X >> Y;\n    vvll d(X, vll(Y)); cin >> d;\n\n    // X=x, Y=y (1 <= x <= X, 1 <= y <= Y)\n    // a = xの数、b = yの数 (0 <= a, b <= 100)\n    //\n    // for all x,y  \n    //      d_xy = min_ab ax+by+c_ab\n    //\n    // c_ab = max(0, max_xy d_xy - ax - by)\n    ll abmax = 3;\n\n    vvll c(abmax, vll(abmax));\n    rep(a, abmax) rep(b, abmax) {\n        repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n            chmax(c[a][b], d[x-1][y-1]-a*x-b*y);\n        }\n    }\n    repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n        ll tmp = INF;\n        rep(a, abmax) rep(b, abmax) {\n            chmin(tmp, a*x+b*y+c[a][b]);\n        }\n        if (d[x-1][y-1] != tmp) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    ll n = 2 * (abmax+1);\n    ll m = abmax*abmax + abmax * 2;\n            cout << \"Possible\" << endl;\n    cout << n << \" \" << m << endl;\n    rep(i, abmax) {\n        cout << i+1 << \" \" << i+1+1 << \" \" << \"X\" << endl;\n        cout << 2*abmax+1-i-1+1 << \" \" << 2*abmax+1-i+1 << \" \" << \"Y\" << endl;\n    }\n    rep(a, abmax) rep(b, abmax) {\n        cout << a+1 << \" \" << 2 * abmax + 1 - b+1 << \" \" << c[a][b] << endl;\n    }\n    cout << 1 << \" \" << n << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\t//freopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N*2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+1;i<N*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i+1,i);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i,N+j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\nusing namespace std;\n#pragma region define\n#define M_PI 3.141592653589793238\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\n#pragma endregion\n#pragma region Inner Class\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n#pragma endregion\nusing mint = modint<998244353>;\n//using mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\n#pragma region mint\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nvem kai, inv_kai;\nvoid make_kai(int n) {\n\tkai = vem(n + 1, 1);\n\tinv_kai = vem(n + 1, 1);\n\trep(i, n) { kai[i + 1] = kai[i] * (i + 1); }\n\tinv_kai[n] = (mint)1 / kai[n];\n\tfor (int i = n; i > 0; i--) { inv_kai[i - 1] = inv_kai[i] * i; }\n}\nmint com(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r] * inv_kai[n - r];\n}\nmint per(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r];\n}\n#pragma endregion\nsigned main() {\n\tomajinai;\n\tint a, b; cin >> a >> b;\n\tvvel d(a, vel(b));\n\trep(i, a) { rep(j, b) { cin >> d[i][j]; } }\n\tvvel vx(a, vel(b,-1));\n\tvvel vy(a, vel(b,-1));\n\tvvel vex(a, vel(b,-1));\n\tvvel way;\n\trep(i, a) {\n\t\trep(j, b) {\n\t\t\tfor (int x = 0; x * (i + 1) <= d[i][j]; x++) {\n\t\t\t\tint ex = d[i][j] - x * (i + 1);\n\t\t\t\tfor (int y = 0; y * (j + 1) <= ex; y++) {\n\t\t\t\t\tint qex = ex - y * (j + 1);\n\t\t\t\t\tbool fl = true;\n\t\t\t\t\trep(mi, a) {\n\t\t\t\t\t\trep(mj, b) {\n\t\t\t\t\t\t\tif (d[mi][mj] > qex + x * (mi + 1) + y * (mj + 1)) {\n\t\t\t\t\t\t\t\tfl = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fl) {\n\t\t\t\t\t\tvx[i][j] = x;\n\t\t\t\t\t\tvy[i][j] = y;\n\t\t\t\t\t\tvex[i][j] = qex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vx[i][j]==-1) {\n\t\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway.push_back({ vx[i][j],vy[i][j] + 101,vex[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tmk_uni(way);\n\tcout << 202 << \" \" << 200 + way.size() << endl;\n\trep(i, 100) {\n\t\tcout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n\t\tcout << i + 102 << \" \" << i + 103 << \" Y\" << endl;\n\t}\n\tfor (auto v : way) {\n\t\tcout << v[0] + 1 << \" \" << 303-v[1] << \" \" << v[2] << endl;\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nstruct edge{\n    int x,y,u;\n};\nvector<edge> conn;\nconst int MAX=12,INF=0x3f3f3f3f;\nint a,b,d[MAX][MAX],d_est[MAX][MAX],val[110][110],x_max,y_max;\nint update(int x,int y,int z){\n    if(x<0||y<0||z<0) return 0;\n    val[x][y]=z;\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++){\n            d_est[i][j]=min(d_est[i][j],val[x][y]+i*x+j*y);\n            if(d[i][j]>d_est[i][j]) return 0;\n        }\n    }\n    return 1;\n}\nint main(){\n    scanf(\" %d %d\",&a,&b);\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++) scanf(\" %d\",&d[i][j]);\n    }\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) val[i][j]=-1;\n    for(int i=0;i<=a;i++) for(int j=0;j<=b;j++) d_est[i][j]=INF;\n    for(int i=a;i>=1;i--){\n        if(b==1){\n            int x=0,y=0,z=0;\n            if(i==a) x=0,y=0,z=d[i][1]-x*i-y;\n            else y=0,x=d[i+1][1]-d[i][1],z=d[i][1]-x*i-y;\n            if(!update(x,y,z)){\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n        else for(int j=b;j>=2;j--){\n            int x=0,y=0,z=0;\n            if(i==a) x=0,y=d[i][j]-d[i][j-1],z=d[i][j]-x*i-y*j;\n            else y=d[i][j]-d[i][j-1],x=max(d[i+1][j]-d[i][j],d[i+1][j-1]-d[i][j-1]),z=d[i][j]-x*i-y*j;\n            //printf(\"%d %d %d %d %d\\n\",i,j,x,y,z);\n            if(!update(x,y,z)){\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Possible\\n\");\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) x_max=max(i,x_max),y_max=max(j,y_max);\n    }\n    for(int i=1;i<=x_max;i++) conn.push_back({i,i+1,-1});\n    for(int i=x_max+2;i<=x_max+y_max+1;i++) conn.push_back({i+1,i,-2});\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) conn.push_back({i+1,x_max+2+j,val[i][j]});\n    }\n    printf(\"%d %d\\n\",x_max+y_max+2,conn.size());\n    for(int i=0;i<conn.size();i++){\n        if(conn[i].u==-1) printf(\"%d %d X\\n\",conn[i].x,conn[i].y);\n        else if(conn[i].u==-2) printf(\"%d %d Y\\n\",conn[i].x,conn[i].y);\n        else printf(\"%d %d %d\\n\",conn[i].x,conn[i].y,conn[i].u);\n    }\n    printf(\"%d %d\\n\",1,x_max+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[1000], Y[1000], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 0, yy = 0;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      xx = std::max(xx, d[i][j] / i);\n      yy = std::max(yy, d[i][j] / j);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = 0;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      if (ans < 0 || ans > 100) continue;\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", cnt, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\n#define int long long\n\nconst int MOD = 1e9 + 7;\n\nint a, b;\nint d[50][50];\nint go[200][200];\n\nsigned main()\n{\n    //freopen(\"input_02.txt\", \"r\", stdin);\n    //freopen(\"output_02.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            int max_c = -1e9;\n            for (int x = 1; x <= a; x++)\n            {\n                for (int y = 1; y <= b; y++)\n                {\n                    int moved = i * x + j * y;\n                    int add = d[x][y] - moved;\n                    max_c = max(max_c, add);\n                }\n            }\n            if (max_c <= 100 && 0 <= max_c)\n            {\n                go[i][j] = max_c;\n            }\n            else\n            {\n                go[i][j] = 1e9;\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (x * i + go[i][j] + y * j < d[x][y])\n                    {\n                        go[i][j] = 1e9;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            int min_c = 1e9;\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (min_c > i * x + go[i][j] + j * y)\n                    {\n                        min_c = i * x + go[i][j] + j * y;\n                    }\n                }\n            }\n            if (min_c != d[x][y])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    int cnt = 0;\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j]) cnt++;\n        }\n    }\n    cout << 202 << \" \" << cnt << \"\\n\";\n    for (int i = 0; i < 100; i++)\n    {\n        cout << i + 1 << \" \" << i + 2 << \" \" << 'X' << \"\\n\";\n    }\n    for (int j = 0; j < 100; j++)\n    {\n        cout << 202 - j - 1 << \" \" << 202 - j << \" \" << 'Y' << \"\\n\";\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j])\n            {\n                cout << i + 1 << \" \" << 202 - j << \" \" << go[i][j] << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << 202 << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int kN = 202 + 5;\nint A, B, d[kN][kN];\nstd::vector<std::tuple<int, int, int>> edges;\nint n = 202;\nint S = 1, T = 202;\n\nstd::vector<std::pair<int, int>> graph[kN];\n\nbool validate()\n{\n    for (int x = 1; x <= A; ++ x) {\n        for (int y = 1; y <= B; ++ y) {\n            for (int i = 1; i <= n; ++ i) graph[i].clear();\n            for (auto t : edges) {\n                int a, b, c;\n                std::tie(a, b, c) = t;\n                graph[a].emplace_back(b, c == -1 ? x : c == -2 ? y : c);\n            }\n            std::vector<int> dist(n + 1, 101);\n            dist[S] = 0;\n            std::priority_queue<std::pair<int, int>> pq;\n            pq.emplace(0, S);\n            while (!pq.empty()) {\n                int u, tmp;\n                std::tie(tmp, u) = pq.top(); pq.pop();\n                if (-tmp != dist[u]) continue;\n                for (auto t : graph[u]) {\n                    int v, w;\n                    std::tie(v, w) = t;\n                    if (dist[v] > dist[u] + w) {\n                        dist[v] = dist[u] + w;\n                        pq.emplace(-dist[v], v);\n                    }\n                }\n            }\n            if (dist[T] != d[x][y]) return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &A, &B);\n    for (int i = 1; i <= A; ++ i)\n        for (int j = 1; j <= B; ++ j)\n            scanf(\"%d\", &d[i][j]);\n\n    for (int i = 1; i < 101; ++ i)\n        edges.emplace_back(i, i + 1, -1);\n    for (int i = 102; i < 202; ++ i)\n        edges.emplace_back(i, i + 1, -2);\n\n    for (int i = 0; i <= 100; ++ i) {\n        for (int j = 0; j <= 100; ++ j) {\n            int v = 0;\n            for (int x = 1; x <= A; ++ x)\n                for (int y = 1; y <= B; ++ y)\n                    v = std::max(v, d[x][y] - i * x - j * y);\n            edges.emplace_back(i + 1, T - j, v);\n        }\n    }\n    if (!validate())\n        return puts(\"Impossible\"), 0;\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", n, edges.size());\n    for (auto t : edges) {\n        int a, b, c;\n        std::tie(a, b, c) = t;\n        printf(\"%d %d \", a, b);\n        if (c < 0) putchar(\"YX\"[c + 2]);\n        else printf(\"%d\", c);\n        puts(\"\");\n    }\n    printf(\"%d %d\\n\", S, T);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint d[11][11];\nint w[102][102];\n\nint main(){\n  int a,b;\n  cin>>a>>b;\n  rep(i,a) rep(j,b) cin>>d[i][j];\n\n  rep(i,101) rep(j,101){\n    // i*x + j*y + w[i][j] >= d[k][l] for all k,l\n    w[i][j] = 0;\n    rep(k,a) rep(l,b) w[i][j] = max(w[i][j], d[k][l] - i*(k+1) - j*(l+1));\n  }\n\n  rep(k,a) rep(l,b){\n    int tmp = INF;\n    rep(i,101) rep(j,101){\n      tmp = min(tmp, w[i][j] + i*(k+1) + j*(l+1));\n    }\n    if(tmp != d[k][l]){\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Possible\\n\";\n  cout << \"202 10401\\n\";\n\n  rep(i,1,101) cout << i << \" \" << i+1 << \" X\\n\";\n  rep(i,102,202) cout << i << \" \" << i+1 << \" Y\\n\";\n  rep(i,101) rep(j,101){\n    cout << i+1 << \" \" << 202-j << \" \" << w[i][j] << \"\\n\";\n  }\n\n  cout << \"1 202\\n\";\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint A, B;\nint D[10][10];\nint f[101][101];\nint main(){\n    cin >> A >> B;\n\n    for (int i = 0; i < A; ++i) {\n        for (int j = 0; j < B; ++j) {\n            cin >> D[i][j];\n        }\n    }\n\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            int fmax = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    int tmp = max(0, D[x - 1][y - 1] - a * x - b * y);\n                    if (tmp > fmax) fmax = tmp;\n                }\n            }\n            f[a][b] = fmax;\n            //cout << fmax << \" \";\n        }\n        //cout << endl;\n    }\n\n    bool possible = true;\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            int dmin = 1000;\n            for (int a = 0; a <= 100; ++a) {\n                for (int b = 0; b <= 100; ++b) {\n                    int dist = a * x + b * y + f[a][b];\n                    if (dmin > dist) dmin = dist;\n                }\n            }\n            if (dmin != D[x - 1][y - 1]) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) break;\n    }\n\n    if (possible) {\n        cout << \"Possible\" << endl;\n        cout << 202 << \" \" << 101 * 101 + 200 << endl;\n        for (int i = 1; i <= 100; ++i) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n            cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n        }\n\n        for (int a = 0; a <= 100; ++a) {\n            for (int b = 0; b <= 100; ++b) {\n                cout << a + 1 << \" \" << b + 102 << \" \" << f[a][b] << endl;\n            }\n        }\n        cout << \"1 202\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * (i) + (k + 1) * (j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define Maxn 300\n#define Maxk 10\n#define Inf 0x3f3f3f3f\nint f[Maxn+5][Maxn+5];\nint d[Maxk+5][Maxk+5];\n//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 \n//d[x][y]=min{f[i][j]+i*x+j*y}\n//f[i][j]=max{d[x][y]-i*x-j*y}\nint mx(int a,int b){\n\treturn a>b?a:b;\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nstruct Edge{\n\tint u,v,w;\n}edge[Maxn*Maxn+5];\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now;\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tnow=Inf;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tnow=mn(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint tot=1;\n\tputs(\"Possible\");\n\tint len=0;\n\tfor(int i=1;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-1;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=202;\n\ttot++;\n\tedge[++len].u=1;\n\tedge[len].v=tot;\n\tedge[len].w=-2;\n\tfor(int i=2;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-2;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=202;\n\tedge[len].w=-2;\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tedge[++len].u=i+1;\n\t\t\tedge[len].v=tot-j+1;\n\t\t\tedge[len].w=f[i][j];\n\t\t}\n\t}\n\tprintf(\"202 %d\\n\",len);\n\tfor(int i=1;i<=len;i++){\n\t\tprintf(\"%d %d \",edge[i].u,edge[i].v);\n\t\tif(edge[i].w==-1){\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse if(edge[i].w==-2){\n\t\t\tputs(\"Y\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",edge[i].w);\n\t\t}\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tcout<<M+1<<' '<<M+2<<' '<<0<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) if(i<M||j<M) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        cout << \"Possible\" << endl;\n        cout << n << \" \" << edges.size() << endl;\n        each(e, edges) {\n            cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nmain() {\n    INT(n, m);\n    VV(int, a, n, m);\n    int N = 105;\n    vv(int, d, N + 1, N + 1);\n    vv(bool, ok, n, m);\n    rep(x, N + 1) {\n        rep(y, N + 1) {\n            rep(i, n) rep(j, m) { chmax(d[x][y], a[i][j] - (i + 1) * x - (j + 1) * y); }\n            rep(i, n) rep(j, m) if(a[i][j] == d[x][y] + (i + 1) * x + (j + 1) * y) ok[i][j] = true;\n            // cout << d[x][y] << \" \";\n        }\n        // cout << endl;\n    }\n    rep(i, n) rep(j, m) {\n        if(!ok[i][j]) {\n            cout << \"Impossible\\n\";\n            exit(0);\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << N * 2 + 1 << \" \" << N * 2 + (N + 1) * (N + 1) << endl;\n    rep2(i, 1, N) cout << i << \" \" << i + 1 << \" \" << 'X' << endl;\n    rep2(i, N + 1, N * 2) cout << i << \" \" << i + 1 << \" \" << 'Y' << endl;\n    rep(i, N + 1) rep(j, N + 1) {\n        int t = 1 + i, s = N * 2 + 1 - j;\n        cout << t << \" \" << s << \" \" << d[i][j] << endl;\n    }\n    cout << 1 << \" \" << N * 2 + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=101;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,2*maxm-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n //https://pitsbuffersolution.com/compro/atcoder/arc089e.php\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint A,B;\nint d[11][11];\nconst int C = 101;\nint S = 1 , T = 2 * C;\nint N = T , M = 2 * (C-1) + C * C;\nint e[C][C];\n \nint main(){\n\tcin >> A >> B;\n\trepp(i,1,A+1) repp(j,1,B+1) cin >> d[i][j];\n\trepp(i,0,C) repp(j,0,C){\n\t\trepp(x,1,A+1) repp(y,1,B+1) e[i][j] = max(e[i][j] , d[x][y]-i*x-j*y);\n\t}\n\trepp(x,1,A+1) repp(y,1,B+1){\n\t\tint z = C;\n\t\trepp(i,0,C) repp(j,0,C) z = min(z,e[i][j]+i*x+j*y);\n\t\tif(z != d[x][y]) return cout << \"Impossible\" << endl , 0;\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << N << ' ' << M << endl;\n\trepp(i,1,C){\n\t\tcout << i << ' ' << i+1 << \" X\" << endl;\n\t\tcout << C+i << ' ' << C+i+1 << \" Y\" << endl;\n\t}\n\trepp(i,0,C) repp(j,0,C) cout << i+1 << ' ' << N-j << ' ' << e[i][j] << endl;\n\tcout << S << ' ' << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\nconstexpr int V = 2 * (d_max + 1);\nconstexpr int S = 0, T = V - 1;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  std::array<std::array<int, d_max + 1>, d_max + 1> cost{};\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      for (int a: range(0, A + 1)) {\n        for (int b: range(0, B + 1)) {\n          chmax(cost[a][b], dist[i][j] - (i + 1) * a - (j + 1) * b);\n        }\n      }\n    }\n  }\n  std::array<std::pair<int, int>, d_max> Xs{};\n  std::array<std::pair<int, int>, d_max> Ys{};\n  for (int i: range(0, d_max)) {\n    Xs[i] = { i, i + 1 };\n    Ys[i] = { V - i - 2, V - i - 1 };\n  }\n  auto calc = [&](int x, int y) {\n    std::array<std::vector<std::pair<int, int>>, V> graph{};\n    for (int i: range(0, d_max)) {\n      graph[Xs[i].first].emplace_back(Xs[i].second, x);\n      graph[Ys[i].first].emplace_back(Ys[i].second, y);\n    }\n    for (int i: range(0, d_max + 1)) {\n      for (int j: range(0, d_max + 1)) {\n        if (cost[i][j] <= d_max) {\n          graph[i].emplace_back(V - j - 1, cost[i][j]);\n        }\n      }\n    }\n    std::array<int, V> length{};\n    length.fill(d_max);\n    length[S] = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(length[S], S);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > length[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(length[e.first], length[v] + e.second)) {\n          que.emplace(length[e.first], e.first);\n        }\n      }\n    }\n    return length[T];\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (dist[i][j] != calc(i + 1, j + 1)) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  int E = 2 * d_max;\n  for (const auto &arr: cost) {\n    for (auto x: arr) {\n      if (x <= d_max) {\n        ++E;\n      }\n    }\n  }\n  std::cout << V << ' ' << E << '\\n';\n  for (auto e: Xs) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" X\\n\";\n  }\n  for (auto e: Ys) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (cost[i][j] <= d_max) {\n        std::cout << i + 1 << ' ' << V - j << ' ' << cost[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << S + 1 << ' ' << T + 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nstruct edge { int v, w; };\nconst int INF = INT_MAX / 2;\nconst int MOD = 1e9 + 7;\nconst ll e18 = 1e18;\n\nvoid f(int u, int v, int w) {\n\tif (w == -1)\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << 'X' << endl;\n\telse if (w == -2)\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << 'Y' << endl;\n\telse\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << w << endl;\n}\n\nint main() {\n\tint X, Y; cin >> X >> Y;\n\tvector<vector<int>> a(X + 1, vector<int>(Y + 1));\n\tfor (int x = 1; x <= X; x++)\n\t\tfor (int y = 1; y <= Y; y++)\n\t\t\tcin >> a[x][y];\n\tvector<vector<int>> l(101, vector<int>(101));\n\trep(i, 101) rep(j, 101) {\n\t\tint ma = 0;\n\t\tfor (int x = 1; x <= X; x++)\n\t\t\tfor (int y = 1; y <= Y; y++)\n\t\t\t\tma = max(ma, a[x][y] - i * x - j * y);\n\t\tl[i][j] = min(ma, 100);\n\t}\n\tfor (int x = 1; x <= X; x++)\n\t\tfor (int y = 1; y <= Y; y++) {\n\t\t\tint mi = INF;\n\t\t\trep(i, 101) rep(j, 101)\n\t\t\t\tmi = min(mi, i * x + j * y + l[i][j]);\n\t\t\tif (mi != a[x][y]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << ' ' << 10401 << endl;\n\trep(i, 100) f(i, i + 1, -1);\n\trep(j, 100) f(101 + j, 101 + j + 1, -2);\n\trep(i, 101) rep(j, 101) f(i, 201 - j, l[i][j]);\n\tcout << 1 << ' ' << 202 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint A, B;\nint D[11][11];\nint U[111][111];\nint idx[111][111];\nint cnt;\nvoid add(int s, int t) {\n    if (idx[s][t] == 0) idx[s][t] = cnt++;\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &A, &B);\n    REP (i, A) REP (j, B) scanf(\"%d\", &D[i][j]);\n\n    REP (i, A) REP (j, B) REP (s, 101) REP (t, 101) {\n\tamax(U[s][t], D[i][j] - s*(i+1) - t*(j+1));\n    }\n\n    cnt = 1;\n    add(0, 0);\n    REP (i, A) REP (j, B) {\n\tREP (s, 101) REP (t, 101) {\n\t    if (s*(i+1) + t*(j+1) + U[s][t] == D[i][j]) {\n\t\tadd(s, t);\n\t\tgoto BREAK;\n\t    }\n\t}\n\n\tputs(\"Impossible\");\n\treturn;\nBREAK:\n\t;\n    }\n\n    for (int s=101; s--;) for (int t=101; t--;) if (idx[s][t]) {\n\tif (s == 0 && t == 0) continue;\n\tif (s && idx[s-1][t]) continue;\n\tif (t && idx[s][t-1]) continue;\n\tif (s < t) add(s, t-1);\n\telse add(s-1, t);\n    }\n\n    puts(\"Possible\");\n    VI from, to, cst;\n    REP (s, 101) REP (t, 101) {\n\tif (idx[s][t]) {\n\t    if (idx[s][t+1]) {\n\t\tfrom.push_back(idx[s][t]);\n\t\tto.push_back(idx[s][t+1]);\n\t\tcst.push_back(-2);  // Y\n\t    }\n\t    if (idx[s+1][t]) {\n\t\tfrom.push_back(idx[s][t]);\n\t\tto.push_back(idx[s+1][t]);\n\t\tcst.push_back(-1);  // X\n\t    }\n\t    from.push_back(idx[s][t]);\n\t    to.push_back(cnt);\n\t    cst.push_back(U[s][t]);\n\t}\n    }\n\n    printf(\"%d %d\\n\", cnt, (int)from.size());\n    REP (i, from.size()) {\n\tprintf(\"%d %d \", from[i], to[i]);\n\tif (cst[i] == -2) puts(\"Y\");\n\telse if (cst[i] == -1) puts(\"X\");\n\telse printf(\"%d\\n\", cst[i]);\n    }\n    printf(\"1 %d\\n\", cnt);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define forsn(i,s,n) for (int i = (s);i < (int)(n);i++)\n#define forn(i,n) forsn(i,0,n)\n#define dforsn(i,s,n) for (int i = (n-1);i >= (int)(s);i--)\n#define dforn(i,n) dforsn(i,0,n)\n#define all(v) (v).begin(), (v).end()\n#define F first\n#define S second\n\nint d[10][10];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint a, b; cin >> a >> b;\n\tforn(i,a) forn(j,b) cin >> d[i][j];\n\t\n\tbool broken = false;\n\tforn(i,a) forn(j,b) {\n\t\tbool nowEqual = false;\n\t\tbroken |= ((i && d[i][j] < d[i - 1][j]) || (j && d[i][j] < d[i][j - 1]) || (nowEqual && d[i][j] != d[i][j - 1]));\n\t\tnowEqual |= (d[i][j] == d[i][j - 1]);\n\t}\n\tforn(j,b) forn(i,a) {\n\t\tbool nowEqual = false;\n\t\tbroken |= ((i && d[i][j] < d[i - 1][j]) || (j && d[i][j] < d[i][j - 1]) || (nowEqual && d[i][j] != d[i - 1][j]));\n\t\tnowEqual |= (d[i][j] == d[i - 1][j]);\n\t}\n\t\n\tif (broken) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\t\n\t\tint n = a * b;\n\t\tcout << 2 * n + 2 << ' ' << 3 * n << '\\n';\n\t\tint done = 0;\n\t\tforn(i,a) forn(j,b) {\n\t\t\tcout << 1 << ' ' << 2 + 2 * done << ' ' << d[i][j] - (i + j) << '\\n';\n\t\t\tcout << 2 + 2 * done << ' ' << 3 + 2 * done << ' ' << 'X' << '\\n';\n\t\t\tcout << 3 + 2 * done << ' ' << 2 * n + 2 << ' ' << 'Y' << '\\n';\n\t\t}\n\t\t\n\t\tcout << 1 << ' ' << 2 * n + 2 << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint a[11][11];\nint d[101][101];\n\nint main() {\n\tint i, j, k, l, m, n, t;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) scanf(\"%d\", &a[i][j]);\n\tfor (i = 0; i <= 100; i++) for (j = 0; j <= 100; j++) {\n\t\tt = -1;\n\t\tfor (k = 1; k <= n; k++) for (l = 1; l <= m; l++) {\n\t\t\tif (a[k][l] - i * k - j * l >= t) {\n\t\t\t\tt = a[k][l] - i * k - j * l;\n\t\t\t}\n\t\t}\n\t\td[i][j] = t;\n\t}\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) {\n\t\tt = 999;\n\t\tfor (k = 0; k <= 100; k++) for (l = 0; l <= 100; l++) {\n\t\t\tif (d[k][l] >= 0 && d[k][l] + i * k + j * l <= t) {\n\t\t\t\tt = d[k][l] + i * k + j * l;\n\t\t\t}\n\t\t}\n\t\tif (t != a[i][j]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%d %d X\", i + 1, i + 2);\n\t\tprintf(\"%d %d Y\", 201 - i, 202 - i);\n\t}\n\tfor (i = 0; i <= 100; i++) for (j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, 202 - j, d[i][j] < 0 ? 100 : d[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,3)\n\t\tRPT(j,0,3)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\t\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 350;\nconst int INF = 1<<30;\n\nint a, b, s, t, d[N][N], f[N][N];\n\ninline void ck_min( int &a, int b ) { if( a > b ) a = b; }\ninline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\ninline bool check( int x, int y, int val )\n{\n\tint res = INF;\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\t\n//\tprintf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n\treturn res == val;\n}\n\nint main()\n{\n\tmemset( f, -1, sizeof( f ) );\n\t\n\tscanf( \"%d%d\", &a, &b );\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\n\t\t\tscanf( \"%d\", &d[i][j] );\n\t\t\t\n\ts = 201, t = 202; \n\t// s --> 1 --> 2 --> ... --> 100\n\t// t <-- 101 <-- 102 <-- ... <-- 200\n\t\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t{\n\t\t\tint tmp = -INF;\n\t\t\tfor( int _a = 1; _a <= a; _a ++ )\n\t\t\t\tfor( int _b = 1; _b <= b; _b ++ )\n\t\t\t\t\tck_max( tmp, d[_a][_b] - i*_a - j*_b );\t\n\t\t\tf[i][j] = tmp; \n\t\t\tif( f[i][j] < 0 ) break;\n//\t\t\tprintf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n\t\t}\n\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\t\n\t\t\tif( !check( i, j, d[i][j] ) ) {\n\t\t\t\tprintf( \"Impossible\\n\" ); return 0;\n\t\t\t} \n\t\t\t\n\tprintf( \"Possible\\n\" );\n\tfor( int i = 1; i < 100; i ++ )\n\t\tprintf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\tprintf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\tprintf( \"%d %d\\n\", s, t );\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 0; i < 100; i++) {\n        adj[ X(i) ].push_back(pii(X(i + 1), -1));\n    }\n    for(int i = 100; i >= 1; i--) {\n        adj[ Y(i) ].push_back(pii(Y(i - 1), -2));\n    }\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0 || 100 < c) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"%d\\n\", V);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                if(w == -1) printf(\"%d %d X\\n\", u + 1, v + 1);\n                else if(w == -2) printf(\"%d %d Y\\n\", u + 1, v + 1);\n                else printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ninline void check_max(int a,int &b){if(a>b)b=a;}\ninline void check_min(int a,int &b){if(a<b)b=a;}\n\nnamespace YouQu____o_o________nyg_tai_qiang_le\n{\n\ttypedef std::pair<int,int> pii;\n\tconst int N=12,M=202;\n\n\tstruct outputer\n\t{\n\t\tint n,m,S,T;\n\t\tint w[M*M];\n\t\tpii E[M*M];\n\t\tvoid reset(int n_){n=n_,m=0;}\n\t\tvoid insert(int u,int v,int k){E[++m]=pii(u,v);w[m]=k;}\n\t\tvoid output()\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",n+1,m);\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d \",E[i].first+1,E[i].second+1);\n\t\t\t\tif(w[i]==-1)printf(\"X\\n\");\n\t\t\t\telse if(w[i]==-2)printf(\"Y\\n\");\n\t\t\t\telse printf(\"%d\\n\",w[i]);\n\t\t\t}\n\t\t\tprintf(\"%d %d\\n\",S+1,T+1);\n\t\t}\n\t}d;\n\n#define idx(p) (p)\n#define idy(p) (201-(p))\n\n\tint dis[N][N],G[M][M];\n\tint A,B,lim;\n\n\tint calc(int x,int y)\n\t{\n\t\tint ret=23333;\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\tcheck_min(x*i+y*j+G[i][j],ret);\n\t\treturn ret;\n\t}\n\n\tvoid solve()\n\t{\n\t\tlim=100;\n\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tscanf(\"%d\",&dis[i][j]);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t{\n\t\t\t\tG[i][j]=0;\n\t\t\t\tfor(int x=1;x<=A;x++)\n\t\t\t\t\tfor(int y=1;y<=B;y++)\n\t\t\t\t\t\tcheck_max(dis[x][y]-x*i-y*j,G[i][j]);\n\t\t\t}\n\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tif(calc(i,j)!=dis[i][j]){printf(\"Impossilbe\\n\");return;}\n\n\t\tprintf(\"Possible\\n\");\n\n\t\td.reset(idy(0));d.S=idx(0),d.T=idy(0);\n\n\t\tfor(int i=0;i<lim;i++)d.insert(idx(i),idx(i+1),-1);\n\t\tfor(int i=lim;i;i--)d.insert(idy(i),idy(i-1),-2);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\td.insert(idx(i),idy(j),G[i][j]);\n\n\t\td.output();\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"out\",\"w\",stdout);\n\tYouQu____o_o________nyg_tai_qiang_le::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n \nint c[12][12],g[12][12];\nint u[1200000],v[1200000],w[1200000];\nint i,j,k,m,n,x,y,z;\nbool b;\n \nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&g[i][j]);\n\tfor (x=0;x<=100;x++)\n\t\tfor (y=0;y<=100;y++)\n\t\t\tfor (z=0;z<=100;z++)\n\t\t\t{\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z<g[i][j])\n\t\t\t\t\t\t\tb=true;\n\t\t\t\tif (b)\n\t\t\t\t\tcontinue;\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z==g[i][j])\n\t\t\t\t\t\t\tb=true,c[i][j]=1;\n\t\t\t\tif (! b)\n\t\t\t\t\tcontinue;\n\t\t\t\tk++,u[k]=x,v[k]=y,w[k]=z;\n\t\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tif (! c[i][j])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,k+200);\n\tfor (i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor (i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor (i=1;i<=k;i++)\n\t\tprintf(\"%d %d %d\\n\",1+u[i],202-v[i],w[i]);\n\tprintf(\"%d %d\\n\",1,202);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0,fff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k&&flag[i][j])f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1,fff=1;\n\t\t\t\tif (fff)ii=i,jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\n\nint main(){\n//\tfreopen(\"graphxy.in\",\"r\", stdin);\n//\tfreopen(\"graphxy.out\",\"w\", stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10198\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i+1 << \" \" << 200-j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tfor(int i=1; i<100; i++) cout << i << \" \" << i+1 << \" X\\n\";\n\tfor(int i=101; i<200; i++) cout << i << \" \" << i+1 << \" Y\\n\";\n\tcout << \"1 200\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nbool P[101][101][101]; // X, Y, 1;\nstruct e {\n    int from, to, cost;\n};\n\nstruct edge {int to; ll cost;};\nstruct node {int pos; ll cost;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nvector<ll> dijkstra(vector<vector<edge>> &G, int root){\n    vector<ll> ret(G.size(), inf);\n    priority_queue<node> pq;\n    pq.push({root, 0});\n    while (!pq.empty()) {\n        node t = pq.top();\n        pq.pop();\n        \n        if (ret[t.pos] == inf) ret[t.pos] = t.cost;\n        else continue;\n        \n        for (edge e : G[t.pos]) {\n            pq.push({e.to, t.cost + e.cost});\n        }\n    }\n    return ret;\n}\n\n\nconst int N = 100;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> D(A, vector<int> (B));\n    rep(i, A) rep(j, B) cin >> D[i][j];\n    rep(i, N) rep(j, N) rep(k, 101) P[i][j][k] = 1;\n    rep(i, N) rep(j, N) rep(k, 101){\n        rep(a, A) rep(b, B){\n            if(D[a][b] > (a + 1) * i + (b + 1) * j + k) P[i][j][k] = 0;\n        }\n    }\n    \n    vector<e> ret;\n    rep(i, N) rep(j, N){\n        rep(k, 101) {\n            if(P[i][j][k]){\n                ret.pb({i, N * 2 + 1 - j, k});\n                break;\n            }\n        }\n    }\n    \n    rep(a, A) rep(b, B){\n        vector<vector<edge>> G(N * 2 + 2);\n        rep(i, N) G[i].pb({i + 1, a + 1});\n        rep(i, N) G[i + N + 1].pb({i + N + 2, b + 1});\n        for(auto e: ret) {\n            G[e.from].pb({e.to, e.cost});\n        }\n        \n        auto dist = dijkstra(G, 0);\n        if(dist[N * 2 + 1] != D[a][b]){\n            output(\"Impossible\");\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << N * 2 + 2 << \" \" << N * 2 + (int)ret.size() << endl;\n    \n    rep(i, N){\n        cout << i + 1 << \" \" << i + 2 << \" \" << \"X\" << endl;\n    }\n    rep(i, N){\n        cout << i + N + 2 << \" \" << i + N + 3 << \" \" << \"Y\" << endl;\n    }\n    \n    for(auto e: ret) {\n        cout << e.from + 1 << \" \" << e.to + 1 << \" \" << e.cost << endl;\n    }\n    cout << 1 << \" \" << N * 2 + 2 << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<vector>\n#include<stack>\n#include<cmath>\n#include<random>\n//This code is written by Itst\nusing namespace std;\n\ninline int read()\n{\n\tint a = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c != EOF)\n\t\tc = getchar();\n\tif(c == EOF)\n\t\texit(0);\n\twhile(isdigit(c))\n\t{\n\t\ta = a * 10 + c - 48;\n\t\tc = getchar();\n\t}\n\treturn f ? -a : a;\n}\n\nint d[12][12] , f[107][107];\n\nsigned main()\n{\n\tint A = read() , B = read();\n\tfor(int i = 1 ; i <= A ; ++i)\n\t\tfor(int j = 1 ; j <= B ; ++j)\n\t\t\td[i][j] = read();\n\tfor(int i = 0 ; i <= 100 ; ++i)\n\t\tfor(int j = 0 ; j <= 100 ; ++j)\n\t\t\tfor(int p = 1 ; p <= A ; ++p)\n\t\t\t\tfor(int q = 1 ; q <= B ; ++q)\n\t\t\t\t\tf[i][j] = max(f[i][j] , d[p][q] - i * p - j * q);\n\tfor(int i = 1 ; i <= A ; ++i)\n\t\tfor(int j = 1 ; j <= B ; ++j)\n\t\t{\n\t\t\tint minN = 1e9;\n\t\t\tfor(int p = 0 ; p <= 100 ; ++p)\n\t\t\t\tfor(int q = 0 ; q <= 100 ; ++q)\n\t\t\t\t\tminN = min(minN , f[p][q] + p * i + q * j);\n\t\t\tif(minN != d[i][j])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i = 1 ; i <= 100 ; ++i)\n\t\tprintf(\"%d %d X\\n\" , i , i + 1);\n\tfor(int i = 102 ; i < 202 ; ++i)\n\t\tprintf(\"%d %d Y\\n\" , i , i + 1);\n\tfor(int i = 0 ; i <= 100 ; ++i)\n\t\tfor(int j = 0 ; j <= 100 ; ++j)\n\t\t\tprintf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,inf);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tconst int v=150;\n\t\n\tint a,b;cin>>a>>b;\n\t\n\tvvc<int> lw(v,vi(v,0));\n\tvvc<int> buf(a+1,vi(b+1,0));\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint d;cin>>d;\n\t\tbuf[x][y]=d;\n\t\trep(i,v)rep(j,v){\n\t\t\tchmax(lw[i][j],d-i*x-(v-1-j)*y);\n\t\t}\n\t}\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint n=v*2;\n\t\tstruct E{int to,cost;};\n\t\tvvc<E> g(n);\n\t\trep(i,v-1)\n\t\t\tg[i].pb(E{i+1,x});\n\t\trep(i,v-1)\n\t\t\tg[v+i].pb(E{v+i+1,y});\n\t\trep(i,v)rep(j,v)\n\t\t\tg[i].pb(E{v+j,lw[i][j]});\n\t\tint d=dijkstra(g,0)[n-1];\n\t\tif(d!=buf[x][y]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\t\n\tint n=v*2;\n\tprint(n,2);\n\tprint((n-1)*2+v*v);\n\trep(i,v-1){\n\t\tcout<<i+1<<\" \"<<i+1+1<<\" X\\n\";\n\t}\n\trep(i,v-1){\n\t\tcout<<v+i+1<<\" \"<<v+i+1+1<<\" Y\\n\";\n\t}\n\trep(i,v)rep(j,v)\n\t\tcout<<i+1<<\" \"<<v+j+1<<\" \"<<lw[i][j]<<\"\\n\";\n\tcout<<1<<\" \"<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t//\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n/*\trep0(i,3){\n\t\trep0(j,3) cerr<<mx[i][j]<<\" \";\n\t\tcerr<<endl;\n\t}*/\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx,idy;\n\t\trep0(x,101){\n\t\t\trep0(y,101){\n\t\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\t\tidx=x,idy=y;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tused[idx][idy]=true;\n\t\tadd(!idx?s:idx,!idy?t:idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\",m);\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n//\tfreopen(\"graphxy.in\",\"r\", stdin);\n//\tfreopen(\"graphxy.out\",\"w\", stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<100; a++)\n\t\tfor(int b=0; b<100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<100; x++){\n\t\t\t\tfor(int y=0; y<100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tint m=0;\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i+1 << \" \" << 101+j << \" \" << ans[i][j] << \"\\n\";\n\t\tm+=100;\n\t}\n\tm+=100+100;\n\tassert(m == 10200);\n\tfor(int i=0; i<99; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i=100; i<199; i++) cout << i+1 << \" \" << i+2 << \" Y\\n\";\n\tcout << \"1 200\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 210;\nint d[N][N];\n\nstruct Edge {\n    int u, v;\n    string c;\n};  \n\nint f[N][N];\n\nint g[N][N];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int A, B;\n    cin >> A >> B;\n    for (int i = 1; i <= A; ++i)\n        for (int j = 1; j <= B; ++j)\n            cin >> d[i][j];    \n\n    int S = 1;\n    int T = 2;\n    int ptr = 3;\n    vector <Edge> ans;\n\n    int lx = ptr;\n    ans.app({S, ptr, \"X\"});\n    ++ptr;\n    for (int i = 1; i <= 100; ++i) {\n        ans.app({ptr - 1, ptr, \"X\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"X\"});\n    int rx = ptr - 1;\n\n    \n    int ly = ptr;\n    ans.app({S, ptr, \"Y\"});\n    ++ptr;\n    for (int i = 1; i <= 100; ++i) {\n        ans.app({ptr - 1, ptr, \"Y\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"Y\"});\n    int ry = ptr - 1;\n    \n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) {\n            for (int x = 0; x <= 100; ++x) {\n                for (int y = 0; y <= 100; ++y) {\n\n                    int have = x * i + y * j;\n                    if (have < d[i][j]) {\n                        f[x][y] = max(f[x][y], d[i][j] - have);\n                    }   \n                \n                }   \n            }   \n        }   \n    }   \n\n    for (int x = 0; x <= 100; ++x) {\n        for (int y = 0; y <= 100; ++y) {\n\n            int u = lx + x - 1;\n            if (x == 0)\n                u = S;\n\n            int v = ry - y + 1;\n            if (y == 0)\n                v = T;\n\n            ans.app({u, v, to_string(f[x][y])});\n        }   \n    }   \n\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            const int INF = 1e9+7;\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    g[i][j] = INF;\n            for (auto e : ans) {\n                if (e.c == \"X\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], x);\n                }   \n                else if (e.c == \"Y\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], y);\n                }\n                else {\n                    g[e.u][e.v] = min(g[e.u][e.v], stoi(e.c));\n                }   \n            }\n            \n            for (int k = 0; k < N; ++k)\n                for (int u = 0; u < N; ++u)\n                    for (int v = 0; v < N; ++v)\n                        g[u][v] = min(g[u][v], g[u][k]+g[k][v]);       \n\n            if (g[S][T] != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                exit(0);\n            }   \n        }\n    }    \n\n    cout << \"Possible\" << endl;\n    for (auto e : ans)\n        cout << e.u << ' ' << e.v << ' ' << e.c << endl;\n    cout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dx[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint A, B;\nint d[11][11];\nint f[101][101];\n\nsigned main() {\n    cin >> A >> B;\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            cin >> d[x][y];\n        }\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            f[a][b] = 0;\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int cur = LLONG_MAX;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    cur = min(cur, x * a + y * b + f[a][b]);\n                }\n            }\n            if (d[x][y] != cur) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 101 * 101 << endl;\n    for (int i = 1; i <= 100; i++) {\n        cout << i << \" \" << i + 1 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            cout << a + 1 << \" \" << b + 102 << \" \" << f[a][b] << endl;\n        }\n    }\n    cout << 1 << \" \" << 202 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\n// struct edge {\n//   ll v, dist;\n// };\n//\n// struct state {\n//   ll v, cost;\n//\n//   bool operator>(const state s) const {\n//     return cost > s.cost;\n//   }\n// };\n//\n// vector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n//   vector<ll> dp(E.size(), INF);\n//   priority_queue<state, vector<state>, greater<state> > q;\n//   q.push((state) { S, 0 });\n//\n//   while(!q.empty()) {\n//     ll v = q.top().v, cost = q.top().cost;\n//     q.pop();\n//\n//     if(dp[v] <= cost) continue;\n//     dp[v] = cost;\n//\n//     REP(i, 0, E[v].size()) {\n//       ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n//       if(dp[nv] > ncost) q.push((state) { nv, ncost });\n//     }\n//   }\n//\n//   return dp;\n// }\n\nint main(void) {\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct data { ll x, y, z; };\n  vector<data> e;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(x, 0, A + 1) REP(y, 0, B + 1) REP(z, 0, 100 + 1) {\n    bool f = true;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      f = f && D[a][b] <= v;\n    }\n    if(!f) continue;\n    ll cnt = 0;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      if(!ok[a][b] && D[a][b] == v) {\n        ok[a][b] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) e.push_back((data) { x, y, z });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  ll N = 22, M = 20 + e.size(), S = 1, T = 12;\n  cout << \"Possible\" << endl;\n  cout << N << \" \" << M << endl;\n  REP(i, S, S + 10) cout << i << \" \" << i + 1 << \" X\" << endl;\n  REP(i, T, T + 10) cout << i + 1 << \" \" << i << \" Y\" << endl;\n  REP(i, 0, e.size()) cout << S + e[i].x << \" \" << T + e[i].y << \" \" << e[i].z << endl;\n  cout << S << \" \" << T << endl;\n\n  // REP(x, 1, A + 1) REP(y, 1, B + 1) {\n  //   vector< vector<edge> > E(N + 1);\n  //   REP(i, S, S + 10) E[i].push_back((edge) { i + 1, x });\n  //   REP(i, T, T + 10) E[i + 1].push_back((edge) { i, y });\n  //   REP(i, 0, e.size()) E[S + e[i].x].push_back((edge) { T + e[i].y, e[i].z });\n  //   ll d = dijkstra(E, S)[T];\n  //   assert(d == D[x][y]);\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?(x==0?S:(x==100?T:101+x)):(x==0?S:(x==100?T:1+x)))\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint c[12][12],g[12][12];\nint u[1200000],v[1200000],w[1200000];\nint i,j,k,m,n,x,y,z;\nbool b;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&g[i][j]);\n\tfor (x=0;x<=100;x++)\n\t\tfor (y=0;y<=100;y++)\n\t\t\tfor (z=0;z<=100;z++)\n\t\t\t{\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z<g[i][j])\n\t\t\t\t\t\t\tb=true;\n\t\t\t\tif (b)\n\t\t\t\t\tcontinue;\n\t\t\t\tb=false;\n\t\t\t\tfor (i=1;i<=n;i++)\n\t\t\t\t\tfor (j=1;j<=m;j++)\n\t\t\t\t\t\tif (x*i+y*j+z==g[i][j])\n\t\t\t\t\t\t\tb=true,c[i][j]=1;\n\t\t\t\tif (! b)\n\t\t\t\t\tcontinue;\n\t\t\t\tk++,u[k]=x,v[k]=y,w[k]=z;\n\t\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tfor (j=1;j<=m;j++)\n\t\t\tif (! c[i][j])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,k+200);\n\tfor (i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor (i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor (i=1;i<=k;i++)\n\t\tprintf(\"%d %d %d\\n\",1+u[i],202-v[i],w[i]);\n\tprintf(\"%d %d\\n\",1,202);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    constexpr int max_c = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i + 1], ys[i], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, bool());\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, max_d + 1) REP (j, max_d + 1) if (i + j <= max_d) {\n        int c = 0;\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1);\n            chmax(c, d[x][y] - f);\n        }\n        if (c > max_c) continue;\n        int_edge.emplace_back(xs[i], ys[j], c);\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1) + c;\n            assert (d[x][y] <= f);\n            if (f == d[x][y]) {\n                used[x][y] = true;\n            }\n        }\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s << ' ' << t << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint d[20][20];\nint t[110][110];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<110;i++){\n\t\tfor(int j=0;j<110;j++){\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tt[i][j]=max(t[i][j],d[k][l]-(k+1)*i-(l+1)*j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint v=mod;\n\t\t\tfor(int k=0;k<110;k++)for(int l=0;l<110;l++){\n\t\t\t\tv=min(v,t[k][l]+k*(i+1)+l*(j+1));\n\t\t\t}\n\t\t\tif(v!=d[i][j]){\n\t\t\t\tprintf(\"Impossible\\n\");return 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",220,109+109+110*110);\n\tfor(int i=0;i<109;i++){\n\t\tprintf(\"%d %d X\\n\",i+1,i+2);\n\t}\n\tfor(int i=0;i<109;i++){\n\t\tprintf(\"%d %d Y\\n\",i+111,i+112);\n\t}\n\tfor(int i=0;i<110;i++)for(int j=0;j<110;j++){\n\t\tprintf(\"%d %d %d\\n\",i+1,220-j,t[i][j]);\n\t}\n\tprintf(\"1 220\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 102;\n    vector<vector<li>> offset(size, vector<li>(size, -1114));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int edge_count = 220;\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            edge_count += 1;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 221 << \" \" << edge_count << endl;\n    for (int i = 0; i < 110; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 111 << \" \" << i + 112 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            cout << xuse + 1 << \" \" << 221 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 221\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nvoid ng(){\n\tcout << \"Impossible\" << endl;\n\texit(0);\n}\n\n#define INF (1<<29)\n\nint a, b;\nint d[108][108];\nint c[108][108];\n\nint main(){\n\tcin >> a >> b;\n\tfor(int i = 1;i <= a;i++){\n\t\tfor(int j = 1;j <= b;j++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0;i <= 100;i++){\n\t\tfor(int j = 0;j <= 100;j++){\n\t\t\tfor(int x = 1;x <= a;x++){\n\t\t\t\tfor(int y = 1;y <= b;y++){\n\t\t\t\t\tc[i][j] = max(c[i][j], d[x][y] - x*i - y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int x = 1;x <= a;x++){\n\t\tfor(int y = 1;y <= b;y++){\n\t\t\tint dist = INF;\n\t\t\tfor(int i = 0;i <= 100;i++){\n\t\t\t\tfor(int j = 0;j <= 100;j++){\n\t\t\t\t\tdist = min(dist, c[i][j] + x*i+y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist != d[x][y])ng();\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << 101*101 + 200 << endl;\n\tfor(int i = 0;i <= 100;i++){\n\t\tint u = i+1;\n\t\tfor(int j = 0;j <= 100;j++){\n\t\t\tint v = j + 102;\n\t\t\tcout << u << \" \" << v << \" \" << c[i][j] << endl;\n\t\t}\n\t}\n\tfor(int i = 0;i < 100;i++){\n\t\tint u = i + 1;\n\t\tint v = u + 1;\n\t\tcout << u << \" \" << v << \" \" << \"X\" << endl;\n\t}\n\t\n\tfor(int i = 0;i < 100;i++){\n\t\tint v = i + 102;\n\t\tint u = v + 1;\n\t\tcout << u << \" \" << v << \" \" << \"Y\" << endl;\n\t}\n\tcout << 1 << \" \" << 102 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nstruct edge { int v, w; };\nconst int INF = INT_MAX / 2;\nconst int MOD = 1e9 + 7;\nconst ll e18 = 1e18;\n\nvoid f(int u, int v, int w) {\n\tif (w == -1)\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << 'X' << endl;\n\telse if (w == -2)\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << 'Y' << endl;\n\telse\n\t\tcout << u + 1 << ' ' << v + 1 << ' ' << w << endl;\n}\n\nint main() {\n\tint X, Y; cin >> X >> Y;\n\tvector<vector<int>> a(X + 1, vector<int>(Y + 1));\n\tfor (int x = 1; x <= X; x++)\n\t\tfor (int y = 1; y <= Y; y++)\n\t\t\tcin >> a[x][y];\n\tvector<vector<int>> l(101, vector<int>(101));\n\trep(i, 101) rep(j, 101) {\n\t\tint ma = 0;\n\t\tfor (int x = 1; x <= X; x++)\n\t\t\tfor (int y = 1; y <= Y; y++)\n\t\t\t\tma = max(ma, a[x][y] - i * x - j * y);\n\t\tl[i][j] = min(ma, 100);\n\t}\n\tfor (int x = 1; x <= X; x++)\n\t\tfor (int y = 1; y <= Y; y++) {\n\t\t\tint mi = INF;\n\t\t\trep(i, 101) rep(j, 101)\n\t\t\t\tmi = min(mi, i * x + j * y + l[i][j]);\n\t\t\tcout << x << ' ' << y << ' ' << mi << endl;\n\t\t\tif (mi != a[x][y]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << ' ' << 10401 << endl;\n\trep(i, 100) f(i, i + 1, -1);\n\trep(j, 100) f(101 + j, 101 + j + 1, -2);\n\trep(i, 101) rep(j, 101) f(i, 201 - j, l[i][j]);\n\tcout << 1 << ' ' << 202 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nbool P[101][101][101]; // X, Y, 1;\nstruct e {\n    int from, to, cost;\n};\n\nstruct edge {int to; ll cost;};\nstruct node {int pos; ll cost;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nvector<ll> dijkstra(vector<vector<edge>> &G, int root){\n    vector<ll> ret(G.size(), inf);\n    priority_queue<node> pq;\n    pq.push({root, 0});\n    while (!pq.empty()) {\n        node t = pq.top();\n        pq.pop();\n        \n        if (ret[t.pos] == inf) ret[t.pos] = t.cost;\n        else continue;\n        \n        for (edge e : G[t.pos]) {\n            pq.push({e.to, t.cost + e.cost});\n        }\n    }\n    return ret;\n}\n\n\nconst int N = 100;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> D(A, vector<int> (B));\n    rep(i, A) rep(j, B) cin >> D[i][j];\n    rep(i, N) rep(j, N) rep(k, 101) P[i][j][k] = 1;\n    rep(i, N) rep(j, N) rep(k, 101){\n        rep(a, A) rep(b, B){\n            if(D[a][b] > (a + 1) * i + (b + 1) * j + k) P[i][j][k] = 0;\n        }\n    }\n    \n    vector<e> ret;\n    rep(i, N) rep(j, N){\n        rep(k, 101) {\n            if(P[i][j][k]){\n                ret.pb({i, N * 2 + 1 - j, k});\n                break;\n            }\n        }\n    }\n    \n    rep(a, A) rep(b, B){\n        vector<vector<edge>> G(N * 2 + 2);\n        rep(i, N) G[i].pb({i + 1, a + 1});\n        rep(i, N) G[i + N + 1].pb({i + N + 2, b + 1});\n        for(auto e: ret) {\n            G[e.from].pb({e.to, e.cost});\n        }\n        \n        auto dist = dijkstra(G, 0);\n        if(dist[N * 2 + 1] != D[a][b]){\n            output(\"Impossible\");\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << N * 2 + 2 << \" \" << N * 2 + (int)ret.size() << endl;\n    \n    rep(i, N){\n        cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n    }\n    rep(i, N){\n        cout << i + N + 1 << \" \" << i + N + 2 << \" \" << \"Y\" << endl;\n    }\n    \n    for(auto e: ret) {\n        cout << e.from << \" \" << e.to << \" \" << e.cost << endl;\n    }\n    cout << 0 << \" \" << N * 2 + 1 << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 105;\nint f[maxn][maxn][maxn], d[maxn][maxn], ans[maxn][maxn][3];\nint A, B, mxA, mxB, n;\nset<pair<pair<int,int>,int> > s;\n\nint main() {\n\tscanf(\"%d%d\", &A, &B);\n\trep (i, 1, A) rep (j, 1, B) scanf(\"%d\", &d[i][j]);\n\trep (a, 0, 100) rep (b, 0, 100) rep (c, 0, 100) if (a + b + c <= 100) {\n\t\trep (i, 1, A) if (!f[a][b][c])\n\t\t\trep (j, 1, B) if (a * i + b * j + c < d[i][j]) {\n\t\t\t\t//printf(\"%d %d %d\\n\", a, b, c);\n\t\t\t\tf[a][b][c] = 1; break;\n\t\t\t}\n\t}\n\trep (i, 1, A) rep (j, 1, B) {\n\t\tint flag = 0;\n\t\trep (a, 0, 100) if (!flag)\n\t\t\trep (b, 0, 100) if (!flag && a * i + b * j <= d[i][j]) \n\t\t\t\trep (c, 0, 100) if (a * i + b * j + c == d[i][j] && !f[a][b][c]) {\n\t\t\t\t\tans[i][j][0] = a; ans[i][j][1] = b; ans[i][j][2] = c;\n\t\t\t\t\tmxA = max(mxA, a); mxB = max(mxB, b); flag = 1; break;\n\t\t\t\t}\t\t\t\t\n\t\tif (!flag) return puts(\"Impossible\"), 0;\n\t}\n\tputs(\"Possible\");\n\tn = mxA + mxB + 2;\n\trep (i, 1, mxA) s.insert(make_pair(make_pair(i, i+1), -1));\n\trep (i, n-mxB, n-1) s.insert(make_pair(make_pair(i, i+1), -2));\n\trep (i, 1, A) rep (j, 1, B) {\n\t\ts.insert(make_pair(make_pair(ans[i][j][0]+1, n-ans[i][j][1]), ans[i][j][2]));\n\t\t//printf(\"# %d %d   %d %d %d\\n\", i, j, ans[i][j][0], ans[i][j][1], ans[i][j][2]);\n\t}\n\tprintf(\"%d %d\\n\", n, (int)s.size());\n\tfor (auto x : s)\n\t\tif (x.second == -1) printf(\"%d %d X\\n\", x.first.first, x.first.second);\n\t\telse if (x.second == -2) printf(\"%d %d Y\\n\", x.first.first, x.first.second);\n\t\telse printf(\"%d %d %d\\n\", x.first.first, x.first.second, x.second);\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    REP(i,N-1) cout << 300-i << \" \" << 299-i << \" Y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint c[101][101], d[11][11];\n\nbool judge(int a, int b) {\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            int dist = 114514;\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    dist = min(dist, i * k + j * l + c[k][l]);\n                }\n            }\n            if (dist != d[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    c[k][l] = max(c[k][l], d[i][j] - i * k - j * l);\n                }\n            }\n        }\n    }\n\n    if (judge(a, b)) {\n        cout << \"Possible\" << endl;\n        cout << 202 << \" \" << 101 * 101 + 200 << endl;\n        for (int i = 1; i <= 100; i++) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n        }\n        for (int i = 102; i < 202; i++) {\n            cout << i + 1 << \" \" << i << \" Y\" << endl;\n        }\n        for (int i = 0; i <= 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                cout << i + 1 << \" \" << j + 102 << \" \" << c[i][j] << endl;\n            }\n        }\n        cout << 1 << \" \" << 102 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0,fff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1,fff=1;\n\t\t\t\tif (fff)ii=i,jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nvoid chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nvoid chkmin(int &x,int y){\n\tx=x<y?x:y;\n}\nint d[11][11];\nstruct edge{\n\tint s,t,v;\n}w[100100];\nint num;\nvoid Addedge(int s,int t,int v){\n\tw[++num]=(edge){s,t,v};\n}\nint n,m;\nint a[101][101];\nbool checkans(){\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint mn=INF;\n\t\t\tfor(int p=0;p<=100;p++)\n\t\t\t\tfor(int q=0;q<=100;q++)\n\t\t\t\t\tchkmin(mn,p*i+q*j+a[p][q]);\n\t\t\tif(mn!=d[i][j]) return 0;\n\t\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tint S=1,T=202;\n\tfor(int i=1;i<=100;i++)\n\t\tAddedge(i,i+1,-1);\n\tfor(int i=102;i<=T;i++)\n\t\tAddedge(i,i+1,-2);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int p=1;p<=10;p++)\n\t\t\t\tfor(int q=1;q<=10;q++)\n\t\t\t\t\tchkmax(a[i][j],d[p][q]-p*i-q*j);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tAddedge(i+1,T-j,a[i][j]);\n\tif(!checkans())\n\t\tprintf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"%d %d\\n\",T,num);\n\t\tfor(int i=1;i<=num;i++){\n\t\t\tprintf(\"%d %d \",w[i].s,w[i].t);\n\t\t\tif(w[i].v==-1) printf(\"X\\n\");\n\t\t\telse if(w[i].v==-2) printf(\"Y\\n\");\n\t\t\telse printf(\"%d\\n\",w[i].v);\n\t\t}\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(int)(n); ++i)\n#define maxn 100005\nstruct edge{\n    int x, y, c;\n    edge(int _x, int _y, int _c):x(_x), y(_y), c(_c){}\n};\nint d[10][10], b[10][10];\nint a[100][100];\nint hit_i[100][100][10];\nint hit_j[100][100][10];\nbool need[100][100];\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> d[i][j];\n    }\n    rep(s,100)rep(t,100){\n        rep(i,n)rep(j,m){\n            a[s][t] = max(d[i][j] - (i + 1) * s - (j + 1) * t, a[s][t]);\n        }\n    }\n    // rep(s, 100){\n    //     rep(t, 100) cout << a[s][t] << ' ';\n    //     cout << endl;\n    // }\n    rep(i,n)rep(j,m){\n        b[i][j] = 1000000;\n        rep(s,100)rep(t,100){\n            b[i][j] = min(b[i][j], (i + 1) * s + (j + 1) * t + a[s][t]);\n            if((i + 1) * s + (j + 1) * t + a[s][t] == d[i][j]){\n                hit_i[s][t][i]  = 1;\n                hit_j[s][t][j]  = 1;\n            }\n        }\n        if(b[i][j] > d[i][j]){\n            cout << \"Impossible\" << endl;\n            return;\n        }\n    }\n\n    rep(s, 100)rep(t, 100){\n        int cnt = 0;\n        rep(i, n) cnt += hit_i[s][t][i];\n        if (cnt < 2) continue;\n        cnt = 0;\n        rep(j, m) cnt += hit_j[s][t][j];\n        if (cnt < 2) continue;\n        need[s][t] = 1;\n    }\n\n    int S, T, node;\n    S = 1;\n    T = 2;\n    node = 3;\n    vector<edge> e; e.clear();\n    rep(s,100)rep(t,100) if(need[s][t]){\n        // s X + t Y + a[s][t]\n        vector<int> v;\n        v.clear();\n        rep(_, s) v.push_back(-2);\n        rep(_, t) v.push_back(-1);\n        rep(_, a[s][t] / 100) v.push_back(100);\n        if(a[s][t] % 100 > 0) v.push_back(a[s][t] % 100);\n        int last = S;\n        rep(i, v.size()){\n            if (i == v.size() - 1) e.push_back(edge(last, T, v[i]));\n            else{\n                e.push_back(edge(last, node, v[i]));\n                last = node;\n                node ++;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << node - 1 << ' ' << e.size() << endl;\n    for(auto p: e){\n        cout << p.x << ' ' << p.y << ' ';\n        if(p.c == -2) cout << 'X'; else\n        if(p.c == -1) cout << 'Y'; else\n        cout << p.c;\n        cout << endl;\n    }\n    cout << \"1 2\" <<endl;\n}\n\nint main(int argc, char const *argv[]) {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 105 \nusing namespace std;\nint d[maxn][maxn];\nint D[maxn][maxn];\nint f[maxn][maxn]; \nint main() {\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; ++i) for(int j = 1; j <= B; ++j) scanf(\"%d\", d[i] + j);\n\tfor(int a = 0; a <= 100; ++a) {\n\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\tfor(int x = 1; x <= A; ++x) {\n\t\t\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\t\t\tf[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0x3f, sizeof D);\n\tfor(int x = 1; x <= A; ++x) {\n\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\tfor(int a = 0; a <= 100; ++a) {\n\t\t\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\t\t\tD[x][y] = min(D[x][y], x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool same = true;\n\tfor(int x = 1; x <= A; ++x) \n\t\tfor(int y = 1; y <= B; ++y) \n\t\t\tif(D[x][y] != d[x][y]) same = false;\n\tputs(same ? \"Possible\" : \"Impossible\");\n\tif(same) {\n\t\tputs(\"202 10401\");\n\t\tfor(int i = 1; i <= 100; ++i) {\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\t\t}\n\t\tfor(int a = 0; a <= 100; ++a) \n\t\t\tfor(int b = 0; b <= 100; ++b) \n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 101, f[a][b]);\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t//\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n/*\trep0(i,3){\n\t\trep0(j,3) cerr<<mx[i][j]<<\" \";\n\t\tcerr<<endl;\n\t}*/\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx,idy;\n\t\trep0(x,101){\n\t\t\trep0(y,101){\n\t\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\t\tidx=x,idy=y;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tused[idx][idy]=true;\n\t\tadd(!idx?s:idx,!idy?t:idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nconst int INF = 999999999;\n\nint n, m, d[55][55], f[550][550], tmp[55][55];\n\nvoid Read(int &x)\n{\n    x = 0; int p = 0; char st = getchar();\n    while (st < '0' || st > '9') p = (st == '-'), st = getchar();\n    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();\n    x = p ? -x : x;\n    return;\n}\n\nint Max(int a, int b)\n{\n    return a > b ? a : b;\n}\n\nint Min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            scanf(\"%d\", &d[i][j]);\n\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++) \n            for (int x = 1; x <= n; x++)\n                for (int y = 1; y <= m; y++)\n                    f[i][j] = Max(f[i][j], d[x][y] - i * x - j * y);\n\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            tmp[x][y] = INF;\n            for (int i = 0; i <= 100; i++)\n                for (int j = 0; j <= 100; j++)\n                    tmp[x][y] = Min(tmp[x][y], i * x + j * y + f[i][j]);\n        }\n\n\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if(tmp[i][j] != d[i][j])\n            {\n                puts(\"Impossible\"); return 0;\n            }\n\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 10401);\n    for (int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", i + 1, 220 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint A, B;\nint D[15][15], C[110][110];\nconst int N = 100;\nconst int V = (N+1)*2;\nconst int E = (N+1)*(N+1) + 2*N;\nconst int S = V-1, T = V;\n \nsigned main() {\n    cin >> A >> B;\n    repq(i,1,A) repq(j,1,B) cin >> D[i][j];\n\n    repq(a,0,N) repq(b,0,N) {\n        repq(x,1,A) repq(y,1,B) chmax(C[a][b], D[x][y] - a*x - b*y);\n    }\n\n    repq(x,1,A) repq(y,1,B) {\n        int cost = INF;\n        repq(a,0,N) repq(b,0,N) chmin(cost, a*x + b*y + C[a][b]);\n        if(cost != D[x][y]) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    printf(\"%lld %lld\\n\", V, E);\n    printf(\"%lld %lld X\\n\", S, 1LL);\n    printf(\"%lld %lld Y\\n\", S-1, T);\n    rep(i,1,N) printf(\"%lld %lld X\\n\", i, i+1);\n    rep(i,1,N) printf(\"%lld %lld Y\\n\", N+i, N+i+1);\n\n    repq(a,0,N) repq(b,0,N) {\n        int u = (a ? a   : S);\n        int v = (b ? N+b : T);\n        printf(\"%lld %lld %lld\\n\", u, v, C[a][b]);\n    }\n    printf(\"%lld %lld\\n\", S, T);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << \"202 10201\" ln;\n    times(100, p) cout << p sp << p+1 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nint A, B;\nint Matrix[15][15];\nvector <pair <int, int> > G[100005];\nint D[15][15], Cost[305][305];\nint cnt;\nvoid Read()\n{\n    cin >> A >> B;\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            cin >> Matrix[i][j];\n}\n\nvoid precalcG()\n{\n    cnt = 1;\n    int last = 1;\n    int lastS, M = 0;\n    for(int i = 1; i <= 100; i++)\n    {\n        ++cnt;\n        G[last].push_back(make_pair(cnt, -1));\n        ++M;\n        last = cnt;\n        lastS = cnt;\n    }\n    ++cnt;\n    last = cnt;\n    ++cnt;\n    G[last].push_back(make_pair(cnt, -2));\n    ++M;\n    for(int i = 2; i <= 100; i++)\n    {\n        ++cnt;\n        G[last].push_back(make_pair(cnt, -2));++M;\n        last = cnt;\n    }\n    for(int i = 1; i <= lastS; i++)\n    {\n        for(int j = lastS + 1; j <= cnt; j++)\n        {\n            int coefx = i - 1, coefy = cnt - j;\n            int val = 0;\n            for(int a = 1; a <= A; a++)\n                for(int b = 1; b <= B; b++)\n                    val = max(val, max(0, Matrix[a][b] - coefx * a - coefy * b));\n            Cost[i][j] = val;\n            G[i].push_back(make_pair(j, val));++M;\n        }\n    }\n    for(int a = 1; a <= A; a++)\n        for(int b = 1; b <= B; b++)\n    {\n        D[a][b] = 100;\n        for(int i = 1; i <= lastS; i++)\n            for(int j = lastS + 1; j <= cnt; j++)\n            {\n                int coefx = i - 1, coefy = cnt - j;\n                D[a][b] = min(D[a][b], coefx * a + coefy * b + Cost[i][j]);\n            }\n        if(D[a][b] != Matrix[a][b])\n        {\n            cout << \"Impossible\\n\";\n            return;\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << cnt << \" \" << M << \"\\n\";\n    for(int i = 1; i <= cnt; i++)\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            int neighb = G[i][j].first, val = G[i][j].second;\n            cout << i << \" \" << neighb << \" \";\n            if(val >= 0)\n                cout << val;\n            if(val == -1)\n                cout << \"X\";\n            if(val == -2)\n                cout << \"Y\";\n            cout << \"\\n\";\n        }\n    cout << \"1 \" << cnt << '\\n';\n}\nint main()\n{\n    Read();\n    precalcG();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll a,b;cin>>a>>b;\n  auto d=vec(a+1,b+1,0LL);\n  rep(i,0,a)rep(j,0,b)cin>>d[i+1][j+1];\n  vector<ll>ru,rv,rc1,rc2;\n  stringstream output;\n  ll cnt=0;\n  auto add=[&](ll u,ll v,ll c){\n    cnt++;\n    if(c==-1){\n      output<<u spa v spa \"X\"<<endl;\n    }\n    else if(c==-2){\n      output<<u spa v spa \"Y\"<<endl;\n    }\n    else output<<u spa v spa c<<endl;\n  };\n  ll num=100;\n  ll start=1,goal=1+num+1;\n  {\n    //1...101:xの道\n    //102...203:yの道\n    //1->102\n    rep(i,start,start+num)add(i,i+1,-1);\n    rep(i,goal,goal+num)add(i+1,i,-2);\n  }\n  auto add_edge=[&](ll ai,ll bi,ll ci){\n    //aix + biy + ciを加える\n    add(start+ai,goal+bi,ci);\n  };\n  auto t=vec(a+1,b+1,false);\n  rep(i,0,num+1)rep(j,0,num+1){\n    ll mic=0;\n    rep(x,1,a+1)rep(y,1,b+1){\n      ll c=d[x][y]-i*x-j*y;\n      //if(i==0&&j==1)cout<<x spa y spa c spa d[x][y] spa -i*x spa -j*y<<endl;\n      chmax(mic,c);\n    }\n    if(mic>num)continue;\n    bool sw=false;\n    rep(x,1,a+1)rep(y,1,b+1){\n      ll c=d[x][y]-i*x-j*y;\n      if(c==mic&&!t[x][y]){\n        sw=true;\n        t[x][y]=true;\n      }\n    }\n    //if(sw)cout<<i spa j spa mic<<endl;\n    if(sw)add_edge(i,j,mic);\n  }\n  rep(i,1,a+1)rep(j,1,b+1)if(!t[i][j])judge=false;\n  if(judge){\n    cout<<\"Possible\"<<endl;\n    cout<<2*(num+1) spa cnt<<endl;\n    cout<<output.str();\n    cout<<start spa goal<<endl;\n  }\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint main()\n{\n  int a, b; cin>>a>>b;\n  int d[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      cin>>d[i][j];\n    }\n  }\n  int p[11][11], q[11][11], r[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      bool ok=0;\n      for(int k=0; k<=100; k++){\n        for(int l=0; l<=100; l++){\n          if(d[i][j]<k*i+l*j) continue;\n          bool nuee=0;\n          for(int s=1; s<=a; s++){\n            for(int t=1; t<=b; t++){\n              if(d[s][t]>d[i][j]+k*(s-i)+l*(t-j)){\n                nuee=1;\n                break;\n              }\n            }\n            if(nuee) break;\n          }\n          if(!nuee){\n            p[i][j]=k, q[i][j]=l, r[i][j]=d[i][j]-(k*i+l*j);\n            ok=1;\n            break;\n          }\n        }\n        if(ok) break;\n      }\n      if(!ok){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n    }\n  }\n  int n=202;\n  int s=1, t=n;\n  vector<P> g[205];\n  set<P> st;\n  int m=0;\n  for(int i=1; i<=n/2-1; i++){\n    g[i].push_back(P(i+1, -1)); m++;\n  }\n  for(int i=n/2+1; i<=n-1; i++){\n    g[i].push_back(P(i+1, -2)); m++;\n  }\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      if(st.find(P(1+p[i][j], n-q[i][j]))!=st.end()) continue;\n      st.insert(P(1+p[i][j], n-q[i][j]));\n      g[1+p[i][j]].push_back(P(n-q[i][j], r[i][j])); m++;\n    }\n  }/*\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      int dp[205];\n      fill(dp+1, dp+n+1, 10000);\n      dp[1]=0;\n      for(int k=1; k<=n; k++){\n        for(auto e:g[k]){\n          if(e.second==-1) dp[e.first]=min(dp[e.first], dp[k]+i);\n          else if(e.second==-2) dp[e.first]=min(dp[e.first], dp[k]+j);\n          else dp[e.first]=min(dp[e.first], dp[k]+e.second);\n          \n        }\n      }\n      cout<<dp[n]<<endl;\n    }\n  }\n  //return 0;*/\n  cout<<\"Possible\"<<endl;\n  cout<<n<<\" \"<<m<<endl;\n  for(int i=1; i<=n; i++){\n    for(auto e:g[i]){\n      cout<<i<<\" \"<<e.first<<\" \";\n      if(e.second==-1) cout<<\"X\"<<endl;\n      else if(e.second==-2) cout<<\"Y\"<<endl;\n      else cout<<e.second<<endl;\n    }\n  }\n  cout<<1<<\" \"<<n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100;\nconst int INF=1e9;\nvoid chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nvoid chkmin(int &x,int y){\n\tx=x<y?x:y;\n}\nint d[11][11];\nstruct edge{\n\tint s,t,v;\n}w[100100];\nint num;\nvoid Addedge(int s,int t,int v){\n\tw[++num]=(edge){s,t,v};\n}\nint n,m;\nint a[101][101];\nbool checkans(){\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint mn=INF;\n\t\t\tfor(int p=0;p<=maxn;p++)\n\t\t\t\tfor(int q=0;q<=maxn;q++)\n\t\t\t\t\tchkmin(mn,p*i+q*j+a[p][q]);\n\t\t\tif(mn!=d[i][j]) return 0;\n\t\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tint S=1,T=maxn*2+2;\n\tfor(int i=1;i<maxn;i++)\n\t\tAddedge(i,i+1,-1);\n\tfor(int i=maxn+2;i<T;i++)\n\t\tAddedge(i,i+1,-2);\n\tfor(int i=0;i<=maxn;i++)\n\t\tfor(int j=0;j<=maxn;j++)\n\t\t\tfor(int p=1;p<=n;p++)\n\t\t\t\tfor(int q=1;q<=m;q++)\n\t\t\t\t\tchkmax(a[i][j],d[p][q]-p*i-q*j);\n\tfor(int i=0;i<=maxn;i++)\n\t\tfor(int j=0;j<=maxn;j++)\n\t\t\tAddedge(i+1,T-j,a[i][j]);\n\tif(!checkans())\n\t\tprintf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\",T,num);\n\t\tfor(int i=1;i<=num;i++){\n\t\t\tprintf(\"%d %d \",w[i].s,w[i].t);\n\t\t\tif(w[i].v==-1) printf(\"X\\n\");\n\t\t\telse if(w[i].v==-2) printf(\"Y\\n\");\n\t\t\telse printf(\"%d\\n\",w[i].v);\n\t\t}\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <tuple>\nusing namespace std;\n\nint A, B, d[100][100], e[100][100]; bool used[100][100]; vector<tuple<int, int, int>>X;\n\nint main() {\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) cin >> d[i][j];\n\t}\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tif (used[i][j] == true) continue;\n\t\t\tbool flag2 = false;\n\t\t\tfor (int k = 0; k <= 100; k++) {\n\t\t\t\tint P1 = i*k; if (P1 > d[i][j]) continue;\n\t\t\t\tfor (int l = 0; l <= 100; l++) {\n\t\t\t\t\tint P2 = j*l; if (P1 + P2 > d[i][j]) continue;\n\t\t\t\t\tint X1 = k, X2 = l, X3 = d[i][j] - P1 - P2;\n\t\t\t\t\t\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tfor (int m = 1; m <= A; m++) {\n\t\t\t\t\t\tfor (int n = 1; n <= B; n++) {\n\t\t\t\t\t\t\tint K = m*X1 + n*X2 + X3;\n\t\t\t\t\t\t\tif (d[m][n] > K) { flag = false; break; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == false) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag == true) {\n\t\t\t\t\t\tX.push_back(make_tuple(X1, X2, X3));\n\t\t\t\t\t\tfor (int m = 1; m <= A; m++) {\n\t\t\t\t\t\t\tfor (int n = 1; n <= B; n++) {\n\t\t\t\t\t\t\t\tint K = m*X1 + n*X2 + X3;\n\t\t\t\t\t\t\t\tif (d[m][n] == K) used[m][n] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2 == true) break;\n\t\t\t}\n\t\t\tif (flag2 == false) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tvector<tuple<int, int, string>>G;\n\tfor (int i = 1; i <= 100; i++) G.push_back(make_tuple(i, i + 1, \"X\"));\n\tfor (int i = 102; i <= 201; i++) G.push_back(make_tuple(i, i + 1, \"Y\"));\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tG.push_back(make_tuple(get<0>(X[i]) + 1, 202 - get<1>(X[i]), to_string(get<2>(X[i]))));\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << \"202 \" << G.size() << endl;\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tcout << get<0>(G[i]) << \" \" << get<1>(G[i]) << \" \" << get<2>(G[i]) << endl;\n\t}\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,s,t;\nint a,b,d[15][15];\n\ninline void init(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tscanf(\"%d\",d[i]+j);\n}\n\nint fl,ga[300][300];\nstruct edge{\n\tint u,v,w;\n}ge[100005];\n\ninline int check(int x,int y,int c){\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tif(i*x+j*y+c<d[i][j])return 0;\n\treturn 1;\n}\n\ninline void solve(){\n\ts=1;t=n=202;\n\tfor(int i=1;i<=100;++i)\n\t\tge[m++]=(edge){i,i+1,-1};\n\tfor(int i=102;i<n;++i)\n\t\tge[m++]=(edge){i,i+1,101};\n\t\n\tfor(int i=1;i<=a;++i){\n\t\tfor(int j=1;j<=b;++j){\n\t\t\tint ok=0;\n\t\t\tfor(int x=0;x<=d[i][j]/i;++x){\n\t\t\t\tfor(int y=0;y<=(d[i][j]-x*i)/j;++y){\n\t\t\t\t\tint c=d[i][j]-x*i-y*j;\n\t\t\t\t\tif(check(x,y,c)){\n\t\t\t\t\t\tif(!ga[x][y]){\n\t\t\t\t\t\t\tga[x][y]=1;\n\t\t\t\t\t\t\tge[m++]=(edge){x+1,n-y,c};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)break;\n\t\t\t}\n\t\t\tif(!ok){fl=1;break;}\n\t\t}\n\t\tif(fl)break;\n\t}\n\t\n\tif(fl){puts(\"Impossible\");return;}\n\tprintf(\"Possible\\n%d %d\\n\",n,m);\n\tfor(int i=0;i<m;++i){\n\t\tprintf(\"%d %d \",ge[i].u,ge[i].v);\n\t\tif(ge[i].w<0)puts(\"X\");\n\t\telse if(ge[i].w>100)puts(\"Y\");\n\t\telse printf(\"%d\\n\",ge[i].w);\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//void __(){\n//    _(int,A);\n//    _(int,B);\n//    vvi d(A+1,vi(B+1,MOD));\n//    rep(i,1,A)\n//        rep(j,1,B)\n//            cin >> d[i][j];\n//    int S = 1, T = 300;\n//    vpii x_edges, y_edges;\n//    rep(i,2,101)\n//        x_edges.pb({i-1,i});\n//    per(i,200,299)\n//        y_edges.pb({i,i+1});\n//    vvi best_c(101,vi(101,MOD));\n//    vvi test(A+1,vi(B+1,MOD));\n//    rep(a,0,100)\n//        rep(b,0,100)\n//            rep(c,0,100){\n//                if(a+b+c >= 1 && a+b+c <= 100){\n//                    bool ok = true;\n//                    rep(i,1,A){\n//                        if(!ok)break;\n//                        rep(j,1,B){\n//                            if(!ok)break;\n//                            if(d[i][j] > i*a+j*b+c) ok = false;\n//                        }\n//                    }\n//                    if(ok){\n//                        best_c[a][b] = min(best_c[a][b],c);\n//                        rep(i,1,A){\n//                            rep(j,1,B){\n//                                test[i][j] = min(test[i][j],i*a+j*b+c);\n//                            }\n//                        }\n//                    }\n//                }\n//            }\n//    if(test != d){\n//        print \"Impossible\";\n//        return;\n//    }\n//    print \"Possible\";\n//    vvi other_edges;\n//    rep(a,0,100)\n//        rep(b,0,100)\n//            if(best_c[a][b] != MOD){\n//                int u = S+a;\n//                int v = T-b;\n//                other_edges.pb({u,v,best_c[a][b]});\n//            }\n//    print T,sz(x_edges)+sz(y_edges)+sz(other_edges);\n//    for(auto _ : x_edges) print _.X,_.Y,'X';\n//    for(auto _ : x_edges) print _.X,_.Y,'Y';\n//    for(auto _ : other_edges) print _;\n//    print S,T;\n//\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT,REP_ZERO_INT)(__VA_ARGS__)\n#define PER_INT(i,l,r) for(int i = r; i >= l; --i)\n#define GET_PER_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define per(...) GET_PER_MACRO(__VA_ARGS__,PER_ANY,PER_INT,PER_ZERO_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define X first\n#define Y second\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout)\n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\nT1 ostream& operator<<(ostream& stream, const vector<T>& t){\n    for(int i = 0; i < sz(t); ++i){\n        stream << t[i];\n        if(i+1 < sz(t))\n            stream << ' ';\n    }\n    return stream;\n}\n#define INPUT_WITHOUT_INIT(type,name) type name; cin >> name\n#define GET_INPUT_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define _(...) GET_INPUT_MACRO(__VA_ARGS__,_IWI,_IWI,_IWI,_IWI,_IWI,_IWI,INPUT_WITHOUT_INIT)(__VA_ARGS__)\nvoid __(){\n    _(int,A);\n    _(int,B);\n    vvi d(A+1,vi(B+1,MOD));\n    rep(i,1,A)\n        rep(j,1,B)\n            cin >> d[i][j];\n    int S = 1, T = 300;\n    vpii x_edges, y_edges;\n    rep(i,2,101)\n        x_edges.pb({i-1,i});\n    per(i,200,299)\n        y_edges.pb({i,i+1});\n    vvi best_c(101,vi(101,MOD));\n    vvi test(A+1,vi(B+1,MOD));\n    rep(a,0,100)\n        rep(b,0,100)\n            rep(c,0,100){\n                if(a+b+c >= 1 && a+b+c <= 100){\n                    bool ok = true;\n                    rep(i,1,A){\n                        if(!ok)break;\n                        rep(j,1,B){\n                            if(!ok)break;\n                            if(d[i][j] > i*a+j*b+c) ok = false;\n                        }\n                    }\n                    if(ok){\n                        best_c[a][b] = min(best_c[a][b],c);\n                        rep(i,1,A){\n                            rep(j,1,B){\n                                test[i][j] = min(test[i][j],i*a+j*b+c);\n                            }\n                        }\n                    }\n                }\n            }\n    if(test != d){\n        print \"Impossible\";\n        return;\n    }\n    print \"Possible\";\n    vvi other_edges;\n    rep(a,0,100)\n        rep(b,0,100)\n            if(best_c[a][b] != MOD){\n                int u = S+a;\n                int v = T-b;\n                other_edges.pb({u,v,best_c[a][b]});\n            }\n    print T,sz(x_edges)+sz(y_edges)+sz(other_edges);\n    for(auto _ : x_edges) print _.X,_.Y,'X';\n    for(auto _ : x_edges) print _.X,_.Y,'Y';\n    for(auto _ : other_edges) print _;\n    print S,T;\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i + 1], ys[i], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, bool());\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, a + 1) REP (j, b + 1) REP (c, 101) {\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1) + c;\n            if (f < d[x][y]) {\n                goto invalid;\n            } else if (f == d[x][y]) {\n                used[x][y] = true;\n            }\n        }\n        int_edge.emplace_back(xs[i], ys[j], c);\ninvalid: ;\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s << ' ' << t << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n#define N 305\n#define db double\n#define ll long long\nint A,B,dist[12][12],f[N][N],d;\nint cal(int a,int b)\n{\n\tint res=0;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) res=max(res,dist[i][j]-i*a-j*b);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) scanf(\"%d\",&dist[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++) f[i][j]=cal(i,j);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\td=1e9;\n\t\t\tfor(int i2=0;i2<=100;i2++)\n\t\t\t\tfor(int j2=0;j2<=100;j2++)\n\t\t\t\t\td=min(d,f[i2][j2]+i*i2+j*j2);\n\t\t\tif(d^dist[i][j]) {puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)//if(f[i][j])\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\tfor(int i=1;i<=100;i++) printf(\"%d %d Y\\n\",102+i,101+i);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100&&k<100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + H * W << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  return 1;\n  std::cout << \"Possible\\n\";\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007\n#define lson(v) ((v)<<1)\n#define rson(v) (((v)<<1)^1)\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\ntypedef pair < pii , int > p3i;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint A,B,arr[15][15];\nvector < p3i > paths;\nint main(){\n    // inputing start\n    scanf(\"%d%d\",&A,&B);\n\tint xb,x2,x3,x4,x5,mmax=0,mmay=0;\n\tfor(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tscanf(\"%d\",&arr[xb][x2]);\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    for(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tint a=xb+1,b=x2+1,k=arr[xb][x2],maxy=100,miny=0;\n\t\t\tfor(x5=0;x5<=100;++x5){\n\t\t\t\tmaxy=100;miny=0;\n\t\t\t\tfor(x3=0;x3<A;++x3){\n\t\t\t\t\tfor(x4=0;x4<B;++x4){\n\t\t\t\t\t\tint n=x3+1,m=x4+1,c=arr[x3][x4],coe=m-b,val=c-k-x5*(n-a);\n\t\t\t\t\t\tif(x3==xb && x4==x2){\n\t\t\t\t\t\t\tn=-a;m=-b;c=-k;\n\t\t\t\t\t\t\tval=c-k-x5*(n-a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe*val<0){\n\t\t\t\t\t\t\tminy=101;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(val==0){\n\t\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\t\tUMIN(maxy,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe==0){\n\t\t\t\t\t\t\tif(val>0){\n\t\t\t\t\t\t\t\tminy=101;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\tUMIN(maxy,(-val)/(-coe));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe>0){\n\t\t\t\t\t\t\tUMAX(miny,(val+coe-1)/coe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(miny<=maxy){\n\t\t\t\t\tpaths.push_back(mpr(mpr(x5,miny),k-x5*a-miny*b));\n\t\t\t\t\tUMAX(mmax,x5);\n\t\t\t\t\tUMAX(mmay,miny);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x5>100){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\tax+by+z=k\n\t\t\t *  -ax-by>=-k\n\t\t\t\tz=k-ax-by\n\t\t\t\tnx+my+k-ax-by>=c\n\t\t\t\t(n-a)x+(m-b)y>=c-k  \n\t\t\t\tcoe*y>=val  \n\t\t\t\tor\n\t\t\t\t-coe*y<=-val  */\n\t\t}\n\t}\n\tsort(paths.begin(),paths.end());\n\tpaths.erase(unique(paths.begin(),paths.end()),paths.end());\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",mmax+1+mmay+1,mmax+mmay+paths.size());\n\tfor(xb=0;xb<mmax;++xb){\n\t\tprintf(\"%d %d x\\n\",xb+1,xb+2);\n\t}\n\tfor(xb=mmay-1;xb>=0;--xb){\n\t\tprintf(\"%d %d y\\n\",mmax+xb+3,mmax+xb+2);\n\t}\n\tfor(xb=0;xb<paths.size();++xb){\n\t\tprintf(\"%d %d %d\\n\",paths[xb].first.first+1,paths[xb].first.second+mmax+2,paths[xb].second);\n\t}\n\tprintf(\"%d %d\\n\",1,mmax+2);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nint main(void){\n  int n = 100;\n  int a, b;\n  int f = 1;\n  cin >> a >> b;\n  vector<vi> d(a, vi(b));\n  vector<vi> finished(a, vi(b, 0));\n  REP(i, a) REP(j, b) cin >> d[i][j];\n  vector<vector<pii> > g(2 * n + 2);\n  REP(i, n + 1) {\n    REP(j, n + 1) {\n      int min_cost = 0;\n      REP(k, a) {\n        REP(l, b) {\n          int x = (k + 1) * i + (l + 1) * j;\n          int y = x - d[k][l];\n          if(y < 0) min_cost = max(min_cost, -y);\n        }\n      }\n      g[i+10].push_back(pii(220 - j, min_cost));\n      REP(k, a) {\n        REP(l, b){\n          if((k + 1) * i + (l + 1) * j + min_cost == d[k][l]) finished[k][l] = 1;\n        }\n      }\n    }\n  }\n  REP(i, a) REP(j, b) if(!finished[i][j]) f = 0;\n\n  if(!f) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  cout << \"Possible\" << endl;\n  int m = 2 * n + 2;\n  REP(i, g.size()) m += g[i].size();\n  cout << \"300 \" << m << endl;\n  cout << \"1 10 0\" << endl;\n  cout << \"220 2 0\" << endl;\n  REP(i, 100) {\n    cout << i + 10 << \" \" << i + 11 << \" X\" << endl;\n    cout << i + 120 << \" \" << i + 121 << \" Y\" << endl;\n  }\n  REP(i, g.size()) {\n    REP(j, g[i].size()) {\n      cout << i << \" \" << g[i][j].first << \" \" << g[i][j].second << endl;\n    }\n  }\n  cout << \"1 2\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n#define N 305\n#define db double\n#define ll long long\nint A,B,dist[12][12],f[N][N],d;\nint cal(int a,int b)\n{\n\tint res=0;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) res=max(res,dist[i][j]-i*a-j*b);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) scanf(\"%d\",&dist[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++) f[i][j]=cal(i,j);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\td=1e9;\n\t\t\tfor(int i2=0;i2<=100;i2++)\n\t\t\t\tfor(int j2=0;j2<=100;j2++)\n\t\t\t\t\td=min(d,f[i2][j2]+i*i2+j*j2);\n\t\t\tif(d^dist[i][j]) {puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"202 10401\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\tfor(int i=1;i<=100;i++) printf(\"%d %d Y\\n\",101+i,102+i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\n \ntemplate<typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48; \n    return x *= f;\n}\n\nconst int N = 300;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nint n = 202, m;\nstruct edge { int u, v, w; } e[N * N + 5];\n\nbool chk() {\n    for(int x = 1; x <= A; ++ x) \n        for(int y = 1; y <= B; ++ y) {\n            int mn = oo;\n            for(int a = 0; a <= 100; ++ a) \n                for(int b = 0; b <= 100; ++ b) if(f[a][b] >= 0) \n                    chkmin(mn, f[a][b] + a*x + b*y);\n\n            if(mn != d[x][y]) return false;\n        }\n    return true;\n}\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif \n\n    read(A), read(B);\n    for(int i = 1; i <= A; ++i) \n        for(int j = 1; j <= B; ++j) read(d[i][j]);\n\n    memset(f, ~oo, sizeof f);\n    for(int a = 0; a <= 100; ++ a) \n        for(int b = 0; b <= 100; ++ b) {\n            for(int x = 1; x <= A; ++ x) \n                for(int y = 1; y <= B; ++y) {\n                    chkmax(f[a][b], d[x][y] - a * x - b * y);\n                }\n\n            // if(f[a][b] >= 0) debug(\"%d %d %d \\n\", a, b, f[a][b]);\n        }\n\n    if(!chk()) return !puts(\"Impossible\");\n\n    puts(\"Possible\");\n\n    for(int a = 0; a <= 100; ++ a) \n        for(int b = 0; b <= 100; ++ b) {\n            if(f[a][b] >= 0) e[++ m] = (edge) { a + 1, n - b, f[a][b] };\n        }\n    for(int a = 2; a <= 101; ++ a) e[++ m] = (edge) { a-1, a, -1 };\n    for(int b = n-99; b<= n; ++ b) e[++ m] = (edge) { b-1, b, -2 };\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 1; i <= m; ++i) {\n        printf(\"%d %d \", e[i].u, e[i].v);\n\n        if(e[i].w >= 0) printf(\"%d\\n\", e[i].w);\n        else {\n            puts(e[i].w == -1 ? \"X\" : \"Y\");\n        }\n    }\n    printf(\"%d %d\\n\", 1, n);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool flg[101][101][101];\n\nint main()\n{\n    cin.tie(0);\n\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> bd(a, vector<int>(b));\n\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            cin >> bd[i][j];\n        }\n    }\n\n    memset(flg, 0, sizeof(flg));\n    bool possible = true;\n    for (int x = 1; x <= a; x++) {\n        for (int y = 1; y <= b; y++) {\n            int t = bd[x - 1][y - 1];\n            bool ok = false;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    for (int c = 0; c <= 100; c++) {\n                        if (flg[a][b][c])\n                            continue;\n\n                        if (a * x + b * y + c == t) {\n                            ok = true;\n                        }\n\n                        if (a * x + b * y + c < t) {\n                            flg[a][b][c] = true;\n                        }\n                    }\n                }\n            }\n            if (!ok) {\n                possible = false;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    cout << \"Possible\" << endl;\n\n    map<pair<int, int>, int> es;\n    es[make_pair(100, 101)] = 100;\n    for (int i = 0; i < 100; i++) {\n        es[make_pair(i, i + 1)] = -1;\n        es[make_pair(101 + i, 101 + i + 1)] = -2;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            for (int c = 0; c <= 100; c++) {\n                if (!flg[a][b][c]) {\n                    es[make_pair(a, 202 - b)] = c;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << 202 << \" \" << es.size() << endl;\n\n    for (auto& it : es) {\n        cout << it.first.first + 1 << \" \" << it.first.second + 1 << \" \";\n        if (it.second == -1) {\n            cout << \"X\";\n        } else if (it.second == -2) {\n            cout << \"Y\";\n        } else {\n            cout << it.second;\n        }\n        cout << endl;\n    }\n\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\t//if(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\t//if(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = 0, y = 0;\n\t\t\tfor(int k = i; k <= a; k++) for(int l = j; l <= b; l++){\n\t\t\t\tif(k>i) chmax(x, (d[k][j]-d[i][j]+k-i-1)/(k-i));\n\t\t\t\tif(l>j) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t}\n\n\t\t\t//for(int k = j+1; k <= b; k++) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t//ll x = i<a?(d[a][j]-d[i][j]+a-i)/(a-i):0;\n\t\t\t//ll y = j<b?(d[i][b]-d[i][j]+b-j)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=233;\nint m,n,a[N][N],b[N][N]; bool vis[N][N];\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tint i,j,x,y;\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++) scanf(\"%d\",&a[i][j]);\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++)\n\t\t\tfor (x=0; x<=100; x++)\n\t\t\t\tfor (y=0; y<=100; y++) b[x][y]=max(b[x][y],a[i][j]-i*x-j*y);\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++)\n\t\t\tfor (x=0; x<=100; x++)\n\t\t\t\tfor (y=0; y<=100; y++)\n\t\t\t\t\tif (b[x][y]==a[i][j]-i*x-j*y) vis[i][j]=1;\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++) if (!vis[i][j]){\n\t\t\tputs(\"Impossible\"); return 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\",200+101*101);\n\tfor (i=1; i<=100; i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (i=102; i<=201; i++) printf(\"%d %d Y\\n\",i+1,i);\n\tfor (i=0; i<=100; i++)\n\t\tfor (j=0; j<=100; j++) printf(\"%d %d %d\\n\",i+1,j+102,b[i][j]);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A, B, N, M, S, T, d[15][15];\nint adj[102][102];\nint dist[204];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i){\n\t\tfor (int j = 1; j <= B; ++j){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tS = 1;\n\tT = 202;\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 1; k <= A; ++k){\n\t\t\t\tfor (int l = 1; l <= B; ++l){\n\t\t\t\t\tmaxi = max(maxi,d[k][l]-k*i-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj[i][j] = maxi;\n\t\t}\n\t}\n\tfor (int k = 1; k <= A; ++k){\n\t\tfor (int l = 1; l <= B; ++l){\n\t\t\tdist[1] = 0;\n\t\t\tfor (int i = 1; i <= 100; ++i){\n\t\t\t\tdist[i+1] = dist[i] + k;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 100; ++i){\n\t\t\t\tint mini = 1e9;\n\t\t\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\t\t\tmini = min(mini,adj[j][100-i]+dist[j+1]);\n\t\t\t\t}\n\t\t\t\tif (i > 0){\n\t\t\t\t\tmini = min(mini,dist[102+i-1]+l);\n\t\t\t\t}\n\t\t\t\tdist[102+i] = mini;\n\t\t\t}\n\t\t\tif (dist[202] != d[k][l]){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tN = 202;\n\tM = 100+100+(101*101);\n\tfor (int i = 1; i <= 100; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 102; i <= 201; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tcout << i+1 << ' ' << j+102 << ' ' << adj[i][100-j] << '\\n';\n\t\t}\n\t}\n\tcout << S << ' ' << T << '\\n';\n\tcout << flush;\n\t//for (int i = 1; i < 1e9; ++i){for (int j = 0; j < 1e9; ++j){}}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint A, B;\n\tcin >> A >> B;\n\tint d[10][10];\n\tfor(int i=0; i<A; ++i)\n\t\tfor(int j=0; j<B; ++j)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\t\t\n\tint nx[10][10], ny[10][10];\n\tfor(int y=A; y--;)\n\t\tfor(int x=B; x--;)\n\t\t{\n\t\t\tif(x == B-1)\n\t\t\t{\n\t\t\t\tnx[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnx[y][x] = max(nx[y][x+1], d[y][x+1] - d[y][x]);\n\t\t\t\tif(y < A-1)\n\t\t\t\t\tnx[y][x] = max(nx[y][x], nx[y+1][x]);\n\t\t\t\tif((0 < x && d[y][x] - d[y][x-1] < nx[y][x]))// || 200/max(A,B) < nx[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y == A-1)\n\t\t\t{\n\t\t\t\tny[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tny[y][x] = max(ny[y+1][x], d[y+1][x] - d[y][x]);\n\t\t\t\tif(x < B-1)\n\t\t\t\t\tny[y][x] = max(ny[y][x], ny[y][x+1]);\n\t\t\t\tif((0 < y && d[y][x] - d[y-1][x] < ny[y][x]))// || 200/max(A,B) < ny[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t*(int*)0=0;\n\tcout << \"Possible\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\n\t\t}\n\t}\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n \ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n \ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n \nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<40;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll a, b;\n  cin >> a >> b;\n  vector<vector<ll>> v(a, vector<ll>(b));\n  REP(i, a) REP(j, b) cin >> v[i][j];\n\n  vector<vector<ll>> g(300, vector<ll>(300, -1));\n  // 0~100\n  FOR(i, 1, 101) {\n    g[i-1][i] = -2;\n  }\n  // 101~201\n  FOR(i, 102, 202) {\n    g[i-1][i] = -3;\n  }\n\n  // 頂点[0,100]から頂点[101,201]への辺\n  REP(x, 101) REP(y, 101) {\n    ll ret = 0;\n    REP(i, a) REP(j, b) {\n      chmax(ret, v[i][j]-(i+1)*x-(j+1)*y);\n    }\n    g[x][201-y] = ret;\n  }\n\n  // 確かめる\n  FOR(i, 1, a+1) FOR(j, 1, b+1) {\n    ll mi = INF;\n    REP(x, 101) REP(y, 101) {\n      chmin(mi, i*x+j*y+g[x][201-y]);\n    }\n    if(v[i-1][j-1] != mi) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  ll m = 0;\n  REP(i, 300) REP(j, 300) {\n    if(g[i][j] != -1) m++;\n  }\n  cout << \"Possible\" << endl;\n  cout << 300 << \" \" << m << endl;\n  REP(i, 300) REP(j, 300) {\n    if(g[i][j] == -1) continue;\n    if(g[i][j] == -2) cout << i+1 << \" \" << j+1 << \" X\" << endl;\n    else if(g[i][j] == -3) cout << i+1 << \" \" << j+1 << \" Y\" << endl;\n    else cout << i+1 << \" \" << j+1 << \" \" << g[i][j] << endl; \n  }\n  cout << 1 << \" \" << 202 << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    set<P> s;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void add(ll from, ll to, string label) {\n        if (s.count({from, to}) > 0) return;\n        s.insert({from, to});\n        edges.pb({from, to, label});\n    }\n    void addX(ll from, ll to) {\n        add(from, to, \"X\");\n    }\n    void addY(ll from, ll to) {\n        add(from, to, \"Y\");\n    }\n    void add(ll from, ll to, ll cost) {\n        add(from, to, to_string(cost));\n    }\n    void output(ll s, ll t) {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << s+1 << \" \" << t+1 << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<ll> xid(101), yid(101);\n    rep(i, 101) xid[i] = V++;\n    rep(i, 101) yid[i] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    G.add(s, xid[0], 0);\n    rep(i, 100) G.addX(xid[i], xid[i+1]);\n    rep(i, 100) G.addY(yid[i+1], yid[i]);\n    G.add(yid[0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(xid[X[a][b]], yid[Y[a][b]], Z[a][b]);\n    }\n    G.add(yid[0], t, 0);\n    G.output(s, t);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n\n\nusing namespace std;\n\nint d[15][15];\nint N;\nint g[305][305];\nVI vy, vx;\n\nint check[15][15];\n\nint main () {\n\tmake2(A, B);\n\tFOR(i,0,A) FOR(j,0,B) {\n\t\tmake(x); d[i+1][j+1] = x;\n\t}\n\tvector<pair<PII, int > > v;\n\tFOR(a,0,101) FOR(b,0,101) {\n\t\tint c = -1000;\n\t\tFOR(x,1,A+1) FOR(y,1,B+1) {\n\t\t\tc = max(c, d[x][y]-a*x-b*y);\n\t\t}\n\t\tif (c < 0) continue;\n\t\tv.pb(mp(mp(a,b),c));\n\t}\n\tN = 2;\n\tFOR(i,0,305) FOR(j,0,305) g[i][j] = -3;\n\tint maxa = 0;\n\tint maxb = 0;\n\tFORE(i, v) maxa = max(maxa, i->st.st);\n\tFORE(i, v) maxb = max(maxb, i->st.nd);\n\tint S = 0; vx.pb(S);\n\tint T = 1; vy.pb(T);\n\tint act = 2;\n\tFOR(i,0,maxa) {\n\t\tg[vx.back()][act] = -1;\n\t\tg[act][vx.back()] = -1;\n\t\tvx.pb(act); \n\t\tact++;\n\t}\n\tFOR(i,0,maxb) {\n\t\tg[vy.back()][act] = -2;\n\t\tg[act][vy.back()] = -2;\n\t\tvy.pb(act); \n\t\tact++;\n\t}\n\tbool ok = true;\n\tFORE(i,v) {\n\t\tint a = i->st.st;\n\t\tint b = i->st.nd;\n\t\tint c = i->nd;\n\t\tg[vx[a]][vx[b]] = c;\n\t\tg[vx[b]][vx[a]] = c;\n\t\tFOR(ii,1,A+1) FOR(jj,1,B+1) {\n\t\t\tif (ii*a +jj*b + c == d[ii][jj]) check[ii][jj] = 1; \n\t\t\tif (ii*a +jj*b + c < d[ii][jj]) ok = false;\n\t\t}\n\t}\n\tFOR(i,1,A+1) FOR(j,1,B+1) {\n\t\tif (check[i][j] != 1 || !ok) {\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tint m = 0;\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] != -3) m++;\n\t}\n\tprintf(\"%d %d\\n\", act, m);\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] == -1) {\n\t\t\tprintf(\"%d %d X\\n\", i+1, j+1);\n\t\t}\n\t\telse if (g[i][j] == -2) {\n\t\t\tprintf(\"%d %d Y\\n\", i+1, j+1);\n\t\t} else if (g[i][j] >= 0) {\n\t\t\tprintf(\"%d %d %d\\n\", i+1, j+1, g[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 2\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int Y = 100;\n\tconst int S = Y * 2 - 2, T = Y * 2 - 1;\n\txv.push_back(S);\n\tFOR(i, Y - 1) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, Y - 1) yv.push_back(i + Y - 1);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int, int, int>> vp;\n\tFOR(i, Y) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(w, Y) FOR(z, Y) {\n\t\tif (w + z >= Y) continue;\n\t\tint maxdiff = -10000;\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tint xw = w * (i + 1);\n\t\t\tint yw = z * (j + 1);\n\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\tchmax(maxdiff, additional);\n\t\t}\n\t\tif (maxdiff >= 0) {\n\t\t\tint from = xv[w], to = yv[Y - z];\n\t\t\t// printf(\"%dx + %dy + %d\\n\", w, z, maxdiff);\n\t\t\tvp.emplace_back(from, to, maxdiff);\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(T + 1);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", T + 1, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S + 1, T + 1);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define ll long long\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FORD(i,a,b) for(int i=a;i>=b;i--)\n#define FORL(i,x) for(int i=head[x];i;i=nxt[i])\n#define clr(x,y) memset(x,y,sizeof(x))\n#define in(a) a=read()\n#define out(a) printf(\"%d\\n\",a)\ninline ll read(){\n    char c=getchar();ll f=1,x=0;\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9')x=x*10+(c-'0'),c=getchar();\n    return x*f;\n}\n#define mod 1000000007\nvoid MOD(int &x){if(x>=mod)x-=mod;}\n#define maxn 100010\n#define inf (1<<30)\n\nint d[110][110],f[110][110];\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint n,m;\n\tin(n);in(m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tin(d[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tbool flag=0;\n\t\t\tfor(int i=0;i<=100;i++)\n\t\t\t\tfor(int j=0;j<=100;j++)\n\t\t\t\t\tif(f[i][j]+i*x+j*y==d[x][y])\n\t\t\t\t\t\tflag=1;\n\t\t\tif(!flag){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<' '<<200+101*101<<endl;\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1); \n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i,202-j,f[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            int ma=0;\n            rep(k,i,a){\n                rep(l,j,b){\n                    if(k==i&&l==j)continue;\n                    int mi=1000000000;\n                    int ddx=0,ddy=0;\n                    rep(ii,0,100){\n                        int zx=ii*(k-i);\n                        int noko=d[k][l]-d[i][j]-zx;\n                        int say=l-j;\n                        if(say==0){\n                            if(noko<=0){\n                                if(mi>zx*(i+1)){\n                                    mi=zx*(i+1);\n                                    ddx=zx;\n                                    ddy=0;\n                                }\n                               // break;\n                            }\n                        }\n                        else{\n                            int zy=(noko+say-1)/say;\n                            if(noko<=0)zy=0;\n                            if(mi>zx*(i+1)+zy*(j+1)){\n                                mi=zx*(i+1)+zy*(j+1);\n                                ddx=zx;\n                                ddy=zy;\n                            }\n                           // if(noko<=0)break;\n                        }\n                    }\n                    if(mi>ma){\n                        ma=mi;\n                        dx=ddx;\n                        dy=ddy;\n                    }\n                }\n            }\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tcout << \"1 199\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint A, B;\n\tint d[20][20];\n\n\tcin >> A >> B;\n\trep(i,A) rep(j,B) cin >> d[i][j];\n\n\tvector<pair<pii,int>> v;\n\tbool ok[20][20] = {};\n\trep(a,101) rep(b,101) rrep(c,101){\n\t\tbool f = true, check = false;\n\t\trep(i,A) rep(j,B){\n\t\t\tint s = a*(i+1) + b*(j+1) + c;\n\t\t\tif( d[i][j] > s ) f = false;\n\t\t\tif( d[i][j] == s ){\n\t\t\t\tok[i][j] = true;\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tif(f && check) v.emplace_back(pii(a,b), c);\n\t\tif(!f) break;\n\t}\n\n\tbool ans = true;\n\trep(i,A) rep(j,B) if( !ok[i][j] ) ans = false;\n\n\tif( !ans ){\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\n\tvector<pair<pii,int>> edge;\n\trep(i,101) edge.emplace_back( pii(i+1,i+2), -1 );\n\trep(i,101) edge.emplace_back( pii(200+i-1,200+i), -2 );\n\tfor(auto p: v){\n\t\tint a = p.X.X;\n\t\tint b = p.X.Y;\n\t\tint c = p.Y;\n\t\tedge.emplace_back( pii(a+1, 300-b), c );\n\t}\n\n\tcout << 300 << \" \" << edge.size() << endl;\n\tfor(auto t: edge){\n\t\tcout << t.X.X << \" \" << t.X.Y << \" \";\n\t\tif( t.Y == -1 ) cout << \"X\" << endl;\n\t\telse if( t.Y == -2 ) cout << \"Y\" << endl;\n\t\telse cout << t.Y << endl;\n\t}\n\tcout << 1 << \" \" << 300 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N], ox[N], oy[N], m;\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tf[i][j] = 0;\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tif (f[i][j]) ox[++m] = i, oy[m] = j;\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\", 200 + m);\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d %d %d\\n\", ox[i] ? ox[i] : 201, oy[i] ? 100 + oy[i] : 202,\n\t\t\t   f[ox[i]][oy[i]]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mkp make_pair\n#define pii pair<int, int> \n#define pll pair<long long int, long long int>\n#define sci(x) scanf(\"%d\", &x)\n#define scl(x) scanf(\"%lld\", &x)\n#define fi first\n#define sc second\n#define deb 0\n\nint d[1001][1001];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);cout.tie(0);cin.tie(0);\n\n\tint a, b, i, j, k, x, y, z;\n\tcin >> a >> b;\n\tfor (i = 1; i <= a; ++i) {\n\t\tfor (j = 1; j <= b; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 100; ++i) {\n\t\tfor (j = 0; j <= 100; ++j) {\n\t\t\tbool valid = true;\n\t\t\tfor (x = 1; x <= a; ++x) {\n\t\t\t\tfor (y = 1; y <= b; ++y) {\n\t\t\t\t\tif (min(x + i, y + j) != d[x][y]) valid = false;\n\t\t\t\t\tif (!valid) break;\n\t\t\t\t}\n\t\t\t\tif (!valid) break;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tcout << \"Possible\" << endl;\n\t\t\t\tcout << \"4 4\" << endl;\n\t\t\t\tcout << \"1 2 X\" << endl;\n\t\t\t\tcout << \"2 4 \" << i << endl;\n\t\t\t\tcout << \"1 3 Y\" << endl;\n\t\t\t\tcout << \"3 4 \" << j << endl;\n\t\t\t\tcout << \"1 4\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Impossible\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY){\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\t\t}\n\tM = 200 + 101 * 101;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J){\n\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint main(){\n    int a,b;\n    cin >> a >> b;\n    vector<vector<int> > d(a,vector<int>(b));\n    rep(i,a){\n        rep(j,b){\n            cin >> d[i][j];\n        }\n    }\n    int n,m;\n    n = 200;\n    int s = 203;\n    int t = 204;\n    bool flag = 0;\n    vector<vector< int > > p(101,vector<int>(101,-inf));\n    rep(i,101){\n        rep(j,101){\n            rep(k,a){\n                rep(l,b){\n                    p[i][j] = max(d[k][l]-i*(k+1)-j*(l+1),p[i][j]);\n                }\n            }\n        }\n    }\n    // rep(i,3){\n    //     rep(j,3){\n    //         cerr << i << \" \" << j << \" \" <<  p[i][j] << endl;\n    //     }\n    // }\n    vector<pair<pair<int,int>,int> > edge;\n    vector<vector<pair<int,int> > > g(210);\n    vector<int> x(101);\n    vector<int> y(101);\n    rep(i,101){\n        x[i] = 1+i;\n        y[i] = 202-i;\n    }\n    g[s].push_back(MP(x[0],0));\n    g[y[0]].push_back(MP(t,0));\n    edge.push_back(MP(MP(s,x[0]),0));\n    edge.push_back(MP(MP(y[0],t),0));\n    rep(i,100){\n        g[x[i]].push_back(MP(x[i+1],mod));\n        g[y[i+1]].push_back(MP(y[i],mod/2));\n        edge.push_back(MP(MP(x[i],x[i+1]),mod));\n        edge.push_back(MP(MP(y[i+1],y[i]),mod/2));\n    }\n    rep(i,101){\n        rep(j,101){\n            if(p[i][j]>=0){\n                g[x[i]].push_back(MP(y[j],p[i][j]));\n                edge.push_back(MP(MP(x[i],y[j]),p[i][j]));\n            }\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            int cx = i+1;\n            int cy = j+1;\n            priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >  pq;\n            pq.push(MP(s,0));\n            vector<int> dst(400,inf);\n            dst[s] = 0;\n            while(!pq.empty()){\n                auto x = pq.top();\n                int id = x.first;\n                \n                pq.pop();\n                if(x.second > dst[id])continue;\n                //cerr << id << \" \" << dst[id] << endl;\n                for(auto y:g[id]){\n                    int cs = 0;\n                    if(y.second==mod){\n                        cs = cx;\n                    }else if(y.second==mod/2){\n                        cs = cy;\n                    }else{\n                        cs = y.second;\n                    }\n                    if(dst[y.first]>dst[id]+cs){\n                        dst[y.first] = dst[id]+cs;\n                        pq.push(MP(y.first,dst[y.first]));\n                    }\n                }\n            }\n            //cerr << i << \" \" << j << \" \" << d[i][j] << \" \" <<  dst[t] << endl;\n            if(dst[t]!=d[i][j]){\n                cout <<\"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << edge.size() << endl;\n    for(auto x:edge){\n        cout << x.first.first << \" \" << x.first.second << \" \" ;\n        if(x.second==mod){\n            cout << \"X\" << endl;\n        }else if(x.second==mod/2){\n            cout << \"Y\" << endl;\n        }else{\n            cout << x.second << endl;\n        }\n    }\n    cout << s << \" \" << t << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\nconstexpr int D_MAX = 100;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x_max;\n  int y_max;\n  cin >> x_max >> y_max;\n\n  auto d_matrix = Make2DVector(x_max + 1, y_max + 1, 0);\n  for (int x = 1; x <= x_max; x++) {\n    for (int y = 1; y <= y_max; y++) {\n      cin >> d_matrix[x][y];\n    }\n  }\n\n  auto c_matrix = Make2DVector(D_MAX + 1, D_MAX + 1, 0);\n  for (int a = 0; a <= D_MAX; a++) {\n    for (int b = 0; b <= D_MAX; b++) {\n      for (int x = 1; x <= x_max; x++) {\n        for (int y = 1; y <= y_max; y++) {\n          UpdateMax(c_matrix[a][b], d_matrix[x][y] - a * x - b * y);\n        }\n      }\n    }\n  }\n\n  auto check_fn = [&]() -> bool {\n    for (int x = 1; x <= x_max; x++) {\n      for (int y = 1; y <= y_max; y++) {\n        int d = INT32_MAX;\n        for (int a = 0; a <= D_MAX; a++) {\n          for (int b = 0; b <= D_MAX; b++) {\n            UpdateMin(d, a * x + b * y + c_matrix[a][b]);\n          }\n        }\n        // cout << d << endl;\n        if (d > d_matrix[x][y]) return false;\n      }\n    }\n    return true;\n  };\n\n  if (!check_fn()) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 2 * D_MAX + 2 << \" \" << D_MAX + D_MAX + (D_MAX + 1) * (D_MAX + 1) << endl;\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << 1 + i << \" \" << 1 + i + 1 << \" \" << \"X\" << endl;\n  }\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << D_MAX + 1 + 1 + i << \" \" << D_MAX + 1 + 1 + i + 1 << \" \" << \"Y\" << endl;\n  }\n  for (int a = 0; a <= D_MAX; a++) {\n    for(int b = 0; b <= D_MAX; b++) {\n      cout << 1 + a << \" \" << 2 * D_MAX + 2 - b << \" \" << c_matrix[a][b] << endl;\n    }\n  }\n  cout << 1 << \" \" << 2 * D_MAX + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx=0,idy=0;\n\t\trep0(x,101) rep0(y,101){\n\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\tidx=x,idy=y;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tused[idx][idy]=true;\n\t\tadd(idx,idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 105\n\nint n, m, d[N][N], f[N][N];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tscanf(\"%d\", &d[i][j]);\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tfor(int x = 1; x <= n; x++)\n\t\t\t\tfor(int y = 1; y <= m; y++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t{\n\t\t\tint res = INT_MAX;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tres = min(res, f[i][j] + i * x + y * j);\n\t\t\t// cout << x << ' ' << y << ' ' << res << endl;\n\t\t\tif(d[x][y] != res) \n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 %d\\n\", 101 * 101 + 200);\n\tprintf(\"1 202\\n\");\n\tfor(int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor(int i = 102; i < 202; i++) printf(\"%d %d Y\\n\", i, i + 1);\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 105;\nint f[maxn][maxn][maxn], d[maxn][maxn], ans[maxn][maxn][3];\nint A, B, mxA, mxB, n;\nset<pair<int,int> > s;\n\nint main() {\n\tscanf(\"%d%d\", &A, &B);\n\trep (i, 1, A) rep (j, 1, B) scanf(\"%d\", &d[i][j]);\n\trep (a, 0, 100) rep (b, 0, 100) rep (c, 0, 100) if (a + b + c <= 100) {\n\t\trep (i, 1, A) if (!f[a][b][c])\n\t\t\trep (j, 1, B) if (a * i + b * j + c < d[i][j]) {\n\t\t\t\t//printf(\"%d %d %d\\n\", a, b, c);\n\t\t\t\tf[a][b][c] = 1; break;\n\t\t\t}\n\t}\n\trep (i, 1, A) rep (j, 1, B) {\n\t\tint flag = 0;\n\t\trep (a, 0, 100) if (!flag)\n\t\t\trep (b, 0, 100) if (!flag && a * i + b * j <= d[i][j]) \n\t\t\t\trep (c, 0, 100) if (a * i + b * j + c == d[i][j] && !f[a][b][c]) {\n\t\t\t\t\tans[i][j][0] = a; ans[i][j][1] = b; ans[i][j][2] = c;\n\t\t\t\t\tmxA = max(mxA, a); mxB = max(mxB, b); flag = 1; break;\n\t\t\t\t}\t\t\t\t\n\t\tif (!flag) return puts(\"Impossible\"), 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n = mxA + mxB + 2, mxA + mxB + A * B);\n\trep (i, 1, mxA) printf(\"%d %d X\\n\", i, i + 1);\n\trep (i, n-mxB, n-1) printf(\"%d %d Y\\n\", i, i + 1);\n\trep (i, 1, A) rep (j, 1, B) if (s.find(make_pair(ans[i][j][0]+1, n-ans[i][j][1])) == s.end()) {\n\t\tprintf(\"%d %d %d\\n\", ans[i][j][0]+1, n-ans[i][j][1], ans[i][j][2]);\n\t\ts.insert(make_pair(ans[i][j][0]+1, n-ans[i][j][1]));\n\t}\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u, v, w; \n\n\tEdge (int u, int v, int w) :\n\t\tu(u), v(v), w(w) {}\n};\n\nint n, m, a[10][10];\nint S, T, id;\nvector<Edge> vres;\n\nvoid add(int x, int y, int z) {\n\tint cur = S;\n\t// -1 : A, -2 : B\n\twhile (x--) vres.push_back(Edge(cur, ++id, -1)), cur = id;\n\twhile (y--) vres.push_back(Edge(cur, ++id, -2)), cur = id;\n\tvres.push_back(Edge(cur, T, z));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 2, id = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tassert(id <= 300);\n\tcout << \"Possible\\n\";\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.u << ' ' << i.v << ' ';\n\t\tif (i.w == -1) cout << \"X\\n\";\n\t\tif (i.w == -2) cout << \"Y\\n\";\n\t\tif (i.w >= 0) cout << i.w << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nvector <int> dv;\nvector <int> av;\nvector <int> bv;\nint mn, mx;\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nvoid reconstruct(int x1, int y1, int c1, int x2, int y2, int c2) {\n  puts(\"Possible\");\n  // cerr << x1 << \" \" << y1 << \" \" << c1 << \" \" << x2 << \" \" << y2 << \" \" << c2 << endl;\n  int mxX = max(x1, x2);\n  int mxY = max(y1, y2);\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= mxX; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= mxY; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  addEdge(2 + x1, n - 1 - y1, c1);\n\n  if (x2 != -1) {\n    addEdge(2 + x2, n - 1 - y2, c2);\n  }\n\n  addEdge(1, n, mx);\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  exit(0);\n}\n\nvoid go(int x1, int y1, int c1, int pos) {\n  if (pos == sz(dv)) {\n    reconstruct(x1, y1, c1, -1, -1, -1);\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 < dv[pos]) {\n    return;\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 == dv[pos] || dv[pos] == mx) {\n    go(x1, y1, c1, pos + 1);\n  }\n  for (int x2 = 0; x2 <= 100; x2++) {\n    if (av[pos] * x2 > dv[pos]) {\n      continue;\n    }\n    for (int y2 = 0; y2 <= 100; y2++) {\n      if (av[pos] * x2 + bv[pos] * y2 > dv[pos]) {\n        continue;\n      }\n      // if (x2 == 0 && y2 == 0 && dv[pos] != mx) {\n      //   continue;\n      // }\n      int c2 = dv[pos] - (av[pos] * x2 + bv[pos] * y2);\n      bool good = true;\n      for (int i = pos; i < sz(dv); i++) {\n        if (!(x2 * av[i] + y2 * bv[i] + c2 == dv[i] || \n              x1 * av[i] + y1 * bv[i] + c1 == dv[i] ||\n              dv[i] == mx)) {\n          good = false;\n          break;\n        }\n        if (x1 * av[i] + y1 * bv[i] + c1 < dv[i] || x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (!good) {\n        continue;\n      }\n      for (int i = 0; i < pos; i++) {\n        if (x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        reconstruct(x1, y1, c1, x2, y2, c2);\n      }\n    }\n  }\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  mx = -1, mn = 105;\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n      mn = min(mn, d[i][j]);\n      mx = max(mx, d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      if (j > 0 && d[i][j] < d[i][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n      if (i > 0 && d[i][j] < d[i - 1][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  if (mn == mx) {\n    puts(\"Possible\");\n    cout << 2 << \" \" << 1 << endl;\n    cout << 1 << \" \" << 2 << \" \" << mx << endl;\n    cout << 1 << \" \" << 2 << endl;\n    return 0;\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      dv.push_back(d[i][j]);\n      av.push_back(i + 1);\n      bv.push_back(j + 1);\n    }\n  }\n\n  for (int x1 = 0; x1 <= 100; x1++) {\n    if (1 * x1 > d[0][0]) {\n      continue;\n    }\n    for (int y1 = 0; y1 <= 100; y1++) {\n      if (1 * x1 + 1 * y1 > d[0][0]) {\n        continue;\n      }\n      // if (x1 == 0 && y1 == 0 && d[0][0] != mx) {\n      //   continue;\n      // }\n      int c1 = d[0][0] - x1 - y1;\n      go(x1, y1, c1, 0);\n    }\n  }\n\n  puts(\"Impossible\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint A, B;\nint d[20][20];\n\nint N, M;\nint cost[20][20];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> A >> B;\n    rep(i, A) rep(j, B) cin >> d[i][j];\n\n    N = A + B + 2;\n    M = A + B + (A + 1) * (B + 1);\n\n    rep(i, A + 1) rep(j, B + 1) rep(x, A) rep(y, B)\n        chmax(cost[i][j], d[x][y] - i * x - j * y);\n\n    rep(x, A) rep(y, B) {\n        int mn = 1 << 30;\n        rep(i, A + 1) rep(j, B + 1) chmin(mn, x * i + y * j + cost[i][j]);\n        if(mn != d[x][y]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    cout << N << \" \" << M << \"\\n\";\n\n    rep(i, A) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    rep(j, B) cout << A + j + 2 << \" \" << A + j + 3 << \" Y\\n\";\n\n    rep(i, A + 1) rep(j, B + 1) cout << i + 1 << \" \" << N - j << \" \"\n                                     << cost[i][j] << \"\\n\";\n\n    cout << \"1 \" << N << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 105;\nconst int MM = 1000000007;\n\nint v[MX][MX], D[MX][MX];\npii E[MX][MX];\n\nint main()\n{\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; i++){\n\t\tfor(int j = 1; j <= B; j++){\n\t\t\tscanf(\"%d\", D[i]+j);\n\t\t\tE[i][j] = pii(-1, -1);\n\t\t}\n\t}\n\tfor(int kk = 100; kk >= 0; kk--){\n\t\tfor(int l = kk; l >= 0; l--){\n\t\t\tint k = kk - l;\n\t\t\tint mx = 0;\n\t\t\tfor(int x = 1; x <= A; x++){\n\t\t\t\tfor(int y = 1; y <= B; y++){\n\t\t\t\t\tmx = max(mx, D[x][y] - x*k - y*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[k][l] = mx;\n\t\t\tfor(int x = 1; x <= A; x++){\n\t\t\t\tfor(int y = 1; y <= B; y++){\n\t\t\t\t\tif( mx == D[x][y] - x*k - y*l) E[x][y] = pii(k, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<t3> L;\n\tmap<pii, int> V;\n\tfor(int i = 1; i <= A; i++){\n\t\tfor(int j = 1; j <= B; j++){\n\t\t\tint a = E[i][j].first, b = E[i][j].second;\n\t\t\tif( a == -1 ) return !printf(\"Impossible\\n\");\n\t\t\tL.emplace_back(a, b, v[a][b]);\n\t\t}\n\t}\n\tsort(L.begin(), L.end());\n\tL.erase(unique(L.begin(), L.end()), L.end());\n\n\tint mx = 0, cur = 1;\n\tfor(t3 c : L) mx = max(mx, get<0>(c));\n\tvector<t3> G;\n\tV[pii(0, 0)] = 1;\n\tfor(int i = 1; i <= mx; i++){\n\t\tG.emplace_back(cur, cur+1, -1);\n\t\tcur += 1;\n\t\tV[pii(i, 0)] = cur;\n\t}\n\tfor(int i = 0; i <= mx; i++){\n\t\tint mx2 = 0, prv = i+1;\n\t\tfor(t3 c : L){\n\t\t\tif( get<0>(c) == i ) mx2 = max(mx2, get<1>(c));\n\t\t}\n\t\tfor(int j = 1; j <= mx2; j++){\n\t\t\tG.emplace_back(prv, ++cur, -2);\n\t\t\tV[pii(i, j)] = cur;\n\t\t\tprv = cur;\n\t\t}\n\t}\n\tfor(t3 e : L){\n\t\tint a, b, c;\n\t\ttie(a, b, c) = e;\n\t\tG.emplace_back(V[pii(a, b)], cur+1, c);\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", cur+1, G.size());\n\tfor(t3 e : G){\n\t\tint a, b, c;\n\t\ttie(a, b, c) = e;\n\t\tprintf(\"%d %d \", a, b);\n\t\tif( c == -1 ) printf(\"X\\n\");\n\t\telse if( c == -2 ) printf(\"Y\\n\");\n\t\telse printf(\"%d\\n\", c);\n\t}\n\tprintf(\"1 %d\\n\", cur+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 502;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[N],st2[N],st3[N];\nbool mrk[N];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=1; t=2;\n\trep(a,0,100) rep(b,0,100) {\n\t\tint mx=-1;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-a*i-b*j); if (mx==-1) continue;\n\t\tbool flag=0;\n\t\trep(i,1,n) rep(j,1,m) if (!ok[i][j]&&d[i][j]-a*i-b*j==mx) {ok[i][j]=1; flag=1;}\n\t\tif (!flag) continue;\n\t\tif (sz==300) break; C[a][b]=mx; dy[a][b]=++sz;\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\trep(a,0,100) rep(b,0,100) {\n\t\tif (dy[a][b]&&dy[a+1][b]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a+1][b]; st3[tot]=1;}\n\t\tif (dy[a][b]&&dy[a][b+1]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a][b+1]; st3[tot]=2;}\n\t}\n\trep(a,0,100) rep(b,0,100) if (dy[a][b]) {\n\t\ttot++; st1[tot]=dy[a][b]; st2[tot]=t;\n\t\tmrk[tot]=1; st3[tot]=C[a][b];\n\t}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[0][1]; st3[tot]=2;}\n\tif (dy[1][0]) {tot++; st1[tot]=s; st2[tot]=dy[1][0]; st3[tot]=1;}\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",sz,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"1 2\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nint low[123][123],req[12][12],remain[123][123];\nint main(){\n    std::ios::sync_with_stdio(false);\n    int a,b;\n    cin>>a>>b;\n    int i,j;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tcin>>req[i][j];\n    \t}\n    }\n    rep(i,101){\n    \trep(j,101){\n    \t\tremain[i][j]=1;\n    \t\tlow[i][j]=0;\n    \t}\n    }\n    int val,p,q;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q;\n    \t\t\t\tif(req[i][j]>val){\n    \t\t\t\t\tlow[p][q]=max(low[p][q],req[i][j]-val);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int flag;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tflag=0;\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q+low[p][q];\n    \t\t\t\tif(val==req[i][j]){\n    \t\t\t\t\tremain[p][q]=1;\n    \t\t\t\t\tflag=1;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t\tif(flag==0){\n    \t\t\tcout<<\"Impossible\"<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t}\n    }\n    int edg=0;\n    cout<<\"Possible\"<<endl;\n    cout<<202<<\" \"<<10401<<endl;\n    cout<<201<<\" \"<<1<<\" X\"<<endl;\n    edg++;\n    f(i,1,100){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" X\"<<endl;\n    }\n    edg++;\n    cout<<200<<\" \"<<202<<\" Y\"<<endl;\n    f(i,101,200){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n    }\n    f(i,1,101){\n    \tf(j,1,101){\n    \t\tedg++;\n    \t\tif(remain[i][j]==1)\n    \t\t\tcout<<i<<\" \"<<200-j+1<<\" \"<<low[i][j]<<endl;\n    \t}\n    }\n    f(i,1,101){\n    \tedg++;\n    \tif(remain[0][i]==1)\n    \t\tcout<<201<<\" \"<<200-i+1<<\" \"<<low[0][i]<<endl;\n    }\n    f(i,1,101){\n    \tedg++;\n    \tif(remain[i][0]==1)\n    \t\tcout<<i<<\" \"<<202<<\" \"<<low[i][0]<<endl;\n    }\n    edg++;\n    cout<<201<<\" \"<<202<<\" \"<<low[0][0]<<endl;\n    //cout<<edg<<endl;\n    cout<<201<<\" \"<<202<<endl;\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200 + 5;\n\nint n, m, d[N][N], f[N][N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, 103 + i, 102 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 102 + j, f[i][j]);\n    puts(\"1 102\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0,fff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k&&!flag[i][j])f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1,fff=1;\n\t\t\t\tif (fff)ii=i,jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << \"202 10201\" ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N], ox[N], oy[N], m;\n\nint main() {\n\tmemset(f, -1, sizeof f);\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tif (f[i][j] >= 0) ox[++m] = i, oy[m] = j;\n\t\t\tf[i][j] = std::max(f[i][j], 0);\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\", 200 + m);\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d %d %d\\n\", ox[i] ? ox[i] : 201, oy[i] ? 100 + oy[i] : 202,\n\t\t\t   f[ox[i]][oy[i]]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\tvector<vector<ll>> d(A+1, vector<ll>(B+1));\n\tfor (int i = 1;i <= A;i++)\n\t\tfor (int j = 1;j <= B;j++)\n\t\t\tcin >> d[i][j];\n\tvector<vector<ll>> e(101, vector<ll>(101, 0));\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++)\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\te[ua][ub] = max(e[ua][ub], d[a][b] - (a * ua + b * ub));\n\tbool ok = true;\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++) {\n\t\t\tbool nowok = false;\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\tif (e[ua][ub] + a * ua + b * ub == d[a][b])\n\t\t\t\t\t\tnowok = true;\n\t\t\tok &= nowok;\n\t\t}\n\tif (!ok)\n\t\tcout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << \"202 \" << 101 * 101 + 100 + 100 << endl;\n\t\tfor (int i = 1;i <= 100;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t\tfor (int i = 102;i <= 201;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"Y\" << endl;\n\t\tfor (int ua = 0;ua <= 100;ua++)\n\t\t\tfor (int ub = 0;ub <= 100;ub++)\n\t\t\t\tcout << ua + 1 << \" \" << 202 - ub << \" \" << min(100LL, e[ua][ub]) << endl;\n\t}\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=101;\nint qa,qb,qr[10][10],mp[N+1][N+1];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nbool jdg(){\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tint res=1e9;\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapn(res,(k-1)*i+(N-l)*j+mp[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(res>=qr[i][j]);\n\t\t\tif(res>qr[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tqa=nxi(),qb=nxi();\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tconst int v=qr[i][j]=nxi();\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapx(mp[k][l],v-i*(k-1)-j*(N-l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!jdg()){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N<<1,N*N+2*(N-1));\n\tfor(int i=1; i<N; ++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+N,i+N+1);\n\t}\n\tfor(int i=1; i<=N; ++i){\n\t\tfor(int j=1; j<=N; ++j){\n\t\t\tprintf(\"%d %d %d\\n\",i,j+N,mp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#include <unistd.h>\n//#include <iostream>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n\tint a, b;\n\tcin >> a >> b;\n\tvii d(a, vi(b));\n\trep (i, a) {\n\t\trep (j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tvii used(a, vi(b));\n\n\tvi aa, bb, cc;\n\tint ma = 100;\n\trep (aaa, ma + 1) {\n\t\trep (bbb, ma + 1) {\n\t\t\trep (ccc, ma + 1) {\n\t\t\t\tbool flag = true;\n\t\t\t\tvector<pii> xy;\n\t\t\t\trep1 (x, a) {\n\t\t\t\t\trep1 (y, b) {\n\t\t\t\t\t\tif (aaa * x + bbb * y + ccc < d[x - 1][y - 1]) {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (aaa * x + bbb * y + ccc == d[x - 1][y - 1] and not used[x - 1][y - 1]) {\n\t\t\t\t\t\t\txy.emplace_back(x - 1, y - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (not flag) break;\n\t\t\t\t}\n\t\t\t\tif (not flag) continue;\n\t\t\t\tif (xy.size() > 0) {\n\t\t\t\t\trep (i, xy.size()) {\n\t\t\t\t\t\tused[xy[i].first][xy[i].second] = true;\n\t\t\t\t\t}\n\t\t\t\t\taa.push_back(aaa);\n\t\t\t\t\tbb.push_back(bbb);\n\t\t\t\t\tcc.push_back(ccc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//DEBUG_VEC(aa);\n\t//DEBUG_VEC(bb);\n\t//DEBUG_VEC(cc);\n\n\tbool flag = true;\n\trep (i, a) {\n\t\trep (j, b) {\n\t\t\tif (not used[i][j]) flag = false;\n\t\t}\n\t}\n\tif (not flag) {\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"Possible\" << endl;\n\n\tint n = ma * 2 + 2;\n\tvi u, v, w;\n\trep (i, n / 2 - 1) {\n\t\tu.push_back(i);\n\t\tv.push_back(i + 1);\n\t\tw.push_back(-1);\n\t}\n\trep (i, n / 2 - 1) {\n\t\tu.push_back(n / 2 + i);\n\t\tv.push_back(n / 2 + i + 1);\n\t\tw.push_back(-2);\n\t}\n\trep (i, aa.size()) {\n\t\tu.push_back(aa[i]);\n\t\tv.push_back(n - 1 - bb[i]);\n\t\tw.push_back(cc[i]);\n\t}\n\tcout << n << \" \" << u.size() << endl;\n\trep (i, u.size()) {\n\t\tcout << u[i] + 1 << \" \" << v[i] + 1;\n\t\tif (w[i] == -1) {\n\t\t\tcout << \" \" << \"X\" << endl;\n\t\t}\n\t\telse if (w[i] == -2) {\n\t\t\tcout << \" \" << \"Y\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \" \" << w[i] << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint a[11][11];\nint d[101][101];\n\nint main() {\n\tint i, j, k, l, m, n, t;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) scanf(\"%d\", &a[i][j]);\n\tfor (i = 0; i <= 100; i++) for (j = 0; j <= 100; j++) {\n\t\tt = 0;\n\t\tfor (k = 1; k <= n; k++) for (l = 1; l <= m; l++) {\n\t\t\tif (a[k][l] - i * k - j * l >= t) {\n\t\t\t\tt = a[k][l] - i * k - j * l;\n\t\t\t}\n\t\t}\n\t\td[i][j] = t;\n\t}\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= m; j++) {\n\t\tt = 999;\n\t\tfor (k = 0; k <= 100; k++) for (l = 0; l <= 100; l++) {\n\t\t\tif (d[k][l] + i * k + j * l <= t) {\n\t\t\t\tt = d[k][l] + i * k + j * l;\n\t\t\t}\n\t\t}\n\t\tif (t != a[i][j]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%d %d X\", i + 1, i + 2);\n\t\tprintf(\"%d %d Y\", 201 - i, 202 - i);\n\t}\n\tfor (i = 0; i <= 100; i++) for (j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, 202 - j, d[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint d[11][11];\nint f[101][101];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint A,B;\n\tcin>>A>>B;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tcin>>d[i][j];\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tf[a][b]=max(d[i][j]-i*a-j*b,f[a][b]);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tbool sw=false;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tif(f[a][b]+a*i+b*j==d[i][j])\n\t\t\t\t\t\tsw=true;\n\t\t\tif(!sw){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<101*101+200<<endl;\n\tcout<<201<<' '<<1<<\" X\\n\";\n\tfor(int i=1;i<100;i++)\n\t\tcout<<i<<' '<<i+1<<\" X\\n\";\n\tfor(int i=101;i<200;i++)\n\t\tcout<<i<<' '<<i+1<<\" Y\\n\";\n\tcout<<200<<' '<<202<<\" Y\\n\";\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tif(i==0)\n\t\t\t\tcout<<201;\n\t\t\telse\n\t\t\t\tcout<<i;\n\t\t\tcout<<' ';\n\t\t\tif(j==0)\n\t\t\t\tcout<<202<<' ';\n\t\t\telse\n\t\t\t\tcout<<201-j<<' ';\n\t\t\tcout<<f[i][j]<<'\\n';\n\t\t}\n\tcout<<201<<' '<<202<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tfreopen(\"1.in\", \"w\", stdout);\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\tif (d[x][y] == f[i][j] + i * x + j * y) goto end;\n\t\t\treturn puts(\"Impossible\"), 0;\n\t\tend:;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i ? i : 201, j ? j + 100 : 202, d[i][j]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?101+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  rep(l, 101) rep(m, 101) {\n    reps(x, 1, a+1) reps(y, 1, b+1) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n    //if(n[l][m]) cout<<l<<\" \"<<m<<\" \"<<n[l][m]<<endl;\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e[202];\n    fill(e, e+202, inf);\n    rep(l, 101) e[l] = l*x;\n    rep(l, 101) rep(m, 101) {\n      //if(!m) cout<<e[m+101]<<\" \"<<l<<\":\"<<e[l]<<\"+\"<<n[l][m]<<endl;\n      chmin(e[m+101], e[l]+n[l][m]);\n    }\n    //cout<<e[101]<<endl;\n    for(int m = 100; m > 0; --m) chmin(e[m-1+101], e[m+101]+y);\n    if(e[101] != d[x][y]) {\n      //cout<<x<<\" \"<<y<<\" \"<<e[101]<<endl;\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl;\n  cout << 1 << \" \" << 102 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 110;\n\nint n, m, d[N][N], f[N][N], dd[N][N];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, n) FOR(j, 1, m) scanf(\"%d\", &d[i][j]);\n    FOR(i, 0, 100) FOR(j, 0, 100) FOR(ii, 1, n) FOR(jj, 1, m)\n        f[i][j] = max(f[i][j], d[ii][jj] - i * ii - j * jj);\n    FOR(ii, 1, n) FOR(jj, 1, m)\n    {\n        dd[ii][jj] = 1e9;\n        FOR(i, 0, 100) FOR(j, 0, 100)\n            dd[ii][jj] = min(dd[ii][jj], i * ii + j * jj + f[i][j]);\n        if (dd[ii][jj] != d[ii][jj]) {puts(\"Impossible\"); return 0;}\n    }\n    puts(\"Possible\"); puts(\"202 10401\");\n    FOR(i, 1, 100) printf(\"%d %d X\\n\", i, i + 1);\n    FOR(i, 102, 201) printf(\"%d %d Y\\n\", i, i + 1);\n    FOR(i, 0, 100) FOR(j, 0, 100) printf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    set<P> s;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void add(ll from, ll to, string label) {\n        if (s.count({from, to}) > 0) return;\n        s.insert({from, to});\n        edges.pb({from, to, label});\n    }\n    void addX(ll from, ll to) {\n        add(from, to, \"X\");\n    }\n    void addY(ll from, ll to) {\n        add(from, to, \"Y\");\n    }\n    void add(ll from, ll to, ll cost) {\n        add(from, to, to_string(cost));\n    }\n    void output(ll s, ll t) {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << s+1 << \" \" << t+1 << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<ll> xid(101), yid(101);\n    rep(i, 101) xid[i] = V++;\n    rep(i, 101) yid[i] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    G.add(s, xid[0], 0);\n    rep(i, 100) G.addX(xid[i], xid[i+1]);\n    rep(i, 100) G.addY(yid[i+1], yid[i]);\n    rep(a, A) rep(b, B) {\n        G.add(xid[X[a][b]], yid[Y[a][b]], Z[a][b]);\n    }\n    G.add(yid[0], t, 0);\n    G.output(s, t);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,d[105][105],f[105][105];\nint main()\n{\n    scanf(\"%d%d\",&x,&y);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j)\n            scanf(\"%d\",&d[i][j]);\n    for (int a=0;a<=100;++a)\n        for (int b=0;b<=100;++b)\n            for (int i=1;i<=x;++i)\n                for (int j=1;j<=y;++j)\n                    f[a][b]=max(f[a][b],d[i][j]-a*i-b*j);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j) {\n            int dis=10000000;\n            for (int a=0;a<=100;++a)\n                for (int b=0;b<=100;++b)\n                    dis=min(dis,f[a][b]+a*i+b*j);\n            if (dis!=d[i][j]) return 0*puts(\"Impossible\");\n        }\n    puts(\"Possible\");\n    for (int i=1;i<=100;++i) printf(\"%d %d X\\n\",i,1+i);\n    for (int i=1;i<=100;++i) printf(\"%d %d Y\\n\",101+i,102+i);\n    for (int i=1;i<=101;++i)\n        for (int j=1;j<=101;++j)\n            printf(\"%d %d %d\\n\",i,203-j,f[i-1][j-1]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 210;\nint d[N][N];\n\nstruct Edge {\n    int u, v;\n    string c;\n};  \n\nint f[N][N];\n\nint g[N][N];\n\n//change to 100!\nconst int LEN = 100;\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int A, B;\n    cin >> A >> B;\n    for (int i = 1; i <= A; ++i)\n        for (int j = 1; j <= B; ++j)\n            cin >> d[i][j];    \n\n    int S = 1;\n    int T = 2;\n    int ptr = 3;\n    vector <Edge> ans;\n\n    int lx = ptr;\n    ans.app({S, ptr, \"X\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"X\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"X\"});\n    int rx = ptr - 1;\n\n    \n    int ly = ptr;\n    ans.app({S, ptr, \"Y\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"Y\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"Y\"});\n    int ry = ptr - 1;\n    \n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) {\n            for (int x = 0; x <= 100; ++x) {\n                for (int y = 0; y <= 100; ++y) {\n\n                    int have = x * i + y * j;\n                    if (have < d[i][j]) {\n                        f[x][y] = max(f[x][y], d[i][j] - have);\n                    }   \n                \n                }   \n            }   \n        }   \n    }   \n\n    for (int x = 0; x <= LEN/2; ++x) {\n        for (int y = 0; y <= LEN/2; ++y) {\n\n            int u = lx + x - 1;\n            if (x == 0)\n                u = S;\n\n            int v = ry - y + 1;\n            if (y == 0)\n                v = T;\n\n            if (f[x][y] > 100)\n                continue;\n\n            ans.app({u, v, to_string(f[x][y])});\n        }   \n    }   \n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            const int INF = 1e9+7;\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    g[i][j] = INF;\n            for (auto e : ans) {\n                if (e.c == \"X\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], x);\n                }   \n                else if (e.c == \"Y\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], y);\n                }\n                else {\n                    g[e.u][e.v] = min(g[e.u][e.v], stoi(e.c));\n                }   \n            }\n            \n            for (int k = 0; k < N; ++k)\n                for (int u = 0; u < N; ++u)\n                    for (int v = 0; v < N; ++v)\n                        g[u][v] = min(g[u][v], g[u][k]+g[k][v]);       \n\n            if (g[S][T] != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                exit(0);\n            }   \n        }\n    }    \n    \n    for (auto e : ans) {\n        if (e.u == e.v) {\n            cout << \"LMAO\" << endl;\n            exit(1);                        \n        }   \n    }   \n    for (int i = 0; i < ans.size(); ++i)\n        for (int j = i + 1; j < ans.size(); ++j) {\n            if (ans[i].u == ans[j].u && ans[i].v == ans[j].v) {\n                cout << \"LMAO\" << endl;\n                exit(1);\n            }   \n        }   \n\n    cout << \"Possible\" << endl;\n    cout << 300 << ' ' << ans.size() << endl;\n    for (auto e : ans)\n        cout << e.u << ' ' << e.v << ' ' << e.c << endl;\n    cout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct edge {\n\tint from,to,weight;\n} e[100009];int en;\nvoid adde(int a,int b,int w) {\n\te[en].from = a;\n\te[en].to = b;\n\te[en].weight = w;\n\t++en;\n}\nint arr[13][13];\nint main()\n{\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i = 1;i <= 99;++i) adde(i,i+1,-10002);\n\tfor(int i = 1;i <= 99;++i) adde(100+i,101+i,-10001);\n\tfor(int i = 1;i <= a;++i) {\n\t\tfor(int j = 1;j <= b;++j) {\n\t\t\tscanf(\"%d\",&arr[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= a;++i) {\n\t\tfor(int j = 1;j <= b;++j) {\n\t\t\tif(arr[i][j] - arr[i-1][j] - arr[i][j-1] + arr[i-1][j-1] < 0) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x,y,z;\n\t\t\tif(i == a && j == b)\n\t\t\t\tx = 0;\n\t\t\telse if(j == b)\n\t\t\t\tx = arr[i+1][j] - arr[i][j];\n\t\t\telse\n\t\t\t\tx = arr[i+1][j+1] - arr[i][j+1];\n\t\t\tif(i == a && j == b)\n\t\t\t\ty = 0;\n\t\t\telse if(i == a)\n\t\t\t\ty = arr[i][j+1] - arr[i][j];\n\t\t\telse\n\t\t\t\ty = arr[i+1][j+1] - arr[i+1][j];\n\t\t\tz = arr[i][j] - x - y;\n\t\t\tif(x < 0 || y < 0 || z < 0) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tadde(1+x,200-y,z);\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",300,en);\n\tfor(int i = 0;i < en;++i) {\n\t\tprintf(\"%d %d \",e[i].from,e[i].to);\n\t\tif(e[i].weight == -10002)\n\t\t\tprintf(\"X\\n\");\n\t\telse if(e[i].weight == -10001)\n\t\t\tprintf(\"Y\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",e[i].weight);\n\t}\n\tprintf(\"%d %d\\n\",1,200);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\n#define mp make_pair\n#define pb push_back\n#define ld long double\n#define pii pair<int,int>\n#define sz(x) (int)x.size()\n#define piii pair<pii,pii>\n#define precise cout<<fixed<<setprecision(10)\n#define st first\n#define nd second\n#define ins insert\n#define vi vector<int>\n#define BOOST ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\nusing namespace std;\nconst int MAX=105;\nconst int inf=1e9+9;\nint tab[MAX][MAX];\nint f[MAX][MAX];\nint32_t main()\n{\n  BOOST;\n  int n,m;\n  cin>>n>>m;\n  for (int i=1;i<=n;i++)\n  \tfor (int j=1;j<=m;j++)\n  \t\tcin>>tab[i][j];\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n       for (int k=1;k<=n;k++)\n         for (int l=1;l<=m;l++)\n           f[i][j]=max(f[i][j],tab[k][l]-i*k-j*l);\n           \n  for (int i=1;i<=n;i++)\n    for (int j=1;j<=m;j++)\n    {\n    \tint mini=inf;\n    \tfor (int k=0;k<=100;k++)\n    \t  for (int l=0;l<=100;l++)\n    \t    mini=min(mini,f[k][l]+i*k+j*l);\n    \tif (mini!=tab[i][j])cout<<\"Impossible\",exit(0);\n    }\n   \n    cout<<\"Possible\\n\";\n  cout<<\"202 \"<<\"10401\\n\";\n  for (int i=1;i<=100;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"X\"<<\"\\n\";\n  for (int i=101;i<=201;i++)cout<<i<<\" \"<<i+1<<\" \"<<\"Y\"<<\"\\n\";\n  for (int i=0;i<=100;i++)\n    for (int j=0;j<=100;j++)\n      cout<<i+1<<\" \"<<202-j<<\" \"<<f[i][j]<<\"\\n\";\n  cout<<\"1 \"<<\"202\";\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)+1<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tcout<<M+1<<' '<<M+2<<' '<<0<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+1<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 110;\n\nint n, m, d[N][N], f[N][N], dd[N][N];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, n) FOR(j, 1, m) scanf(\"%d\", &d[i][j]);\n    FOR(i, 0, 100) FOR(j, 0, 100) FOR(ii, 1, n) FOR(jj, 1, m)\n        f[i][j] = max(f[i][j], d[ii][jj] - i * ii - j * jj);\n    FOR(ii, 1, n) FOR(jj, 1, m)\n    {\n        dd[ii][jj] = 1e9;\n        FOR(i, 0, 100) FOR(j, 0, 100)\n            dd[ii][jj] = min(dd[ii][jj], i * ii + j * jj + f[i][j]);\n        if (dd[ii][jj] != d[ii][jj]) {puts(\"Impossible\"); return 0;}\n    }\n    printf(\"202 10201\");\n    FOR(i, 0, 100) FOR(j, 0, 100) printf(\"%d %d %d\\n\", i + 1, j + 102);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(int)(n); ++i)\n#define maxn 100005\nstruct edge{\n    int x, y, c;\n    edge(int _x, int _y, int _c):x(_x), y(_y), c(_c){}\n};\nint d[10][10], b[10][10];\nint a[100][100];\nint hit_i[100][100][10];\nint hit_j[100][100][10];\nbool need[100][100];\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> d[i][j];\n    }\n    rep(s,100)rep(t,100){\n        rep(i,n)rep(j,m){\n            a[s][t] = max(d[i][j] - (i + 1) * s - (j + 1) * t, a[s][t]);\n        }\n    }\n    // rep(s, 100){\n    //     rep(t, 100) cout << a[s][t] << ' ';\n    //     cout << endl;\n    // }\n    rep(i,n)rep(j,m){\n        b[i][j] = 1000000;\n        rep(s,100)rep(t,100){\n            b[i][j] = min(b[i][j], (i + 1) * s + (j + 1) * t + a[s][t]);\n            if((i + 1) * s + (j + 1) * t + a[s][t] == d[i][j]){\n                hit_i[s][t][i]  = 1;\n                hit_j[s][t][j]  = 1;\n            }\n        }\n        if(b[i][j] > d[i][j]){\n            cout << \"Impossible\" << endl;\n            return;\n        }\n    }\n\n    rep(s, 100)rep(t, 100){\n        int cnt = 0;\n        rep(i, n) cnt += hit_i[s][t][i];\n        if (cnt < 2) continue;\n        cnt = 0;\n        rep(j, m) cnt += hit_j[s][t][j];\n        if (cnt < 2) continue;\n        need[s][t] = 1;\n    }\n\n    int S, T, node;\n    S = 1;\n    T = 2;\n    node = 3;\n    vector<edge> e; e.clear();\n    rep(s,100)rep(t,100) if(need[s][t]){\n        // s X + t Y + a[s][t]\n        vector<int> v;\n        v.clear();\n        rep(_, s) v.push_back(-2);\n        rep(_, t) v.push_back(-1);\n        rep(_, a[s][t] / 100) v.push_back(100);\n        if(a[s][t] % 100 > 0) v.push_back(a[s][t] % 100);\n        int last = S;\n        rep(i, v.size()){\n            if (i == v.size() - 1) e.push_back(edge(last, T, v[i]));\n            else{\n                e.push_back(edge(last, node, v[i]));\n                last = node;\n                node ++;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << node - 1 << ' ' << e.size() << endl;\n    for(auto p: e){\n        cout << p.x << ' ' << p.y << ' ';\n        if(p.c == -2) cout << 'X'; else\n        if(p.c == -1) cout << 'Y'; else\n        cout << p.c;\n        cout << endl;\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define min(a,b) ((a)<(b)? (a):(b))\n#define max(a,b) ((a)>(b)? (a):(b))\nint d[15][15],f[105][105];\nint main() {\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tscanf(\"%d\",&d[x][y]);\n\t\t}\t\n\t}\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tfor(register int x=1;x<=n;++x) {\n\t\t\t\tfor(register int y=1;y<=m;++y) {\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(f[i][j]>0) printf(\"%d \",f[i][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n//\tgetchar();getchar();\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tint minn=105;\n\t\t\tfor(register int i=0;i<=100;++i) {\n\t\t\t\tfor(register int j=0;j<=100;++j) {\n\t\t\t\t\tminn=min(minn,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minn!=d[x][y])  {printf(\"Impossible\\n\");return 0;}\n\t\t}\n\t}\n\tprintf(\"202 10401\\n\");\n\tfor(register int x=1;x<=100;++x) printf(\"%d %d X\\n\",x,x+1);\n\tfor(register int x=101;x<=201;++x) printf(\"%d %d Y\\n\",x,x+1);\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\n#define int ll\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nsigned main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\"=\"<<x<<endl\n#define DEBUG2(x,y) cout<<#x<<\"=\"<<x<<\",\"<<#y<<\"=\"<<y<<endl\ntypedef long long ll;\nclass Solver{\npublic:\n    static const int MAXD=11;\n    int A,B;\n    int d[MAXD][MAXD];\n    int f[MAXD*MAXD][MAXD*MAXD];\n    void solve(){\n        cin>>A>>B;\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++)\n                cin>>d[x][y];\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        f[a][b]=max(f[a][b],d[x][y]-x*a-y*b);\n                    }\n                }\n            }\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                int mmin=1e9;\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        mmin=min(mmin,x*a+y*b+f[a][b]);\n                    }\n                }\n                if(mmin!=d[x][y]){\n                    cout<<\"Impossible\\n\";\n                    return;\n                }\n            }\n        }\n        cout<<\"Possible\\n\";\n        cout<<300<<\" \"<<101*101+298<<\"\\n\";\n        for(int u=1;u<150;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'X'<<\"\\n\";\n        }\n        for(int u=151;u<300;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'Y'<<\"\\n\";\n        }\n        for(int u=0;u<=100;u++){\n            for(int v=0;v<=100;v++){\n                cout<<u+1<<\" \"<<300-v<<\"  \"<<f[u][v]<<\"\\n\";\n            }\n        }\n        cout<<1<<\" \"<<300;\n    }\n};\nint main()\n{\n    // freopen(\"in.txt\",\"r\",stdin);\n    (new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\n\nint main(int argc, char const *argv[]) {\n  // 不可能なものを削る\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n  vector<tp> use;\n  for(ll i=0;i<=99;i++){\n    for(ll j=0;j<=99;j++){\n      for(ll k=0;k<=100;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        break;\n        nxt:;\n      }\n    }\n  }\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n\n  std::cout << \"Possible\" << '\\n';\n  vvl e;\n  vvl ok = VV(301, 301, 0, ll);\n\n\n  for(int i=1;i<100;i++){\n    ok[i][i+1] = 1;\n    e.push_back({i, i+1, -1});\n  }\n  for(int i=1;i<100;i++){\n    ok[i+200][i+201] = 1;\n    e.push_back({i+200, i+201, -2});\n  }\n\n  for(auto v:use){\n    ll i = get<0>(v);\n    ll j = get<1>(v);\n    ll k = get<2>(v);\n    ll x = i+1;\n    ll y = 300 - j;\n    if(ok[x][y]) return 1;\n    ok[x][y] = 1;\n    e.push_back({x, y, k});\n  }\n\n  //------output area-----\n  std::cout << \"300 \" << e.size() << '\\n';\n  for(auto v:e){\n    std::cout << v[0] << \" \" << v[1] << \" \";\n    if(v[2]==-1) std::cout << \"X\" << '\\n';\n    else if(v[2]==-2) std::cout << \"Y\" << '\\n';\n    else std::cout << v[2] << '\\n';\n  }\n  std::cout << \"1 300\" << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <utility>\n#include <iterator>\n#include <functional>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(1, A + 1))\n        RDV(d[i] + 1, d[i] + B + 1);\n\n    vector<pair<int, int>> adj[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(1, A + 1))\n        for(int j: RG(1, B + 1))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    bool check = true;\n                    for(int ii = 1; ii <= A && check; ii++)\n                        for(int jj: RG(1, B + 1))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else if(adj[xx + 1].size() == 1 - (xx + 1 == 101))\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n\n\n\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\t//freopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N*2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+1;i<N*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i+1,i);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,N+j+1,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a < N; ++a)\n\t\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a < N; ++a)\n\t\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"Impossible\");\n\telse\n\t{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + (N+1)*(N+1));\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a < N; ++a)\n\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b;\nint v[20][20];\nbool taken[20][20];\nvector<pair<int, int> > adj[110];\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &v[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tif (i + j + k > 100) break;\n\t\t\t\tbool works = true;\n\t\t\t\tbool canhelp = false;\n\t\t\t\tfor (int x = 1; x <= a && works; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k < v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworks = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i * x + j * y + k == v[x][y] && !taken[x][y]) canhelp = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!works) continue;\n\t\t\t\tif (!canhelp) continue;\n\t\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k == v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttaken[x][y] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadj[i].emplace_back(j, k);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tif (!taken[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint constant = a*b;\n\t// 1 = sink\n\t// 2 - 101 = that many xs\n\t// 102 - 201 = that many ys\n\t// 202 (2*constant + 2) sink\n\tprintf(\"Possible\\n\");\n\tvector<pair<pair<int, int> , char> > out;\n\tvector<pair<pair<int, int> , int> > out2;\n\tprintf(\"%d \", 2*constant+2);\n\tfor (int i = 1; i <= constant; i++)\n\t{\n\t\tout.emplace_back(make_pair(i, i+1), 'X');\n\t//\tprintf(\"%d %d X\\n\", i, i+1);\n\t\tout.emplace_back(make_pair(i+constant+1, i+constant+2), 'Y');\n\t//\tprintf(\"%d %d Y\\n\", i+constant+1, i + constant+2);\n\t}\n\tfor (int i = 0; i <= constant; i++)\n\t{\n\t\tfor (auto a : adj[i])\n\t\t{\n\t\t\tint y = a.first;\n\t\t\ty = constant-y;\n\t\t\t// 0 if 100\n\t\t\ty += constant+2;\n\t\t\tint wei = a.second;\n\t\t\tout2.emplace_back(make_pair(i+1, y), wei);\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", out.size() + out2.size());\n\tfor (auto a : out) printf(\"%d %d %c\\n\", a.first.first, a.first.second, a.second);\n\tfor (auto a : out2) printf(\"%d %d %d\\n\", a.first.first, a.first.second, a.second);\n\tprintf(\"%d %d\\n\", 1, 2*constant+2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nstruct Edge{\n  int u, v, w;\n  Edge(){}\n  Edge(int u, int v, int w){\n    this -> u = u;\n    this -> v = v;\n    this -> w = w;\n  }\n};\nbool operator<(const Edge& a, const Edge& b){\n  return tie(a.u, a.v, a.w) < tie(b.u, b.v, b.w);\n}\nbool operator==(const Edge& a, const Edge& b){\n  return tie(a.u, a.v, a.w) == tie(b.u, b.v, b.w);\n}\nstring conv(int w){\n  if(w == -1)\n    return \"X\";\n  else if(w == -2)\n    return \"Y\";\n  else\n    return to_string(w);\n\n}\nint main(){\n//  freopen(\"connect.in\", \"r\", stdin);\n//  freopen(\"connect.out\", \"w\", stdout);\n//  freopen(\"in.txt\", \"r\", stdin);\n//  freopen(\"out.txt\", \"w\", stdout);\n  int a, b;\n  cin >> a >> b;\n  int arr[10][10];\n  for(int i = 0;i < a;i++)\n    for(int j = 0;j < b;j++)\n      scanf(\"%d\", arr[i] + j);\n  for(int i = 0;i < a;i++){\n    for(int j = 0;j < b;j++){\n      if(i && arr[i][j] < arr[i - 1][j]){\n        cout << \"Impossible\";\n        return 0;\n      }\n      if(j && arr[i][j] < arr[i][j - 1]){\n        cout << \"Impossible\";\n        return 0;\n      }\n    }\n  }\n//  assert(false);\n  vector<Edge> es;\n  for(int i = 0;i < 100;i++){\n    es.push_back(Edge(i, i + 1, -1));\n  }\n  es.push_back(Edge(100, 101, 100));\n  for(int j = 0;j < 100;j++)\n    es.push_back(Edge(100 + j + 1, 100 + j + 2, -2));\n  int cur = 202;\n  for(int i = 0;i < a;i++){\n    for(int j = 0;j < b;j++){\n      int x, y;\n      x = i + 1;\n      y = j + 1;\n      bool done = 0;\n      for(int c = 0;c <= 100;c++){\n        for(int nx = 0;nx <= 100;nx++){\n          int ny = (arr[i][j] - nx * x - c) / y;\n          if((arr[i][j] - nx * x - c) % y || ny < 0)\n            continue;\n          bool good = 1;\n          for(int k = 0;k < a;k++){\n            for(int m = 0;m < b;m++){\n              if(c + nx * (k + 1) + ny * (m + 1) < arr[k][m]){\n                good = 0;\n                break;\n              }\n            }\n            if(!good)\n              break;\n          }\n          if(good){\n            es.push_back(Edge(nx, 201 - ny, c));\n            done = 1;\n            break;\n          }\n        }\n        if(done)\n          break;\n      }\n      if(!done){\n        cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\\n\";\n  sort(es.begin(), es.end());\n  es.erase(unique(es.begin(), es.end()), es.end());\n  cout << \"202 \" << es.size() << endl;\n  for(auto el : es){\n    cout << el.u + 1 << ' ' << el.v + 1 << ' ' << conv(el.w) << endl;\n  }\n  cout << \"1 202\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 2005\nusing namespace std;\nint a,b,tot;\nint d[maxn][maxn];\nint dis[maxn][maxn];\nint head[maxn],nex[maxn*maxn],to[maxn*maxn];\nstring val[maxn*maxn];\nvoid add(int x,int y,string z)\n{\n\tto[++tot]=y; val[tot]=z; nex[tot]=head[x]; head[x]=tot;\n}\nint main()\n{\n\tmemset(dis,0x3f,sizeof(dis));\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\n\tfor(int i=1;i<=100;i++)\n\t\tadd(i,i+1,\"X\");\n\n\tfor(int i=102;i<=201;i++)\n\t\tadd(i,i+1,\"Y\");\n\t\n//\tcerr<<\"+2\"<<endl;\n\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint temp=0;\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\ttemp=max(temp,d[k][o]-k*i-o*j);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr<<\"its \"<<i<<\" \"<<j<<endl;\t\n\t\t\tadd(i+1,202-j,to_string(temp));\n\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\tdis[k][o]=min(dis[k][o],temp+i*k+o*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcerr<<\"+1\"<<endl;\n\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\tif(dis[i][j]!=d[i][j])\n\t\t{\n//\t\t\tcerr<<d[i][j]<<' '<<dis[i][j]<<endl;\n\t\t\treturn printf(\"Impossible\\n\"),0;\n\t\t}\n\t}\n\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,tot);\t\n\tfor(int i=1;i<=202;i++)\n\t{\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t{\n\t\t\tcout<<i<<\" \"<<to[j]<<\" \"<<val[j]<<endl;\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nbool exi[301][301];\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 202, cur = 3;\n\tRep1(i, 2, 101) {\n\t\tv.push_back({ i - 1,i,\"X\" });\n\t}\n\tRep1(i, 102, 201) {\n\t\tv.push_back({ i,i + 1,\"Y\" });\n\t}\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tbool ansed = false;\n\t\t\trep(l, 101) {\n\t\t\t\trep(r, 101) {\n\t\t\t\t\tint z = d[i][j] - l * i - r * j;\n\t\t\t\t\tif (z < 0)continue;\n\t\t\t\t\tbool f = true;\n\t\t\t\t\trep1(i_, a) {\n\t\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tint sta = 1 + l;\n\t\t\t\t\t\tint goa = 202 - r;\n\t\t\t\t\t\tif (!exi[sta][goa])v.push_back({ sta,goa,to_string(z) });\n\t\t\t\t\t\texi[sta][goa] = true;\n\t\t\t\t\t\tansed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ansed)break;\n\t\t\t}\n\t\t\tif (!ansed)valid = false;\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << 202 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 202\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ninline int Min(int a,int b){return a<b?a:b;}\ninline int Max(int a,int b){return a>b?a:b;}\n\nconst int N=305,Inf=0x3f3f3f3f;\nint n,m,f[N][N],d[N][N];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=m;++j)\n            scanf(\"%d\",&d[i][j]);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            for(int x=1;x<=n;++x)\n                for(int y=1;y<=m;++y)\n                    f[i][j]=Max(f[i][j],d[x][y]-i*x-j*y);\n    for(int x=1;x<=n;++x)\n        for(int y=1;y<=m;++y)\n        {\n            int Now=Inf;\n            for(int i=0;i<=100;++i)\n                for(int j=0;j<=100;++j)\n                    Now=Min(Now,f[i][j]+i*x+j*y);\n            if(Now!=d[x][y])return puts(\"Impossible\"),0;\n        }\n    puts(\"Possible\\n202 10401\");\n    for(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n    for(int i=102;i<=201;++i)printf(\"%d %d Y\\n\",i,i+1);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    return puts(\"1 202\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint A, B;\nint D[11][11];\nint C[101][101];\nint main() {\n\tcin >> A >> B;\n\n\tREP(i, 0, A) {\n\t\tREP(j, 0, B) {\n\t\t\tcin >> D[i + 1][j + 1];\n\t\t}\n\t}\n\n\tREP(x, 0, 101) {\n\t\tREP(y, 0, 101) {\n\t\t\tREP(a, 1, A + 1) {\n\t\t\t\tREP(b, 1, B + 1) {\n\t\t\t\t\tC[x][y] = max(C[x][y], D[a][b] - (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok = 1;\n\tREP(a, 1, A + 1) {\n\t\tREP(b, 1, B + 1) {\n\t\t\tint mn = INF;\n\t\t\tREP(x, 0, 101) {\n\t\t\t\tREP(y, 0, 101) {\n\t\t\t\t\tmn = min(mn, C[x][y] + (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != D[a][b]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (ok ? \"Possible\" : \"Impossible\") << endl;\n\tif (ok) {\n\t\tint X = 1;\n\t\tint Y = 1;\n\t\tcout << X + Y + 1 << ' ' << (X + 1) * (Y + 1) + X + Y - 1 << endl;\n\t\tREP(i, 0, X) {\n\t\t\tcout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n\t\t}\n\t\tREP(i, 0, Y) {\n\t\t\tcout << i + X + 1 << ' ' << i + X + 2 << \" Y\" << endl;\n\t\t}\n\n\t\tint S = X + 1;\n\t\tREP(i, 0, X + 1) {\n\t\t\tREP(j, 0, Y + 1) {\n\t\t\t\tif (i == X && j == Y) continue;\n\t\t\t\tcout << S - (X - i) << ' ' << S + (Y - j) << ' ' << C[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a < N; ++a)\n\t\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a < N; ++a)\n\t\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"Impossible\");\n\telse\n\t{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + N*N);\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a < N; ++a)\n\t\t\tfor(int b = 0; b < N; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nconst int INF = 999999999;\n\nint n, m, d[55][55], f[550][550], tmp[55][55];\n\nvoid Read(int &x)\n{\n    x = 0; int p = 0; char st = getchar();\n    while (st < '0' || st > '9') p = (st == '-'), st = getchar();\n    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();\n    x = p ? -x : x;\n    return;\n}\n\nint Max(int a, int b)\n{\n    return a > b ? a : b;\n}\n\nint Min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            scanf(\"%d\", &d[i][j]);\n\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++) \n            for (int x = 1; x <= n; x++)\n                for (int y = 1; y <= m; y++)\n                    f[i][j] = Max(f[i][j], d[x][y] - i * x - j * y);\n\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            tmp[x][y] = INF;\n            for (int i = 0; i <= 100; i++)\n                for (int j = 0; j <= 100; j++)\n                    tmp[x][y] = Min(tmp[x][y], i * x + j * y + f[i][j]);\n        }\n\n\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if(tmp[i][j] != d[i][j])\n            {\n                puts(\"Impossible\"); return 0;\n            }\n\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 10401);\n    for (int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << n-1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tfreopen(\"tmp.out\",\"w\",stdout);\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"202 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<202;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int MAX = 100;\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > d(n+1, vector<int>(m+1));\n    for(int x=1; x<=n; ++x){\n        for(int y=1; y<=m; ++y){\n            cin >> d[x][y];\n        }\n    }\n\n    int size = 2 * MAX + 2;\n    vector<tuple<int, int, int>> ans;\n    for(int i=0; i<MAX; ++i)\n        ans.push_back(make_tuple(i, i+1, -1));\n    for(int i=0; i<MAX; ++i)\n        ans.push_back(make_tuple(size-2-i, size-1-i, -2));\n\n    vector<vector<bool> > check(n+1, vector<bool>(m+1, false));\n    int cnt = n * m;\n    for(int a=0; a<=MAX; ++a){\n        for(int b=0; b<=MAX; ++b){\n            int c = 0;\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    c = max(c, tmp);\n                }\n            }\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    if(tmp == c && !check[x][y]){\n                        check[x][y] = true;\n                        -- cnt;\n                    }\n                }\n            }\n            if(c <= MAX)\n                ans.push_back(make_tuple(a, 2*MAX+1-b, c));\n        }\n    }\n\n    if(cnt == 0){\n        cout << \"Possible\" << endl;\n        cout << size << ' ' << ans.size() << endl;\n        for(const auto& t : ans){\n            int a, b, c;\n            tie(a, b, c) = t;\n            ++ a;\n            ++ b;\n            cout << a << ' ' << b << ' ';\n            if(c == -1)\n                cout << 'X' << endl;\n            else if(c == -2)\n                cout << 'Y' << endl;\n            else\n                cout << c << endl;\n        }\n        cout << 1 << ' ' << size << endl;\n    }\n    else{\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    int matrix[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++) cin >> matrix[i][j];\n    }\n    int mnx[a][b], mny[a][b], mxx[a][b], mxy[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            mnx[i][j] = 0;\n            mny[i][j] = 0;\n            mxx[i][j] = matrix[i][j] / (i+1);\n            mxy[i][j] = matrix[i][j] / (j+1);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b-1; j++){\n            int D = matrix[i][j+1] - matrix[i][j];\n            mny[i][j] = max(mny[i][j], D);\n            mxy[i][j+1] = min(mxy[i][j+1], D);\n        }\n    }\n    for (int i=0; i < a-1; i++){\n        for (int j=0; j < b; j++){\n            int D = matrix[i+1][j] - matrix[i][j];\n            mnx[i][j] = max(mnx[i][j], D);\n            mxx[i+1][j] = min(mxx[i+1][j], D);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            if (mnx[i][j] > mxx[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mny[i][j] > mxy[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mnx[i][j] * (i+1) + mny[i][j] * (j+1) > matrix[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    //cout << mxx[0][1] << \" \" << mxy[0][1] << endl;\n    int sv = 3;\n    vector<pair<int, int> > reb;\n    vector<int> wh;\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            int K, L, res = -1;\n            for (int k=mnx[i][j]; k <= mxx[i][j]; k++){\n                for (int l=mny[i][j]; l <= mxy[i][j]; l++){\n                    int re = k * (i+1) + l * (j+1);\n                    if (re > matrix[i][j]) continue;\n                    int N = k+l+(re != matrix[i][j]);\n                    if (N > res){\n                        res = N;\n                        K = k;\n                        L = l;\n                    }\n                }\n            }\n            int last = 1;\n            for (int k=0; k < K; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-1);\n                last = sv;\n                sv++;\n            }\n            for (int k=0; k < L; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-2);\n                last = sv;\n                sv++;\n            }\n            reb.push_back(make_pair(last, 300));\n            wh.push_back(matrix[i][j] - K * (i+1) - L * (j+1));\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << reb.size() << endl;\n    for (int i=0; i < reb.size(); i++){\n        cout << reb[i].first << \" \" << reb[i].second << \" \";\n        if (wh[i] == -1) cout << \"X\" << endl;\n        else if (wh[i] == -2) cout << \"Y\" << endl;\n        else cout << wh[i] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * (i + 1) + (k + 1) * (j + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 1, j + a, to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j, j+1);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 505\n#define MAXN 149\n#define INF 1000000000\nusing namespace std;\nint n,m,f[M][M],g[M][M],S,T;\nint read(){\n\tchar c=getchar();int ans=0;\n    while (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans;\n}\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n\tn=read(),m=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++) f[i][j]=read();\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tfor (register int k=1;k<=n;k++)\n\t\t\t\tfor (register int l=1;l<=m;l++)\n\t\t\t\t\tg[i][j]=max(g[i][j],f[k][l]-k*i-l*j);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++){\n\t\t\tint now=INF;\n\t\t\tfor (register int k=0;k<=MAXN;k++)\n\t\t\t\tfor (register int l=0;l<=MAXN;l++)\n\t\t\t\t\tnow=min(now,k*i+l*j+g[k][l]);\n\t\t\tif (now!=f[i][j]){printf(\"Impossible\");return 0;}\n\t\t}\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tif (g[i][j]>100){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n%d %d\\n\",MAXN+MAXN+1,(MAXN+1)*(MAXN+1)+2*MAXN);\n\tS=1,T=MAXN+MAXN+1;\n\tfor (register int i=1;i<=MAXN;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (register int i=MAXN+1;i<=MAXN+MAXN;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,MAXN+MAXN-j+1,g[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)44e12;//ごめん\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint main(void){\n\tint A,B,i,j,x,y;cin>>A>>B;\n\tint d[11][11]={0};\n\tint mydis[11][11]={0};\n\tint ans[101][101]={0};\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++){cin>>d[i][j];mydis[i][j]=9999;}\n\t}\n\tfor(i=0;i<=100;i++){for(j=0;j<=100;j++){ans[i][j]=-1;}}\n\tfor(x=0;x<=100;x++){\n\t\tfor(y=0;y<=100;y++){\n\t\t\t//この数でやってみる\n\t\t\tint gen=-1;\n\t\t\tfor(i=1;i<=A;i++){\n\t\t\t\tfor(j=1;j<=B;j++){\n\t\t\t\t\tmaxeq(gen,d[i][j]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gen<0){continue;}\n\t\t\tans[x][y]=gen;\n\t\t\tfor(i=1;i<=A;i++){\n\t\t\t\tfor(j=1;j<=B;j++){\n\t\t\t\t\tmineq(mydis[i][j],gen+x*i+y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++){\n\t\t\tif(mydis[i][j]!=d[i][j]){cout<<\"Impossible\"<<endl;RE;}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tvector<tuple<int,int,int>> ret;\n\tint use=3;\n\tfor(x=0;x<=100;x++){\n\t\tfor(y=0;y<=100;y++){\n\t\t\tif(ans[x][y]==-1){continue;}\n\t\t\tret.pub(mt(1+x,102+y,ans[x][y]));\n\t\t}\n\t}\n\tcout<<\"202 \"<<ret.size()+200<<endl;\n\tfor(x=0;x<100;x++){cout<<x+1<<\" \"<<x+2<<\" X\"<<endl;}\n\tfor(y=0;y<100;y++){cout<<y+103<<\" \"<<y+102<<\" Y\"<<endl;}\n\tfor(auto it:ret){cout<<get<0>(it)<<\" \"<<get<1>(it)<<\" \"<<get<2>(it)<<endl;}\n\tcout<<\"1 102\"<<endl;\n\tRE;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 205\n\nint n,m,A,B;\nint d[maxn][maxn],f[maxn][maxn];\n\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tA=read(),B=read();\n\tfor (int i=1;i<=A;i++)\n\t\tfor (int j=1;j<=B;j++)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int a=1;a<=A;a++)\n\t\t\t\tfor (int b=1;b<=B;b++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[a][b]-i*a-j*b);\n\tfor (int a=1;a<=A;a++)\n\t\tfor (int b=1;b<=B;b++){\n\t\t\tint res=1e9;\n\t\t\tfor (int i=0;i<=100;i++)\n\t\t\t\tfor (int j=0;j<=100;j++)\n\t\t\t\t\tres=min(res,f[i][j]+i*a+j*b);\n\t\t\tif (res!=d[a][b]){puts(\"Impossible\"); return 0;}\n\t\t}\n\tputs(\"Possible\");\n\tn=202,m=10401; printf(\"%d %d\\n\",n,m);\n\tfor (int i=1;i<(n>>1);i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (int i=(n>>1)+1;i<n;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (int i=1;i<=(n>>1);i++)\n\t\tfor (int j=(n>>1)+1;j<=n;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i,j,f[i-1][n-j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define max(a, b) (((a)<(b))?b:a)\n#define min(a, b) ((a>b)?b:a)\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pi 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define maxlg 18\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\n#define maxn 2006\nint a,b;\nint d[26][26];\nint f[105][105];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n #endif\n    cin>>a>>b;\n    rep (i,0,a)\n        rep (j,0,b)\n            cin>>d[i+1][j+1];\n\n    rep (i,0,100+1)\n        rep (j,0,100+1)\n            rep (x,1,a+1)\n                rep (y,1,b+1) {\n                    f[i][j] = max(f[i][j],d[x][y]-i*x-j*y);\n                }\n\n    rep (x,1,a+1)\n        rep (y,1,b+1) {\n            int dist = 1e9;\n            rep (i,0,100+1)\n                rep (j,0,100+1) {\n                    dist= min(dist,f[i][j]+i*x +j*y);\n                }\n            if (dist!=d[x][y]){\n                cout<<\"Impossible\";\n                return 0;\n            }\n        }\n    cout<<\"Possible\\n\";\n    vector<string>  ans;\n    rep (i,1,102) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" X\\n\");\n        rep (j,102,203) {\n            ans.push_back(to_string(i)+ \" \"+to_string(j)+\" \"+ to_string(f[i-1][202-j])+\"\\n\");\n        }\n    }\n    rep (i,102,203) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" Y\\n\");\n    }\n    cout<<202<<\" \"<<ans.size()<<endl;\n    rep (i,0,ans.size()) {\n        cout<<ans[i];\n    }\n    cout<<1<<\" \"<<202;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int A, B;\n    cin >> A >> B;\n\n    vvi d(A + 1, vi(B + 1));\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++)\n            cin >> d[i][j];\n    }\n\n    vvi c(101, vi(101));\n    for (int xc = 0; xc <= 100; xc++) {\n        for (int yc = 0; yc <= 100; yc++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[xc][yc] = max(c[xc][yc], d[x][y] - xc * x - yc * y);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int sp = INT_MAX;\n            for (int xc = 0; xc <= 100; xc++) {\n                for (int yc = 0; yc <= 100; yc++) {\n                    sp = min(sp, xc * x + yc * y + c[xc][yc]);\n                }\n            }\n            if (sp != d[x][y]) { cout << \"Impossible\\n\"; return 0; }\n        }\n    }\n\n    int XL = 1, YL = XL + 101, SNK = YL + 101;\n    int V = SNK, E = 100 + 100 + 101 * 101 + 101;\n\n    cout << \"Possible\\n\";\n    cout << V << \" \" << E << \"\\n\";\n    for (int xc = 1; xc <= 100; xc++)\n        cout << (XL + xc - 1) << \" \" << (XL + xc) << \" X\\n\";\n    for (int yc = 0; yc < 100; yc++)\n        cout << (YL + yc) << \" \" << (YL + yc + 1) << \" Y\\n\";\n    for (int xc = 0; xc <= 100; xc++)\n        for (int yc = 0; yc <= 100; yc++)\n            cout << (XL + xc) << \" \" << (YL + yc) << \" \" << c[xc][yc] << \"\\n\";\n    for (int yc = 0; yc <= 100; yc++)\n        cout << (YL + yc) << \" \" << SNK << \"\\n\";\n    cout << 1 << \" \" << SNK << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\n//#define ANDREIKKAA_INTERACTIVE\nconst int _ML = 220;\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n        \"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n        \"\"\n#else\n\"\"\n#endif\n;\n\n#if !defined(ANDREIKKAA)\n#pragma GCC optimize (\"O3\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define rand rd\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#if !defined(ANDREIKKAA_INTERACTIVE) && !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\n\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n\n/* ________ CODE ________ */\n\nvoid bad()\n{\n    cout << \"Impossible\" << endl;\n    exit(0);\n}\n\ninline void mainFunction()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> a(n, vector<int>(m));\n    cin >> a;\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && a[i][j] > a[i + 1][j])\n            {\n                bad();\n            }\n\n            if(j + 1 < m && a[i][j] > a[i][j + 1])\n            {\n                bad();\n            }\n        }\n    }\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && a[i][j] == a[i + 1][j])\n            {\n                for(int k = i + 2; k < n; ++k)\n                {\n                    if(a[i][j] != a[k][j])\n                    {\n                        bad();\n                    }\n                }\n            }\n\n            if(j + 1 < m && a[i][j] == a[i][j + 1])\n            {\n                for(int k = j + 2; k < m; ++k)\n                {\n                    if(a[i][j] != a[i][k])\n                    {\n                        bad();\n                    }\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && abs(a[i][j] - a[i + 1][j]) > 1)\n            {\n                bad();\n            }\n\n            if(j + 1 < m && abs(a[i][j] - a[i][j + 1]) > 1)\n            {\n                bad();\n            }\n        }\n    }\n\n    assert(false);\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << setprecision(228);\n    //cout << fixed;\n    mainFunction();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint constexpr MAXVAL=100;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> used(MAXVAL+1,std::vector<int>(MAXVAL+1));\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=std::min(sum,MAXVAL);++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint maxd1=INT_MIN;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmaxd1=std::max(maxd1,d1[x][y]-=(x+1)*nx+(y+1)*ny);\n\t\t\t}\n\t\t\tif(maxd1<0)\n\t\t\t\tcontinue; // useless line (all value strictly > d)\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==maxd1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tconnval[nx][ny]=maxd1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tused[0][0]=true;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny]){\n\t\t\tfor(int sumd=1;sumd<=2*MAXVAL;++sumd){\n\t\t\t\tfor(int dx=std::max(0,sumd-ny),\n\t\t\t\t\t\tmax_dx=std::min({MAXVAL,sumd,nx});\n\t\t\t\t\t\tdx<=max_dx;++dx){\n\t\t\t\t\tint dy=sumd-dx; // 0 <= dy && dy <= ny\n\t\t\t\t\tif(used[nx-dx][ny-dy]){\n\t\t\t\t\t\tint nx1=nx,ny1=ny;\n\t\t\t\t\t\twhile(dy--)\n\t\t\t\t\t\t\tused[nx1][--ny1]=true;\n\t\t\t\t\t\twhile(dx--)\n\t\t\t\t\t\t\tused[--nx1][ny1]=true;\n\t\t\t\t\t\tgoto break_outer_2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nbreak_outer_2:;\n\t\t}\n\n\tauto& index=used;\n\tint lastindex=0;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny])\n\t\t\tindex[nx][ny]=++lastindex;\n\n\tint const n_used=lastindex; // 1 .. lastindex\n\tint const n_used_edge=n_used-1;\n\tint const source=1;\n\tint const dest=lastindex+1;\n\tint const nnode=dest;\n\n\tassert(nnode<=300);\n\tstd::cout<<\"Possible\\n\"<<nnode<<' '<<n_used_edge+n_connedge<<'\\n';\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const curindex=index[nx][ny];\n\t\tif(curindex){\n\t\t\tif(nx!=0&&index[nx-1][ny])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx-1][ny]<<\" X\\n\";\n\t\t\telse if(ny!=0&&index[nx][ny-1])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx][ny-1]<<\" Y\\n\";\n\t\t\telse\n\t\t\t\tassert(nx==0&&ny==0);\n\t\t\tif(connval[nx][ny]>=0)\n\t\t\t\tstd::cout<<curindex<<' '<<dest<<' '<<connval[nx][ny]<<'\\n';\n\t\t}else\n\t\t\tassert(connval[nx][ny]<0);\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nint n, m, d[N][N], f[N][N];\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t{\n\t\t\tint dist = INT_MAX;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist = min(dist, f[i][j] + i * x + j * y);\n\t\t\tif(d[x][y] != dist) return (cout << \"Impossible\" << endl) && 0; \n\t\t}\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\tfor(int i = 1; i < 101; i++) cout << i << ' ' << i + 1 << ' ' << 'X' << endl;\n\tfor(int i = 102; i < 202; i++) cout << i << ' ' << i + 1 << ' ' << 'Y' << endl;\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tcout << i + 1 << ' ' << 202 - j << ' ' << f[i][j] << endl;\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <limits>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\nconstexpr int INF = std::numeric_limits<int>::max()>>2;\n\nint A, B;\nint d[10][10];\nint c[100][100];\n\nint main()\n{\n  scanf( \"%d%d\", &A, &B );\n  rep( i, A ) rep( j, B )\n    scanf( \"%d\", &d[i][j] );\n\n  rep( i, 100 ) rep( j, 100 )\n  {\n    rep( a, A ) rep( b, B )\n      c[i][j] = std::max( c[i][j], d[a][b]-i*a-j*b );\n  }\n\n  bool fl = true;\n  rep( a, A ) rep( b, B )\n  {\n    int D = INF;\n    rep( i, 100 ) rep( j, 100 )\n      D = std::min( D, i*a+j*b+c[i][j] );\n    \n    fl &= D == d[a][b];\n  }\n\n  if( !fl )\n    puts( \"Impossible\" );\n  else\n  {\n    puts( \"Possible\" );\n  \n    printf( \"%d %d\\n\", 202, 100*100+200 );\n\n    rep( i, 100 )\n      printf( \"%d %d X\\n\", i+1, i+2 );\n    rep( i, 100 )\n      printf( \"%d %d Y\\n\", i+102, i+103 );  \n    rep( i, 100 ) rep( j, 100 )\n      printf( \"%d %d %d\\n\", i+1, 201-j, c[i][j] );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, d[102][102], a, b, ok[102][102];\nstruct skrr {\n  int i, j, c;\n} v[20002];\n\nint main()\n{\n  cin >> a >> b;\n  for (int i = 1; i <= a; i++)\n    for (int j = 1; j <= b; j++)\n      cin >> d[i][j];\n  for (int i = 0; i <= 100; i++)\n    for (int j = 0; j <= 100; j++) {\n      int mx = 0;\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          mx = max (mx, d[x][y] - i * x - j * y);\n      v[++m] = {i + 1, 202 - j, mx};\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          if (mx + i * x + j * y == d[x][y])\n            ok[x][y] = 1;\n    }\n  for (int x = 1; x <= a; x++)\n    for (int y = 1; y <= b; y++)\n    if (!ok[x][y]) {\n      cout << \"Impossible\";\n      return 0;\n    }\n  cout << \"Possible\\n\";\n  cout << \"202 \" << m + 200;\n  for (int i = 1; i <= 100; i++)\n    cout << i << \" \" << i + 1 << \" X\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i + 101 << \" \" << i + 102 << \" Y\\n\";\n  for (int i = 1; i <= m; i++)\n    cout << v[i].i << \" \" << v[i].j << \" \" << v[i].c << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u, v, w; \n\n\tEdge (int u, int v, int w) :\n\t\tu(u), v(v), w(w) {}\n};\n\nint n, m, a[10][10];\nint S, T, id;\nvector<Edge> vres;\n\nvoid add(int x, int y, int z) {\n\tint cur = S;\n\t// -1 : A, -2 : B\n\twhile (x--) vres.push_back(Edge(cur, ++id, -1)), cur = id;\n\twhile (y--) vres.push_back(Edge(cur, ++id, -2)), cur = id;\n\tvres.push_back(Edge(cur, T, z));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 2, id = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tassert(id <= 300);\n\tcout << \"Possible\\n\";\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.u << ' ' << i.v << ' ';\n\t\tif (i.w == -1) cout << \"X\\n\";\n\t\tif (i.w == -2) cout << \"Y\\n\";\n\t\tif (i.w >= 0) cout << i.w << '\\n';\n\t}\n\tcout << \"1 2\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nconst int N = 11;\n\nint a, b, d[N][N], delta[101][101];\nbool ok[N][N];\n\nint main()\n{\n    scanf(\"%d%d\", &a, &b);\n    int cnt = 0, left = a * b;\n    for (int i = 1; i <= a; ++ i) {\n        for (int j = 1; j <= b; ++ j) {\n            scanf(\"%d\", d[i] + j);\n            cnt = std::max(cnt, d[i][j]);\n        }\n    }\n    for (int i = 0; i <= cnt; ++ i) {\n        for (int j = 0; j <= cnt; ++ j) {\n            int& dt = delta[i][j];\n            dt = 0;\n            for (int x = 1; x <= a; ++ x) {\n                for (int y = 1; y <= b; ++ y) {\n                    dt = std::max(dt, d[x][y] - i * x - j * y);\n                }\n            }\n            for (int x = 1; x <= a; ++ x) {\n                for (int y = 1; y <= b; ++ y) {\n                    if (dt + i * x + j * y == d[x][y]) {\n                        left -= !ok[x][y];\n                        ok[x][y] = true;\n                    }\n                }\n            }\n        }\n    }\n    if (left) {\n        puts(\"Impossible\");\n    } else {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 2 * (cnt + 1), 2 * cnt + (cnt + 1) * (cnt + 1));\n\n        for (int i = 0; i < cnt; ++ i) {\n            printf(\"%d %d X\\n\", i + 1, i + 2);\n            printf(\"%d %d Y\\n\", i + cnt + 3, i + cnt + 2);\n        }\n        for (int i = 0; i <= cnt; ++ i) {\n            for (int j = 0; j <= cnt; ++ j) {\n                printf(\"%d %d %d\\n\", i + 1, j + cnt + 2, delta[i][j]);\n            }\n        }\n        printf(\"%d %d\\n\", 1, cnt + 2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 105 \nusing namespace std;\nint d[maxn][maxn];\nint D[maxn][maxn];\nint f[maxn][maxn]; \nint main() {\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; ++i) for(int j = 1; j <= B; ++j) scanf(\"%d\", d[i] + j);\n\tfor(int a = 0; a <= 100; ++a) {\n\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\tfor(int x = 1; x <= A; ++x) {\n\t\t\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\t\t\tf[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0x3f, sizeof D);\n\tfor(int x = 1; x <= A; ++x) {\n\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\tfor(int a = 0; a <= 100; ++a) {\n\t\t\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\t\t\tD[x][y] = min(D[x][y], x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool same = true;\n\tfor(int x = 1; x <= A; ++x) \n\t\tfor(int y = 1; y <= B; ++y) \n\t\t\tif(D[x][y] != d[x][y]) same = false;\n\tputs(same ? \"Possible\" : \"Impossible\");\n\tif(same) {\n\t\tputs(\"202 10401\");\n\t\tfor(int i = 1; i <= 100; ++i) {\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\t\t}\n\t\tfor(int a = 0; a <= 100; ++a) \n\t\t\tfor(int b = 0; b <= 100; ++b) \n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 101, f[a][b]);\n\t\tputs(\"1 202\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+1<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=2*M;i++) cout<<i<<' '<<i+1<<' '<<(i<=M?'X':'Y')<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+1-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+1<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[11][11], f[111][111];\nint main()\n{\n\tint a, b, e = 0;\n\tcin >> a >> b;\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tcin >> d[i][j];\n\tfor (int i = 0; i < 101; i++) {\n\t\tfor (int j = 0; j < 101; j++) {\n\t\t\tfor (int k = 1; k <= a; k++)\n\t\t\t\tfor (int l = 1; l <= b; l++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[k][l] - k * i - l * j);\n\t\t\tif (f[i][j] <= 100)\n\t\t\t\te++;\n\t\t}\n\t}\n\tfor (int k = 1; k <= a; k++) {\n\t\tfor (int l = 1; l <= b; l++) {\n\t\t\tint m = 114514;\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tfor (int j = 0; j < 101; j++)\n\t\t\t\t\tm = min(m, f[i][j] + k * i + l * j);\n\t\t\tif (m != d[k][l]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n202 \" << e + 200 << \"\\n\";\n\tfor (int i = 0; i < 100; i++) {\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\t\tcout << i + 102 << ' ' << i + 103 << \" Y\\n\";\n\t}\n\tfor (int i = 1; i < 102; i++)\n\t\tfor (int j = 102; j < 203; j++)\n\t\t\tif (f[i - 1][202 - j] <= 100)\n\t\t\t\tcout << i << ' ' << j << ' ' << f[i - 1][202 - j] << '\\n';\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\nusing namespace std;\nstruct p {\n\tint x, y, z;\n\tbool operator<(const p &A) const {\n\t\tif (x != A.x) return x < A.x;\n\t\tif (y != A.y) return y < A.y;\n\t\treturn z < A.z;\n\t}\n\tp& operator-=(const p &A) {\n\t\tx -= A.x; y -= A.y; z -= A.z;\n\t\treturn *this;\n\t}\n};\np cross(const p &A, const p &B) {\n\treturn { A.y*B.z - B.y*A.z, A.z*B.x - B.z*A.x, A.x*B.y - B.x*A.y };\n}\nstruct Plane {\n\tint a, b, c; // z = ax + by + c\n\tbool valid;\n\tPlane(p u, p v, p z) {\n\t\tvalid = false;\n\t\tu -= z; v -= z;\n\t\tp t = cross(u, v);\n\t\tif (t.z == 0 || t.x%t.z != 0 || t.y % t.z != 0) return;\n\t\ta = -t.x / t.z; b = -t.y / t.z;\n\t\tc = z.z - a * z.x - b * z.y;\n\t\tif (c < 0 || a < 0 || b < 0) return;\n\t\tvalid = true;\n\t}\n\tbool operator<(const Plane &A) const {\n\t\tif (a != A.a) return a < A.a;\n\t\tif (b != A.b) return b < A.b;\n\t\treturn c < A.c;\n\t}\n\tbool operator()(const p &A) const {\n\t\treturn a * A.x + b * A.y + c;\n\t}\n};\nvector<p> v;\nint chk[111];\nbool isunder(Plane c, p x) {\n\treturn c(x) <= x.z;\n}\nset<Plane> ans;\nint main() {\n\tint a, b, n, t;\n\tscanf(\"%d%d\", &a, &b);\n\tn = a * b;\n\tfor (int i = 1; i <= a; i++)for (int j = 1; j <= b; j++) {\n\t\tscanf(\"%d\", &t);\n\t\tv.push_back({ i, j, t });\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) for (int k = j + 1; k < n; k++) {\n\t\tPlane t(v[i], v[j], v[k]);\n\t\tif (!t.valid) continue;\n\t\tint succ = 1;\n\t\tfor (auto x : v) {\n\t\t\tif (!isunder(t, x)) {\n\t\t\t\tsucc = 0; break;\n\t\t\t}\n\t\t}\n\t\tif (succ) {\n\t\t\tchk[i] = chk[j] = chk[k] = 1;\n\t\t\tans.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (chk[i] == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"200 %d\\n\", 198 + ans.size());\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d Y\\n\", i + 100, i + 101);\n\tfor (auto t : ans) {\n\t\tprintf(\"%d %d %d\\n\", t.a + 1, 200 - t.b, t.c);\n\t}\n\tprintf(\"1 200\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\t\t\td[0] = 0;\n\t\t\tpriority_queue<p>Q;\n\t\t\tQ.push({0,0});\n\t\t\twhile (Q.size()) {\n\t\t\t\tp t = Q.top(); Q.pop();\n\t\t\t\tif (d[t.second] < t.first)continue;\n\t\t\t\tfor (P u : V) {\n\t\t\t\t\tif (u.second.first == t.second) {\n\t\t\t\t\t\tint h = 0;\n\t\t\t\t\t\tif (u.second.first >= 0) {\n\t\t\t\t\t\t\th = u.second.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (u.second.first == -1) {\n\t\t\t\t\t\t\th = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse h = j + 1;\n\t\t\t\t\t\tif (d[u.second.second] > t.first + h) {\n\t\t\t\t\t\t\td[u.second.second] = t.first + h;\n\t\t\t\t\t\t\tQ.push({ u.second.second,t.first + h });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nint main(void){\n  int n = 100;\n  int a, b;\n  int f = 1;\n  cin >> a >> b;\n  vector<vi> d(a, vi(b));\n  vector<vi> finished(a, vi(b, 0));\n  REP(i, a) REP(j, b) cin >> d[i][j];\n  vector<vector<pii> > g(2 * n + 2);\n  REP(i, n + 1) {\n    REP(j, n + 1) {\n      int min_cost = 0;\n      REP(k, a) {\n        REP(l, b) {\n          int x = (k + 1) * i + (l + 1) * j;\n          int y = x - d[k][l];\n          if(y < 0) min_cost = max(min_cost, -y);\n        }\n      }\n      g[i+10].push_back(pii(220 - j, min_cost));\n      REP(k, a) {\n        REP(l, b){\n          if((k + 1) * i + (l + 1) * j + min_cost == d[k][l]) finished[k][l] = 1;\n        }\n      }\n    }\n  }\n  REP(i, a) REP(j, b) if(!finished[i][j]) f = 0;\n\n  if(!f) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  int m = 2 * n + 2;\n  REP(i, g.size()) m += g[i].size();\n  cout << \"300 \" << m << endl;\n  cout << \"1 10 0\" << endl;\n  cout << \"220 2 0\" << endl;\n  REP(i, 100) {\n    cout << i + 10 << \" \" << i + 11 << \" X\" << endl;\n    cout << i + 120 << \" \" << i + 121 << \" Y\" << endl;\n  }\n  REP(i, g.size()) {\n    REP(j, g[i].size()) {\n      cout << i << \" \" << g[i][j].first << \" \" << g[i][j].second << endl;\n    }\n  }\n  cout << \"1 2\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\n#include<map>\n#include<bitset>\n#include<stack>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define INF 1000000000\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\nchar BB[1 << 15],*SS = BB,*TT = BB;\ninline long long read()\n{\n\tlong long x = 0;int f = 1;\n\tchar ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())\n\t\tif(ch == '-')\n\t\t\tf = -1;\n\tfor(;isdigit(ch);ch = getchar())\n\t\tx = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(long long x)\n{\n\tif(x < 0)\n\t\tputchar('-'),x = -x;\n\tif(x > 9)\n\t\tprint(x / 10);\n\tputchar(x % 10 + '0');\n}\nconst int N = 410,K = 20;\n\nint f[N][N],d[K][K];\nstruct edge\n{\n    int u,v,w;\n}e[N * N];\nint n,m;\nint main()\n{\n    n = read(),m = read();\n    for(int i = 1;i <= n;i++)\n        for(int j = 1;j <= m;j++)\n            d[i][j] = read();\n    for(int i = 0;i <= 100;i++)\n        for(int j = 0;j <= 100;j++)\n            for(int x = 1;x <= n;x++)\n                for(int y = 1;y <= m;y++)\n                    f[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n    int res;\n    for(int x = 1;x <= n;x++)\n        for(int y = 1;y <= m;y++)\n        {\n            res = INF;\n            for(int i = 0;i <= 100;i++)\n                for(int j = 0;j <= 100;j++)\n                    res = min(res,f[i][j] + i * x + j * y);\n            if(res != d[x][y])\n\t\t\t{\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1;i <= 100;i++)\n        pprint(i),pprint(i + 1),puts(\"X\");\n    for(int i = 102;i < 202;i++)\n        pprint(i),pprint(i + 1),puts(\"Y\");\n    for(int i = 0;i <= 100;i++)\n        for(int j = 0;j <= 100;j++)\n            pprint(i + 1),pprint(202 - j),fprint(f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)+1<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tcout<<M+1<<' '<<M+2<<' '<<0<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) if(i<M||j<M) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305,K=10;\nint f[N][N];\nint d[K][K];\nstruct Edge{\n\tint u,v,w;\n}e[N*N];\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now;\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tnow=0x3f3f3f3f;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor(int i=102;i<202;i++){\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint A, B;\nint d[11][11];\npair<pii, int> info[11][11];\n\nint main() {\n\tcin >> A >> B;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tint maxi = 0;\n\tint u = 0;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tvector<pii> cand;\n\n\t\t\tfor (int k = 0; k <= 100; ++k) {\n\t\t\t\tfor (int l = 0; l <= 100; ++l) {\n\t\t\t\t\tif (k * i + l * j > d[i][j]) continue;\n\t\t\t\t\tint c = d[i][j] - k * i - l * j;\n\t\t\t\t\tbool ok = 1;\n\n\t\t\t\t\tfor (int p = 1; p <= A; ++p) {\n\t\t\t\t\t\tfor (int q = 1; q <= B; ++q) {\n\t\t\t\t\t\t\tif (p * k + q * l + c < d[p][q]) {\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tcand.eb(k, l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cand.size() == 0) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpii la = cand[0];\n\t\t\t\tu = max(u, la.fi);\n\t\t\t\tmaxi = max(maxi, la.se);\n\t\t\t\tint zan = d[i][j] - la.fi * i - la.se * j;\n\t\t\t\tinfo[i][j] = mp(la, zan);\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\n\tvector<pair<pii, int>> vec;\n\n\tint S = 0;\n\tint now = u + 1;\n\n\trep(i, u) {\n\t\tvec.eb(mp(i, i + 1), -1);\n\t}\n\n\tint T = now;\n\n\trep(i, maxi) {\n\t\t++now;\n\t\tvec.eb(mp(now, now - 1), -2);\n\t}\n\t++now;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tpii p = info[i][j].fi;\n\t\t\tint c = info[i][j].se;\n\t\t\tvec.eb(mp(p.fi, now), c);\n\t\t\tvec.eb(mp(now, T + p.se), 0);\n\t\t\t++now;\n\t\t}\n\t}\n\n\tcout << now << \" \" << vec.size() << endl;\n\tfor (auto e : vec) {\n\t\tprintf(\"%d %d \", e.fi.fi + 1, e.fi.se + 1);\n\t\tif (e.se == -1) {\n\t\t\tputchar('X');\n\t\t} else if (e.se == -2) {\n\t\t\tputchar('Y');\n\t\t} else {\n\t\t\tprintf(\"%d\", e.se);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\tcout << S + 1 << \" \" << T + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint dd[12][12];\n\nvector<tuple<int, int, int> > vv;\n\nint en[12][12];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tint a, b;\n\tcin >> a >> b;\n\tfor (int i = 1; i <= a; ++i)\n\t\tfor (int j = 1; j <= b; ++j)\n\t\t\tcin >> dd[i][j];\n\tfor (int k = 0; k <= 100; ++k)\n\t\tfor (int x = 0; x + k <= 100; ++x)\n\t\t\tfor (int y = 0; x + y + k <= 100; ++y) {\n\t\t\t\tint fl = 0;\n\t\t\t\tfor (int i = 1; i <= a; ++i)\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (i * x + j * y + k < dd[i][j])\n\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t}\n\t\t\t\tif (fl)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int i = 1; i <= a; ++i)\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (!en[i][j] && i * x + j * y + k == dd[i][j])\n\t\t\t\t\t\t\ten[i][j] = 1, fl = 1;\n\t\t\t\t\t}\n\t\t\t\tif (fl)\n\t\t\t\t\tvv.emplace_back(k, x, y);\n\t\t\t}\n\tfor (int i = 1; i <= a; ++i)\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tif (!en[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout << \"Possible\\n\";\n\tint n = 202;\n\tvector<tuple<int, int, string>> ed;\n\tfor (int i = 1; i <= 100; ++i)\n\t\ted.emplace_back(i, i + 1, \"X\");\n\tfor (int i = 102; i < 202; ++i)\n\t\ted.emplace_back(i, i + 1, \"Y\");\n\tfor (auto e: vv) {\n\t\tint k, x, y;\n\t\ttie(k, x, y) = e;\n\t\ted.emplace_back(1 + x, 202 - y, to_string(k));\n\t}\n\tcout << n << \" \" << ed.size() << \"\\n\";\n\tfor (auto e: ed) {\n\t\tcout << get<0>(e) << \" \" << get<1>(e) << \" \" << get<2>(e) << \"\\n\";\n\t}\n\tcout << 1 << \" \" << 202 << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\nconst int INF = 0x3f3f3f3f;\nusing namespace std;\n\nconst int MAXV = 15;\nconst int MAXN = 105;\nint A, B, D[MAXV][MAXV], F[MAXN][MAXN];\n\nconst int PointS = 1;\nconst int PointT = 2;\nint NPoint = 2, NSide = 0, pointX[MAXN], pointY[MAXN];\nstruct side { int u, v, d; } S[MAXN * MAXN];\ninline void link(int u, int v, int d) { S[++NSide] = (side){u, v, d}; } //-1: X, -2: Y\n\nint main() {\n    int x, y, a, b;\n    scanf(\"%d%d\", &A, &B);\n    for(x = 1; x <= A; x++) for(y = 1; y <= B; y++) scanf(\"%d\", &D[x][y]);\n\n    //construct\n    for(a = 0; a <= 100; a++) for(b = 0; b <= 100; b++) {\n        for(x = 1; x <= A; x++) for(y = 1; y <= B; y++) F[a][b] = max(F[a][b], D[x][y] - a * x - b * y);\n    }\n    //check if ok\n    bool Succ = 1;\n    for(x = 1; x <= A; x++) for(y = 1; y <= B; y++) {\n        int dist = INF;\n        for(a = 0; a <= 100; a++) for(b = 0; b <= 100; b++) dist = min(dist, a * x + b * y + F[a][b]);\n        if(dist != D[x][y]) Succ = 0;\n    }\n    if(!Succ) printf(\"Impossible\");\n    else {\n        //construct\n        pointX[0] = PointS; for(a = 1; a <= 100; a++) pointX[a] = ++NPoint, link(pointX[a - 1], pointX[a], -1);\n        pointY[0] = PointT; for(b = 1; b <= 100; b++) pointY[b] = ++NPoint, link(pointY[b], pointY[b - 1], -2);\n        for(a = 0; a <= 100; a++) for(b = 0; b <= 100; b++) link(pointX[a], pointY[b], F[a][b]);\n        //print\n        printf(\"Possible\\n%d %d\\n\", NPoint, NSide);\n        for(int i = 1; i <= NSide; i++) {\n            if(S[i].d < 0) printf(\"%d %d %c\\n\", S[i].u, S[i].v, (S[i].d == -1) ? 'X' : 'Y');\n            else printf(\"%d %d %d\\n\", S[i].u, S[i].v, S[i].d);\n        }\n        printf(\"%d %d\", PointS, PointT);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint mn[305][305], dis[305][305]; \nint main()\n{\n\tint a, b; \n\tscanf(\"%d%d\", &a, &b); \n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tscanf(\"%d\", dis[i] + j); \n\t\t\tfor (int x = 0; x <= 100; x++)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y <= 100; y++)\n\t\t\t\t\tmn[x][y] = std::max(mn[x][y], dis[i][j] - i * x - j * y); \n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tbool f = false; \n\t\t\tfor (int x = 0; x <= 100; x++)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y <= 100; y++)\n\t\t\t\t\tf |= mn[x][y] + i * x + j * y == dis[i][j]; \n\t\t\t}\n\t\t\tif (!f)\n\t\t\t{\n\t\t\t\tputs(\"Impossible\"); \n\t\t\t\treturn 0; \n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\"); \n\tprintf(\"%d %d\\n\", 202, 101 * 101 + 100 * 2);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, mn[i][j]);\n\t}\n\tputs(\"1 202\"); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint A, B;\n\tcin >> A >> B;\n\tvector<vector<int> >d(A + 1, vector<int>(B + 1, 0));\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool f;\n\tint mn = 100;\n\tint sc = 0;\n\tint xx, yy;\n\tint xmax = 0;\n\tbool ok = true;\n\tvector<pair<pair<int, int>, int> > vp;\n\tfor (int a = 1; a <= A; a++) {\n\t\tfor (int b = 1; b <= B; b++) {\n\t\t\txx = -1;\n\t\t\tmn = 10000;\n\t\t\tfor (int x = 0; x <= 100; x++) {\n\t\t\t\tfor (int y = 0; y <= 100; y++) {\n\t\t\t\t\tint z = d[a][b] - x*a - y*b;\n\t\t\t\t\tif (z < 0)break;\n\t\t\t\t\tf = true;\n\t\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\t\tif (d[a2][b2] > x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\tsc = max(x, y);\n\t\t\t\t\t\tif (mn > sc) {\n\t\t\t\t\t\t\tmn = sc;\n\t\t\t\t\t\t\txx = x;\n\t\t\t\t\t\t\tyy = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xx == -1) {\n\t\t\t\tcerr << a << \" \" << b << endl;\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txmax = max(xx, xmax);\n\t\t\tvp.push_back(make_pair(make_pair(xx, yy), d[a][b] - xx*a - yy*b));\n\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif (ok) {\n\t\tint v = 0;\n\t\tsort(vp.begin(), vp.end());\n\t\tvector<int> ymax(xmax + 1, -1);\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\tymax[vp[i].first.first] = max(ymax[vp[i].first.first], vp[i].first.second);\n\t\t\t//cerr << vp[i].first.first << \" \" << vp[i].first.second << \" \" << vp[i].second << endl;\n\t\t}\n\t\tmap<pair<int, int>, int> mp;\n\t\tvector<pair<pair<int, int>, int> >ed;\n\t\tmp[make_pair(0, 0)] = 0;\n\t\tfor (int i = 0; i < xmax; i++) {\n\t\t\tv++;\n\t\t\ted.push_back(make_pair(make_pair(v, v - 1), -1));\n\t\t\tmp[make_pair(v, 0)] = v;\n\t\t}\n\t\tfor (int i = 0; i <= xmax; i++) {\n\t\t\tfor (int j = 0; j < ymax[i]; j++) {\n\t\t\t\tv++;\n\t\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(i, j)], v), -2));\n\t\t\t\tmp[make_pair(i, j + 1)] = v;\n\t\t\t}\n\t\t}\n\t\tv++;\n\t\tint fc = v;\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(vp[i].first.first, vp[i].first.second)], fc), vp[i].second));\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\n\t\tcout << fc + 1 << \" \" << (int)ed.size() << endl;\n\t\tfor (int i = 0; i < ed.size(); i++) {\n\t\t\tcout << ed[i].first.first + 1 << \" \" << ed[i].first.second + 1 << \" \";\n\t\t\tif (ed[i].second == -1) {\n\t\t\t\tcout << \"X\" << endl;\n\t\t\t}\n\t\t\telse if (ed[i].second == -2) {\n\t\t\t\tcout << \"Y\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << ed[i].second << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << \" \" << fc + 1 << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\n#include<bitset>\nusing namespace std;\n#define pb push_back\n#define x0 fuckcjb\n#define x1 fuckshb\n#define y0 fucksub\n#define y1 fuckjtjl\nstruct edges\n{\n\tint x,y,z;\n};\nint d[15][15];\nbool vis[20][20];\nint tot,n,idx[120],idy[120],S,T,A,B;\nvector<edges> edge;\nvoid check()\n{\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(!vis[i][j])\n\t\t\t{\n\t\t\tputs(\"Impossible\");\n\t\t\texit(0);\n\t\t}\n\t\t}\n\t}\n}\nint get(int p,int q)\n{\n\tint c=-1000000;\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tc=max(c,d[i][j]-i*p-j*q);\n\t\t}\n\t}\n\tif(c<0)\n\t{\n\t\treturn -3;\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(d[i][j]-i*p-j*q==c)\n\t\t\t{\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\nvoid add(int x,int y,int z)\n{\n\tif(z==-3)\n\t{\n\t\treturn;\n\t}\n\tedge.push_back({x,y,z});\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tS=1;T=2;tot=2;\n\tidx[0]=S;idy[0]=T;\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tidx[i]=++tot;\n\t\tidy[i]=++tot;\n\t}\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tadd(idx[i-1],idx[i],-1);\n\t\tadd(idy[i],idy[i-1],-2);\n\t}\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tadd(idx[i],idy[j],get(i,j));\n\t\t}\n\t}\n\tcheck();\n\tputs(\"Possible\");\n\tint cnt=edge.size();\n\tprintf(\"%d %d\\n\",tot,cnt);\n\tfor(int i=0;i<cnt;i++)\n\t{\n\t\tprintf(\"%d %d \",edge[i].x,edge[i].y);\n\t\tif(edge[i].z>=0)\n\t\t{\n\t\t\tprintf(\"%d\\n\",edge[i].z);\n\t\t}\n\t\telse if(edge[i].z==-1)\n\t\t{\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"Y\");\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint a, b;\nconst int maxN = 15;\nint d[maxN][maxN];\nbool ok[maxN][maxN];\nint val[maxN][maxN];\nint vert[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n    int sz = 1;\n    for (int cnt1 = 0; cnt1 < maxN; cnt1++) {\n        for (int cnt2 = 0; cnt2 < maxN; cnt2++) {\n            vert[cnt1][cnt2] = sz++;\n            int at_least_t = 0;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    at_least_t = max(at_least_t, d[j][k] - j * cnt1 - k * cnt2);\n                }\n            }\n            val[cnt1][cnt2] = at_least_t;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    int p = at_least_t + j * cnt1 + k * cnt2;\n                    assert(p >= d[j][k]);\n                    if (p == d[j][k]) ok[j][k] = true;\n                }\n            }\n        }\n    }\n    for (int j = 1; j <= a; j++) {\n        for (int k = 1; k <= b; k++) {\n            if (!ok[j][k]) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << '\\n';\n    vector < pair < pair < int, int >, int > > edges;\n    int T = sz;\n    for (int i = 0; i < maxN; i++) {\n        for (int j = 0; j < maxN; j++) {\n            edges.emplace_back(make_pair(vert[i][j], T), val[i][j]);\n            if (i + 1 < maxN) {\n                edges.emplace_back(make_pair(vert[i][j], vert[i + 1][j]), -1);\n            }\n            if (j + 1 < maxN) {\n                edges.emplace_back(make_pair(vert[i][j], vert[i][j + 1]), -2);\n            }\n        }\n    }\n    cout << sz << \" \" << edges.size() << '\\n';\n    for (auto it : edges) {\n        cout << it.first.first << \" \" << it.first.second << \" \";\n        if (it.second == -1) cout << 'X' << '\\n';\n        else if (it.second == -2) cout << 'Y' << '\\n';\n        else it.second << '\\n';\n    }\n    cout << 1 << \" \" << sz << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    exit(7);\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            for(int it = j+1; it <= b; it++)\n            {\n                int delta = d[i][it] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-j;\n                y[i][j] = max(delta/k + (delta%k!=0), y[i][j]);\n            }\n            for(int it = i+1; it <= a; it++)\n            {\n                int delta = d[it][j] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-i;\n                x[i][j] = max(delta/k + (delta%k!=0), x[i][j]);\n            }\n            int cost = x[i][j]*i + y[i][j]*j;\n            if(cost>d[i][j])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb({x[i][j], y[i][j], d[i][j] - cost});\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    if(nodes>300) exit(7);\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1114));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int edge_count = 200;\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            edge_count += 1;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 201 << \" \" << edge_count << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            if ((201 - yuse) - (xuse + 1) <= 1) {\n                return -1;\n            }\n            cout << xuse + 1 << \" \" << 201 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 201\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid solve(){\n  int A,B;\n  cin >> A >> B;\n\n  vector<vector<int>> d(A,vector<int>(B));\n  REP(i,A) REP(j,B) cin >> d[i][j];\n  \n  int s = 1, t = 300;\n  mat e(A,vec(B,LINF));\n  vector<T> ans; \n  REP2(i,100) REP2(j,100){\n    int f = 0;\n    REP(a,A) REP(b,B){\n      chmax(f,d[a][b]-(a+1)*i-(b+1)*j);\n    }\n    assert(f <= 100);\n    REP(a,A) REP(b,B){\n      chmin(e[a][b],(a+1)*i+(b+1)*j+f);\n    }\n    ans.emplace_back(i+1,300-j,f);\n  }\n\n  REP(i,A) REP(j,B){\n    if(d[i][j]!=e[i][j]){\n      cout << \"Impossible\" << endl;\n      return;\n    }\n  }\n\n  cout << 300 SP 200+ans.size() << endl;\n  REP(i,100) cout << i+1 SP i+2 << \"X\" << endl;\n  REP(i,100) cout << 200+i SP 201+i << \"Y\" << endl;\n  REP(i,ans.size()){\n    int x,y,z;\n    tie(x,y,z) = ans[i];\n    cout << x SP y SP z << endl;\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nusing Data = pair<pii, int>;\nusing Edge = pair<pii, char>;\n\nint A;\nint B;\nint d[114][114];\n\nvoid Output(vector<Data> &ds) {\n  int N = 202;\n  vector<Edge> es;\n\n  puts(\"Possible\");\n  rep(i, 100) {\n    es.eb(Edge(pii(i, i+1), 'X'));\n    es.eb(Edge(pii(i+101, i+102), 'Y'));\n  }\n\n  map<pii, int> cnt;\n  for (auto &d : ds) {\n    int p, q;\n    tie(p, q) = d.X;\n    assert(!cnt.count(d.X));\n    cnt[d.X]++;\n    assert(p <= 100 && q <= 100);\n    int t = d.Y;\n    es.eb(Edge(pii(p, N-1-q), -t));\n  }\n\n  cout << N << \" \" << es.size() << endl;\n  for (auto &e : es) {\n    int u, v;\n    tie(u, v) = e.X;\n    char c = e.Y;\n    if (c <= 0) {\n      int l = -c;\n      cout << u+1 << \" \" << v+1 << \" \" << l << endl;\n    } else {\n      assert(c == 'X' || c == 'Y');\n      cout << u+1 << \" \" << v+1 << \" \" << c << endl;\n    }\n  }\n  cout << 1 << \" \" << N << endl;\n}\n\nint main() {\n  cin >> A >> B;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      cin >> d[i][j];\n    }\n  }\n\n  vector<Data> ds;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      int p = 1000;\n      int q = 1000;\n      rep(a, 101) {\n        rep(b, 101) {\n          int t = d[i][j] - a*i - b*j;\n          if (t < 0) break;\n\n          bool ok = true;\n          reps(k, 1, A+1) {\n            reps(l, 1, B+1) {\n              if ((k-i)*a + (l-j)*b < d[k][l] - d[i][j]) {\n                ok = false;\n                goto L_OUT;\n              }\n            }\n          }\nL_OUT:\n          if (ok) {\n            if (p+q > a+b) {\n              p = a;\n              q = b;\n            }\n          }\n        }\n      }\n\n      if (p == 1000) {\n        puts(\"Impossible\");\n        return 0;\n      }\n\n      ds.eb(Data(pii(p, q), d[i][j] - p*i - q*j));\n    }\n  }\n  sort(all(ds));\n  ds.erase(unique(all(ds)), ds.end());\n  Output(ds);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint A, B, D[11][11], O[111][111], Nw[11][11];\n\nint main() {\n    scanf(\"%d%d\", &A, &B);\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            scanf(\"%d\", &D[i][j]);\n    memset(Nw, 63, sizeof Nw);\n    for(int i = 0; i <= 100; i++)\n        for(int j = 0; j <= 100; j++) {\n            int c = 0;\n            for(int a = 1; a <= A; a++)\n                for(int b = 1; b <= B; b++)\n                    c = max(c, D[a][b] - i * a - j * b);\n            O[i][j] = c;\n            for(int a = 1; a <= A; a++)\n                for(int b = 1; b <= B; b++)\n                    Nw[a][b] = min(Nw[a][b], i * a + j * b + c);\n        }\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            if(D[i][j] != Nw[i][j]) {\n                puts(\"Impossible\");\n                return 0;\n            }\n    puts(\"Possible\\n204 10401\\n\");\n    for(int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n    for(int i = 1; i <= 101; i++)\n        for(int j = 102; j <= 202; j++)\n            printf(\"%d %d %d\\n\", i, j, O[i - 1][202 - j]);\n    for(int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tvvi c(n+1,vi(m+1,100));\n\trep(i,n+1)rep(j,m+1){\n\t\tint ma=0;\n\t\trep(k,n)rep(l,m)ma=max(ma,in[k][l]-i*(k+1)-j*(l+1));\n\t\tc[i][j]=ma;\n\t}\n\tbool h=true;\n\trep(i,n)rep(j,m){\n\t\tint mi=inf;\n\t\trep(k,n+1)rep(l,m+1)mi=min(mi,(i+1)*k+(j+1)*l+c[k][l]);\n\t\tif(mi!=in[i][j])h=false;\n\t}\n\t\n\tif(!h)cout<<\"Impossible\"<<endl;\n\telse{\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<n+1+m+1<<\" \"<<n+m+(n+1)*(m+1)<<endl;\n\t\trep(i,n)cout<<1+i<<\" \"<<2+i<<\" X\"<<endl;\n\t\trep(i,m)cout<<n+m+1-i<<\" \"<<n+m+2-i<<\" Y\"<<endl;\n\t\trep(i,n+1)rep(j,m+1){\n\t\t\tcout<<1+i<<\" \"<<n+2+j<<\" \"<<c[i][j]<<endl;\n\t\t}\n\t\tcout<<\"1 \"<<n+m+2<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint d[11][11], f[111][111];\n\nint main(void)\n{\n    int A, B, ok = 1;\n    scanf(\"%d %d\", &A, &B);\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            scanf(\"%d\", &d[i][j]);\n    for(int x = 1; x <= A; x++)\n    for(int y = 1; y <= B; y++)\n    for(int a = 0; a <= 100; a++)\n    for(int b = 0; b <= 100; b++)\n    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n    for(int x = 1; x <= A; x++)\n    for(int y = 1; y <= B; y++)\n    {\n        int tmp = 1111;\n        for(int a = 0; a <= 100; a++)\n        for(int b = 0; b <= 100; b++)\n            tmp = min(x * a + y * b + f[a][b], tmp);\n        if(tmp != d[x][y]) ok = 0;\n    }\n    if(!ok) puts(\"Impossible\");\n    else\n    {\n        puts(\"Possible\");\n        printf(\"202 10401\\n\");\n        for(int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n        for(int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n        for(int i = 1; i <= 101; i++)\n            for(int j = 102; j <= 202; j++)\n                printf(\"%d %d %d\\n\", i, j, f[i-1][202-j]);\n        printf(\"1 202\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[55];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 55; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  //cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 10;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = -1;\n\t\tbool finish = false;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tif (finish) break;\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  dx = tdx, dy = tdy, se = tse;\n\t\t\t  finish = true;\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (!finish) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\tputs(\"Possible\");\n\n\t\tset<pair<int,pint> > S;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (auto e : G[i]) {\n\t\t\tS.insert(make_pair(i, e));\n\t\t  }\n\t\t}\n\t\t\n\t\tcout << G.size() << \" \" << S.size() << endl;\n\t\tfor (set<pair<int,pint> >::iterator it = S.begin(); it != S.end(); ++it) {\n\t\t  int from = (*it).first;\n\t\t  int to = (*it).second.first;\n\t\t  int w = (*it).second.second;\n\t\t  cout << from+1 << \" \" << to+1 << \" \";\n\t\t  if (w == -1) cout << \"X\";\n\t\t  else if (w == -2) cout << \"Y\";\n\t\t  else cout << w;\n\t\t  cout << endl;\n\t\t}\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint A,B;\nint C[11][11];\nint DX[11][11];\nint DY[11][11];\nint NV;\nint V[303][303];\nint YV[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(V);\n\t\n\tvector<int> Xs,Ys;\n\tNV=1;\n\tXs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV][NV+1]=-2;\n\t\tNV++;\n\t\tXs.push_back(NV);\n\t}\n\tNV++;\n\tYs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV+1][NV]=-3;\n\t\tNV++;\n\t\tYs.push_back(NV);\n\t}\n\treverse(ALL(Ys));\n\t\n\t\n\tcin>>A>>B;\n\tfor(y=1;y<=A;y++) {\n\t\tfor(x=1;x<=B;x++) {\n\t\t\tcin>>C[y][x];\n\t\t}\n\t}\n\tfor(y=A;y>=1;y--) {\n\t\tfor(x=B;x>=1;x--) {\n\t\t\tif(y<A) {\n\t\t\t\tDY[y][x]=max({DY[y][x],C[y+1][x]-C[y][x],DY[y+1][x]});\n\t\t\t\tDX[y][x]=max({DX[y][x],DX[y+1][x]});\n\t\t\t}\n\t\t\tif(x<B) {\n\t\t\t\tDX[y][x]=max({DX[y][x],C[y][x+1]-C[y][x],DX[y][x+1]});\n\t\t\t\tDY[y][x]=max({DY[y][x],DY[y][x+1]});\n\t\t\t\n\t\t\tif(C[y][x]<DY[y][x]*y+DX[y][x]*x) return _P(\"Impossible\\n\");}\n\t\t\tV[Xs[DX[y][x]]][NV]=C[y][x]-(DY[y][x]*y+DX[y][x]*x);\n\t\t\tV[NV][Ys[DY[y][x]]]=0;\n\t\t\tNV++;\n\t\t}\n\t}\n\t\n\tint cnt=0;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) cnt++;\n\tcout<<cnt<<endl;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) {\n\t\tcout<<x<<\" \"<<y<<\" \";\n\t\tif(V[x][y]==-2) cout<<\"X\"<<endl;\n\t\tif(V[x][y]==-3) cout<<\"Y\"<<endl;\n\t\tif(V[x][y]>=0) cout<<V[x][y]<<endl;\n\t}\n\tcout<<Xs[0]<<\" \"<<Ys[0]<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[191][111];\nint l[110][199];\nint j[111];\n\nlong long x,y,z,mod=1000000007;\n//string r,r1;\nchar r[1];\n\nP u[10];\nqueue<P> q;\n//stack<int> s;\nmap<int,int> p;\nvector<int> v;\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&a,&b);\n  for(int t=1;t<=a;t++)\n    for(int w=1;w<=b;w++)\n    {\n      scanf(\"%d\",&l[t][w]);\n      for(int i=0;i*t<=l[t][w];i++)\n      for(int j=0;i*t+j*w<=l[t][w];j++)\n      o[i][j]=max(o[i][j],l[t][w]-i*t-j*w);\n    }\n  for(int t=1;t<=a;t++)\n  for(int w=1;w<=b;w++)\n  {\n    int p=mod;\n    for(int i=0;i*t<=l[t][w];i++)\n    for(int j=0;i*t+j*w<=l[t][w];j++)\n    p=min(p,i*t+j*w+o[i][j]);\n    if(p!=l[t][w])\n    {\n      puts(\"Impossible\");\n      return 0;\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d %d\\n\",a+b+2,a+b+(a+1)*(b+1));\n  for(int t=1;t<=a;t++)\n    printf(\"%d %d X\\n\",t,t+1);\n  for(int t=a+2;t<a+b+2;t++)\n    printf(\"%d %d Y\\n\",t,t+1);\n  for(int i=1,t=0;i<=a+1;t++,i++)\n  for(int j=a+b+2,w=0;j>=a+2;j--,w++)\n    printf(\"%d %d %d\\n\",i,j,o[t][w]);\n  printf(\"1 %d\",a+b+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\nusing namespace std;\n#pragma region define\n#define M_PI 3.141592653589793238\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\n#pragma endregion\n#pragma region Inner Class\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n#pragma endregion\nusing mint = modint<998244353>;\n//using mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\n#pragma region mint\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nvem kai, inv_kai;\nvoid make_kai(int n) {\n\tkai = vem(n + 1, 1);\n\tinv_kai = vem(n + 1, 1);\n\trep(i, n) { kai[i + 1] = kai[i] * (i + 1); }\n\tinv_kai[n] = (mint)1 / kai[n];\n\tfor (int i = n; i > 0; i--) { inv_kai[i - 1] = inv_kai[i] * i; }\n}\nmint com(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r] * inv_kai[n - r];\n}\nmint per(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r];\n}\n#pragma endregion\nsigned main() {\n\tomajinai;\n\tint a, b; cin >> a >> b;\n\tvvel d(a, vel(b));\n\trep(i, a) { rep(j, b) { cin >> d[i][j]; } }\n\tvvel vx(a, vel(b,-1));\n\tvvel vy(a, vel(b,-1));\n\tvvel vex(a, vel(b,-1));\n\tvvel way;\n\trep(i, a) {\n\t\trep(j, b) {\n\t\t\tfor (int x = 0; x * (i + 1) <= d[i][j]; x++) {\n\t\t\t\tint ex = d[i][j] - x * (i + 1);\n\t\t\t\tfor (int y = 0; y * (j + 1) <= ex; y++) {\n\t\t\t\t\tint qex = ex - y * (j + 1);\n\t\t\t\t\tbool fl = true;\n\t\t\t\t\trep(mi, a) {\n\t\t\t\t\t\trep(mj, b) {\n\t\t\t\t\t\t\tif (d[mi][mj] > qex + x * (mi + 1) + y * (mj + 1)) {\n\t\t\t\t\t\t\t\tfl = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fl) {\n\t\t\t\t\t\tvx[i][j] = x;\n\t\t\t\t\t\tvy[i][j] = y;\n\t\t\t\t\t\tvex[i][j] = qex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vx[i][j]==-1) {\n\t\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway.push_back({ vx[i][j],vy[i][j] + 101,vex[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tmk_uni(way);\n\tcout << 202 << \" \" << 200 + way.size() << endl;\n\trep(i, 100) {\n\t\tcout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n\t\tcout << i + 102 << \" \" << i + 103 << \" Y\" << endl;\n\t}\n\tfor (auto v : way) {\n\t\tcout << v[0] + 1 << \" \" << 303-v[1] << \" \" << v[2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 110;\nint n, m;\nint d[15][15], p[N][N];\nint x[N*N], y[N*N], v[N*N], cnt;\n\nint main() {\n\tint i, j, k, A, B; bool f = 1;\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, n) rep(j, 1, m) {\n\t\tscanf(\"%d\", &d[i][j]);\n\t\tif(i > 1 && d[i][j] < d[i-1][j]) f = 0;\n\t\tif(j > 1 && d[i][j] < d[i][j-1]) f = 0;\n\t}\n\trep(A, 0, 100)\n\t\trep(B, 0, 100) {\n\t\t\tp[A][B] = -100;\n\t\t\trep(i, 1, n)\n\t\t\t\trep(j, 1, m) {\n\t\t\t\t\tp[A][B] = max(p[A][B], d[i][j] - i*A - j*B);\n\t\t\t\t}\n\t\t\tif(p[A][B] >= 0) {\n\t\t\t\t++cnt;\n\t\t\t\tx[cnt] = A; y[cnt] = B+102; v[cnt] = p[A][B];\n\t\t\t}\n\t\t}\n\tif(!f) {puts(\"Impossible\"); return 0;}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 202, cnt+200);\n\trep(i, 1, cnt) printf(\"%d %d %d\\n\", x[i], y[i], v[i]);\n\trep(i, 2, 101) printf(\"%d %d X\\n\", i-1, i);\n\trep(i, 103, 202) printf(\"%d %d Y\\n\", i, i-1);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 3;\nint d[12][12], c[N][N], ma[12][12];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n        ma[i][j] = 1e9;\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        ma[i][j] = min(ma[i][j], cx * i + cy * j + c[cx][cy]);\n    }\n\n    FOR(i,1,a) FOR(j,1,b){\n        if (ma[i][j] != d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    REP(i,N-1) cout << 299-i << \" \" << 300-i << \" Y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\n \ntemplate<typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48; \n    return x *= f;\n}\n\nconst int N = 300;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nint n = 202, m;\nstruct edge { int u, v, w; } e[N * N + 5];\n\nbool chk() {\n    for(int x = 1; x <= A; ++ x) \n        for(int y = 1; y <= B; ++ y) {\n            int mn = oo;\n            for(int a = 0; a <= 100; ++ a) \n                for(int b = 0; b <= 100; ++ b) if(f[a][b] >= 0) \n                    chkmin(mn, f[a][b] + a*x + b*y);\n\n            if(mn != d[x][y]) return false;\n        }\n    return true;\n}\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif \n\n    read(A), read(B);\n    for(int i = 1; i <= A; ++i) \n        for(int j = 1; j <= B; ++j) read(d[i][j]);\n\n    memset(f, ~oo, sizeof f);\n    for(int a = 0; a <= 100; ++ a) \n        for(int b = 0; b <= 100; ++ b) {\n            for(int x = 1; x <= A; ++ x) \n                for(int y = 1; y <= B; ++y) {\n                    chkmax(f[a][b], d[x][y] - a * x - b * y);\n                }\n\n            // if(f[a][b] >= 0) debug(\"%d %d %d \\n\", a, b, f[a][b]);\n        }\n\n    if(!chk()) return !puts(\"Impossible\");\n\n    puts(\"Possible\");\n\n    for(int a = 0; a <= 100; ++ a) \n        for(int b = 0; b <= 100; ++ b) {\n            if(f[a][b] >= 0) e[++ m] = (edge) { a + 1, n - b, f[a][b] };\n        }\n    for(int a = 2; a <= 101; ++ a) e[++ m] = (edge) { a-1, a, -1 };\n    for(int b = n-99; b<= n; ++ b) e[++ m] = (edge) { b-1, b, -2 };\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 1; i <= m; ++i) {\n        printf(\"%d %d \", e[i].u, e[i].v);\n\n        if(e[i].w >= 0) printf(\"%d\\n\", e[i].w);\n        else {\n            puts(e[i].w == -1 ? \"X\" : \"Y\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long\n#define up(i,a,b) for (int i = a, _b = (b); i <= _b; i++)\n#define down(i,a,b) for (int i = a, _b = (b); i >= b; i--)\n#define endl '\\n'\n#define X first\n#define Y second\n#define II pair<int, int>\n#define debug(X) cerr<< #X << \"=\" <<X << endl\n#define debug2(X,Y)  cerr<< #X << \"=\" <<X << \", \" << #Y << \"=\" <<Y << endl\n#define show(X,a,b) {cerr << #X << \" = \"; up(__,a,b) cerr << X[__] << ' '; cerr << endl;}\n#define gc getchar\n#define pc putchar\nusing namespace std;\n\ninline void read(int &x) {\n    register int c = gc();\n    x = 0;\n    int neg = 0;\n    for (;((c<48 || c>57) && c != '-') ;c = gc());\n    if(c=='-') {neg=1;c=gc();}\n    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n    if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n         char buffor[21];\n         register int i=0;\n         int neg=0; if (x<0) {neg=1; x= -x;}\n         do{\n               buffor[i++]=(x%10)+'0';\n               x/=10;\n            } while(x);\n           i--;\n           if (neg) pc('-');\n           while(i>=0) pc(buffor[i--]);\n           pc('\\n');\n       }\nint X, Y, d[12][12], f[102][102];\nvector<II> edge;\nvoid input() {\n    cin >> X >> Y;\n    up(i, 1, X)\n        up(j, 1, Y)\n            cin >> d[i][j];\n}\n\nvoid solve() {\n    //s = 201, t= 202\n    up(a, 0, 100)\n        up(b, 0, 100) {\n            f[a][b] = 0;\n            up(x, 1, X)\n                up(y, 1, Y)\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n        }\n\n    up(x, 1, X)\n        up(y, 1, Y) {\n            int cur_d = 1e9;\n            up(a, 0, 100)\n                up(b, 0, 100)\n                    cur_d = min(cur_d, f[a][b] + x * a + y * b);\n            if (cur_d != d[x][y]) {\n                cout << \"Impossible\"; return;\n            }\n        }\n    cout << \"Possible\" << endl;\n    int s = 201, t = 202;\n    cout << 202 << \" \" << 10401 << endl;\n    cout << s << \" \" << 1 << \" X\" << endl;\n    up(i, 1, 99) cout << i << \" \" << i + 1 << \" X\" << endl;\n    up(i, 101, 199) cout << i << \" \" << i + 1 << \" Y\" << endl;\n    cout << 200 << \" \" << t << \" Y\" << endl;\n    up(i, 101, 200) cout << s << \" \" << i << \" \" << f[0][200 - i + 1] << endl;\n    up(i, 1, 100)\n        up(j, 101, 200)\n            cout << i << \" \" << j << \" \" << f[i][200 - j + 1] << endl;\n    cout << s << \" \" << t << \" \" << f[0][0] << endl;\n    up(i, 1, 100) cout << i << \" \" << t << \" \" << f[i][0] << endl;\n    cout << s << \" \" << t << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    #ifdef I_Love_Pork\n    #define TASK \"tmp\"\n    freopen(TASK\".inp\",\"r\",stdin);\n    freopen(TASK\".out\",\"w\",stdout);\n    #endif\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int M = 12, N = 310;\n\nint d[M][M], dis[M][M], A, B;\nint f[N][N];\n\nint main(){\n\n\tscanf(\"%d%d\", &A, &B);\n\tFor(i, 1, A) For(j, 1, B) scanf(\"%d\", &d[i][j]), dis[i][j] = 1e9;\n\tFor(i, 0, 100) For(j, 0, 100) For(u, 1, A) For(v, 1, B) \n\t\tf[i][j] = max(f[i][j], d[u][v] - u * i - v * j);\n\tFor(u, 1, A) For(v, 1, B) For(i, 0, 100) For(j, 0, 100)\n\t\tdis[u][v] = min(dis[u][v], f[i][j] + i * u + j * v);\n\tFor(u, 1, A) For(v, 1, B) if(d[u][v] != dis[u][v]){\n\t\tputs(\"IMPOSSIBLE\");\n\t\treturn 0;\n\t}\n\n\tint n = 101;\n\tprintf(\"%d %d\\n\", n * 2, n * n + 2 * (n - 1));\n\tFor(i, 1, n) For(j, 1, n) printf(\"%d %d %d\\n\", i, j + n, f[i - 1][j - 1]);\n\tFor(i, 2, n) printf(\"%d %d X\\n\", i - 1, i);\n\tFor(i, 2, n) printf(\"%d %d Y\\n\", i + n, i + n - 1);\n\tprintf(\"%d %d\\n\", 1, n + 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n    int x,y,k;\n}f[20][20];\nint d[20][20];\nbool vis[305][305],fl[20][20];\nint main()\n{\n    int A,B;\n    scanf(\"%d%d\",&A,&B);\n    for (int i=1; i<=A; i++)\n        for (int j=1; j<=B; j++) scanf(\"%d\",&d[i][j]);\n    for (int i=0; i<=100; i++)\n        for (int j=0; j<=100; j++)\n            for (int k=0; k<=100; k++)\n            {\n                bool flag=0;\n                for (int a=1; a<=A; a++)\n                {\n                    for (int b=1; b<=B; b++)\n                    {\n                        if (i*a+j*b+k<d[a][b]) \n                        {\n                            flag=1;\n                            break;\n                        }\n                    }\n                    if (flag) break;\n                }\n                if (flag) continue;\n                for (int a=1; a<=A; a++)\n                {\n                    for (int b=1; b<=B; b++)\n                    {\n                        if (i*a+j*b+k==d[a][b]) f[a][b]=(node){i,j,k},fl[a][b]=1;\n                    }\n                }\n            }\n    for (int a=1; a<=A; a++)\n        for (int b=1; b<=B; b++)\n        {\n            if (!fl[a][b]) \n            {\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    puts(\"Possible\");\n    printf(\"300 %d\\n\",200+A*B);\n    for (int a=1; a<=A; a++)\n        for (int b=1; b<=B; b++)\n        {\n            int i=f[a][b].x,j=f[a][b].y,k=f[a][b].k;\n            if (!vis[i+1][300-j] && fl[a][b]) printf(\"%d %d %d\\n\",i+1,300-j,k);\n            vis[i+1][300-j]=1;\n        }\n    for (int i=1; i<=100; i++) printf(\"%d %d X\\n\",i,i+1);\n    for (int i=1; i<=100; i++) printf(\"%d %d Y\\n\",300-i,300-i+1);\n    printf(\"1 300\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\nusing namespace std;\nstruct p {\n\tint x, y, z;\n\tbool operator<(const p &A) const {\n\t\tif (x != A.x) return x < A.x;\n\t\tif (y != A.y) return y < A.y;\n\t\treturn z < A.z;\n\t}\n\tp& operator-=(const p &A) {\n\t\tx -= A.x; y -= A.y; z -= A.z;\n\t\treturn *this;\n\t}\n};\np cross(const p &A, const p &B) {\n\treturn { A.y*B.z - B.y*A.z, A.z*B.x - B.z*A.x, A.x*B.y - B.x*A.y };\n}\nstruct Plane {\n\tint a, b, c; // z = ax + by + c\n\tbool valid;\n\tPlane(p u, p v, p z) {\n\t\tvalid = false;\n\t\tu -= z; v -= z;\n\t\tp t = cross(u, v);\n\t\tif (t.z == 0 || t.x%t.z != 0 || t.y % t.z != 0) return;\n\t\ta = -t.x / t.z; b = -t.y / t.z;\n\t\tc = z.z - a * z.x - b * z.y;\n\t\tif (c < 0 || a < 0 || b < 0) return;\n\t\tvalid = true;\n\t}\n\tbool operator<(const Plane &A) const {\n\t\tif (a != A.a) return a < A.a;\n\t\tif (b != A.b) return b < A.b;\n\t\treturn c < A.c;\n\t}\n\tint operator()(const p &A) const {\n\t\treturn a * A.x + b * A.y + c;\n\t}\n};\nvector<p> v;\nint chk[111];\nbool isunder(Plane c, p x) {\n\treturn c(x) >= x.z;\n}\nset<Plane> ans;\nint main() {\n\tint a, b, n, t;\n\tscanf(\"%d%d\", &a, &b);\n\tn = a * b;\n\tfor (int i = 1; i <= a; i++)for (int j = 1; j <= b; j++) {\n\t\tscanf(\"%d\", &t);\n\t\tv.push_back({ i, j, t });\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) for (int k = j + 1; k < n; k++) {\n\t\tPlane t(v[i], v[j], v[k]);\n\t\tif (!t.valid) continue;\n\t\tint succ = 1;\n\t\tfor (auto x : v) {\n\t\t\tif (!isunder(t, x)) {\n\t\t\t\tsucc = 0; break;\n\t\t\t}\n\t\t}\n\t\tif (succ) {\n\t\t\tchk[i] = chk[j] = chk[k] = 1;\n\t\t\tans.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (chk[i] == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"200 %d\\n\", 198 + ans.size());\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d Y\\n\", i + 100, i + 101);\n\tfor (auto t : ans) {\n\t\tprintf(\"%d %d %d\\n\", t.a + 1, 200 - t.b, t.c);\n\t}\n\tprintf(\"1 200\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 505\n#define MAXN 149\n#define INF 1000000000\nusing namespace std;\nint n,m,f[M][M],g[M][M],S,T;\nint read(){\n\tchar c=getchar();int ans=0;\n    while (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans;\n}\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n\tn=read(),m=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++) f[i][j]=read();\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tfor (register int k=1;k<=n;k++)\n\t\t\t\tfor (register int l=1;l<=m;l++)\n\t\t\t\t\tg[i][j]=max(g[i][j],f[k][l]-k*i-l*j);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++){\n\t\t\tint now=INF;\n\t\t\tfor (register int k=0;k<=MAXN;k++)\n\t\t\t\tfor (register int l=0;l<=MAXN;l++)\n\t\t\t\t\tnow=min(now,k*i+l*j+g[k][l]);\n\t\t\tif (now!=f[i][j]){printf(\"Impossible\");while (1);return 0;}\n\t\t}\n\tprintf(\"Possible\\n%d %d\\n\",MAXN+MAXN+1,(MAXN+1)*(MAXN+1)+2*MAXN);\n\tS=1,T=MAXN+MAXN+1;\n\tfor (register int i=1;i<=MAXN;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (register int i=MAXN+1;i<=MAXN+MAXN;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,MAXN+MAXN-j,g[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint d[10][10];\nint c[101][101];\n\nint main(){\n\tint a,b;\n\tcin >> a >> b;\n\n\tfor(int i=0; i<a; i++)\n\t\tfor(int j=0; j<b; j++)\n\t\t\tcin >> d[i][j];\n\n\tfor(int i=0; i<a; i++){\n\t\tfor(int j=1; j<b;j++){\n\t\t\tif(d[i][j-1] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(j!=b-1 && d[i][j-1] + d[i][j+1] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0; j<b; j++){\n\t\tfor(int i=1; i<a;i++){\n\t\t\tif(d[i-1][j] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(i!=a-1 && d[i-1][j] + d[i+1][j] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\n\tfor(int i=1;i<=100;i++){\n\t\tcout << i <<\"  \"<< i+1 <<\" X\"<<endl;\n\t\tcout << i+101 <<\" \"<< i+102 <<\" Y\"<<endl;\n\t}\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tint res = 0;\n\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tif(res < d[i-1][j-1] - kx*i - ky*j)\n\t\t\t\t\t\tres = d[i-1][j-1] - kx*i - ky*j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << kx+1 <<\" \"<<202 - ky<<\" \"<<res<<endl;\n\t\t}\n\t}\n\n\n\tcout << \"1 202\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\n#define int ll\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nsigned main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\ta = max(a, ll(100));\n\tb = max(b, ll(100));\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\t\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Ralif Rakhmatullin\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cstring>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<valarray>\n#include<iterator>\n#include<list>\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define S second\n#define ld long double\n#define F first\n#define y1 LOL\n#define ld long double\n#define pb push_back\n#define len length\n#define sz size\n#define beg begin\nconst ll INF = (ll)1e18 + 123;\nconst int inf=(int)2e9 + 123; \nconst int mod=1e9+7;\nusing namespace std;\nint n, A, B, d[21][21], f[111][111];\nint main(){\n\tunsigned int FOR;\n \tasm(\"rdtsc\" : \"=A\"(FOR));\n  \tsrand(FOR);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout.tie(0);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i ++){\n\t\tfor(int j = 1; j <= B; j ++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tint n = 1;\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tfor(int a = 1; a <= A; a ++){\n\t\t\t\tfor(int b = 1; b <= B; b ++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[a][b] - a * i - b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int a = 1; a <= A; a ++){\n\t\tfor(int b = 1; b <= B; b ++){\n\t\t\tint res = inf;\n\t\t\tfor(int i = 0; i <= 100; i ++){\n\t\t\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\t\t\tres = min(res, f[i][j] + a * i + b * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res != d[a][b]){\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tint s = 1, t = 201;\n\tcout << t << \" \" << 101 * 101 + 200 << endl;\n\tfor(int i = 2; i <= 101; i ++){\n\t\tcout << i - 1 << \" \" << i << \" X\\n\";\n\t}\n\tfor(int i = 102; i <= t; i ++){\n\t\tcout << i - 1 << \" \" << i << \" Y\\n\";\n\t}\n\tfor(int i = 0; i <= 100; i ++){\n\t\tfor(int j = 0; j <= 100; j ++){\n\t\t\tcout << i + 1 << \" \" << t - j << \" \" << f[i][j] << endl;\n\t\t}\n\t}\n\tcout << s << \" \" << t;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef std::pair<int,int> P;\n#define mk std::make_pair\n#define fr first\n#define sc second\ninline int in()\n{\n\tint k=0;char ch=gt;bool p=1;\n\twhile(ch<'-')ch=gt;if(ch=='-')ch=gt,p=0;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn p?k:-k;\n}\nconst int N=105;\nint f[N][N],d[N][N];\nint main()\n{\n\tint n=in(),m=in();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\td[i][j]=in();\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tfor(int a=1;a<=n;++a)\n\t\t\t\tfor(int b=1;b<=m;++b)\n\t\t\t\t\tf[i][j]=std::max(f[i][j],d[a][b]-a*i-b*j);\n\tfor(int a=1;a<=n;++a)\n\t\tfor(int b=1;b<=m;++b)\n\t\t{\n\t\t\tint mi=1e9;\n\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\tmi=std::min(mi,f[i][j]+a*i+b*j);\n\t\t\tif(mi!=d[a][b])return puts(\"Impossible\"),0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=1;i<=100;++i)printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(int A, int B) {\n  int dist[10][10];\n  for (int i = 0; i < A; i++) {\n    for (int j = 0; j < B; j++) {\n      cin >> dist[i][j];\n    }\n  }\n\n  int T = 101;\n  vector<vector<int>> data(T, vector<int>(T, -1));\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int basecost = 0;\n          basecost += (i + 1) * x;\n          basecost += (j + 1) * y;\n          int amari = dist[i][j] - basecost;\n          data[x][y] = max(data[x][y], amari);\n        }\n    }\n  }\n\n  int cnt = 0;\n  vector<vector<int>> ans(A, vector<int>(B, 200));\n  for (int x = 0; x < T; x++)\n    for (int y = 0; y < T; y++) {\n      // cout << x << \" \" << y << \" \" << data[x][y] << endl;\n      if (data[x][y] < 0) continue;\n      cnt++;\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int cost = (i + 1) * x + (j + 1) * y + data[x][y];\n          ans[i][j] = min(ans[i][j], cost);\n        }\n    }\n  for (int i = 0; i < A; i++)\n    for (int j = 0; j < B; j++)\n      if (ans[i][j] != dist[i][j]) return false;\n\n  cout << \"POSSIBLE\" << endl;\n  cout << 2 * T + 1 << \" \" << 2 * T + cnt << endl;\n  for (int i = 0; i < T; i++) {\n    cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n  }\n  for (int i = 0; i < T; i++) {\n    cout << i + T + 1 << \" \" << i + T + 2 << \" Y\" << endl;\n  }\n  int s = 1;\n  int t = T + T + 1;\n\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      if (data[x][y] < 0) continue;\n      cout << s + x << \" \" << t - y << \" \" << data[x][y] << endl;\n    }\n  }\n  cout << s << \" \" << t << endl;\n  return true;\n}\nint main() {\n  int A, B;\n  cin >> A >> B;\n  bool ok = solve(A, B);\n  if (!ok) {\n    cout << \"IMPOSSIBLE\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint G[11][11], a[11][11], b[11][11];\n\nint main(void)\n{\n    int A, B, ok = 1;\n    scanf(\"%d %d\", &A, &B);\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            scanf(\"%d\", &G[i][j]);\n    for(int i = 1; i <= A; i++)\n    for(int j = 1; j <= B; j++)\n    {\n        int ma = 0, mb = 0;\n        for(int k = i + 1; k <= A; k++)\n        {\n            if(G[k][j] < G[i][j]) ok = 0;\n            ma = max(ma, (G[k][j] - G[i][j] + k - i - 1) / (k - i));\n        }\n        for(int k = j + 1; k <= B; k++)\n        {\n            if(G[i][k] < G[i][j]) ok = 0;\n            mb = max(mb, (G[i][k] - G[i][j] + k - j - 1) / (k - j));\n        }\n        if(i * ma + j * mb > G[i][j]) ok = 0;\n        else a[i][j] = ma, b[i][j] = mb;\n    }\n    if(!ok) puts(\"Impossible\");\n    else\n    {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 200 + A * B, 198 + 2 * A * B);\n        for(int i = 1; i < 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n        for(int i = 101; i < 200; i++) printf(\"%d %d Y\\n\", i, i + 1);\n        for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n        printf(\"%d %d %d\\n%d %d %d\\n\", a[i][j] + 1, 200 + (i - 1) * B + j, 0, 200 + (i - 1) * B + j, 200 - b[i][j], G[i][j] - i * a[i][j] - j * b[i][j]);\n        printf(\"1 200\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint d[10][10];\n\nint main(){\n\tint a,b;\n\tcin >> a >> b;\n\n\tfor(int i=0; i<a; i++)\n\t\tfor(int j=0; j<b; j++)\n\t\t\tcin >> d[i][j];\n\n\tfor(int i=0; i<a; i++){\n\t\tfor(int j=0; j<b;j++){\n\t\t\tif(j != 0){\n\t\t\t\tif(d[i][j-1] > d[i][j]){\n\t\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(j!=b-1 && d[i][j-1] + d[i][j+1] > 2*d[i][j]){\n\t\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(i != 0 && d[i-1][j-1] + d[i][i] > d[i][j-1] + d[i-1][j]){\n\t\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i != 0){\n\t\t\t\tif(d[i-1][j] > d[i][j]){\n\t\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(i!=a-1 && d[i-1][j] + d[i+1][j] > 2*d[i][j]){\n\t\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\n\tfor(int i=1;i<=100;i++){\n\t\tcout << i <<\"  \"<< i+1 <<\" X\"<<endl;\n\t\tcout << i+101 <<\" \"<< i+102 <<\" Y\"<<endl;\n\t}\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tint res = 0;\n\n\t\t\tfor(int i=1;i<=a;i++){\n\t\t\t\tfor(int j=1;j<=b;j++){\n\t\t\t\t\tif(res < d[i-1][j-1] - kx*i - ky*j)\n\t\t\t\t\t\tres = d[i-1][j-1] - kx*i - ky*j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << kx+1 <<\" \"<<202 - ky<<\" \"<<res<<endl;\n\t\t}\n\t}\n\n\n\tcout << \"1 202\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      rep(x, a){\n        rep(y, b){\n          chmax(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][100-j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define se second\n#define fi first\n#define mk(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pii;\n\nint A,B;\nint D[10][10];\nint mem[110][110];\nvector<pii> G[300];\nint dis[300];\n\nint main()\n{\n    scanf(\"%d%d\",&A,&B);\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            scanf(\"%d\",&D[i][j]);\n        }\n    }\n\n    for(int i = 0; i <= 100; i++)\n    {\n        for(int j = 0; j <= 100; j++)\n        {\n            int res = 0;\n            for(int k = 1; k <= A; k++)\n            {\n                for(int l = 1; l <= B; l++)\n                {\n                    res = max(res,D[k][l] - i * k - j * l);\n                }\n            }\n            if(res > 100)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            mem[i][j] = res;\n        }\n    }\n\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            int MIN = 1001001001;\n            for(int k = 0; k <= 100; k++)\n            {\n                for(int l = 0; l <= 100; l++)\n                {\n                    MIN = min(MIN,k * i + l * j + mem[k][l]);\n                }\n            }\n            if(MIN != D[i][j])\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"202 10401\\n\");\n    for(int i = 0; i < 100; i++)\n    {\n        printf(\"%d %d X\\n\",i + 1,i + 2);\n        printf(\"%d %d Y\\n\",i + 2 + 101,i + 1 + 101);\n    }\n\n    for(int i = 0; i < 101; i++)\n    {\n        for(int j = 0; j < 101; j++)\n        {\n            printf(\"%d %d %d\\n\",j + 1,i + 1 + 101,mem[i][j]);\n        }\n    }\n\n    printf(\"1 102\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint nr, N, A, B, d[15][15], mi[109][109], cod[2][109];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &A, &B);\nfor (int x=1; x<=A; x++)\n    for (int y=1; y<=B; y++)\n    {\n        scanf (\"%d\", &d[x][y]);\n        for (int i=0; i<=100; i++)\n            for (int j=0; j<=100; j++)\n            {\n                int curr = d[x][y] - x * i - y * j;\n                if (curr > mi[i][j])\n                    mi[i][j] = curr;\n            }\n    }\nfor (int x=1; x<=A; x++)\n    for (int y=1; y<=B; y++)\n    {\n        int mini = 1 << 30;\n        for (int i=0; i<=100; i++)\n            for (int j=0; j<=100; j++)\n            {\n                int curr = mi[i][j] + i * x + j * y;\n                if (curr < mini)\n                    mini = curr;\n            }\n        if (mini != d[x][y])\n        {\n            printf (\"Impossible\\n\");\n            return 0;\n        }\n    }\nfor (int i=0; i<2; i++)\n    for (int j=0; j<=100; j++)\n        cod[i][j] = ++nr;\nprintf (\"Possible\\n\");\nprintf (\"%d %d\\n\", nr, 101 * 101 + 200);\nfor (int i=0; i<2; i++)\n{\n    char c = (i == 0 ? 'X' : 'Y');\n    for (int j=1; j<=100; j++)\n        printf (\"%d %d %c\\n\", cod[i][j - 1], cod[i][j], c);\n}\nfor (int i=0; i<=100; i++)\n    for (int j=0; j<=100; j++)\n        printf (\"%d %d %d\\n\", cod[0][i], cod[1][100 - j], mi[i][j]);\nprintf (\"%d %d\\n\", cod[0][0], cod[1][100]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nchar buf[1<<21], *p1, *p2;\n#define getc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin)), p1 == p2 ? EOF : *p1++)\n#define lint long long\n#define isnum(x) ('0' <= (x) && (x) <= '9')\ntemplate<typename tint>\ninline void readint(tint& x) {\n\tint f = 1; char ch = getc(); x = 0;\n\tfor(; !isnum(ch); ch = getc()) if(ch == '-') f = -1;\n\tfor(; isnum(ch); ch = getc()) x = x * 10 + ch - '0';\n\tx *= f;\n}\nusing namespace std;\nconst int maxa = 12;\nconst int maxn = 204;\n\n// dist[x][y] = min{i * x + j * y + f[i][j]}\n// dist[x][y] - i * x - j * y <= f[i][j]\n// f[i][j] = max{dist[x][y] - i * x - j * y}\n\n// f[i][j] = max{dist[x][y] - i * x - j * y}\n\nint n = 202, m = 100;\nint A, B;\nint dist[maxa][maxa], f[maxn][maxn];\nint edge[maxn][maxn];\nint now[maxn];\nbool vis[maxn];\n\nint main() {\n\tmemset(f, -1, sizeof(f)), memset(edge, -1, sizeof(edge));\n\treadint(A), readint(B);\n\tfor(int i=1; i<=A; i++) {\n\t\tfor(int j=1; j<=B; j++) readint(dist[i][j]);\n\t}\n\n\tint cnt = 0;\n\tfor(int i=0; i<=m; i++) {\n\t\tfor(int j=0; j<=m; j++) {\n\t\t\tfor(int x=1; x<=A; x++) {\n\t\t\t\tfor(int y=1; y<=B; y++) {\n\t\t\t\t\tf[i][j] = max(f[i][j], dist[x][y] - i * x - j * y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// i个x, j个y的最短路\n\t\t\tedge[i + 1][202 - j] = f[i][j];\n\t\t\tif(edge[i + 1][202 - j] != -1) cnt++;\n\t\t}\n\t}\n\n\n\tfor(int a=1; a<=A; a++) {\n\t\tfor(int b=1; b<=B; b++) {\n\t\t\tfor(int i=1; i<=100; i++) edge[i][i+1] = a;\n\t\t\tfor(int i=102; i<=201; i++) edge[i][i+1] = b;\n\t\t\tmemset(vis, 0, sizeof(vis)), memset(now, 0x3f, sizeof(now));\n\t\t\tnow[1] = 0;\n\t\t\twhile(true) {\n\t\t\t\tint x = 0;\n\t\t\t\tfor(int i=1; i<=n; i++) if(!vis[i] && now[i] < now[x]) x = i;\n\t\t\t\tif(x == 0) break;\n\t\t\t\tvis[x] = 1;\n\t\t\t\tfor(int y=1; y<=n; y++)\n\t\t\t\t\tif(edge[x][y] != -1 && now[y] > now[x] + edge[x][y]) now[y] = now[x] + edge[x][y];\n\t\t\t}\n\t\t\tif(now[n] != dist[a][b]) { puts(\"Impossible\"); return 0; }\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n, cnt + 200);\n\tfor(int i=1; i<=100; i++) printf(\"%d %d X\\n\", i, i+1);\n\tfor(int i=102; i<=201; i++) printf(\"%d %d Y\\n\", i, i+1);\n\tfor(int i=0; i<=m; i++) {\n\t\tfor(int j=0; j<=m; j++) {\n\t\t\tif(f[i][j] == -1) continue;\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 1, 202);\n\t// [1, 101] [102, 202]\n\t//\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n// Y\n// X + 1\n// X + X\n// 3\n\n// x = 2, y = 3\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint A, B;\nint D[11][11];\nint C[101][101];\nint main() {\n\tcin >> A >> B;\n\n\tREP(i, 0, A) {\n\t\tREP(j, 0, B) {\n\t\t\tcin >> D[i + 1][j + 1];\n\t\t}\n\t}\n\n\tREP(x, 0, 101) {\n\t\tREP(y, 0, 101) {\n\t\t\tREP(a, 1, A + 1) {\n\t\t\t\tREP(b, 1, B + 1) {\n\t\t\t\t\tC[x][y] = max(C[x][y], D[a][b] - (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok = 1;\n\tREP(a, 1, A + 1) {\n\t\tREP(b, 1, B + 1) {\n\t\t\tint mn = INF;\n\t\t\tREP(x, 0, 101) {\n\t\t\t\tREP(y, 0, 101) {\n\t\t\t\t\tmn = min(mn, C[x][y] + (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != D[a][b]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (ok ? \"Possible\" : \"Impossible\") << endl;\n\tif (ok) {\n\t\tint X = 100;\n\t\tint Y = 100;\n\t\tcout << X + Y + 1 << ' ' << (X + 1) * (Y + 1) + X + Y - 1 << endl;\n\t\tREP(i, 0, X) {\n\t\t\tcout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n\t\t}\n\t\tREP(i, 0, Y) {\n\t\t\tcout << i + X + 1 << ' ' << i + X + 2 << \" Y\" << endl;\n\t\t}\n\n\t\tint S = X + 1;\n\t\tREP(i, 0, X + 1) {\n\t\t\tREP(j, 0, Y + 1) {\n\t\t\t\tif (i == X && j == Y) continue;\n\t\t\t\tcout << S - (X - i) << ' ' << S + (Y - j) << ' ' << C[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int A,B;cin>>A>>B;\n  vector<vll> d(A,vll(B));\n  repeat(i,A){\n    repeat(j,B){\n      cin>>d[i][j];\n    }\n  }\n  vector<vll> f(110,vll(110,0));\n  repeat(a,101){\n    repeat(b,101){\n      repeat(x,A){\n        repeat(y,B){\n          f[a][b]=max(f[a][b],d[x][y]-a*(x+1)-b*(y+1));\n        }\n      }\n    }\n  }\n  vector<vll> D(A,vll(B,INF));\n  bool isok=true;\n  repeat(x,A){\n    repeat(y,B){\n      repeat(a,101){\n        repeat(b,101){\n          D[x][y]=min(D[x][y],a*(x+1)+b*(y+1)+f[a][b]);\n        }\n      }\n      isok &= D[x][y]==d[x][y];\n    }\n  }\n  if(!isok){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  repeat(i,100){\n    cout << i+1 << \" \" << i+2 << \" x\" << endl;\n  }\n  repeat(i,100){\n    cout << i+102 << \" \" << i+103 << \" y\" << endl;\n  }\n  repeat(i,101){\n    repeat(j,101){\n      cout << i+1 << \" \" << 202-j << f[i][j] << endl;\n    }\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nbool exi[301][301];\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 2, cur = 3;\n\tRep1(i, 3, 102) {\n\t\tv.push_back({ i - 1,i,\"X\" });\n\t}\n\tRep(i, 103, 202) {\n\t\tv.push_back({ i,i + 1,\"Y\" });\n\t}\n\tv.push_back({ 202,2,\"Y\" });\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\trep(k, 101) {\n\t\t\t\tint l = k;\n\t\t\t\tif (l*i > d[i][j]) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t\tint r = (d[i][j] - l*i) / j;\n\t\t\t\tint z = d[i][j] - l*i - r * j;\n\t\t\t\tbool f = true;\n\t\t\t\trep1(i_, a) {\n\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tint sta = 2 + l; if (l == 0)sta = 1;\n\t\t\t\t\tint goa = 203 - r; if (r == 0)goa = 2;\n\t\t\t\t\tif(!exi[sta][goa])v.push_back({ sta,goa,to_string(z) });\n\t\t\t\t\texi[sta][goa] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == 100)valid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << cur - 1 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 2\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    int matrix[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++) cin >> matrix[i][j];\n    }\n    int mnx[a][b], mny[a][b], mxx[a][b], mxy[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            mnx[i][j] = 0;\n            mny[i][j] = 0;\n            mxx[i][j] = matrix[i][j] / (i+1);\n            mxy[i][j] = matrix[i][j] / (j+1);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b-1; j++){\n            int D = matrix[i][j+1] - matrix[i][j];\n            mny[i][j] = max(mny[i][j], D);\n            mxy[i][j+1] = min(mxy[i][j+1], D);\n        }\n    }\n    for (int i=0; i < a-1; i++){\n        for (int j=0; j < b; j++){\n            int D = matrix[i+1][j] - matrix[i][j];\n            mnx[i][j] = max(mnx[i][j], D);\n            mxx[i+1][j] = min(mxx[i+1][j], D);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            if (mnx[i][j] > mxx[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mny[i][j] > mxy[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mnx[i][j] * (i+1) + mny[i][j] * (j+1) > matrix[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    //cout << mxx[0][1] << \" \" << mxy[0][1] << endl;\n    int sv = 3;\n    vector<pair<int, int> > reb;\n    vector<int> wh;\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            int K, L, res = -1;\n            for (int k=mnx[i][j]; k <= mxx[i][j]; k++){\n                for (int l=mny[i][j]; l <= mxy[i][j]; l++){\n                    int re = k * (i+1) + l * (j+1);\n                    if (re > matrix[i][j]) continue;\n                    int N = k+l+1;\n                    if (N > res){\n                        res = N;\n                        K = k;\n                        L = l;\n                    }\n                }\n            }\n            int last = 1;\n            for (int k=0; k < K; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-1);\n                last = sv;\n                sv++;\n            }\n            for (int k=0; k < L; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-2);\n                last = sv;\n                sv++;\n            }\n            reb.push_back(make_pair(last, 300));\n            wh.push_back(matrix[i][j] - K * (i+1) - L * (j+1));\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << reb.size() << endl;\n    for (int i=0; i < reb.size(); i++){\n        cout << reb[i].first << \" \" << reb[i].second << \" \";\n        if (wh[i] == -1) cout << \"X\" << endl;\n        else if (wh[i] == -2) cout << \"Y\" << endl;\n        else cout << wh[i] << endl;\n    }\n    cout << \"1 300\" << endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            func mn={101, 101, 102};\n            for(int ix = 0; ix <= 100; ix++)\n            {\n                for(int iy = 0; iy <= 100; iy++)\n                {\n                    int cost = ix*i + iy*j;\n                    if(cost > d[i][j]) continue;\n                    int kk = d[i][j] - cost;\n                    //if(kk > mn.k) continue;\n                    if(ix+iy > mn.xc + mn.yc) continue;\n                    bool flag=true;\n                    for(int ita = 1; ita <= a; ita++)\n                    {\n                        for(int itb = 1; itb <= b; itb++)\n                        {\n                            if(ix*ita + iy*itb + kk < d[ita][itb])\n                            {\n                                flag=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(flag)\n                    {\n                        mn={ix, iy, kk};\n                    }\n                }\n            }\n            if(mn.xc==101)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb(mn);\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    if(nodes>300) exit(7);\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\tfreopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N*2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+1;i<N*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i+1,i);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i,N+j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 130, M = N*N;\nint n, m;\nint d[15][15], p[N][N];\nint x[M], y[M], v[M], cnt;\n\nint dis(int A, int B) {\n\tint ret = 101, i, j;\n\trep(i, 0, 100)\n\t\trep(j, 0, 100)\n\t\t\tif(p[i][j] >= 0) ret = min(ret, i*A + j*B + p[i][j]);\n\treturn ret;\n}\n\nint main() {\n\tint i, j, k, A, B; bool f = 1;\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, n) rep(j, 1, m) scanf(\"%d\", &d[i][j]);\n\trep(A, 0, 100)\n\t\trep(B, 0, 100) {\n\t\t\tp[A][B] = -100;\n\t\t\trep(i, 1, n)\n\t\t\t\trep(j, 1, m) {\n\t\t\t\t\tp[A][B] = max(p[A][B], d[i][j] - i*A - j*B);\n\t\t\t\t}\n\t\t\tif(p[A][B] >= 0) {\n\t\t\t\t++cnt;\n\t\t\t\tx[cnt] = A+1; y[cnt] = B+102; v[cnt] = p[A][B];\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\trep(i, 1, n) rep(j, 1, m) \n\tif(dis(i, j) != d[i][j]) {puts(\"Impossible\"); return 0;}\n\t\t\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 202, cnt+200);\n\trep(i, 1, cnt) printf(\"%d %d %d\\n\", x[i], y[i], v[i]);\n\trep(i, 2, 101) printf(\"%d %d X\\n\", i-1, i);\n\trep(i, 103, 202) printf(\"%d %d Y\\n\", i, i-1);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100;\nint x,y,d[105][105],f[105][105];\nint main()\n{\n    scanf(\"%d%d\",&x,&y);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j)\n            scanf(\"%d\",&d[i][j]);\n    for (int a=0;a<=maxn;++a)\n        for (int b=0;b<=maxn;++b)\n            for (int i=1;i<=x;++i)\n                for (int j=1;j<=y;++j)\n                    f[a][b]=max(f[a][b],d[i][j]-a*i-b*j);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j) {\n            int dis=10000000;\n            for (int a=0;a<=maxn;++a)\n                for (int b=0;b<=maxn;++b)\n                    dis=min(dis,f[a][b]+a*i+b*j);\n            if (dis!=d[i][j]) return 0*puts(\"Impossible\");\n        }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\",maxn+maxn+2,maxn+maxn+(maxn+1)*(maxn+1));\n    for (int i=1;i<=maxn;++i) printf(\"%d %d X\\n\",i,1+i);\n    for (int i=1;i<=maxn;++i) printf(\"%d %d Y\\n\",maxn+1+i,maxn+2+i);\n    for (int i=1;i<=maxn+1;++i)\n        for (int j=1;j<=maxn+1;++j)\n            printf(\"%d %d %d\\n\",i,maxn+maxn+3-j,f[i-1][j-1]);\n    printf(\"%d %d\\n\",1,maxn+maxn+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=105;\nint a,b,f[N][N],d[N][N],s[N][N];\nint main()\n{\n    scanf(\"%d%d\",&a,&b);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        scanf(\"%d\",&d[x][y]);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        f[i][j]=max(f[i][j],d[x][y]-(i-1)*x-(101-j)*y);\n    memset(s,inf,sizeof(s));\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n            for(int x=1;x<=a;x++)\n            for(int y=1;y<=b;y++)\n            s[x][y]=min(s[x][y],f[i][j]+(i-1)*x+(101-j)*y);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        if(d[x][y]!=s[x][y])\n    {\n        printf(\"Impossible\\n\");\n        return 0;\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\",100+100+101*101);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d X\\n\",i,i+1);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d Y\\n\",101+i,101+i+1);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        printf(\"%d %d %d\\n\",i,j+101,f[i][j]);\n    printf(\"%d %d\\n\",1,202);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\"=\"<<x<<endl\n#define DEBUG2(x,y) cout<<#x<<\"=\"<<x<<\",\"<<#y<<\"=\"<<y<<endl\ntypedef long long ll;\nclass Solver{\npublic:\n    static const int MAXD=11;\n    int A,B;\n    int d[MAXD][MAXD];\n    int f[MAXD*MAXD][MAXD*MAXD];\n    void solve(){\n        cin>>A>>B;\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++)\n                cin>>d[x][y];\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        f[a][b]=max(0,d[x][y]-x*a-y*b);\n                    }\n                }\n            }\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                int mmin=1e9;\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        mmin=min(mmin,x*a+y*b+f[a][b]);\n                    }\n                }\n                if(mmin!=d[x][y]){\n                    cout<<\"Impossible\\n\";\n                    return;\n                }\n            }\n        }\n        cout<<\"Possible\\n\";\n        cout<<300<<\" \"<<101*101+298<<\"\\n\";\n        for(int u=1;u<150;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'X'<<\"\\n\";\n        }\n        for(int u=151;u<300;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'Y'<<\"\\n\";\n        }\n        for(int u=0;u<=100;u++){\n            for(int v=0;v<=100;v++){\n                cout<<u+1<<\" \"<<300-v<<\"  \"<<f[u][v]<<\"\\n\";\n            }\n        }\n        cout<<1<<\" \"<<300;\n    }\n};\nint main()\n{\n    // freopen(\"in.txt\",\"r\",stdin);\n    (new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,y,d[105][105],f[105][105];\nint main()\n{\n    scanf(\"%d%d\",&x,&y);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j)\n            scanf(\"%d\",&d[i][j]);\n    for (int a=0;a<=100;++a)\n        for (int b=0;b<=100;++b)\n            for (int i=1;i<=x;++i)\n                for (int j=1;j<=y;++j)\n                    f[a][b]=max(f[a][b],d[i][j]-a*i-b*j);\n    for (int i=1;i<=x;++i)\n        for (int j=1;j<=y;++j) {\n            int dis=10000000;\n            for (int a=0;a<=100;++a)\n                for (int b=0;b<=100;++b)\n                    dis=min(dis,f[a][b]+a*i+b*j);\n            if (dis!=d[i][j]) return 0*puts(\"Impossible\");\n        }\n    puts(\"Possible\");\n    for (int i=1;i<=100;++i) printf(\"%d %d X\\n\",i,1+i);\n    for (int i=1;i<=100;++i) printf(\"%d %d X\\n\",101+i,102+i);\n    for (int i=1;i<=101;++i)\n        for (int j=1;j<=101;++j)\n            printf(\"%d %d %d\\n\",i,101+j,f[i-1][j-1]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 105;\nint f[maxn][maxn][maxn], d[maxn][maxn], ans[maxn][maxn][3];\nint A, B, mxA, mxB, n;\n\nint main() {\n\tscanf(\"%d%d\", &A, &B);\n\trep (i, 1, A) rep (j, 1, B) scanf(\"%d\", &d[i][j]);\n\trep (a, 0, 100) rep (b, 0, 100) rep (c, 0, 100) if (a + b + c <= 100) {\n\t\trep (i, 1, A) if (!f[a][b][c])\n\t\t\trep (j, 1, B) if (a * i + b * j + c < d[i][j]) {\n\t\t\t\t//printf(\"%d %d %d\\n\", a, b, c);\n\t\t\t\tf[a][b][c] = 1; break;\n\t\t\t}\n\t}\n\trep (i, 1, A) rep (j, 1, B) {\n\t\tint flag = 0;\n\t\trep (a, 0, 100) if (!flag)\n\t\t\trep (b, 0, 100) if (!flag && a * i + b * j <= d[i][j]) \n\t\t\t\trep (c, 0, 100) if (a * i + b * j + c == d[i][j] && !f[a][b][c]) {\n\t\t\t\t\tans[i][j][0] = a; ans[i][j][1] = b; ans[i][j][2] = c;\n\t\t\t\t\tmxA = max(mxA, a); mxB = max(mxB, b); flag = 1; break;\n\t\t\t\t}\t\t\t\t\n\t\tif (!flag) return puts(\"Impossible\"), 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n = mxA + mxB + 2, mxA + mxB + A * B);\n\trep (i, 1, mxA) printf(\"%d %d X\\n\", i, i + 1);\n\trep (i, n-mxB, n-1) printf(\"%d %d Y\\n\", i, i + 1);\n\trep (i, 1, A) rep (j, 1, B)\n\t\tprintf(\"%d %d %d\\n\", ans[i][j][0]+1, n-ans[i][j][1], ans[i][j][2]);\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint a, b;\nint d[105][105];\n\nbool ok(int i, int j, int x, int y) {\n  int c = d[i][j] - i*x - j*y;\n  for (int i1 = 1; i1 <= a; ++i1) for (int j1 = 1; j1 <= b; ++j1) {\n    if (c + i1 * x + j1 * y < d[i1][j1]) {\n      return 0;\n    }\n  }\n//  cerr << i << ' ' << j << ' ' << x << ' ' << y << ' ' << c << endl;\n  return 1;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  cin >> a >> b;\n  int maxd = 0;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    cin >> d[i][j];\n    maxd = max(maxd, d[i][j]);\n    if ((i > 1 && d[i][j] < d[i-1][j]) || (j > 1 && d[i][j] < d[i][j-1])) {\n      cout << \"Impossible\\n\"; return 0;\n    }\n  }\n  vector<vii> res(a + 1, vii(b + 1));\n  int T = maxd;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    bool found = 0;\n    for (int x = 0; x <= T && !found; ++x) for (int y = 0; i*x+j*y <= d[i][j]; ++y) {\n      if (ok(i, j, x, y)) {\n        res[i][j] = pii(x, y);\n        found = 1; break;\n      }\n    }\n    if (!found) {\n      cout << \"Impossible\\n\"; return 0;\n    }\n  }\n  cout << \"Possible\\n\";\n  int s = 0, t = 2 * (T + 1) - 1;\n  vector<array<int, 3>> e;\n  for (int i = 0; i < T; ++i) {\n    e.push_back({i, i + 1, -1});\n    e.push_back({t - i - 1, t - i, -2});\n  }\n  set<pii> used;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    if (used.count(res[i][j])) continue;\n    used.insert(res[i][j]);\n    int c = d[i][j] - res[i][j].first * i - res[i][j].second * j;\n    assert(c >= 0 && c <= 100);\n    e.push_back({res[i][j].first, t - res[i][j].second, c});\n  }\n/*  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n\n  }*/\n  cout << t + 1 << ' ' << e.size() << endl;\n  for (auto v : e) {\n    cout << v[0] + 1 << ' ' << v[1] + 1 << ' ';\n    if (v[2] >= 0) cout << v[2];\n    else cout << (v[2] == -1 ? \"X\" : \"Y\");\n    cout << endl;\n  }\n  cout << s + 1 << ' ' << t + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int N = 6;\nconstexpr char disco[] = { 'D', 'I', 'S', 'C', 'O' };\nconst std::array<std::array<uint32_t, N>, N> identity = [] {\n  std::array<std::array<uint32_t, N>, N> res{};\n  for (int i = 0; i < N; ++i) {\n    res[i][i] = 1;\n  }\n  return res;\n}();\n\ntemplate <class T>\nclass disjoint_sparse_table {\npublic:\n  using value_type = typename T::value_type;\n  using value_operation = typename T::value_operation;\n\nprivate:\n  const value_operation op;\n  std::vector<std::vector<value_type>> table;\n\npublic: \n  disjoint_sparse_table(): op(value_operation()) { }\n  disjoint_sparse_table(const std::vector<value_type> &table_):\n    op(value_operation())\n  { build(table_); }\n\n  void build(const std::vector<value_type> &table_) {\n    int height = 0, size = table_.size();\n    while ((1 << height) < size) {\n      ++height;\n    }\n    if (size == 1) {\n      ++height;\n    }\n    table.assign(height, std::vector<value_type>(size));\n    for (int i = 0; i < size; ++i) {\n      table[0][i] = table_[i];\n    }\n    for (int i = 1; i < height; ++i) {\n      int bit = (1 << i);\n      for (int l = 0; l < size; l += (bit << 1)) {\n        int m = (l + bit < size ? l + bit : size);\n        table[i][m - 1] = table_[m - 1];\n        for (int j = m - 2; j >= l; --j) {\n          table[i][j] = op(table_[j], table[i][j + 1]);\n        }\n        if (m >= size) {\n          continue;\n        }\n        int r = (m + bit < size ? m + bit : size);\n        table[i][m] = table_[m];\n        for (int j = m + 1; j < r; ++j) {\n          table[i][j] = op(table[i][j - 1], table_[j]);\n        }\n      }\n    }\n  }\n\n  value_type fold(int l, int r) const {\n    if (l >= --r) {\n      return table[0][l];\n    }\n    else {\n      int h = 31 - __builtin_clz(l ^ r);\n      return op(table[h][l], table[h][r]);\n    }\n  }\n\n};\n\n\nstruct semigroup {\n  using value_type = std::array<std::array<uint32_t, N>, N>;\n  struct value_operation {\n    value_type operator () (const value_type &x, const value_type &y) const {\n      value_type res{};\n      for (int i = 0; i < N; ++i) {\n        for (int j = i; j < N; ++j) {\n          for (int k = 0; k < N; ++k) {\n            res[i][j] += x[i][k] * y[k][j];\n          }\n        }\n      }\n      return res;\n    }\n  };\n};\n\nint main() {\n  std::string S;\n  std::cin >> S;\n  std::vector<std::array<std::array<uint32_t, N>, N>> build(S.length(), identity);\n  for (int i: range(0, S.size())) {\n    int k;\n    for (k = 0; k < 5; ++k) {\n      if (disco[k] == S[i]) {\n        break;\n      }\n    }\n    build[i][k][k + 1] = 1;\n  }\n  disjoint_sparse_table<semigroup> table(build);\n  int Q;\n  std::cin >> Q;\n  while (Q--) {\n    int l, r;\n    std::cin >> l >> r;\n    --l;\n    std::cout << table.fold(l, r)[0][5] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[10][10], f[111][111];\nint main()\n{\n\tint a, b, e = 0;\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++)\n\t\tfor (int j = 0; j < b; j++)\n\t\t\tcin >> d[i][j];\n\tfor (int i = 0; i < 101; i++) {\n\t\tfor (int j = 0; j < 101; j++) {\n\t\t\tfor (int k = 0; k < a; k++)\n\t\t\t\tfor (int l = 0; l < b; l++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[k][l] - k * i - l * j);\n\t\t\tif (f[i][j] <= 100)\n\t\t\t\te++;\n\t\t}\n\t}\n\tfor (int k = 0; k < a; k++) {\n\t\tfor (int l = 0; l < b; l++) {\n\t\t\tint m = 114514;\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tfor (int j = 0; j < 101; j++)\n\t\t\t\t\tm = min(m, f[i][j] + k * i + l * j);\n\t\t\tif (m != d[k][l]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n202 \" << e + 200 << \"\\n\";\n\tfor (int i = 0; i < 100; i++) {\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\t\tcout << i + 102 << ' ' << i + 103 << \" Y\\n\";\n\t}\n\tfor (int i = 1; i < 102; i++)\n\t\tfor (int j = 102; j < 203; j++)\n\t\t\tif (f[i - 1][202 - j] <= 100)\n\t\t\t\tcout << i << ' ' << j << ' ' << f[i - 1][202 - j] << '\\n';\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nstruct edge{\n    int x,y,u;\n};\nvector<edge> conn;\nconst int MAX=12,INF=0x3f3f3f3f;\nint a,b,d[MAX][MAX],d_est[MAX][MAX],d_est2[MAX][MAX],val[110][110],x_max,y_max;\nint update(int x,int y,int z){\n    if(x<0||y<0||z<0) return 0;\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++){\n            d_est2[i][j]=min(d_est[i][j],z+i*x+j*y);\n            if(d[i][j]>d_est2[i][j]) return 0;\n        }\n    }\n    val[x][y]=z;\n    for(int i=1;i<=a;i++) for(int j=1;j<=b;j++) d_est[i][j]=d_est2[i][j];\n    return 1;\n}\nint main(){\n    scanf(\" %d %d\",&a,&b);\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++) scanf(\" %d\",&d[i][j]);\n    }\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) val[i][j]=-1;\n    for(int i=0;i<=a;i++) for(int j=0;j<=b;j++) d_est[i][j]=INF;\n    for(int i=a;i>=1;i--){\n        for(int j=b;j>=1;j--){\n            int x,y,z,chk=0;\n            for(x=0;x<=100&&!chk;x++) for(y=0;y<=100&&!chk;y++) {\n                z=d[i][j]-x*i-y*j;\n                if(update(x,y,z)) chk=1;\n            }\n            if(!chk){\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Possible\\n\");\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) x_max=max(i,x_max),y_max=max(j,y_max);\n    }\n    for(int i=1;i<=x_max;i++) conn.push_back({i,i+1,-1});\n    for(int i=x_max+2;i<=x_max+y_max+1;i++) conn.push_back({i+1,i,-2});\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) conn.push_back({i+1,x_max+2+j,val[i][j]});\n    }\n    printf(\"%d %d\\n\",x_max+y_max+2,conn.size());\n    for(int i=0;i<conn.size();i++){\n        if(conn[i].u==-1) printf(\"%d %d X\\n\",conn[i].x,conn[i].y);\n        else if(conn[i].u==-2) printf(\"%d %d Y\\n\",conn[i].x,conn[i].y);\n        else printf(\"%d %d %d\\n\",conn[i].x,conn[i].y,conn[i].u);\n    }\n    printf(\"%d %d\\n\",1,x_max+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?(x==0?S:(x==100?T:101+x)):(x==0?S:(x==100?T:1+x)))\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tprintf(\"%d %d X\\n\",S,id(1,0));\n\tprintf(\"%d %d Y\\n\",S,id(1,1));\n\tprintf(\"%d %d X\\n\",id(99,0),T);\n\tprintf(\"%d %d Y\\n\",id(99,1),T);\n\tfor (int i=2;i<=99;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=2;i<=99;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=310,M=100010;\nint s1[N],s2[N];\nstruct Dat {\n    int x,y,z;\n} g[N],v[M];\ninline int gi() {\n    int x=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint main() {\n    int A,B,cnt=0,n=0,m=0;\n    cin>>A>>B;\n    for(int i=0;i<=100;i++) {\n\ts1[i]=++n,s2[i]=++n;\n\tif(i) {\n\t    v[++m]=(Dat){s1[i-1],s1[i],-1};\n\t    v[++m]=(Dat){s2[i],s2[i-1],-2};\n\t}\n    }\n    for(int i=1;i<=A;i++)\n\tfor(int j=1;j<=B;j++) g[++cnt]=(Dat){i,j,gi()};\n    for(int i=1;i<=cnt;i++) {\n\tint x=g[i].x,y=g[i].y,z=g[i].z;\n\tfor(int p=0;p*x<=z;p++)\n\t    for(int q=0;p*x+q*y<=z;q++) {\n\t\tint c=z-p*x-q*y;\n\t\tbool flg=1;\n\t\tfor(int j=1;j<=cnt;j++) {\n\t\t    int X=g[j].x,Y=g[j].y;\n\t\t    if(p*X+q*Y<g[j].z) {flg=0;break;}\n\t\t}\n\t\tif(flg) {v[++m]=(Dat){s1[p],s2[q],c};goto ed;}\n\t    }\n\treturn puts(\"Impossible\"),0;\n    ed:;\n    }\n    puts(\"Possible\");\n    cout<<n<<' '<<m<<endl;\n    for(int i=1;i<=m;i++) {\n\tprintf(\"%d %d \",v[i].x,v[i].y);\n\tif(v[i].z==-1) puts(\"X\");\n\telse if(v[i].z==-2) puts(\"Y\");\n\telse printf(\"%d\\n\",v[i].z);\n    }\n    cout<<1<<' '<<2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,((n)+1))\n#define repst(i,s,n) reps(i,s,((n)+1))\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// Xの辺をa回、Yの辺をb回通ったときのS->Tの(整数が書いてある辺の重みのみを考慮した)最短距離をf(ab)とすると\n// X=x,Y=yのときの最短距離は Dx,y = min(xa+yb+f(a,b)) となる\n// dがたかだか100だからa・bの範囲は[0,100]で十分\n// 頂点0〜100をXの辺で、101〜201をYの辺でつなぎ、\n// S(0〜100)とT(101〜201)をコストfabの辺で繋ぐと総コストSX+(T-101)Y+fabのパスができる\n// fabは任意の1<=x<=A, 1<=y<=Bに対しdxy<=xa+yb+fabを満たす条件の中で最も小さくするのが最善\n// ∴ fab = max( 0, max(dxy-xa-yb) ) (0<=a,b<=100)\n// これに従って辺を伸ばした後にちゃんとdを満たしているか確認すればok\n\nint A, B, d[11][11], f[101][101];\n\nsigned main() {\n\tcin >> A >> B;\n\trepst(i,1,A) repst(j,1,B) {\n\t\tcin >> d[i][j];\n\t\trept(a,100) rept(b,100) chmax(f[a][b], d[i][j]-i*a-j*b);\n\t}\n\trepst(i,1,A) repst(j,1,B) {\n\t\tint m = inf;\n\t\trept(a,100) rept(b,100) chmin(m, i*a+j*b+f[a][b]);\n\t\tif (m!=d[i][j]) return cout << \"Impossible\" << ln, 0;\n\t}\n\tcout << \"Possible\" << ln << \"202 10401\" << ln;\n\trepst(i,1,100) cout << i << ' ' << i+1 << \" X\" << ln;\n\trepst(i,1,100) cout << i+101 << ' ' << i+102 << \" Y\" << ln;\n\trept(a,100) rept(b,100) cout << a+1 << ' ' << b+102 << ' ' << f[a][100-b] << ln;\n\tcout << \"1 202\" << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[N], Y[N], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 0, yy = 0;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      xx = std::max(xx, d[i][j] / i);\n      yy = std::max(yy, d[i][j] / j);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = 0;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      if (ans < 0 || ans > 100) continue;\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", cnt, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tll svkek[20][20];\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 1000;\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tfor (int t = 0; t < 101; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(ll)(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) reps(i,0,((n)+1))\n#define repst(i,s,n) reps(i,s,((n)+1))\n#define reprt(i,n,t) for(ll (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ');}}\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// Xの辺をa回、Yの辺をb回通ったときのS->Tの(整数が書いてある辺の重みのみを考慮した)最短距離をf(ab)とすると\n// X=x,Y=yのときの最短距離は Dx,y = min(xa+yb+f(a,b)) となる\n// dがたかだか100だからa・bの範囲は[0,100]で十分\n// 頂点0〜100をXの辺で、101〜201をYの辺でつなぎ、\n// S(0〜100)とT(101〜201)をコストfabの辺で繋ぐと総コストSX+(T-101)Y+fabのパスができる\n// fabは任意の1<=x<=A, 1<=y<=Bに対しdxy<=xa+yb+fabを満たす条件の中で最も小さくするのが最善\n// ∴ fab = max( 0, max(dxy-xa-yb) ) (0<=a,b<=100)\n// これに従って辺を伸ばした後にちゃんとdを満たしているか確認すればok\n\nint A, B, d[11][11], f[101][101];\n\nsigned main() {\n\tcin >> A >> B;\n\trepst(i,1,A) repst(j,1,B) {\n\t\tcin >> d[i][j];\n\t\trept(a,100) rept(b,100) chmax(f[a][b], d[i][j]-i*a-j*b);\n\t}\n\trepst(i,1,A) repst(j,1,B) {\n\t\tint m = inf;\n\t\trept(a,100) rept(b,100) chmin(m, i*a+j*b+f[a][b]);\n\t\tif (m!=d[i][j]) return cout << \"Impossible\" << ln, 0;\n\t}\n\tcout << \"Possible\" << ln << \"202 10401\" << ln;\n\t\n\trepst(i,1,100) cout << i << ' ' << i+1 << \" X\" << ln;\n\trepst(i,1,100) cout << i+101 << ' ' << i+102 << \" Y\" << ln;\n\trept(a,100) rept(b,100) cout << a+1 << ' ' << b+102 << ' ' << f[a][b] << ln;\n\tcout << \"1 202\" << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; \n#define ll long long\n#define ld long double\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i) \n#define FOr(i,x,y)  for(ll i=x;i>=y;--i) \n#define pi acos(-1)\n#define pa pair<ll,ll>\n#define lf else if\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)\t\t(x)*(x)\n#define Mul(x,y)    x=x*(y)%mod\n#define Add(x,y)    x=(x+(y))%mod\n#define Max(x,y)\tx=x<(y)?(y):x\n#define Min(x,y)\tx=x>(y)?(y):x\n#define E(x) \t\treturn writeln(x),0\n#define p(x)\t\tprintf(\"~%d~\\n\",x)\n#define pp(x,y)\t\tprintf(\"~~%d %d~~\\n\",x,y)\n#define ppp(x,y,z)\tprintf(\"~~~%d %d %d~~~\\n\",x,y,z)\n#define f_in(x)\t\tfreopen(x\".in\",\"r\",stdin)\n#define f_out(x) \tfreopen(x\".out\",\"w\",stdout)\n#define open(x)\t\tf_in(x),f_out(x)\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif \n#define NEG 1\n    const int L=2333333;\n    char SZB[L],*S=SZB,*T=SZB;\n    inline char gc(){   if (S==T){  T=(S=SZB)+fread(SZB,1,L,stdin); if (S==T) return '\\n';  }   return *S++;    }\n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n}using namespace SHENZHEBEI;\nll q[100000][3],a[310][310],mark[310][310],all_sz,A,B,top;\nint main(){\n\tA=read(),B=read();\n\tFor(i,1,A)For(j,1,B)a[i][j]=read();\n\tFor(i,1,A)For(j,1,B)if (a[i][j]<a[i-1][j]||a[i][j]<a[i][j-1])\treturn puts(\"Impossible\"),0;all_sz=202;\n\tFor(cho_a,0,100)For(cho_b,0,100)For(cho_z,0,100)if (cho_a+cho_b+cho_z<=100){\n\t\tbool fl=1;\n\t\tFor(i,1,A)For(j,1,B)if (a[i][j]>cho_a*i+cho_b*j+cho_z)\tfl=0;\n\t\tif (!fl)\tcontinue;\n\t\tfl=0;\n\t\tFor(i,1,A)For(j,1,B)if (!mark[i][j]&&(a[i][j]==cho_a*i+cho_b*j+cho_z))\tmark[i][j]=1,fl=1;\n\t\tif (fl){\n\t\t\tq[++top][0]=cho_a+1;\n\t\t\tq[top][1]=all_sz-cho_b;\n\t\t\tq[top][2]=cho_z;\n\t\t}\n\t\tbreak;\n\t}\n\tFor(i,1,A)For(j,1,B)if (!mark[i][j])\treturn puts(\"Impossible\"),0;\n\tll node=1;\n\tFor(i,1,100)\tq[++top][0]=node,q[top][1]=++node,q[top][2]=-1;\n\tq[++top][0]=node;\tq[top][1]=all_sz;\tq[top][2]=-1;\n\tFor(i,1,100)\tq[++top][0]=(i==1)?1:node,q[top][1]=++node,q[top][2]=-2;\n\tq[++top][0]=node;\tq[top][1]=all_sz;\tq[top][2]=-2;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",all_sz,top);\n\tFor(i,1,top){\n\t\tif (q[i][2]>=0)\tprintf(\"%d %d %d\\n\",q[i][0],q[i][1],q[i][2]);\n\t\tif (q[i][2]==-1)printf(\"%d %d X\\n\",q[i][0],q[i][1]);\n\t\tif (q[i][2]==-2)printf(\"%d %d Y\\n\",q[i][0],q[i][1]);\n\t}printf(\"%d %d\\n\",1,all_sz);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[20][20];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 1000;\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tfor (int t = 0; t < 101; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 303, M = 100;\nint a, b, d[14][14], C[M+3][M+3], sz = 1;\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int as = 0; as <= M; as++) {\n\t\tfor(int bs = 0; bs <= M; bs++) {\n\t\t\tint mn = 0;\n\t\t\tfor(int i =1; i <= a; i++)\n\t\t\t\tfor(int j = 1; j <= b; j++)\n\t\t\t\t\tmn = max(mn, d[i][j] - as*i - bs*j);\n\t\t\tC[as][bs] = mn;\n\t\t}\n\t}\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++) {\n\t\t\tint cst = 1<<30;\n\t\t\tfor(int as = 0; as <= M; as++)\n\t\t\t\tfor(int bs = 0; bs <= M; bs++)\n\t\t\t\t\tcst = min(cst, as*i + bs*j + C[as][bs]);\n\t\t\tif(cst != d[i][j]) return cout << \"Impossible\\n\", 0;\n\t\t}\n\t\n\tcout << \"Possible\\n\";\n\tcout << 2*M+2 << \" \" << (M+1)*(M+1) + 2*M << '\\n';\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" X\\n\", sz++;\n\tsz++;\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" Y\\n\", sz++;\n\tfor(int i = 0; i <= M; i++)\n\t\tfor(int j = 0; j <= M; j++)\n\t\t\tcout << 1+i << \" \" << M+2+j << \" \" << C[i][M-j] << '\\n';\n\tcout << 1 << \" \" << 2*M+2 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint d[11][11];\nbool marked[11][11];\nint n, m;\n\nint verif(int x, int y, int add)\n{\n    int ans(0);\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (x * i + y * j + add == d[i][j] && !marked[i][j])\n                ans++;\n            else if (x * i + y * j + add < d[i][j])\n                ans = -1e9;\n        }\n    }\n    return ans;\n}\nvoid mark(int x, int y, int add)\n{\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (x * i + y * j + add == d[i][j])\n                marked[i][j] = 1;\n        }\n    }\n}\n\nstruct Edge { int x, y, cost; };\n\nvector <Edge> ans;\nvector <int> lantx, lanty;\nint s, dest;\nint cnt;\n\nvoid mk_lant(vector <int> & lant, int l)\n{\n    while (lant.size() <= l)\n        lant.push_back(++cnt);\n}\n\nvoid mk_choice(int x, int y, int simple)\n{\n    if (x < y) {\n        mk_lant(lanty, y);\n        int last(lanty[y]);\n        while (x--) {\n            ans.push_back((Edge) { last, ++cnt, -1 });\n            last = cnt;\n        }\n        while (simple > 0) {\n            ans.push_back((Edge) { last, ++cnt, (simple > 100 ? 100 : simple) });\n            last = cnt;\n            simple -= 100;\n        }\n        if (last == lanty[y])\n            ans.push_back((Edge) { last, dest, 0 });\n        else {\n            cnt--;\n            ans.back().y = dest;\n        }\n    }\n    else {\n        mk_lant(lantx, x);\n        int last(lantx[x]);\n        while (y--) {\n            ans.push_back((Edge) { last, ++cnt, -2 });\n            last = cnt;\n        }\n        while (simple > 0) {\n            ans.push_back((Edge) { last, ++cnt, (simple > 100 ? 100 : simple) });\n            last = cnt;\n            simple -= 100;\n        }\n        if (last == lantx[x])\n            ans.push_back((Edge) { last, dest, 0 });\n        else {\n            cnt--;\n            ans.back().y = dest;\n        }\n    }\n}\n\nint main()\n{\n    s = 1, dest = 2;\n    cnt = 2;\n    lantx.push_back(s);\n    lanty.push_back(s);\n    cin >> n >> m;\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++)\n            cin >> d[i][j];\n    }\n\n    bool pus(1);\n    int best(0), x, y, add;\n    while (pus) {\n        pus = 0;\n        best = 0;\n        for (int i(0); i <= 100; i++) {\n            for (int j(0); j <= 100; j++) {\n                for (int k(0); k <= 100; k++) {\n                    int q = verif(i, j, k);\n                    if (q > best)\n                        best = q, x = i, y = j, add = k;\n                }\n            }\n        }\n        if (best) {\n            pus = 1;\n            mk_choice(x, y, add);\n            mark(x, y, add);\n        }\n    }\n\n    for (int i(1); i <= n; i++) {\n        for (int j(1); j <= m; j++) {\n            if (!marked[i][j]) {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n\n    cout << cnt << ' ' << ans.size() + lantx.size() - 1 + lanty.size() - 1 << '\\n';\n    for (int i(1); i < lantx.size(); i++)\n        cout << lantx[i - 1] << ' ' << lantx[i] << \" X\\n\";\n    for (int i(1); i < lanty.size(); i++)\n        cout << lanty[i - 1] << ' ' << lanty[i] << \" Y\\n\";\n\n    for (auto i : ans) {\n        cout << i.x << ' ' << i.y << ' ';\n        if (i.cost >= 0)\n            cout << i.cost << '\\n';\n        else\n            cout << (i.cost == -1 ? 'X' : 'Y') << '\\n';\n    }\n    cout << s << ' ' << dest << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<sys/time.h>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int ri()\n{\n\tregister int x=0;register bool f=0;register char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();};\n\treturn f?-x:x;\n}\nvoid wi(int x)\n{\n\tif(x<0)\tx=-x,putchar('-');\n\tif(x>9)\twi(x/10);\n\tputchar('0'+x%10);\n}\nconst int N=105;\nint c[N][N],d[15][15];\nbool judge(int a,int b)\n{\n    int i,j,k,l;\n    for(i=1;i<=a;i++)\n        for(j=1;j<=b;j++)\n\t{\n            int dist=1e9;\n            for(k=0;k<=100;k++)\n                for(l=0;l<=100;l++)\n                    dist=min(dist,i*k+j*l+c[k][l]);\n            if(dist!=d[i][j]) return 0;\n        }\n    return 1;\n}\nint main()\n{\n    int a,b,i,j,k,l;\n    a=ri(),b=ri();\n    for(i=1;i<=a;i++)\n        for(j=1;j<=b;j++)\n            d[i][j]=ri();\n    for(i=1;i<=a;i++) \n        for(j=1;j<=b;j++) \n            for(k=0;k<=100;k++) \n                for(l=0;l<=100;l++)\n                    c[k][l]=max(c[k][l],d[i][j]-i*k-j*l);\n    if(judge(a,b))\n    {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\",202,101*101+200);\n        for(i=1;i<=100;i++)\n\t    printf(\"%d %d X\\n\",i,i+1);\n        for(i=102;i<202;i++)\n\t    printf(\"%d %d Y\\n\",i+1,i);\n        for(i=0;i<=100;i++)\n            for(j=0;j<=100;j++)\n\t\tprintf(\"%d %d %d\\n\",i+1,j+102,c[i][j]);\n        printf(\"%d %d\\n\",1,102);\n    }\n    else\tputs(\"Impossible\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\n#define N 305\n#define INF 0x3fffffff\nint f[N][N];\nint d[N][N];\nbool check(int x,int y,int v)\n{\n\tint res=INF;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tres=min(res,i*x+j*y+f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res==v;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n#endif\n\tmemset(f,-1,sizeof(f));\n\tint a,b;\n\tcin>>a>>b;\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint tmp=-INF;\n\t\t\tfor(int c=1;c<=a;c++)\n\t\t\t{\n\t\t\t\tfor(int e=1;e<=b;e++)\n\t\t\t\t{\n\t\t\t\t\ttmp=max(tmp,d[c][e]-i*c-j*e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i][j]=tmp;\n\t\t\tif(f[i][j]<0) break;\n\t\t\tsum++;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tif(!check(i,j,d[i][j]))\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint s=201,t=202;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,sum+200);\n\tfor(int i=1;i<100;i++)\n\t{\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+100);\n\t}\n\tprintf(\"%d %d X\\n\",s,1);\n\tprintf(\"%d %d Y\\n\",101,t);\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\",i==0?s:i,j==0?t:j+100,f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n#ifndef ONLINE_JUDGE\n\tprintf(\"Time Used : %d\\n\",clock());\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int A, B; cin >> A >> B;\n    vector d(A, vector(B, 0));\n    for(auto& v : d){\n        for(auto& t : v) cin >> t;\n    }\n    int ofs[101][101];\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            ofs[i][j] = 0;\n            for(int a=1;a<=A;a++){\n                for(int b=1;b<=B;b++){\n                    ofs[i][j] = max(ofs[i][j], d[a-1][b-1]-(i*a+j*b));\n                }\n            }\n        }\n    }\n    bool ok = true;\n    for(int a=1;a<=A;a++){\n        for(int b=1;b<=B;b++){\n            int r = 10000;\n            for(int i=0;i<=100;i++){\n                for(int j=0;j<=100;j++){\n                    r = min(r, i*a+j*b+ofs[i][j]);\n                }\n            }\n            if(r != d[a-1][b-1]) ok = false;\n        }\n    }\n    if(ok){\n        cout << \"Possible\" << endl;\n        cout << 200 + 101*101 << endl;\n        for(int i=1;i<=100;i++){\n            cout << i << \" \" << i+1 << \" X\" << endl;\n            cout << 151+i << \" \" << 150+i << \" Y\" << endl;\n        }\n        for(int i=0;i<=100;i++){\n            for(int j=0;j<=100;j++){\n                cout << i+1 << \" \" << 150+j << \" \" << ofs[i][j] << endl;\n            }\n        }\n        cout << 1 << \" \" << 150 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,s,t;\nint a,b,d[15][15];\n\ninline void init(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tscanf(\"%d\",d[i]+j);\n}\n\nint fl,ga[300][300];\nstruct edge{\n\tint u,v,w;\n}ge[100005];\n\ninline int check(int x,int y,int c){\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tif(i*x+j*y+c<d[i][j])return 0;\n\treturn 1;\n}\n\ninline void solve(){\n\ts=1;t=n=202;\n\tfor(int i=1;i<=100;++i)\n\t\tge[m++]=(edge){i,i+1,-1};\n\tfor(int i=102;i<n;++i)\n\t\tge[m++]=(edge){i,i+1,101};\n\t\n\tfor(int i=1;i<=a;++i){\n\t\tfor(int j=1;j<=b;++j){\n\t\t\tint ok=0;\n\t\t\tfor(int x=0;x<=d[i][j]/i;++x){\n\t\t\t\tfor(int y=0;y<=(d[i][j]-x*i)/j;++y){\n\t\t\t\t\tint c=d[i][j]-x*i-y*j;\n\t\t\t\t\tif(check(x,y,c)){\n\t\t\t\t\t\tif(!ga[x][y]){\n\t\t\t\t\t\t\tga[x][y]=1;\n\t\t\t\t\t\t\tge[m++]=(edge){x+1,n-y,c};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)break;\n\t\t\t}\n\t\t\tif(!ok){fl=1;break;}\n\t\t}\n\t\tif(fl)break;\n\t}\n\t\n\tif(fl){puts(\"Impossible\");return;}\n\tprintf(\"Possible\\n%d %d\\n\",n,m);\n\tfor(int i=0;i<m;++i){\n\t\tprintf(\"%d %d \",ge[i].u,ge[i].v);\n\t\tif(ge[i].w<0)puts(\"X\");\n\t\telse if(ge[i].w>100)puts(\"Y\");\n\t\telse printf(\"%d\\n\",ge[i].w);\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\nconstexpr int V = 2 * (d_max + 1);\nconstexpr int E = d_max * 2 + (d_max + 1) * (d_max + 1);\nconstexpr int S = 0, T = V - 1;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  std::array<std::array<int, d_max + 1>, d_max + 1> cost{};\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      for (int a: range(0, A + 1)) {\n        for (int b: range(0, B + 1)) {\n          chmax(cost[a][b], dist[i][j] - (i + 1) * a - (j + 1) * b);\n        }\n      }\n    }\n  }\n  std::array<std::pair<int, int>, d_max> Xs{};\n  std::array<std::pair<int, int>, d_max> Ys{};\n  for (int i: range(0, d_max)) {\n    Xs[i] = { i, i + 1 };\n    Ys[i] = { V - i - 2, V - i - 1 };\n  }\n  auto calc = [&](int x, int y) {\n    std::array<std::vector<std::pair<int, int>>, V> graph{};\n    for (int i: range(0, d_max)) {\n      graph[Xs[i].first].emplace_back(Xs[i].second, x);\n      graph[Ys[i].first].emplace_back(Ys[i].second, y);\n    }\n    for (int i: range(0, d_max + 1)) {\n      for (int j: range(0, d_max + 1)) {\n        graph[i].emplace_back(V - j - 1, cost[i][j]);\n      }\n    }\n    std::array<int, V> length{};\n    length.fill(d_max);\n    length[S] = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(length[S], S);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > length[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(length[e.first], length[v] + e.second)) {\n          que.emplace(length[e.first], e.first);\n        }\n      }\n    }\n    return length[T];\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (dist[i][j] != calc(i + 1, j + 1)) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  std::cout << V << ' ' << E << '\\n';\n  for (auto e: Xs) {\n    std::cout << e.first + 1 << ' ' << e.second << \" X\\n\";\n  }\n  for (auto e: Ys) {\n    std::cout << e.first + 1 << ' ' << e.second << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      std::cout << i + 1 << ' ' << V - j << ' ' << cost[i][j] << '\\n';\n    }\n  }\n  std::cout << S + 1 << ' ' << T + 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+1;\n\t\tnumn+=ans[i].a+ans[i].b;\n\t}\n\tnumn+=2;\n\t//if (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tprintf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'X'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\t{\n\t\t\t\t\tint c=s-a-b;\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                /*\n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                */\n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\nint d[20][20];\nint f[110][110];\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nint a,b;\n  \tcin>>a>>b;\n  \tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++)cin>>d[i][j];\n  \t\n  \t\n  \tfor(int s=0;s<=100;s++)for(int t=0;t<=100;t++){\n  \t\tint r=0;\n  \t\t\n  \t\t\n  \t\tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++){\n  \t\t\tr=max(r,d[i][j]-s*i-t*j);\n  \t\t}\n  \t\tf[s][t]=r;\n  \t}\n  \t\n  \tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++){\n  \t\tint g=inf;\n  \t\tfor(int s=0;s<=100;s++)for(int t=0;t<=100;t++){\n  \t\t\tg=min(g,f[s][t]+s*i+t*j);\n  \t\t}\n  \t\tif(g!=d[i][j]){\n  \t\t\tcout<<\"Impossible\"<<endl;\n  \t\t\treturn 0;\n  \t\t}\n  \t}\n  \t\n  \tcout<<\"Possible\"<<endl;\n  \tcout<<\"202 \"<<200+101*101<<endl;\n  \t\n  \tfor(int i=1;i<=100;i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n  \tfor(int i=102;i<=201;i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n  \tfor(int s=0;s<=100;s++)for(int t=0;t<=100;t++){\n  \t\tcout<<1+s<<\" \"<<202-t<<\" \"<<f[s][t]<<endl;\n  \t}\n  \tcout<<\"1 202\"<<endl;\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define ins insert\n#define F first\n#define S second\n#define var auto\nusing namespace std;\ntypedef long long ll;\nconst int Max = 120;\n\nint d[Max][Max];\nvector<pair<pair<int,int>,int> > edges;\n#define X(i) (i + 1)\n#define Y(i) (i + 101)\nint main()\n{\n\tint A,B;cin >> A >> B;\n\tfor(int i = 1; i <= A; i++)\n\t{\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= A; i++)\n\t\td[i][B + 1] = d[i][B];\n\tfor(int i = 1; i <= B; i++)\n\t\td[A + 1][i] = d[A][i];\n\n\tfor(int i = 1; i <= 99; i++)\n\t\tedges.pb({{X(i - 1) , X(i)} , -1});\n\tfor(int i = 99; i >= 1; i--)\n\t\tedges.pb({{Y(i) , Y(i - 1)} , -2});\n\n\tbool able = true;\n\n\tint qvert = 201;\n\tfor(int i = 1; i <= A; i++)\n\t{\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tint xzrb = d[i + 1][j] - d[i][j];\n\t\t\tint yzrb = d[i][j + 1] - d[i][j];\n\t\t\tif(xzrb < 0 || yzrb < 0 || xzrb * i + yzrb * j > d[i][j])\n\t\t\t\table = false;\n\t\t\tedges.pb({{X(xzrb) , qvert} , d[i][j] - i * xzrb - j * yzrb});\n\t\t\tedges.pb({{qvert , Y(yzrb)} , 0});\n\t\t}\n\t}\n\tif(able)\n\t{\n\t\tcout << \"Possible\\n\";\n\t\tcout << 300 << \" \" << edges.size() << '\\n';\n\t\tfor(var e : edges)\n\t\t{\n\t\t\tstring col;\n\t\t\tif(e.S == -1)\n\t\t\t\tcol = \"X\";\n\t\t\telse if(e.S == -2)\n\t\t\t\tcol = \"Y\";\n\t\t\telse\n\t\t\t\tcol = to_string(e.S);\n\t\t\tcout << e.F.F << \" \" << e.F.S << \" \" << col << '\\n';\n\t\t}\n\t\tcout << X(0) << \" \" << Y(0) << '\\n';\n\t}\n\telse\n\t{\n\t\tcout << \"Impossible\\n\";\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register int\nusing namespace std;\nint n,m,d[15][15],f[110][110];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re i=1;i<=n;i++)\n\tfor(re j=1;j<=m;j++)scanf(\"%d\",&d[i][j]);\n\tfor(re i=0;i<=100;i++){\n\t\tfor(re j=0;j<=100;j++){\n\t\t\tfor(re k=1;k<=n;k++){\n\t\t\t\tfor(re l=1;l<=m;l++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[k][l]-i*k-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(re i=1;i<=n;i++){\n\t\tfor(re j=1;j<=m;j++){\n\t\t\tint now=0x3f3f3f;\n\t\t\tfor(re k=0;k<=100;k++){\n\t\t\t\tfor(re l=0;l<=100;l++){\n\t\t\t\t\tnow=min(now,f[k][l]+i*k+j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[i][j]){\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      vector<Int> dp1(100,INF),dp2(100,INF);\n      for(Int k=100-1;k>=0;k--){\n\tdp1[k]=C[k];\n\tdp2[k]=D[k];\n\tif(k+1<100){\n\t  chmin(dp1[k],dp1[k+1]);\n\t  chmin(dp2[k],dp2[k+1]);\n\t}\n      }\n      for(Int k=0;k<100;k++){\n\tfor(Int l=0;l<100;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*(k+1)+dp2[l]));\n\t  chmax(F[k][l],d[i][j]-((j+1)*(k+1)+dp1[l]));\n\t}\n      }\n    }\n  }\n  \n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  for(Int k=0;k<100;k++){\n    for(Int l=0;l<100;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i<<\" \"<<j<<\":\"<<dist<<\":\"<<d[i][j]<<endl;\n\t//assert(0);\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int fr,to;\n    int w;\n};\nint main(){\n    int a,b;\n    cin>>a>>b;\n    vector<vector<int>> d(a,vector<int>(b,0));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cin>>d[i][j];\n        }\n    }\n    const int S=1,T=204;\n    auto getX=[](int idx){\n        return 2+idx;\n    };\n    auto getY=[](int idx){\n        return 103+idx;\n    };\n    \n    vector<vector<int>> useX(a,vector<int>(b,0));\n    bool isok=true;\n    for(int i=a-2;i>=0;i--){\n        for(int j=b-1;j>=0;j--){\n            useX[i][j]=d[i+1][j]-d[i][j];\n            isok&=(useX[i+1][j]<=useX[i][j]);\n        }\n    }\n    vector<vector<int>> useY(a,vector<int>(b,0));\n    for(int i=a-1;i>=0;i--){\n        for(int j=b-2;j>=0;j--){\n            useY[i][j]=max(d[i][j+1]-d[i][j],i+1<a ? useY[i+1][j] : 0);\n            isok&=(useY[i][j+1]<=useY[i][j]);\n        }\n    }\n\n    \n    vector<Edge> edges;\n    edges.push_back(Edge{S,getX(0)});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getX(i),getX(i+1),0});\n    }\n    edges.push_back(Edge{getY(0),T,0});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getY(i+1),getY(i),0});\n    }\n    /*\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cout<<\"(\"<<useX[i][j]<<\",\"<<useY[i][j]<<\") \";\n        }\n        cout<<endl;\n    }\n    cout<<isok<<endl;\n    */\n   if(!isok){\n       cout<<\"Impossible\"<<endl;\n       return 0;\n   }\n   vector<vector<int>> table(101,vector<int>(101,-1));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            int w=d[i][j]-(i+1)*useX[i][j]-(j+1)*useY[i][j];\n            isok&=(w>=0);\n            isok&=!(table[useX[i][j]][useY[i][j]]!=-1 && table[useX[i][j]][useY[i][j]]!=w);\n            if(table[useX[i][j]][useY[i][j]]!=w){\n                edges.push_back(Edge{getX(useX[i][j]),getY(useY[i][j]),w});            \n                table[useX[i][j]][useY[i][j]]=w;\n            }\n        }\n    }\n    \n    if(isok){\n        cout<<\"Possible\"<<endl;\n        cout<<250<<\" \"<<edges.size()<<endl;\n        for(int i=0;i<edges.size();i++){\n            cout<<edges[i].fr<<\" \"<<edges[i].to<<\" \"<<edges[i].w<<endl;\n        }\n        cout<<S<<\" \"<<T<<endl;\n    }\n    else{\n        cout<<\"Impossible\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t\tii=i;jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tcout<<dd[i][j]<<' '<<d[i][j]<<endl;\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\t\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*k);\n\tchmax(D[k],d[i][j]-(j+1)*k);\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(E[k],d[i][j]-(N-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(N-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[idx(k)].emplace_back(t,C[k]);\n    G[idy(k)].emplace_back(t,D[k]);\n    G[z].emplace_back(idx(k),E[k]);\n    G[z].emplace_back(idy(k),F[k]);\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      //cout<<dist<<\" \"<<d[i][j]<<endl;\n      flg&=(dist==d[i][j]);\n      assert(dist>=d[i][j]);\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC089E.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 330;\n\nint n, A, B, d[MAX_N][MAX_N], f[MAX_N][MAX_N];\n\nint main()\n{\n    scanf(\"%d%d\", &A, &B);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n            scanf(\"%d\", &d[i][j]);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            for (int p = 0; p <= A; p++)\n                for (int q = 0; q <= B; q++)\n                    f[i][j] = max(0, d[p][q] - i * p - j * q);\n    for (int i = 1; i <= A; i++)\n        for (int j = 1; j <= B; j++)\n        {\n            int dist = 1e9;\n            for (int p = 0; p <= 100; p++)\n                for (int q = 0; q <= 100; q++)\n                    dist = min(dist, f[p][q] + i * p + j * q);\n            if (dist != d[i][j])\n                puts(\"Impossible\"), exit(0);\n        }\n    puts(\"Possible\"), puts(\"202 10401\");\n    for (int i = 1; i <= 100; i++)\n        printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i < 202; i++)\n        printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10 + 5;\n\nint n, m, d[N][N], f[105][105];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, 103 + i, 102 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 102 + j, f[i][j]);\n    puts(\"1 102\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ninline void check_max(int a,int &b){if(a>b)b=a;}\ninline void check_min(int a,int &b){if(a<b)b=a;}\n\nnamespace YouQu____o_o________nyg_tai_qiang_le\n{\n\ttypedef std::pair<int,int> pii;\n\tconst int N=12,M=202;\n\n\tstruct outputer\n\t{\n\t\tint n,m,S,T;\n\t\tint w[M*M];\n\t\tpii E[M*M];\n\t\tvoid reset(int n_){n=n_,m=0;}\n\t\tvoid insert(int u,int v,int k){E[++m]=pii(u,v);w[m]=k;}\n\t\tvoid output()\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",n+1,m);\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d \",E[i].first+1,E[i].second+1);\n\t\t\t\tif(w[i]==-1)printf(\"X\\n\");\n\t\t\t\telse if(w[i]==-2)printf(\"Y\\n\");\n\t\t\t\telse printf(\"%d\\n\",w[i]);\n\t\t\t}\n\t\t\tprintf(\"%d %d\\n\",S+1,T+1);\n\t\t}\n\t}d;\n\n#define idx(p) (p)\n#define idy(p) (201-p)\n\n\tint dis[N][N],G[M][M];\n\tint A,B,lim;\n\n\tint calc(int x,int y)\n\t{\n\t\tint ret=23333;\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\tcheck_min(x*i+y*j+G[i][j],ret);\n\t\treturn ret;\n\t}\n\n\tvoid solve()\n\t{\n\t\tlim=100;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tscanf(\"%d\",&dis[i][j]);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t{\n\t\t\t\tG[i][j]=0;\n\t\t\t\tfor(int x=1;x<=A;x++)\n\t\t\t\t\tfor(int y=1;y<=B;y++)\n\t\t\t\t\t\tcheck_max(dis[x][y]-x*i-y*j,G[i][j]);\n\t\t\t}\n\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tif(calc(i,j)!=dis[i][j]){printf(\"Impossilbe\\n\");return;}\n\n\t\tprintf(\"Possible\\n\");\n\n\t\td.reset(idy(0));d.S=idx(0),d.T=idy(0);\n\n\t\tfor(int i=0;i<lim;i++)d.insert(idx(i),idx(i+1),-1);\n\t\tfor(int i=lim;i;i--)d.insert(idy(i-1),idy(i),-2);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\td.insert(idx(i),idy(j),G[i][j]);\n\n\t\td.output();\n\t}\n}\n\nint main()\n{\n\tYouQu____o_o________nyg_tai_qiang_le::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint A,B;\nint d[15][15];\nint f[105][105],tot,gx[105],gy[105],S,T;\npii p[305 * 305];\nint val[305 * 305],cnt;\nint check(int x,int y) {\n    int res = 1000000;\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    res = min(res,f[i][j] + i * x + j * y);\n\t}\n    }\n    return res;\n}\nvoid Solve() {\n    read(A);read(B);\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    read(d[i][j]);\n\t}\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    for(int k = 1 ; k <= A ; ++k) {\n\t\tfor(int h = 1 ; h <= B ; ++h) {\n\t\t    f[i][j] = max(f[i][j],d[k][h] - k * i - h * j);\n\t\t}\n\t    }\n\t} \n    }\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    if(check(i,j) != d[i][j]) {\n\t\tputs(\"Impossible\");\n\t\treturn;\n\t    }\n\t}\n    }\n    puts(\"Possible\");\n    S = ++tot;\n    gx[0] = S;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgx[i] = ++tot;\n\tp[++cnt] = mp(gx[i - 1],gx[i]);\n\tval[cnt] = -2;\n    }\n    T = ++tot;\n    gy[0] = T;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgy[i] = ++tot;\n\tp[++cnt] = mp(gy[i],gy[i - 1]);\n\tval[cnt] = -1;\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    p[++cnt] = mp(gx[i],gy[j]);\n\t    val[cnt] = f[i][j];\n\t}\n    }\n    out(tot);space;out(cnt);enter;\n    for(int i = 1 ; i <= cnt ; ++i) {\n\tout(p[i].fi);space;out(p[i].se);space;\n\tif(val[i] < 0) {\n\t    if(val[i] == -2) {puts(\"X\");}\n\t    else puts(\"Y\");\n\t}\n\telse {out(val[i]);enter;}\n    }\n    out(S);space;out(T);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T> void mini(T &l, T r) {l = min(l, r);}\ntemplate <class T> void maxi(T &l, T r) {l = max(l, r);}\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(bool a) {\n  return a ? \"T\" : \"F\";\n}\n \nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n \n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 101;\n\nint A, B;\nint d[N][N];\nint a[N][N];\n\nvoid run() {\n  cin >> A >> B;\n  for (int i = 1; i <= A; ++i) {\n    for (int j = 1; j <= B; ++j) {\n      cin >> d[i][j];\n    }\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n          maxi(a[i][j], d[x][y] - i * x - j * y);\n        }\n      }\n    }\n  }\n  for (int x = 1; x <= A; ++x) {\n    for (int y = 1; y <= B; ++y) {\n      bool ok = 0;\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n          if (a[i][j] + i * x + y * j == d[x][y]) {\n            ok = 1;\n          }\n        }\n      }\n      if (!ok) {\n        puts(\"Impossible\");\n        return;\n      }\n    }\n  }\n\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", 2 * N, N * N + (N - 1) * 2);\n  for (int i = 0; i + 1 < N; ++i) {\n    printf(\"%d %d X\\n\", i + 1, i + 2);\n    printf(\"%d %d Y\\n\", N + i + 2, 1 + N + i);\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n      printf(\"%d %d %d\\n\", i + 1, j + N + 1, a[i][j]);\n    }\n  }\n  printf(\"1 %d\\n\", N + 1);\n}\n\nint main() {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <limits>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\nconstexpr int INF = std::numeric_limits<int>::max()>>2;\n\nint A, B;\nint d[10][10];\nint c[100][100];\n\nint main()\n{\n  scanf( \"%d%d\", &A, &B );\n  rep( i, A ) rep( j, B )\n    scanf( \"%d\", &d[i][j] );\n\n  rep( i, 100 ) rep( j, 100 )\n  {\n    rep( a, A ) rep( b, B )\n      c[i][j] = std::max( c[i][j], d[a][b]-i*a-j*b );\n  }\n\n  bool fl = true;\n  rep( a, A ) rep( b, B )\n  {\n    int D = INF;\n    rep( i, 100 ) rep( j, 100 )\n      D = std::min( D, i*a+j*b+c[i][j] );\n    \n    fl &= D == d[a][b];\n  }\n\n  if( !fl )\n    puts( \"Impossible\" );\n  else\n  {\n    puts( \"Possible\" );\n  \n    printf( \"%d %d\\n\", 202, 100*100+200 );\n\n    rep( i, 100 )\n      printf( \"%d %d X\\n\", i+1, i+2 );\n    rep( i, 100 )\n      printf( \"%d %d Y\\n\", i+102, i+103 );  \n    rep( i, 100 ) rep( j, 100 )\n      printf( \"%d %d %d\\n\", i+1, 201-j, c[i][j] );\n    printf( \"%d %d\\n\", 1, 202 );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 350;\nconst int INF = 1<<30;\n\nint a, b, s, t, d[N][N], f[N][N];\n\ninline void ck_min( int &a, int b ) { if( a > b ) a = b; }\ninline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\ninline bool check( int x, int y, int val )\n{\n\tint res = INF;\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\t\n\tprintf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n\treturn res == val;\n}\n\nint main()\n{\n\tmemset( f, -1, sizeof( f ) );\n\t\n\tscanf( \"%d%d\", &a, &b );\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\n\t\t\tscanf( \"%d\", &d[i][j] );\n\t\t\t\n\ts = 201, t = 202; \n\t// s --> 1 --> 2 --> ... --> 100\n\t// t <-- 101 <-- 102 <-- ... <-- 200\n\t\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t{\n\t\t\tint tmp = -INF;\n\t\t\tfor( int _a = 1; _a <= a; _a ++ )\n\t\t\t\tfor( int _b = 1; _b <= b; _b ++ )\n\t\t\t\t\tck_max( tmp, d[_a][_b] - i*_a - j*_b );\t\n\t\t\tf[i][j] = tmp; \n\t\t\tif( f[i][j] < 0 ) break;\n//\t\t\tprintf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n\t\t}\n\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\t\n\t\t\tif( !check( i, j, d[i][j] ) ) {\n\t\t\t\tprintf( \"Impossible\\n\" ); return 0;\n\t\t\t} \n\t\t\t\n\tprintf( \"Possible\\n\" );\n\tfor( int i = 1; i < 100; i ++ )\n\t\tprintf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\tprintf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\tprintf( \"%d %d\\n\", s, t );\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(E[k],d[i][j]-(100-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(100-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n\n  G[s].emplace_back(z,0);\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n    G[z].emplace_back(idx(i),E[i]);\n    G[z].emplace_back(idy(i),F[i]);\n  }\n  \n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=105;\nint a,b,f[N][N],d[N][N],s[N][N];\nint main()\n{\n    scanf(\"%d%d\",&a,&b);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        scanf(\"%d\",&d[x][y]);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        f[i][j]=max(f[i][j],d[x][y]-(i-1)*x-(j-1)*y);\n    memset(s,inf,sizeof(s));\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n            for(int x=1;x<=a;x++)\n            for(int y=1;y<=b;y++)\n            s[x][y]=min(s[x][y],f[i][j]+(i-1)*x+(j-1)*y);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        if(d[x][y]!=s[x][y])\n    {\n        printf(\"Impossible\\n\");\n        return 0;\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\",100+100+101*101);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d X\\n\",i,i+1);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d Y\\n\",101+i,101+i+1);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        printf(\"%d %d %d\\n\",i,j+101,f[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst string POSSIBLE = \"Possible\", IMPOSSIBLE = \"Impossible\";\nconst int INF = numeric_limits<int>::max();\n\n\nstruct edge {\n    int to, cost;\n    edge() {}\n    ~edge() {}\n    edge(int to, int cost): to(to), cost(cost) {}\n};\n\nint A, B, D[11][11];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 1; j <= A; ++j) {\n        for (int k = 1; k <= B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    int F[101][101];\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            F[a][b] = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    F[a][b] = max(F[a][b], D[x][y] - x*a - y*b);\n                }\n            }\n        }\n    }\n\n    int graph[205][205], dist[205][205];\n    for (int j = 0; j < 205; ++j) {\n        fill(graph[j], graph[j]+205, INF);\n        graph[j][j] = 0;\n    }\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            graph[a][201-b] = F[a][b];\n        }\n    }\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            for (int j = 1; j <= 100; ++j) {\n                graph[j-1][j] = x;\n            }\n            for (int j = 1; j <= 100; ++j) {\n                graph[101+(j-1)][101+j] = y;\n            }\n\n            for (int j = 0; j < 205; ++j) {\n                for (int k = 0; k < 205; ++k) {\n                    dist[j][k] = graph[j][k];\n                }\n            }\n\n            for (int k = 0; k < 205; ++k) {\n                for (int i = 0; i < 205; ++i) {\n                    for (int j = 0; j < 205; ++j) {\n                        if (dist[i][j] < INF && dist[j][k] < INF) {\n                            dist[i][k] = min(dist[i][k], dist[i][j] + dist[j][k]);\n                        }\n                    }\n                }\n            }\n            if (dist[0][201] != D[x][y]) {\n                cout << IMPOSSIBLE << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << POSSIBLE << endl;\n    int N = 202, M = 200 + 100 * 100;\n    cout << N << \" \" << M << endl;\n    for (int j = 1; j <= 100; ++j) {\n        cout << j << \" \" << (j+1) << \" \" << \"X\" << endl;\n    }\n    for (int j = 1; j <= 100; ++j) {\n        cout << 101+j << \" \" << 101+(j+1) << \" \" << \"Y\" << endl;\n    }\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            if (F[a][b] != 0) cout << \"foo \";\n            cout << (a+1) << \" \" << (202-b) << \" \" << F[a][b] << endl;\n        }\n    }\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_A 10\n#define MAX_B 10\n#define MAX_C 100\n\n#define xx first\n#define yy second\n\n#define MAX_CATE 100\n\nusing namespace std;\n\nint d[MAX_A + 1][MAX_B + 1];\n\nint cate[MAX_C + 1][MAX_C + 1][MAX_C + 1];\n\nvector <pair<pair<int, int>, int>> g[MAX_A + 1][MAX_B + 1];\nvector <pair<int, int>> care[MAX_C + 1][MAX_C + 1][MAX_C + 1];\n\nbool luat[MAX_A + 1][MAX_B + 1];\n\nstruct rezul\n{\n    int a, b, c;\n};\n\nint rez;\nrezul rz[MAX_CATE + 1];\n\nint A, B;\n\nint main()\n{\n    cin >> A >> B;\n\n    int i, j;\n    for(i = 1; i <= A; i ++)\n    {\n        for(j = 1; j <= B; j ++)\n            cin >> d[i][j];\n    }\n\n    int a, b, c, x, y;\n    for(a = 0; a <= 100; a ++)\n    {\n        for(b = 0; b <= 100; b ++)\n        {\n            for(c = 0; c <= 100; c ++)\n            {\n                int ok = 1;\n                int oke = 0;\n                for(x = 1; x <= A && ok; x ++)\n                {\n                    for(y = 1; y <= B && ok; y ++)\n                    {\n                        ok = ok && (a * x + b * y + c >= d[x][y]);\n                        oke = oke || (a * x + b * y + c == d[x][y]);\n                    }\n                }\n\n                if(ok && oke)\n                {\n                    for(x = 1; x <= A; x ++)\n                    {\n                        for(y = 1; y <= B; y ++)\n                        {\n                            if(a * x + b * y + c == d[x][y])\n                            {\n                                cate[a][b][c] ++;\n                                care[a][b][c].push_back({x, y});\n                                g[x][y].push_back({{a, b}, c});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int sum = 0;\n    for(x = 1; x <= A; x ++)\n    {\n        for(y = 1; y <= B; y ++)\n        {\n            if(luat[x][y] == 0)\n            {\n                luat[x][y] = 1;\n                if(g[x][y].size() == 0)\n                {\n                    cout << \"Impossible\\n\";\n                    return 0;\n                }\n\n                int a = g[x][y][0].xx.xx;\n                int b = g[x][y][0].xx.yy;\n                int c = g[x][y][0].yy;\n\n                rz[++ rez] = {a, b, c};\n                sum += a + b + 1;//(c > 0);\n\n                for(auto u : care[a][b][c])\n                    luat[u.xx][u.yy] = 1;\n            }\n        }\n    }\n\n    cout << \"Possible\\n\";\n    cout << \"300 \" << sum << \"\\n\";\n    assert(sum <= 300);\n\n    int k = 2;\n    int ant = 1;\n    for(i = 1; i <= rez; i ++)\n    {\n        int a = rz[i].a;\n        int b = rz[i].b;\n        int c = rz[i].c;\n\n        ant = 1;\n        for(j = 1; j <= a; j ++)\n        {\n            cout << ant << \" \" << k << \" X\\n\";\n            ant = k;\n            k ++;\n        }\n\n\n        for(j = 1; j <= b; j ++)\n        {\n            cout << ant << \" \" << k << \" Y\\n\";\n            ant = k;\n            k ++;\n        }\n\n        cout << ant << \" 300 \" << c << \"\\n\";\n    }\n\n\n    cout << \"1 300\" << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\n#define N 305\n#define INF 0x3fffffff\nint f[N][N];\nint d[N][N];\nbool check(int x,int y,int v)\n{\n\tint res=INF;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tres=min(res,i*x+j*y+f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res==v;\n}\nsigned main()\n{\n\tmemset(f,-1,sizeof(f));\n\tint a,b;\n\tcin>>a>>b;\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint tmp=-INF;\n\t\t\tfor(int c=1;c<=a;c++)\n\t\t\t{\n\t\t\t\tfor(int e=1;e<=b;e++)\n\t\t\t\t{\n\t\t\t\t\ttmp=max(tmp,d[c][e]-i*c-j*e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i][j]=tmp;\n\t\t\tif(f[i][j]<0) break;\n\t\t\tsum++;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tif(!check(i,j,d[i][j]))\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint s=201,t=202;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,sum+200);\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+100);\n\t}\n\tprintf(\"%d %d X\\n\",s,1);\n\tprintf(\"%d %d Y\\n\",101,t);\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\",i==0?s:i,j==0?t:j+100,f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<numeric>\n#include<bitset>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define MOD 1000000007\n#define EPS 1e-9\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int A,B;\n    cin >> A >> B;\n    int d[A+1][B+1], f[101][101], dmax = 0;\n    reppp(i, 1, A+1) reppp(j, 1, B+1){\n        cin >> d[i][j];\n        dmax = max(dmax, d[i][j]);\n    }\n\n    repp(a, dmax+1) repp(b, dmax+1){\n        int m = 0;\n        reppp(x, 1, A+1) reppp(y, 1, B+1){\n            m = max(m, d[x][y] - x*a - y*b);\n        }\n        f[a][b] = max(0, m);\n        if(f[a][b] > 100){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    reppp(x, 1, A+1) reppp(y, 1, B+1){\n        int shortest = INT_MAX;\n        repp(a, dmax+1) repp(b, dmax+1){\n            shortest = min(shortest, x*a + y*b + f[a][b]);\n        }\n        if(d[x][y] != shortest){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    printf(\"%d %d\\n\", (dmax+1)*2, (dmax+1)*(dmax+1) + 2*dmax);\n    reppp(n, 1, dmax+1) printf(\"%d %d %c\\n\", n, n+1, 'X');\n    reppp(n, dmax+2, 2*dmax+2) printf(\"%d %d %c\\n\", n, n+1, 'Y');\n    repp(a, dmax+1) repp(b, dmax+1) printf(\"%d %d %d\\n\", a+1, 2*dmax+2-b, f[a][b]);\n    printf(\"1 %d\\n\", 2*dmax+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 110;\n\nint n, m, d[N][N], f[N][N], dd[N][N];\n\nint main()\n{\n    freopen(\"1.out\", \"w\", stdout);\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, n) FOR(j, 1, m) scanf(\"%d\", &d[i][j]);\n    FOR(i, 0, 100) FOR(j, 0, 100) FOR(ii, 1, n) FOR(jj, 1, m)\n        f[i][j] = max(f[i][j], d[ii][jj] - i * ii - j * jj);\n    FOR(ii, 1, n) FOR(jj, 1, m)\n    {\n        dd[ii][jj] = 1e9;\n        FOR(i, 0, 100) FOR(j, 0, 100)\n            dd[ii][jj] = min(dd[ii][jj], i * ii + j * jj + f[i][j]);\n        if (dd[ii][jj] != d[ii][jj]) {puts(\"Impossible\"); return 0;}\n    }\n    puts(\"Possible\"); puts(\"202 10201\");\n    FOR(i, 0, 100) FOR(j, 0, 100) printf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n//////////////////////////\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\n\tvvll d(A + 1, vll(B + 1));\n\trepn(i, A)repn(j, B) cin >> d[i][j];\n\n\tvll a, b, c;\n\n\tll k = 1;\n\trep(x, 101)rep(y, 101) {\n\t\tll k = -1;\n\n\t\trepn(i, A)repn(j, B) {\n\t\t\tk = max(d[i][j] - x * i - y * j, k);\n\t\t}\n\t\t\n\t\tif (k >= 0) { a.push_back(x); b.push_back(y); c.push_back(k);}\n\t}\n\n\tll M = a.size();\n\n\tbool tf = 1;\n\n\trepn(i, A)repn(j, B) {\n\t\tll dis = INF;\n\t\trep(l, M) {\n\t\t\tdis = min(dis, a[l] * i + b[l] * j + c[l]);\n\t\t}\n\t\tif (dis != d[i][j]) { tf = 0; }\n\t}\n\n\tif (tf == 0) { cout << \"Impossible\" << endl; return 0; }\n\n\tcout << \"Possible\" << endl;\n\n\tcout << 202 << \" \" << 200 + M << endl;\n\n\trepn(i, 100) {\n\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t}\n\trepn(i, 100) {\n\t\tcout << 101 + i << \" \" << 101 + i + 1 << \" \" << \"Y\" << endl;\n\t}\n\trep(i, M) {\n\t\tcout << a[i] + 1 << \" \" << 202 - b[i] << \" \" << c[i] << endl;\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read( ){\n\tint x=0,y=1;char ch=' ';\n\tfor(;(ch!='-' && (ch>'9' || ch<'0'));ch=getchar( ));\n\tif(ch=='-')y=-1,ch=getchar( );\n\tfor(;ch>='0' && ch<='9';ch=getchar( ))x=x*10+ch-48;\n\treturn x*y;\n}\nconst int N=1e3+10;\nint n,m;\nint d[N][N],f[N][N];\nint main( ){\n\tint x,y,z,k;\n\tn=read();m=read();\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor(register int i=0;i<=100;++i)\n\t\tfor(register int j=0;j<=100;++j)\n\t\t\tfor(register int x=1;x<=n;++x)\n\t\t\t\tfor(register int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(register int x=1;x<=n;++x)\n\t\tfor(register int y=1;y<=m;++y){\n\t\t\tint mn=1000;\n\t\t\tfor(register int i=0;i<=100;++i)\n\t\t\t\tfor(register int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,i*x+j*y+f[i][j]);\n\t\t\tif(mn!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");return 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\",200+101*101);\n\tfor(register int i=1;i<=100;++i)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(register int i=102;i<=201;++i)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor(register int i=0;i<=100;++i)\n\t\tfor(register int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\t\n\tputs(\"1 202\");\n\treturn 0;\n}\n/*\n1<=x<=n  1<=y<=m \nf[i][j] :经过 i 个 x,j 个 y,其它边和的最小值 \nd[x][y] = min( i * x + j * y + f[i][j] )\nd[x][y] <= i * x + j * y + f[i][j]\nf[i][j] >= d[x][y] - i * x - j * y\n\nf[i][j] = max( d[x][y] - i * x - j * y )\n这样可能存在 dR[x][y] > d[x][y]\n但每个 f[i][j] 都存在一组 x,y dR[x][y]=d[x][y]\n所以 f[i][j] 不能调小，此时 impossible \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=101;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,maxm-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint d[10][10];\nint c[101][101];\n\nint main(){\n\tint a,b;\n\tcin >> a >> b;\n\n\tfor(int i=0; i<a; i++)\n\t\tfor(int j=0; j<b; j++)\n\t\t\tcin >> d[i][j];\n\n\tfor(int i=0; i<a; i++){\n\t\tfor(int j=1; j<b;j++){\n\t\t\tif(d[i][j-1] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(j!=b-1 && d[i][j-1] + d[i][j+1] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0; j<b; j++){\n\t\tfor(int i=1; i<a;i++){\n\t\t\tif(d[i-1][j] > d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(i!=a-1 && d[i-1][j] + d[i+1][j] > 2*d[i][j]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\n\tfor(int i=1;i<=100;i++){\n\t\tcout << i <<\"  \"<< i+1 <<\" X\"<<endl;\n\t\tcout << i+101 <<\" \"<< i+102 <<\" Y\"<<endl;\n\t}\n\n\tfor(int kx=0; kx<=100; kx++){\n\t\tfor(int ky=0; ky<=100; ky++){\n\t\t\tint res = 0;\n\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\t\tif(res < d[i][j] - kx*i - ky*j)\n\t\t\t\t\t\tres = d[i][j] - kx*i - ky*j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << kx+1 <<\" \"<<202 - ky<<\" \"<<res<<endl;\n\t\t}\n\t}\n\n\n\tcout << \"1 202\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            for(int it = j+1; it <= b; it++)\n            {\n                int delta = d[i][it] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-j;\n                y[i][j] = max(delta/k + (delta%k!=0), y[i][j]);\n            }\n            for(int it = i+1; it <= a; it++)\n            {\n                int delta = d[it][j] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-i;\n                x[i][j] = max(delta/k + (delta%k!=0), x[i][j]);\n            }\n            int cost = x[i][j]*i + y[i][j]*j;\n            if(cost>d[i][j])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb({x[i][j], y[i][j], d[i][j] - cost});\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    if(nodes>300) exit(7);\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\n\nint d[16][16] = {};\nbool pass[16][16] = {};\n\n\nint stu[12345][3];\n\nint main() {\n\tint A, B;\n\tcin >> A >> B;\n\n\trep(i, A)rep(j, B) {\n\t\tcin >> d[i][j];\n\t}\n\n\tint stuN = 0;\n\n\trep(s, 100)rep(t, 100) {\n\t\tint u = 0;\n\t\trep(i, A)rep(j, B) {\n\t\t\tint x = i + 1;\n\t\t\tint y = j + 1;\n\t\t\tu = max(u, d[i][j] - s*x - t*y);\n\t\t}\n\t\tbool f = true;\n\t\t\n\t\tif ([&]() {\n\t\t\tbool f = false;\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u < d[i][j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}()) {\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tpass[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstu[stuN][0] = s;\n\t\t\tstu[stuN][1] = t;\n\t\t\tstu[stuN][2] = u;\n\t\t\tstuN++;\n\t\t\t//cout << s << \"x + \" << t << \"y + \"<<u << endl;\n\t\t}\n\t}\n\trep(i, A)rep(j, B) {\n\t\tif (!pass[i][j]) {\n\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\n\tint E = A*B+1;\n\n\tcout << A*B << \" \" << A*(B - 1) + (A - 1)*B + 1 + stuN << endl;\n\n\trep(i, A) {\n\t\trep(j, B - 1) {\n\t\t\tcout << i*B + j + 1 << \" \" << i*B + j + 2 << \" Y\\n\";\n\t\t}\n\t}\n\trep(i, A - 1) {\n\t\trep(j, B) {\n\t\t\tcout << i*B + j + 1 << \" \" << (i+1)*B + j + 1 << \" X\\n\";\n\t\t}\n\t}\n\n\n\n\trep(k, stuN) {\n\t\t//cout << stu[i][0] << \"x + \" << stu[i][1] << \"y + \"<< stu[i][2] << endl;\n\t\tint i = stu[k][1];\n\t\tint j = stu[k][0];\n\t\tint c = stu[k][2];\n\t\tcout << i*B + j + 1 << \" \" << E << \" \"<<c << endl;\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n\tcout<<\"Impossible\"; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u, v, w; \n\n\tEdge (int u, int v, int w) :\n\t\tu(u), v(v), w(w) {}\n};\n\nint n, m, a[10][10];\nint S, T, id;\nvector<Edge> vres;\n\nvoid add(int x, int y, int z) {\n\tint cur = S;\n\t// -1 : A, -2 : B\n\twhile (x--) vres.push_back(Edge(cur, ++id, -1)), cur = id;\n\twhile (y--) vres.push_back(Edge(cur, ++id, -2)), cur = id;\n\tvres.push_back(Edge(cur, T, z));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 2, id = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tassert(id <= 300);\n\tcout << \"Possible\\n\";\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.u << ' ' << i.v << ' ';\n\t\tif (i.w == -1) cout << \"A\\n\";\n\t\tif (i.w == -2) cout << \"B\\n\";\n\t\tif (i.w >= 0) cout << i.w << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int inf=1000000000;\nstruct edge{\n\tint t,next,v;\n}g[210001];\nstruct data{\n\tint a,b,v;\n}e[210001];\nint te,i,j,k,n,m,a[21][21],h[411],tot,dis[411],q[210001],v[411],num,s,t,w,tx,ty,fl;\nvoid addedge(int x,int y,int z){\n\t//printf(\"%d %d %d\\n\",x,y,z);\n\tg[++tot].t=y;g[tot].next=h[x];h[x]=tot;g[tot].v=z;\n\te[++te].a=x;e[te].b=y;e[te].v=z;\n}\nint gv(int x){\n\tif (x>=0) return x;\n\tif (x==-1) return tx;else return ty;\n}\nint work(int x,int y){\n\tint i,j,res=0;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) res=max(res,a[i][j]-i*x-j*y);\n\treturn res;\n}\nint spfa(){\n\tint i,j,k,l,r;\n\tmemset(v,0,sizeof(v));\n\tfor (i=1;i<=num;i++) dis[i]=inf;\n\tl=0;r=1;q[1]=1;dis[1]=0;\n\twhile (l<r){\n\t\tj=q[++l];v[j]=0;\n\t\tfor (i=h[j];i;i=g[i].next)\n\t\t if (dis[g[i].t]>dis[j]+gv(g[i].v)){\n\t\t \tdis[g[i].t]=dis[j]+gv(g[i].v);\n\t\t \tif (!v[g[i].t]) v[g[i].t]=1,q[++r]=g[i].t;\n\t\t }\n\t}\n\treturn dis[num];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);w=105;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tnum=2*w;s=1;t=num;tot=te=0;memset(h,0,sizeof(h));\n\tfor (i=1;i<w;i++) addedge(i,i+1,-1),addedge(i+w,i+w+1,-2);\n\tfor (i=0;i<w;i++)\n\t for (j=0;j<w;j++) addedge(i+1,2*w-j,work(i,j));\n\tfor (i=fl=1;fl&&i<=n;i++)\n\t for (j=1;fl&&j<=m;j++){\n\t \ttx=i;ty=j;\n\t\tk=spfa();\n\t\tif (k!=a[i][j]) fl=0;//,printf(\"** %d %d %d\\n\",i,j,k);\n\t }\n\tif (!fl){\n\t\tputs(\"Impossible\");\n\t}else{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\",num,te);\n\t\tfor (i=1;i<=te;i++){\n\t\t\tprintf(\"%d %d \",e[i].a,e[i].b);\n\t\t\tif (e[i].v==-1) printf(\"X\\n\");\n\t\t\tif (e[i].v==-2) printf(\"Y\\n\");\n\t\t\tif (e[i].v>=0) printf(\"%d\\n\",e[i].v);\n\t\t}\n\t\tprintf(\"%d %d\\n\",1,num);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 111\n\nconst int val = 100;\n\nint A, B, i, j, n, m;\nint v[maxN][maxN];\nint least[maxN][maxN];\nvector< pair<pair<int, int>, int> > edges;\n\nvoid execute(int x, int y, int need) {\n    int i, j;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            least[i][j] = max(least[i][j], need - (x * i + y * j));\n\n}\n\nbool check(int x, int y, int need) {\n    int i, j;\n\n    int act = 1 << 30;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            act = min(act, i * x + j * y + least[i][j]);\n\n    if (act != need) return false;\n    return true;\n}\n\nvoid add_edge(int x, int y, int v) {\n    edges.pb(mp(mp(x, y), v));\n    m++;\n}\n\nint main()\n{\n//    freopen(\"test.in\",\"r\",stdin);\n\n    cin >> A >> B;\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            cin >> v[i][j];\n\n            execute(i, j, v[i][j]);\n        }\n    }\n\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            if (!check(i, j, v[i][j])) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    add_edge(1, 2, 0);\n    for (i = 2; i + 1 <= val + 2; i++)\n        add_edge(i, i + 1, -1);\n\n    add_edge(1, val + 3, 0);\n    for (i = val + 3; i + 1 <= 2 * val + 3; i++)\n        add_edge(i, i + 1, -2);\n\n    add_edge(2 * val + 3, 2 * val + 4, 0);\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            add_edge(i + 2, j + val + 3, least[i][j]);\n\n    n = 2 * val + 4;\n\n    cout << n << ' ' << m << '\\n';\n    for (auto e : edges) {\n        cout << e.first.first << ' ' << e.first.second << ' ';\n        if (e.second == -1) cout << \"X\\n\";\n        if (e.second == -2) cout << \"Y\\n\";\n        if (e.second >= 0) cout << e.second << \"\\n\";\n    }\n\n    cout << 1 << ' ' << n;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<map>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nint A,B;\nint dis[15][15];\nint ed[105][105];\nint main()\n{\n\tread(A);\n\tread(B);\n\tmemset(ed,-23,sizeof(ed));\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tread(dis[i][j]);\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\ted[a][b]=max(ed[a][b],dis[i][j]-a*i-b*j);\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tlong long ans=12345678987654321ll;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tans=min(ans,1ll*a*i+b*j+ed[a][b]);\n\t\t\tif(ans!=dis[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tcout<<202<<' '<<101*101+200<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i<<' '<<i+1<<\" X\"<<endl;\n\tfor(int i=1;i<=100;i++)\n\t\tcout<<i+101+1<<' '<<i+101<<\" Y\"<<endl;\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tcout<<i+1<<' '<<j+101+1<<' '<<ed[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b, d[11][11], ta, tb, tc;\npair< pair< int, int >, int > p[11][11];\nvector< pair< pair< int, int >, int > > v;\nbool u[101][101];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tscanf(\"%d\", d[i] + j), p[i][j].second = -1;\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tta = INT_MIN;\n\t\t\tfor (int ii = 1; ii <= a; ii++)\n\t\t\t\tfor (int jj = 1; jj <= b; jj++)\n\t\t\t\t\tta = max(ta, d[ii][jj] - ii * i - jj * j);\n\t\t\tif (ta >= 0 && ta <= 100)\n\t\t\t\tfor (int ii = 1; ii <= a; ii++)\n\t\t\t\t\tfor (int jj = 1; jj <= b; jj++)\n\t\t\t\t\t\tif (ta == d[ii][jj] - ii * i - jj * j)\n\t\t\t\t\t\t\tp[ii][jj] = make_pair(make_pair(i, j), ta);\n\t\t}\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tif (p[i][j].second == -1) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tfor (int i = 1; i <= 100; i++)\n\t\tv.push_back(make_pair(make_pair(i, i + 1), -1));\n\tfor (int i = 1; i <= 100; i++)\n\t\tv.push_back(make_pair(make_pair(101 + i, 101 + i + 1), -2));\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) {\n\t\t\tta = p[i][j].first.first;\n\t\t\ttb = p[i][j].first.second;\n\t\t\ttc = p[i][j].second;\n\t\t\tif (!u[ta][tb]) {\n\t\t\t\tu[ta][tb] = 1;\n\t\t\t\tv.push_back(make_pair(make_pair(ta + 1, 101 + 100 + 1 - tb), tc));\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n%d %d\\n\", 101 + 100 + 1, v.size());\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tprintf(\"%d %d \", v[i].first.first, v[i].first.second);\n\t\tif (v[i].second == -1)\n\t\t\tprintf(\"X\\n\");\n\t\telse if (v[i].second == -2)\n\t\t\tprintf(\"Y\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", v[i].second);\n\t}\n\tprintf(\"%d %d\\n\", 1, 101 + 100 + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nconst int inf=2147483647,mx=100;\nvoid fmax(int&a,int b){\n\tif(b>a)a=b;\n}\nvoid fmin(int&a,int b){\n\tif(b<a)a=b;\n}\nint d[20][20],f[110][110];\nint main(){\n\tint A,B,i,j,k,l,t;\n\tscanf(\"%d%d\",&A,&B);\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++)scanf(\"%d\",d[i]+j);\n\t}\n\tfor(i=0;i<=mx;i++){\n\t\tfor(j=0;j<=mx;j++){\n\t\t\tt=0;\n\t\t\tfor(k=1;k<=A;k++){\n\t\t\t\tfor(l=1;l<=B;l++)fmax(t,d[k][l]-i*k-j*l);\n\t\t\t}\n\t\t\tf[i][j]=t;\n\t\t}\n\t}\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++){\n\t\t\tt=inf;\n\t\t\tfor(k=0;k<=mx;k++){\n\t\t\t\tfor(l=0;l<=mx;l++)fmin(t,i*k+j*l+f[k][l]);\n\t\t\t}\n\t\t\tif(t!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n%d %d\\n\",mx*2+2,mx*2+(mx+1)*(mx+1));\n\tfor(i=1;i<=mx;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=mx+2;i<=2*mx+1;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=mx;i++){\n\t\tfor(j=0;j<=mx;j++)printf(\"%d %d %d\\n\",1+i,2*mx+2-j,f[i][j]);\n\t}\n\tprintf(\"%d %d\",1,mx*2+2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 2005\nusing namespace std;\nint a,b,tot;\nint d[maxn][maxn];\nint dis[maxn][maxn];\nint head[maxn],nex[maxn*maxn],to[maxn*maxn];\nstring val[maxn*maxn];\nvoid add(int x,int y,string z)\n{\n\tto[++tot]=y; val[tot]=z; nex[tot]=head[x]; head[x]=tot;\n}\nint main()\n{\n\tfreopen(\"1.txt\",\"w\",stdout);\n\tmemset(dis,0x3f,sizeof(dis));\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\n\tfor(int i=1;i<=100;i++)\n\t\tadd(i,i+1,\"X\");\n\n\tfor(int i=102;i<=201;i++)\n\t\tadd(i,i+1,\"Y\");\n\t\n//\tcerr<<\"+2\"<<endl;\n\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint temp=0;\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\ttemp=max(temp,d[k][o]-k*i-o*j);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr<<\"its \"<<i<<\" \"<<j<<endl;\t\n\t\t\tadd(i+1,202-j,to_string(temp));\n\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t{\n\t\t\t\tfor(int o=1;o<=b;o++)\n\t\t\t\t{\n\t\t\t\t\tdis[k][o]=min(dis[k][o],temp+i*k+o*j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcerr<<\"+1\"<<endl;\n\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\tif(dis[i][j]!=d[i][j])\n\t\t{\n//\t\t\tcerr<<d[i][j]<<' '<<dis[i][j]<<endl;\n\t\t\treturn printf(\"Impossible\\n\"),0;\n\t\t}\n\t}\n\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,tot);\t\n\tfor(int i=1;i<=202;i++)\n\t{\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t{\n\t\t\tcout<<i<<\" \"<<to[j]<<\" \"<<val[j]<<endl;\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint d[15][15];\nint li[222][222];\nint dis[222]; \nint main()\n{\n\tint a=io::F(),b=io::F();\n\tfor(register int i=1;i<=a;++i)\n\t\tfor(register int j=1;j<=b;++j)\n\t\t\td[i][j]=io::F();\n\tint po=202;\n\tfor(register int i=1;i<=po;++i)\n\t\tfor(register int j=1;j<=po;++j)\n\t\t\tli[i][j]=-3;\n\tint pe=0;\n\tfor(register int i=1;i<=100;++i)li[i][i+1]=-1,++pe;\n\tfor(register int i=202;i>102;--i)li[i][i-1]=-2,++pe;\n\tint s=1,t=102;\n\tfor(register int i=0;i<=100;++i)\n\t\tfor(register int j=0;j<=100;++j)\n\t\t{\n\t\t\tint max=0;\n\t\t\tfor(register int x=1;x<=a;++x)\n\t\t\t\tfor(register int y=1;y<=b;++y)\n\t\t\t\t\tcmax(max,d[x][y]-i*x-j*y);\n\t\t\tli[s+i][t+j]=max;\n\t\t\t++pe;\n\t\t}\n\tfor(register int x=1;x<=a;++x)\n\t\tfor(register int y=1;y<=b;++y)\n\t\t{\n\t\t\tmemset(dis,63,sizeof(dis));\n\t\t\tdis[1]=0;\n\t\t\tfor(register int i=1;i<=100;++i)dis[i+1]=dis[i]+x;\n\t\t\tfor(register int i=1;i<=101;++i)\n\t\t\t\tfor(register int j=102;j<=202;++j)\n\t\t\t\t\tif(li[i][j]!=-3)cmin(dis[j],dis[i]+li[i][j]);\n\t\t\tfor(register int i=202;i>t;--i)\n\t\t\t\tcmin(dis[i-1],dis[i]+y);\n\t\t\tif(dis[t]!=d[x][y])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",po,pe);\n\tfor(register int i=1;i<=po;++i)\n\t\tfor(register int j=1;j<=po;++j)\n\t\t{\n\t\t\tif(li[i][j]==-1)printf(\"%d %d X\\n\",i,j);\n\t\t\t\telse if(li[i][j]==-2)printf(\"%d %d Y\\n\",i,j);\n\t\t\t\t\t\telse if(li[i][j]!=-3)printf(\"%d %d %d\\n\",i,j,li[i][j]);\n\t\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << 101*2 sp << 100*2+101*101 ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nauto fraclt = [](const pii&a,const pii&b) { return (ll)a.x * b.y < (ll)b.x * a.y; };\nstruct cmpfrac { bool operator()(const pii&a,const pii&b)const { return (ll)a.x * b.y < (ll)b.x * a.y; }};\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { B = 0; for (auto &a: A) a = queue<T>(); }\nprivate:\n\tvector<queue<T>> A; ui B;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass E {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int A,B; cin >> A >> B;\n        vector2<int> D(A,B);\n        cin >> D;\n\n        int z = 100;\n\n        vector2<int> R(z+1,z+1,-1);\n        for (int i = 1; i <= A; ++i) {\n            for (int j = 1; j <= B; ++j) {\n                int c = D[i-1][j-1];\n                bool found = false;\n                for (int x = 0; x <= c/i && !found; ++x) {\n                    for (int y = 0; y <= (c-x*i)/j && !found; ++y) {\n                        int z = c-x*i-y*j;\n                        bool ok = true;\n                        for (int a = 1; a <= A && ok; ++a) {\n                            for (int b = 1; b <= B && ok; ++b) {\n                                if (a*x + b*y + z < D[a-1][b-1]) ok = false;\n                            }\n                        }\n                        if (ok) {\n                            found = true;\n                            R[x][y] = z;\n                        }\n                    }\n                }\n                if (!found) {\n                    cout << \"Impossible\\n\";\n                    return;\n                }\n            }\n        }\n\n        int M = 2*z;\n        for (int i = 0; i <= z; ++i) {\n            for (int j = 0; j <= z; ++j) {\n                if (R[i][j] != -1) ++M;\n            }\n        }\n\n        cout << \"Possible\\n\";\n        cout << 2*z+2 << \" \" << M << '\\n';\n        for (int i = 1; i <= z; ++i) {\n            cout << i << ' ' << i+1 << \" X\\n\";\n            cout << z+1+i << ' ' << z+2+i << \" Y\\n\";\n        }\n\n        for (int i = 0; i <= z; ++i) {\n            for (int j = 0; j <= z; ++j) {\n                if (R[i][j] != -1) {\n                    cout << i+1 << ' ' << 2*z+2-j << ' ' << R[i][j] << '\\n';\n                }\n            }\n        }\n\n\n        cout << 1 << ' ' << 2*z+2 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tE solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?102+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(100-j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint dd[12][12];\n\nvector<tuple<int, int, int> > vv;\n\nint en[12][12];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tint a, b;\n\tcin >> a >> b;\n\tfor (int i = 1; i <= a; ++i)\n\t\tfor (int j = 1; j <= b; ++j)\n\t\t\tcin >> dd[i][j];\n\tfor (int k = 0; k <= 100; ++k)\n\t\tfor (int x = 0; x + k <= 100; ++x)\n\t\t\tfor (int y = 0; x + y + k <= 100; ++y) {\n\t\t\t\tint fl = 0;\n\t\t\t\tfor (int i = 1; i <= a; ++i)\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (i * x + j * y + k < dd[i][j])\n\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t}\n\t\t\t\tif (fl)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int i = 1; i <= a; ++i)\n\t\t\t\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\t\t\t\tif (!en[i][j] && i * x + j * y + k == dd[i][j])\n\t\t\t\t\t\t\ten[i][j] = 1, fl = 1;\n\t\t\t\t\t}\n\t\t\t\tif (fl)\n\t\t\t\t\tvv.emplace_back(k, x, y);\n\t\t\t}\n\tfor (int i = 1; i <= a; ++i)\n\t\tfor (int j = 1; j <= b; ++j) {\n\t\t\tif (!en[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tint n = 202;\n\tvector<tuple<int, int, string>> ed;\n\tfor (int i = 1; i <= 100; ++i)\n\t\ted.emplace_back(i, i + 1, \"X\");\n\tfor (int i = 102; i < 202; ++i)\n\t\ted.emplace_back(i, i + 1, \"Y\");\n\tfor (auto e: vv) {\n\t\tint k, x, y;\n\t\ttie(k, x, y) = e;\n\t\ted.emplace_back(1 + x, 202 - y, to_string(k));\n\t}\n\tcout << n << \" \" << ed.size() << \"\\n\";\n\tfor (auto e: ed) {\n\t\tcout << get<0>(e) << \" \" << get<1>(e) << \" \" << get<2>(e) << \"\\n\";\n\t}\n\tcout << 1 << \" \" << 202 << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define max(a, b) (((a)<(b))?b:a)\n#define min(a, b) ((a>b)?b:a)\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pi 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define maxlg 18\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\n#define maxn 2006\nint a,b;\nint d[26][26];\nint f[101][101];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n #endif\n    cin>>a>>b;\n    rep (i,0,a)\n        rep (j,0,b)\n            cin>>d[i+1][j+1];\n\n    rep (i,0,100+1)\n        rep (j,0,100+1)\n            rep (x,1,a+1)\n                rep (y,1,b+1) {\n                    f[i][j] = max(f[i][j],d[x][y]-i*x-j*y);\n                }\n\n    rep (x,1,a+1)\n        rep (y,1,b+1) {\n            int dist = 1e9;\n            rep (i,0,100+1)\n                rep (j,0,100+1) {\n                    dist= min(dist,f[i][j]+i*x +j*y);\n                }\n            if (dist!=d[x][y]){\n                cout<<\"Impossible\";\n                return 0;\n            }\n        }\n    cout<<\"Possible\\n\";\n    vector<string>  ans;\n    rep (i,1,102) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" X\\n\");\n        rep (j,102,203) {\n            ans.push_back(to_string(i)+ \" \"+to_string(j)+\" \"+ to_string(f[i-1][202-j])+\"\\n\");\n\n        }\n    }\n    rep (i,102,203) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" Y\\n\");\n    }\n    cout<<202<<\" \"<<ans.size()<<endl;\n    rep (i,0,ans.size()) {\n        cout<<ans[i];\n    }\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint w[11][11], v[11][11];\nint A, B;\nstruct Edge {\n\tint a, b, c;\n}E[10100];\nint cnt;\nint main() {\n\tint i, j, k, l;\n\tscanf(\"%d%d\", &A, &B);\n\tfor (i = 1; i <= 100; i++) {\n\t\tE[cnt++] = { i,i + 1,-2 };\n\t}\n\tfor (i = 102; i < 202; i++) {\n\t\tE[cnt++] = { i,i + 1,-1 };\n\t}\n\tfor (i = 1; i <= A; i++)for (j = 1; j <= B; j++)scanf(\"%d\", &w[i][j]);\n\tfor (i = 0; i <= 100; i++)for (j = 0; i + j <= 100; j++){\n\t\tint Mx = 0;\n\t\tfor (k = 1; k <= A; k++) {\n\t\t\tfor (l = 1; l <= B; l++) {\n\t\t\t\tMx = max(Mx, w[k][l] - i*k - j*l);\n\t\t\t}\n\t\t}\n\t\tif (Mx < 0)continue;\n\t\tint chk = 0;\n\t\tfor (k = 1; k <= A; k++) {\n\t\t\tfor (l = 1; l <= B; l++) {\n\t\t\t\tif (w[k][l] == i*k + j*l + Mx && !v[k][l])chk = 1, v[k][l] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!chk)continue;\n\t\tE[cnt++] = { i + 1, 202 - j, Mx };\n\t}\n\tfor (i = 1; i <= A; i++)for (j = 1; j <= B; j++)if (!v[i][j]) {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 202, cnt);\n\tfor (i = 0; i < cnt; i++) {\n\t\tprintf(\"%d %d \", E[i].a, E[i].b);\n\t\tif (E[i].c < 0)printf(\"%c\\n\", E[i].c + 'Z');\n\t\telse printf(\"%d\\n\", E[i].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define max(a, b) (((a)<(b))?b:a)\n#define min(a, b) ((a>b)?b:a)\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pi 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define maxlg 18\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\n#define maxn 2006\nint a,b;\nint d[26][26];\nint f[105][105];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n #endif\n    cin>>a>>b;\n    rep (i,0,a)\n        rep (j,0,b)\n            cin>>d[i+1][j+1];\n\n    rep (i,0,100+1)\n        rep (j,0,100+1)\n            rep (x,1,a+1)\n                rep (y,1,b+1) {\n                    f[i][j] = max(f[i][j],d[x][y]-i*x-j*y);\n                }\n\n    rep (x,1,a+1)\n        rep (y,1,b+1) {\n            int dist = 1e9;\n            rep (i,0,100+1)\n                rep (j,0,100+1) {\n                    dist= min(dist,f[i][j]+i*x +j*y);\n                }\n            if (dist!=d[x][y]){\n                cout<<\"Impossible\";\n                return 0;\n            }\n        }\n    cout<<\"Possible\\n\";\n    vector<string>  ans;\n    rep (i,1,101) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" X\\n\");\n        rep (j,102,203) {\n            ans.push_back(to_string(i)+ \" \"+to_string(j)+\" \"+ to_string(f[i-1][202-j])+\"\\n\");\n        }\n    }\n    rep (i,102,202) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" Y\\n\");\n    }\n    cout<<202<<\" \"<<ans.size()<<endl;\n    rep (i,0,ans.size()) {\n        cout<<ans[i];\n    }\n    cout<<1<<\" \"<<202;\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst int inf=0x3f3f3f3f;\nint A,B,d[15][15],f[105][105];\nstruct edge{int u,v,w;}e[40005];\nint n,m;\nint main(){\n\tA=read(),B=read();\n\tREP(i,1,A)\n\t\tREP(j,1,B)\n\t\t\td[i][j]=read();\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tREP(x,1,A)\n\t\t\t\tREP(y,1,B)\n\t\t\t\t\tchkmax(f[i][j],d[x][y]-i*x-j*y);\n\tREP(x,1,A)\n\t\tREP(y,1,B){\n\t\t\tint dis=inf;\n\t\t\tint ii,jj;\n\t\t\tREP(i,0,100)\n\t\t\t\tREP(j,0,100)\n\t\t\t\t\tif(chkmin(dis,f[i][j]+i*x+j*y))ii=i,jj=j;\n\t\t\tif(dis>d[x][y])return puts(\"Impossible\"),0;\n\t\t}\n\tn=202,m=10401;\n\twrite(n,' '),write(m,'\\n');\n\tputs(\"Possible\");\n\tREP(i,2,n/2)\n\t\tprintf(\"%d %d X\\n\",i-1,i);\n\tREP(i,n/2+2,n)\n\t\tprintf(\"%d %d Y\\n\",i-1,i);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",1+i,n-j,f[i][j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = 0, y = 0;\n\t\t\tfor(int k = i+1; k <= a; k++) chmax(x, (d[k][j]-d[i][j]+k-i-1)/(k-i));\n\t\t\tfor(int k = j+1; k <= b; k++) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t//ll x = i<a?(d[a][j]-d[i][j]+a-i)/(a-i):0;\n\t\t\t//ll y = j<b?(d[i][b]-d[i][j]+b-j)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200+100*100-1;\n\trep(i, 100) rep(j, 100){\n\t\tif(i==99&&j==99) break;\n\t\tll c = 0;\n\t\trep1(i2, a) rep1(j2, b) chmax(c, d[i2][j2]-(i*i2+j*j2));\n\t\tg[1+i][201-j] = c;\n\t}\n\t/*for(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = 0, y = 0;\n\t\t\tfor(int k = i+1; k <= a; k++) chmax(x, (d[k][j]-d[i][j]+k-i-1)/(k-i));\n\t\t\tfor(int k = j+1; k <= b; k++) chmax(y, (d[i][k]-d[i][j]+k-j-1)/(k-j));\n\t\t\t//ll x = i<a?(d[a][j]-d[i][j]+a-i)/(a-i):0;\n\t\t\t//ll y = j<b?(d[i][b]-d[i][j]+b-j)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||(g[x+1][201-y]!=-1)||(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}*/\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            func mn={-1, -1, 102};\n            for(int ix = 0; ix <= 100; ix++)\n            {\n                for(int iy = 0; iy <= 100; iy++)\n                {\n                    int cost = ix*i + iy*j;\n                    if(cost > d[i][j]) continue;\n                    int kk = d[i][j] - cost;\n                    if(kk > mn.k) continue;\n                    if(kk==mn.k && ix+iy > mn.xc + mn.yc) continue;\n                    bool flag=true;\n                    for(int ita = 1; ita <= a; ita++)\n                    {\n                        for(int itb = 1; itb <= b; itb++)\n                        {\n                            if(ix*ita + iy*itb + kk < d[ita][itb])\n                            {\n                                flag=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(flag)\n                    {\n                        mn={ix, iy, kk};\n                    }\n                }\n            }\n            if(mn.xc==-1)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb(mn);\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    if(nodes>300) exit(7);\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int A, B; cin >> A >> B;\n    vector d(A, vector(B, 0));\n    for(auto& v : d){\n        for(auto& t : v) cin >> t;\n    }\n    int ofs[101][101];\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            ofs[i][j] = 0;\n            for(int a=1;a<=A;a++){\n                for(int b=1;b<=B;b++){\n                    ofs[i][j] = max(ofs[i][j], d[a-1][b-1]-(i*a+j*b));\n                }\n            }\n        }\n    }\n    bool ok = true;\n    for(int a=1;a<=A;a++){\n        for(int b=1;b<=B;b++){\n            int r = 10000;\n            for(int i=0;i<=100;i++){\n                for(int j=0;j<=100;j++){\n                    r = min(r, i*a+j*b+ofs[i][j]);\n                }\n            }\n            if(r != d[a-1][b-1]) ok = false;\n        }\n    }\n    if(ok){\n        cout << \"Possible\" << endl;\n        cout << 300 << \" \" << 200 + 101*101 << endl;\n        for(int i=1;i<=100;i++){\n            cout << i << \" \" << i+1 << \" X\" << endl;\n            cout << 151+i << \" \" << 150+i << \" Y\" << endl;\n        }\n        for(int i=0;i<=100;i++){\n            for(int j=0;j<=100;j++){\n                cout << i+1 << \" \" << j+151 << \" \" << ofs[i][j] << endl;\n            }\n        }\n        cout << 1 << \" \" << 151 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m, A, B, d[200][200];\nint used[200][200];\nvector<pair<int, int> > ed[2000];\nvoid add(int x, int y, int z) {\n    ed[x].push_back(make_pair(y, z));\n    m++;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> A >> B;\n    for (int i = 1; i <= A; i++)\n    for (int j = 1; j <= B; j++) cin >> d[i][j];\n    for (int i = 1; i < 99; i++) add(i, i + 1, -1);\n    for (int i = 101; i < 200; i++) add(i + 1, i, -2);\n    int cnt = 200;\n    for (int c1 = 0; c1 < 100; c1++)\n    for (int c2 = 0; c2 < 100; c2++)\n    for (int c3 = 0; c3 <= 100; c3++) {\n        if (c1 + c2 + c3 > 100) break;\n        bool bd = 0; vector<pair<int, int> > lst;\n        for (int i = 1; i <= A; i++) {\n            for (int j = 1; j <= B; j++)\n            if (i * c1 + j * c2 + c3 < d[i][j]) {\n                bd = 1;\n                break;\n            }\n            else\n            if (i * c1 + j * c2 + c3 == d[i][j] && used[i][j] == 0) lst.push_back(make_pair(i, j));\n            if (bd == 1) break;\n        }\n        if (bd) continue;\n        if (lst.size() != 0) {\n            cnt++;\n            add(c1 + 1, cnt, c3);\n            add(cnt, c2 + 101, 0);\n            for (int i = 0; i < lst.size(); i++) used[lst[i].first][lst[i].second] = 1;\n        }\n    }\n    for (int i = 1; i <= A; i++)\n    for (int j = 1; j <= B; j++)\n    if (used[i][j] == 0) {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    cout << \"Possible\\n\";\n    cout << cnt << \" \" << m << \"\\n\";\n    for (int i = 1; i <= cnt; i++) {\n        for (int j = 0; j < ed[i].size(); j++) {\n            int to = ed[i][j].first;\n            int cs = ed[i][j].second;\n            cout << i << \" \" << to << \" \";\n            if (cs >= 0) cout << cs << \"\\n\";\n            else\n            if (cs == -1) cout << \"X\\n\";\n            else cout << \"Y\\n\";\n        }\n    }\n    cout << \"1 101\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nint ff,ans[105][105][3],a,b,dist[105][105],tong[105][105];\nint main(){\n\ta=read(); b=read();\n\tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++)dist[i][j]=read();\n\tfor(int i=0;i<=100;i++)for(int j=0;j<=100;j++)for(int o=0;o<=100;o++){\n\t\tint f=1;\n\t\tfor(int k=1;k<=a&&f;k++){\n\t\t\tfor(int l=1;l<=b&&f;l++)if(i*k+j*l+o<dist[k][l])f=0;\n\t\t}\n\t\tif(!f)continue;\n\t\tfor(int k=1;k<=a;k++){\n\t\t\tfor(int l=1;l<=b;l++){\n\t\t\t\tif(i*k+j*l+o==dist[k][l]){\n\t\t\t\t\tans[k][l][0]=i+1; ans[k][l][1]=j+1; ans[k][l][2]=o;\n\t\t\t\t}\n\t\t\t}\n\t\t} break;\n\t}\n\tff=1;\n\tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++)if(!ans[i][j][0])ff=0;\n\tif(!ff){\n\t\tputs(\"Impossible\"); return 0;\n\t}\n\tputs(\"Possible\");\n\tint m=200; for(int i=1;i<=a;i++)for(int j=1;j<=b;j++){\n\t\tif(!tong[ans[i][j][0]][ans[i][j][1]])m++; tong[ans[i][j][0]][ans[i][j][1]]=1;\n\t}\n\tcout<<202<<\" \"<<m<<endl; memset(tong,0,sizeof(tong));\n\tfor(int i=1;i<=100;i++)cout<<i<<\" \"<<i+1<<\" X\\n\";\n\tfor(int i=102;i<=201;i++)cout<<i<<' '<<i+1<<\" Y\\n\";\n\tfor(int i=1;i<=a;i++)for(int j=1;j<=b;j++)if(ans[i][j][0]){\n\t\tif(!tong[ans[i][j][0]][ans[i][j][1]]){\n\t\t\tcout<<ans[i][j][0]<<\" \"<<203-ans[i][j][1]<<\" \"<<ans[i][j][2]<<endl;\n\t\t}\n\t\ttong[ans[i][j][0]][ans[i][j][1]]=1;\n\t}\n\tputs(\"1 202\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A, B, N, M, S, T, d[15][15];\nint adj[102][102];\nint dist[204];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i){\n\t\tfor (int j = 1; j <= B; ++j){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tS = 1;\n\tT = 202;\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 1; k <= A; ++k){\n\t\t\t\tfor (int l = 1; l <= B; ++l){\n\t\t\t\t\tmaxi = max(maxi,d[k][l]-k*i-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj[i][j] = maxi;\n\t\t}\n\t}\n\tfor (int k = 1; k <= A; ++k){\n\t\tfor (int l = 1; l <= B; ++l){\n\t\t\tdist[1] = 0;\n\t\t\tfor (int i = 1; i <= 100; ++i){\n\t\t\t\tdist[i+1] = dist[i] + k;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 100; ++i){\n\t\t\t\tint mini = 1e9;\n\t\t\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\t\t\tmini = min(mini,adj[j][i]+dist[j+1]);\n\t\t\t\t}\n\t\t\t\tif (i > 0){\n\t\t\t\t\tmini = min(mini,dist[102+i-1]+l);\n\t\t\t\t}\n\t\t\t\tdist[102+i] = mini;\n\t\t\t}\n\t\t\tif (dist[202] != d[k][l]){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tN = 202;\n\tM = 100+100+(101*101);\n\tfor (int i = 1; i <= 100; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 102; i <= 201; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tcout << i+1 << ' ' << j+102 << ' ' << adj[i][j] << '\\n';\n\t\t}\n\t}\n\tcout << S << ' ' << T << '\\n';\n\tcout << flush;\n\t//for (int i = 1; i < 1e9; ++i){for (int j = 0; j < 1e9; ++j){}}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool flg[101][101][101];\n\nint main()\n{\n    cin.tie(0);\n\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> bd(a, vector<int>(b));\n\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            cin >> bd[i][j];\n        }\n    }\n\n    memset(flg, 0, sizeof(flg));\n    bool possible = true;\n    for (int x = 1; x <= a; x++) {\n        for (int y = 1; y <= b; y++) {\n            int t = bd[x - 1][y - 1];\n            bool ok = false;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    for (int c = 0; c <= 100; c++) {\n                        if (flg[a][b][c])\n                            continue;\n\n                        if (a * x + b * y + c == t) {\n                            ok = true;\n                        }\n\n                        if (a * x + b * y + c < t) {\n                            flg[a][b][c] = true;\n                        }\n                    }\n                }\n            }\n            if (!ok) {\n                possible = false;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    cout << \"Possible\" << endl;\n\n    map<pair<int, int>, int> es;\n    es[make_pair(100, 101)] = 100;\n    for (int i = 0; i < 100; i++) {\n        es[make_pair(i, i + 1)] = -1;\n        es[make_pair(101 + i, 101 + i + 1)] = -2;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            for (int c = 0; c <= 100; c++) {\n                if (!flg[a][b][c]) {\n                    es[make_pair(a, 201 - b)] = c;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << 202 << \" \" << es.size() << endl;\n\n    for (auto& it : es) {\n        cout << it.first.first + 1 << \" \" << it.first.second + 1 << \" \";\n        if (it.second == -1) {\n            cout << \"X\";\n        } else if (it.second == -2) {\n            cout << \"Y\";\n        } else {\n            cout << it.second;\n        }\n        cout << endl;\n    }\n\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int M = 101;\nint A, B;\nint d[M][M];\nint a[M][M];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tscanf(\"%d%d\", &A, &B);\n\tfor (int i = 1; i <= A; i++)\n\t\tfor (int j = 1; j <= B; j++)\n\t\t\tscanf(\"%d\", &d[i][j]);\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++) {\n\t\t\ta[x][y] = 0;\n\t\t\tfor (int i = 1; i <= A; i++)\n\t\t\t\tfor (int j = 1; j <= B; j++) {\n\t\t\t\t\ta[x][y] = max(a[x][y], d[i][j] - i * x - j * y);\n\t\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= A; i++)\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (int x = 0; x < M; x++)\n\t\t\t\tfor (int y = 0; y < M; y++) {\n\t\t\t\t\tif (a[x][y] + i * x + j * y == d[i][j])\n\t\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 2 * M, 2 * M - 2 + M * M);\n\tfor (int i = 0; i < M - 1; i++) {\n\t\tprintf(\"%d %d X\\n\", 1 + i, 1 + i + 1);\n\t\tprintf(\"%d %d Y\\n\", 1 + M + i + 1, 1 + M + i);\n\t}\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tprintf(\"%d %d %d\\n\", 1 + x, 1 + M + y, a[x][y]);\n\tprintf(\"1 %d\\n\", M + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#endif\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\nusing ld = long double;\n\nconstexpr int nax = 300;\nconstexpr int infty = 1000 * 1000 * 1000 + 5;\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\n\nconstexpr int MaxWsp = 145;\n\nint n, s, t, A, B;\nint D[11][11];\nint gdziex[MaxWsp + 1];\nint gdziey[MaxWsp + 1];\nvoid DajKrawedz(int a, int b, int d);\n\nvoid Algos() {\n  for (int x = 1; x <= A; x++) {\n    for (int y = 1; y <= B; y++) {\n      for (int a = 0; a <= MaxWsp; a++) {\n        for (int b = 0; b <= MaxWsp; b++) {\n          const int c = D[x][y] - a * x - b * y;\n          if (!(0 <= c and c <= 100)) {\n            goto out;\n          }\n          for (int x2 = 1; x2 <= A; x2++) {\n            for (int y2 = 1; y2 <= B; y2++) {\n              if (a * x2 + b * y2 + c < D[x2][y2]) {\n                goto out;\n              }\n            }\n          }\n          debug() << imie(x) imie(y) imie(a) imie(b) imie(c) imie(gdziex[a]) imie(gdziey[b]);\n          DajKrawedz(gdziex[a], gdziey[b], c);\n          goto mam_juz;\n          out:;\n        }\n      }\n      mam_juz:;\n    }\n  }\n}\n\nmap<int, string> graf[nax];\n\nll mac[nax][nax];\nll odl[nax];\nbool nakol[nax];\n\nint Odl() {\n  for (int i = 0; i < n; i++) {\n    odl[i] = numeric_limits<ll>::max();\n    nakol[i] = false;\n  }\n  odl[s] = 0;\n  queue<int> kol;\n  kol.push(s);\n  while (!kol.empty()) {\n    const int w = kol.front();\n    kol.pop();\n    nakol[w] = false;\n    for (int i = 0; i < n; i++) {\n      if (mac[w][i] == numeric_limits<ll>::max()) continue;\n      const ll o = odl[w] + mac[w][i];\n      if (o < odl[i]) {\n        odl[i] = o;\n        if (!nakol[i]) {\n          nakol[i] = true;\n          kol.push(i);\n        }\n      }\n    }\n  }\n  return odl[t];\n}\n\nbool Check() {\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      for (int k = 0; k < n; k++) {\n        for (int l = 0; l < n; l++) {\n          mac[k][l] = numeric_limits<ll>::max();\n        }\n      }\n      for (int k = 0; k < n; k++) {\n        for (auto& it : graf[k]) {\n          if (it.second == \"X\") mac[k][it.first] = i;\n          else if (it.second == \"Y\") mac[k][it.first] = j;\n          else {\n            stringstream str(it.second);\n            int d;\n            str >> d;\n            mac[k][it.first] = d;\n          }\n        }\n      }\n      const ll o = Odl();\n      if (o != D[i][j]) {\n        debug() << imie(i) imie(j) imie(D[i][j]) imie(o);\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid DajKrawedz(int a, int b, int d) {\n  assert(0 <= a and a < n);\n  assert(0 <= b and b < n);\n  assert(a != b);\n  graf[a][b] = to_string(d);\n}\n\nint DajId() {\n  assert(n < nax);\n  return n++;\n}\n\nint main() {\n  scanf(\"%d%d\", &A, &B);\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      scanf(\"%d\", &D[i][j]);\n    }\n  }\n\n  s = DajId();\n  t = DajId();\n  /*\n  for (int y = 0; y <= MaxWsp; y++) {\n    int last = t;\n    for (int j = 0; j < y; j++) {\n      const int nowy = DajId();\n      graf[nowy][last] = \"Y\";\n      last = nowy;\n    }\n    for (int x = 0; true; x++) {\n      gdziex[x][y] = last;\n      if (x == MaxWsp) break;\n      const int nowy = DajId();\n      graf[nowy][last] = \"X\";\n      last = nowy;\n    }\n  }\n  */\n\n  int last = s;\n  for (int x = 0; x <= MaxWsp; x++) {\n    gdziex[x] = last;\n    if (x == MaxWsp) break;\n    const int nowy = DajId();\n    graf[last][nowy] = \"X\";\n    last = nowy;\n  }\n  last = t;\n  for (int y = 0; y <= MaxWsp; y++) {\n    gdziey[y] = last;\n    if (y == MaxWsp) break;\n    const int nowy = DajId();\n    graf[nowy][last] = \"Y\";\n    last = nowy;\n  }\n  debug() << imie(range(gdziex, gdziex + MaxWsp + 1));\n  debug() << imie(range(gdziey, gdziey + MaxWsp + 1));\n\n  Algos();\n  if (!Check()) {\n    printf(\"Impossible\\n\");\n    return 0;\n  }\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    m += (int) graf[i].size();\n  }\n  printf(\"Possible\\n\");\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 0; i < n; i++) {\n    for (auto& it : graf[i]) {\n      printf(\"%d %d %s\\n\", i + 1, it.first + 1, it.second.c_str());\n    }\n  }\n  printf(\"%d %d\\n\", s + 1, t + 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007\n#define lson(v) ((v)<<1)\n#define rson(v) (((v)<<1)^1)\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\ntypedef pair < pii , int > p3i;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint A,B,arr[15][15];\nvector < p3i > paths;\nint main(){\n    // inputing start\n    scanf(\"%d%d\",&A,&B);\n\tint xb,x2,x3,x4,x5,mmax=0,mmay=0;\n\tfor(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tscanf(\"%d\",&arr[xb][x2]);\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    for(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tint a=xb+1,b=x2+1,k=arr[xb][x2],maxy=105,miny=0;\n\t\t\tfor(x5=0;x5<=105;++x5){\n\t\t\t\tmaxy=105;miny=0;\n\t\t\t\tfor(x3=0;x3<A;++x3){\n\t\t\t\t\tfor(x4=0;x4<B;++x4){\n\t\t\t\t\t\tint n=x3+1,m=x4+1,c=arr[x3][x4],coe=m-b,val=c-k-x5*(n-a);\n\t\t\t\t\t\tif(x3==xb && x4==x2){\n\t\t\t\t\t\t\tn=-a;m=-b;c=-k;\n\t\t\t\t\t\t\tcoe=m;\n\t\t\t\t\t\t\tval=c-n*x5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe*val<0){\n\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(val==0){\n\t\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\t\tUMIN(maxy,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe==0){\n\t\t\t\t\t\t\tif(val>0){\n\t\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\tUMIN(maxy,(-val)/(-coe));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe>0){\n\t\t\t\t\t\t\tUMAX(miny,(val+coe-1)/coe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(miny<=maxy){\n\t\t\t\t\tif(k-x5*a-miny*b<0) continue;\n\t\t\t\t\tpaths.push_back(mpr(mpr(x5,miny),k-x5*a-miny*b));\n\t\t\t\t\tUMAX(mmax,x5);\n\t\t\t\t\tUMAX(mmay,miny);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x5>105){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\tax+by+z=k\n\t\t\t *  -ax-by>=-k\n\t\t\t *   nx+my>=c\n\t\t\t *   coe=m  val=c-nx\n\t\t\t\tz=k-ax-by\n\t\t\t\tnx+my+k-ax-by>=c\n\t\t\t\t(n-a)x+(m-b)y>=c-k  \n\t\t\t\tcoe*y>=val  \n\t\t\t\tor\n\t\t\t\t-coe*y<=-val  */\n\t\t}\n\t}\n\tsort(paths.begin(),paths.end());\n\tpaths.erase(unique(paths.begin(),paths.end()),paths.end());\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",mmax+1+mmay+1,mmax+mmay+(int)paths.size());\n\tfor(xb=0;xb<mmax;++xb){\n\t\tprintf(\"%d %d x\\n\",xb+1,xb+2);\n\t}\n\tfor(xb=mmay-1;xb>=0;--xb){\n\t\tprintf(\"%d %d y\\n\",mmax+xb+3,mmax+xb+2);\n\t}\n\tfor(xb=0;xb<paths.size();++xb){\n\t\tprintf(\"%d %d %d\\n\",paths[xb].first.first+1,paths[xb].first.second+mmax+2,paths[xb].second);\n\t}\n\tprintf(\"%d %d\\n\",1,mmax+2);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\ninline bool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\ninline bool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x << 1) + (x << 3) + (ch ^ 48);\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"E.in\", \"r\", stdin);\n\tfreopen (\"E.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 310;\nint A, B, n, d[N][N], f[N][N];\n\nint main () {\n\tFile();\n\n\tn = 149;\n\tA = read(); B = read();\n\tFor (i, 1, A) For (j, 1, B) d[i][j] = read();\n\n\tFor (i, 0, n) For (j, 0, n)\n\t\tFor (a_, 1, A) For (b_, 1, B)\n\t\t\tchkmax(f[i][j], d[a_][b_] - a_ * i - b_ * j);\n\n\tFor (a_, 1, A) For (b_, 1, B) {\n\t\tint res = 0x7f7f7f7f;\n\t\tFor (i, 0, n) For (j, 0, n)\n\t\t\tchkmin(res, f[i][j] + a_ * i + b_ * j);\n\t\tif (res != d[a_][b_]) return puts(\"Impossible\"), 0;\n\t}\n\n\tputs(\"Possible\");\n\t\n\tprintf (\"%d %d\\n\", n * 2 + 2, n * 2 + (n + 1) * (n + 1));\n\tint S = 1, T = n + 2;\n\tFor (i, 1, n)\n\t\tprintf (\"%d %d X\\n\", i, i + 1);\n\n\tFor (i, 1, n)\n\t\tprintf (\"%d %d Y\\n\", i + n + 2, i + n + 1);\n\n\tFor (i, 0, n) For (j, 0, n)\n\t\tprintf (\"%d %d %d\\n\", i + 1, j + n + 2, f[i][j]);\n\n\tprintf (\"%d %d\\n\", S, T);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 99999;\nint A, B;\nint d[11][11];\nvector<piii> E;\n\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int a=0;a<100;a++){\n        for(int b=0;b<100;b++){\n            int c = -1;\n            for(int x=1;x<=A;x++){\n                for(int y=1;y<=B;y++){\n                    c = max(d[x][y] - a*x - b*y, c);\n                }\n            }\n            if (c >= 0 && c <= 100)E.emplace_back(pii(a,b),c);\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=305,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint A,B,k[N],b[N],d[15][15];\nint f[105][105],ans[N];\nbool vis[N],use[105][105];\nvector<pii> g[N];\n\nint X[N],Y[N];\nvector<pair<pii,int> > edge;\ninline void push(int x,int y,int k){\n\tedge.pb(mp(mp(x,y),k));\n}\ninline void putans(){\n\tprintf(\"%d %d\\n\",300,SZ(edge));\n\tfor(auto i:edge){\n\t\tprintf(\"%d %d \",i.FF.FF,i.FF.SS);\n\t\tif(i.SS>=0) printf(\"%d\\n\",i.SS); else if(i.SS==-1) puts(\"X\"); else puts(\"Y\");\n\t}\n\tprintf(\"%d %d\\n\",299,300);\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(A,B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tread(d[i][j]);\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++){\n\t\t\t\t\tint tmp=a*i+b*j;\n\t\t\t\t\tgmax(f[a][b],d[i][j]-tmp);\n\t\t\t\t}\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tbool isok=0;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tif(f[a][b]+a*i+b*j==d[i][j])\n\t\t\t\t\t\tisok=1,use[a][b]=1;\n\t\t\tif(!isok){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=299,T=300;\n\tX[0]=S;Y[0]=T;\n\tfor(int i=1;i<=100;i++)\n\t\tX[i]=i;\n\tfor(int i=1;i<=100;i++)\n\t\tY[i]=i+105;\n\tfor(int i=0;i<100;i++)\n\t\tpush(X[i],X[i+1],-1);\n\tfor(int i=0;i<100;i++)\n\t\tpush(Y[i+1],Y[i],-2);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tif(use[i][j]) push(X[i],Y[j],f[i][j]);\n\tputans();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        // assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << 1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst string POSSIBLE = \"Possible\", IMPOSSIBLE = \"Impossible\";\nconst int INF = numeric_limits<int>::max();\n\n\nint A, B, D[11][11];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 1; j <= A; ++j) {\n        for (int k = 1; k <= B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    int F[101][101];\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            F[a][b] = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    F[a][b] = max(F[a][b], D[x][y] - x*a - y*b);\n                }\n            }\n        }\n    }\n\n    int graph[205][205], dist[205][205];\n    for (int j = 0; j < 205; ++j) {\n        fill(graph[j], graph[j]+205, INF);\n        graph[j][j] = 0;\n    }\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            graph[a][201-b] = F[a][b];\n        }\n    }\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            for (int j = 1; j <= 100; ++j) {\n                graph[j-1][j] = x;\n            }\n            for (int j = 1; j <= 100; ++j) {\n                graph[101+(j-1)][101+j] = y;\n            }\n\n            for (int j = 0; j < 205; ++j) {\n                for (int k = 0; k < 205; ++k) {\n                    dist[j][k] = graph[j][k];\n                }\n            }\n\n            for (int k = 0; k < 205; ++k) {\n                for (int i = 0; i < 205; ++i) {\n                    for (int j = 0; j < 205; ++j) {\n                        if (dist[i][j] < INF && dist[j][k] < INF) {\n                            dist[i][k] = min(dist[i][k], dist[i][j] + dist[j][k]);\n                        }\n                    }\n                }\n            }\n            if (dist[0][201] != D[x][y]) {\n                cout << IMPOSSIBLE << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << POSSIBLE << endl;\n    int N = 202, M = 200 + 100 * 100;\n    cout << N << \" \" << M << endl;\n    for (int j = 1; j <= 100; ++j) {\n        cout << j << \" \" << (j+1) << \" \" << \"X\" << endl;\n    }\n    for (int j = 1; j <= 100; ++j) {\n        cout << 101+j << \" \" << 101+(j+1) << \" \" << \"Y\" << endl;\n    }\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            cout << (a+1) << \" \" << (202-b) << \" \" << F[a][b] << endl;\n        }\n    }\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 301\nll d[N][N];\nll g[M+10][M+10];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif(x<0||y<0||(g[x+1][201-y]!=-1)||(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t <= a; t++) {\n\t\t\t\tfor (int k = 0; k <= b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * (i) + (k + 1) * (j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=15;\nconst int M=105; \nconst int t=100;\nint m,n,d[N][N],f[M][M],p;\nint read()\n{\tchar x=getchar();\n\twhile(x<48||x>57) x=getchar();\n\tint ans=0;\n\twhile(x>=48&&x<=57)\n\t{\tans=(ans<<1)+(ans<<3)+(x^48);\n\t\tx=getchar();\n\t}\n\treturn ans;\n}\nint main()\n{\tm=read();n=read();\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=n;j++)\n\td[i][j]=read();\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\t{\tp=0x7ffffff;\n\t\tfor(int i=0;i<=t;i++)\n\t\tfor(int j=0;j<=t;j++)\n\t\tp=min(p,i*x+j*y+f[i][j]);\n\t\tif(p!=d[x][y]) {printf(\"Impossible\\n\");return 0;}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(int i=1;i<=t;i++)\n\t{\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+102);\n\t}\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1114));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int edge_count = 200;\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            edge_count += 1;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 201 << \" \" << edge_count << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            if ((201 - yuse) - (xuse + 1) <= 1) {\n                cin >> a;\n                return -1;\n            }\n            cout << xuse + 1 << \" \" << 201 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 201\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1114));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int edge_count = 200;\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            edge_count += 1;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 201 << \" \" << edge_count << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            cout << xuse + 1 << \" \" << 201 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 201\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint A, B;\nint D[11][11];\nint C[101][101];\nint main() {\n\tcin >> A >> B;\n\n\tREP(i, 0, A) {\n\t\tREP(j, 0, B) {\n\t\t\tcin >> D[i + 1][j + 1];\n\t\t}\n\t}\n\n\tREP(x, 0, 101) {\n\t\tREP(y, 0, 101) {\n\t\t\tREP(a, 1, A + 1) {\n\t\t\t\tREP(b, 1, B + 1) {\n\t\t\t\t\tC[x][y] = max(C[x][y], D[a][b] - (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok = 1;\n\tREP(a, 1, A + 1) {\n\t\tREP(b, 1, B + 1) {\n\t\t\tint mn = INF;\n\t\t\tREP(x, 0, 101) {\n\t\t\t\tREP(y, 0, 101) {\n\t\t\t\t\tmn = min(mn, C[x][y] + (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != D[a][b]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (ok ? \"Possible\" : \"Impossible\") << endl;\n\tif (ok) {\n\t\tint X = 100;\n\t\tint Y = 100;\n\t\tcout << X + Y + 1 << ' ' << (X + 1) * (Y + 1) + X + Y - 1 << endl;\n\t\tREP(i, 0, X) {\n\t\t\tcout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n\t\t}\n\t\tREP(i, 0, Y) {\n\t\t\tcout << i + X + 1 << ' ' << i + X + 2 << \" Y\" << endl;\n\t\t}\n\n\t\tint S = X + 1;\n\t\tREP(i, 0, X + 1) {\n\t\t\tREP(j, 0, Y + 1) {\n\t\t\t\tif (i == X && j == Y) continue;\n\t\t\t\tcout << S - (X - i) << ' ' << S + (Y - j) << ' ' << C[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << ' ' << X + Y + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=1e2+10;\nint d[maxn][maxn],f[maxn][maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\nint main(){\n\tint i,j,k,l,m,n;\n\tint a,b;\n\ta=read();b=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\td[i][j]=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tf[k][l]=max(f[k][l],d[i][j]-i*k-j*l);\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++){\n\t\t\tint dis=INF;\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tdis=min(dis,f[k][l]+i*k+j*l);\n\t\t\tif(dis!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tn=202,m=101*101+200;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,m);\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;i++)\n\t\tfor(j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i], ys[i + 1], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, bool());\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, a + 1) REP (j, b + 1) REP (c, 101) {\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1) + c;\n            if (f < d[x][y]) {\n                goto invalid;\n            } else if (f == d[x][y]) {\n                used[x][y] = true;\n            }\n        }\n        int_edge.emplace_back(xs[i], ys[j], c);\ninvalid: ;\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s << ' ' << t << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\nconstexpr int D_MAX = 100;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x_max;\n  int y_max;\n  cin >> x_max >> y_max;\n\n  auto d_matrix = Make2DVector(x_max + 1, y_max + 1, 0);\n  for (int x = 1; x <= x_max; x++) {\n    for (int y = 1; y <= y_max; y++) {\n      cin >> d_matrix[x][y];\n    }\n  }\n\n  auto c_matrix = Make2DVector(D_MAX + 1, D_MAX + 1, 0);\n  for (int a = 0; a <= D_MAX; a++) {\n    for (int b = 0; b <= D_MAX; b++) {\n      for (int x = 1; x <= x_max; x++) {\n        for (int y = 1; y <= y_max; y++) {\n          UpdateMax(c_matrix[a][b], d_matrix[x][y] - a * x - b * y);\n        }\n      }\n    }\n  }\n\n  auto check_fn = [&]() -> bool {\n    for (int x = 1; x <= x_max; x++) {\n      for (int y = 1; y <= y_max; y++) {\n        int d = INT32_MAX;\n        for (int a = 0; a <= D_MAX; a++) {\n          for (int b = 0; b <= D_MAX; b++) {\n            UpdateMin(d, a * x + b * y + c_matrix[a][b]);\n          }\n        }\n        // cout << d << endl;\n        if (d > d_matrix[x][y]) return false;\n      }\n    }\n    return true;\n  };\n\n  if (!check_fn()) {\n    cout << \"Impossible\" << endl;\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 2 * D_MAX + 2 << \" \" << D_MAX + D_MAX + (D_MAX + 1) * (D_MAX + 1) << endl;\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << 1 + i << \" \" << 1 + i + 1 << \" \" << \"X\" << endl;\n  }\n  for (int i = 0; i + 1 <= D_MAX; i++) {\n    cout << D_MAX + 1 + 1 + i << \" \" << D_MAX + 1 + 1 + i + 1 << \" \" << \"Y\" << endl;\n  }\n  for (int a = 0; a <= D_MAX; a++) {\n    for(int b = 0; b <= D_MAX; b++) {\n      cout << 1 + a << \" \" << 2 * D_MAX + 2 - b << \" \" << c_matrix[a][b] << endl;\n    }\n  }\n  cout << 1 << \" \" << 2 * D_MAX + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<pair<int, int>, int> > ans;\nmap<pair<int, int>, int> res;\nint d[15][15];\nint a, b;\n\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++) scanf(\"%d\", d[i]+j);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++)\n\t{\n\t\tbool done = false;\n\t\tint nA = 0, nB = 0, c = 0;\n\t\tfor (;nA*i <= d[i][j];nA++)\n\t\t{\n\t\t\tfor (nB=0;nA*i+nB*j <= d[i][j];nB++)\n\t\t\t{\n\t\t\t\tc = d[i][j]-nA*i-nB*j;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int x = 1;x <= a;x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1;y <= b;y++) if (nA*x+nB*y+c < d[x][y])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ok) break;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (done) break;\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tres[make_pair(nA, nB)] = c;\n\t}\n\tfor (int i = 1;i <= a;i++) ans.emplace_back(make_pair(i-1, i), -1);\n\tfor (int i = 0;i <= a;i++) for (int j = 1;j <= b;j++) ans.emplace_back(make_pair((j-1)*(a+1)+i, j*(a+1)+i), -2);\n\tfor (auto u: res) ans.emplace_back(make_pair(u.first.second*(a+1)+u.first.first, 299), u.second);\n\tprintf(\"Possible\\n300 %ld\\n\", ans.size());\n\tfor (auto u: ans)\n\t{\n\t\tprintf(\"%d %d \", u.first.first+1, u.first.second+1);\n\t\tif (u.second >= 0) printf(\"%d\\n\", u.second);\n\t\telse if (u.second == -1) printf(\"x\\n\");\n\t\telse printf(\"y\\n\");\n\t}\n\tprintf(\"1 300\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<numeric>\n#include<bitset>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define MOD 1000000007\n#define EPS 1e-9\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int A,B;\n    cin >> A >> B;\n    int d[A+1][B+1], f[101][101], dmax = 0;\n    reppp(i, 1, A+1) reppp(j, 1, B+1){\n        cin >> d[i][j];\n        dmax = max(dmax, d[i][j]);\n    }\n\n    repp(a, dmax+1) repp(b, dmax+1){\n        int m = 0;\n        reppp(x, 1, A+1) reppp(y, 1, B+1){\n            m = max(m, d[x][y] - x*a - y*b);\n        }\n        f[a][b] = max(0, m);\n    }\n\n    reppp(x, 1, A+1) reppp(y, 1, B+1){\n        int shortest = INT_MAX;\n        repp(a, dmax+1) repp(b, dmax+1){\n            shortest = min(shortest, x*a + y*b + f[a][b]);\n        }\n        if(d[x][y] != shortest){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    printf(\"%d %d\\n\", (dmax+1)*2, (dmax+1)*(dmax+1) + 2*dmax);\n    reppp(n, 1, dmax+1) printf(\"%d %d %c\\n\", n, n+1, 'X');\n    reppp(n, dmax+2, 2*dmax+2) printf(\"%d %d %c\\n\", n, n+1, 'Y');\n    repp(a, dmax+1) repp(b, dmax+1) printf(\"%d %d %d\\n\", a+1, 2*dmax+2-b, f[a][b]);\n    printf(\"1 %d\\n\", 2*dmax+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define se second\n#define fi first\n#define mk(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pii;\n\nint A,B;\nint D[11][11];\nint mem[110][110];\nvector<pii> G[300];\nint dis[300];\n\nint main()\n{\n    scanf(\"%d%d\",&A,&B);\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            scanf(\"%d\",&D[i][j]);\n        }\n    }\n\n    for(int i = 0; i <= 100; i++)\n    {\n        for(int j = 0; j <= 100; j++)\n        {\n            int res = 0;\n            for(int k = 1; k <= A; k++)\n            {\n                for(int l = 1; l <= B; l++)\n                {\n                    res = max(res,D[k][l] - i * k - j * l);\n                }\n            }\n            if(res > 100)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            mem[i][j] = res;\n        }\n    }\n\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            int MIN = 1001001001;\n            for(int k = 0; k <= 100; k++)\n            {\n                for(int l = 0; l <= 100; l++)\n                {\n                    MIN = min(MIN,k * i + l * j + mem[k][l]);\n                }\n            }\n            if(MIN != D[i][j])\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"202 10401\\n\");\n    for(int i = 0; i < 100; i++)\n    {\n        printf(\"%d %d X\\n\",i + 1,i + 2);\n        printf(\"%d %d Y\\n\",i + 2 + 101,i + 1 + 101);\n    }\n\n    for(int i = 0; i < 101; i++)\n    {\n        for(int j = 0; j < 101; j++)\n        {\n            printf(\"%d %d %d\\n\",i + 1,j + 1 + 101,mem[i][j]);\n        }\n    }\n\n    printf(\"1 102\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10 + 5;\n\nint n, m, d[N][N], f[105][105];\n\nint main() {\n    printf(\"%d\\n\", 101 * 101);\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, 102 + i, 103 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint w[11][11], v[11][11];\nint A, B;\nstruct Edge {\n\tint a, b, c;\n}E[10100];\nint cnt;\nint main() {\n\tint i, j, k, l;\n\tscanf(\"%d%d\", &A, &B);\n\tfor (i = 1; i <= 100; i++) {\n\t\tE[cnt++] = { i,i + 1,-2 };\n\t}\n\tfor (i = 102; i < 202; i++) {\n\t\tE[cnt++] = { i,i + 1,-1 };\n\t}\n\tfor (i = 1; i <= A; i++)for (j = 1; j <= B; j++)scanf(\"%d\", &w[i][j]);\n\tfor (i = 0; i <= 100; i++)for (j = 0; i + j <= 100; j++){\n\t\tint Mx = 0;\n\t\tfor (k = 1; k <= A; k++) {\n\t\t\tfor (l = 1; l <= B; l++) {\n\t\t\t\tMx = max(Mx, w[k][l] - i*k - j*l);\n\t\t\t}\n\t\t}\n\t\tif (Mx < 0)continue;\n\t\tint chk = 0;\n\t\tfor (k = 1; k <= A; k++) {\n\t\t\tfor (l = 1; l <= B; l++) {\n\t\t\t\tif (w[k][l] == i*k + j*l + Mx && !v[k][l])chk = 1, v[k][l] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!chk)continue;\n\t\tE[cnt++] = { i + 1, 202 - j, Mx };\n\t}\n\tfor (i = 1; i <= A; i++)for (j = 1; j <= B; j++)if (!v[i][j]) {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 202, cnt);\n\tfor (i = 0; i < cnt; i++) {\n\t\tprintf(\"%d %d \", E[i].a, E[i].b);\n\t\tif (E[i].c < 0)printf(\"%c\\n\", E[i].c + 'Z');\n\t\telse printf(\"%d\\n\", E[i].c);\n\t}\n\tprintf(\"%d %d\\n\", 1, 202);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 110;\n\nint n, m, d[N][N], f[N][N], dd[N][N];\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, n) FOR(j, 1, m) scanf(\"%d\", &d[i][j]);\n    FOR(i, 0, 100) FOR(j, 0, 100) FOR(ii, 1, n) FOR(jj, 1, m)\n        f[i][j] = max(f[i][j], d[ii][jj] - i * ii - j * jj);\n    FOR(ii, 1, n) FOR(jj, 1, m)\n    {\n        dd[ii][jj] = 1e9;\n        FOR(i, 0, 100) FOR(j, 0, 100)\n            dd[ii][jj] = min(dd[ii][jj], i * ii + j * jj + f[i][j]);\n        if (dd[ii][jj] != d[ii][jj]) {puts(\"Impossible\"); return 0;}\n    }\n    puts(\"Possible\"); puts(\"202 10201\");\n    FOR(i, 0, 100) FOR(j, 0, 100) printf(\"%d %d %d\\n\", i + 1, j + 102);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint A,B,tot,d[15][15];\nbool mp[205][205];\nstruct edge{int i,j,x;};\nedge tg[15][15],e[23333];\nint main(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor (int i=1;i<=A;i++)\n\t\tfor (int j=1;j<=B;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\ttg[i][j].i=-1;\n\t\t}\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int x=0;x<=100;x++){\n\t\t\t\tbool fl=0;\n\t\t\t\tfor (int k=1;k<=A&&!fl;k++)\n\t\t\t\t\tfor (int l=1;l<=B&&!fl;l++)\n\t\t\t\t\t\tif (i*k+j*l+x<d[k][l])\n\t\t\t\t\t\t\tfl=1;\n\t\t\t\tif (fl) continue;\n\t\t\t\tfor (int k=1;k<=A&&!fl;k++)\n\t\t\t\t\tfor (int l=1;l<=B&&!fl;l++)\n\t\t\t\t\t\tif (i*k+j*l+x==d[k][l])\n\t\t\t\t\t\t\ttg[k][l]=(edge){i,j,x};\n\t\t\t}\n\tfor (int i=1;i<=100;i++)\n\t\te[++tot]=(edge){i,i+1,-1};\n\tfor (int i=102;i<=201;i++)\n\t\te[++tot]=(edge){i,i+1,-2};\n\tfor (int i=1;i<=A;i++)\n\t\tfor (int j=1;j<=B;j++){\n\t\t\tif (tg[i][j].i==-1){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!mp[tg[i][j].i][tg[i][j].j])\n\t\t\t\te[++tot]=(edge){1+tg[i][j].i,202-tg[i][j].j,tg[i][j].x};\n\t\t\tmp[tg[i][j].i][tg[i][j].j]=1;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,tot);\n\tfor (int i=1;i<=tot;i++){\n\t\tprintf(\"%d %d \",e[i].i,e[i].j);\n\t\tif (e[i].x==-1) printf(\"X\\n\");\n\t\telse if (e[i].x==-2) printf(\"Y\\n\");\n\t\telse printf(\"%d\\n\",e[i].x);\n\t}\n\tprintf(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[55];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 55; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  //cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 10;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = -1;\n\t\tbool finish = false;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tif (finish) break;\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0 || tse > 100) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  dx = tdx, dy = tdy, se = tse;\n\t\t\t  finish = true;\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (!finish) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\tputs(\"Possible\");\n\n\t\tset<pair<int,pint> > S;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (auto e : G[i]) {\n\t\t\tS.insert(make_pair(i, e));\n\t\t  }\n\t\t}\n\t\t\n\t\tcout << G.size() << \" \" << S.size() << endl;\n\t\tfor (set<pair<int,pint> >::iterator it = S.begin(); it != S.end(); ++it) {\n\t\t  int from = (*it).first;\n\t\t  int to = (*it).second.first;\n\t\t  int w = (*it).second.second;\n\t\t  cout << from+1 << \" \" << to+1 << \" \";\n\t\t  if (w == -1) cout << \"X\";\n\t\t  else if (w == -2) cout << \"Y\";\n\t\t  else cout << w;\n\t\t  cout << endl;\n\t\t}\n\t\tcout << s+1 << \" \" << t+1 << endl;\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int a, b; cin>>a>>b;\n  int d[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      cin>>d[i][j];\n    }\n  }\n  int p[2][11][11], q[2][11][11];\n\tfor(int i=1; i<=a; i++){\n      for(int j=1; j<=b; j++){\n        p[0][i][j]=0, p[1][i][j]=1000;\n        q[0][i][j]=0, q[1][i][j]=1000;\n      }\n    }\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      for(int k=1; i-k>0; k++){\n        p[1][i][j]=min(p[1][i][j], (d[i][j]-d[i-k][j])/k);\n      }\n      for(int k=1; i+k<=a; k++){\n        p[0][i][j]=max(p[0][i][j], (d[i+k][j]-d[i][j]+k-1)/k);\n      }\n      for(int k=1; j-k>0; k++){\n        q[1][i][j]=min(q[1][i][j], (d[i][j]-d[i][j-k])/k);\n      }\n      for(int k=1; j+k<=b; k++){\n        q[0][i][j]=max(q[0][i][j], (d[i][j+k]-d[i][j]+k-1)/k);\n      }\n    }\n  }\n  int r[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      if(p[1][i][j]<0 || p[0][i][j]>p[1][i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      if(q[1][i][j]<0 || q[0][i][j]>q[1][i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      if(p[0][i][j]*i+q[0][i][j]*j>d[i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      r[i][j]=d[i][j]-(p[0][i][j]*i+q[0][i][j]*j);\n    }\n  }\n  int n=202;\n  int s=1, t=n;\n  vector<P> g[205];\n  set<P> st;\n  int m=0;\n  for(int i=1; i<=n/2-1; i++){\n    g[i].push_back(P(i+1, -1)); m++;\n  }\n  for(int i=n/2+1; i<=n-1; i++){\n    g[i].push_back(P(i+1, -2)); m++;\n  }\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      if(st.find(P(1+p[0][i][j], n-q[0][i][j]))!=st.end()) continue;\n      st.insert(P(1+p[0][i][j], n-q[0][i][j]));\n      g[1+p[0][i][j]].push_back(P(n-q[0][i][j], r[i][j])); m++;\n    }\n  }\n  cout<<n<<\" \"<<m<<endl;\n  for(int i=1; i<=n; i++){\n    for(auto e:g[i]){\n      cout<<i<<\" \"<<e.first<<\" \";\n      if(e.second==-1) cout<<\"X\"<<endl;\n      else if(e.second==-2) cout<<\"Y\"<<endl;\n      else cout<<e.second<<endl;\n    }\n  }\n  cout<<1<<\" \"<<n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\t// freopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N*2+2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<=N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+2;i<(N+1)*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,(N+1)*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    constexpr int max_c = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i + 1], ys[i], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, false);\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, max_d + 1) REP (j, max_d + 1) if (i + j <= max_d) {\n        int c = 0;\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1);\n            chmax(c, d[x][y] - f);\n        }\n        if (c > max_c) continue;\n        int_edge.emplace_back(xs[i], ys[j], c);\n        REP (x, a) REP (y, b) {\n            int f = i * (x + 1) + j * (y + 1);\n            assert (d[x][y] <= f + c);\n            if (f + c == d[x][y]) {\n                used[x][y] = true;\n            }\n        }\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) + 1 << ' ' << get<1>(e) + 1 << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) + 1 << ' ' << get<1>(e) + 1 << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s + 1 << ' ' << t + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    set<P> s;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void add(ll from, ll to, string label) {\n        if (s.count({from, to}) > 0) return;\n        s.insert({from, to});\n        edges.pb({from, to, label});\n    }\n    void addX(ll from, ll to) {\n        add(from, to, \"X\");\n    }\n    void addY(ll from, ll to) {\n        add(from, to, \"Y\");\n    }\n    void add(ll from, ll to, ll cost) {\n        add(from, to, to_string(cost));\n    }\n    void output(ll s, ll t) {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << s+1 << \" \" << t+1 << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * (a+1) + y * (b+1));\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if ((aa+1) * x + (bb+1) * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    // ll w = mx(X)+1;\n    // ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<ll> xid(101), yid(101);\n    rep(i, 101) xid[i] = V++;\n    rep(i, 101) yid[i] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    G.add(s, xid[0], 0);\n    rep(i, 100) G.addX(xid[i], xid[i+1]);\n    rep(i, 100) G.addY(yid[i+1], yid[i]);\n    G.add(yid[0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(xid[X[a][b]], yid[Y[a][b]], Z[a][b]);\n    }\n    G.output(s, t);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200 + 5;\n\nint n, m, d[N][N], f[N][N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, 103 + i, 102 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 102 + j, f[i][j]);\n    puts(\"1 102\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXSIZE=10000020;\nint bufpos;\nchar buf[MAXSIZE];\n#define NEG 0\nvoid init(){\n    #ifdef LOCAL\n        freopen(\"E.txt\",\"r\",stdin);\n    #endif\n    buf[fread(buf,1,MAXSIZE,stdin)]='\\0';\n    bufpos=0;\n}\n#if NEG\nint readint(){\n    bool isneg;\n    int val=0;\n    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);\n    bufpos+=(isneg=buf[bufpos]=='-');\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return isneg?-val:val;\n}\n#else\nint readint(){\n    int val=0;\n    for(;!isdigit(buf[bufpos]);bufpos++);\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return val;\n}\n#endif\nchar readchar(){\n    for(;isspace(buf[bufpos]);bufpos++);\n    return buf[bufpos++];\n}\nint readstr(char* s){\n    int cur=0;\n    for(;isspace(buf[bufpos]);bufpos++);\n    for(;!isspace(buf[bufpos]);bufpos++)\n        s[cur++]=buf[bufpos];\n    s[cur]='\\0';\n    return cur;\n}\nint d[13][13];\nstruct edge{\n    int x,y,z;\n}e[2333];\nbool vis[103][103];\nint main(){\n    init();\n    int a=readint(),b=readint(),cur=0;\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            d[i][j]=readint();\n    // memset(vis,-1,sizeof(vis));\n    for(int i=0;i<=100;i++)\n        for(int j=0;j<=100;j++)\n            for(int k=0;k<=100;k++){\n                bool flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++){\n                        if (i*o+j*t+k<d[o][t]){\n                            flag=1;\n                            goto hell;\n                        }\n                    }\n                hell:;\n                if (flag)\n                    continue;\n                flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++)\n                        if (!vis[o][t] && i*o+j*t+k==d[o][t])\n                            vis[o][t]=flag=1;\n                if (flag)\n                    e[++cur]=(edge){i,j,k};\n            }\n    // puts(\"WTF\");\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            if (!vis[i][j])\n                return puts(\"Impossible\"),0;\n    puts(\"Possible\");\n    printf(\"%d %d\\n\",202,cur+100);\n    for(int i=0;i<100;i++)\n        printf(\"%d %d X\\n\",i+1,i+2);\n    for(int j=1;j<=100;j++)\n        printf(\"%d %d Y\\n\",j+102,j+101);\n    for(int i=1;i<=cur;i++)\n        printf(\"%d %d %d\\n\",e[i].x+1,e[i].y+101,e[i].z);\n    puts(\"1 102\");\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m, A, B, d[200][200];\nint used[200][200];\nvector<pair<int, int> > ed[2000];\nvoid add(int x, int y, int z) {\n    ed[x].push_back(make_pair(y, z));\n    m++;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> A >> B;\n    for (int i = 1; i <= A; i++)\n    for (int j = 1; j <= B; j++) cin >> d[i][j];\n    for (int i = 1; i < 99; i++) add(i, i + 1, -1);\n    for (int i = 101; i < 200; i++) add(i + 1, i, -2);\n    int cnt = 200;\n    for (int c1 = 0; c1 < 100; c1++)\n    for (int c2 = 0; c2 < 100; c2++)\n    for (int c3 = 0; c3 <= 100; c3++) {\n        if (c1 + c2 + c3 > 100) break;\n        bool bd = 0; vector<pair<int, int> > lst;\n        for (int i = 1; i <= A; i++) {\n            for (int j = 1; j <= B; j++)\n            if (i * c1 + j * c2 + c3 < d[i][j]) {\n                bd = 1;\n                break;\n            }\n            else\n            if (i * c1 + j * c2 + c3 == d[i][j] && used[i][j] == 0) lst.push_back(make_pair(i, j));\n            if (bd == 1) break;\n        }\n        if (bd) continue;\n        if (lst.size() != 0) {\n            cnt++;\n            add(c1 + 1, cnt, c3);\n            add(cnt, c2 + 101, 0);\n            for (int i = 0; i < lst.size(); i++) used[lst[i].first][lst[i].second] = 1;\n        }\n    }\n    for (int i = 1; i <= A; i++)\n    for (int j = 1; j <= B; j++)\n    if (used[i][j] == 0) {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    cout << \"Possible\\n\";\n    cout << cnt << \" \" << m << \"\\n\";\n    for (int i = 1; i <= cnt; i++) {\n        for (int j = 0; j < ed[i].size(); j++) {\n            int to = ed[i][j].first;\n            int cs = ed[i][j].second;\n            cout << i << \" \" << to << \" \";\n            if (cs >= 0) cout << cs << \"\\n\";\n            else\n            if (cs == -1) cout << \"X\\n\";\n            else cout << \"Y\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nvoid chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nvoid chkmin(int &x,int y){\n\tx=x<y?x:y;\n}\nint d[11][11];\nstruct edge{\n\tint s,t,v;\n}w[100100];\nint num;\nvoid Addedge(int s,int t,int v){\n\tw[++num]=(edge){s,t,v};\n}\nint n,m;\nint a[101][101];\nbool checkans(){\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint mn=INF;\n\t\t\tfor(int p=0;p<=100;p++)\n\t\t\t\tfor(int q=0;q<=100;q++)\n\t\t\t\t\tchkmin(mn,p*i+q*j+a[p][q]);\n\t\t\tif(mn!=d[i][j]) return 0;\n\t\t}\n\treturn 1;\n}\nint main(){\n//\tfreopen(\"A.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tint S=1,T=202;\n\tfor(int i=1;i<=100;i++)\n\t\tAddedge(i,i+1,-1);\n\tfor(int i=102;i<=T;i++)\n\t\tAddedge(i,i+1,-2);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int p=1;p<=10;p++)\n\t\t\t\tfor(int q=1;q<=10;q++)\n\t\t\t\t\tchkmax(a[i][j],d[p][q]-p*i-q*j);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tAddedge(i+1,T-j,a[i][j]);\n\tif(!checkans())\n\t\tprintf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"%d %d\\n\",T,num);\n\t\tfor(int i=1;i<=num;i++)\n\t\t\tprintf(\"%d %d %d\\n\",w[i].s,w[i].t,w[i].v);\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>\t\t//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>\t\t//do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n#define ALL(u) (u).begin(),(u).end()\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\ntypedef pair<int, int> PII;\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\n\nconst int MT = 20;\nconst int MR = 300;\n\nint d[MT][MT];\n\nint main()\n{\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tREP(i, A)REP(j, B)\n\t\tscanf(\"%d\", &d[i][j]);\n\n\tvector<PII> cand[2];\n\tREP(i, 2)FORQ(V, 1, MR - 2)FORQ(vV, -V + 1, 110 - V)\n\t\tcand[i].push_back(MP(V, vV));\n\n\tvector<bitset<100>> mask[2];\n\tvector<bool> ok[2];\n\tREP(cnt, 2)\n\t{\n\t\tREP(i, cand[cnt].size())\n\t\t{\n\t\t\tconst auto p = cand[cnt][i];\n\t\t\tbitset<100> tmp = 0;\n\t\t\tok[cnt].push_back(1);\n\t\t\tREP(x, A)\n\t\t\t{\n\n\t\t\t\tREP(y, B)\n\t\t\t\t{\n\t\t\t\t\tint v;\n\t\t\t\t\tif (!cnt)\n\t\t\t\t\t\tv = p.first*(x + 1) + p.second;\n\t\t\t\t\telse\n\t\t\t\t\t\tv = p.first*(y + 1) + p.second;\n\n\t\t\t\t\tif (v < d[x][y])\n\t\t\t\t\t{\n\t\t\t\t\t\tok[cnt][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (v == d[x][y])\n\t\t\t\t\t\ttmp[x*B + y] = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!ok[cnt][i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmask[cnt].push_back(tmp);\n\t\t}\n\t}\n\n\tbitset<100> full = 0;\n\tREP(i, A*B)\n\t\tfull[i] = 1;\n\tREP(i,mask[0].size())REP(j,mask[1].size())\n\t\tif (ok[0][i] && ok[1][j] && (mask[0][i] | mask[1][j]) == full && cand[0][i].first + cand[1][j].first + 1 < MR)\n\t\t{\n\t\t\tprintf(\"Possible\\n\");\n\t\t\tint N = cand[0][i].first + cand[1][j].first + 2;\n\t\t\tprintf(\"%d %d\\n\", N, N);\n\t\t\tREP(i, cand[0][i].first)\n\t\t\t\tprintf(\"%d %d X\\n\", i + 1, i + 2);\n\t\t\tprintf(\"1 %d Y\\n\", 2 + cand[0][i].first);\n\t\t\tFOR(i, 1, cand[1][j].first)\n\t\t\t\tprintf(\"%d %d Y\\n\", i + 1 + cand[0][i].first, i + 2 + cand[0][i].first);\n\n\t\t\tprintf(\"%d %d %d\\n\", cand[0][i].first + 1, N, cand[0][i].second);\n\t\t\tprintf(\"%d %d %d\\n\", cand[0][i].first + cand[1][j].first + 1, N, cand[1][j].second);\n\n\t\t\tprintf(\"1 %d\\n\", N);\n\n\t\t\treturn 0;\n\t\t}\n\n\tprintf(\"Impossible\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A, B, N, M, S, T, d[15][15];\nint adj[102][102];\nint dist[204];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i){\n\t\tfor (int j = 1; j <= B; ++j){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tS = 1;\n\tT = 202;\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 1; k <= A; ++k){\n\t\t\t\tfor (int l = 1; l <= B; ++l){\n\t\t\t\t\tmaxi = max(maxi,d[k][l]-k*i-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj[i][j] = maxi;\n\t\t\tif (maxi > 100){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 1; k <= A; ++k){\n\t\tfor (int l = 1; l <= B; ++l){\n\t\t\tdist[1] = 0;\n\t\t\tfor (int i = 1; i <= 100; ++i){\n\t\t\t\tdist[i+1] = dist[i] + k;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 100; ++i){\n\t\t\t\tint mini = 1e9;\n\t\t\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\t\t\tmini = min(mini,adj[j][100-i]+dist[j+1]);\n\t\t\t\t}\n\t\t\t\tif (i > 0){\n\t\t\t\t\tmini = min(mini,dist[102+i-1]+l);\n\t\t\t\t}\n\t\t\t\tdist[102+i] = mini;\n\t\t\t}\n\t\t\t//cout << dist[202] << ' ';\n\t\t\tif (dist[202] != d[k][l]){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t//cout << '\\n';\n\t}\n\tN = 202;\n\tM = 100+100+(101*101);\n\tcout << \"Possible\\n\";\n\tfor (int i = 1; i <= 100; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 102; i <= 201; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tcout << i+1 << ' ' << j+102 << ' ' << adj[i][100-j] << '\\n';\n\t\t}\n\t}\n\tcout << S << ' ' << T << '\\n';\n\tcout << flush;\n\t//for (int i = 1; i < 1e9; ++i){for (int j = 0; j < 1e9; ++j){}}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n\n\nusing namespace std;\n\nint d[15][15];\nint N;\nint g[305][305];\nVI vy, vx;\n\nint check[15][15];\n\nint main () {\n\tmake2(A, B);\n\tFOR(i,0,A) FOR(j,0,B) {\n\t\tmake(x); d[i+1][j+1] = x;\n\t}\n\tvector<pair<PII, int > > v;\n\tFOR(a,0,101) FOR(b,0,101) {\n\t\tint c = -1000;\n\t\tFOR(x,1,A+1) FOR(y,1,B+1) {\n\t\t\tc = max(c, d[x][y]-a*x-b*y);\n\t\t}\n\t\tif (c < 0) continue;\n\t\tv.pb(mp(mp(a,b),c));\n\t}\n\tN = 2;\n\tFOR(i,0,305) FOR(j,0,305) g[i][j] = -3;\n\tint maxa = 0;\n\tint maxb = 0;\n\tFORE(i, v) maxa = max(maxa, i->st.st);\n\tFORE(i, v) maxb = max(maxb, i->st.nd);\n\tint S = 0; vx.pb(S);\n\tint T = 1; vy.pb(T);\n\tint act = 2;\n\tFOR(i,0,maxa) {\n\t\tg[vx.back()][act] = -1;\n\t\tvx.pb(act); \n\t\tact++;\n\t}\n\tFOR(i,0,maxb) {\n\t\tg[act][vy.back()] = -2;\n\t\tvy.pb(act); \n\t\tact++;\n\t}\n\tbool ok = true;\n\tFORE(i,v) {\n\t\tint a = i->st.st;\n\t\tint b = i->st.nd;\n\t\tint c = i->nd;\n\t\tg[vx[a]][vy[b]] = c;\n\t\tFOR(ii,1,A+1) FOR(jj,1,B+1) {\n\t\t\tif (ii*a +jj*b + c == d[ii][jj]) check[ii][jj] = 1; \n\t\t\tif (ii*a +jj*b + c < d[ii][jj]) ok = false;\n\t\t}\n\t}\n\tFOR(i,1,A+1) FOR(j,1,B+1) {\n\t\tif (check[i][j] != 1 || !ok) {\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tint m = 0;\n\tFOR(i,0,act) FOR(j,0,act) {\n\t\tif (g[i][j] != -3) m++;\n\t}\n\tprintf(\"%d %d\\n\", act, m);\n\tFOR(i,0,act) FOR(j,0,act) {\n\t\tif (g[i][j] == -1) {\n\t\t\tprintf(\"%d %d X\\n\", i+1, j+1);\n\t\t}\n\t\telse if (g[i][j] == -2) {\n\t\t\tprintf(\"%d %d Y\\n\", i+1, j+1);\n\t\t} else if (g[i][j] >= 0) {\n\t\t\tprintf(\"%d %d %d\\n\", i+1, j+1, g[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 2\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b;\nvector<vector<int> > d;\n\nint saitan(vector<vector<pair<int, int> > > edges)\n{\n    vector<int> dist_tmp(202, 101);\n    dist_tmp[0] = 0;\n\n    for (int i=0; i<201; i++)\n    {\n        for (auto to : edges[i])\n        {\n            dist_tmp[to.first] = min(dist_tmp[to.first], dist_tmp[i] + to.second);\n        }\n    }\n    return dist_tmp[201];\n}\n\nint main()\n{\n    cin >> a >> b;\n    d = vector<vector<int> >(a, vector<int>(b, 0));\n\n    for (int i=0; i<a; i++) for (int j=0; j<b; j++) cin >> d[i][j];\n\n    vector<vector<int> > length(101, vector<int>(101, 0));\n    for (int ii=0; ii<a; ii++)\n        for (int jj=0; jj<b; jj++)\n            for (int i=0; i<=100; i++)\n                for (int j=0; j<=100; j++)\n                    length[i][j] = max(length[i][j], d[ii][jj] - i * (ii+1) - j * (jj+1));\n\n    vector<vector<pair<int, int> > > edge(201);\n    for (int i=0; i<=100; i++)\n    {\n        for (int j=0; j<=100; j++)\n        {\n            edge[i].push_back(make_pair(201-j, length[i][j]));\n        }\n    }\n\n    for (int x=1; x<=a; x++)\n    {\n        for (int y=1; y<=b; y++)\n        {\n            vector<vector<pair<int, int> > > edge_copy = edge;\n            for (int i=0; i<100; i++)\n            {\n                edge_copy[i].push_back(make_pair(i+1, x));\n                edge_copy[101+i].push_back(make_pair(i+102, y));\n            }\n            if (saitan(edge_copy) != d[x-1][y-1])\n            {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n\n    cout << \"202 10401\" << endl;\n    for (int i=1; i<=100; i++)\n    {\n        cout << i << \" \" << i+1 << \" X\" << endl;\n        cout << i+101 << \" \" << i+102 << \" Y\" << endl;\n    }\n    for (int i=0; i<=100; i++)\n    {\n        for (int j=0; j<=100; j++)\n        {\n            cout << i+1 << \" \" << 202-j << \" \" << length[i][j] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        cout << \"Possible\" << endl;\n        cout << n << \" \" << edges.size() << endl;\n        each(e, edges) {\n            cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            assert(false);\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+(ans[i].c!=0);\n\t\tnumn+=ans[i].a+ans[i].b+(ans[i].c!=0)-1;\n\t}\n\tnumn+=2;\n\t//if (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tif (ans[i].c) printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'X'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\t{\n\t\t\t\t\tint c=s-a-b;\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define MN 100\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0; char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct edge{\n\tint fr,to,val;\n}e[(MN*MN<<1)+5];\nint d[13][13],a,b,cnt;\nbool vis[13][13];\nint main()\n{\n\ta=in();b=in();\n\tfor (int i=1;i<=a;++i)\n\tfor (int j=1;j<=b;++j) d[i][j]=in();\n\tfor (int i=0;i<=MN;++i)\n\tfor (int j=0;j<=MN;++j){\n\t\tint mx=0;\n\t\tfor (int k=1;k<=a;++k)\n\t\tfor (int l=1;l<=b;++l) mx=max(mx,d[k][l]-i*k-j*l);\n\t\te[++cnt].fr=i+1;e[cnt].to=((MN+1)<<1)-j;e[cnt].val=mx;\n\t\tfor (int k=1;k<=a;++k)\n\t\tfor (int l=1;l<=b;++l)\n\t\tif (d[k][l]==mx+i*k+j*l) vis[k][l]=1;\n\t}\n\tfor (int i=1;i<=a;++i)\n\tfor (int j=1;j<=b;++j)\n\tif (!vis[i][j]) {puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");printf(\"202 %d\\n\",cnt+(MN<<1));\n\tfor (int i=1;i<=MN;++i) printf(\"%d %d X\\n%d %d Y\\n\",i,i+1,i+MN+1,i+MN+2);\n\tfor (int i=1;i<=cnt;++i) printf(\"%d %d %d\\n\",e[i].fr,e[i].to,e[i].val); \n\tputs(\"1 202\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <limits>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\nconstexpr int INF = std::numeric_limits<int>::max()>>2;\n\nint A, B;\nint d[10][10];\nint c[100][100];\n\nint main()\n{\n  scanf( \"%d%d\", &A, &B );\n  rep( i, A ) rep( j, B )\n    scanf( \"%d\", &d[i][j] );\n\n  rep( i, 101 ) rep( j, 101 )\n  {\n    rep( a, A ) rep( b, B )\n      c[i][j] = std::max( c[i][j], d[a][b]-i*a-j*b );\n  }\n\n  bool fl = true;\n  rep( a, A ) rep( b, B )\n  {\n    int D = INF;\n    rep( i, 101 ) rep( j, 101 )\n      D = std::min( D, i*a+j*b+c[i][j] );\n    \n    fl &= D == d[a][b];\n  }\n\n  if( !fl )\n    puts( \"Impossible\" );\n  else\n  {\n    puts( \"Possible\" );\n  \n    printf( \"%d %d\\n\", 202, 101*101+202 );\n\n    rep( i, 101 )\n      printf( \"%d %d X\\n\", i+1, i+2 );\n    rep( i, 101 )\n      printf( \"%d %d Y\\n\", i+102, i+103 );  \n    rep( i, 101 ) rep( j, 101 )\n      printf( \"%d %d %d\\n\", i+1, 202-j, c[i][j] );\n    printf( \"%d %d\\n\", 1, 202 );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edge{\n    int a,b,c;\n}ans[310];\nint numn,numm;\nvoid print(){\n    for(int i=1;i<=sum;i++){\n        numm+=ans[i].a+ans[i].b+1;\n        numn+=ans[i].a+ans[i].b;\n    }\n    numn+=2;\n    /*if (numn>300){\n        puts(\"Impossible\");\n        return ;\n    }*/\n    puts(\"Possible\");\n    //printf(\"Possible\\n\");\n    printf(\"%d %d\\n\",numn,numm);\n    int t=1,pre=1;\n    for (int i=1;i<=sum;i++){\n        pre=1;\n        printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n        for (int j=1;j<=ans[i].a;j++){\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].a&&ans[i].b==0)?numn:++t,'X'),pre=t;\n        }\n        for (int j=1;j<=ans[i].b;j++)\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\n    }\n    printf(\"%d %d\\n\",1,numn);\n}\n\nint a,b,c;\nbool p,q;\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&d[i][j]);\n    for(int s=0;s<=300;s++)\n        for(a=0;a<=s&&a<=100;a++)\n            for(b=0;b<=s-a&&b<=100;b++){\n                    c=s-a-b;\n                    p=false;\n                    q=false;\n                    int now=0;\n                    for(int i=1;i<=n;i++){\n                        for(int j=1;j<=m;j++){\n                            if(a*i+b*j+c==d[i][j]&&!vis[i][j]){\n                                q=true;\n                                pa[++now]=i;\n                                pb[now]=j;\n                            }\n                            else{\n                                if(a*i+b*j+c<d[i][j]){\n                                    p=true;\n                                    break;\n                                }\n                            }\n                        }\n                        if(p==1) break;\n                    }\n                    if((!p)&&q){\n                        for(int i=1;i<=now;i++)\n                            vis[pa[i]][pb[i]]=1;\n                        tot+=now;\n                        ans[++sum]=(edge){a,b,c};\n                        if(tot==n*m){\n                            print();\n                            return 0;\n                        }\n                    }\n                }\n    puts(\"Impossible\");\n    //printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[N], Y[N], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 100, yy = 100;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = 0;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      if (ans < 0 || ans > 100) continue;\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", cnt, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 303, M = 100;\nint a, b, d[14][14], C[M+3][M+3], sz = 1;\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int as = 0; as <= M; as++) {\n\t\tfor(int bs = 0; bs <= M; bs++) {\n\t\t\tint mn = 0;\n\t\t\tfor(int i =1; i <= a; i++)\n\t\t\t\tfor(int j = 1; j <= b; j++)\n\t\t\t\t\tmn = max(mn, d[i][j] - as*i - bs*j);\n\t\t\tC[as][bs] = mn;\n\t\t}\n\t}\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++) {\n\t\t\tint cst = 1<<30;\n\t\t\tfor(int as = 0; as <= M; as++)\n\t\t\t\tfor(int bs = 0; bs <= M; bs++)\n\t\t\t\t\tcst = min(cst, as*i + bs*j + C[as][bs]);\n\t\t\tif(cst != d[i][j]) return cout << \"Impossible\\n\", 0;\n\t\t}\n\t\n\tcout << \"Possible\\n\";\n\tcout << 2*M+2 << \" \" << (M+1)*(M+1) + 2*M << '\\n';\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" X\\n\", sz++;\n\tsz++;\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" Y\\n\", sz++;\n\tfor(int i = 0; i <= M; i++)\n\t\tfor(int j = 0; j <= M; j++)\n\t\t\tcout << 1+i << \" \" << M+2+j << \" \" << C[i][j] << '\\n';\n\tcout << 1 << \" \" << 2*M+2 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int MAX = 100;\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > d(n+1, vector<int>(m+1));\n    for(int x=1; x<=n; ++x){\n        for(int y=1; y<=m; ++y){\n            cin >> d[x][y];\n        }\n    }\n\n    int size = 2 * MAX + 2;\n    vector<tuple<int, int, int>> ans;\n    for(int i=0; i<MAX; ++i){\n        ans.push_back(make_tuple(i, i+1, -1));\n        ans.push_back(make_tuple(size-2, size-1, -2));\n    }\n\n    vector<vector<bool> > check(n+1, vector<bool>(m+1, false));\n    int cnt = n * m;\n    for(int a=0; a<=MAX; ++a){\n        for(int b=0; b<=MAX; ++b){\n            int c = 0;\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    c = max(c, tmp);\n                }\n            }\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    if(tmp == c && !check[x][y]){\n                        check[x][y] = true;\n                        -- cnt;\n                    }\n                }\n            }\n            if(c <= MAX)\n                ans.push_back(make_tuple(a, 2*MAX+1-b, c));\n        }\n    }\n\n    if(cnt == 0){\n        cout << \"Possible\" << endl;\n        cout << size << ' ' << ans.size() << endl;\n        for(const auto& t : ans){\n            int a, b, c;\n            tie(a, b, c) = t;\n            ++ a;\n            ++ b;\n            cout << a << ' ' << b << ' ';\n            if(c == -1)\n                cout << 'X' << endl;\n            else if(c == -2)\n                cout << 'Y' << endl;\n            else\n                cout << c << endl;\n        }\n        cout << 1 << ' ' << size << endl;\n    }\n    else{\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\n\nint d[16][16] = {};\nbool pass[16][16] = {};\n\n\nint stu[12345][3];\n\nint main() {\n\tint A, B;\n\tcin >> A >> B;\n\n\trep(i, A)rep(j, B) {\n\t\tcin >> d[i][j];\n\t}\n\n\tint stuN = 0;\n\n\trep(s, 100)rep(t, 100) {\n\t\tint u = 0;\n\t\trep(i, A)rep(j, B) {\n\t\t\tint x = i + 1;\n\t\t\tint y = j + 1;\n\t\t\tu = max(u, d[i][j] - s*x - t*y);\n\t\t}\n\t\tbool f = true;\n\t\t\n\t\tif ([&]() {\n\t\t\tbool f = false;\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u < d[i][j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}()) {\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tpass[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstu[stuN][0] = s;\n\t\t\tstu[stuN][1] = t;\n\t\t\tstu[stuN][2] = u;\n\t\t\tstuN++;\n\t\t\t//cout << s << \"x + \" << t << \"y + \"<<u << endl;\n\t\t}\n\t}\n\trep(i, A)rep(j, B) {\n\t\tif (!pass[i][j]) {\n\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\n\tint E = A*B+1;\n\n\tcout << A*B+1 << \" \" << A*(B - 1) + (A - 1)*B + stuN << endl;\n\n\trep(i, A) {\n\t\trep(j, B - 1) {\n\t\t\tcout << i*B + j + 1 << \" \" << i*B + j + 2 << \" Y\\n\";\n\t\t}\n\t}\n\trep(i, A - 1) {\n\t\trep(j, B) {\n\t\t\tcout << i*B + j + 1 << \" \" << (i+1)*B + j + 1 << \" X\\n\";\n\t\t}\n\t}\n\n\n\n\trep(k, stuN) {\n\t\t//cout << stu[i][0] << \"x + \" << stu[i][1] << \"y + \"<< stu[i][2] << endl;\n\t\tint i = stu[k][1];\n\t\tint j = stu[k][0];\n\t\tint c = stu[k][2];\n\t\tcout << i*B + j + 1 << \" \" << E << \" \"<<c << endl;\n\t}\n\n\tcout << \"1 \" << E << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*i);\n\tchmax(D[k],d[i][j]-(k+1)*j);\n      }\n    }\n  }\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i<<\" \"<<j<<\":\"<<dist<<\":\"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[200][200];\nint a,b,c[200][200],flag[200][200],fff[200][200],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t\tii=i;jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<200+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nint main(void){\n  int n = 100;\n  int a, b;\n  int f = 1;\n  cin >> a >> b;\n  vector<vi> d(a, vi(b));\n  vector<vi> finished(a, vi(b, 0));\n  REP(i, a) REP(j, b) cin >> d[i][j];\n  vector<vector<pii> > g(2 * n + 2);\n  REP(i, n+1) {\n    REP(j, n+1) {\n      int min_cost = 0;\n      REP(k, a) {\n        REP(l, b) {\n          int x = k * i + l * j;\n          int y = x - d[k][l];\n          if(y < 0) min_cost = max(min_cost, -y);\n        }\n      }\n      g[i].push_back(pii(n + j, min_cost));\n      REP(k, a) {\n        REP(l, b){\n          if(k * i + l * j + min_cost == d[k][l]) finished[k][l] = 1;\n        }\n      }\n    }\n  }\n  REP(i, a) REP(j, b) if(!finished[i][j]) f = 0;\n\n  if(!f) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  int m = 2 * n + 1;\n  REP(i, g.size()) m += g[i].size();\n  cout << \"202 \" << m << endl;\n  cout << \"101 1 0\" << endl;\n  cout << \"200 202 0\" << endl;\n  REP(i, 100) {\n    cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n    cout << i + n + 1 << \" \" << i + n + 2 << \" Y\" << endl;\n  }\n  REP(i, g.size()) {\n    REP(j, g[i].size()) {\n      cout << i + 1 << \" \" << g[i][j].first + 1 << \" \" << g[i][j].second << endl;\n    }\n  }\n  cout << \"201 202\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> II;\n#define fi first\n#define se second\n\nconst int N = 550;\n\nint A, B;\nint n, S, T;\nint nx[N][N], ny[N][N];\nint a[N][N];\n\nbool check(int x, int y, int ni, int nj) {\n\tint rem = a[x][y] - ni * x - nj * y;\n\tif (rem < 0) return false;\n\n\tfor (int i = 1; i <= A; ++i) for (int j = 1; j <= B; ++j) {\n\t\tif (rem + ni * i + nj * j < a[i][j]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) cin >> a[i][j], nx[i][j] = -1, ny[i][j] = -1;\n\t}\t\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tfor (int ni = 0; ni <= 100; ++ni) for (int nj = 0; nj <= 100; ++nj) {\n\t\t\t\tif (check(i, j, ni, nj)) {\n\t\t\t\t\tnx[i][j] = ni, ny[i][j] = nj; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tS = ++n;\n\tT = ++n;\n\tvector<II> X, edges;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (nx[i][j] == -1 || ny[i][j] == -1) return cout << \"Impossible\\n\", 0;\n\n\t\t\tint rem = a[i][j] - nx[i][j] * i - ny[i][j] * j;\n\n\t\t\tint last = S;\n\t\t\tfor (int k = 0; k < min(nx[i][j], (int)X.size()); ++k) {\n\t\t\t\tedges.push_back(X[k]);\n\t\t\t\tlast = X[k].se.se;\n\t\t\t}\n\t\t\tnx[i][j] -= X.size();\n\t\t\twhile (nx[i][j]-- > 0) {\n\t\t\t\t++n; X.push_back(II(-1, ii(last, n))); last = n;\n\t\t\t\tedges.push_back(X.back());\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < ny[i][j]; ++k) {\n\t\t\t\t++n; edges.push_back(II(-2, ii(last, n))); last = n;\n\t\t\t}\n\n\t\t\tedges.push_back(II(rem, ii(last, T)));\n\t\t}\n\t}\n\n\tassert(n <= 300);\n\n\tsort(edges.begin(), edges.end());\n\tedges.erase(unique(edges.begin(), edges.end()), edges.end());\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << edges.size() << endl;\n\tfor (auto e : edges) {\n\t\tcout << e.se.fi << ' ' << e.se.se << ' ';\n\t\tif (e.fi < 0) cout << (e.fi == -1 ? 'X' : 'Y') << endl;\n\t\telse cout << e.fi << endl;\n\t}\n\tcout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint A, B;\n\tint d[20][20];\n\n\tcin >> A >> B;\n\trep(i,A) rep(j,B) cin >> d[i][j];\n\n\tvector<pair<pii,int>> v;\n\tbool ok[20][20] = {};\n\trep(a,101) rep(b,101) rrep(c,101){\n\t\tbool f = true, check = false;\n\t\trep(i,A) rep(j,B){\n\t\t\tint s = a*(i+1) + b*(j+1) + c;\n\t\t\tif( d[i][j] > s ) f = false;\n\t\t\tif( d[i][j] == s ){\n\t\t\t\tok[i][j] = true;\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tif(f && check) v.emplace_back(pii(a,b), c);\n\t\tif(!f) break;\n\t}\n\n\tbool ans = true;\n\trep(i,A) rep(j,B) if( !ok[i][j] ) ans = false;\n\n\tif( !ans ){\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\n\tvector<pair<pii,int>> edge;\n\trep(i,100) edge.emplace_back( pii(i+1,i+2), -1 );\n\trep(i,100) edge.emplace_back( pii(102+i,102+i+1), -2 );\n\tint cnt = 0, pos = 203;\n\tfor(auto p: v){\n\t\tint a = p.X.X;\n\t\tint b = p.X.Y;\n\t\tint c = p.Y;\n\t\tif( a >= b ){\n\t\t\tedge.emplace_back( pii(a+1,pos), -2 );\n\t\t\trep(i,b-1){\n\t\t\t\tedge.emplace_back( pii(pos,pos+1), -2 );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tedge.emplace_back( pii(pos,300), c );\n\t\t}else{\n\t\t\tedge.emplace_back( pii(102+b,pos), -1 );\n\t\t\trep(i,a-1){\n\t\t\t\tedge.emplace_back( pii(pos,pos+1), -1 );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tedge.emplace_back( pii(pos,300), c );\n\t\t}\n\t}\n\n\tcout << 300 << \" \" << edge.size() << endl;\n\tfor(auto t: edge){\n\t\tcout << t.X.X << \" \" << t.X.Y << \" \";\n\t\tif( t.Y == -1 ) cout << \"X\" << endl;\n\t\telse if( t.Y == -2 ) cout << \"Y\" << endl;\n\t\telse cout << t.Y << endl;\n\t}\n\tcout << 1 << \" \" << 300 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int fr,to;\n    int w;\n};\nint main(){\n    int a,b;\n    cin>>a>>b;\n    vector<vector<int>> d(a,vector<int>(b,0));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cin>>d[i][j];\n        }\n    }\n    const int S=1,T=204;\n    auto getX=[](int idx){\n        return 2+idx;\n    };\n    auto getY=[](int idx){\n        return 103+idx;\n    };\n    \n    vector<vector<int>> useX(a,vector<int>(b,0));\n    bool isok=true;\n    for(int i=a-2;i>=0;i--){\n        for(int j=b-1;j>=0;j--){\n            useX[i][j]=d[i+1][j]-d[i][j];\n            isok&=(useX[i+1][j]<=useX[i][j]);\n        }\n    }\n    vector<vector<int>> useY(a,vector<int>(b,0));\n    for(int i=a-1;i>=0;i--){\n        for(int j=b-2;j>=0;j--){\n            useY[i][j]=max(d[i][j+1]-d[i][j],i+1<a ? useY[i+1][j] : 0);\n            isok&=(useY[i][j+1]<=useY[i][j]);\n        }\n    }\n\n    \n    vector<Edge> edges;\n    edges.push_back(Edge{S,getX(0)});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getX(i),getX(i+1),0});\n    }\n    edges.push_back(Edge{getY(0),T,0});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getY(i+1),getY(i),0});\n    }\n    /*\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cout<<\"(\"<<useX[i][j]<<\",\"<<useY[i][j]<<\") \";\n        }\n        cout<<endl;\n    }\n    cout<<isok<<endl;\n    */\n   vector<vector<int>> table(101,vector<int>(101,-1));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            int w=d[i][j]-(i+1)*useX[i][j]-(j+1)*useY[i][j];\n            isok&=(w>=0);\n            isok&=!(table[useX[i][j]][useY[i][j]]!=-1 && table[useX[i][j]][useY[i][j]]!=w);\n            if(table[useX[i][j]][useY[i][j]]!=w){\n                edges.push_back(Edge{getX(useX[i][j]),getY(useY[i][j]),w});            \n                table[useX[i][j]][useY[i][j]]=w;\n            }\n        }\n    }\n    \n    if(isok){\n        cout<<\"Possible\"<<endl;\n        cout<<250<<\" \"<<edges.size()<<endl;\n        for(int i=0;i<edges.size();i++){\n            cout<<edges[i].fr<<\" \"<<edges[i].to<<\" \"<<edges[i].w<<endl;\n        }\n        cout<<S<<\" \"<<T<<endl;\n    }\n    else{\n        cout<<\"Impossible\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nint d[N][N], f[N][N];\nstruct data {\n  int x, y, w;\n} g[N * N * 10];\nint dx[N], dy[N];\n\nint check(int x, int y) {\n  int ans = 1e9;\n  for(int i = 0; i <= 100; ++i)\n   for(int j = 0; j <= 100; ++j)\n    ans = min(ans, i * x + j * y + f[i][j]);\n  return ans;\n}\n\nint main() {\n  int A, B;\n  cin >> A >> B;\n  for(int i = 1; i <= A; ++i)\n    for(int j = 1; j <= B; ++j)\n      scanf(\"%d\", &d[i][j]);\n  for(int i = 0; i <= 100; ++i)\n    for(int j = 0; j <= 100; ++j) {\n      for(int k = 1; k <= A; ++k)\n       for(int t = 1; t <= B; ++t)\n        f[i][j] = max(f[i][j], d[k][t] - i * k - j * t);\n    }\n  for(int i = 1; i <= A; ++i)\n    for(int j = 1; j <= B; ++j) {\n      if(check(i, j) != d[i][j]) {\n        puts(\"Impossible\");\n        exit(0);\n      }\n    }\n  puts(\"Possible\");\n  int tot = 0, res = 0;\n  int S = ++tot;\n  dx[0] = S;\n  for(int i = 1; i <= 100; ++i) {\n    dx[i] = ++tot;\n    g[++res] = (data){dx[i - 1], dx[i], -1};\n  }\n  int T = ++tot;\n  dy[0] = T;\n  for(int i = 1; i <= 100; ++i) {\n    dy[i] = ++tot;\n    g[++res] = (data){dy[i], dy[i - 1], -2};\n  }\n  for(int i = 0; i <= 100; ++i)\n    for(int j = 0; j <= 100; ++j) {\n      g[++res] = (data){dx[i], dy[j], f[i][j]};\n    }\n  printf(\"%d %d\\n\", tot, res);\n  for(int i = 1; i <= res; ++i) {\n    printf(\"%d %d \", g[i].x, g[i].y);\n    if(g[i].w < 0) {\n      if(g[i].w == -1) puts(\"X\");\n      else puts(\"Y\");\n    } else printf(\"%d\\n\", g[i].w);\n  }\n  printf(\"%d %d\\n\", S, T);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nint d[11][11];\nint c[101][101];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint a,b;\n\tcin>>a>>b;\n\trep(i,1,a)\n\trep(j,1,b)cin>>d[i][j];\n\tint n=101+101;\n\trep(x,0,100)\n\trep(y,0,100)\n\t{\n\t\trep(i,1,a)\n\t\trep(j,1,b)chmax(c[x][y],d[i][j]-(i*x+j*y));\n\t}\n\trep(i,1,a)\n\trep(j,1,b)\n\t{\n\t\trep(x,0,100)\n\t\trep(y,0,100)\n\t\tif(i*x+j*y+c[x][y]==d[i][j])goto have;\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t\thave : ;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,101*101);\n\trep(x,0,100)\n\trep(y,0,100)printf(\"%d %d %d\\n\",1+x,n-y,c[x][y]);\n\tprintf(\"%d %d\\n\",1,n);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint A, B;\nint d[11][11];\nbool flag[11][11];\nvector<pair<pair<int, int>, int>> out;\nmap<pair<int, int>, int>tmp;\n\n#define PAPAPAPAPAPA 1\n\nint main(void)\n{\n\tcin >> A >> B;\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int xk = 0; xk <= 100; ++xk) {\n\t\tfor (int yk = 0; yk <= 100; ++yk) {\n\t\t\tint small = INT_MIN;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\t//if (flag[i][j])continue;\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tsmall = max(small, d[i][j] - val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (small < 0)continue;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tif (small == d[i][j] - val) {\n\t\t\t\t\t\tif (!flag[i][j]) {\n\t\t\t\t\t\t\tflag[i][j] = true;\n\t\t\t\t\t\t\tint from = 0 + xk;\n\t\t\t\t\t\t\tint to = 201 - yk;\n\t\t\t\t\t\t\tif (tmp.count({ from,to })) {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = min(tmp[{from, to}], small);//バグの可能性あり\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = small;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(small <= 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tif (!flag[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tfor (auto tm : tmp) {\n\t\tout.push_back(tm);\n\t}\n\tout.push_back({ { 202,0 },0 });\n\tout.push_back({ { 202,101 },0 });\n\tout.push_back({ { 100,203 },0 });\n\tout.push_back({ { 201,203 },0 });\n\tfor (int i = 0; i < 100; ++i) {\n\t\tout.push_back({ { i,i + 1 },-1 });\n\t\tout.push_back({ { i + 101,i + 102 },-2 });\n\t}\n\tcout << 204 << \" \" << (int)out.size() << endl;\n\tfor (auto elm : out) {\n\t\tcout << elm.first.first + 1 << \" \" << elm.first.second + 1 << \" \";\n#if PAPAPAPAPAPA\n\t\tif (elm.second == -1) {\n\t\t\tcout << \"X\\n\";\n\t\t}\n\t\telse if (elm.second == -2) {\n\t\t\tcout << \"Y\\n\";\n\t\t}\n\t\telse {\n#endif\n\t\t\tcout << elm.second << endl;\n#if PAPAPAPAPAPA\n\t\t}\n#endif\n\t}\n\tcout << \"203 204\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <cassert>\n#include <tuple>\n#include <list>\n#include <iterator>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <complex>\n#include <memory>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class htpe, class cmp>\nusing heap = priority_queue<htpe, vector<htpe>, cmp>;\n\ntemplate<class htpe>\nusing min_heap = heap<htpe, greater<htpe> >;\n\ntemplate<class htpe>\nusing max_heap = heap<htpe, less<htpe> >;\n\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define ff first\n#define ss second\n\n#define forn(i, n) for (int i = 0; i < ((int)(n)); ++i)\n#define forrn(i, s, n) for (int i = (int)(s); i < ((int)(n)); ++i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n\n#define PYMOD(a, m) ((((a) % (m)) + (m)) % (m))\n\nconst int INF = 1791791791;\nconst ll INFLL = 1791791791791791791ll;\n\nstruct edge {\n    int u, v;\n    edge(int _u, int _v) {\n        u = _u, v = _v;\n    }\n    int from() { return u; }\n    int to() { return v; }\n    virtual int get_cost() = 0;\n    virtual void print() = 0;\n};\n\nstruct cost_edge : public edge {\n    int w;\n    cost_edge(int u, int v, int _w) : edge(u, v) {\n        w = _w;\n    }\n    virtual int get_cost() { return w; }\n    virtual void print() { cout << from() + 1 << \" \" << to() + 1 << \" \" << w << endl; }\n};\n\nint x, y;\n\nstruct x_edge : public edge {\n    x_edge(int u, int v) : edge(u, v) { }\n    virtual int get_cost() { return x; }\n    virtual void print() { cout << from() + 1 << \" \" << to() + 1 << \" X\" << endl; }\n};\n\nstruct y_edge : public edge {\n    y_edge(int u, int v) : edge(u, v) { }\n    virtual int get_cost() { return y; }\n    virtual void print() { cout << from() + 1 << \" \" << to() + 1 << \" Y\" << endl; }\n};\n\nvoid impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint d[10][10];\n\nconst int n = 203;\nvector<shared_ptr<edge> > graph[n];\n\nint dijkstra(int s, int t) {\n    min_heap<pair<int, int> > pq;\n    vector<int> dist(n, INF);\n    vector<bool> vis(n, false);\n    dist[s] = 0;\n    pq.push(mp(0, s));\n    while (!pq.empty()) {\n        auto pp = pq.top();\n        pq.pop();\n        //cout << pp.ss << \" \" << pp.ff << endl;\n        if (vis[pp.ss])\n            continue;\n        vis[pp.ss] = true;\n        for (auto e : graph[pp.ss]) {\n            if (!vis[e->to()]) {\n                if (dist[e->to()] > dist[e->from()] + e->get_cost()) {\n                    dist[e->to()] = dist[e->from()] + e->get_cost();\n                    pq.push(mp(dist[e->to()], e->to()));\n                }\n            }\n        }\n    }\n    //cout << x << \" \" << y << \" \" << dist[0] << \" \" << dist[1] << \" \" << dist[201] << \" \" << dist[202] << endl;\n    return dist[t];\n}\n\nint main() {\n    // Code here:\n\n    int a, b;\n    cin >> a >> b;\n    forn(i, a)\n        forn(j, b)\n            cin >> d[i][j];\n\n    forn(i, 100) {\n        graph[i].pb(make_shared<x_edge>(i, i + 1));\n        graph[102 + i].pb(make_shared<y_edge>(102 + i, 102 + i + 1));\n    }\n    int s = 0, t = 202;\n    forn(i, 101) {\n        forn(j, 101) {\n            int w = 0;\n            forn(x, a) {\n                forn(y, b) {\n                    w = max(w, d[x][y] - (x + 1) * i - (y + 1) * j);\n                }\n            }\n            graph[i].pb(make_shared<cost_edge>(i, 202 - j, w));\n        }\n    }\n\n    forn(i, a) {\n        forn(j, b) {\n            x = i + 1, y = j + 1;\n            if (dijkstra(s, t) != d[i][j]) {\n                //cerr << x << \" \" << y << \" \" << dijkstra(s, t) << \" \" << d[i][j] << endl;\n                impossible();\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << n << \" \" << 100 + 100 + 101 * 101 << endl;\n    forn(i, n) {\n        for (auto e : graph[i]) {\n            e->print();\n        }\n    }\n    cout << s + 1 << \" \" << t + 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=109;\nconst int M=19;\n\nint d[M][M],dis[M][M],f[N][N],n=101,a,b;\ninline void chkmax(int &a,int b){if(a<b)a=b;}\ninline void chkmin(int &a,int b){if(a>b)a=b;}\n\nint main()\n{\n\tif(fopen(\"vj.in\",\"r\"))\n\t{\n\t\tfreopen(\"vj.in\",\"r\",stdin);\n\t\tfreopen(\"vj.out\",\"w\",stdout);\n\t}\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\tdis[i][j]=1e9;\n\t\t}\n\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=1;k<=a;k++)\n\t\t\t\tfor(int l=1;l<=b;l++)\n\t\t\t\t\tchkmax(f[i][j],d[k][l]-k*i-l*j);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\tfor(int l=0;l<=n;l++)\n\t\t\t\t\tchkmin(dis[i][j],f[k][l]+i*k+j*l);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tif(dis[i][j]!=d[i][j])\n\t\t\t\treturn puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n*2,n*n+2*n-2);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d Y\\n\",1+n+i,n+i);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i,j+n,f[i-1][j-1]);\n\tprintf(\"%d %d\\n\",1,n+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint A, B;\nint d[11][11];\nbool flag[11][11];\nvector<pair<pair<int, int>, int>> out;\nmap<pair<int, int>, int>tmp;\n\nint main(void)\n{\n\tcin >> A >> B;\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int xk = 0; xk <= 100; ++xk) {\n\t\tfor (int yk = 0; yk <= 100; ++yk) {\n\t\t\tint small = INT_MIN;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\t//if (flag[i][j])continue;\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tsmall = max(small, d[i][j] - val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (small < 0)continue;\n\t\t\tfor (int i = 0; i < A; ++i) {\n\t\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\t\tint val = (i + 1) * xk + (j + 1) * yk;\n\t\t\t\t\tif (small == d[i][j] - val) {\n\t\t\t\t\t\tif (!flag[i][j]) {\n\t\t\t\t\t\t\tflag[i][j] = true;\n\t\t\t\t\t\t\tint from = 0 + xk;\n\t\t\t\t\t\t\tint to = 201 - yk;\n\t\t\t\t\t\t\tif (tmp.count({ from,to })) {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = min(tmp[{from, to}], small);//バグの可能性あり\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ttmp[{from, to}] = small;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tassert(small <= 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < A; ++i) {\n\t\tfor (int j = 0; j < B; ++j) {\n\t\t\tif (!flag[i][j]) {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tfor (auto tm : tmp) {\n\t\tout.push_back(tm);\n\t}\n\tout.push_back({ { 202,0 },0 });\n\tout.push_back({ { 202,101 },0 });\n\tout.push_back({ { 100,203 },0 });\n\tout.push_back({ { 201,203 },0 });\n\tfor (int i = 0; i < 100; ++i) {\n\t\tout.push_back({ { i,i + 1 },-1 });\n\t\tout.push_back({ { i + 101,i + 102 },-2 });\n\t}\n\tcout << 204 << \" \" << (int)out.size() << endl;\n\tfor (auto elm : out) {\n\t\tcout << elm.first.first + 1 << \" \" << elm.first.second + 1 << \" \";\n\t\tif (elm.second == -1) {\n\t\t\tcout << \"A\\n\";\n\t\t}\n\t\telse if (elm.second == -2) {\n\t\t\tcout << \"B\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << elm.second << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> II;\n#define fi first\n#define se second\n\nconst int N = 550;\n\nint A, B;\nint n, S, T;\nint nx[N][N], ny[N][N];\nint a[N][N];\n\nbool check(int x, int y, int ni, int nj) {\n\tint rem = a[x][y] - ni * x - nj * y;\n\tif (rem < 0) return false;\n\n\tfor (int i = 1; i <= A; ++i) for (int j = 1; j <= B; ++j) {\n\t\tif (rem + ni * i + nj * j < a[i][j]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) cin >> a[i][j], nx[i][j] = -1, ny[i][j] = -1;\n\t}\t\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tfor (int ni = 0; ni <= 100; ++ni) for (int nj = 0; nj <= 100; ++nj) {\n\t\t\t\tif (check(i, j, ni, nj)) {\n\t\t\t\t\tnx[i][j] = ni, ny[i][j] = nj; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tS = ++n;\n\tT = ++n;\n\tvector<II> X, edges;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (nx[i][j] == -1 || ny[i][j] == -1) return cout << \"Impossible\\n\", 0;\n\n\t\t\tint rem = a[i][j] - nx[i][j] * i - ny[i][j] * j;\n\n\t\t\tint last = S;\n\t\t\tfor (int k = 0; k < min(nx[i][j], (int)X.size()); ++k) {\n\t\t\t\tedges.push_back(X[k]);\n\t\t\t\tlast = X[k].se.se;\n\t\t\t}\n\t\t\tnx[i][j] -= X.size();\n\t\t\twhile (nx[i][j]-- > 0) {\n\t\t\t\t++n; X.push_back(II(-1, ii(last, n))); last = n;\n\t\t\t\tedges.push_back(X.back());\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < ny[i][j]; ++k) {\n\t\t\t\t++n; edges.push_back(II(-2, ii(last, n))); last = n;\n\t\t\t}\n\n\t\t\tedges.push_back(II(rem, ii(last, T)));\n\t\t}\n\t}\n\n\tsort(edges.begin(), edges.end());\n\tedges.erase(unique(edges.begin(), edges.end()), edges.end());\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << edges.size() << endl;\n\tfor (auto e : edges) {\n\t\tcout << e.se.fi << ' ' << e.se.se << ' ';\n\t\tif (e.fi < 0) cout << (e.fi == -1 ? 'X' : 'Y') << endl;\n\t\telse cout << e.fi << endl;\n\t}\n\tcout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\n#define N 305\n#define INF 0x3fffffff\nint f[N][N];\nint d[N][N];\nbool check(int x,int y,int v)\n{\n\tint res=INF;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tres=min(res,i*x+j*y+f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res==v;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n#endif\n\tmemset(f,-1,sizeof(f));\n\tint a,b;\n\tcin>>a>>b;\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint tmp=-INF;\n\t\t\tfor(int c=1;c<=a;c++)\n\t\t\t{\n\t\t\t\tfor(int e=1;e<=b;e++)\n\t\t\t\t{\n\t\t\t\t\ttmp=max(tmp,d[c][e]-i*c-j*e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i][j]=tmp;\n\t\t\tif(f[i][j]<0) break;\n\t\t\tsum++;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tif(!check(i,j,d[i][j]))\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint s=201,t=202;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,sum+200);\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+100);\n\t}\n\tprintf(\"%d %d X\\n\",s,1);\n\tprintf(\"%d %d Y\\n\",101,t);\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\",i==0?s:i,j==0?t:j+100,f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n#ifndef ONLINE_JUDGE\n\tprintf(\"Time Used : %d\\n\",clock());\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define reg register\n#define MAXN 101\n#define MAXI 11\nusing namespace std;\n\nint dis[MAXI][MAXI];\nint f[MAXN][MAXN];\nint n,m;\n\ninline int max(int a,int b)\n{return(a>b?a:b);}\n\ninline int min(int a,int b)\n{return(a<b?a:b);}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&dis[i][j]);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tfor(reg int px=1;px<=n;px++)\n\t\t\t\tfor(reg int py=1;py<=m;py++)\n\t\t\t\t\tf[i][j]=max(f[i][j],dis[px][py]-i*px-j*py);\n\tfor(reg int px=1;px<=n;px++)\n\t\tfor(reg int py=1;py<=m;py++)\n\t\t{\n\t\t\tint tmp=2147483647;\n\t\t\tfor(reg int i=0;i<=100;i++)\n\t\t\t\tfor(reg int j=0;j<=100;j++)\n\t\t\t\t\ttmp=min(tmp,f[i][j]+i*px+j*py);\n\t\t\tif(tmp!=dis[px][py])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(reg int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(reg int i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\",1+i,202-j,f[i][j]);\n\tprintf(\"1 202\");\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nusing taplis = tuple<int, int, int>;\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n        if(p==1&&q==0) {db(x); db(y); dbg(D[x][y] - p * (x+1) - q * (y+1));}\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(1) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << 101*2 sp << 100*2+101*101 ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            int ma=0;\n            rep(k,i,a){\n                rep(l,j,b){\n                    if(k==i&&l==j)continue;\n                    int mi=1000000000;\n                    int ddx=0,ddy=0;\n                    rep(ii,0,100){\n                        int zx=ii*(k-i);\n                        int noko=d[k][l]-d[i][j]-zx;\n                        int say=l-j;\n                        if(say==0){\n                            if(noko<=0){\n                                if(mi>zx*(i+1)){\n                                    mi=zx*(i+1);\n                                    ddx=zx;\n                                    ddy=0;\n                                }\n                                break;\n                            }\n                        }\n                        else{\n                            int zy=(noko+say-1)/say;\n                            if(noko<=0)zy=0;\n                            if(mi>zx*(i+1)+zy*(j+1)){\n                                mi=zx*(i+1)+zy*(j+1);\n                                ddx=zx;\n                                ddy=zy;\n                            }\n                            if(noko<=0)break;\n                        }\n                    }\n                    if(mi>ma){\n                        ma=mi;\n                        dx=ddx;\n                        dy=ddy;\n                    }\n                }\n            }\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m++;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nstruct Edge {\n\tLL from, to, cost;\n};\n\n\nint A, B;\nint D[11][11];\nint C[101][101];\nvector<Edge> G;\n\nint main() {\n\tcin >> A >> B;\n\n\tREP(i, 0, A) {\n\t\tREP(j, 0, B) {\n\t\t\tcin >> D[i + 1][j + 1];\n\t\t}\n\t}\n\n\tREP(x, 0, 101) {\n\t\tREP(y, 0, 101) {\n\t\t\tREP(a, 1, A + 1) {\n\t\t\t\tREP(b, 1, B + 1) {\n\t\t\t\t\tC[x][y] = max(C[x][y], D[a][b] - (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok = 1;\n\tREP(a, 1, A + 1) {\n\t\tREP(b, 1, B + 1) {\n\t\t\tint mn = INF;\n\t\t\tREP(x, 0, 101) {\n\t\t\t\tREP(y, 0, 101) {\n\t\t\t\t\tmn = min(mn, C[x][y] + (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != D[a][b]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (ok ? \"Possible\" : \"Impossible\") << endl;\n\tif (ok) {\n\t\tconst int XX = 12345;\n\t\tconst int YY = 56789;\n\n\t\tint X = 101;\n\t\tint Y = 101;\n\t\tREP(i, 0, X) G.push_back(Edge{ i, i + 1, XX });\n\t\tREP(i, 0, Y) G.push_back(Edge{ i + X, i + X + 1, YY });\n\n\t\tint S = X;\n\t\tREP(i, 0, X + 1) {\n\t\t\tREP(j, 0, Y + 1) {\n\t\t\t\tif (i == X || j == Y) continue;\n\t\t\t\tG.push_back(Edge{ S - (X - i),  S + (Y - j), C[i][j] });\n\t\t\t}\n\t\t}\n\n\t\tcout << X + Y + 1 << ' ' << G.size() << endl;\n\t\tfor (auto e : G) {\n\t\t\tcout << e.from + 1 << ' ' << e.to + 1 << ' ';\n\t\t\tif (e.cost == XX) {\n\t\t\t\tcout << 'X' << endl;\n\t\t\t} else if (e.cost == YY) {\n\t\t\t\tcout << 'Y' << endl;\n\t\t\t} else {\n\t\t\t\tcout << e.cost << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << ' ' << X + Y + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i=(a); i<=(b); i++)\n#define per(i,a,b) for (int i=(a); i>=(b); i--)\nusing namespace std;\n\nconst int maxn = 105;\nint f[maxn][maxn][maxn], d[maxn][maxn], ans[maxn][maxn][3];\nint A, B, mxA, mxB, n;\nset<pair<pair<int,int>,int> > s;\n\nint main() {\n\tscanf(\"%d%d\", &A, &B);\n\trep (i, 1, A) rep (j, 1, B) scanf(\"%d\", &d[i][j]);\n\trep (a, 0, 100) rep (b, 0, 100) rep (c, 0, 100) if (a + b + c <= 100) {\n\t\trep (i, 1, A) if (!f[a][b][c])\n\t\t\trep (j, 1, B) if (a * i + b * j + c < d[i][j]) {\n\t\t\t\t//printf(\"%d %d %d\\n\", a, b, c);\n\t\t\t\tf[a][b][c] = 1; break;\n\t\t\t}\n\t}\n\trep (i, 1, A) rep (j, 1, B) {\n\t\tint flag = 0;\n\t\trep (a, 0, 100) if (!flag)\n\t\t\trep (b, 0, 100) if (!flag && a * i + b * j <= d[i][j]) \n\t\t\t\trep (c, 0, 100) if (a * i + b * j + c == d[i][j] && !f[a][b][c]) {\n\t\t\t\t\tans[i][j][0] = a; ans[i][j][1] = b; ans[i][j][2] = c;\n\t\t\t\t\tmxA = max(mxA, a); mxB = max(mxB, b); flag = 1; break;\n\t\t\t\t}\t\t\t\t\n\t\tif (!flag) return puts(\"Impossible\"), 0;\n\t}\n\tputs(\"Possible\");\n\tn = mxA + mxB + 2;\n\trep (i, 1, mxA) s.insert(make_pair(make_pair(i, i+1), -1));\n\trep (i, n-mxB, n-1) s.insert(make_pair(make_pair(i, i+1), -2));\n\trep (i, 1, A) rep (j, 1, B) \n\t\ts.insert(make_pair(make_pair(ans[i][j][0]+1, n-ans[i][j][1]), ans[i][j][3]));\n\tprintf(\"%d %d\\n\", n, (int)s.size());\n\tfor (auto x : s)\n\t\tif (x.second == -1) printf(\"%d %d X\\n\", x.first.first, x.first.second);\n\t\telse if (x.second == -2) printf(\"%d %d Y\\n\", x.first.first, x.first.second);\n\t\telse printf(\"%d %d %d\\n\", x.first.first, x.first.second, x.second);\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define Maxn 300\n#define Maxk 10\n#define Inf 0x3f3f3f3f\nint f[Maxk+5][Maxk+5];\nint d[Maxk+5][Maxk+5];\n//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 \n//d[x][y]=min{f[i][j]+i*x+j*y}\n//f[i][j]=max{d[x][y]-i*x-j*y}\nint mx(int a,int b){\n\treturn a>b?a:b;\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nstruct Edge{\n\tint u,v,w;\n}edge[Maxn<<2|5];\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now;\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tnow=Inf;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tnow=mn(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint tot=1;\n\tputs(\"Possible\");\n\tint len=0;\n\tfor(int i=1;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-1;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=300;\n\ttot++;\n\tedge[++len].u=1;\n\tedge[len].v=tot;\n\tedge[len].w=-2;\n\tfor(int i=2;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-2;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=300;\n\tedge[len].w=-2;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tedge[++len].u=i+1;\n\t\t\tedge[len].v=tot-j+1;\n\t\t\tedge[len].w=f[i][j];\n\t\t}\n\t}\n\tprintf(\"300 %d\\n\",len);\n\tfor(int i=1;i<=len;i++){\n\t\tprintf(\"%d %d \",edge[i].u,edge[i].v);\n\t\tif(edge[i].w==-1){\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse if(edge[i].w==-2){\n\t\t\tputs(\"Y\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",edge[i].w);\n\t\t}\n\t}\n\tputs(\"1 300\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 110;\nint n, m;\nint d[15][15], p[N][N];\nint x[N*N], y[N*N], v[N*N], cnt;\n\nint main() {\n\tint i, j, k, A, B; bool f = 1;\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, n) rep(j, 1, m) {\n\t\tscanf(\"%d\", &d[i][j]);\n\t\tif(i > 1 && d[i][j] < d[i-1][j]) f = 0;\n\t\tif(j > 1 && d[i][j] < d[i][j-1]) f = 0;\n\t}\n\trep(A, 0, 100)\n\t\trep(B, 0, 100) {\n\t\t\tp[A][B] = -100;\n\t\t\trep(i, 1, n)\n\t\t\t\trep(j, 1, m) {\n\t\t\t\t\tp[A][B] = max(p[A][B], d[i][j] - i*A - j*B);\n\t\t\t\t}\n\t\t\tif(p[A][B] >= 0) {\n\t\t\t\t++cnt;\n\t\t\t\tx[cnt] = A+1; y[cnt] = B+102; v[cnt] = p[A][B];\n\t\t\t}\n\t\t}\n\tif(!f) {puts(\"Impossible\"); return 0;}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", 202, cnt+200);\n\trep(i, 1, cnt) printf(\"%d %d %d\\n\", x[i], y[i], v[i]);\n\trep(i, 2, 101) printf(\"%d %d X\\n\", i-1, i);\n\trep(i, 103, 202) printf(\"%d %d Y\\n\", i, i-1);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 105\n\nint n, m, d[N][N], f[N][N];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tscanf(\"%d\", &d[i][j]);\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tfor(int x = 1; x <= n; x++)\n\t\t\t\tfor(int y = 1; y <= m; y++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n\tfor(int x = 1; x <= n; x++)\n\t\tfor(int y = 1; y <= m; y++)\n\t\t{\n\t\t\tint res = INT_MAX;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tres = min(res, f[i][j] + i * x + y * j);\n\t\t\t// cout << x << ' ' << y << ' ' << res << endl;\n\t\t\tif(d[x][y] != res) \n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 %d\\n\", 101 * 101 + 200);\n\tfor(int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor(int i = 102; i < 202; i++) printf(\"%d %d Y\\n\", i, i + 1);\n\tfor(int i = 0; i <= 100; i++)\n\t\tfor(int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"202 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<202;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define RG register\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n#define clear(x, y) memset(x, y, sizeof(x))\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile(ch != '-' && (!isdigit(ch))) ch = getchar();\n\tif(ch == '-') w = -1, ch = getchar();\n\twhile(isdigit(ch)) data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int _A_(15), N(110);\nint d[_A_][_A_], f[N][N], A, B;\n\nint main()\n{\n\tA = read(), B = read();\n\tfor(RG int i = 1; i <= A; i++)\n\t\tfor(RG int j = 1; j <= B; j++)\n\t\t\td[i][j] = read();\n\tfor(RG int i = 0; i <= 100; i++)\n\t\tfor(RG int j = 0; j <= 100; j++)\n\t\t\tfor(RG int p = 1; p <= A; p++)\n\t\t\t\tfor(RG int q = 1; q <= B; q++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[p][q] - i * p - j * q);\n\tfor(RG int i = 1; i <= A; i++)\n\t\tfor(RG int j = 1; j <= B; j++)\n\t\t{\n\t\t\tint min = 1e9;\n\t\t\tfor(RG int p = 0; p <= 100; p++)\n\t\t\t\tfor(RG int q = 0; q <= 100; q++)\n\t\t\t\t\tmin = std::min(min, f[p][q] + i * p + j * q);\n\t\t\tif(min != d[i][j]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(RG int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\tfor(RG int i = 102; i < 202; i++)\n\t\tprintf(\"%d %d Y\\n\", i, i + 1);\n\tfor(RG int i = 0; i <= 100; i++)\n\t\tfor(RG int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\nconstexpr int V = 2 * (d_max + 1);\nconstexpr int S = 0, T = V - 1;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  std::array<std::array<int, d_max + 1>, d_max + 1> cost{};\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      for (int a: range(0, A + 1)) {\n        for (int b: range(0, B + 1)) {\n          chmax(cost[a][b], dist[i][j] - (i + 1) * a - (j + 1) * b);\n        }\n      }\n    }\n  }\n  std::array<std::pair<int, int>, d_max> Xs{};\n  std::array<std::pair<int, int>, d_max> Ys{};\n  for (int i: range(0, d_max)) {\n    Xs[i] = { i, i + 1 };\n    Ys[i] = { V - i - 2, V - i - 1 };\n  }\n  auto calc = [&](int x, int y) {\n    std::array<std::vector<std::pair<int, int>>, V> graph{};\n    for (int i: range(0, d_max)) {\n      graph[Xs[i].first].emplace_back(Xs[i].second, x);\n      graph[Ys[i].first].emplace_back(Ys[i].second, y);\n    }\n    for (int i: range(0, d_max + 1)) {\n      for (int j: range(0, d_max + 1)) {\n        if (cost[i][j] <= d_max) {\n          graph[i].emplace_back(V - j - 1, cost[i][j]);\n        }\n      }\n    }\n    std::array<int, V> length{};\n    length.fill(d_max + 1);\n    length[S] = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(length[S], S);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > length[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(length[e.first], length[v] + e.second)) {\n          que.emplace(length[e.first], e.first);\n        }\n      }\n    }\n    return length[T];\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (dist[i][j] != calc(i + 1, j + 1)) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  std::cout << \"Possible\\n\";\n  int E = 2 * d_max;\n  for (const auto &arr: cost) {\n    for (auto x: arr) {\n      if (x <= d_max) {\n        ++E;\n      }\n    }\n  }\n  std::cout << V << ' ' << E << '\\n';\n  for (auto e: Xs) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" X\\n\";\n  }\n  for (auto e: Ys) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (cost[i][j] <= d_max) {\n        std::cout << i + 1 << ' ' << V - j << ' ' << cost[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << S + 1 << ' ' << T + 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint A,B,val[11][11], mn[11][11];\nvector<pair<pi,string>> ed;\n\nvoid edge(int x, int y, string z) {\n    ed.pb({{x,y},z});\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> A >> B;\n    FOR(i,1,A+1) FOR(j,1,B+1) {\n        cin >> val[i][j];\n        mn[i][j] = MOD;\n    }\n    F0R(i,100) edge(i+1,i+2,\"X\"); // 1 to 101 \n    F0R(i,100) edge(i+102,i+103,\"Y\"); // 102 to 202\n    F0R(x,101) F0R(y,101) {\n        int z = 0;\n        FOR(i,1,A+1) FOR(j,1,B+1) z = max(z,val[i][j]-x*i-y*j);\n        FOR(i,1,A+1) FOR(j,1,B+1) mn[i][j] = min(mn[i][j],z+x*i+y*j);\n        edge(1+x,202-y,to_string(z));\n    }\n    FOR(i,1,A+1) FOR(j,1,B+1) if (mn[i][j] != val[i][j]) {\n        cout << \"Impossible\";\n        exit(0);\n    }\n    cout << \"Possible\\n\";\n    cout << \"202 \" << sz(ed) << \"\\n\";\n    for (auto a: ed) cout << a.f.f << \" \" << a.f.s << \" \" << a.s << \"\\n\";\n    cout << \"1 202\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nmain() {\n    INT(n, m);\n    VV(int, a, n, m);\n    int N = 100;\n    vv(int, d, N + 1, N + 1);\n    vv(bool, ok, n, m);\n    rep(x, N + 1) {\n        rep(y, N + 1) {\n            rep(i, n) rep(j, m) { chmax(d[x][y], a[i][j] - (i + 1) * x - (j + 1) * y); }\n            rep(i, n) rep(j, m) if(a[i][j] == d[x][y] + (i + 1) * x + (j + 1) * y) ok[i][j] = true;\n            // cout << d[x][y] << \" \";\n        }\n        // cout << endl;\n    }\n    rep(i, n) rep(j, m) {\n        if(!ok[i][j]) {\n            cout << \"Impossible\\n\";\n            exit(0);\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << N * 2 + 1 << \" \" << N * 2 + (N + 1) * (N + 1) << endl;\n    rep2(i, 1, N) cout << i << \" \" << i + 1 << \" \" << 'X' << endl;\n    rep2(i, N, N * 2) cout << i << \" \" << i + 1 << \" \" << 'Y' << endl;\n    rep(i, N + 1) rep(j, N + 1) {\n        int t = 1 + i, s = N * 2 + 1 - j;\n        cout << t << \" \" << s << \" \" << d[i][j] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_A=10,MAX_B=10,INF=1e5;\nint A,B,d[MAX_A][MAX_B];\n\nint f[101][101];\n\nint main(){\n\tcin>>A>>B;\n\tREP(i,A)REP(j,B){\n\t\tcin>>d[i][j];\n\t}\n\tREP(a,101){\n\t\tREP(b,101){\n\t\t\tREP(x,A){\n\t\t\t\tREP(y,B){\n\t\t\t\t\tf[a][b]=max(f[a][b],d[x][y]-(x+1)*a-(y+1)*b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool ans=true;\n\tREP(x,A){\n\t\tREP(y,B){\n\t\t\tint td=INF;\n\t\t\tREP(a,101){\n\t\t\t\tREP(b,101){\n\t\t\t\t\ttd=min(td,(x+1)*a+(y+1)*b+f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (td!=d[x][y]){\n\t\t\t\tans=false;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans){\n\t\tcout<<\"Possible\"<<endl<<101*2<<\" \"<<101*101+200<<endl;\n\t\tREP(i,100){\n\t\t\tcout<<i+1<<\" \"<<i+2<<\" X\"<<endl;\n\t\t}\n\t\tREP(i,100){\n\t\t\tcout<<i+102<<\" \"<<i+103<<\" Y\"<<endl;\n\t\t}\n\t\tREP(a,101){\n\t\t\tREP(b,101){\n\t\t\t\tcout<<a+1<<\" \"<<202-b<<\" \"<<f[a][b]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<\"1 202\"<<endl;\n\t}else{\n\t\tcout<<\"Impossible\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[15][15];\nint f[105][105];\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int na, nb;\n   cin >> na >> nb;\n   for (int i = 1; i <= na; ++i) {\n      for (int j = 1; j <= nb; ++j) {\n         cin >> d[i][j];\n      }\n   }\n   for (int nx = 0; nx < 105; ++nx) {\n      for (int ny = 0; ny < 105; ++ny) {\n         for (int i = 1; i <= na; ++i) {\n            for (int j = 1; j <= nb; ++j) {\n               f[nx][ny] = max(f[nx][ny], d[i][j] - i * nx - j * ny);\n            }\n         }\n      }\n   }\n   for (int i = 1; i <= na; ++i) {\n      for (int j = 1; j <= nb; ++j) {\n         bool found = false;\n         for (int nx = 0; nx < 105; ++nx) {\n            for (int ny = 0; ny < 105; ++ny) {\n               if (f[nx][ny] + i * nx + j * ny == d[i][j]) {\n                  found = true;\n               }\n            }\n         }\n         if (!found) {\n            cout << \"Impossible\\n\";\n            return 0;\n         }\n      }\n   }\n   cout << \"Possible\\n\";\n   cout << 210 << \" \" << 11233 << \"\\n\";\n   for (int i = 0; i < 104; ++i) {\n      cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n      cout << i + 107 << \" \" << i + 106 << \" Y\\n\";\n   }\n   for (int nx = 0; nx < 105; ++nx) {\n      for (int ny = 0; ny < 105; ++ny) {\n         cout << nx + 1 << \" \" << ny + 106 << \" \" << f[nx][ny] << \"\\n\";\n      }\n   } \n   cout << 1 << \" \" << 106 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\n\nint main(int argc, char const *argv[]) {\n  // 不可能なものを削る\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n  vector<tp> use;\n  for(ll i=0;i<=99;i++){\n    for(ll j=0;j<=99;j++){\n      for(ll k=0;k<=100;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        nxt:;\n      }\n    }\n  }\n\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n  return 1;\n  std::cout << \"Possible\" << '\\n';\n  vvl e;\n  vvl ok = VV(301, 301, 0, ll);\n\n  for(int i=1;i<100;i++){\n    ok[i][i+1] = 1;\n    e.push_back({i, i+1, -1});\n  }\n  for(int i=1;i<100;i++){\n    ok[i+200][i+201] = 1;\n    e.push_back({i+200, i+201, -2});\n  }\n\n  for(auto v:use){\n    ll i = get<0>(v);\n    ll j = get<1>(v);\n    ll k = get<2>(v);\n    ll x = 0;\n  }\n\n  //------output area-----\n  std::cout << \"300 \" << e.size() << '\\n';\n\n\n  std::cout << \"1 300\" << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\n\nint A,B;\nint d[11][11];\nconst int C = 101;\nint S = 1 , T = 2 * C;\nint N = T , M = 2 * (C-1) + C * C;\nint e[C][C];\n \nint main(){\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\trep(i,C) rep(j,C){\n\t\tfor (int x = 1; x <= A; ++x) {\n\t\t\tfor (int y = 1; y <= B; ++y) {\n\t\t\t\te[i][j] = max(e[i][j] , d[x][y]-i*x-j*y)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= A; ++x) {\n\t\tfor (int y = 1; y <= B; ++y) {\n\t\t\tint z = C;\n\t\t\trep(i,C) rep(j,C) z = min(z,e[i][j]+i*x+j*y);\n\t\t\tif(z != d[x][y]) return cout << \"Impossible\" << endl , 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << N << ' ' << M << endl;\n\tfor (int i = 1; i < C; ++i) {\n\t\tcout << i << ' ' << i+1 << \" X\" << endl;\n\t\tcout << C+i << ' ' << C+i+1 << \" Y\" << endl;\n\t}\n\trep(i,C) rep(j,C) cout << i+1 << ' ' << N-j << ' ' << e[i][j] << endl;\n\tcout << S << ' ' << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\nusing namespace std;\nstruct p {\n\tint x, y, z;\n\tbool operator<(const p &A) const {\n\t\tif (x != A.x) return x < A.x;\n\t\tif (y != A.y) return y < A.y;\n\t\treturn z < A.z;\n\t}\n\tp& operator-=(const p &A) {\n\t\tx -= A.x; y -= A.y; z -= A.z;\n\t\treturn *this;\n\t}\n};\np cross(const p &A, const p &B) {\n\treturn { A.y*B.z - B.y*A.z, A.z*B.x - B.z*A.x, A.x*B.y - B.x*A.y };\n}\nstruct Plane {\n\tint a, b, c; // z = ax + by + c\n\tbool valid;\n\tPlane(p u, p v, p z) {\n\t\tvalid = false;\n\t\tu -= z; v -= z;\n\t\tp t = cross(u, v);\n\t\tif (t.z == 0 || t.x%t.z != 0 || t.y % t.z != 0) return;\n\t\ta = -t.x / t.z; b = -t.y / t.z;\n\t\tc = z.z - a * z.x - b * z.y;\n\t\tif (c < 0 || a < 0 || b < 0) return;\n\t\tvalid = true;\n\t}\n\tbool operator<(const Plane &A) const {\n\t\tif (a != A.a) return a < A.a;\n\t\tif (b != A.b) return b < A.b;\n\t\treturn c < A.c;\n\t}\n\tbool operator()(const p &A) const {\n\t\treturn a * A.x + b * A.y + c;\n\t}\n};\nvector<p> v;\nint chk[111];\nbool isunder(Plane c, p x) {\n\treturn c(x) >= x.z;\n}\nset<Plane> ans;\nint main() {\n\tint a, b, n, t;\n\tscanf(\"%d%d\", &a, &b);\n\tn = a * b;\n\tfor (int i = 1; i <= a; i++)for (int j = 1; j <= b; j++) {\n\t\tscanf(\"%d\", &t);\n\t\tv.push_back({ i, j, t });\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) for (int k = j + 1; k < n; k++) {\n\t\tPlane t(v[i], v[j], v[k]);\n\t\tif (!t.valid) continue;\n\t\tint succ = 1;\n\t\tfor (auto x : v) {\n\t\t\tif (!isunder(t, x)) {\n\t\t\t\tsucc = 0; break;\n\t\t\t}\n\t\t}\n\t\tif (succ) {\n\t\t\tchk[i] = chk[j] = chk[k] = 1;\n\t\t\tans.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (chk[i] == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"200 %d\\n\", 198 + ans.size());\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d Y\\n\", i + 100, i + 101);\n\tfor (auto t : ans) {\n\t\tprintf(\"%d %d %d\\n\", t.a + 1, 200 - t.b, t.c);\n\t}\n\tprintf(\"1 200\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=105;\nint a,b,f[N][N],d[N][N],s[N][N];\nint main()\n{\n    scanf(\"%d%d\",&a,&b);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        scanf(\"%d\",&d[x][y]);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        f[i][j]=max(f[i][j],d[x][y]-(i-1)*x-(j-1)*y);\n    memset(s,inf,sizeof(s));\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n            for(int x=1;x<=a;x++)\n            for(int y=1;y<=b;y++)\n            s[x][y]=min(s[x][y],f[i][j]+(i-1)*x+(j-1)*y);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        if(d[x][y]!=s[x][y])\n    {\n        printf(\"Impossible\\n\");\n        return 0;\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\",100+100+101*101);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d X\\n\",i,i+1);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d Y\\n\",101+i,101+i+1);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        printf(\"%d %d %d\\n\",i,j+101,f[i][j]);\n    printf(\"%d %d\\n\",1,202);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 10000000;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 105;\nconst int MM = 1000000007;\n\nint v[MX][MX], D[MX][MX];\npii E[MX][MX];\n\nint main()\n{\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; i++){\n\t\tfor(int j = 1; j <= B; j++){\n\t\t\tscanf(\"%d\", D[i]+j);\n\t\t\tE[i][j] = pii(-1, -1);\n\t\t}\n\t}\n\tfor(int kk = 100; kk >= 0; kk--){\n\t\tfor(int l = kk; l >= 0; l--){\n\t\t\tint k = kk - l;\n\t\t\tint mx = 0;\n\t\t\tfor(int x = 1; x <= A; x++){\n\t\t\t\tfor(int y = 1; y <= B; y++){\n\t\t\t\t\tmx = max(mx, D[x][y] - x*k - y*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[k][l] = mx;\n\t\t\tfor(int x = 1; x <= A; x++){\n\t\t\t\tfor(int y = 1; y <= B; y++){\n\t\t\t\t\tif( mx == D[x][y] - x*k - y*l) E[x][y] = pii(k, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<t3> L;\n\tmap<pii, int> V;\n\tfor(int i = 1; i <= A; i++){\n\t\tfor(int j = 1; j <= B; j++){\n\t\t\tint a = E[i][j].first, b = E[i][j].second;\n\t\t\tif( a == -1 ) return !printf(\"Impossible\\n\");\n\t\t\tL.emplace_back(a, b, v[a][b]);\n\t\t}\n\t}\n\tsort(L.begin(), L.end());\n\tL.erase(unique(L.begin(), L.end()), L.end());\n\n\tint mx = 0, cur = 1;\n\tfor(t3 c : L) mx = max(mx, get<0>(c));\n\tvector<t3> G;\n\tV[pii(0, 0)] = 1;\n\tfor(int i = 1; i <= mx; i++){\n\t\tG.emplace_back(cur, cur+1, -1);\n\t\tcur += 1;\n\t\tV[pii(i, 0)] = cur;\n\t}\n\tfor(int i = 0; i <= mx; i++){\n\t\tint mx2 = 0, prv = i+1;\n\t\tfor(t3 c : L){\n\t\t\tif( get<0>(c) == i ) mx2 = max(mx2, get<1>(c));\n\t\t}\n\t\tfor(int j = 1; j <= mx2; j++){\n\t\t\tG.emplace_back(prv, ++cur, -2);\n\t\t\tV[pii(i, j)] = cur;\n\t\t\tprv = cur;\n\t\t}\n\t}\n\tfor(t3 e : L){\n\t\tint a, b, c;\n\t\ttie(a, b, c) = e;\n\t\tG.emplace_back(V[pii(a, b)], cur+1, c);\n\t}\n\tprintf(\"%d %d\\n\", cur+1, G.size());\n\tfor(t3 e : G){\n\t\tint a, b, c;\n\t\ttie(a, b, c) = e;\n\t\tprintf(\"%d %d \", a, b);\n\t\tif( c == -1 ) printf(\"X\\n\");\n\t\telse if( c == -2 ) printf(\"Y\\n\");\n\t\telse printf(\"%d\\n\", c);\n\t}\n\tprintf(\"1 %d\\n\", cur+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tregister int x=0;\n\tregister bool f=0;\n\tregister char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') f=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+c-48;\n\t\tc=getchar();\n\t}\n\treturn f?-x:x;\n}\nconst int maxn=305;\nint d[15][15],f[maxn][maxn];\nint n,m;\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++) d[i][j]=read();\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++)\n\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tint sum=1000000007;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tsum=min(sum,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<300<<\" \"<<10401<<endl;\n\tint tot=0;\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\ttot++;\n\t}\n\tfor(int j=300;j>=201;j--){\n\t\tprintf(\"%d %d Y\\n\",j-1,j);\n\t\ttot++;\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,300-j,f[i][j]);\n\t\t\ttot++;\n\t\t}\n\t}\n\tputs(\"1 300\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint mx[305][305], dis[305][305]; \nint main()\n{\n\t// freopen(\"ARC089-E.in\", \"r\", stdin); \n\tint a, b, n = 300; \n\tscanf(\"%d%d\", &a, &b); \n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tscanf(\"%d\", dis[i] + j); \n\t}\n\tfor (int x = 0; x <= 100; x++)\n\t{\n\t\tfor (int y = 0; y <= 100; y++)\n\t\t{\n\t\t\tfor (int i = 1; i <= a; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= b; j++)\n\t\t\t\t\tmx[x][y] = std::max(mx[x][y], dis[i][j] - (i * x + j * y)); \n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tbool f = false; \n\t\t\tfor (int x = 0; x <= 100 && !f; x++)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y <= 100 && !f; y++)\n\t\t\t\t\tf |= mx[x][y] + i * x + j * y == dis[i][j]; \n\t\t\t}\n\t\t\tif (!f)\n\t\t\t{\n\t\t\t\tputs(\"Impossible\"); \n\t\t\t\treturn 0; \n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\t// return 0; \n\tprintf(\"%d %d\\n\", n, 101 * 101 + 100 * 2);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d Y\\n\", n - i, n - i + 1);\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, n - j, mx[i][j]);\n\t}\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B, E;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 0; i < 100; i++) {\n        adj[ X(i) ].push_back(pii(X(i + 1), -1));\n    }\n    for(int i = 100; i >= 1; i--) {\n        adj[ Y(i) ].push_back(pii(Y(i - 1), -2));\n    }\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    E = 0;\n    for(int u = 0; u < V; u++) E += adj[u].size();\n\n    printf(\"%d %d\\n\", V, E);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                if(w == -1) printf(\"%d %d X\\n\", u + 1, v + 1);\n                else if(w == -2) printf(\"%d %d Y\\n\", u + 1, v + 1);\n                else printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n            }\n        }\n    }\n\n    printf(\"%d %d\", src + 1, snk + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nvoid solve(){\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > dist(A,vector<int>(B));\n\tfor(int i=0;i<A;++i){\n\t\tfor(int j=0;j<B;++j){\n\t\t\tcin >> dist[i][j];\n\t\t}\n\t}\n\tfor(int a = 0;a<=100;++a){\n\t\tfor(int b=0;b<=100;++b){\n\t\t\tfor(int c=0;c<=100;++c){\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int i=1;i<=A;++i){\n\t\t\t\t\tfor(int j=1;j<=B;++j){\n\t\t\t\t\t\tint res = INF;\n\t\t\t\t\t\tres = min(a,i+b);\n\t\t\t\t\t\tres = min(res,j+c);\n\t\t\t\t\t\tif( dist[i-1][j-1] != res ){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( flag == false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( flag == true ){\n\t\t\t\t\tcout << \"Possible\" << endl;\n\t\t\t\t\tcout << \"4 5\" << endl;\n\t\t\t\t\tcout << \"1 2 \" << a << endl;\n\t\t\t\t\tcout << \"1 3 X\" << endl;\n\t\t\t\t\tcout << \"3 2 \" << b << endl;\n\t\t\t\t\tcout << \"1 4 Y\" << endl;\n\t\t\t\t\tcout << \"4 2 \" << c << endl;\n\t\t\t\t\tcout << \"1 2\" << endl;//ST\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a=0;a<=100;++a){\n\t\tfor(int b=0;b<=100;++b){\n\t\t\tbool flag = true;\n\t\t\tfor(int i=1;i<=A;++i){\n\t\t\t\tfor(int j=1;j<=B;++j){\n\t\t\t\t\tint res = INF;\n\t\t\t\t\tres = min(a,i+b);\n\t\t\t\t\tres = min(res,j+b);\n\t\t\t\t\tif( dist[i-1][j-1] != res ){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( flag == false ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag == true ){\n\t\t\t\tcout << \"Possible\" << endl;\n\t\t\t\tcout << \"3 4\" << endl;\n\t\t\t\tcout << \"1 2 \" << a << endl;\n\t\t\t\tcout << \"1 3 X\" << endl;\n\t\t\t\tcout << \"1 3 Y\" << endl;\n\t\t\t\tcout << \"3 2 \" << b << endl;\n\t\t\t\tcout << \"1 2\" << endl;//ST\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0;a<=100;++a){\n\t\tfor(int b=0;b<=100;++b){\n\t\t\tfor(int c=0;c<=100;++c){\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int i=1;i<=A;++i){\n\t\t\t\t\tfor(int j=1;j<=B;++j){\n\t\t\t\t\t\tint res = INF;\n\t\t\t\t\t\tres = min(a+b,i+j);\n\t\t\t\t\t\tres = min(res,c);\n\t\t\t\t\t\tres = min(res,a+j);\n\t\t\t\t\t\tres = min(res,i+b);\n\n\t\t\t\t\t\tif( dist[i-1][j-1] != res ){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( flag == false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( flag == true ){\n\t\t\t\t\tcout << \"Possible\" << endl;\n\t\t\t\t\tcout << \"1 2 \" << c << endl;\n\t\t\t\t\tcout << \"1 3 \" << a << endl;\n\t\t\t\t\tcout << \"1 3 X\" << endl;\n\t\t\t\t\tcout << \"3 2 \" << b << endl;\n\t\t\t\t\tcout << \"3 2 Y\" << endl;\n\t\t\t\t\tcout << \"1 2\" << endl;//ST\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Impossible\" << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\n//#define ANDREIKKAA_INTERACTIVE\nconst int _ML = 220;\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n        \"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n        \"\"\n#else\n\"\"\n#endif\n;\n\n#if !defined(ANDREIKKAA)\n#pragma GCC optimize (\"O3\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define rand rd\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#if !defined(ANDREIKKAA_INTERACTIVE) && !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\n\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n\n/* ________ CODE ________ */\n\nvoid bad()\n{\n    cout << \"Impossible\" << endl;\n    exit(0);\n}\n\ninline void mainFunction()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> v(n, vector<int>(m));\n    cin >> v;\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && v[i][j] > v[i + 1][j])\n            {\n                bad();\n            }\n\n            if(j + 1 < m && v[i][j] > v[i][j + 1])\n            {\n                bad();\n            }\n        }\n    }\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && v[i][j] == v[i + 1][j])\n            {\n                for(int k = i + 2; k < n; ++k)\n                {\n                    if(v[i][j] != v[k][j])\n                    {\n                        bad();\n                    }\n                }\n            }\n\n            if(j + 1 < m && v[i][j] == v[i][j + 1])\n            {\n                for(int k = j + 2; k < n; ++k)\n                {\n                    if(v[i][j] != v[i][k])\n                    {\n                        bad();\n                    }\n                }\n            }\n        }\n    }\n\n    assert(false);\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << setprecision(228);\n    //cout << fixed;\n    mainFunction();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\n\nvoid test_edge(int a,int b, int x, int y){\n    int c = d[x][y] - a*x - b*y;\n    if (a >= 0 && b >= 0 && c >= 0 && c <= 100){\n        for(int i=1;i<=A;i++){\n            for(int j=1;j<=B;j++){\n                if (a*i + b*j + c < d[i][j])return;\n            }\n        }\n        C[a][b] = min(C[a][b], c);\n    }\n    else return;\n}\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a0 = d[x+1][y] - d[x][y];\n            int a1 = d[x+1][y+1] - d[x][y+1];\n            int b0 = d[x][y+1] - d[x][y];\n            int b1 = d[x+1][y+1] - d[x+1][y];\n            test_edge(a0, b0, x,y);\n            test_edge(a0, b1, x,y);\n            test_edge(a1, b0, x,y);\n            test_edge(a1, b1, x+1,y+1);\n        }\n    }\n    for(int y=1;y<B;y++){\n        int b = d[A][y+1] - d[A][y];\n        int c = d[A][y] - b*y;\n        if (b >= 0 && c >= 0 && c <= 100)C[0][b] = min(C[0][b],c);\n    }\n    for(int x=1;x<A;x++){\n        int a = d[x+1][B] - d[x][B];\n        int c = d[x][B] - a*x;\n        if (a >= 0 && c >= 0 && c <= 100)C[a][0] = min(C[a][0],c);\n    }\n    C[0][0] = min(C[0][0], d[A][B]);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint a, b;\nconst int maxN = 105;\nint d[maxN][maxN];\nbool ok[maxN][maxN];\nint val[maxN][maxN];\nint vert[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n    int sz = 1;\n    for (int cnt1 = 0; cnt1 < 100; cnt1++) {\n        for (int cnt2 = 0; cnt2 < 100; cnt2++) {\n            vert[cnt1][cnt2] = sz++;\n            int at_least_t = 0;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    at_least_t = max(at_least_t, d[j][k] - j * cnt1 - k * cnt2);\n                }\n            }\n            val[cnt1][cnt2] = at_least_t;\n            for (int j = 1; j <= a; j++) {\n                for (int k = 1; k <= b; k++) {\n                    int p = at_least_t + j * cnt1 + k * cnt2;\n                    assert(p >= d[j][k]);\n                    if (p == d[j][k]) ok[j][k] = true;\n                }\n            }\n        }\n    }\n    for (int j = 1; j <= a; j++) {\n        for (int k = 1; k <= b; k++) {\n            if (!ok[j][k]) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << '\\n';\n    vector < pair < pair < int, int >, int > > edges;\n    int T = sz;\n    for (int i = 0; i < maxN; i++) {\n        if (i + 1 < maxN) edges.emplace_back(make_pair(i + 1, i + 2), -1);\n        if (i + 1 < maxN) edges.emplace_back(make_pair(maxN + i + 1, maxN + i + 2), -2);\n        for (int j = 0; j < maxN; j++) {\n            edges.emplace_back(make_pair(i + 1, maxN + (maxN - j - 1) + 1), val[i][j]);\n        }\n    }\n    cout << 2 * maxN << \" \" << edges.size() << '\\n';\n    for (auto it : edges) {\n        cout << it.first.first << \" \" << it.first.second << \" \";\n        if (it.second == -1) cout << 'X' << '\\n';\n        else if (it.second == -2) cout << 'Y' << '\\n';\n        else cout << it.second << '\\n';\n    }\n    cout << 1 << \" \" << maxN + maxN  << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            if (k >= 0 && k < T) {\n                v.push_back(F{i, j, k});\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n    int s = 0;\n    int t = 299;\n\n    const int N = 300;\n    int dd[N][N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dd[i][j] = INT_MAX;\n        }\n    }\n    for (int i = 0; i < T; ++i) {\n        dd[i][i + 1] = -1;\n    }\n\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        dd[i + YY][i + 1 + YY] = -2;\n    }\n\n    for (const auto &f : v) {\n        dd[f.a][YY] = min(dd[f.a][YY], 0);\n        dd[YY + f.b][t] = min(dd[YY + f.b][t], f.c);\n    }\n    cout << \"Possible\" << \"\\n\";\n    int esize = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                esize++;\n            }\n        }\n    }\n    cout << t + 1 << \" \" << esize << \"\\n\";\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                cout << i + 1 << \" \" << j + 1 << \" \";\n                if (dd[i][j] >= 0) {\n                    cout << dd[i][j];\n                } else if (dd[i][j] == -1) {\n                    cout << \"X\";\n                } else {\n                    cout << \"Y\";\n                }\n                cout << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << N << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int INF = 1 << 29;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nvector< T > dijkstra(WeightedGraph< T > &g, int s) {\n  const auto INF = numeric_limits< T >::max();\n  vector< T > dist(g.size(), INF);\n\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  dist[s] = 0;\n  que.emplace(dist[s], s);\n  while(!que.empty()) {\n    T cost;\n    int idx;\n    tie(cost, idx) = que.top();\n    que.pop();\n    if(dist[idx] < cost) continue;\n    for(auto &e : g[idx]) {\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}\n\n\nint main() {\n  int A, B, D[10][10];\n  cin >> A >> B;\n  for(int i = 0; i < A; i++) {\n    for(int j = 0; j < B; j++) {\n      cin >> D[i][j];\n    }\n  }\n\n  int F[101][101] = {{}};\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      for(int c = 0; c < A; c++) {\n        for(int d = 0; d < B; d++) {\n          F[a][b] = max(F[a][b], D[c][d] - a * (c + 1) - b * (d + 1));\n        }\n      }\n    }\n  }\n\n  for(int c = 1; c <= A; c++) {\n    for(int d = 1; d <= B; d++) {\n      WeightedGraph< int > g(202);\n      for(int a = 0; a <= 99; a++) {\n        g[a].emplace_back(a + 1, c);\n        g[a + 102].emplace_back(a + 101, d);\n      }\n      for(int a = 0; a <= 100; a++) {\n        for(int b = 0; b <= 100; b++) {\n          g[a].emplace_back(b + 101, F[a][b]);\n        }\n      }\n      if(dijkstra(g, 0)[101] != D[c - 1][d - 1]) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n\n\n  Edges< int > edges;\n  for(int a = 0; a <= 99; a++) {\n    edges.emplace_back(a, a + 1, -1);\n    edges.emplace_back(a + 102, a + 101, -2);\n  }\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      edges.emplace_back(a, b + 101, F[a][b]);\n    }\n  }\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << edges.size() << endl;\n  for(auto &e : edges) {\n    cout << e.src + 1 << \" \" << e.to + 1 << \" \";\n    if(e.cost == -1) cout << \"X\" << endl;\n    else if(e.cost == -2) cout << \"Y\" << endl;\n    else cout << e.cost << endl;\n  }\n  cout << 1 << \" \" << 102 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint G[11][11], a[11][11], b[11][11];\n\nint main(void)\n{\n    int A, B, ok = 1;\n    scanf(\"%d %d\", &A, &B);\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            scanf(\"%d\", &G[i][j]);\n    for(int i = 1; i <= A; i++)\n    for(int j = 1; j <= B; j++)\n    {\n        int ma = 0, mb = 0;\n        for(int k = i + 1; k <= A; k++)\n        {\n            if(G[k][j] < G[i][j]) ok = 0;\n            ma = max(ma, (G[k][j] - G[i][j] + k - i - 1) / (k - i));\n        }\n        for(int k = j + 1; k <= B; k++)\n        {\n            if(G[i][k] < G[i][j]) ok = 0;\n            mb = max(mb, (G[i][k] - G[i][j] + k - j - 1) / (k - j));\n        }\n        if(i * ma + j * mb > G[i][j]) ok = 0;\n        else a[i][j] = ma, b[i][j] = mb;\n    }\n    if(!ok) puts(\"Impossible\");\n    else\n    {\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 200 + A * B, 198 + 2 * A * B);\n        for(int i = 1; i < 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n        for(int i = 101; i < 200; i++) printf(\"%d %d Y\\n\", i, i + 1);\n        for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n        printf(\"%d %d %d\\n%d %d %d\\n\", a[i][j] + 1, 200 + (i - 1) * A + B, 0, 200 + (i - 1) * A + B, 200 - b[i][j], G[i][j] - i * a[i][j] - j * b[i][j]);\n        printf(\"1 100\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*i);\n\tchmax(D[k],d[i][j]-(k+1)*j);\n      }\n    }\n  }\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i<<\" \"<<j<<\":\"<<dist<<\":\"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int M = 12, N = 310;\n\nint d[M][M], dis[M][M], A, B;\nint f[N][N];\n\nint main(){\n\n\tscanf(\"%d%d\", &A, &B);\n\tFor(i, 1, A) For(j, 1, B) scanf(\"%d\", &d[i][j]), dis[i][j] = 1e9;\n\tFor(i, 0, 100) For(j, 0, 100) For(u, 1, A) For(v, 1, B) \n\t\tf[i][j] = max(f[i][j], d[u][v] - u * i - v * j);\n\tFor(u, 1, A) For(v, 1, B) For(i, 0, 100) For(j, 0, 100)\n\t\tdis[u][v] = min(dis[u][v], f[i][j] + i * u + j * v);\n\tFor(u, 1, A) For(v, 1, B) if(d[u][v] != dis[u][v]){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\n\tputs(\"Possible\");\n\tint n = 101;\n\tprintf(\"%d %d\\n\", n * 2, n * n + 2 * (n - 1));\n\tFor(i, 1, n) For(j, 1, n) printf(\"%d %d %d\\n\", i, j + n, f[i - 1][j - 1]);\n\tFor(i, 2, n) printf(\"%d %d X\\n\", i - 1, i);\n\tFor(i, 2, n) printf(\"%d %d Y\\n\", i + n, i + n - 1);\n\tprintf(\"%d %d\\n\", 1, n + 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(101, vector<int>(101, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[i][j] - i * k - j * l);\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            minDistance = min(minDistance, i * k + j * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[a][b]) impossible();\n      }\n    }\n    cout << \"202 10401\" << endl;\n    for (int k = 0; k <= 100; ++k) {\n      for (int l = 0; l <= 100; ++l) {\n        cout << k + 1 << ' ' << 102 + l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < 100; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + 102 << ' ' << i + 103 << \" Y\" << endl;\n    }\n\n    cout << \"1 202\" << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\n//#define ANDREIKKAA_INTERACTIVE\nconst int _ML = 220;\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n        \"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n        \"\"\n#else\n\"\"\n#endif\n;\n\n#if !defined(ANDREIKKAA)\n#pragma GCC optimize (\"O3\")\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define rand rd\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#if !defined(ANDREIKKAA_INTERACTIVE) && !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\n\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n\n/* ________ CODE ________ */\n\nvoid bad()\n{\n    cout << \"Impossible\" << endl;\n    exit(0);\n}\n\ninline void mainFunction()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> v(n, vector<int>(m));\n    cin >> v;\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && v[i][j] > v[i + 1][j])\n            {\n                bad();\n            }\n\n            if(j + 1 < m && v[i][j] > v[i][j + 1])\n            {\n                bad();\n            }\n        }\n    }\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n        {\n            if(i + 1 < n && v[i][j] == v[i + 1][j])\n            {\n                for(int k = i + 2; k < n; ++k)\n                {\n                    if(v[i][j] != v[k][j])\n                    {\n                        bad();\n                    }\n                }\n            }\n\n            if(j + 1 < m && v[i][j] == v[i][j + 1])\n            {\n                for(int k = j + 2; k < m; ++k)\n                {\n                    if(v[i][j] != v[i][k])\n                    {\n                        bad();\n                    }\n                }\n            }\n        }\n    }\n\n    assert(false);\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << setprecision(228);\n    //cout << fixed;\n    mainFunction();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int INF = 1 << 29;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nvector< T > dijkstra(WeightedGraph< T > &g, int s) {\n  const auto INF = numeric_limits< T >::max();\n  vector< T > dist(g.size(), INF);\n\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  dist[s] = 0;\n  que.emplace(dist[s], s);\n  while(!que.empty()) {\n    T cost;\n    int idx;\n    tie(cost, idx) = que.top();\n    que.pop();\n    if(dist[idx] < cost) continue;\n    for(auto &e : g[idx]) {\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}\n\n\nint main() {\n  int A, B, D[10][10];\n  cin >> A >> B;\n  for(int i = 0; i < A; i++) {\n    for(int j = 0; j < B; j++) {\n      cin >> D[i][j];\n    }\n  }\n\n  int F[101][101] = {{}};\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      for(int c = 0; c < A; c++) {\n        for(int d = 0; d < B; d++) {\n          F[a][b] = max(0, D[c][d] - a * (c + 1) - b * (d + 1));\n        }\n      }\n    }\n  }\n\n  for(int c = 1; c <= A; c++) {\n    for(int d = 1; d <= B; d++) {\n      WeightedGraph< int > g(202);\n      for(int a = 0; a <= 99; a++) {\n        g[a].emplace_back(a + 1, c);\n        g[a + 102].emplace_back(a + 101, d);\n      }\n      for(int a = 0; a <= 100; a++) {\n        for(int b = 0; b <= 100; b++) {\n          g[a].emplace_back(b + 101, F[a][b]);\n        }\n      }\n      if(dijkstra(g, 0)[101] != D[c - 1][d - 1]) {\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n\n\n  Edges< int > edges;\n  for(int a = 0; a <= 99; a++) {\n    edges.emplace_back(a, a + 1, -1);\n    edges.emplace_back(a + 102, a + 101, -2);\n  }\n  for(int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      edges.emplace_back(a, b + 101, F[a][b]);\n    }\n  }\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << edges.size() << endl;\n  for(auto &e : edges) {\n    cout << e.src + 1 << \" \" << e.to + 1 << \" \";\n    if(e.cost == -1) cout << \"X\" << endl;\n    else if(e.cost == -2) cout << \"Y\" << endl;\n    else cout << e.cost << endl;\n  }\n  cout << 1 << \" \" << 102 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)+1<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tcout<<M+1<<' '<<M+2<<' '<<0<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint A,B;\nint d[15][15];\nint f[105][105],tot,gx[105],gy[105],S,T;\npii p[305 * 305];\nint val[305 * 305],cnt;\nint check(int x,int y) {\n    int res = 1000000;\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    res = min(res,f[i][j] + i * x + j * y);\n\t}\n    }\n    return res;\n}\nvoid Solve() {\n    read(A);read(B);\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    read(d[i][j]);\n\t}\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    for(int k = 1 ; k <= A ; ++k) {\n\t\tfor(int h = 1 ; h <= B ; ++h) {\n\t\t    f[i][j] = max(f[i][j],d[k][h] - k * i - h * j);\n\t\t}\n\t    }\n\t} \n    }\n    for(int i = 1 ; i <= A ; ++i) {\n\tfor(int j = 1 ; j <= B ; ++j) {\n\t    if(check(i,j) != d[i][j]) {\n\t\tputs(\"Impossible\");\n\t\treturn;\n\t    }\n\t}\n    }\n    puts(\"Possible\");\n    S = ++tot;\n    gx[0] = S;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgx[i] = ++tot;\n\tp[++cnt] = mp(gx[i - 1],gx[i]);\n\tval[cnt] = -2;\n    }\n    T = ++tot;\n    gy[0] = T;\n    for(int i = 1 ; i <= 100 ; ++i) {\n\tgy[i] = ++tot;\n\tp[++cnt] = mp(gy[i],gy[i - 1]);\n\tval[cnt] = -1;\n    }\n    for(int i = 0 ; i <= 100 ; ++i) {\n\tfor(int j = 0 ; j <= 100 ; ++j) {\n\t    if(f[i][j]) {\n\t\tp[++cnt] = mp(gx[i],gy[j]);\n\t\tval[cnt] = f[i][j];\n\t    }\n\t}\n    }\n    out(tot);space;out(cnt);enter;\n    for(int i = 1 ; i <= cnt ; ++i) {\n\tout(p[i].fi);space;out(p[i].se);space;\n\tif(val[i] < 0) {\n\t    if(val[i] == -1) {puts(\"X\");}\n\t    else puts(\"Y\");\n\t}\n\telse {out(val[i]);enter;}\n    }\n    out(S);space;out(T);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\nint main(int argc, char const *argv[]) {\n  // aX + bY + c = d11 不可能な(a, b, c)がわかる\n  // 10000条件×10000試行\n  // 不可能なものを削る\n\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll x = d[1][1];\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n\n  vector<tp> use;\n  for(ll i=0;i<=x;i++){\n    for(ll j=0;i+j<=x;j++){\n      for(ll k=0;k<=x;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        nxt:;\n      }\n    }\n  }\n\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n\n  throw runtime_error(\"error\");\n  std::cout << \"Possible\" << '\\n';\n  if(x==100){\n    std::cout << \"2 1\" << '\\n';\n    std::cout << \"1 2 100\" << '\\n';\n    std::cout << \"1 2\" << '\\n';\n    return 0;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dx[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint A, B;\nint d[11][11];\nint f[101][101];\n\nsigned main() {\n    cin >> A >> B;\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            cin >> d[x][y];\n        }\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            f[a][b] = 0;\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int cur = LLONG_MAX;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    cur = min(cur, x * a + y * b + f[a][b]);\n                }\n            }\n            if (d[x][y] != cur) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 200 + 101 * 101 << endl;\n    for (int i = 1; i <= 100; i++) {\n        cout << i << \" \" << i + 1 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            cout << a + 1 << \" \" << b + 102 << \" \" << f[a][b] << endl;\n        }\n    }\n    cout << 1 << \" \" << 202 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nint A , B , d[20][20] , mn[20][20];\n\nint main(){\n  cin >> A >> B;\n  rep(i,1,A+1) rep(j,1,B+1)\n    cin >> d[i][j];\n  rep(i,1,A+1) rep(j,1,B+1)\n    mn[i][j] = d[i][j] + 1;\n  vi X , Y;\n  int _ = 0;\n  rep(i,0,101) X.pb(++_) , Y.pb(++_);\n  vector<pair<pii,int> > edge;\n  rep(i,1,sz(X)) edge.pb(mp(mp(X[i - 1] , X[i]) , -1));\n  rep(i,1,sz(Y)) edge.pb(mp(mp(Y[i] , Y[i - 1]) , -2));\n  rep(i,0,sz(X)) rep(j,0,sz(Y)) {\n    int add = 0;\n    rep(x,1,A+1) rep(y,1,B+1) {\n      int cost = i * x + j * y;\n      if(cost < d[x][y])\n        add = max(add , d[x][y] - cost);\n    }\n    edge.pb(mp(mp(X[i] , Y[i]) , add));\n    rep(x,1,A+1) rep(y,1,B+1) {\n      mn[x][y] = min(mn[x][y] , i * x + j * y + add);\n    }\n  }\n  bool ok = true;\n  rep(i,1,A+1) rep(j,1,B+1) ok &= mn[i][j] == d[i][j];\n  if(!ok) cout << \"Impossible\" << endl;\n  else {\n    cout << \"Possible\" << endl;\n    cout << sz(X) + sz(Y) << \" \" << sz(edge) << endl;\n    for(auto e : edge) {\n      cout << e.fi.fi << \" \" << e.fi.se << \" \";\n      if(e.se == -1) cout << \"X\" << endl;\n      else if(e.se == -2) cout << \"Y\" << endl;\n      else cout << e.se << endl;\n    }\n    cout << X[0] << \" \" << Y[0] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint X=-1;\nint Y=-2;\nstruct Edge{\n    int fr,to;\n    int w;\n};\nint main(){\n    int a,b;\n    cin>>a>>b;\n    vector<vector<int>> d(a,vector<int>(b,0));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cin>>d[i][j];\n        }\n    }\n    const int S=1,T=204;\n    auto getX=[](int idx){\n        return 2+idx;\n    };\n    auto getY=[](int idx){\n        return 103+idx;\n    };\n    \n    vector<vector<int>> useX(a,vector<int>(b,0));\n    bool isok=true;\n    for(int i=a-2;i>=0;i--){\n        for(int j=b-1;j>=0;j--){\n            useX[i][j]=d[i+1][j]-d[i][j];\n            isok&=(useX[i+1][j]<=useX[i][j]);\n        }\n    }\n    vector<vector<int>> useY(a,vector<int>(b,0));\n    for(int i=a-1;i>=0;i--){\n        for(int j=b-2;j>=0;j--){\n            useY[i][j]=max(d[i][j+1]-d[i][j],i+1<a ? useY[i+1][j] : 0);\n            isok&=(useY[i][j+1]<=useY[i][j]);\n        }\n    }\n\n    \n    vector<Edge> edges;\n    edges.push_back(Edge{S,getX(0)});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getX(i),getX(i+1),X});\n    }\n    edges.push_back(Edge{getY(0),T,0});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getY(i+1),getY(i),Y});\n    }\n    /*\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cout<<\"(\"<<useX[i][j]<<\",\"<<useY[i][j]<<\") \";\n        }\n        cout<<endl;\n    }\n    cout<<isok<<endl;\n    */\n   if(!isok){\n       cout<<\"Impossible\"<<endl;\n       return 0;\n   }\n   vector<vector<int>> table(101,vector<int>(101,-1));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            int w=d[i][j]-(i+1)*useX[i][j]-(j+1)*useY[i][j];\n            isok&=(w>=0);\n            isok&=!(table[useX[i][j]][useY[i][j]]!=-1 && table[useX[i][j]][useY[i][j]]!=w);\n            if(table[useX[i][j]][useY[i][j]]!=w){\n                edges.push_back(Edge{getX(useX[i][j]),getY(useY[i][j]),w});            \n                table[useX[i][j]][useY[i][j]]=w;\n            }\n        }\n    }\n    \n    if(isok){\n        cout<<\"Possible\"<<endl;\n        cout<<250<<\" \"<<edges.size()<<endl;\n        for(int i=0;i<edges.size();i++){\n            string cost;\n            if(edges[i].w==X){\n                cost=\"X\";\n            }\n            else if(edges[i].w==Y){\n                cost=\"Y\";\n            }\n            else{\n                cost=to_string(edges[i].w);\n            }\n            cout<<edges[i].fr<<\" \"<<edges[i].to<<\" \"<<cost<<endl;\n        }\n        cout<<S<<\" \"<<T<<endl;\n    }\n    else{\n        cout<<\"Impossible\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\n\nvoid test_edge(int a,int b, int x, int y){\n    int c = d[x][y] - a*x - b*y;\n    if (a >= 0 && b >= 0 && c >= 0 && c <= 100){\n        for(int i=1;i<=A;i++){\n            for(int j=1;j<=B;j++){\n                if (a*i + b*j + c < d[i][j])return;\n            }\n        }\n        C[a][b] = min(C[a][b], c);\n    }\n    else return;\n}\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a0 = d[x+1][y] - d[x][y];\n            int a1 = d[x+1][y+1] - d[x][y+1];\n            int b0 = d[x][y+1] - d[x][y];\n            int b1 = d[x+1][y+1] - d[x+1][y];\n            test_edge(a0, b0, x,y);\n            test_edge(a0, b1, x,y);\n            test_edge(a1, b0, x,y);\n            test_edge(a1, b1, x,y);\n        }\n    }\n    for(int y=1;y<B;y++){\n        int b = d[A][y+1] - d[A][y];\n        int c = d[A][y] - b*y;\n        if (b >= 0 && c >= 0 && c <= 100)C[0][b] = min(C[0][b],c);\n    }\n    for(int x=1;x<A;x++){\n        int a = d[x+1][B] - d[x][B];\n        int c = d[x][B] - a*x;\n        if (a >= 0 && c >= 0 && c <= 100)C[a][0] = min(C[a][0],c);\n    }\n    C[0][0] = min(C[0][0], d[A][B]);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=210;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\nint A,B,n,D[N][N],d[N][N],G[N][N];\nint main()\n{\n\tfile();\n\tread(A),read(B);\n\tn=100;\n\tFor(i,1,A)For(j,1,B)read(d[i][j]);\n\tFor(i,0,n)\n\t\tFor(j,0,n)\n\t\t\tFor(a,1,A)\n\t\t\t\tFor(b,1,B)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"(%d %d %d %d) %d\\n\",i,j,a,b,d[a][b]-a*i-b*j);\n\t\t\t\t\tchkmax(D[i][j],d[a][b]-a*i-b*j);\n\t\t\t\t}\n\tFor(a,1,A)\n\t\tFor(b,1,B)\n\t\t{\n\t\t\tG[a][b]=inf;\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tchkmin(G[a][b],D[i][j]+a*i+b*j);\n\t\t\tif(G[a][b]!=d[a][b]){puts(\"Impossible\");exit(0);}\n\t\t}\n\tputs(\"Possible\");\n\tn=101;\n\tprintf(\"%d %d\\n\",2*n,n*n+2*n-2);\n\tFor(i,2,n)printf(\"%d %d %c\\n\",i-1,i,'X');\n\tFor(i,2,n)printf(\"%d %d %c\\n\",n+i,n+i-1,'Y');\n\tFor(i,1,n)For(j,1,n)printf(\"%d %d %d\\n\",i,j+n,D[i-1][j-1]);\n\tprintf(\"%d %d\\n\",1,n+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\n#define N 305\n#define INF 0x3fffffff\nint f[N][N];\nint d[N][N];\nbool check(int x,int y,int v)\n{\n\tint res=INF;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tres=min(res,i*x+j*y+f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res==v;\n}\nsigned main()\n{\n\tmemset(f,-1,sizeof(f));\n\tint a,b;\n\tcin>>a>>b;\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tint sum=0;\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tint tmp=-INF;\n\t\t\tfor(int c=1;c<=a;c++)\n\t\t\t{\n\t\t\t\tfor(int e=1;e<=b;e++)\n\t\t\t\t{\n\t\t\t\t\ttmp=max(tmp,d[c][e]-i*c-j*e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i][j]=tmp;\n\t\t\tif(f[i][j]<0) break;\n\t\t\tsum++;\n\t\t}\n\t}\n\tfor(int i=1;i<=a;i++)\n\t{\n\t\tfor(int j=1;j<=b;j++)\n\t\t{\n\t\t\tif(!check(i,j,d[i][j]))\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint s=201,t=202;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",202,sum+200);\n\tfor(int i=1;i<100;i++)\n\t{\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+100);\n\t}\n\tprintf(\"%d %d X\\n\",s,1);\n\tprintf(\"%d %d Y\\n\",101,t);\n\tfor(int i=0;i<=100;i++)\n\t{\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tif(f[i][j]>=0)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\",i==0?s:i,j==0?t:j+100,f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        // assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << n-1 << \" \" << n << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint n,m,cnt,ans;\nint w[110][110],v[110][110];\nbool flag=1,fl;\nint main()\n{\n\t//freopen(\"ans.txt\",\"w\",stdout);\n\tint i,s,a,b,j,k,c;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\tfor(s=1;s<=m;s++)\n\t{\n\t\tscanf(\"%d\",&w[i][s]);\n\t\tfor(k=0;k<=100;k++)\n\t\tfor(j=0;j<=100;j++)v[k][j]=max(v[k][j],w[i][s]-i*k-s*j);\n\t}\n\tfor(i=1;i<=n && flag;i++)\n\tfor(s=1;s<=m && flag;s++)\n\t{\n\t\tc=1e9;\n\t\tfor(k=0;k<=100;k++)\n\t\tfor(j=0;j<=100;j++)c=min(v[k][j]+i*k+s*j,c);\n\t\tif(c!=w[i][s])flag=0;\n\t}\n\tif(!flag){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n202 41004\\n\");\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1),printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(i=0;i<=100;i++)\n\tfor(s=0;s<=100;s++)printf(\"%d %d %d\\n\",1+i,102+s,v[i][s]);\n\tprintf(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+1<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=2*M;i++) cout<<i<<' '<<i+1<<' '<<(i<=M?'X':'Y')<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+1-j<<' '<<b[i][j]<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tassert(i);\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + H*W << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\tcout << 1 << \" \" << 201 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//void __(){\n//    _(int,A);\n//    _(int,B);\n//    vvi d(A+1,vi(B+1,MOD));\n//    rep(i,1,A)\n//        rep(j,1,B)\n//            cin >> d[i][j];\n//    int S = 1, T = 300;\n//    vpii x_edges, y_edges;\n//    rep(i,2,101)\n//        x_edges.pb({i-1,i});\n//    per(i,200,299)\n//        y_edges.pb({i,i+1});\n//    vvi best_c(101,vi(101,MOD));\n//    vvi test(A+1,vi(B+1,MOD));\n//    rep(a,0,100)\n//        rep(b,0,100)\n//            rep(c,0,100){\n//                if(a+b+c >= 1 && a+b+c <= 100){\n//                    bool ok = true;\n//                    rep(i,1,A){\n//                        if(!ok)break;\n//                        rep(j,1,B){\n//                            if(!ok)break;\n//                            if(d[i][j] > i*a+j*b+c) ok = false;\n//                        }\n//                    }\n//                    if(ok){\n//                        best_c[a][b] = min(best_c[a][b],c);\n//                        rep(i,1,A){\n//                            rep(j,1,B){\n//                                test[i][j] = min(test[i][j],i*a+j*b+c);\n//                            }\n//                        }\n//                    }\n//                }\n//            }\n//    if(test != d){\n//        print \"Impossible\";\n//        return;\n//    }\n//    print \"Possible\";\n//    vvi other_edges;\n//    rep(a,0,100)\n//        rep(b,0,100)\n//            if(best_c[a][b] != MOD){\n//                int u = S+a;\n//                int v = T-b;\n//                other_edges.pb({u,v,best_c[a][b]});\n//            }\n//    print T,sz(x_edges)+sz(y_edges)+sz(other_edges);\n//    for(auto _ : x_edges) print _.X,_.Y,'X';\n//    for(auto _ : y_edges) print _.X,_.Y,'Y';\n//    for(auto _ : other_edges) print _;\n//    print S,T;\n//\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT,REP_ZERO_INT)(__VA_ARGS__)\n#define PER_INT(i,l,r) for(int i = r; i >= l; --i)\n#define GET_PER_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define per(...) GET_PER_MACRO(__VA_ARGS__,PER_ANY,PER_INT,PER_ZERO_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define X first\n#define Y second\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout)\n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\nT1 ostream& operator<<(ostream& stream, const vector<T>& t){\n    for(int i = 0; i < sz(t); ++i){\n        stream << t[i];\n        if(i+1 < sz(t))\n            stream << ' ';\n    }\n    return stream;\n}\n#define INPUT_WITHOUT_INIT(type,name) type name; cin >> name\n#define GET_INPUT_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define _(...) GET_INPUT_MACRO(__VA_ARGS__,_IWI,_IWI,_IWI,_IWI,_IWI,_IWI,INPUT_WITHOUT_INIT)(__VA_ARGS__)\nvoid __(){\n    _(int,A);\n    _(int,B);\n    vvi d(A+1,vi(B+1,MOD));\n    rep(i,1,A)\n        rep(j,1,B)\n            cin >> d[i][j];\n    int S = 1, T = 300;\n    vpii x_edges, y_edges;\n    rep(i,2,101)\n        x_edges.pb({i-1,i});\n    per(i,200,299)\n        y_edges.pb({i,i+1});\n    vvi best_c(101,vi(101,MOD));\n    vvi test(A+1,vi(B+1,MOD));\n    rep(a,0,100)\n        rep(b,0,100)\n            rep(c,0,100){\n                if(a+b+c >= 1 && a+b+c <= 100){\n                    bool ok = true;\n                    rep(i,1,A){\n                        if(!ok)break;\n                        rep(j,1,B){\n                            if(!ok)break;\n                            if(d[i][j] > i*a+j*b+c) ok = false;\n                        }\n                    }\n                    if(ok){\n                        best_c[a][b] = min(best_c[a][b],c);\n                        rep(i,1,A){\n                            rep(j,1,B){\n                                test[i][j] = min(test[i][j],i*a+j*b+c);\n                            }\n                        }\n                    }\n                }\n            }\n    if(test != d){\n        print \"Impossible\";\n        return;\n    }\n    print \"Possible\";\n    vvi other_edges;\n    rep(a,0,100)\n        rep(b,0,100)\n            if(best_c[a][b] != MOD){\n                int u = S+a;\n                int v = T-b;\n                other_edges.pb({u,v,best_c[a][b]});\n            }\n    print T,sz(x_edges)+sz(y_edges)+sz(other_edges);\n    for(auto _ : x_edges) print _.X,_.Y,'X';\n    for(auto _ : y_edges) print _.X,_.Y,'Y';\n    for(auto _ : other_edges) print _;\n    print S,T;\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\t// freopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");;;;\n\tprintf(\"%d %d\\n\",N*2+2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<=N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+2;i<(N+1)*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,(N+1)*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint To[10005], Next[10005], Head[305], W[10005], S, T, Cnt, Dis[305], M;\nbool Vis[305];\nstruct Node{\n\tint X, V;\n\tbool operator < (const Node &B)const\n\t{\n\t\treturn V > B.V;\n\t}\n};\ninline void Insert(int U, int V, int Val)\n{\n\tTo[++Cnt] = V, Next[Cnt] = Head[U], Head[U] = Cnt, W[Cnt] = Val;\n}\npriority_queue<Node>Q;\ninline int Dij(int X, int Y)\n{\n\tmemset(Dis, 0x3f, sizeof(Dis));\n\tmemset(Vis, 0, sizeof(Vis));\n\tDis[S] = 0;\n\tQ.push((Node){S, 0});\n\tint U, V;\n\twhile(!Q.empty()){\n\t\tU = Q.top().X;\n\t\tQ.pop();\n\t\tif(Vis[U])continue;\n\t\tVis[U] = true;\n\t\tfor(int I = Head[U], Val, V; I; I = Next[I]){\n\t\t\tVal = (W[I] == -1) ? X : (W[I] == -2) ? Y : W[I];\n\t\t\tV = To[I];\n\t\t\tif(Dis[U] + Val < Dis[V]){\n\t\t\t\tDis[V] = Dis[U] + Val;\n\t\t\t\tQ.push((Node){V, Dis[V]});\n\t\t\t}\n\t\t}\n\t}\n\treturn Dis[T];\n}\nint main()\n{\n\tmemset(F, -1, sizeof(F));\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\tfor(int I = 1; I <= 100; ++I)\n\t\tInsert(I, I + 1, -1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tInsert(I, I + 1, -2);\n\tM = 200;\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1)\n\t\t\t\tInsert(1 + I, 102 + J, F[I][100 - J]), ++M;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\tif(Dij(X, Y) != D[X][Y]){puts(\"Impossilble\"); return 0;}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1){\n\t\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\t\t\t}\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            int ma=0;\n            rep(k,i,a){\n                rep(l,j,b){\n                    if(k==i&&l==j)continue;\n                    int mi=1000000000;\n                    int ddx=0,ddy=0;\n                    rep(ii,0,100){\n                        int zx=ii*(k-i);\n                        int noko=d[k][l]-d[i][j]-zx;\n                        int say=l-j;\n                        if(say==0){\n                            if(noko<=0){\n                                if(mi>zx*(i+1)){\n                                    mi=zx*(i+1);\n                                    ddx=zx;\n                                    ddy=0;\n                                }\n                                break;\n                            }\n                        }\n                        else{\n                            int zy=(noko+say-1)/say;\n                            if(noko<=0)zy=0;\n                            if(mi>zx*(i+1)+zy*(j+1)){\n                                mi=zx*(i+1)+zy*(j+1);\n                                ddx=zx;\n                                ddy=zy;\n                            }\n                            if(noko<=0)break;\n                        }\n                    }\n                    if(mi>ma){\n                        ma=mi;\n                        dx=ddx;\n                        dy=ddy;\n                    }\n                }\n            }\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m++;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + (N-1) * (N-1);\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" x\" << endl;\n    REP(i,N-1) cout << 300-i << \" \" << 299-i << \" y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?102+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int INF = numeric_limits<int>::max();\n\nconstexpr int MAX_N = 105;\n\nint A, B, D[11][11];\n\nint F[MAX_N][MAX_N];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 0; j < A; ++j) {\n        for (int k = 0; k < B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    for (int j = 0; j < MAX_N; ++j) for (int k = 0; k < MAX_N; ++k) {\n        for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n            F[j][k] = max(F[j][k], D[a][b] - (a+1) * j - (b+1) * k);\n        }\n    }\n\n    for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n        int min_dist = INF;\n        for (int j = 0; j < MAX_N; ++j) {\n            for (int k = 0; k < MAX_N; ++k) {\n                min_dist = min(min_dist, (a+1) * j + (b+1) * k + F[j][k]);\n            }\n        }\n        if (min_dist != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", 2*MAX_N, 2*(MAX_N-1) + MAX_N*MAX_N);\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d X\\n\", (j+1), (j+2));\n    }\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d Y\\n\", MAX_N+(j+1), MAX_N+(j+2));\n    }\n    for (int j = 0; j < MAX_N; ++j) {\n        for (int k = 0; k < MAX_N; ++k) {\n            printf(\"%d %d %d\\n\", (j+1), 2*MAX_N-j, F[j][k]);\n        }\n    }\n    printf(\"%d %d\\n\", 1, 2*MAX_N);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > d(A,vector<int>(B));\n\tfor(int i =0; i < A*B; i++) cin >> d[i/B][i%B];\n\n\tvector< vector<int> > mincost(101,vector<int>(101,0));\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++)\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\t mincost[k][l] =max(d[i][j]-k*i-l*j,mincost[k][l]);\n\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++) {\n\t\tint m =101;\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\tm =min(m,mincost[k][l]+k*i+l*j);\n\t\tif(m != d[i][j]) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tint N =2*(100+1), M =(N/2)*(N/2)+2*(N/2-1);\n\tcout << N << \" \" << M << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i =0; i <= N/2-1; i++) for(int j =0; j <= N/2-1; j++)\n\t\tcout << i+1 << \" \" << N-j << \" \" << mincost[i][j] << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+N/2+1 << \" \" << i+N/2+2 << \" Y\\n\";\n\tcout << \"1 \" << N << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n    using namespace std;\n    const int N = 350;\n    const int INF = 1<<30;\n\n    int a, b, s, t, sum, d[N][N], f[N][N];\n\n    inline void ck_min( int &a, int b ) { if( a > b ) a = b; }\n    inline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\n    inline bool check( int x, int y, int val )\n    {\n        int res = INF;\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n                if( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\n    //  printf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n        return res == val;\n    }\n\n    int main()\n    {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\",\"r\",stdin);\n#endif\n        memset( f, -1, sizeof( f ) );\n\n        scanf( \"%d%d\", &a, &b );\n        for( int i = 1; i <= a; i ++ )\n            for( int j = 1; j <= b; j ++ )\n                scanf( \"%d\", &d[i][j] );\n\n        s = 201, t = 202; \n        // s --> 1 --> 2 --> ... --> 100\n        // t <-- 101 <-- 102 <-- ... <-- 200\n\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n            {\n                int tmp = -INF;\n                for( int _a = 1; _a <= a; _a ++ )\n                    for( int _b = 1; _b <= b; _b ++ )\n                        ck_max( tmp, d[_a][_b] - i*_a - j*_b ); \n                f[i][j] = tmp; \n                if( f[i][j] < 0 ) break;\n\n                sum ++;\n    //          printf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n            }\n\n        for( int i = 1; i <= a; i ++ )\n            for( int j = 1; j <= b; j ++ )  \n                if( !check( i, j, d[i][j] ) ) {\n                    printf( \"Impossible\\n\" ); return 0;\n                } \n\n        printf( \"Possible\\n\" );\n\n        printf( \"%d %d\\n\", 202, sum+200 );\n        for( int i = 1; i < 100; i ++ )\n            printf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\n        printf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n                if( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\n        printf( \"%d %d\\n\", s, t );\n\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    const int MAXW = 100;\n\n    int A, B;\n    cin >> A >> B;\n\n    vvi d(A + 1, vi(B + 1));\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++)\n            cin >> d[i][j];\n    }\n\n    vvi c(MAXW + 1, vi(MAXW + 1));\n    for (int xc = 0; xc <= MAXW; xc++) {\n        for (int yc = 0; yc <= MAXW; yc++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[xc][yc] = max(c[xc][yc], d[x][y] - xc * x - yc * y);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int sp = INT_MAX;\n            for (int xc = 0; xc <= MAXW; xc++) {\n                for (int yc = 0; yc <= MAXW; yc++) {\n                    sp = min(sp, xc * x + yc * y + c[xc][yc]);\n                }\n            }\n            if (sp != d[x][y]) { cout << \"Impossible\\n\"; return 0; }\n        }\n    }\n\n    int XL = 1, YL = XL + MAXW + 1;\n    int V = YL + MAXW + 1, E = MAXW + MAXW + (MAXW + 1) * (MAXW + 1);\n\n    cout << \"Possible\\n\";\n    cout << V << \" \" << E << \"\\n\";\n    for (int xc = 1; xc <= MAXW; xc++)\n        cout << (XL + xc - 1) << \" \" << (XL + xc) << \" X\\n\";\n    for (int yc = 0; yc < MAXW; yc++)\n        cout << (YL + yc + 1) << \" \" << (YL + yc) << \" Y\\n\";\n    for (int xc = 0; xc <= MAXW; xc++)\n        for (int yc = 0; yc <= MAXW; yc++)\n            cout << (XL + xc) << \" \" << (YL + yc) << \" \" << c[xc][yc] << \"\\n\";\n\n    cout << 1 << \" \" << YL << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N;\nint A, B;\nint Matrix[15][15];\nvector <pair <int, int> > G[100005];\nint D[15][15], Cost[305][305];\nint cnt;\nvoid Read()\n{\n    cin >> A >> B;\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n            cin >> Matrix[i][j];\n}\n\nvoid precalcG()\n{\n    cnt = 1;\n    int last = 1;\n    int lastS, M = 0;\n    for(int i = 1; i <= 101; i++)\n    {\n        ++cnt;\n        G[last].push_back(make_pair(cnt, -1));\n        ++M;\n        last = cnt;\n        lastS = cnt;\n    }\n    ++cnt;\n    last = cnt;\n    ++cnt;\n    G[last].push_back(make_pair(cnt, -2));\n    ++M;\n    for(int i = 2; i <= 101; i++)\n    {\n        ++cnt;\n        G[last].push_back(make_pair(cnt, -2));++M;\n        last = cnt;\n    }\n    for(int i = 1; i <= lastS; i++)\n    {\n        for(int j = lastS + 1; j <= cnt; j++)\n        {\n            int coefx = i - 1, coefy = cnt - j;\n            int val = 0;\n            for(int a = 1; a <= A; a++)\n                for(int b = 1; b <= B; b++)\n                    val = max(val, max(0, Matrix[a][b] - coefx * a - coefy * b));\n            Cost[i][j] = val;\n            G[i].push_back(make_pair(j, val));++M;\n        }\n    }\n    for(int a = 1; a <= A; a++)\n        for(int b = 1; b <= B; b++)\n    {\n        D[a][b] = 105;\n        for(int i = 1; i <= lastS; i++)\n            for(int j = lastS + 1; j <= cnt; j++)\n            {\n                int coefx = i - 1, coefy = cnt - j;\n                D[a][b] = min(D[a][b], coefx * a + coefy * b + Cost[i][j]);\n            }\n        if(D[a][b] != Matrix[a][b])\n        {\n            cout << \"Impossible\\n\";\n            return;\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << cnt << \" \" << M << \"\\n\";\n    for(int i = 1; i <= cnt; i++)\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            int neighb = G[i][j].first, val = G[i][j].second;\n            cout << i << \" \" << neighb << \" \";\n            if(val >= 0)\n                cout << val;\n            if(val == -1)\n                cout << \"X\";\n            if(val == -2)\n                cout << \"Y\";\n            cout << \"\\n\";\n        }\n    cout << \"1 \" << cnt << '\\n';\n}\nint main()\n{\n    Read();\n    precalcG();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nusing Data = pair<pii, int>;\nusing Edge = pair<pii, char>;\n\nint A;\nint B;\nint d[114][114];\n\nvoid Output(vector<Data> &ds) {\n  int N = 200;\n  vector<Edge> es;\n\n  puts(\"Possible\");\n  rep(i, 100) {\n    es.eb(Edge(pii(i, i+1), 'X'));\n    es.eb(Edge(pii(i+100, i+101), 'Y'));\n  }\n\n  map<pii, int> cnt;\n  for (auto &d : ds) {\n    int p, q;\n    tie(p, q) = d.X;\n    assert(!cnt.count(d.X));\n    cnt[d.X]++;\n    assert(p <= 100 && q <= 100);\n    int t = d.Y;\n    es.eb(Edge(pii(p, N-1-q), -t));\n  }\n\n  cout << N << \" \" << es.size() << endl;\n  for (auto &e : es) {\n    int u, v;\n    tie(u, v) = e.X;\n    char c = e.Y;\n    if (c <= 0) {\n      int l = -c;\n      cout << u+1 << \" \" << v+1 << \" \" << l << endl;\n    } else {\n      assert(c == 'X' || c == 'Y');\n      cout << u+1 << \" \" << v+1 << \" \" << c << endl;\n    }\n  }\n  cout << 1 << \" \" << N << endl;\n}\n\nint main() {\n  cin >> A >> B;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      cin >> d[i][j];\n    }\n  }\n\n  vector<Data> ds;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      int p = 1000;\n      int q = 1000;\n      rep(a, 101) {\n        rep(b, 101) {\n          int t = d[i][j] - a*i - b*j;\n          if (t < 0) break;\n\n          bool ok = true;\n          reps(k, 1, A+1) {\n            reps(l, 1, B+1) {\n              if ((k-i)*a + (l-j)*b < d[k][l] - d[i][j]) {\n                ok = false;\n                goto L_OUT;\n              }\n            }\n          }\nL_OUT:\n          if (ok) {\n            if (p+q > a+b) {\n              p = a;\n              q = b;\n            }\n          }\n        }\n      }\n\n      if (p == 1000) {\n        puts(\"Impossible\");\n        return 0;\n      }\n\n      ds.eb(Data(pii(p, q), d[i][j] - p*i - q*j));\n    }\n  }\n  sort(all(ds));\n  ds.erase(unique(all(ds)), ds.end());\n  Output(ds);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b, d[11][11], ta, tb, tc;\npair< pair< int, int >, int > p[11][11];\nvector< pair< pair< int, int >, int > > v;\nbool u[101][101];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tscanf(\"%d\", d[i] + j), p[i][j].second = -1;\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tta = INT_MIN;\n\t\t\tfor (int ii = 1; ii <= a; ii++)\n\t\t\t\tfor (int jj = 1; jj <= b; jj++)\n\t\t\t\t\tta = max(ta, d[ii][jj] - ii * i - jj * j);\n\t\t\tif (ta >= 0 && ta <= 100)\n\t\t\t\tfor (int ii = 1; ii <= a; ii++)\n\t\t\t\t\tfor (int jj = 1; jj <= b; jj++)\n\t\t\t\t\t\tif (ta == d[ii][jj] - ii * i - jj * j)\n\t\t\t\t\t\t\tp[ii][jj] = make_pair(make_pair(i, j), ta);\n\t\t}\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tif (p[i][j].second == -1) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tfor (int i = 1; i <= 100; i++)\n\t\tv.push_back(make_pair(make_pair(i, i + 1), -1));\n\tfor (int i = 1; i <= 100; i++)\n\t\tv.push_back(make_pair(make_pair(101 + i, 101 + i + 1), -2));\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) {\n\t\t\tta = p[i][j].first.first;\n\t\t\ttb = p[i][j].first.second;\n\t\t\ttc = p[i][j].second;\n\t\t\tif (!u[ta][tb]) {\n\t\t\t\tu[ta][tb] = 1;\n\t\t\t\tv.push_back(make_pair(make_pair(ta + 1, 101 + 100 + 1 - tb), tc));\n\t\t\t}\n\t\t}\n\tprintf(\"%d %d\\n\", 101 + 100 + 1, v.size());\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tprintf(\"%d %d \", v[i].first.first, v[i].first.second);\n\t\tif (v[i].second == -1)\n\t\t\tprintf(\"X\\n\");\n\t\telse if (v[i].second == -2)\n\t\t\tprintf(\"Y\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", v[i].second);\n\t}\n\tprintf(\"%d %d\\n\", 1, 101 + 100 + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 105;\nconst int INF=0x7fffffff;\n\nint n,m,d[N][N],f[N][N];\nbool flag;\n\nint main(){\n    scanf(\"%d %d\",&n,&m);\n    for (register int i=1;i<=n;i++)\n        for (register int j=1;j<=m;j++)\n            scanf(\"%d\",&d[i][j]);\n    \n    for (register int i=0;i<=100;i++)\n        for (register int j=0;j<=100;j++)\n            for (register int x=1;x<=n;x++)\n                for (register int y=1;y<=m;y++)\n                    f[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n    \n    for (register int x=1;x<=n;x++)\n        for (register int y=1;y<=m;y++){\n            int now=INF;\n            for (register int i=0;i<=100;i++)\n                for (register int j=0;j<=100;j++)\n                    now=min(now,i*x+j*y+f[i][j]);\n            if (now!=d[x][y]){ flag=true; goto End; }\n        }\n    \nEnd:\n    if (flag){ printf(\"Impossible\\n\"); return 0; }\n\n    //S:1\n    //T:202\n    //X:[2,101]\n    //Y:[102,202]\n    printf(\"Possible\\n\");\n    printf(\"202 10401\\n\");\n    for (register int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n    for (register int i=102;i<202;i++) printf(\"%d %d Y\\n\",i,i+1);\n    for (register int i=0;i<=100;i++)\n        for (register int j=0;j<=100;j++)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    printf(\"1 202\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int M = 101;\nint A, B;\nint d[M][M];\nint a[M][M];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tscanf(\"%d%d\", &A, &B);\n\tfor (int i = 1; i <= A; i++)\n\t\tfor (int j = 1; j <= B; j++)\n\t\t\tscanf(\"%d\", &d[i][j]);\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++) {\n\t\t\ta[x][y] = 0;\n\t\t\tfor (int i = 1; i <= A; i++)\n\t\t\t\tfor (int j = 1; j <= B; j++) {\n\t\t\t\t\ta[x][y] = max(a[x][y], d[i][j] - i * x - j * y);\n\t\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= A; i++)\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (int x = 0; x < M; x++)\n\t\t\t\tfor (int y = 0; y < M; y++) {\n\t\t\t\t\tif (a[x][y] + i * x + j * y == d[i][j])\n\t\t\t\t\t\tok = true;\n\t\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 2 * M, 2 * M - 2 + M * M);\n\tfor (int i = 0; i < M - 1; i++) {\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\tprintf(\"%d %d Y\\n\", M + i + 1, M + i);\n\t}\n\tfor (int x = 0; x < M; x++)\n\t\tfor (int y = 0; y < M; y++)\n\t\t\tprintf(\"%d %d %d\\n\", x, M + y, a[x][y]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int S = 198, T = 199;\n\txv.push_back(S);\n\tFOR(i, 99) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, 99) yv.push_back(i + 99);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int,int,int>> vp;\n\tFOR(i, 100) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(w, 100) FOR(z, 100) {\n\t\tif (w + z >= 100) continue;\n\t\tint maxdiff = -10000;\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tint xw = w * (i + 1);\n\t\t\tint yw = z * (j + 1);\n\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\tchmax(maxdiff, additional);\n\t\t}\n\t\tif (maxdiff >= 0) {\n\t\t\tint from = xv[w], to = yv[100 - z];\n\t\t\t// printf(\"%dx + %dy + %d\\n\", w, z, maxdiff);\n\t\t\tvp.emplace_back(from, to, maxdiff);\n\t\t}\n\t}\n\n\t//FOR(i, a) FOR(j, b) {\n\t//\tint minad = 12345;\n\t//\tint cxw = minx[i][j], cyw = miny[i][j];\n\t//\tfor (int w = minx[i][j]; w <= 100; w++) {\n\t//\t\tfor (int z = miny[i][j]; z <= 100; z++) {\n\t//\t\t\tint xw = w * (i + 1);\n\t//\t\t\tint yw = z * (j + 1);\n\t//\t\t\tint additional = d[i][j] - xw - yw;\n\t//\t\t\tif (additional < 0) {\n\t//\t\t\t\tcontinue;\n\t//\t\t\t}\n\t//\t\t\tif (additional < minad) {\n\t//\t\t\t\tminad = additional;\n\t//\t\t\t\tcxw = w;\n\t//\t\t\t\tcyw = z;\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tif (minad == 12345) {\n\t//\t\tok = false;\n\t//\t\tcontinue;\n\t//\t}\n\t//\tint from = xv[cxw], to = yv[100 - cyw];\n\t//\t// printf(\"%d %d %d\\n\", cxw, cyw, minad);\n\t//\tvp.emplace_back(from, to, minad);\n\t//}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(200);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", 200, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S +1 , T + 1);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+1;\n\t\tnumn+=ans[i].a+ans[i].b;\n\t}\n\tnumn+=2;\n\tif (numn>300) {while(1);printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tprintf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a&&ans[i].b==0)?numn:++t,'X'),pre=t;\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\t{\n\t\t\t\t\tint c=s-a-b;\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\t//cout<<now<<endl;\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll X, Y; cin >> X >> Y;\n    vvll d(X, vll(Y)); cin >> d;\n\n    // X=x, Y=y (1 <= x <= X, 1 <= y <= Y)\n    // a = xの数、b = yの数 (0 <= a, b <= 100)\n    //\n    // for all x,y  \n    //      d_xy = min_ab ax+by+c_ab\n    //\n    // c_ab = max(0, max_xy d_xy - ax - by)\n    ll abmax = 101;\n\n    vvll c(abmax, vll(abmax));\n    rep(a, abmax) rep(b, abmax) {\n        repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n            chmax(c[a][b], d[x-1][y-1]-a*x-b*y);\n        }\n    }\n    repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n        ll tmp = INF;\n        rep(a, abmax) rep(b, abmax) {\n            chmin(tmp, a*x+b*y+c[a][b]);\n        }\n        if (d[x-1][y-1] != tmp) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    ll n = 2 * (abmax+1);\n    ll m = abmax*abmax + abmax * 2;\n            cout << \"Possible\" << endl;\n    cout << n << \" \" << m << endl;\n    rep(i, abmax) {\n        cout << i+1 << \" \" << i+1+1 << \" \" << \"X\" << endl;\n        cout << 2*abmax+1-i-1+1 << \" \" << 2*abmax+1-i+1 << \" \" << \"Y\" << endl;\n    }\n    rep(a, abmax) rep(b, abmax) {\n        cout << a+1 << \" \" << 2 * abmax + 1 - b+1 << \" \" << c[a][b] << endl;\n    }\n    cout << 1 << \" \" << n << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 101;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint A, B;\nint d[N][N];\nint ga[N][N];\nint gb[N][N];\nint gc[N][N];\nbool us[N][N][N];\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> A >> B;\n        for(int i = 1; i <= A; i++){\n                for(int j = 1; j <= B; j++){\n                        cin >> d[i][j];\n                        ga[i][j] = -1;\n                }\n        }\n        vector < int > a, b, c;\n        for(int x = 0; x <= 100; x++){\n                for(int y = 0; y <= 100; y++){\n                        for(int z = 0; z <= 100; z++){\n                                bool good = true;\n                                for(int i = 1; i <= A && good; i++){\n                                        for(int j = 1; j <= B; j++){\n                                                if(i * x + j * y + z < d[i][j]){\n                                                        good = false;\n                                                        break;\n                                                }\n                                        }\n                                }\n                                if(good){\n                                        for(int i = 1; i <= A; i++){\n                                                for(int j = 1; j <= B; j++){\n                                                        if(i * x + j * y + z == d[i][j]){\n                                                                if(ga[i][j] == -1 || x + y < ga[i][j] + gb[i][j]){\n                                                                        ga[i][j] = x;\n                                                                        gb[i][j] = y;\n                                                                        gc[i][j] = z;\n                                                                }\n                                                        }\n                                                }\n                                        }\n                                }\n                        }\n                }\n        }\n        int res = 1;\n        for(int i = 1; i <= A; i++){\n                for(int j = 1; j <= B; j++){\n                        if(ga[i][j] == -1){\n                                cout << \"Impossible\" << \"\\n\";\n                                return 0;\n                        }\n                        int x = ga[i][j], y = gb[i][j], z = gc[i][j];\n                        if(!us[x][y][z]){\n                                us[x][y][z] = 1;\n                                a.push_back(x);\n                                b.push_back(y);\n                                c.push_back(z);\n                        }\n                }\n        }\n\n        int G = 2;\n        vector < pair < pair < int, int >, int > > E;\n        for(int i = 0; i < a.size(); i++){\n                int s = 1;\n                for(int j = 0; j < a[i]; j++){\n                        G += 1;\n                        E.push_back({{s, G}, -1});\n                        s = G;\n                }\n                for(int j = 0; j < b[i]; j++){\n                        G += 1;\n                        E.push_back({{s, G}, -2});\n                        s = G;\n                }\n                E.push_back({{s, 2}, c[i]});\n        }\n        assert(G <= 300);\n        cout << \"Possible\" << \"\\n\";\n        cout << G << \" \" << E.size() << \"\\n\";\n        for(auto p: E){\n                cout << p.fi.fi << ' ' << p.fi.se << ' ';\n                if(p.se == -1){\n                        cout << \"X\\n\";\n                } else if(p.se == -2){\n                        cout << \"Y\\n\";\n                } else{\n                        cout << p.se << \"\\n\";\n                }\n        }\n        cout << \"1 2\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007\n#define lson(v) ((v)<<1)\n#define rson(v) (((v)<<1)^1)\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\ntypedef pair < pii , int > p3i;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint A,B,arr[15][15];\nvector < p3i > paths;\nint main(){\n    // inputing start\n    scanf(\"%d%d\",&A,&B);\n\tint xb,x2,x3,x4,x5,mmax=0,mmay=0;\n\tfor(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tscanf(\"%d\",&arr[xb][x2]);\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    for(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tint a=xb+1,b=x2+1,k=arr[xb][x2],maxy=105,miny=0;\n\t\t\tfor(x5=0;x5<=105;++x5){\n\t\t\t\tmaxy=105;miny=0;\n\t\t\t\tfor(x3=0;x3<A;++x3){\n\t\t\t\t\tfor(x4=0;x4<B;++x4){\n\t\t\t\t\t\tint n=x3+1,m=x4+1,c=arr[x3][x4],coe=m-b,val=c-k-x5*(n-a);\n\t\t\t\t\t\tif(x3==xb && x4==x2){\n\t\t\t\t\t\t\tn=-a;m=-b;c=-k;\n\t\t\t\t\t\t\tcoe=m;\n\t\t\t\t\t\t\tval=c-n*x5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe*val<0){\n\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(val==0){\n\t\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\t\tUMIN(maxy,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe==0){\n\t\t\t\t\t\t\tif(val>0){\n\t\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\tUMIN(maxy,(-val)/(-coe));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe>0){\n\t\t\t\t\t\t\tUMAX(miny,(val+coe-1)/coe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(miny<=maxy){\n\t\t\t\t\tif(k-x5*a-maxy*b>100) continue;\n\t\t\t\t\tpaths.push_back(mpr(mpr(x5,maxy),k-x5*a-maxy*b));\n\t\t\t\t\tUMAX(mmax,x5);\n\t\t\t\t\tUMAX(mmay,maxy);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x5>105){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\tax+by+z=k\n\t\t\t *  -ax-by>=-k\n\t\t\t *   my>=c-nx\n\t\t\t *   coe=m  val=c-nx\n\t\t\t\tz=k-ax-by\n\t\t\t\tnx+my+k-ax-by>=c\n\t\t\t\t(n-a)x+(m-b)y>=c-k  \n\t\t\t\tcoe*y>=val  \n\t\t\t\tor\n\t\t\t\t-coe*y<=-val  */\n\t\t}\n\t}\n\tsort(paths.begin(),paths.end());\n\tpaths.erase(unique(paths.begin(),paths.end()),paths.end());\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",mmax+1+mmay+1,mmax+mmay+(int)paths.size());\n\tfor(xb=0;xb<mmax;++xb){\n\t\tprintf(\"%d %d x\\n\",xb+1,xb+2);\n\t}\n\tfor(xb=mmay-1;xb>=0;--xb){\n\t\tprintf(\"%d %d y\\n\",mmax+xb+3,mmax+xb+2);\n\t}\n\tfor(xb=0;xb<paths.size();++xb){\n\t\tprintf(\"%d %d %d\\n\",paths[xb].first.first+1,paths[xb].first.second+mmax+2,paths[xb].second);\n\t}\n\tprintf(\"%d %d\\n\",1,mmax+2);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>v(H, vector<int>(W));\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tvector<int>from;\n\tvector<int>to;\n\tvector<string>cost;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfrom.push_back(i + 1);\n\t\tto.push_back(i + 2);\n\t\tif (i < 100)cost.push_back(\"X\");\n\t\telse cost.push_back(\"Y\");\n\t}\n\tfor (int i = 0; i < H*W; i++) {\n\t\tint h = i / W;\n\t\tint w = i % W;\n\t\th++;\n\t\tw++;\n\t\tint nj = -1;\n\t\tint nk = -1;\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int k = 0; j + k <= 100; k++) {\n\t\t\t\tint add = v[h - 1][w - 1] - j * h - k * w;\n\t\t\t\tif (add < 0)continue;\n\t\t\t\tif (!i&&add)continue;\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = 0; l < H*W; l++) {\n\t\t\t\t\tif (i == l)continue;\n\t\t\t\t\tint nh = l / W;\n\t\t\t\t\tint nw = l % W;\n\t\t\t\t\tnh++;\n\t\t\t\t\tnw++;\n\t\t\t\t\tif (j*nh + k * nw + add < v[nh - 1][nw - 1]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tnj = j;\n\t\t\t\t\tnk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nj == -1) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << i << endl;\n\t\tif (!i) {\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(0));\n\t\t}\n\t\telse {\n\t\t//\tcout << i << endl;\n\t\t\tfrom.push_back(nj + 1);\n\t\t\tto.push_back(201 + i);\n\t\t\tcost.push_back(to_string(0));\n\t\t\tfrom.push_back(201 + i);\n\t\t\tto.push_back(201 - nk);\n\t\t\tcost.push_back(to_string(v[h - 1][w - 1] - nj * h - nk * w));\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 + N << \" \" << from.size() << endl;\n\tfor (int i = 0; i < from.size(); i++) {\n\t\tcout << from[i] << \" \" << to[i] << \" \" << cost[i] << endl;\n\t}\n\tcout << 1 << \" \" << 201 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 105;\nconst int INF = 1e9;\n\nint A,B;\nint d[11][11];\nint f[N][N];\nint m,ed[N*4][3];\nbool bz[11][11];\nbool v[N][N];\nint n;\nint id0[N],id1[N],S,T;\n\nint main(){\n\tA=get();B=get();\n\tfo(i,1,A)fo(j,1,B)d[i][j]=get();\n\tfo(i,0,100)\n\t\tfo(j,0,100){\n\t\t\tf[i][j]=-INF;\n\t\t\tfo(x,1,A)\n\t\t\t\tfo(y,1,B)\n\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-x*i-y*j);\n\t\t}\n\tint cnt=0;\n\tS=n=1;\n\tfo(i,0,100)id0[i]=++n;\n\tfo(i,0,100)id1[i]=++n;\n\tT=++n;\n\ted[m=1][0]=S;ed[1][1]=id0[0];ed[1][2]=0;\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id0[i];ed[m][1]=id0[i+1];ed[m][2]=-1;\n\t}\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id1[i+1];ed[m][1]=id1[i];ed[m][2]=-2;\n\t}\n\tm++;\n\ted[m][0]=id1[0];ed[m][1]=T;ed[m][2]=0;\n\twhile(cnt<A*B){\n\t\tbool pd=0;\n\t\tfo(i,0,100){\n\t\t\tfo(j,0,100)\n\t\t\tif (!v[i][j]&&f[i][j]<=100&&f[i][j]>=0){\n\t\t\t\tint ct=0;\n\t\t\t\tfo(x,1,A)\n\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\tif (!bz[x][y]&&d[x][y]-x*i-y*j==f[i][j])ct++;\n\t\t\t\tif (ct){\n\t\t\t\t\tpd=1;\n\t\t\t\t\tfo(x,1,A)\n\t\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\t\tif (d[x][y]-x*i-y*j==f[i][j])bz[x][y]=1;\n\t\t\t\t\ted[++m][0]=id0[i];ed[m][1]=id1[j];ed[m][2]=f[i][j];\n\t\t\t\t\tcnt=cnt+ct;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse v[i][j]=1;\n\t\t\t}\n\t\t\tif (pd)break;\n\t\t}\n\t\tif (!pd)break;\n\t}\n\tif (cnt!=A*B)printf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"Possbile\\n\");\n\t\tprintf(\"%d %d\\n\",n,m);\n\t\tfo(i,1,m){\n\t\t\tprintf(\"%d %d \",ed[i][0],ed[i][1]);\n\t\t\tif (ed[i][2]==-1)printf(\"X\\n\");\n\t\t\tif (ed[i][2]==-2)printf(\"Y\\n\");\n\t\t\tif (ed[i][2]>=0)printf(\"%d\\n\",ed[i][2]);\n\t\t}\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\n#define B cerr<<\"Break Point\"<<endl;\n\nconstexpr int N=15;\nconstexpr int M=105;\n\nint n,m;\nint d[N][N];\nint f[M][M];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i)\n        for(int j=1;j<=m;++j)\n            scanf(\"%d\",&d[i][j]);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            for(int x=1;x<=n;++x)\n                for(int y=1;y<=m;++y)\n                    f[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n    for(int x=1;x<=n;++x)\n        for(int y=1;y<=m;++y)\n        {\n            int nowdis=1e9;\n            for(int i=0;i<=100;++i)\n                for(int j=0;j<=100;++j)\n                    nowdis=min(nowdis,f[i][j]+i*x+j*y);\n            if(nowdis!=d[x][y])\n            {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    printf(\"Possible\\n\");\n    printf(\"%d %d\\n\",202,10401);\n    for(int i=1;i<=100;++i) printf(\"%d %d X\\n\",i,i+1);\n    for(int i=102;i<=201;++i) printf(\"%d %d Y\\n\",i,i+1);\n    for(int i=0;i<=100;++i)\n        for(int j=0;j<=100;++j)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    printf(\"%d %d\\n\",1,202);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nll mp[11][11];\nll dist[222][222];\nll mi[22][22];\n\nint main()\n{\n\tint a,b;cin >> a >> b;\n\tREP(i,22)REP(j,22)mi[i][j] = 10000;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\t\n\tREP(i,101)\n\t{\n\t\tREP(j,101)\n\t\t{\n\t\t\tll tmp = 0;\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\ttmp = max(tmp,mp[x][y]-(i*(x+1))-(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\tmi[x][y] = min(mi[x][y],tmp+(i*(x+1))+(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdist[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tif(mi[i][j] != mp[i][j])\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(!flag)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t\n\t\tcout << 1 << ' ' << 202 << endl;\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+1 << ' ' << i+2 << ' ' << 'X' << endl;\n\t\t}\n\t\t\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+102 << ' ' << i+103 << ' ' << 'X' << endl;\n\t\t}\n\t\t\n\t\tREP(i,101)\n\t\t{\n\t\t\tREP(j,101)\n\t\t\t{\n\t\t\t\tcout << 1+i << ' ' << 202-j << ' ' << dist[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 303, M = 100;\nint a, b, d[14][14], C[M+3][M+3], sz = 1;\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int as = 0; as <= M; as++) {\n\t\tfor(int bs = 0; bs <= M; bs++) {\n\t\t\tint mn = 0;\n\t\t\tfor(int i =1; i <= a; i++)\n\t\t\t\tfor(int j = 1; j <= b; j++)\n\t\t\t\t\tmn = max(mn, d[i][j] - as*i - bs*j);\n\t\t\tC[as][bs] = mn;\n\t\t}\n\t}\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++) {\n\t\t\tint cst = 1<<30;\n\t\t\tfor(int as = 0; as <= M; as++)\n\t\t\t\tfor(int bs = 0; bs <= M; bs++)\n\t\t\t\t\tcst = min(cst, as*i + bs*j + C[as][bs]);\n\t\t\tif(cst != d[i][j]) return cout << \"Impossible\\n\", 0;\n\t\t}\n\t\n\tcout << \"Possible\\n\";\n\tcout << 2*M+2 << \" \" << (M+1)*(M+1) + 2*M << '\\n';\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" X\\n\", sz++;\n\tsz++;\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" Y\\n\", sz++;\n\tfor(int i = 0; i <= M; i++)\n\t\tfor(int j = 0; j <= M; j++)\n\t\t\tcout << 1+i << \" \" << M+2+j << \" \" << C[i][j] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i<<\" \"<<j<<\":\"<<dist<<\":\"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <limits>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\nconstexpr int INF = std::numeric_limits<int>::max()>>2;\n\nint A, B;\nint d[10][10];\nint c[100][100];\n\nint main()\n{\n  scanf( \"%d%d\", &A, &B );\n  rep( i, A ) rep( j, B )\n    scanf( \"%d\", &d[i][j] );\n\n  rep( i, 101 ) rep( j, 101 )\n  {\n    rep( a, A ) rep( b, B )\n      c[i][j] = std::max( c[i][j], d[a][b]-i*a-j*b );\n  }\n\n  bool fl = true;\n  rep( a, A ) rep( b, B )\n  {\n    int D = INF;\n    rep( i, 101 ) rep( j, 101 )\n      D = std::min( D, i*a+j*b+c[i][j] );\n    \n    fl &= D == d[a][b];\n  }\n\n  if( !fl )\n    puts( \"Impossible\" );\n  else\n  {\n    puts( \"Possible\" );\n  \n    printf( \"%d %d\\n\", 202, 101*101+200 );\n\n    rep( i, 100 )\n      printf( \"%d %d X\\n\", i+1, i+2 );\n    rep( i, 100 )\n      printf( \"%d %d Y\\n\", i+102, i+103 );  \n    rep( i, 101 ) rep( j, 101 )\n      printf( \"%d %d %d\\n\", i+1, 202-j, c[i][j] );\n    printf( \"%d %d\\n\", 1, 202 );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            int ma=0;\n            rep(k,i,a){\n                rep(l,j,b){\n                    if(k==i&&l==j)continue;\n                    int mi=1000000000;\n                    int ddx=0,ddy=0;\n                    rep(ii,0,100){\n                        int zx=ii*(k-i);\n                        int noko=d[k][l]-d[i][j]-zx;\n                        int say=l-j;\n                        if(say==0){\n                            if(noko<=0){\n                                if(mi>zx*(i+1)){\n                                    mi=zx*(i+1);\n                                    ddx=zx;\n                                    ddy=0;\n                                }\n                                break;\n                            }\n                        }\n                        else{\n                            int zy=(noko+say-1)/say;\n                            if(noko<=0)zy=0;\n                            if(mi>zx*(i+1)+zy*(j+1)){\n                                mi=zx*(i+1)+zy*(j+1);\n                                ddx=zx;\n                                ddy=zy;\n                            }\n                            if(noko<=0)break;\n                        }\n                    }\n                    if(mi>ma){\n                        ma=mi;\n                        dx=ddx;\n                        dy=ddy;\n                    }\n                }\n            }\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define gt getchar()\n#define ll long long\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef std::pair<int,int> P;\n#define mk std::make_pair\n#define fr first\n#define sc second\ninline int in()\n{\n\tint k=0;char ch=gt;bool p=1;\n\twhile(ch<'-')ch=gt;if(ch=='-')ch=gt,p=0;\n\twhile(ch>'-')k=k*10+ch-'0',ch=gt;\n\treturn p?k:-k;\n}\nconst int N=105;\nint f[N][N],d[N][N];\nint main()\n{\n\tint n=in(),m=in();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\td[i][j]=in();\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tfor(int a=1;a<=n;++a)\n\t\t\t\tfor(int b=1;b<=m;++b)\n\t\t\t\t\tf[i][j]=std::max(f[i][j],d[a][b]-a*i-b*j);\n\tfor(int a=1;a<=n;++a)\n\t\tfor(int b=1;b<=m;++b)\n\t\t{\n\t\t\tint mi=1e9;\n\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\tmi=std::min(mi,f[i][j]+a*i+b*j);\n\t\t\tif(mi!=d[a][b])return puts(\"Impossible\"),0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(int i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=1;i<=100;++i)printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int a, b; cin >> a >> b;\n  VV<> d; assign(d, a + 1, b + 1, 0);\n  for (int x = 1; x <= a; ++x) for (int y = 1; y <= b; ++y) cin >> d[x][y];\n  VV<> c; assign(c, 101, 101, 0);\n  for (int i = 0; i <= 100; ++i) for (int j = 0; j <= 100; ++j) {\n    for (int x = 1; x <= a; ++x) for (int y = 1; y <= b; ++y) {\n      c[i][j] = max(c[i][j], d[x][y] - i * x - j * y);\n    }\n  }\n  for (int x = 1; x <= a; ++x) for (int y = 1; y <= b; ++y) {\n    int mn = 1e9;\n    for (int i = 0; i <= 100; ++i) for (int j = 0; j <= 100; ++j) {\n      mn = min(mn, i * x + j * y + c[i][j]);\n    }\n    if (d[x][y] != mn) return cout << \"Impossible\" << '\\n', 0;\n  }\n  cout << \"Possible\" << '\\n';\n  int n = 202, m = 100 + 100 + 101 * 101;\n  cout << n << ' ' << m << '\\n';\n  for (int i = 1; i <= 100; ++i) cout << i << ' ' << i + 1 << \" X\\n\";\n  for (int i = 102; i < 202; ++i) cout << i << ' ' << i + 1 << \" Y\\n\";\n  for (int i = 0; i <= 100; ++i) for (int j = 0; j <= 100; ++j) {\n    cout << i + 1 << ' ' << 202 - j << ' ' << c[i][j] << '\\n';\n  }\n  cout << 1 << ' ' << 202 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nint main()\n{\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\n// struct edge {\n//   ll v, dist;\n// };\n//\n// struct state {\n//   ll v, cost;\n//\n//   bool operator>(const state s) const {\n//     return cost > s.cost;\n//   }\n// };\n//\n// vector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n//   vector<ll> dp(E.size(), INF);\n//   priority_queue<state, vector<state>, greater<state> > q;\n//   q.push((state) { S, 0 });\n//\n//   while(!q.empty()) {\n//     ll v = q.top().v, cost = q.top().cost;\n//     q.pop();\n//\n//     if(dp[v] <= cost) continue;\n//     dp[v] = cost;\n//\n//     REP(i, 0, E[v].size()) {\n//       ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n//       if(dp[nv] > ncost) q.push((state) { nv, ncost });\n//     }\n//   }\n//\n//   return dp;\n// }\n\nint main(void) {\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct data { ll x, y, z; };\n  vector<data> e;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(x, 0, 101) REP(y, 0, 101) REP(z, 0, 100 + 1) {\n    bool f = true;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      f = f && D[a][b] <= v;\n    }\n    if(!f) continue;\n    ll cnt = 0;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      if(!ok[a][b] && D[a][b] == v) {\n        ok[a][b] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) e.push_back((data) { x, y, z });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  ll N = 22, M = 20 + e.size(), S = 1, T = 12;\n  cout << \"Possible\" << endl;\n  cout << N << \" \" << M << endl;\n  REP(i, S, S + 10) cout << i << \" \" << i + 1 << \" X\" << endl;\n  REP(i, T, T + 10) cout << i + 1 << \" \" << i << \" Y\" << endl;\n  REP(i, 0, e.size()) cout << S + e[i].x << \" \" << T + e[i].y << \" \" << e[i].z << endl;\n  cout << S << \" \" << T << endl;\n\n  // REP(x, 1, A + 1) REP(y, 1, B + 1) {\n  //   vector< vector<edge> > E(N + 1);\n  //   REP(i, S, S + 10) E[i].push_back((edge) { i + 1, x });\n  //   REP(i, T, T + 10) E[i + 1].push_back((edge) { i, y });\n  //   REP(i, 0, e.size()) E[S + e[i].x].push_back((edge) { T + e[i].y, e[i].z });\n  //   ll d = dijkstra(E, S)[T];\n  //   assert(d == D[x][y]);\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int a, b; cin>>a>>b;\n  int d[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      cin>>d[i][j];\n    }\n  }\n  int p[2][11][11], q[2][11][11];\n\tfor(int i=1; i<=a; i++){\n      for(int j=1; j<=b; j++){\n        p[0][i][j]=0, p[1][i][j]=1000;\n        q[0][i][j]=0, q[1][i][j]=1000;\n      }\n    }\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      for(int k=1; i-k>0; k++){\n        p[1][i][j]=min(p[1][i][j], (d[i][j]-d[i-k][j])/k);\n      }\n      for(int k=1; i+k<=a; k++){\n        p[0][i][j]=max(p[0][i][j], (d[i+k][j]-d[i][j]+k-1)/k);\n      }\n      for(int k=1; j-k>0; k++){\n        q[1][i][j]=min(q[1][i][j], (d[i][j]-d[i][j-k])/k);\n      }\n      for(int k=1; j+k<=b; k++){\n        q[0][i][j]=max(q[0][i][j], (d[i][j+k]-d[i][j]+k-1)/k);\n      }\n    }\n  }\n  int r[11][11];\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      if(p[1][i][j]<0 || p[0][i][j]>p[1][i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      if(q[1][i][j]<0 || q[0][i][j]>q[1][i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      if(p[0][i][j]*i+q[0][i][j]*j>d[i][j]){\n        cout<<\"Impossible\"<<endl;\n        return 0;\n      }\n      r[i][j]=d[i][j]-(p[0][i][j]*i+q[0][i][j]*j);\n    }\n  }\n  int n=202;\n  int s=1, t=n;\n  vector<P> g[205];\n  set<P> st;\n  int m=0;\n  for(int i=1; i<=n/2-1; i++){\n    g[i].push_back(P(i+1, -1)); m++;\n  }\n  for(int i=n/2+1; i<=n-1; i++){\n    g[i].push_back(P(i+1, -2)); m++;\n  }\n  for(int i=1; i<=a; i++){\n    for(int j=1; j<=b; j++){\n      if(st.find(P(1+p[0][i][j], n-q[0][i][j]))!=st.end()) continue;\n      st.insert(P(1+p[0][i][j], n-q[0][i][j]));\n      g[1+p[0][i][j]].push_back(P(n-q[0][i][j], r[i][j])); m++;\n    }\n  }\n  cout<<\"Possible\"<<endl;\n  cout<<n<<\" \"<<m<<endl;\n  for(int i=1; i<=n; i++){\n    for(auto e:g[i]){\n      cout<<i<<\" \"<<e.first<<\" \";\n      if(e.second==-1) cout<<\"X\"<<endl;\n      else if(e.second==-2) cout<<\"Y\"<<endl;\n      else cout<<e.second<<endl;\n    }\n  }\n  cout<<1<<\" \"<<n<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define Maxn 300\n#define Maxk 10\n#define Inf 0x3f3f3f3f\nint f[Maxk+5][Maxk+5];\nint d[Maxk+5][Maxk+5];\n//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 \n//d[x][y]=min{f[i][j]+i*x+j*y}\n//f[i][j]=max{d[x][y]-i*x-j*y}\nint mx(int a,int b){\n\treturn a>b?a:b;\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nstruct Edge{\n\tint u,v,w;\n}edge[Maxn<<2|5];\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now;\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tnow=Inf;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\t\tnow=mn(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint tot=1;\n\tputs(\"Possible\");\n\tint len=0;\n\tfor(int i=1;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-1;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=202;\n\ttot++;\n\tedge[++len].u=1;\n\tedge[len].v=tot;\n\tedge[len].w=-2;\n\tfor(int i=2;i<=100;i++){\n\t\ttot++;\n\t\tedge[++len].u=tot-1;\n\t\tedge[len].v=tot;\n\t\tedge[len].w=-2;\n\t}\n\tedge[++len].u=tot;\n\tedge[len].v=202;\n\tedge[len].w=-2;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tedge[++len].u=i+1;\n\t\t\tedge[len].v=tot-j+1;\n\t\t\tedge[len].w=f[i][j];\n\t\t}\n\t}\n\tprintf(\"202 %d\\n\",len);\n\tfor(int i=1;i<=len;i++){\n\t\tprintf(\"%d %d \",edge[i].u,edge[i].v);\n\t\tif(edge[i].w==-1){\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse if(edge[i].w==-2){\n\t\t\tputs(\"Y\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",edge[i].w);\n\t\t}\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nll mp[11][11];\nll dist[222][222];\nll mi[22][22];\n\nint main()\n{\n\tint a,b;cin >> a >> b;\n\tREP(i,22)REP(j,22)mi[i][j] = 10000;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\t\n\tREP(i,101)\n\t{\n\t\tREP(j,101)\n\t\t{\n\t\t\tll tmp = 0;\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\ttmp = max(tmp,mp[x][y]-(i*(x+1))-(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\tmi[x][y] = min(mi[x][y],tmp+(i*(x+1))+(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdist[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tif(mi[i][j] != mp[i][j])\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(!flag)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\tcout << 202 << ' ' << 10401 << endl;\n\t\t\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+1 << ' ' << i+2 << ' ' << 'X' << endl;\n\t\t}\n\t\t\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+102 << ' ' << i+103 << ' ' << 'Y' << endl;\n\t\t}\n\t\t\n\t\tREP(i,101)\n\t\t{\n\t\t\tREP(j,101)\n\t\t\t{\n\t\t\t\tcout << 1+i << ' ' << 202-j << ' ' << dist[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << ' ' << 202 << endl;\n\t\t\n\t\t/*\n\t\tREP(i,a)\n\t\t{\n\t\t\tREP(j,b)\n\t\t\t{\n\t\t\t\tcout << mi[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\treturn 0;\n\t}\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<utility>\n#include<bitset>\n#include<complex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define REP(i,a,b) for(int i=a; i<=b; ++i)\n#define FOR(i,a,b) for(int i=a; i<b; ++i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 100;\n\nint A, B, dis[12][12];\nint D[maxn + 5][maxn + 5];\n\nint main() {\n    scanf(\"%d%d\", &A, &B);\n    REP(i,1,A) REP(k,1,B) scanf(\"%d\", &dis[i][k]);\n    for(int a = 0; a <= 100; ++a)\n        for(int b = 0; b <= 100; ++b) {\n            REP(i,1,A) REP(k,1,B)\n                D[a][b] = max(D[a][b], dis[i][k] - a*i - b*k);\n            D[a][b] = min(D[a][b], 100);\n        }\n    for(int i = 1; i <= A; ++i)\n        for(int k = 1; k <= B; ++k) {\n            int d = 1 << 30;\n            REP(a,0,100) REP(b,0,100)\n                d = min(d, D[a][b] + a*i + b*k);\n            if(d != dis[i][k]) exit(0 * puts(\"Impossible\"));\n        }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 101*101 + 100*2);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d X\\n\", i, i+1);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d Y\\n\", i+101, i+1+101);\n    for(int i = 0; i <= 100; ++i)\n        for(int k = 0; k <= 100; ++k)\n            printf(\"%d %d %d\\n\", i+1, 101-k + 101, D[i][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nint main() {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        vector<vector<int>> d(a, vector<int> (b));\n        for (int i = 0; i < a; i ++) { \n                for (int j = 0; j < b; j ++) {\n                        scanf(\"%d\", &d[i][j]);\n                }\n        }\n        vector<vector<int>> f(110, vector<int> (110));\n        for (int i = 0; i < 110; i ++) {\n                for (int j = 0; j < 110; j ++) {\n                        for (int k = 0; k < a; k ++) {\n                                for (int l = 0; l < b; l ++) {\n                                        f[i][j] = max(f[i][j], d[k][l] - (k + 1) * i - (l + 1) * j);\n                                }\n                        }\n                }\n        }\n        for (int i = 0; i < a; i ++) {\n                for (int j = 0; j < b; j ++) {\n                        int f2 = 1 << 30;\n                        for (int k = 0; k < 110; k ++) {\n                                for (int l = 0; l < 110; l ++) {\n                                        f2 = min(f2, f[k][l] + k * (i + 1) + l * (j + 1));\n                                }\n                        }\n                        if (f2 != d[i][j]) {\n                                puts(\"Impossible\");\n                                return 0;\n                        }\n                }\n        }\n        puts(\"Possible\");\n        printf(\"%d %d\\n\", 220, 109 + 109 + 110 * 110);\n        for (int i = 0; i < 109; i ++) {\n                printf(\"%d %d X\\n\", i + 1, i + 2);\n        }\n        for (int i = 0; i < 109; i ++) {\n                printf(\"%d %d Y\\n\", i + 111, i + 112);\n        }\n        for (int i = 0; i < 110; i ++) {\n                for (int j = 0; j < 110; j ++) {\n                        printf(\"%d %d %d\\n\", i + 1, 220 - j, f[i][j]);\n                }\n        }\n        printf(\"%d %d\\n\", 1, 220);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    constexpr int max_c = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i + 1], ys[i], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, bool());\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, max_d + 1) REP (j, max_d + 1) if (i + j <= max_d) {\n        REP (c, max_c + 1) {\n            REP (x, a) REP (y, b) {\n                int f = i * (x + 1) + j * (y + 1) + c;\n                if (f < d[x][y]) {\n                    goto invalid;\n                }\n            }\n            int_edge.emplace_back(xs[i], ys[j], c);\n            REP (x, a) REP (y, b) {\n                int f = i * (x + 1) + j * (y + 1) + c;\n                if (f == d[x][y]) {\n                    used[x][y] = true;\n                }\n            }\n            break;\ninvalid: ;\n        }\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s << ' ' << t << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        cout << \"Possible\" << endl;\n        cout << n << \" \" << edges.size() << endl;\n        each(e, edges) {\n            cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint d[11][11];\nint dist[101][101];\nint done[11][11];\nint main() {\n\tint A,B;\n\tcin >> A >> B;\n\tfor(int i=1;i<=A;i++){\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<101;i++){\n\t\tfor(int j=0;j<101;j++){\n\t\t\tint m=0;\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tm=max(m,d[x][y]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tif(m==d[x][y]-x*i-y*j){\n\t\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i][j]=m;\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++){\n\t\tfor(int y=1;y<=B;y++){\n\t\t\tif(!done[x][y]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << 2*100+101*101 << endl;\n\tfor(int i=0;i<100;i++){\n\t\tcout << i+1 << \" \" << i+2 << \" X\" << endl;\n\t}\n\tfor(int i=0;i<100;i++){\n\t\tcout << i+102 << \" \" << i+103 << \" Y\" << endl;\n\t}\n\tfor(int i=0;i<101;i++){\n\t\tfor(int j=0;j<101;j++){\n\t\t\tcout << i+1 << \" \" << j+102 << \" \" << dist[i][j] << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 102 << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define F first\n#define S second\n#define pb push_back\nconst int N=11, INF=1e9;\nusing namespace std;\nint a, b, d[N][N], x[N][N], y[N][N], nodes = 2;\nstruct func\n{\n    int xc, yc, k;\n};\nstruct edge\n{\n    int x, y, c;\n};\nvector<func> v;\nvector<edge> ans;\nsigned main()\n{\n    cin >> a >> b;\n    for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for(int i = 1; i <= a; i++)\n    {  \n        for(int j = 1; j <= b; j++)\n        {\n            int chk = 1; // 0 - lost hope, 1 - need to add new node/edges, 2 - already done\n            for(auto it: v)\n            {\n                if(it.xc * i + it.yc * j + it.k == d[i][j])\n                {\n                    chk = 2;\n                }\n                if(it.xc * i + it.yc * j + it.k < d[i][j])\n                {\n                    chk = 0;\n                    break;\n                }\n            }\n            if(chk==0)\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            else if(chk==2)\n            {\n                continue;\n            }\n            for(int it = j+1; it <= b; it++)\n            {\n                int delta = d[i][it] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-j;\n                y[i][j] = max(delta/k + (delta%k!=0), y[i][j]);\n            }\n            for(int it = i+1; it <= a; it++)\n            {\n                int delta = d[it][j] - d[i][j];\n                if(delta<0)\n                {\n                    cout << \"Impossible\";\n                    return 0;\n                }\n                int k = it-i;\n                x[i][j] = max(delta/k + (delta%k!=0), x[i][j]);\n            }\n            int cost = x[i][j]*i + y[i][j]*j;\n            if(cost>d[i][j])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n            v.pb({x[i][j], y[i][j], d[i][j] - cost});\n        }\n    }\n   /* for(int i = 1; i <= a; i++)\n    {\n        for(int j = 1; j <= b; j++)\n        {\n            cout << i << \" \" << j << \" - \" << x[i][j] << \" \" << y[i][j] << endl;\n        }\n    }*/\n    for(auto it: v)\n    {\n        int curr = 1;\n        for(int i = 0; i < it.xc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 101});\n            curr = nodes;\n        }\n        for(int i = 0; i < it.yc; i++)\n        {\n            nodes++;\n            ans.pb({curr, nodes, 102});\n            curr = nodes;\n        }\n        ans.pb({curr, 2, it.k});\n    }\n    cout << \"Possible\" << endl;\n    cout << nodes << \" \" << ans.size() << endl;\n    for(auto it: ans)\n    {\n        cout << it.x << \" \" << it.y << \" \";\n        if(it.c==101) cout << 'X';\n        else if(it.c==102) cout << 'Y';\n        else cout << it.c;\n        cout << endl;\n    }\n    cout << 1 << \" \" << 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nbool exi[301][301];\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 202, cur = 3;\n\tRep1(i, 2, 101) {\n\t\tv.push_back({ i - 1,i,\"X\" });\n\t}\n\tRep1(i, 102, 201) {\n\t\tv.push_back({ i,i + 1,\"Y\" });\n\t}\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\trep(k, 101) {\n\t\t\t\tint l = k;\n\t\t\t\tif (l*i > d[i][j]) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t\tint r = (d[i][j] - l*i) / j;\n\t\t\t\tint z = d[i][j] - l*i - r * j;\n\t\t\t\tbool f = true;\n\t\t\t\trep1(i_, a) {\n\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tint sta = 1 + l;\n\t\t\t\t\tint goa = 202 - r;\n\t\t\t\t\tif(!exi[sta][goa])v.push_back({ sta,goa,to_string(z) });\n\t\t\t\t\texi[sta][goa] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == 100)valid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << cur - 1 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 202\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <time.h>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdlib.h>\n#include <deque>\n#include <iomanip>\n#include <complex>\n//#include <ext/rope>\n\nusing namespace std;\n//using namespace __gnu_cxx;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fast_read cin.sync_with_stdio(0)\n#define PREX(number) cout << fixed << setprecision(number)\n#define nul point(0, 0)\n#define random srand(time(NULL))\n#define rand_int abs((rand() << 15) | rand())\n#define str_to_int(stroka) atoi(stroka.c_str())\n#define str_to_ll(stroka) atoll(stroka.c_str())\n#define str_to_double(stroka) atof(stroka.c_str())\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; forn(i, 0, number) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); forn(i, 0, number) solve()\n\n//easy functions\ntemplate< typename T >\nT gcd(T a, T b) { return a ? gcd(b % a, a) : b; }\ntemplate< typename T >\nT lcm(T a, T b) { return (a / gcd(a, b)) * b; }\nbool is_down(char x) { return ('a' <= x && x <= 'z'); }\nbool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\nbool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//constants\nconst ld pi = 3.141592653589793238462643383279;\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ld zero = 0;\nconst ll INF = 1e18;\nconst int COUT = 30;\nconst int prost = 239;\nconst ll prost64 = 239;\nconst int two = 2;\nconst int thr = 3;\nconst ll sr = 31;\nconst int MOD = 1e9 + 7;\nconst int BIG = 2 * 1e9 + 1;\nconst int alf = 26;\nconst int MAX_N = 2 * 1e5 + 10;\nconst int MAX_M = 11;\nconst int MAX_T = (1 << 20);\nconst int BLOCK = trunc(sqrt(MAX_N)) + 1;\nconst int MAX_LOG = 19;\nconst int km = (1 << 18);\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int bit_max = 32;\nconst int dig = 10;\nconst string str_alf = \"abcdefghijklmnopqrstuvwxyz\";\nconst string str_alf_big = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n// Code starts here\n\nint n, m, d[MAX_M][MAX_M];\nbool used[MAX_M][MAX_M];\n\nbool check(int a, int b, int c)\n{\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            int now = (x * a + y * b + c);\n            if (now < d[x - 1][y - 1])\n                return false;\n        }\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            int now = (x * a + y * b + c);\n            if (d[x - 1][y - 1] == now)\n                used[x - 1][y - 1] = true;\n        }\n    return 1;\n}\n\nint main()\n{   /*\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif /**/\n    fast_read;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            cin >> d[i][j];\n    vector<tuple<int, int, int> > ans;\n    for (int a = 0; a <= 100; a++)\n        for (int b = 0; b <= 100; b++)\n            for (int c = 0; c <= 100; c++)\n                if (check(a, b, c))\n                {\n                    ans.push_back(make_tuple(a, b, c));\n                    break;\n                }\n    bool ch = true;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            ch &= used[i][j];\n    if (!ch)\n    {\n        cout << \"Impossible\";\n        return 0;\n    }\n    cout << \"Possible\\n\";\n    int N = (202);\n    vector<tuple<int, int, int> > r;\n    for (tuple<int, int, int> t : ans)\n        r.push_back(make_tuple(get<0>(t), (100 - get<1>(t)) + 101, get<2>(t)));\n    cout << N << \" \" << r.size() + 200 << \"\\n\";\n    for (tuple<int, int, int> t : r)\n        cout << get<0>(t) + 1 << \" \" << get<1>(t) + 1 << \" \" << get<2>(t) << \"\\n\";\n    for (int i = 0; i < 100; i++)\n        cout << i + 1 << \" \" << i + 2 << \" \" << \"X\\n\";\n    for (int i = 0; i < 100; i++)\n        cout << i + 1 + 101 << \" \" << i + 2 + 101 << \" \" << \"Y\\n\";\n    cout << \"1 202\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<vector>\n#include<stack>\n#include<cmath>\n#include<random>\n//This code is written by Itst\nusing namespace std;\n\ninline int read(){\n    int a = 0;\n    char c = getchar();\n    bool f = 0;\n    while(!isdigit(c) && c != EOF)\n        c = getchar();\n    if(c == EOF)\n        exit(0);\n    while(isdigit(c)){\n\ta = a * 10 + c - 48;\n        c = getchar();\n    }\n    return f ? -a : a;\n}\n\nint d[12][12] , f[107][107];\n\nsigned main(){\n    int A = read() , B = read();\n    for(int i = 1 ; i <= A ; ++i)\n\tfor(int j = 1 ; j <= B ; ++j)\n\t    d[i][j] = read();\n    for(int i = 0 ; i <= 100 ; ++i)\n\tfor(int j = 0 ; j <= 100 ; ++j)\n\t    for(int p = 1 ; p <= A ; ++p)\n\t\tfor(int q = 1 ; q <= B ; ++q)\n\t\t    f[i][j] = max(f[i][j] , d[p][q] - i * p - j * q);\n    for(int i = 1 ; i <= A ; ++i)\n\tfor(int j = 1 ; j <= B ; ++j){\n\t    int minN = 1e9;\n\t    for(int p = 0 ; p <= 100 ; ++p)\n\t\tfor(int q = 0 ; q <= 100 ; ++q)\n\t\t    minN = min(minN , f[p][q] + p * i + q * j);\n\t    if(minN != d[i][j]){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t    }\n\t}\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1 ; i <= 100 ; ++i)\n\tprintf(\"%d %d X\\n\" , i , i + 1);\n    for(int i = 102 ; i < 202 ; ++i)\n\tprintf(\"%d %d Y\\n\" , i , i + 1);\n    for(int i = 0 ; i <= 100 ; ++i)\n\tfor(int j = 0 ; j <= 100 ; ++j)\n\t    printf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nvector <int> dv;\nvector <int> av;\nvector <int> bv;\nint mn, mx;\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nvoid reconstruct(int x1, int y1, int c1, int x2, int y2, int c2) {\n  puts(\"Possible\");\n  // cerr << x1 << \" \" << y1 << \" \" << c1 << \" \" << x2 << \" \" << y2 << \" \" << c2 << endl;\n  int mxX = max(x1, x2);\n  int mxY = max(y1, y2);\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= mxX; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= mxY; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  addEdge(2 + x1, n - 1 - y1, c1);\n\n  if (x2 != -1) {\n    addEdge(2 + x2, n - 1 - y2, c2);\n  }\n\n  addEdge(1, n, mx);\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  exit(0);\n}\n\nvoid go(int x1, int y1, int c1, int pos) {\n  if (pos == sz(dv)) {\n    reconstruct(x1, y1, c1, -1, -1, -1);\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 < dv[pos]) {\n    return;\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 == dv[pos] || dv[pos] == mx) {\n    go(x1, y1, c1, pos + 1);\n  }\n  for (int x2 = 0; x2 <= 100; x2++) {\n    if (av[pos] * x2 > dv[pos]) {\n      continue;\n    }\n    for (int y2 = 0; y2 <= 100; y2++) {\n      if (av[pos] * x2 + bv[pos] * y2 > dv[pos]) {\n        continue;\n      }\n      // if (x2 == 0 && y2 == 0 && dv[pos] != mx) {\n      //   continue;\n      // }\n      int c2 = dv[pos] - (av[pos] * x2 + bv[pos] * y2);\n      bool good = true;\n      for (int i = pos; i < sz(dv); i++) {\n        if (!(x2 * av[i] + y2 * bv[i] + c2 == dv[i] || \n              x1 * av[i] + y1 * bv[i] + c1 == dv[i] ||\n              dv[i] == mx)) {\n          good = false;\n          break;\n        }\n        if (x1 * av[i] + y1 * bv[i] + c1 < dv[i] || x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (!good) {\n        continue;\n      }\n      for (int i = 0; i < pos; i++) {\n        if (x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        reconstruct(x1, y1, c1, x2, y2, c2);\n      }\n    }\n  }\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  mx = -1, mn = 105;\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n      mn = min(mn, d[i][j]);\n      mx = max(mx, d[i][j]);\n    }\n  }\n\n  /* for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      if (j > 0 && d[i][j] < d[i][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n      if (i > 0 && d[i][j] < d[i - 1][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  } */\n\n  if (mn == mx) {\n    puts(\"Possible\");\n    cout << 2 << \" \" << 1 << endl;\n    cout << 1 << \" \" << 2 << \" \" << mx << endl;\n    cout << 1 << \" \" << 2 << endl;\n    return 0;\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      dv.push_back(d[i][j]);\n      av.push_back(i + 1);\n      bv.push_back(j + 1);\n    }\n  }\n\n  for (int x1 = 0; x1 <= 100; x1++) {\n    if (1 * x1 > d[0][0]) {\n      continue;\n    }\n    for (int y1 = 0; y1 <= 100; y1++) {\n      if (1 * x1 + 1 * y1 > d[0][0]) {\n        continue;\n      }\n      // if (x1 == 0 && y1 == 0 && d[0][0] != mx) {\n      //   continue;\n      // }\n      int c1 = d[0][0] - x1 - y1;\n      go(x1, y1, c1, 0);\n    }\n  }\n\n  puts(\"Impossible\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor (int i = 0; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, i + 103, i + 102);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, j + 102, f[i][j]);\n\tputs(\"1 102\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            if (k >= 0 && k < T) {\n                v.push_back(F{i, j, k});\n            }\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    const int N = 300;\n    int t = N - 1;\n    int dd[N][N];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dd[i][j] = INT_MAX;\n        }\n    }\n    for (int i = 0; i < T; ++i) {\n        dd[i][i + 1] = -1;\n    }\n\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        dd[i + YY][i + 1 + YY] = -2;\n    }\n    dd[YY + T][N - 1] = 0;\n\n    for (const auto &f : v) {\n        dd[f.a][YY + T - f.b] = f.c;\n    }\n\n    cout << \"Possible\" << \"\\n\";\n    int esize = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                esize++;\n            }\n        }\n    }\n    cout << t + 1 << \" \" << esize << \"\\n\";\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dd[i][j] < INT_MAX) {\n                cout << i + 1 << \" \" << j + 1 << \" \";\n                if (dd[i][j] >= 0) {\n                    cout << dd[i][j];\n                } else if (dd[i][j] == -1) {\n                    cout << \"X\";\n                } else {\n                    cout << \"Y\";\n                }\n                cout << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << N << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[55];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 55; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  //cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 10;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = -1;\n\t\tbool finish = false;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tif (finish) break;\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  dx = tdx, dy = tdy, se = tse;\n\t\t\t  finish = true;\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (!finish) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\tputs(\"Possible\");\n\t\tint E = 0;\n\t\tfor (int i = 0; i < G.size(); ++i) E += G[i].size();\n\t\tcout << G.size() << \" \" << E << endl;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (int j = 0; j < G[i].size(); ++j) {\n\t\t\tint to = G[i][j].first;\n\t\t\tint w = G[i][j].second;\n\t\t\tcout << i+1 << \" \" << to+1 << \" \";\n\t\t\tif (w == -1) cout << \"X\";\n\t\t\telse if (w == -2) cout << \"Y\";\n\t\t\telse cout << w;\n\t\t\tcout << endl;\n\t\t  }\n\t\t}\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint a, b;\nint d[105][105];\n\nbool ok(int i, int j, int x, int y) {\n  int c = d[i][j] - i*x - j*y;\n  for (int i1 = 1; i1 <= a; ++i1) for (int j1 = 1; j1 <= b; ++j1) {\n    if (c + i1 * x + j1 * y < d[i1][j1]) {\n      return 0;\n    }\n  }\n//  cerr << i << ' ' << j << ' ' << x << ' ' << y << ' ' << c << endl;\n  return 1;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  cin >> a >> b;\n  int maxd = 0;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    cin >> d[i][j];\n    maxd = max(maxd, d[i][j]);\n    if ((i > 1 && d[i][j] < d[i-1][j]) || (j > 1 && d[i][j] < d[i][j-1])) {\n      cout << \"Impossible\\n\"; return 0;\n    }\n  }\n  vector<vii> res(a + 1, vii(b + 1));\n  int T = maxd;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    bool found = 0;\n    for (int x = 0; x <= T && !found; ++x) for (int y = 0; i*x+j*y <= d[i][j]; ++y) {\n      if (ok(i, j, x, y)) {\n        res[i][j] = pii(x, y);\n        found = 1; break;\n      }\n    }\n    if (!found) {\n      cout << \"Impossible\\n\"; return 0;\n    }\n  }\n  cout << \"Possible\\n\";\n  int s = 0, t = 2 * (T + 1) - 1;\n  vector<array<int, 3>> e;\n  for (int i = 0; i < T; ++i) {\n    e.push_back({i, i + 1, -1});\n    e.push_back({t - i - 1, t - i, -2});\n  }\n  set<pii> used;\n  for (int i = 1; i <= a; ++i) for (int j = 1; j <= b; ++j) {\n    if (used.count(res[i][j])) continue;\n    used.insert(res[i][j]);\n    int c = d[i][j] - res[i][j].first * i - res[i][j].second * j;\n    assert(c >= 0 && c <= 100);\n    e.push_back({res[i][j].first, t - res[i][j].second, c});\n  }\n  cout << t + 1 << ' ' << e.size() << endl;\n  for (auto v : e) {\n    cout << v[0] + 1 << ' ' << v[1] + 1 << ' ';\n    if (v[2] >= 0) cout << v[2];\n    else cout << (v[2] == -1 ? \"x\" : \"y\");\n    cout << endl;\n  }\n  cout << s + 1 << ' ' << t + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111;\nint d[maxn][maxn]; // d[x][y] = min x * a + y * b + f[a][b]\nint f[maxn][maxn]; // f[a][b] = max x * a + y * b - d[x][y]\nint S[maxn], T[maxn];\nint main(){\n\tint A, B;\n\tcin >> A >> B;\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tcin >> d[x][y];\n\t\t\tfor(int a = 0; a < maxn; a++){\n\t\t\t\tfor(int b = 0; b < maxn; b++){\n\t\t\t\t\tf[a][b] = max(f[a][b], -(x * a + y * b - d[x][y]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x = 1; x <= A; x++){\n\t\tfor(int y = 1; y <= B; y++){\n\t\t\tint mi = 1<<30;\n\t\t\tfor(int a = 0; a < maxn; a++){\n\t\t\t\tfor(int b = 0; b < maxn; b++){\n\t\t\t\t\tmi = min(mi, x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi != d[x][y]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tint nds = 0;\n\tfor(int i = 0; i < maxn; i++){\n\t\tS[i] = nds++;\n\t\tT[i] = nds++;\n\t}\n\tcout << 2 * maxn << \" \" << 2 * maxn - 2 + maxn * maxn << endl;\n\tfor(int i = 0; i < maxn - 1; i++){\n\t\tcout << S[i] << \" \" << S[i + 1] << \" X\" << endl;\n\t}\n\tfor(int i = maxn - 1; i > 0; i--){\n\t\tcout << T[i] << \" \" << T[i - 1] << \" Y\" << endl; \n\t}\n\tfor(int a = 0; a < maxn; a++){\n\t\tfor(int b = 0; b < maxn; b++){\n\t\t\tcout << S[a] << \" \" << T[b] << \" \" << f[a][b] << endl;\n\t\t}\n\t}\n\tcout << S[0] << \" \" << T[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXXLIM = 10;\nconst int MAXYLIM = 10;\n\nint xlim, ylim;\nint d[MAXXLIM + 1][MAXYLIM + 1];\n\nbool ok(int nx, int ny, int cnst) {\n\tFORE(x, 1, xlim) FORE(y, 1, ylim) {\n\t\tint cur = nx*x + ny*y + cnst;\n\t\tif (cur < d[x][y]) return false;\n\t}\n\treturn true;\n}\n\npair<int, int> search(int cx, int cy) {\n\tfor (int nx = 0; nx*cx <= d[cx][cy]; ++nx) for (int ny = 0; nx*cx + ny*cy <= d[cx][cy]; ++ny) {\n\t\tint cnst = d[cx][cy] - nx*cx - ny*cy;\n\t\tif (ok(nx, ny, cnst)) return MP(nx, ny);\n\t}\n\treturn MP(-1, -1);\n}\n\nmap<pair<int, int>, int> e;\n\nvoid run() {\n\tscanf(\"%d%d\", &xlim, &ylim); FORE(cx, 1, xlim) FORE(cy, 1, ylim) scanf(\"%d\", &d[cx][cy]);\n\tFORE(cx, 1, xlim) FORE(cy, 1, ylim) {\n\t\tpair<int, int> p = search(cx, cy);\n\t\tif (p.first == -1 || p.second == -1) { printf(\"Impossible\\n\"); return; }\n\t\tint cnst = d[cx][cy] - cx*p.first - cy*p.second;\n\t\tif (e.count(p)) assert(e[p] == cnst); else e[p] = cnst;\n\t}\n\tint mxx = 0, mxy = 0; for (auto it = e.begin(); it != e.end(); ++it) { int nx = it->first.first, ny = it->first.second; mxx = max(mxx, nx); mxy = max(mxy, ny); }\n\tvector<int> xid(mxx + 1), yid(mxy + 1); int nid = 0; REPSZ(i, xid) xid[i] = ++nid; REPSZ(i, yid) yid[i] = ++nid;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", nid, mxx + mxy + SZ(e));\n\tREP(i, mxx) printf(\"%d %d X\\n\", xid[i], xid[i + 1]);\n\tREP(i, mxy) printf(\"%d %d Y\\n\", yid[i + 1], yid[i]);\n\tfor (auto it = e.begin(); it != e.end(); ++it) printf(\"%d %d %d\\n\", xid[it->first.first], yid[it->first.second], it->second);\n\tprintf(\"%d %d\\n\", xid[0], yid[0]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\nint main(int argc, char const *argv[]) {\n  // aX + bY + c = d11 不可能な(a, b, c)がわかる\n  // 10000条件×10000試行\n  // 不可能なものを削る\n\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll x = d[1][1];\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n\n  vector<tp> use;\n  for(ll i=0;i<=100;i++){\n    for(ll j=0;j<=100;j++){\n      for(ll k=0;k<=100;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        nxt:;\n      }\n    }\n  }\n\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n\n  throw runtime_error(\"error\");\n  std::cout << \"Possible\" << '\\n';\n  if(x==100){\n    std::cout << \"2 1\" << '\\n';\n    std::cout << \"1 2 100\" << '\\n';\n    std::cout << \"1 2\" << '\\n';\n    return 0;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tvvi c(110,vi(110));\n\trep(i,110)rep(j,110){\n\t\tint ma=0;\n\t\trep(k,n)rep(l,m)ma=max(ma,in[k][l]-i*(k+1)-j*(l+1));\n\t\tc[i][109-j]=ma;\n\t}\n\tbool h=true;\n\trep(i,n)rep(j,m){\n\t\tint mi=inf;\n\t\trep(k,110)rep(l,110)mi=min(mi,(i+1)*k+(j+1)*l+c[k][109-l]);\n\t\tif(mi!=in[i][j])h=false;\n\t}\n\t\n\tif(!h)cout<<\"Impossible\"<<endl;\n\telse{\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<\"220 \"<<n+m+(n+1)*(m+1)<<endl;\n\t\trep(i,109)cout<<1+i<<\" \"<<2+i<<\" X\"<<endl;\n\t\trep(i,109)cout<<219-i<<\" \"<<220-i<<\" Y\"<<endl;\n\t\trep(i,110)rep(j,110){\n\t\t\tcout<<1+i<<\" \"<<n+2+j<<\" \"<<c[i][j]<<endl;\n\t\t}\n\t\tcout<<\"1 220\"<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> II;\n#define fi first\n#define se second\n\nconst int N = 550;\n\nint A, B;\nint n, S, T;\nint nx[N][N], ny[N][N];\nint a[N][N];\n\nbool check(int x, int y, int ni, int nj) {\n\tint rem = a[x][y] - ni * x - nj * y;\n\tif (rem < 0) return false;\n\n\tfor (int i = 1; i <= A; ++i) for (int j = 1; j <= B; ++j) {\n\t\tif (rem + ni * i + nj * j < a[i][j]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) cin >> a[i][j], nx[i][j] = -1, ny[i][j] = -1;\n\t}\t\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tfor (int ni = 0; ni <= 100; ++ni) for (int nj = 0; nj <= 100; ++nj) {\n\t\t\t\tif (check(i, j, ni, nj)) {\n\t\t\t\t\tnx[i][j] = ni, ny[i][j] = nj; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tS = ++n;\n\tT = ++n;\n\tvector<II> X, Y, edges;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (nx[i][j] == -1 || ny[i][j] == -1) return cout << \"Impossible\\n\", 0;\n\n\t\t\tint rem = a[i][j] - nx[i][j] * i - ny[i][j] * j;\n\n\t\t\tint lastS = S;\n\t\t\tfor (int k = 0; k < min(nx[i][j], (int)X.size()); ++k) {\n\t\t\t\tedges.push_back(X[k]);\n\t\t\t\tlastS = X[k].se.se;\n\t\t\t}\n\t\t\tnx[i][j] -= X.size();\n\t\t\twhile (nx[i][j]-- > 0) {\n\t\t\t\t++n; X.push_back(II(-1, ii(lastS, n))); lastS = n;\n\t\t\t\tedges.push_back(X.back());\n\t\t\t}\n\n\n\t\t\tint lastT = T;\n\t\t\tfor (int k = 0; k < min(ny[i][j], (int)Y.size()); ++k) {\n\t\t\t\tedges.push_back(Y[k]);\n\t\t\t\tlastT = Y[k].se.se;\n\t\t\t}\n\t\t\tny[i][j] -= Y.size();\n\t\t\twhile (ny[i][j]-- > 0) {\n\t\t\t\t++n; Y.push_back(II(-2, ii(lastT, n))); lastT = n;\n\t\t\t\tedges.push_back(Y.back());\n\t\t\t}\n\n\t\t\tedges.push_back(II(rem, ii(lastS, lastT)));\n\t\t}\n\t}\n\n\tassert(n <= 300);\n\n\tsort(edges.begin(), edges.end());\n\tedges.erase(unique(edges.begin(), edges.end()), edges.end());\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << edges.size() << endl;\n\tfor (auto e : edges) {\n\t\tcout << e.se.fi << ' ' << e.se.se << ' ';\n\t\tif (e.fi < 0) cout << (e.fi == -1 ? 'X' : 'Y') << endl;\n\t\telse cout << e.fi << endl;\n\t}\n\tcout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint constexpr MAXVAL=100;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> used(MAXVAL+1,std::vector<int>(MAXVAL+1));\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=std::min(sum,MAXVAL);++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint maxd1=INT_MIN;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmaxd1=std::max(maxd1,d1[x][y]-=(x+1)*nx+(y+1)*ny);\n\t\t\t}\n\t\t\tif(maxd1<0)\n\t\t\t\tcontinue; // useless line\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==maxd1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tconnval[nx][ny]=maxd1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tused[0][0]=true;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny]){\n\t\t\tfor(int sumd=1;sumd<=2*MAXVAL;++sumd){\n\t\t\t\tfor(int dx=std::max(0,sumd-ny),\n\t\t\t\t\t\tmax_dx=std::min({MAXVAL,sumd,nx});\n\t\t\t\t\t\tdx<=max_dx;++dx){\n\t\t\t\t\tint dy=sumd-dx; // 0 <= dy && dy <= ny\n\t\t\t\t\tif(used[nx-dx][ny-dy]){\n\t\t\t\t\t\tint nx1=nx,ny1=ny;\n\t\t\t\t\t\twhile(dy--)\n\t\t\t\t\t\t\tused[nx1][--ny1]=true;\n\t\t\t\t\t\twhile(dx--)\n\t\t\t\t\t\t\tused[--nx1][ny1]=true;\n\t\t\t\t\t\tgoto break_outer_2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nbreak_outer_2:;\n\t\t}\n\n\tauto& index=used;\n\tint lastindex=0;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny])\n\t\t\tindex[nx][ny]=++lastindex;\n\n\tint const n_used=lastindex; // 1 .. lastindex\n\tint const n_used_edge=n_used-1;\n\tint const source=1;\n\tint const dest=lastindex+1;\n\n\tstd::cout<<\"Possible\\n\"<<dest+1<<' '<<n_used_edge+n_connedge<<'\\n';\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const curindex=index[nx][ny];\n\t\tif(curindex){\n\t\t\tif(nx!=0&&index[nx-1][ny])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx-1][ny]<<\" X\\n\";\n\t\t\telse if(ny!=0&&index[nx][ny-1])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx][ny-1]<<\" Y\\n\";\n\t\t\telse\n\t\t\t\tassert(nx==0&&ny==0);\n\t\t\tif(connval[nx][ny]>=0)\n\t\t\t\tstd::cout<<curindex<<' '<<dest<<' '<<connval[nx][ny]<<'\\n';\n\t\t}else\n\t\t\tassert(connval[nx][ny]<0);\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  const ll N = 202, S = 1, T = 102, LabelX = -1, LabelY = -2;\n\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct edge { ll u, v, c; };\n  vector<edge> edges;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  ll maxp = 0, maxq = 0;\n  REP(p, 0, 101) REP(q, 0, 101) REP(r, 0, 100 + 1) {\n    bool f = true;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) f = f && D[x][y] <= p * x + q * y + r;\n    if(!f) continue;\n    ll cnt = 0;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      if(!ok[x][y] && D[x][y] == p * x + q * y + r) {\n        ok[x][y] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) {\n      edges.push_back((edge) { S + p, T + q, r });\n      maxp = max(maxp, p);\n      maxq = max(maxq, q);\n    }\n  }\n\n  REP(i, S, S + maxp) edges.push_back((edge) { i, i + 1, LabelX });\n  REP(i, T, T + maxq) edges.push_back((edge) { i + 1, i, LabelY });\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << \"Possible\" << endl;\n    cout << N << \" \" << edges.size() << endl;\n    for(edge e : edges) {\n      if(e.c >= 0) cout << e.u << \" \" << e.v << \" \" << e.c << endl;\n      else cout << e.u << \" \" << e.v << \" \" << (e.c == LabelX ? \"X\" : \"Y\") << endl;\n    }\n    cout << S << \" \" << T << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor (int i = 0; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, i + 103, i + 102);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, j + 102, f[i][j]);\n\tputs(\"1 102\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<P,string> PP;\n\nstring S(ll x){\n  string s;\n  stringstream ss;\n  ss << x;ss >> s;\n  return s;\n}\n\nll N(string s){\n  ll x;\n  stringstream ss;\n  ss << s;ss >> x;\n  return x;\n}\n\nvoid Main() {\n  ll X,Y;\n  cin >> X >> Y;\n  ll a[X+1][Y+1];\n  REP(i,1,X+1)REP(j,1,Y+1) R a[i][j];\n  REP(i,1,X+1) {\n    REP(j,1,Y) {\n      if(a[i][j]>a[i][j+1]) {\n        pr(\"Impossible\");\n        return;\n      }\n    }\n  }\n  REP(j,1,Y+1) {\n    REP(i,1,X) {\n      if(a[i][j]>a[i+1][j]) {\n        pr(\"Impossible\");\n        return;\n      }\n    }\n  }\n  vector<PP> v;\n  map<P,string> mm;\n  ll k=3;\n  REP(x,1,X+1) {\n    REP(y,1,Y+1) {\n      ll d=a[x][y]-x-y;\n      if(d>=0) {\n        v.pb(PP(P(1,k),\"X\"));\n        while(d) {\n          v.pb(PP(P(k,k+1),S(min(100LL,d))));\n          d-=min(100LL,d);\n          k++;\n        }\n        v.pb(PP(P(k,2),\"Y\"));\n        k++;\n      } else {\n        string t=\"X\";\n        d=a[x][y]-x;\n        if(x==X&&y==Y);\n        else if(x==X||a[x][y+1]>=a[x+1][y]) {\n          d=a[x][y]-y;\n          t=\"Y\";\n        }\n        if(d<0) {\n          if(t==\"X\") {\n            d=a[x][y]-y;\n            t=\"Y\";\n          } else {\n            d=a[x][y]-x;\n            t=\"X\";\n          }\n        }\n        if(d<0) {\n          d=a[x][y];\n          t=\"\";\n        }\n        if(t!=\"\") {\n          v.pb(PP(P(1,k),t));\n          v.pb(PP(P(k,2),S(d)));\n          k++;\n        } else {\n          if(mm.count(P(1,2))&&mm[P(1,2)]!=S(d)) {\n            pr(\"Impossible\");\n            return;\n          } \n          v.pb(PP(P(1,2),S(d)));\n          mm[P(1,2)]=S(d);\n        }\n      }\n    }\n  }\n  if(k>301) {\n    pr(\"Impossible\");\n    return;\n  }\n  REP(xx,1,X+1) {\n    REP(yy,1,Y+1) {\n      vector<P> g[k];\n      rep(i,v.size()) {\n        if(v[i].S==\"X\") g[v[i].F.F].pb(P(v[i].F.S,xx));\n        else if(v[i].S==\"Y\") g[v[i].F.F].pb(P(v[i].F.S,yy));\n        else g[v[i].F.F].pb(P(v[i].F.S,N(v[i].S)));\n      }\n      ll d[k];\n      fill(d,d+k,MAX);\n      d[1]=0;\n      priority_queue<P,vector<P>,greater<P> > que;\n      que.push(P(0,1));\n      while(!que.empty()) {\n        P p=que.top();que.pop();\n        ll x=p.S,c=p.F;\n        if(x==2) {\n          if(d[x]!=a[xx][yy]) {\n            pr(\"Impossible\");\n            return;\n          }\n          break;\n        }\n        if(d[x]<c) continue;\n        rep(i,g[x].size()) {\n          P q=g[x][i];\n          ll y=q.F,cc=q.S;\n          if(d[y]>cc+c) {\n            d[y]=cc+c;\n            que.push(P(d[y],y));\n          }\n        }\n      }\n    }\n  }\n  pr(\"Possible\");\n  pr(k-1,v.size());\n  rep(i,v.size()) pr(v[i].F.F,v[i].F.S,v[i].S);\n  pr(1,2);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nint low[123][123],req[12][12];\nint main(){\n    std::ios::sync_with_stdio(false);\n    int a,b;\n    cin>>a>>b;\n    int i,j;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tcin>>req[i][j];\n    \t}\n    }\n    rep(i,101){\n    \trep(j,101){\n    \t\tlow[i][j]=0;\n    \t}\n    }\n    int val,p,q;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q;\n    \t\t\t\tif(req[i][j]>val){\n    \t\t\t\t\tlow[p][q]=max(low[p][q],req[i][j]-val);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int flag;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tflag=0;\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q+low[p][q];\n    \t\t\t\tif(val==req[i][j])\n    \t\t\t\t\tflag=1;\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t\tif(flag==0){\n    \t\t\tcout<<\"Impossible\"<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t}\n    }\n    int edg=0;\n    cout<<\"Possible\"<<endl;\n    cout<<202<<\" \"<<10401;\n    cout<<201<<\" \"<<1<<\" X\"<<endl;\n    edg++;\n    f(i,1,100){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" X\"<<endl;\n    }\n    edg++;\n    cout<<200<<\" \"<<202<<\" Y\"<<endl;\n    f(i,101,200){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n    }\n    f(i,1,101){\n    \tf(j,1,101){\n    \t\tedg++;\n    \t\tcout<<i<<\" \"<<200-j+1<<\" \"<<low[i][j]<<endl;\n    \t}\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<201<<\" \"<<200-i+1<<\" \"<<low[0][i]<<endl;\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<i<<\" \"<<202<<\" \"<<low[i][0]<<endl;\n    }\n    edg++;\n    cout<<201<<\" \"<<202<<\" \"<<low[0][0]<<endl;\n    //cout<<edg<<endl;\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n    using namespace std;\n    const int N = 350;\n    const int INF = 1<<30;\n\n    int a, b, s, t, sum, d[N][N], f[N][N];\n\n    inline void ck_min( int &a, int b ) { if( a > b ) a = b; }\n    inline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\n    inline bool check( int x, int y, int val )\n    {\n        int res = INF;\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n                if( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\n    //  printf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n        return res == val;\n    }\n\n    int main()\n    {\n        memset( f, -1, sizeof( f ) );\n\n        scanf( \"%d%d\", &a, &b );\n        for( int i = 1; i <= a; i ++ )\n            for( int j = 1; j <= b; j ++ )\n                scanf( \"%d\", &d[i][j] );\n\n        s = 201, t = 202; \n        // s --> 1 --> 2 --> ... --> 100\n        // t <-- 101 <-- 102 <-- ... <-- 200\n\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n            {\n                int tmp = -INF;\n                for( int _a = 1; _a <= a; _a ++ )\n                    for( int _b = 1; _b <= b; _b ++ )\n                        ck_max( tmp, d[_a][_b] - i*_a - j*_b ); \n                f[i][j] = tmp; \n                if( f[i][j] < 0 ) break;\n\n                sum ++;\n    //          printf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n            }\n\n        for( int i = 1; i <= a; i ++ )\n            for( int j = 1; j <= b; j ++ )  \n                if( !check( i, j, d[i][j] ) ) {\n                    printf( \"Impossible\\n\" ); return 0;\n                } \n\n        printf( \"Possible\\n\" );\n\n        printf( \"%d %d\\n\", 202, sum+200 );\n        for( int i = 1; i < 100; i ++ )\n            printf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\n        printf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n        for( int i = 0; i <= 100; i ++ )\n            for( int j = 0; j <= 100; j ++ )\n                if( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\n        printf( \"%d %d\\n\", s, t );\n\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\ntypedef pair<int, int> P;\ntypedef pair<P, string> E;\n\nint f[101][101];\nint d[11][11];\nint main() {\n\tint A, B;\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) cin >> d[i][j];\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tfor (int x = 1; x <= A; x++) {\n\t\t\t\tfor (int y = 1; y <= B; y++) {\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - x * i - y * j);\n\t\t\t\t}\n\t\t\t }\n\t\t}\n\t}\n\tfor (int x = 1; x <= A; x++) {\n\t\tfor (int y = 1; y <= B; y++) {\n\t\t\tint D = 1 << 30;\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tD = min(D, x*i + y * j + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (D != d[x][y]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tvector<E> edge;\n\tfor (int i = 0; i < 100; i++) {\n\t\tedge.emplace_back(P(1 + i, 1 + i + 1), \"X\");\n\t\tedge.emplace_back(P(202 - i, 202 - i - 1), \"Y\");\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tedge.emplace_back(P(1 + i, 102 + j), to_string(f[i][j]));\n\t\t}\n\t}\n\tcout << 202 << \" \" << edge.size() << endl;\n\tfor (E e : edge) {\n\t\tcout << e.first.first << \" \" << e.first.second << \" \" << e.second << endl;\n\t}\n\tcout << \"1 102\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint A, B, d[11][11], f[101][101];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) {\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            f[a][b] = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    f[a][b] = std::max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            int D = 1e9;\n            for (int a = 0; a <= 100; ++a) {\n                for (int b = 0; b <= 100; ++b) {\n                    D = std::min(D, a * x + b * y + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n\n        }\n    }\n\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 101 * 101 + 200);\n    for(int i = 1; i <= 100; ++i) {\n        printf(\"%d %d X\\n\", i, i + 1);\n    }\n    for(int i = 102; i <= 201; ++i) {\n        printf(\"%d %d Y\\n\", i, i + 1);\n    }\n    for(int a = 0; a <= 100; ++a) {\n        for(int b = 0; b <= 100; ++b) {\n            printf(\"%d %d %d\\n\", a + 1, 202 - b, f[a][b]);\n        }\n    }\n    printf(\"1 202\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\nint G[101][101];\n\nvoid Set(int p, int q)\n{\n\tint min_f = INT_MAX;\n\n\tfor (int f = 0; f <= 100; f++)\n\t{\n\t\tbool is_update = false;\n\n\t\tREP(x, A) REP(y, B)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + f;\n\t\t\tif (D[x][y] > d)\n\t\t\t{\n\t\t\t\tis_update = false;\n\t\t\t\tgoto BREAK;\n\t\t\t}\n\t\t\tif (G[x][y] > d && D[x][y] == d)\n\t\t\t{\n\t\t\t\tis_update = true;\n\t\t\t}\n\t\t}\n\tBREAK:\n\t\tif (is_update)\n\t\t{\n\t\t\tmin_f = MIN(f, min_f);\n\t\t}\n\t}\n\n\tif (min_f <= 100)\n\t{\n\t\tF[p][q] = min_f;\n\n\t\tREP(x, 101) REP(y, 101)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + min_f;\n\t\t\tG[x][y] = MIN(G[x][y], d);\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\tREP(i, 101) REP(j, 101)\n\t{\n\t\tF[i][j] = 100;\n\t\tG[i][j] = 100;\n\t}\n\n\tREP(p, 101) REP(q, 101)\n\t{\n\t\tSet(p, q);\n\t}\n\n\tREP(x, A) REP(y, B)\n\t{\n\t\tint min = INT_MAX;\n\t\tREP(p, 101) REP(q, 101)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + F[p][q];\n\t\t\tmin = MIN(min, d);\n\t\t}\n\t\tif (D[x][y] != min)\n\t\t{\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10401\" << endl;\n\tREP(i, 100) cout << (i + 1) << \" \" << (i + 2) << \" X\" << endl;\n\tREP(i, 100) cout << (i + 102) << \" \" << (i + 103) << \" Y\" <<  endl;\n\n\tREP(p, 101) REP(q, 101)\n\t{\n\t\tcout << (p + 1) << \" \" << (202 - q) << \" \" << F[p][q] << endl;\n\t}\n\n\tcout << \"1 202\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=105;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tassert(0);\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint dx[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint A, B;\nint d[11][11];\nint f[101][101];\n\nsigned main() {\n    cin >> A >> B;\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            cin >> d[x][y];\n        }\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            f[a][b] = 0;\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int cur = LLONG_MAX;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    cur = min(cur, x * a + y * b + f[a][b]);\n                }\n            }\n            if (d[x][y] != cur) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 200 + 101 * 101 << endl;\n    for (int i = 1; i <= 100; i++) {\n        cout << i << \" \" << i + 1 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            cout << a + 1 << \" \" << 202 - b << \" \" << f[a][b] << endl;\n        }\n    }\n    cout << 1 << \" \" << 202 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint c[101][101], d[11][11];\n\nbool judge(int a, int b) {\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            int dist = 114514;\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    dist = min(dist, i * k + j * l + c[k][l]);\n                }\n            }\n            if (dist != d[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    c[k][l] = max(c[k][l], d[i][j] - i * k - j * l);\n                }\n            }\n        }\n    }\n\n    if (judge(a, b)) {\n        cout << \"Possible\" << endl;\n        for (int i = 1; i <= 100; i++) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n        }\n        for (int i = 102; i < 202; i++) {\n            cout << i + 1 << \" \" << i << \" Y\" << endl;\n        }\n        for (int i = 0; i <= 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                cout << i + 1 << \" \" << j + 102 << \" \" << c[i][j] << endl;\n            }\n        }\n        cout << 1 << \" \" << 102 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int S = 198, T = 199;\n\txv.push_back(S);\n\tFOR(i, 99) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, 99) yv.push_back(i + 99);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int,int,int>> vp;\n\tFOR(i, 100) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(w, 100) FOR(z, 100) {\n\t\tif (w + z >= 100) continue;\n\t\tint maxdiff = -10000;\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tint xw = w * (i + 1);\n\t\t\tint yw = z * (j + 1);\n\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\tchmax(maxdiff, additional);\n\t\t}\n\t\tif (maxdiff >= 0) {\n\t\t\tint from = xv[w], to = yv[100 - z];\n\t\t\t// printf(\"%dx + %dy + %d\\n\", w, z, maxdiff);\n\t\t\tvp.emplace_back(from, to, maxdiff);\n\t\t}\n\t}\n\n\t//FOR(i, a) FOR(j, b) {\n\t//\tint minad = 12345;\n\t//\tint cxw = minx[i][j], cyw = miny[i][j];\n\t//\tfor (int w = minx[i][j]; w <= 100; w++) {\n\t//\t\tfor (int z = miny[i][j]; z <= 100; z++) {\n\t//\t\t\tint xw = w * (i + 1);\n\t//\t\t\tint yw = z * (j + 1);\n\t//\t\t\tint additional = d[i][j] - xw - yw;\n\t//\t\t\tif (additional < 0) {\n\t//\t\t\t\tcontinue;\n\t//\t\t\t}\n\t//\t\t\tif (additional < minad) {\n\t//\t\t\t\tminad = additional;\n\t//\t\t\t\tcxw = w;\n\t//\t\t\t\tcyw = z;\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tif (minad == 12345) {\n\t//\t\tok = false;\n\t//\t\tcontinue;\n\t//\t}\n\t//\tint from = xv[cxw], to = yv[100 - cyw];\n\t//\t// printf(\"%d %d %d\\n\", cxw, cyw, minad);\n\t//\tvp.emplace_back(from, to, minad);\n\t//}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(200);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", 200, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S , T);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define max(a,b) ((a>b)?a:b)\n#define min(a,b) ((a<b)?a:b)\nusing namespace std;\nnamespace fio {\n\tstreambuf* in = cin.rdbuf();\n\tchar bb[1000000], * s = bb, * t = bb;\n#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)\n\tinline int read() {\n\t\tint x = 0;\n\t\tchar ch = gc();\n\t\twhile (ch < 48)ch = gc();\n\t\twhile (ch >= 48)x = x * 10 + ch - 48, ch = gc();\n\t\treturn x;\n\t}\n}using fio::read;\nint n, m;\nint arr[15][15];\nint dp[305][305];\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++)for (int u = 1; u <= m; u++)arr[i][u] = read();\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)for (int x = 1; x <= n; x++)for (int y = 1; y <= n; y++)dp[i][u] = max(dp[i][u], arr[x][y] - i * x - u * y);\n\tfor (int x = 0; x <= n; x++)for (int y = 0, now = 0x7fffffff; y <= m; now = 0x7fffffff, y++) {\n\t\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)\n\t\t\tnow = min(now, dp[i][u] + i * x + u * y);\n\t\tif (now != arr[x][y])cout << \"Impossible\", exit(0);\n\t}\n\tputs(\"Possible\"), puts(\"202 10401\");\n\tfor (int i = 1; i <= 201; i++)if (i != 101)cout << i << ' ' << i + 1 << ' ' << (i <= 100 ? 'X' : 'Y') << endl;\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)printf(\"%d %d %d\\n\", i + 1, 202 - u, dp[i][u]);\n\tcout << 1 << ' ' << 202;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 150;\nconst int M = (int) 20;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nconst int nx[4] = {0, 0, -1, 1};\nconst int ny[4] = {1, -1, 0, 0};\n\nint A, B;\nint d[N][N];\nint f[N][N];\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n  //    freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> A >> B;\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      cin >> d[i][j];\n    }\n  }\n  for (int a = 0; a < N; a++) {\n    for (int b = 0; b < N; b++) {\n      for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++) {\n          f[a][b] = max(f[a][b], d[i][j] - i * a - j * b);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      bool cur = false;\n      for (int a = 0; a < N; a++) {\n        for (int b = 0; b < N; b++) {\n          if (d[i][j] == f[a][b] + a * i + b * j) {\n            cur = true;\n          }\n        }\n      }\n      if (!cur) {\n        cout << i << ' ' << j << ' ' << d[i][j] << endl;\n        return 0;\n      }\n    }\n  }\n  cout << 200 << ' ' << 100 * 100 + 99 * 2 << endl;\n  for (int a = 0; a + 1 < 100; a++) {\n    cout << a + 1 << ' ' << a + 2 << \" X\\n\";\n  }\n  for (int b = 0; b + 1 < 100; b++) {\n    cout << b + 1 << ' ' << b + 2 << \" Y\\n\";\n  }\n  for (int a = 0; a < 100; a++) {\n    for (int b = 0; b < 100; b++) {\n      cout << a + 1 << ' ' << 100 + 100 - b << ' ' << f[a][b] << \"\\n\";\n    }\n  }\n  cout << 1 << ' ' << 200;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"201 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<=200;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,201-j,f[i][j]);\n\tprintf(\"1 201\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <array>\n#include <iterator>\n#include <functional>\n#include <map>\n#include <cstdio>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(1, A + 1))\n        RDV(d[i] + 1, d[i] + B + 1);\n\n    vector<pair<int, int>> adj[300];\n    set<int> adj2[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(1, A + 1))\n        for(int j: RG(1, B + 1))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    bool check = true;\n                    for(int ii = 1; ii <= A && check; ii++)\n                        for(int jj: RG(1, B + 1))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else if(adj2[xx + 1].insert(202 - yy).second)\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n\n\n\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<vector>\n#include<stack>\n#include<cmath>\n#include<random>\n//This code is written by Itst\nusing namespace std;\n\ninline int read()\n{\n\tint a = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c != EOF)\n\t\tc = getchar();\n\tif(c == EOF)\n\t\texit(0);\n\twhile(isdigit(c))\n\t{\n\t\ta = a * 10 + c - 48;\n\t\tc = getchar();\n\t}\n\treturn f ? -a : a;\n}\n\nint d[12][12] , f[107][107];\n\nsigned main()\n{\n\tint A = read() , B = read();\n\tfor(int i = 1 ; i <= A ; ++i)\n\t\tfor(int j = 1 ; j <= B ; ++j)\n\t\t\td[i][j] = read();\n\tfor(int i = 0 ; i <= 100 ; ++i)\n\t\tfor(int j = 0 ; j <= 100 ; ++j)\n\t\t\tfor(int p = 1 ; p <= A ; ++p)\n\t\t\t\tfor(int q = 1 ; q <= B ; ++q)\n\t\t\t\t\tf[i][j] = max(f[i][j] , d[p][q] - i * p - j * q);\n\tfor(int i = 1 ; i <= A ; ++i)\n\t\tfor(int j = 1 ; j <= B ; ++j)\n\t\t{\n\t\t\tint minN = 1e9;\n\t\t\tfor(int p = 0 ; p <= 100 ; ++p)\n\t\t\t\tfor(int q = 0 ; q <= 100 ; ++q)\n\t\t\t\t\tminN = min(minN , f[p][q] + p * i + q * j);\n\t\t\tif(minN != d[i][j])\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i = 1 ; i <= 100 ; ++i)\n\t\tprintf(\"%d %d X\\n\" , i , i + 1);\n\tfor(int i = 102 ; i < 202 ; ++i)\n\t\tprintf(\"%d %d Y\\n\" , i , i + 1);\n\tfor(int i = 0 ; i <= 100 ; ++i)\n\t\tfor(int j = 0 ; j <= 100 ; ++j)\n\t\t\tprintf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXSIZE=10000020;\nint bufpos;\nchar buf[MAXSIZE];\n#define NEG 0\nvoid init(){\n    #ifdef LOCAL\n        freopen(\"E.txt\",\"r\",stdin);\n    #endif\n    buf[fread(buf,1,MAXSIZE,stdin)]='\\0';\n    bufpos=0;\n}\n#if NEG\nint readint(){\n    bool isneg;\n    int val=0;\n    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);\n    bufpos+=(isneg=buf[bufpos]=='-');\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return isneg?-val:val;\n}\n#else\nint readint(){\n    int val=0;\n    for(;!isdigit(buf[bufpos]);bufpos++);\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return val;\n}\n#endif\nchar readchar(){\n    for(;isspace(buf[bufpos]);bufpos++);\n    return buf[bufpos++];\n}\nint readstr(char* s){\n    int cur=0;\n    for(;isspace(buf[bufpos]);bufpos++);\n    for(;!isspace(buf[bufpos]);bufpos++)\n        s[cur++]=buf[bufpos];\n    s[cur]='\\0';\n    return cur;\n}\nint d[13][13];\nstruct edge{\n    int x,y,z;\n}e[2333];\nbool vis[103][103];\nint main(){\n    init();\n    int a=readint(),b=readint(),cur=0;\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            d[i][j]=readint();\n    // memset(vis,-1,sizeof(vis));\n    for(int i=0;i<=100;i++)\n        for(int j=0;j<=100;j++)\n            for(int k=0;k<=100;k++){\n                bool flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++){\n                        if (i*o+j*t+k<d[o][t]){\n                            flag=1;\n                            goto hell;\n                        }\n                    }\n                hell:;\n                if (flag)\n                    continue;\n                flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++)\n                        if (!vis[o][t] && i*o+j*t+k==d[o][t])\n                            vis[o][t]=flag=1;\n                if (flag)\n                    e[++cur]=(edge){i,j,k};\n            }\n    // puts(\"WTF\");\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            if (!vis[i][j])\n                return puts(\"Impossible\"),0;\n    puts(\"Possible\");\n    printf(\"%d %d\\n\",202,cur+100);\n    for(int i=0;i<100;i++)\n        printf(\"%d %d X\\n\",i+1,i+2);\n    for(int j=1;j<=100;j++)\n        printf(\"%d %d Y\\n\",j+102,j+101);\n    for(int i=1;i<=cur;i++)\n        printf(\"%d %d %d\\n\",e[i].x+1,e[i].y+102,e[i].z);\n    puts(\"1 102\");\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\n\nint dis[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int A,B;cin>>A>>B;\n    int N=16*16+1;\n    int M=15*17+16*16;\n    \n    vector<pair<int,int>> ans;\n    \n    for(int i=0;i<256;i+=16){\n        for(int j=0;j<15;j++){\n            ans.push_back(mp(i+j,i+j+1));\n        }\n    }\n    \n    for(int i=0;i+16<256;i+=16) ans.push_back(mp(i,i+16));\n    \n    for(int i=0;i<256;i++) ans.push_back(mp(i,256));\n    \n    vector<vector<int>> S(A+1,vector<int>(B+1));\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            cin>>S[i][j];\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    int sum=a*i+b*j;\n                    chmax(dis[16*b+a][256],S[i][j]-sum);\n                }\n            }\n        }\n    }\n    \n    bool ok=true;\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            int mini=INF;\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    chmin(mini,a*i+b*j+dis[16*b+a][256]);\n                }\n            }\n            \n            if(mini!=S[i][j]) ok=false;\n        }\n    }\n    \n    if(ok){\n        cout<<\"Possible\\n\";\n        cout<<N<<\" \"<<M<<endl;\n        for(int i=0;i<M;i++){\n            cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<\" \";\n            if(ans[i].se==256) cout<<dis[ans[i].fi][256]<<\"\\n\";\n            else if(ans[i].se-ans[i].fi==1) cout<<\"X\\n\";\n            else if(ans[i].se-ans[i].fi==16) cout<<\"Y\\n\";\n        }\n        cout<<1<<\" \"<<257<<endl;\n    }else{\n        cout<<\"Impossible\\n\";\n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main()\n{\n\tint a,mod=1e18;\n\tcin>>a;\n\tint l,r,b;\n\tb=(mod%a*(9%a)*(9%a)+1)%a;\n\tl=a-b+1;\n\tr=1e18+a-b;\n\tcout<<l<<\" \"<<r;\n\treturn 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define AB_MAX 12\n#define N_MAX 102\n\nusing namespace std;\n\nint A, B;\n\nint d[AB_MAX][AB_MAX];\n\nint a[N_MAX][N_MAX];\n\nint n;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> A >> B;\n    bool ok = true;\n    for(int i = 1; i <= A; i++)\n        for(int j = 1; j <= B; j++)\n        {\n            cin >> d[i][j];\n            if(d[i][j] < d[i - 1][j] || d[i][j] < d[i][j - 1])\n                ok = false;\n        }\n    if(ok == false)\n    {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    n = 101;\n    for(int i = 0; i <= n; i++)\n        for(int j = 0; j <= n; j++)\n        {\n            for(int x = 1; x <= A; x++)\n                for(int y = 1; y <= B; y++)\n                    a[i][j] = max(a[i][j], d[x][y] - x * i - y * j);\n        }\n    int cntX = 101;\n    int cntY = 101;\n    cout << \"Possible\\n\";\n    cout << cntX + cntY + 2 << \" \" << cntX - 1 + cntY - 1 + cntX * cntY + 2 << \"\\n\";\n    for(int i = 2; i < cntX + 1; i++)\n        cout << i << \" \" << i + 1 << \" X\\n\";\n    for(int i = 2; i < cntY + 1; i++)\n        cout << cntX + i << \" \" << cntX + i + 1 << \" Y\\n\";\n    cout << \"1 2 0\\n\";\n    for(int i = 2; i <= cntX + 1; i++)\n        for(int j = 2; j <= cntY + 1; j++)\n            cout << i << \" \" << cntX + j << \" \" << a[i - 2][cntY - j + 1] << \"\\n\";\n    cout << cntX + cntY + 1 << \" \" << cntX + cntY + 2 << \" 0\\n\";\n    cout << 1 << \" \" << cntX + cntY + 2 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nmain() {\n    INT(n, m);\n    VV(int, a, n, m);\n    int N = 100;\n    vv(int, d, N + 1, N + 1);\n    vv(bool, ok, n, m);\n    rep(x, N + 1) {\n        rep(y, N + 1) {\n            rep(i, n) rep(j, m) { chmax(d[x][y], a[i][j] - (i + 1) * x - (j + 1) * y); }\n            rep(i, n) rep(j, m) if(a[i][j] == d[x][y] + (i + 1) * x + (j + 1) * y) ok[i][j] = true;\n            // cout << d[x][y] << \" \";\n        }\n        // cout << endl;\n    }\n    rep(i, n) rep(j, m) {\n        if(!ok[i][j]) {\n            cout << \"Impossible\\n\";\n            exit(0);\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << N * 2 + 1 << \" \" << N * 2 + (N + 1) * (N + 1) << endl;\n    rep2(i, 1, N) cout << i << \" \" << i + 1 << \" \" << 'X' << endl;\n    rep2(i, N + 1, N * 2) cout << i << \" \" << i + 1 << \" \" << 'Y' << endl;\n    rep(i, N + 1) rep(j, N + 1) {\n        int t = 1 + i, s = N * 2 + 1 - j;\n        cout << t << \" \" << s << \" \" << d[i][j] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n/*\nstruct point\n{\nlong long dist; long long name;\nbool operator<(const point& rhs) const {\nreturn dist > rhs.dist;\n}\n};\n*/\n\nll d[20][20];\nll color[20][20] = {};\nll a, b;\n\nvll ansx, ansy, ansc;\nll cnt = 2;\nll edge = 0;\nll flag = 0;\n\nbool check(ll i, ll j) {\n\tif (color[i][j] == 1) {\n\t\treturn 0;\n\t}\n\tll x = d[i + 1][j] - d[i][j];\n\tll y = d[i][j + 1] - d[i][j];\n\tll c = d[i][j] - x * i - y * j;\n\tcnt += ((c != 0) + x + y - 1);\n\tedge += (c != 0) + x + y;\n\tif (min({ x,y,c }) < 0) {\n\t\treturn 1;\n\t}\n\tREP(i_, 1, a) {\n\t\tREP(j_, 1, b) {\n\t\t\tif (d[i_][j_] == x * i_ + y * j_ + c) {\n\t\t\t\tcolor[i_][j_] = 1;\n\t\t\t}\n\t\t\telse if (d[i_][j_] > x*i_ + y * j_ + c) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tansx.push_back(x);\n\tansy.push_back(y);\n\tansc.push_back(c);\n\treturn 0;\n}\n\nint main() {\n\tcin >> a >> b;\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tREP(i, 1, a + 1) {\n\t\td[i][b + 1] = d[i][b];\n\t}REP(j, 1, b + 1) {\n\t\td[a + 1][j] = d[a][j];\n\t}\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tif(check(i, j)){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tll max_x = 0, max_y = 0;\n\tREP(i, 0, SIZE(ansx) - 1) {\n\t\tmax_x = max(max_x, ansx[i]);\n\t\tmax_y = max(max_y, ansy[i]);\n\t}\n\tll ver = max_x + max_y + 2;\n\tll edge = max_x + max_y + SIZE(ansx);\n\tcout << ver << \" \" << edge << endl;\n\tll cnt = 1;\n\tREP(i, 1, max_x) {\n\t\tcout << cnt << \" \" << cnt + 1 << \" X\" << endl;\n\t\tcnt++;\n\t}\n\tcnt++;\n\tREP(j, 1, max_y) {\n\t\tcout << cnt << \" \" << cnt + 1 << \" Y\" << endl;\n\t\tcnt++;\n\t}\n\tREP(i, 0, SIZE(ansx) - 1) {\n\t\tll x = ansx[i];\n\t\tll y = ansy[i];\n\t\tll c = ansc[i];\n\t\tif (c != 0) {\n\t\t\tcout << 1 + x << \" \" << ver - y << \" \" <<c << endl;\n\t\t}\n\t\telse {\n\t\t\tif (x != 0) {\n\t\t\t\tcout << x << \" \" << ver - y << \" X\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << x + 1 << \" \" << ver - y + 1 << \" Y\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << 1 << \" \" << ver << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n    int a,b,c;\n}ans[310];\nvoid print()\n{\n    int numn=0,numm=0;\n    for (int i=1;i<=sum;i++)\n    {\n        numm+=ans[i].a+ans[i].b+1;\n        numn+=ans[i].a+ans[i].b;\n    }\n    numn+=2;\n    if (numn>300) {while(1);printf(\"Impossible\\n\");return;}\n    printf(\"Possible\\n\");\n    printf(\"%d %d\\n\",numn,numm);\n    int t=1,pre=1;\n    for (int i=1;i<=sum;i++)\n    {\n        pre=1;\n        printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n        for (int j=1;j<=ans[i].a;j++)\n        {\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].a&&ans[i].b==0)?numn:++t,'X'),pre=t;\n        }\n        for (int j=1;j<=ans[i].b;j++)\n            printf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\n    }\n    printf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%d\",&d[i][j]);\n    for (int s=0;s<=300;s++)\n        for (int a=0;a<=s&&a<=100;a++)\n            for (int b=0;b<=s-a&&b<=100;b++)\n                {\n                    int c=s-a-b;\n                    bool p=0,q=0;\n                    int now=0;\n                    for (int i=1;i<=n;i++)\n                    {\n                        for (int j=1;j<=m;j++)\n                        {\n                            if (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n                            else if (a*i+b*j+c<d[i][j]) {p=1;break;}\n                        }\n                        if (p==1) break;\n                    }\n                    if ((!p)&&q) \n                    {\n                        for (int i=1;i<=now;i++)\n                            vis[pa[i]][pb[i]]=1;\n                        tot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n                        if (tot==n*m){print();return 0;}\n                    }\n                }\n    printf(\"Impossible\\n\");\n}\n/*--------------------- \n作者：Fizzmy \n来源：CSDN \n原文：https://blog.csdn.net/Charlie_jilei/article/details/79132120 \n版权声明：本文为博主原创文章，转载请附上博文链接！*/"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i,a,n) for(LL i = (a); i < (LL)(n); ++i)\n#define REM(i,a,n) for(LL i = ((n) - 1); i >= (a); --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(0); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n// all_of\n// partial_sum, adjacent_difference\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nint A, B;\nint D[11][11];\nint C[101][101];\nint main() {\n\tcin >> A >> B;\n\n\tREP(i, 0, A) {\n\t\tREP(j, 0, B) {\n\t\t\tcin >> D[i + 1][j + 1];\n\t\t}\n\t}\n\n\tREP(x, 0, 101) {\n\t\tREP(y, 0, 101) {\n\t\t\tREP(a, 1, A + 1) {\n\t\t\t\tREP(b, 1, B + 1) {\n\t\t\t\t\tC[x][y] = max(C[x][y], D[a][b] - (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok = 1;\n\tREP(a, 1, A + 1) {\n\t\tREP(b, 1, B + 1) {\n\t\t\tint mn = INF;\n\t\t\tREP(x, 0, 101) {\n\t\t\t\tREP(y, 0, 101) {\n\t\t\t\t\tmn = min(mn, C[x][y] + (int)(a * x + b * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != D[a][b]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (ok ? \"Possible\" : \"Impossible\") << endl;\n\tif (ok) {\n\t\tint X = 100;\n\t\tint Y = 100;\n\t\tcout << X + Y + 1 << ' ' << (X + 1) * (Y + 1) << endl;\n\t\tREP(i, 0, X) {\n\t\t\tcout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n\t\t}\n\t\tREP(i, 0, Y) {\n\t\t\tcout << i + X + 1 << ' ' << i + X + 2 << \" Y\" << endl;\n\t\t}\n\n\t\tint S = X + 1;\n\t\tREP(i, 0, X + 1) {\n\t\t\tREP(j, 0, Y + 1) {\n\t\t\t\tif (i == X && j == Y) continue;\n\t\t\t\tcout << S - (X - i) << ' ' << S + (Y - j) << ' ' << C[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\n#include<bitset>\nusing namespace std;\n#define pb push_back\n#define x0 fuckcjb\n#define x1 fuckshb\n#define y0 fucksub\n#define y1 fuckjtjl\nstruct edges\n{\n\tint x,y,z;\n};\nint d[15][15];\nbool vis[20][20];\nint tot,n,idx[20][20],idy[20][20],S,T,A,B;\nvector<edges> edge;\nvoid check()\n{\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(!vis[i][j])\n\t\t\t{\n\t\t\tputs(\"Impossible\");\n\t\t\texit(0);\n\t\t}\n\t\t}\n\t}\n}\nint get(int p,int q)\n{\n\tint c=-1000000;\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tc=max(c,d[i][j]-i*p-j*q);\n\t\t}\n\t}\n\tif(c<0)\n\t{\n\t\treturn -3;\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tif(d[i][j]-i*p-j*q==c)\n\t\t\t{\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\nvoid add(int x,int y,int z)\n{\n\tif(z==-3)\n\t{\n\t\treturn;\n\t}\n\tedge.push_back({x,y,z});\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tS=1;T=2;tot=2;\n\tfor(int j=1;j<=B;j++)\n\t{\n\t\tidy[0][j]=++tot;\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tidx[i][j]=++tot;\n\t\t}\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tidy[i][j]=++tot;\n\t\t}\n\t}\n\tadd(S,idy[0][1],-2);\n\tfor(int j=2;j<=B;j++)\n\t{\n\t\tadd(idy[0][j-1],idy[0][j],-2);\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tadd(S,idx[i][1],-1);\n\t\tfor(int j=2;j<=i;j++)\n\t\t{\n\t\t\tadd(idx[i][j-1],idx[i][j],-1);\n\t\t}\n\t\tadd(idx[i][i],idy[i][1],-2);\n\t\tfor(int j=2;j<=B;j++)\n\t\t{\n\t\t\tadd(idy[i][j-1],idy[i][j],-2);\n\t\t}\n\t}\n\tadd(S,T,get(0,0));\n\tfor(int j=1;j<=B;j++)\n\t{\n\t\tadd(idy[0][j],T,get(0,j));\n\t}\n\tfor(int i=1;i<=A;i++)\n\t{\n\t\tadd(idx[i][i],T,get(i,0));\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\tadd(idy[i][j],T,get(i,j));\n\t\t}\n\t}\n\tcheck();\n\tputs(\"Possible\");\n\tint cnt=edge.size();\n\tprintf(\"%d %d\\n\",tot,cnt);\n\tfor(int i=0;i<cnt;i++)\n\t{\n\t\tprintf(\"%d %d \",edge[i].x,edge[i].y);\n\t\tif(edge[i].z>=0)\n\t\t{\n\t\t\tprintf(\"%d\\n\",edge[i].z);\n\t\t}\n\t\telse if(edge[i].z==-1)\n\t\t{\n\t\t\tputs(\"X\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"Y\");\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#include<math.h>\n#include<memory>\n#include<vector>\n#include<bitset>\n#include<fstream>\n#include<stdio.h>\n#include<utility>\n#include<sstream>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint d[15][15];\nint weight[15][105];\nint xy[105][105];\nvoid wa()\n{\n    puts(\"Impossible\");\n}\nint check_ans[15];\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    int i,j;\n    for (i=1;i<=a;i++)\n    {\n        for (j=1;j<=b;j++)\n        {\n            scanf(\"%d\",&d[i][j]);\n        }\n    }\n    for (i=1;i<=a;i++)\n    {\n        for (j=0;j<=100;j++)\n        {\n            int k;\n            for (k=1;k<=b;k++)\n            {\n                weight[i][j]=max(weight[i][j],d[i][k]-j*k);\n            }\n        }\n        for (j=1;j<=b;j++)\n        {\n            check_ans[j]=105;\n        }\n        for (j=0;j<=100;j++)\n        {\n            int k;\n            for (k=1;k<=b;k++)\n            {\n                check_ans[k]=min(check_ans[k],weight[i][j]+j*k);\n            }\n        }\n        for (j=1;j<=b;j++)\n        {\n            if (d[i][j]!=check_ans[j])\n            {\n                wa();\n                return 0;\n            }\n        }\n    }\n    for (i=0;i<=101;i++)\n    {\n        int j;\n        for (j=1;j<=a;j++)\n        {\n            //weight[j][i]\n            int k;\n            for (k=0;k<=100;k++)\n            {\n                xy[k][i]=max(xy[k][i],weight[j][i]-j*k);\n            }\n        }\n        for (j=1;j<=a;j++)\n        {\n            check_ans[j]=105;\n        }\n        for (j=1;j<=a;j++)\n        {\n            int k;\n            for (k=0;k<=100;k++)\n            {\n                check_ans[j]=min(check_ans[j],xy[k][i]+j*k);\n            }\n        }\n        for (j=1;j<=a;j++)\n        {\n            if (weight[j][i]!=check_ans[j])\n            {\n                wa();\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    int sum=0;\n    for (i=1;i<=100;i++)\n    {\n        printf(\"%d %d X\\n\",i,i+1);\n        sum++;\n    }\n    for (i=102;i<=201;i++)\n    {\n        printf(\"%d %d Y\\n\",i,i+1);\n        sum++;\n    }\n    for (i=0;i<=100;i++)\n    {\n        for (j=0;j<=100;j++)\n        {\n            printf(\"%d %d %d\\n\",i+1,202-j,xy[i][j]);\n            sum++;\n        }\n    }\n    printf(\"1 202\\n\");\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmin(a,b) a=min(a,b);\n#define chmax(a,b) a=max(a,b);\n#define H 11\n#define N 110\nll d[H][H],z[N][N],h,w;\nint main(){\n  cin>>h>>w;\n  for(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n    cin>>d[i][j];\n  }\n  for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n    z[i][j]=0;\n    for(int a=1;a<=h;a++)for(int b=1;b<=w;b++){\n      chmax(z[i][j],d[a][b]-i*a-j*b);\n    }\n  }\n  bool ok=1; ll cnt=0;\n  for(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n    ll mi=1e9;\n    for(int a=0;a<N;a++)for(int b=0;b<N;b++){\n      if(z[a][b]>100)continue; cnt++;\n      chmin(mi,z[a][b]+a*i+b*j);\n    }\n    if(mi!=d[i][j])ok=0;\n  }\n  cnt=cnt/h/w+2*(N-1);\n  if(ok==0){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  cout<<2*N<<\" \"<<cnt<<endl;\n  for(int i=1;i<N;i++)cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n  for(int i=N+1;i<2*N;i++)cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n  for(int a=0;a<N;a++)for(int b=0;b<N;b++){\n    if(z[a][b]>100)continue;\n    cout<<a+1<<\" \"<<2*N-b<<\" \"<<z[a][b]<<endl;\n  }\n  cout<<1<<\" \"<<2*N<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\nclass GRAPH \n{\n\tpublic:\n\t\tint to[MAXM],next[MAXM],weight[MAXM];\n\t\tint head[MAXN];\n\t\tint cnt;\n\t\t\n\tGRAPH()\n\t{\n\t\tcnt=1;\n\t} \n\t\n\tvoid add(int x,int y,int z)\n\t{\n\t\tnext[cnt]=head[x];\n\t\tweight[cnt]=z;\n\t\tto[cnt]=y;\n\t\thead[x]=cnt++;\n\t}\n};\n\nGRAPH g;\n\nint n,m;\nint a[12][12],b[12][12],c[12][12];\n\nint main()\n{\n\t//WRT(ceil(111.0));\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tDRPT(k,n,i)\n\t\t\t\ta[i][j]=max(a[i][j],(int)ceil(((DB)c[k][j]-c[i][j])/(k-i)));\n\t\t\tDRPT(k,i-1,-1)\n\t\t\t\tif (ceil(((DB)c[k][j]-c[i][j])/(k-i))<a[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\n\t\t\tDRPT(k,m,j)\n\t\t\t\tb[i][j]=max(b[i][j],(int)ceil(((DB)c[i][k]-c[i][j])/(k-j)));\n\t\t\tDRPT(k,j-1,-1)\n\t\t\t\tif (ceil(((DB)c[i][k]-c[i][j])/(k-j))<b[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t}\n\t//RPT(i,1,n+1)\n\t//\tRPT(j,1,m+1)\n\t//\t\tcout<<i<<' '<<j<<' '<<a[i][j]<<' '<<b[i][j]<<endl;\n\tcout<<\"Possible\"<<endl;\n\tcout<<200<<' '<<198+m*n<<endl;\n\tRPT(i,1,100)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,101,200)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tcout<<a[i][j]+1<<' '<<b[i][j]+101<<' '<<c[i][j]-i*a[i][j]-j*b[i][j]<<endl;\n\tcout<<1<<' '<<101;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint d[15][15];\n\nint s[105][105];\n\nint main() {\n  int a, b;\n  cin >> a >> b;\n  for (int ai = 1; ai <= a; ai++) {\n    for (int bi = 1; bi <= b; bi++) {\n      cin >> d[ai][bi];\n    }\n  }\n  for (int i = 0; i <= 100; i++) {\n    for (int j = 0; j <= 100; j++) {\n      int ss = 0;\n      for (int ai = 1; ai <= a; ai++) {\n        for (int bi = 1; bi <= b; bi++) {\n          int sss = d[ai][bi] - ai * i - bi * j;\n          if (sss > ss) ss = sss;\n        }\n      }\n      s[i][j] = ss;\n    }\n  }\n  bool feasible = true;\n  for (int ai = 1; ai <= a; ai++) {\n    for (int bi = 1; bi <= b; bi++) {\n      int dd = 999999999;\n      for (int i = 0; i <= 100; i++) {\n        for (int j = 0; j <= 100; j++) {\n          int ddd = ai * i + bi * j + s[i][j];\n          if (ddd < dd) dd = ddd;\n        }\n      }\n      if (dd != d[ai][bi]) feasible = false;\n    }\n  }\n  if (feasible) {\n    cout << \"Possible\" << endl;\n    cout << \"202 10401\" << endl;\n    for (int i = 0; i < 100; i++) {\n      cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n    }\n    for (int i = 0; i < 100; i++) {\n      cout << i + 102 << \" \" << i + 103 << \" Y\" << endl;\n    }\n    for (int i = 0; i <= 100; i++) {\n      for (int j = 0; j <= 100; j++) {\n        cout << i + 1 << \" \" << 202 - j << \" \" << s[i][j] << endl;\n      }\n    }\n    cout << \"1 202\" << endl;\n  } else {\n    cout << \"Impossible\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int MAX = 100;\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > d(n+1, vector<int>(m+1));\n    for(int x=1; x<=n; ++x){\n        for(int y=1; y<=m; ++y){\n            cin >> d[x][y];\n        }\n    }\n\n    int size = 2 * MAX + 2;\n    vector<tuple<int, int, int>> ans;\n    for(int i=0; i<MAX; ++i){\n        ans.push_back(make_tuple(i, i+1, -1));\n        ans.push_back(make_tuple(size-2, size-1, -2));\n    }\n\n    vector<vector<bool> > check(n+1, vector<bool>(m+1, false));\n    int cnt = n * m;\n    for(int a=0; a<=MAX; ++a){\n        for(int b=0; b<=MAX; ++b){\n            int c = 0;\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    c = max(c, tmp);\n                }\n            }\n            for(int x=1; x<=n; ++x){\n                for(int y=1; y<=m; ++y){\n                    int tmp = d[x][y] - a * x - b * y;\n                    if(tmp == c && !check[x][y]){\n                        check[x][y] = true;\n                        -- cnt;\n                    }\n                }\n            }\n            if(c <= MAX)\n                ans.push_back(make_tuple(a, 2*MAX+1-b, c));\n        }\n    }\n\n    if(cnt == 0){\n        cout << \"Possible\" << endl;\n        cout << size << ' ' << ans.size() << endl;\n        for(const auto& t : ans){\n            int a, b, c;\n            tie(a, b, c) = t;\n            cout << a << ' ' << b << ' ';\n            if(c == -1)\n                cout << 'X' << endl;\n            else if(c == -2)\n                cout << 'Y' << endl;\n            else\n                cout << c << endl;\n        }\n    }\n    else{\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 105 \nusing namespace std;\nint d[maxn][maxn];\nint D[maxn][maxn];\nint f[maxn][maxn]; \nint main() {\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; ++i) for(int j = 1; j <= B; ++j) scanf(\"%d\", d[i] + j);\n\tfor(int a = 0; a <= 100; ++a) {\n\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\tfor(int x = 1; x <= A; ++x) {\n\t\t\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\t\t\tf[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0x3f, sizeof D);\n\tfor(int x = 1; x <= A; ++x) {\n\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\tfor(int a = 0; a <= 100; ++a) {\n\t\t\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\t\t\tD[x][y] = min(D[x][y], x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool same = true;\n\tfor(int x = 1; x <= A; ++x) \n\t\tfor(int y = 1; y <= B; ++y) \n\t\t\tif(D[x][y] != d[x][y]) same = false;\n\tputs(same ? \"Possible\" : \"Impossible\");\n\tif(same) {\n\t\tputs(\"202 10401\");\n\t\tfor(int i = 1; i <= 100; ++i) {\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\t\t}\n\t\tfor(int a = 0; a <= 100; ++a) \n\t\t\tfor(int b = 0; b <= 100; ++b) \n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 101, f[a][b]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#endif\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\nusing ld = long double;\n\nconstexpr int nax = 300;\nconstexpr int infty = 1000 * 1000 * 1000 + 5;\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\n\nconstexpr int MaxWsp = 13;\n\nint n, s, t, A, B;\nint D[11][11];\nint gdziex[MaxWsp + 1][MaxWsp + 1];\nvoid DajKrawedz(int a, int b, int d);\n\nvoid Algos() {\n  for (int x = 1; x <= A; x++) {\n    for (int y = 1; y <= B; y++) {\n      for (int a = 0; a <= MaxWsp; a++) {\n        for (int b = 0; b <= MaxWsp; b++) {\n          const int c = D[x][y] - a * x - b * y;\n          for (int x2 = 1; x2 <= A; x2++) {\n            for (int y2 = 1; y2 <= B; y2++) {\n              if (a * x2 + b * y2 + c < D[x2][y2]) {\n                goto out;\n              }\n            }\n          }\n          DajKrawedz(s, gdziex[a][b], c);\n          goto mam_juz;\n          out:;\n        }\n      }\n      mam_juz:;\n    }\n  }\n}\n\nmap<int, string> graf[nax];\n\nint mac[nax][nax];\nint odl[nax];\nbool nakol[nax];\n\nint Odl() {\n  for (int i = 0; i < n; i++) {\n    odl[i] = numeric_limits<int>::max();\n    nakol[i] = false;\n  }\n  odl[s] = 0;\n  queue<int> kol;\n  kol.push(s);\n  while (!kol.empty()) {\n    const int w = kol.front();\n    kol.pop();\n    nakol[w] = false;\n    for (int i = 0; i < n; i++) {\n      if (mac[w][i] == numeric_limits<int>::max()) continue;\n      const int o = odl[w] + mac[w][i];\n      if (o < odl[i]) {\n        odl[i] = o;\n        if (!nakol[i]) {\n          nakol[i] = true;\n          kol.push(i);\n        }\n      }\n    }\n  }\n  return odl[t];\n}\n\nbool Check() {\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      for (int k = 0; k < n; k++) {\n        for (int l = 0; l < n; l++) {\n          mac[k][l] = numeric_limits<int>::max();\n        }\n      }\n      for (int k = 0; k < n; k++) {\n        for (auto& it : graf[k]) {\n          if (it.second == \"X\") mac[k][it.first] = i;\n          else if (it.second == \"Y\") mac[k][it.first] = j;\n          else {\n            stringstream str(it.second);\n            int d;\n            str >> d;\n            mac[k][it.first] = d;\n          }\n        }\n      }\n      const int o = Odl();\n      if (o != D[i][j]) {\n        debug() << imie(i) imie(j) imie(D[i][j]) imie(o);\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid DajKrawedz(int a, int b, int d) {\n  assert(0 <= a and a < n);\n  assert(0 <= b and b < n);\n  assert(a != b);\n  graf[a][b] = to_string(d);\n}\n\nint DajId() {\n  assert(n < nax);\n  return n++;\n}\n\nint main() {\n  scanf(\"%d%d\", &A, &B);\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      scanf(\"%d\", &D[i][j]);\n    }\n  }\n\n  s = DajId();\n  t = DajId();\n  for (int y = 0; y <= MaxWsp; y++) {\n    int last = t;\n    for (int j = 0; j < y; j++) {\n      const int nowy = DajId();\n      graf[nowy][last] = \"Y\";\n      last = nowy;\n    }\n    for (int x = 0; true; x++) {\n      gdziex[x][y] = last;\n      if (x == MaxWsp) break;\n      const int nowy = DajId();\n      graf[nowy][last] = \"X\";\n      last = nowy;\n    }\n  }\n  Algos();\n  if (!Check()) {\n    printf(\"Impossible\\n\");\n    return 0;\n  }\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    m += (int) graf[i].size();\n  }\n  printf(\"Possible\\n\");\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 0; i < n; i++) {\n    for (auto& it : graf[i]) {\n      printf(\"%d %d %s\\n\", i + 1, it.first + 1, it.second.c_str());\n    }\n  }\n  printf(\"%d %d\\n\", s + 1, t + 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\nusing namespace std;\ntypedef long long ll;\n\nint a, b;\nint d[15][15];\nstruct edge {\n\tint x, y, z;\n\tedge() { x = y = z = 0; }\n\tedge(int a, int b, int c) { x = a, y = b, z = c; }\n}ans[15][15];\nint vis[300][300];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor(int i = 1; i <= a; i ++)\n\t\tfor(int j = 1; j <= b; j ++) scanf(\"%d\", &d[i][j]);\n\tfor(int i = 0; i <= 100; i ++)\n\t\tfor(int j = 0; j <= 100; j ++)\n\t\t\tfor(int k = 0; k <= 100; k ++) {\n\t\t\t\tbool flag = 0;\n\t\t\t\tfor(int t1 = 1; t1 <= a; t1 ++)\n\t\t\t\t\tfor(int t2 = 1; t2 <= b; t2 ++)\n\t\t\t\t\t\tif(i*t1+j*t2+k < d[t1][t2]) flag = 1;\n\t\t\t\tif(flag) continue;\n\t\t\t\tfor(int t1 = 1; t1 <= a; t1 ++)\n\t\t\t\t\tfor(int t2 = 1; t2 <= b; t2 ++)\n\t\t\t\t\t\tif(i*t1+j*t2+k == d[t1][t2]) ans[t1][t2] = edge(i+1, j+1, k);\n\t\t\t\tbreak;\n\t\t\t}\n\tbool chk = 0;\n\tfor(int i = 1; i <= a; i ++)\n\t\tfor(int j = 1; j <= b; j ++) if(ans[i][j].x == 0) { puts(\"Impossible\"); return 0; }\n\tputs(\"Possible\"); int n = 200;\n\tfor(int i = 1; i <= a; i ++)\n\t\tfor(int j = 1; j <= b; j ++) if(!vis[ans[i][j].x][ans[i][j].y]) n ++, vis[ans[i][j].x][ans[i][j].y] = 1;\n\tprintf(\"202 %d\\n\", n); memset(vis, 0, sizeof vis);\n\tfor(int i = 1; i < 101; i ++) printf(\"%d %d X\\n\", i, i+1);\n\tfor(int i = 102; i < 202; i ++) printf(\"%d %d Y\\n\", i, i+1);\n\tfor(int i = 1; i <= a; i ++)\n\t\tfor(int j = 1; j <= b; j ++) if(ans[i][j].x) {\n\t\t\tif(!vis[ans[i][j].x][ans[i][j].y]) printf(\"%d %d %d\\n\", ans[i][j].x, 202-ans[i][j].y+1, ans[i][j].z);\n\t\t\tvis[ans[i][j].x][ans[i][j].y] = 1;\n\t\t}\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A, B;\nconst int N = 15;\nint dx[N][N], nw[N][N];\nint V[N][N];\nconst int INF = 1e9 + 7;\nvector <int> Ai, Bi, Ci;\nvoid add_edge(int a, int b, int c)\n{\n    Ai.push_back(a);\n    Bi.push_back(b);\n    Ci.push_back(c);\n}\nint main()\n{\n    cin >> A >> B;\n    for (int a = 1; a <= A; ++ a)\n        for (int b = 1; b <= B; ++ b)\n            cin >> dx[a][b], nw[a][b] = INF;\n    for (int i = 1; i <= 100; ++ i)\n        add_edge(i, i + 1, -1);\n    for (int i = 1; i <= 100; ++ i)\n        add_edge(101 + i, 101 + i + 1, -2);\n    for (int i = 0; i <= 100; ++ i)\n        for (int j = 0; j <= 100; ++ j)\n        {\n            int d = -INF;\n            for (int a = 1; a <= A; ++ a)\n                for (int b = 1; b <= B; ++ b)\n                    d = max(d, dx[a][b] - (i * a + j * b));\n            if (d >= 0 && d <= 100)\n            {\n                add_edge(i + 1, 202 - j, d);\n                for (int a = 1; a <= A; ++ a)\n                    for (int b = 1; b <= B; ++ b)\n                        nw[a][b] = min(nw[a][b], i * a + j * b + d);\n            }\n        }\n    for (int a = 1; a <= A; ++ a)\n        for (int b = 1; b <= B; ++ b)\n            if (nw[a][b] != dx[a][b])\n                return cout << \"Impossible\" << endl, 0;\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << Ci.size() << endl;\n    for (int i = 0; i < Ci.size(); ++ i)\n    {\n        cout << Ai[i] << \" \" << Bi[i] << \" \";\n        if (Ci[i] == -1) cout << \"X\" << endl;\n        else if (Ci[i] == -2) cout << \"Y\" << endl;\n        else cout << Ci[i] << endl;\n    }\n    cout << 1 << \" \" << 202 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e3 + 5;\n\nint mx[MAXN][MAXN];\nint d[MAXN][MAXN];\nint used[MAXN][MAXN];\n\nvoid solve(){\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tREPN(i, 1, A){\n\t\tREPN(j, 1, B){\n\t\t\tscanf(\"%d\", &d[i][j]);\n\t\t}\n\t}\n\tint lim = 100;\n\tREPN(i, 0, lim){\n\t\tREPN(j, 0, lim){\n\t\t\tREPN(k, 1, A){\n\t\t\t\tREPN(l, 1, B){\n\t\t\t\t\tint delta = d[k][l] - (i * k + j * l);\n\t\t\t\t\tmx[i][j] = max(mx[i][j], delta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREPN(k, 1, A){\n\t\t\t\tREPN(l, 1, B){\n\t\t\t\t\tint delta = i * k + j * l - d[k][l];\n\t\t\t\t\tif (delta == mx[i][j]){\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\", i, j, k, l, d[k][l]);\n\t\t\t\t\t\tused[k][l] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t/*if (k == 1 && l == 1){\n\t\t\t\t\t\tprintf(\"%d %d %d %d\\n\", i, j, i * k + j * l + mx[i][j], d[1][1]);\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint good = 1;\n\tREPN(k, 1, A){\n\t\tREPN(l, 1, B){\n\t\t\t//printf(\"%d %d %d\\n\", k, l, used[k][l]);\n\t\t\tgood &= used[k][l];\n\t\t}\n\t}\n\t\n\tif (!good){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn;\n\t}\n\tprintf(\"Possible\\n\");\n\tint n = lim + lim + 2;\n\tprintf(\"%d %d\\n\", n, (lim + 1) * (lim + 1) + lim + lim);\n\tREPN(i, 1, lim){\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t}\n\tREPN(i, 1, lim){\n\t\tprintf(\"%d %d Y\\n\", lim + 1 + i, lim + 1 + i + 1);\n\t}\n\tREPN(i, 0, lim){\n\t\tREPN(j, 0, lim){\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, n - j, mx[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 1, n);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int fr,to;\n    int w;\n};\nint main(){\n    int a,b;\n    cin>>a>>b;\n    vector<vector<int>> d(a,vector<int>(b,0));\n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            cin>>d[i][j];\n        }\n    }\n    const int S=1,T=204;\n    auto getX=[](int idx){\n        return 2+idx;\n    };\n    auto getY=[](int idx){\n        return 103+idx;\n    };\n    \n    vector<vector<int>> useX(a,vector<int>(b,0));\n    bool isok=true;\n    for(int i=a-2;i>=0;i--){\n        for(int j=b-1;j>=0;j--){\n            useX[i][j]=d[i+1][j]-d[i][j];\n            isok&=(useX[i+1][j]<=useX[i][j]);\n        }\n    }\n    vector<vector<int>> useY(a,vector<int>(b,0));\n    for(int i=a-1;i>=0;i--){\n        for(int j=b-2;j>=0;j--){\n            useY[i][j]=d[i][j+1]-d[i][j];\n            isok&=(useY[i][j+1]<=useY[i][j]);\n        }\n    }\n    vector<Edge> edges;\n    edges.push_back(Edge{S,getX(0)});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getX(i),getX(i+1),0});\n    }\n    edges.push_back(Edge{getY(0),T,0});\n    for(int i=0;i<100;i++){\n        edges.push_back(Edge{getY(i+1),getY(i),0});\n    }\n    \n    for(int i=0;i<a;i++){\n        for(int j=0;j<b;j++){\n            int w=d[i][j]-(i+1)*useX[i][j]-(j+1)*useY[i][j];\n            isok&=(w>=0);\n            edges.push_back(Edge{getX(useX[i][j]),getY(useY[i][j]),w});            \n        }\n    }\n    if(isok){\n        cout<<\"Possible\"<<endl;\n        cout<<250<<\" \"<<edges.size()<<endl;\n        for(int i=0;i<edges.size();i++){\n            cout<<edges[i].fr<<\" \"<<edges[i].to<<\" \"<<edges[i].w<<endl;\n        }\n        cout<<S<<\" \"<<T<<endl;\n    }\n    else{\n        cout<<\"Impossible\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        // assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h, vector<ll>(w));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h) rep(x, w) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nint A, B, a[15][15], b[15][15], c[15][15], d[15][15], g[105][105];\nint main() {\n\tcin >> A >> B;\n\tfor (int i = 0; i < A; i++) {\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool found = true;\n\tfor (int i = 0; i < A; i++) {\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\ta[i][j] = -1;\n\t\t\tfor (int k = 0; k <= 100; k++) {\n\t\t\t\tfor (int l = 0; l <= 100; l++) {\n\t\t\t\t\tint val = (i + 1) * k + (j + 1) * l;\n\t\t\t\t\tif (val > d[i][j]) continue;\n\t\t\t\t\tint nc = d[i][j] - val; bool flag = false;\n\t\t\t\t\tfor (int p = 0; p < A; p++) {\n\t\t\t\t\t\tfor (int q = 0; q < B; q++) {\n\t\t\t\t\t\t\tif ((p + 1) * k + (q + 1) * l + nc < d[p][q]) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag) a[i][j] = k, b[i][j] = l, c[i][j] = nc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i][j] == -1) found = false;\n\t\t}\n\t}\n\tif (!found) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\tg[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tint xs = 0, ys = 0;\n\t\tfor (int i = 0; i < A; i++) {\n\t\t\tfor (int j = 0; j < B; j++) {\n\t\t\t\tg[a[i][j]][b[i][j]] = min(g[a[i][j]][b[i][j]], c[i][j]);\n\t\t\t\txs = max(xs, a[i][j]);\n\t\t\t\tys = max(ys, b[i][j]);\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\tif (g[i][j] != inf) cnt++;\n\t\t\t}\n\t\t}\n\t\tcout << xs + ys + 2 << \" \" << xs + ys + cnt << endl;\n\t\tfor (int i = 0; i < xs; i++) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n\t\tfor (int i = 0; i < ys; i++) cout << xs + i + 3 << \" \" << xs + i + 2 << \" Y\\n\";\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\tif (g[i][j] != inf) {\n\t\t\t\t\tcout << i + 1 << \" \" << xs + j + 2 << \" \" << g[i][j] << \"\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << 1 << \" \" << xs + 2 << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nset<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = s;\n\t++s;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i < 50; ++i) {\n\t\tedge.insert({{lenXY[i + 1], s}, -2});\n\t\tedge.insert({{s, lenXY[i]}, -1});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 100; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.insert({{lenX[i + 1], lenX[i]}, -1});\n\t\tedge.insert({{lenY[i + 1], lenY[i]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.insert({{lenXY[50 - Y[i][j]], lenX[X[i][j] - Y[i][j]]}, D[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.insert({{lenXY[50 - X[i][j]], lenY[Y[i][j] - X[i][j]]}, D[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct edge { int to, cost; };\nvector<edge> G[301];\n\nint s, t;\npriority_queue<P, vector<P>, greater<P>> q;\nint dist(int x, int y) {\n\tint d[301]; fill(d, d + 301, 10000);\n\td[s] = 0; q.push({ 0,s });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j].to, cost = G[id][j].cost;\n\t\t\tif (cost == -1)cost = x;\n\t\t\telse if (cost == -2)cost = y;\n\t\t\tif (p.first + cost < d[to]) {\n\t\t\t\td[to] = p.first + cost;\n\t\t\t\tq.push({ d[to],to });\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 2, cur = 3;\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\trep(k, 101) {\n\t\t\t\tint l = k;\n\t\t\t\tif (l*i > d[i][j]) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t\tint r = (d[i][j] - l*i) / j;\n\t\t\t\tint z = d[i][j] - l*i - r * j;\n\t\t\t\tbool f = true;\n\t\t\t\trep1(i_, a) {\n\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tint ori = s;\n\t\t\t\t\twhile (l--) {\n\t\t\t\t\t\tv.push_back({ ori,cur,\"X\" });\n\t\t\t\t\t\tori = cur; cur++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (r--) {\n\t\t\t\t\t\tv.push_back({ ori,cur,\"Y\" });\n\t\t\t\t\t\tori = cur; cur++;\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back({ ori,t,to_string(z) });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == 100)valid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << cur - 1 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 2\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nint c[128][128];\nbool flag[128][128];\n\nvoid solve(ll A, ll B, vector<vector<ll>> d) {\n  REP(x,128) REP(y,128) {\n    REP(i,A) REP(j,B) {\n      chmax(c[x][y], int(d[i][j]) - x * (i + 1) - y * (j + 1));\n    }\n  }\n  // REP(i,10) { REP(j,10) cout << c[i][j] << \" \"; cout << endl; }\n  vector<tuple<int,int,int>> res;\n  REP(s,120) REP(x,128) {\n    int y = s - x;\n    if (y < 0) continue;\n    // if (x == 0 && y == 0)\n    // cout << x << \" \" << y << endl;\n    bool ok = false;\n    REP(i,A) REP(j,B) {\n      if (flag[i][j]) continue;\n      if (c[x][y] == int(d[i][j]) - x * (i + 1) - y * (j + 1)) {\n        ok = true;\n        flag[i][j] = true;\n      }\n    }\n    if (ok) {\n      res.emplace_back(x, y, c[x][y]);\n      // cout << x << \" \" << y << \" \" << c[x][y] << endl;\n    }\n  }\n  bool ng = false;\n  REP(i,A) REP(j,B) if (!flag[i][j]) ng = true;\n  if (ng) cout << \"Impossible\" << endl;\n  else {\n    int V = 2;\n    vector<tuple<int,int,string>> edge;\n    for (auto t: res) {\n      int x, y, cost;\n      tie(x, y, cost) = t;\n      int pv = 0;\n      REP(i,x) {\n        edge.emplace_back(pv, V, \"X\");\n        pv = V; ++V;\n      }\n      REP(i,y) {\n        edge.emplace_back(pv, V, \"Y\");\n        pv = V; ++V;\n      }\n      edge.emplace_back(pv, 1, to_string(cost));\n    }\n    cout << \"Possible\" << endl;\n    cout << V << \" \" << edge.size() << endl;\n    for (auto e: edge) {\n      int s, t; string c;\n      tie(s, t, c) = e;\n      cout << s + 1 << \" \" << t + 1 << \" \" << c << endl;\n    }\n    cout << 1 << \" \" << 2 << endl;\n  }\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll B;\n\tll A;\n\tscanf(\"%lld\", &A);\n\tscanf(\"%lld\", &B);\n\tvector<vector<ll>> d(A-1+1,vector<ll>(B-1+1));\n\tfor (int i = 0 ; i <= A-1 ; i++) {\n\t  for (int j = 0 ; j <= B-1 ; j++) {\n\t    scanf(\"%lld\", &d[i][j]);\n\t  }\n\t}\n\tsolve(A, B, d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid solve(){\n  int A,B;\n  cin >> A >> B;\n\n  vector<vector<int>> d(A,vector<int>(B));\n  REP(i,A) REP(j,B) cin >> d[i][j];\n  \n  int s = 1, t = 300;\n  mat e(A,vec(B,LINF));\n  vector<T> ans; \n  REP2(i,100) REP2(j,100){\n    int f = 0;\n    REP(a,A) REP(b,B){\n      chmax(f,d[a][b]-(a+1)*i-(b+1)*j);\n    }\n    assert(f <= 100);\n    REP(a,A) REP(b,B){\n      chmin(e[a][b],(a+1)*i+(b+1)*j+f);\n    }\n    ans.emplace_back(i+1,300-j,f);\n  }\n\n  REP(i,A) REP(j,B){\n    if(d[i][j]!=e[i][j]){\n      cout << \"Impossible\" << endl;\n      return;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 300 SP 200+ans.size() << endl;\n  REP(i,100) cout << i+1 SP i+2 << \"X\" << endl;\n  REP(i,100) cout << 200+i SP 201+i << \"Y\" << endl;\n  REP(i,ans.size()){\n    int x,y,z;\n    tie(x,y,z) = ans[i];\n    cout << x SP y SP z << endl;\n  }\n  cout << s SP t << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10401\");\n\t\n\tfor(int i = 1;i <= 100;++i) printf(\"%d %d X\\n\",i,i + 1);\n\tfor(int i = 102;i < 202;++i) printf(\"%d %d Y\\n\",i,i + 1);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",1 + i,202 - j,f[i][j]);\n\tputs(\"1 202\");\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define mp make_pair\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cerr <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n\n\nusing namespace std;\n\nint d[15][15];\nint N;\nint g[305][305];\nVI vy, vx;\n\nint check[15][15];\n\nint main () {\n\tmake2(A, B);\n\tFOR(i,0,A) FOR(j,0,B) {\n\t\tmake(x); d[i+1][j+1] = x;\n\t}\n\tvector<pair<PII, int > > v;\n\tFOR(a,0,101) FOR(b,0,101) {\n\t\tint c = -1000;\n\t\tFOR(x,1,A+1) FOR(y,1,B+1) {\n\t\t\tc = max(c, d[x][y]-a*x-b*y);\n\t\t}\n\t\tif (c < 0) continue;\n\t\tv.pb(mp(mp(a,b),c));\n\t}\n\tN = 2;\n\tFOR(i,0,305) FOR(j,0,305) g[i][j] = -3;\n\tint maxa = 0;\n\tint maxb = 0;\n\tFORE(i, v) maxa = max(maxa, i->st.st);\n\tFORE(i, v) maxb = max(maxb, i->st.nd);\n\tint S = 0; vx.pb(S);\n\tint T = 1; vy.pb(T);\n\tint act = 2;\n\tFOR(i,0,maxa) {\n\t\tg[vx.back()][act] = -1;\n\t\tg[act][vx.back()] = -1;\n\t\tvx.pb(act); \n\t\tact++;\n\t}\n\tFOR(i,0,maxb) {\n\t\tg[vy.back()][act] = -2;\n\t\tg[act][vy.back()] = -2;\n\t\tvy.pb(act); \n\t\tact++;\n\t}\n\tFORE(i,v) {\n\t\tint a = i->st.st;\n\t\tint b = i->st.nd;\n\t\tint c = i->nd;\n\t\tg[vx[a]][vx[b]] = c;\n\t\tg[vx[b]][vx[a]] = c;\n\t\tFOR(ii,1,A+1) FOR(jj,1,B+1) {\n\t\t\tif (ii*a +jj*b + c == d[ii][jj]) check[ii][jj] = 1;   \n\t\t}\n\t}\n\tFOR(i,1,A+1) FOR(j,1,B+1) {\n\t\tif (check[i][j] != 1) {\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tint m = 0;\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] != -3) m++;\n\t}\n\tprintf(\"%d %d\\n\", act, m);\n\tFOR(i,0,act) FOR(j,i+1,act) {\n\t\tif (g[i][j] == -1) {\n\t\t\tprintf(\"%d %d X\\n\", i+1, j+1);\n\t\t}\n\t\telse if (g[i][j] == -2) {\n\t\t\tprintf(\"%d %d Y\\n\", i+1, j+1);\n\t\t} else if (g[i][j] >= 0) {\n\t\t\tprintf(\"%d %d %d\\n\", i+1, j+1, g[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 2\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nint d[11][11];\nint c[101][101];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint a,b;\n\tcin>>a>>b;\n\trep(i,1,a)\n\trep(j,1,b)cin>>d[i][j];\n\tint n=101+101;\n\trep(x,0,100)\n\trep(y,0,100)\n\t{\n\t\trep(i,1,a)\n\t\trep(j,1,b)chmax(c[x][y],d[i][j]-(i*x+j*y));\n\t}\n\trep(i,1,a)\n\trep(j,1,b)\n\t{\n\t\trep(x,0,100)\n\t\trep(y,0,100)\n\t\tif(i*x+j*y+c[x][y]==d[i][j])goto have;\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t\thave : ;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,101*101+100*2);\n\trep(x,1,100)printf(\"%d %d x\\n\",x,x+1);\n\trep(y,1,100)printf(\"%d %d y\\n\",n-y,n-y+1);\n\trep(x,0,100)\n\trep(y,0,100)printf(\"%d %d %d\\n\",1+x,n-y,c[x][y]);\n\tprintf(\"%d %d\\n\",1,n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n\nint n, m, a[10][10];\nint S, T, id;\nvector<II> vres;\n\nvoid add(int x, int y, int z) {\n\tint cur = S;\n\t// -1 : A, -2 : B\n\twhile (x--) vres.push_back(II(-1, ii(cur, ++id))), cur = id;\n\twhile (y--) vres.push_back(II(-2, ii(cur, ++id))), cur = id;\n\tvres.push_back(II(z, ii(cur, T)));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 2, id = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tsort(vres.begin(), vres.end());\n\tvres.erase(unique(vres.begin(), vres.end()), vres.end());\n\tassert(id <= 300);\n\tcout << \"Possible\\n\";\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.se.fi << ' ' << i.se.se << ' ';\n\t\tif (i.fi == -1) cout << \"X\\n\";\n\t\tif (i.fi == -2) cout << \"Y\\n\";\n\t\tif (i.fi >= 0) cout << i.fi << '\\n';\n\t}\n\tcout << S << ' ' << T;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=1e2+10;\nint d[maxn][maxn],f[maxn][maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\nint main(){\n\tint i,j,k,l,m,n;\n\tint a,b;\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\ta=read();b=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\td[i][j]=read();\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++)\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tf[k][l]=max(f[k][l],d[i][j]-i*k-j*l);\n\tfor(i=1;i<=a;i++)\n\t\tfor(j=1;j<=b;j++){\n\t\t\tint dis=INF;\n\t\t\tfor(k=0;k<=100;k++)\n\t\t\t\tfor(l=0;l<=100;l++)\n\t\t\t\t\tdis=min(dis,f[k][l]+i*k+j*l);\n\t\t\tif(dis!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tn=202,m=101*101+200;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,m);\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;i++)\n\t\tfor(j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n    int A, B; cin >> A >> B;\n    vector d(A, vector(B, 0));\n    for(auto& v : d){\n        for(auto& t : v) cin >> t;\n    }\n    int ofs[101][101];\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            ofs[i][j] = 0;\n            for(int a=1;a<=A;a++){\n                for(int b=1;b<=B;b++){\n                    ofs[i][j] = max(ofs[i][j], d[a-1][b-1]-(i*a+j*b));\n                }\n            }\n        }\n    }\n    bool ok = true;\n    for(int a=1;a<=A;a++){\n        for(int b=1;b<=B;b++){\n            int r = 10000;\n            for(int i=0;i<=100;i++){\n                for(int j=0;j<=100;j++){\n                    r = min(r, i*a+j*b+ofs[i][j]);\n                }\n            }\n            if(r != d[a-1][b-1]) ok = false;\n        }\n    }\n    if(ok){\n        cout << \"Possible\" << endl;\n        cout << 200 + 101*101 << endl;\n        for(int i=1;i<=100;i++){\n            cout << i << \" \" << i+1 << \" X\" << endl;\n            cout << 151+i << \" \" << 150+i << \" Y\" << endl;\n        }\n        for(int i=0;i<=100;i++){\n            for(int j=0;j<=100;j++){\n                cout << i+1 << \" \" << j+151 << \" \" << ofs[i][j] << endl;\n            }\n        }\n        cout << 1 << \" \" << 151 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<numeric>\n#include<bitset>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define MOD 1000000007\n#define EPS 1e-9\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n\n    int A,B;\n    cin >> A >> B;\n    int d[A+1][B+1], f[101][101], dmax = 100;\n    reppp(i, 1, A+1) reppp(j, 1, B+1){\n        cin >> d[i][j];\n        // dmax = max(dmax, d[i][j]);\n    }\n\n    repp(a, dmax+1) repp(b, dmax+1){\n        int m = 0;\n        reppp(x, 1, A+1) reppp(y, 1, B+1){\n            m = max(m, d[x][y] - x*a - y*b);\n        }\n        f[a][b] = max(0, m);\n    }\n\n    reppp(x, 1, A+1) reppp(y, 1, B+1){\n        int shortest = INT_MAX;\n        repp(a, dmax+1) repp(b, dmax+1){\n            shortest = min(shortest, x*a + y*b + f[a][b]);\n        }\n        if(d[x][y] != shortest){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", (dmax+1)*2, (dmax+1)*(dmax+1) + 2*dmax);\n    reppp(n, 1, dmax+1) printf(\"%d %d X\\n\", n, n+1);\n    reppp(n, dmax+2, 2*dmax+2) printf(\"%d %d Y\\n\", n, n+1);\n    repp(a, dmax+1) repp(b, dmax+1) printf(\"%d %d %d\\n\", a+1, 2*dmax+2-b, f[a][b]);\n    printf(\"1 %d\\n\", 2*dmax+2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint A, B;\nint D[10][10];\nint f[101][101];\nint main(){\n    cin >> A >> B;\n\n    for (int i = 0; i < A; ++i) {\n        for (int j = 0; j < B; ++j) {\n            cin >> D[i][j];\n        }\n    }\n\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            int fmax = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    int tmp = max(0, D[x - 1][y - 1] - a * x - b * y);\n                    if (tmp > fmax) fmax = tmp;\n                }\n            }\n            f[a][b] = fmax;\n            cout << fmax << \" \";\n        }\n        cout << endl;\n    }\n\n    bool possible = true;\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            int dmin = 1000;\n            for (int a = 0; a <= 100; ++a) {\n                for (int b = 0; b <= 100; ++b) {\n                    int dist = a * x + b * y + f[a][b];\n                    if (dmin > dist) dmin = dist;\n                }\n            }\n            if (dmin != D[x - 1][y - 1]) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) break;\n    }\n\n    if (possible) {\n        \n        cout << 202 << \" \" << 101 * 101 + 200 << endl;\n        for (int i = 1; i <= 100; ++i) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n            cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n        }\n\n        for (int a = 0; a <= 100; ++a) {\n            for (int b = 0; b <= 100; ++b) {\n                cout << a + 1 << \" \" << b + 102 << \" \" << f[a][b] << endl;\n            }\n        }\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\n#define int long long\n\nconst int MOD = 1e9 + 7;\n\nint a, b;\nint d[50][50];\nint go[200][200];\n\nsigned main()\n{\n    //freopen(\"input_02.txt\", \"r\", stdin);\n    //freopen(\"output_02.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            int max_c = -1e9;\n            for (int x = 1; x <= a; x++)\n            {\n                for (int y = 1; y <= b; y++)\n                {\n                    int moved = i * x + j * y;\n                    int add = d[x][y] - moved;\n                    max_c = max(max_c, add);\n                }\n            }\n            if (max_c <= 100 && 0 <= max_c)\n            {\n                go[i][j] = max_c;\n            }\n            else\n            {\n                go[i][j] = 1e9;\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (x * i + go[i][j] + y * j < d[x][y])\n                    {\n                        go[i][j] = 1e9;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            int min_c = 1e9;\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (min_c > i * x + go[i][j] + j * y)\n                    {\n                        min_c = i * x + go[i][j] + j * y;\n                    }\n                }\n            }\n            if (min_c != d[x][y])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    int cnt = 0;\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j]) cnt++;\n        }\n    }\n    cout << 202 << \" \" << cnt + 200 << \"\\n\";\n    for (int i = 0; i < 100; i++)\n    {\n        cout << i + 1 << \" \" << i + 2 << \" \" << 'X' << \"\\n\";\n    }\n    for (int j = 0; j < 100; j++)\n    {\n        cout << 202 - j - 1 << \" \" << 202 - j << \" \" << 'Y' << \"\\n\";\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j])\n            {\n                cout << i + 1 << \" \" << 202 - j << \" \" << go[i][j] << \"\\n\";\n            }\n        }\n    }\n    cout << 1 << \" \" << 202 << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long int;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 373;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> init_vector2(size_t n0, size_t n1, T e = T()) {\n    return vector2<T>(n0, vector<T>(n1, e));\n}\n\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> init_vector3(size_t n0, size_t n1, size_t n2, T e = T()) {\n    return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\n\nint main() {\n    cout << \"Impossible\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(int A, int B) {\n  int dist[10][10];\n  for (int i = 0; i < A; i++) {\n    for (int j = 0; j < B; j++) {\n      cin >> dist[i][j];\n    }\n  }\n\n  int T = 100;\n  vector<vector<int>> data(T, vector<int>(T, -1));\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int basecost = 0;\n          basecost += (i + 1) * x;\n          basecost += (j + 1) * y;\n          int amari = dist[i][j] - basecost;\n          data[x][y] = max(data[x][y], amari);\n        }\n    }\n  }\n\n  int cnt = 0;\n  vector<vector<int>> ans(A, vector<int>(B, 200));\n  for (int x = 0; x < T; x++)\n    for (int y = 0; y < T; y++) {\n      cout << x << \" \" << y << \" \" << data[x][y] << endl;\n      if (data[x][y] < 0) continue;\n      cnt++;\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int cost = (i + 1) * x + (j + 1) * y + data[x][y];\n          ans[i][j] = min(ans[i][j], cost);\n        }\n    }\n  for (int i = 0; i < A; i++)\n    for (int j = 0; j < B; j++)\n      if (ans[i][j] != dist[i][j]) return false;\n\n  cout << \"POSSIBLE\" << endl;\n  cout << 2 * T + 1 << \" \" << 2 * T + cnt << endl;\n  for (int i = 0; i < T; i++) {\n    cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n  }\n  for (int i = 0; i < T; i++) {\n    cout << i + T + 1 << \" \" << i + T + 2 << \" Y\" << endl;\n  }\n  int s = 1;\n  int t = T + T + 1;\n\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      if (data[x][y] < 0) continue;\n      cout << s + x << \" \" << t - y << \" \" << data[x][y] << endl;\n    }\n  }\n  cout << s << \" \" << t << endl;\n  return true;\n}\nint main() {\n  int A, B;\n  cin >> A >> B;\n  bool ok = solve(A, B);\n  if (!ok) {\n    cout << \"IMPOSSIBLE\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 301\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int A, B;\n    cin >> A >> B;\n\n    vvi d(A + 1, vi(B + 1));\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++)\n            cin >> d[i][j];\n    }\n\n    vvi c(101, vi(101));\n    for (int xc = 0; xc <= 100; xc++) {\n        for (int yc = 0; yc <= 100; yc++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[xc][yc] = max(c[xc][yc], d[x][y] - xc * x - yc * y);\n                }\n            }\n        }\n    }\n\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int sp = INT_MAX;\n            for (int xc = 0; xc <= 100; xc++) {\n                for (int yc = 0; yc <= 100; yc++) {\n                    sp = min(sp, xc * x + yc * y + c[xc][yc]);\n                }\n            }\n            if (sp != d[x][y]) { cout << \"Impossible\\n\"; return 0; }\n        }\n    }\n\n    int XL = 1, YL = XL + 101;\n    int V = YL + 100, E = 100 + 100 + 101 * 101;\n\n    cout << \"Possible\\n\";\n    cout << V << \" \" << E << \"\\n\";\n    for (int xc = 1; xc <= 100; xc++)\n        cout << (XL + xc - 1) << \" \" << (XL + xc) << \" X\\n\";\n    for (int yc = 0; yc < 100; yc++)\n        cout << (YL + yc) << \" \" << (YL + yc + 1) << \" Y\\n\";\n    for (int xc = 0; xc <= 100; xc++)\n        for (int yc = 0; yc <= 100; yc++)\n            cout << (XL + xc) << \" \" << (YL + yc) << \" \" << c[xc][yc] << \"\\n\";\n    cout << 1 << \" \" << V << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=71;\n  Int sz=N*4;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  auto idx2=[&](Int x){return N*2+x;};\n  auto idy2=[&](Int y){return N*3+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*k);\n\tchmax(D[k],d[i][j]-(j+1)*k);\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tfor(Int l=0;l<N;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx2(N-1)].emplace_back(t,0);\n  G[idy2(N-1)].emplace_back(t,0);\n  \n  for(Int k=0;k<N;k++){\n    G[idx(k)].emplace_back(t,C[k]);\n    G[idy(k)].emplace_back(t,D[k]);\n     \n    for(Int l=0;l<N;l++){\n      G[idx(k)].emplace_back(idy2(l),E[k][l]);\n      G[idy(k)].emplace_back(idx2(l),F[k][l]);      \n    }\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n\tT[idx2(k-1)].emplace_back(idx2(k),i+1);\n\tT[idy2(k-1)].emplace_back(idy2(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      //cout<<dist<<\" \"<<d[i][j]<<endl;\n      flg&=(dist==d[i][j]);\n      assert(dist>=d[i][j]);\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n    X[idx2(i-1)].emplace_back(idx2(i));\n    Y[idy2(i-1)].emplace_back(idy2(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_A = 11;\nconst int MAX_N = 2e2 + 10;\n\nint A, B, Nr[MAX_A][MAX_A];\n\n\nconst int ITER = 100;\nint N = 2*ITER + 2;\nvector<pi> Ed[MAX_N];\nint Ans[ITER+1][ITER+1];\nint main() {\n\tcin >> A >> B;\n\tfor(int i=1; i<=A; i++) for(int j=1; j<=B; j++) scanf(\"%d\", &Nr[i][j]);\n\tfor(int i=1; i<=ITER; i++) Ed[i].emplace_back(i+1, 'X'+1000);\n\tfor(int i=ITER+2; i<N; i++) Ed[i].emplace_back(i+1, 'Y'+1000);\n\t\n\tfor(int i=0; i<=ITER; i++) for(int j=0; j<=ITER; j++) {\n\t\tint val = 0;\n\t\tfor(int a=1; a<=A; a++) for(int b=1; b<=B; b++)\n\t\t\tval = max(Nr[a][b] - a*i - b*j, val);\n\t\tAns[i][j] = val;\n\t\t//printf(\"%d %d : %d\\n\", i, j, val);\n\t\tif(val >= 0 && val <= 100)\n\t\t\tEd[i+1].emplace_back(N-j, val);\n\t}\n\n\tfor(int a=1; a<=A; a++) for(int b=1; b<=B; b++) {\n\t\tint now = INF;\n\t\tfor(int i=0; i<=ITER; i++) for(int j=0; j<=ITER; j++) {\n\t\t\tint val = Ans[i][j]; \n\t\t\tif(val >= 0 && val <= 100) now = min(now, val + a*i + b*j);\n\t\t}\n\t\tif(now != Nr[a][b]) return puts(\"Impossible\") < 0;\n\t}\n\tputs(\"Possible\");\n\tint M = 0; \n\tfor(int i=1; i<=N; i++) M += SZ(Ed[i]);\n\tprintf(\"%d %d\\n\", N, M);\n\tfor(int v=1; v<=N; v++) {\n\t\tfor(auto &val : Ed[v]) {\n\t\t\tint w, c; tie(w, c) = val;\n\t\t\tif(c >= 1000) printf(\"%d %d %c\\n\", v, w, c - 1000);\n\t\t\telse printf(\"%d %d %d\\n\", v, w, c);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 1, N);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\nconst int MA = 100;\nconst int MA2 = MA + 1;\nint A, B, D[10][10];\nint C[MA2][MA2];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> A >> B;\n    rep(x, 0, A) rep(y, 0, B) cin >> D[x][y];\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        rep(i, 0, MA2) rep(j, 0, MA2) chmax(C[i][j], D[a][b] - i * x - j * y);\n    }\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        int d = inf;\n        rep(i, 0, MA2) rep(j, 0, MA2) chmin(d, i * x + j * y + C[i][j]);\n        if (d != D[a][b]) {\n            printf(\"Impossible\\n\");\n            //printf(\"[%d %d]\\n\", d, D[a][b]);\n            return;\n        }\n    }\n\n    vector<tuple<int, int, int>> edges;\n    rep(i, 0, MA) edges.push_back(make_tuple(i, i + 1, -1));\n    rep(i, 0, MA) edges.push_back(make_tuple(MA2 + i, MA2 + i + 1, -2));\n    rep(i, 0, MA2) rep(j, 0, MA2) edges.push_back(make_tuple(i, MA2 * 2 - 1 - j, C[i][j]));\n\n    printf(\"Possible\\n\");\n    printf(\"%d %d\\n\", MA2 * 2, edges.size());\n    fore(t, edges) {\n        int a, b, c;\n        tie(a, b, c) = t;\n        a++; b++;\n        if (c == -1) printf(\"%d %d X\\n\", a, b);\n        else if (c == -2) printf(\"%d %d Y\\n\", a, b);\n        else printf(\"%d %d %d\\n\", a, b, c);\n    }\n    printf(\"1 %d\\n\", MA2 * 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 301\nll d[N][N];\nll g[M+10][M+10];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\nconstexpr int V = 2 * (d_max + 1);\nconstexpr int S = 0, T = V - 1;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  std::array<std::array<int, d_max + 1>, d_max + 1> cost{};\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      for (int a: range(0, A + 1)) {\n        for (int b: range(0, B + 1)) {\n          chmax(cost[a][b], dist[i][j] - (i + 1) * a - (j + 1) * b);\n        }\n      }\n    }\n  }\n  std::array<std::pair<int, int>, d_max> Xs{};\n  std::array<std::pair<int, int>, d_max> Ys{};\n  for (int i: range(0, d_max)) {\n    Xs[i] = { i, i + 1 };\n    Ys[i] = { V - i - 2, V - i - 1 };\n  }\n  auto calc = [&](int x, int y) {\n    std::array<std::vector<std::pair<int, int>>, V> graph{};\n    for (int i: range(0, d_max)) {\n      graph[Xs[i].first].emplace_back(Xs[i].second, x);\n      graph[Ys[i].first].emplace_back(Ys[i].second, y);\n    }\n    for (int i: range(0, d_max + 1)) {\n      for (int j: range(0, d_max + 1)) {\n        if (cost[i][j] <= d_max) {\n          graph[i].emplace_back(V - j - 1, cost[i][j]);\n        }\n      }\n    }\n    std::array<int, V> length{};\n    length.fill(d_max + 1);\n    length[S] = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(length[S], S);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > length[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(length[e.first], length[v] + e.second)) {\n          que.emplace(length[e.first], e.first);\n        }\n      }\n    }\n    return length[T];\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (dist[i][j] != calc(i + 1, j + 1)) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  return 1;\n  int E = 2 * d_max;\n  for (const auto &arr: cost) {\n    for (auto x: arr) {\n      if (x <= d_max) {\n        ++E;\n      }\n    }\n  }\n  std::cout << V << ' ' << E << '\\n';\n  for (auto e: Xs) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" X\\n\";\n  }\n  for (auto e: Ys) {\n    std::cout << e.first + 1 << ' ' << e.second + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (cost[i][j] <= d_max) {\n        std::cout << i + 1 << ' ' << V - j << ' ' << cost[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << S + 1 << ' ' << T + 1 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      f[i][j] = inf;\n      rep(x, a){\n        rep(y, b){\n          chmin(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n      if(f[i][j] < 0)f[i][j] = 0;\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][100-j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nll svkek[200][200];\n\nint main()\n{\n\tfastInp;\ncout << \"Impossible\";\n\t\t\t\treturn 0;\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\t\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsvkek[i][j] = c;\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= a; x++) {\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tll z = 10000;\n\t\t\tfor (int i = 0; i <= a; i++) {\n\t\t\t\tfor (int t = 0; t <= b; t++) {\n\t\t\t\t\tz = min(z, svkek[i][t] + (i * x) + (t * y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (z != grid[x - 1][y - 1]) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define Fail() { printf(\"Impossible\"); return 0; }\nusing namespace std;\n\nconst int MAXN = 12;\nint A, B, D[MAXN][MAXN];\n\nstruct solve {\n    int N, val[MAXN], curK[MAXN], curB[MAXN], curV[MAXN];\n    bool equ[MAXN], Found = 0;\n#define searchIn() \\\n    for(curK[d] = curK[d - 1]; curK[d] >= 0; curK[d]--) { \\\n        if(Found) return; \\\n \\\n        curB[d] = curV[d] - curK[d] * d; \\\n        if(curB[d] >= curB[d - 1]) { \\\n            bool Ok = 1; \\\n            for(int i = 1; i < d; i++) if( curK[d] * i + curB[d] < val[i] ) { Ok = 0; break; } \\\n \\\n            if(Ok) dfs(d + 1); \\\n        } \\\n    }\n\n    void dfs(int d) {\n        if(d == N + 1) { Found = 1; return; }\n        //get min value here\n        int mindist = 100;\n        for(int i = 1; i < d; i++) mindist = min(mindist, curK[i] * d + curB[i]);\n        if(mindist < val[d]) return; //Fail\n        if(equ[d]) {\n            curV[d] = val[d];\n            searchIn()\n        }\n        else {\n            for(curV[d] = val[d]; curV[d] <= mindist; curV[d]++) searchIn()\n        }\n    }\n} SvX, SvY;\n\nint main() {\n    int x, y;\n    scanf(\"%d%d\", &A, &B);\n    for(x = 1; x <= A; x++) for(y = 1; y <= B; y++) scanf(\"%d\", &D[x][y]);\n    //check X & get val X\n    for(x = 1; x <= A; x++) {\n        for(y = 1; y <= B; y++) {\n            if(D[x][y] < D[x][y - 1]) Fail()\n            if(D[x][y] == D[x][y + 1]) SvX.val[x] = D[x][y], SvX.equ[x] = 1;\n        }\n        if(!SvX.equ[x]) SvX.val[x] = D[x][B];\n    }\n    SvX.N = A, SvX.curK[0] = 100, SvX.dfs(1);\n    if(!SvX.Found) Fail()\n\n    for(y = 1; y <= B; y++) {\n        for(x = 1; x <= A; x++) {\n            if(D[x][y] < D[x - 1][y]) Fail()\n            if(D[x][y] == D[x + 1][y]) SvY.val[y] = D[x][y], SvY.equ[y] = 1;\n        }\n        if(!SvY.equ[y]) SvY.val[y] = D[A][y];\n    }\n    SvY.N = B, SvY.curK[0] = 100, SvY.dfs(1);\n    if(!SvY.Found) Fail()\n\n    //Construct\n    int PS = 1, PT = 300, pPool = 2, pLast;\n    printf(\"%d\\n\", 300);\n\n    //x\n    for(x = 1; x <= A; x++) {\n        pLast = pPool++; printf(\"%d %d %d\\n\", PS, pLast, SvX.curB[x]);\n        for(int i = 1; i <= SvX.curK[x]; i++) printf(\"%d %d X\\n\", pLast, pPool), pLast = pPool++;\n        printf(\"%d %d %d\\n\", pLast, PT, 0);\n    }\n    //y\n    for(x = 1; x <= B; x++) {\n        pLast = pPool++; printf(\"%d %d %d\\n\", PS, pLast, SvY.curB[x]);\n        for(int i = 1; i <= SvY.curK[x]; i++) printf(\"%d %d X\\n\", pLast, pPool), pLast = pPool++;\n        printf(\"%d %d %d\\n\", pLast, PT, 0);\n    }\n\n    printf(\"%d %d\", PS, PT);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[191][111];\nint l[100][99];\nint j[111];\n\nlong long x,y,z,mod=1000000007;\n//string r,r1;\nchar r[1];\n\nP u[10];\nqueue<P> q;\n//stack<int> s;\nmap<int,int> p;\nvector<int> v;\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&a,&b);\n  for(int t=1;t<=a;t++)\n    for(int w=1;w<=b;w++)\n    {\n      scanf(\"%d\",&l[t][w]);\n      for(int i=0;i*t<=l[t][w];i++)\n      for(int j=0;i*t+j*w<=l[t][w];j++)\n      o[i][j]=max(o[i][j],l[t][w]-i*t-j*w);\n    }\n  for(int t=1;t<=a;t++)\n  for(int w=1;w<=b;w++)\n  {\n    int p=mod;\n    for(int i=0;i*t<=l[t][w];i++)\n    for(int j=0;i*t+j*w<=l[t][w];j++)\n    p=min(p,i*t+j*w+o[i][j]);\n    if(p!=l[t][w])\n    {\n      puts(\"Impossible\");\n      return 0;\n    }\n  }\n  puts(\"Possible\");\n  for(int t=1;t<=a;t++)\n    printf(\"%d %d X\\n\",t,t+1);\n  for(int t=a+2;t<a+b+2;t++)\n    printf(\"%d %d Y\\n\",t,t+1);\n  for(int i=1,t=0;i<=a+1;t++,i++)\n  for(int j=a+b+2,w=0;j>=a+2;j--,w++)\n    printf(\"%d %d %d\\n\",i,j,o[t][w]);\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint A,B;\nint D[11][11];\n\nvector<int>X,Y,Z;\n\nsigned main(){\n    cin>>A>>B;\n    for(int i=1;i<=A;i++)for(int j=1;j<=B;j++)cin>>D[i][j];\n\n    rep(i,100){\n        X.pb(i);Y.pb(i+1);Z.pb(-1);\n        X.pb(i+100);Y.pb(i+1+100);Z.pb(-2);\n    }\n    int S=0,T=200;\n\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            bool flag=false;\n            for(int k=0;k<=100;k++)for(int l=0;l<=100;l++){\n                if(flag)continue;\n                if(k*i+l*j>D[i][j])continue;\n                int m=D[i][j]-k*i-l*j;\n                bool ok=true;\n                for(int x=1;x<=A;x++)for(int y=1;y<=B;y++)if(k*x+l*y+m<D[x][y])ok=false;\n                if(!ok)continue;\n                flag=true;\n\n                bool latte=false;\n                rep(w,X.size())if(X[w]==k&&Y[w]==200-l)latte=true;\n                if(!latte){X.pb(k);Y.pb(200-l);Z.pb(m);}\n\n            }\n            if(!flag){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"Possible\"<<endl;\n\n\n\n    cout<<201<<\" \"<<X.size()<<endl;\n    rep(i,X.size()){\n        cout<<X[i]+1<<\" \"<<Y[i]+1<<\" \";\n        if(Z[i]==-1)cout<<\"X\"<<endl;\n        else if(Z[i]==-2)cout<<\"Y\"<<endl;\n        else cout<<Z[i]<<endl;\n    }\n    cout<<S+1<<\" \"<<T+1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 0x7fffffff\n\nint A,B;\nint D[15][15],F[305][305];\n\nvoid init(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++){\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tscanf(\"%d\",&D[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tF[i][j]=max(F[i][j],D[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++){\n\t\tfor(int y=1;y<=B;y++){\n\t\t\tint f=INF;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tf=min(f,F[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f!=D[x][y]){\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor(int i=102;i<202;i++){\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,F[i][j]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tinit();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint A, B;\n\tint d[20][20];\n\n\tcin >> A >> B;\n\trep(i,A) rep(j,B) cin >> d[i][j];\n\n\tvector<pair<pii,int>> v;\n\tbool ok[20][20] = {};\n\trep(a,101) rep(b,101) rrep(c,101){\n\t\tbool f = true, check = false;\n\t\trep(i,A) rep(j,B){\n\t\t\tint s = a*(i+1) + b*(j+1) + c;\n\t\t\tif( d[i][j] > s ) f = false;\n\t\t}\n\t\tif(!f) break;\n\t\trep(i,A) rep(j,B){\n\t\t\tint s = a*(i+1) + b*(j+1) + c;\n\t\t\tif( f && d[i][j] == s ){\n\t\t\t\tok[i][j] = true;\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tif(f && check) v.emplace_back(pii(a,b), c);\n\t}\n\n\tbool ans = true;\n\trep(i,A) rep(j,B) if( !ok[i][j] ) ans = false;\n\n\tif( !ans ){\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}else{\n\t\tcout << \"Possible\" << endl;\n\t}\n\n\tvector<pair<pii,int>> edge;\n\trep(i,101) edge.emplace_back( pii(i+1,i+2), -1 );\n\trep(i,101) edge.emplace_back( pii(200+i-1,200+i), -2 );\n\tfor(auto p: v){\n\t\tint a = p.X.X;\n\t\tint b = p.X.Y;\n\t\tint c = p.Y;\n\t\tedge.emplace_back( pii(a+1, 300-b), c );\n\t}\n\n\tcout << 300 << \" \" << edge.size() << endl;\n\tfor(auto t: edge){\n\t\tcout << t.X.X << \" \" << t.X.Y << \" \";\n\t\tif( t.Y == -1 ) cout << \"X\" << endl;\n\t\telse if( t.Y == -2 ) cout << \"Y\" << endl;\n\t\telse cout << t.Y << endl;\n\t}\n\tcout << 1 << \" \" << 300 << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint A, B;\nint D[10][10];\nint f[101][101];\nint main(){\n    cin >> A >> B;\n\n    for (int i = 0; i < A; ++i) {\n        for (int j = 0; j < B; ++j) {\n            cin >> D[i][j];\n        }\n    }\n\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            int fmax = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    int tmp = max(0, D[x - 1][y - 1] - a * x - b * y);\n                    if (tmp > fmax) fmax = tmp;\n                }\n            }\n            f[a][b] = fmax;\n            //cout << fmax << \" \";\n        }\n        //cout << endl;\n    }\n\n    bool possible = true;\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            int dmin = 1000;\n            for (int a = 0; a <= 100; ++a) {\n                for (int b = 0; b <= 100; ++b) {\n                    int dist = a * x + b * y + f[a][b];\n                    if (dmin > dist) dmin = dist;\n                }\n            }\n            if (dmin != D[x - 1][y - 1]) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) break;\n    }\n\n    if (possible) {\n        cout << \"Possible\" << endl;\n        cout << 202 << \" \" << 101 * 101 + 200 << endl;\n        for (int i = 1; i <= 100; ++i) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n            cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n        }\n\n        for (int a = 0; a <= 100; ++a) {\n            for (int b = 0; b <= 100; ++b) {\n                cout << a + 1 << \" \" << 202 - b << \" \" << f[a][b] << endl;\n            }\n        }\n        cout << \"1 202\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"202 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=102;i<202;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nint f[MAXN][MAXN];\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      for (int x = 0; x <= 100; x++) {\n        for (int y = 0; y <= 100; y++) {\n          int cur = (i + 1) * x + (j + 1) * y;\n          f[x][y] = max(f[x][y], d[i][j] - cur);\n        }\n      }\n    }\n  }\n\n  for (int i = 1; i <= a; i++) {\n    for (int j = 1; j <= b; j++) {\n      int dist = 1e9;\n      for (int x = 0; x <= 100; x++) {\n        for (int y = 0; y <= 100; y++) {\n          dist = min(dist, i * x + j * y + f[x][y]);\n        }\n      }\n      if (dist != d[i - 1][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  puts(\"Possible\");\n  \n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= 100; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= 100; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  for (int x = 0; x <= 100; x++) {\n    for (int y = 0; y <= 100; y++) {\n      addEdge(2 + x, n - 1 - y, f[x][y]);\n    }\n  }\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\nconst int MA = 100;\nconst int MA2 = MA + 1;\nint A, B, D[10][10];\nint C[MA2][MA2];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> A >> B;\n    rep(x, 0, A) rep(y, 0, B) cin >> D[x][y];\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        rep(i, 0, MA2) rep(j, 0, MA2) chmax(C[i][j], D[a][b] - i * x - j * y);\n    }\n\n    rep(a, 0, A) rep(b, 0, B) {\n        int x = a + 1, y = b + 1;\n        int d = inf;\n        rep(i, 0, MA2) rep(j, 0, MA2) chmin(d, i * a + j * y + C[i][j]);\n        if (d != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return;\n        }\n    }\n\n    vector<tuple<int, int, int>> edges;\n    rep(i, 0, MA) edges.push_back(make_tuple(i, i + 1, -1));\n    rep(i, 0, MA) edges.push_back(make_tuple(MA2 + i, MA2 + i + 1, -2));\n    rep(i, 0, MA2) rep(j, 0, MA2) edges.push_back(make_tuple(i, MA2 * 2 - 1 - j, C[i][j]));\n\n    printf(\"Possible\\n\");\n    printf(\"%d %d\\n\", MA2 * 2, edges.size());\n    fore(t, edges) {\n        int a, b, c;\n        tie(a, b, c) = t;\n        a++; b++;\n        if (c == -1) printf(\"%d %d X\\n\", a, b);\n        else if (c == -2) printf(\"%d %d Y\\n\", a, b);\n        else printf(\"%d %d %d\\n\", a, b, c);\n    }\n    printf(\"1 %d\\n\", MA2 * 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint A, B;\nint d[11][11];\npair<pii, int> info[11][11];\n\nint main() {\n\tcin >> A >> B;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tint maxi = 0;\n\tint u = 0;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tvector<pii> cand;\n\t\t\tfor (int k = 0; k <= 100; ++k) {\n\t\t\t\tfor (int l = 0; l <= 100; ++l) {\n\t\t\t\t\tif (k * i + l * j > d[i][j]) continue;\n\t\t\t\t\tint c = d[i][j] - k * i - l * j;\n\t\t\t\t\tbool ok = 1;\n\n\t\t\t\t\tfor (int p = 1; p <= A; ++p) {\n\t\t\t\t\t\tfor (int q = 1; q <= B; ++q) {\n\t\t\t\t\t\t\tif (p * k + q * l + c < d[p][q]) {\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tcand.eb(k, l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cand.size() == 0) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpii la = cand.back();\n\t\t\t\tu = max(u, la.fi);\n\t\t\t\tmaxi = max(maxi, la.se);\n\t\t\t\tint zan = d[i][j] - la.fi * i - la.se * j;\n\t\t\t\tinfo[i][j] = mp(la, zan);\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\n\tvector<pair<pii, int>> vec;\n\n\tint S = 0;\n\tint now = u + 1;\n\n\trep(i, u) {\n\t\tvec.eb(mp(i, i + 1), -1);\n\t}\n\n\tint T = now;\n\n\trep(i, maxi) {\n\t\t++now;\n\t\tvec.eb(mp(now, now - 1), -2);\n\t}\n\t++now;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tpii p = info[i][j].fi;\n\t\t\tint c = info[i][j].se;\n\t\t\tvec.eb(mp(p.fi, now), c);\n\t\t\tvec.eb(mp(now, T + p.se), 0);\n\t\t\t++now;\n\t\t}\n\t}\n\n\tcout << now << \" \" << vec.size() << endl;\n\tfor (auto e : vec) {\n\t\tprintf(\"%d %d \", e.fi.fi + 1, e.fi.se + 1);\n\t\tif (e.se == -1) {\n\t\t\tputchar('X');\n\t\t} else if (e.se == -2) {\n\t\t\tputchar('Y');\n\t\t} else {\n\t\t\tprintf(\"%d\", e.se);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\tcout << S + 1 << \" \" << T + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint A, B;\n\tcin >> A >> B;\n\tint d[10][10];\n\tfor(int i=0; i<A; ++i)\n\t\tfor(int j=0; j<B; ++j)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\t\t\n\tint nx[10][10], ny[10][10];\n\tfor(int y=A; y--;)\n\t\tfor(int x=B; x--;)\n\t\t{\n\t\t\tif(x == B-1)\n\t\t\t{\n\t\t\t\tnx[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnx[y][x] = max(nx[y][x+1], d[y][x+1] - d[y][x]);\n\t\t\t\tif(y < A-1)\n\t\t\t\t\tnx[y][x] = max(nx[y][x], nx[y+1][x]);\n\t\t\t\tif((0 < x && d[y][x] - d[y][x-1] < nx[y][x]) || 200/max(A,B) < nx[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y == A-1)\n\t\t\t{\n\t\t\t\tny[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tny[y][x] = max(ny[y+1][x], d[y+1][x] - d[y][x]);\n\t\t\t\tif(x < B-1)\n\t\t\t\t\tny[y][x] = max(ny[y][x], ny[y][x+1]);\n\t\t\t\tif((0 < y && d[y][x] - d[y-1][x] < ny[y][x]) || 200/max(A,B) < ny[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t*(int*)0=0;\n\tcout << \"Possible\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <climits>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <time.h>\n#include <utility>\n#include <vector>\n\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,a,b) for(int32 i = (a); i < (b); ++i)\n#define ALL(x) (x).begin(),(x).end()\n#define scanf scanf_s\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\n\n\nint main(void) {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tuint32 a, b;\n\tstd::cin >> a >> b;\n\tbool f = 1;\n\tstd::vector<std::vector<int32>> d(a, std::vector<int32>(b)), x(a, std::vector<int32>(b)), y(a, std::vector<int32>(b)), n(a, std::vector<int32>(b));\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tstd::cin >> d[i][j];\n\t\t}\n\t}\n\trep(i, 0, a) {\n\t\trep(j, 0, b-1) {\n\t\t\ty[i][j] = d[i][j + 1] - d[i][j];\n\t\t\tif (y[i][j] < 0) f = 0;\n\t\t\tif (j != 0) {\n\t\t\t\tif (y[i][j] - y[i][j - 1] > 0) f = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, a-1) {\n\t\trep(j, 0, b) {\n\t\t\tx[i][j] = d[i + 1][j] - d[i][j];\n\t\t\tif (x[i][j] < 0) f = 0;\n\t\t\tif (i != 0) {\n\t\t\t\tif (x[i][j] - x[i-1][j] > 0) f = 0;\n\t\t\t}\n\t\t}\n\t}\n\tstd::queue < std::pair<std::pair<uint32, uint32>, int32>> Q;\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tn[i][j] = d[i][j] - (i + 1)*x[i][j] - (j + 1)*y[i][j];\n\t\t\tif (n[i][j] < 0) f = 0;\n\t\t\tif (n[i][j] > 100) f = 0;\n\t\t}\n\t}\n\tif (!f) {\n\t\tstd::cout << \"Impossible\"; return 0;\n\t}\n\trep(i, 0, 101) {\n\t\tQ.push({ {i,i + 1},-2 });\n\t}\n\trep(i, 0, 101) {\n\t\tQ.push({ {i + 102,i + 101},-1 });\n\t}\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tQ.push({ {y[i][j],x[i][j] + 101},n[i][j] });\n\t\t}\n\t}\n\tstd::cout << 202 << \" \" << Q.size() << \"\\n\";\n\twhile (!Q.empty()) {\n\t\t\tstd::cout << Q.front().first.first << \" \" << Q.front().first.second << \" \";\n\t\t\tif (Q.front().second >= 0) {\n\t\t\t\tstd::cout<<Q.front().second << \"\\n\";\n\t\t\t}\n\t\t\telse if (Q.front().second == -1) {\n\t\t\t\tstd::cout << \"X\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"Y\\n\";\n\t\t\t}\n\t\tQ.pop();\n\t}\n\tstd::cout << \"0 101\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A, B, N, M, S, T, d[15][15];\nll adj[102][102];\nll dist[204];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i){\n\t\tfor (int j = 1; j <= B; ++j){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tS = 1;\n\tT = 202;\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tint maxi = 0;\n\t\t\tfor (int k = 1; k <= A; ++k){\n\t\t\t\tfor (int l = 1; l <= B; ++l){\n\t\t\t\t\tmaxi = max(maxi,d[k][l]-k*i-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj[i][j] = maxi;\n\t\t\tif (maxi > 100){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 1; k <= A; ++k){\n\t\tfor (int l = 1; l <= B; ++l){\n\t\t\tdist[1] = 0;\n\t\t\tfor (int i = 1; i <= 100; ++i){\n\t\t\t\tdist[i+1] = dist[i] + k;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 100; ++i){\n\t\t\t\tint mini = 1e9;\n\t\t\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\t\t\tmini = min(mini,adj[j][100-i]+dist[j+1]);\n\t\t\t\t}\n\t\t\t\tif (i > 0){\n\t\t\t\t\tmini = min(mini,dist[102+i-1]+l);\n\t\t\t\t}\n\t\t\t\tdist[102+i] = mini;\n\t\t\t}\n\t\t\tif (dist[202] != d[k][l]){\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tN = 202;\n\tM = 100+100+(101*101);\n\tfor (int i = 1; i <= 100; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'X' << '\\n';\n\t}\n\tfor (int i = 102; i <= 201; ++i){\n\t\tcout << i << ' ' << i+1 << ' ' << 'Y' << '\\n';\n\t}\n\tfor (int i = 0; i <= 100; ++i){\n\t\tfor (int j = 0; j <= 100; ++j){\n\t\t\tcout << i+1 << ' ' << j+102 << ' ' << adj[i][100-j] << '\\n';\n\t\t}\n\t}\n\tcout << S << ' ' << T << '\\n';\n\tcout << flush;\n\t//for (int i = 1; i < 1e9; ++i){for (int j = 0; j < 1e9; ++j){}}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,inf);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tconst int v=150;\n\t\n\tint a,b;cin>>a>>b;\n\t\n\tvvc<int> lw(v,vi(v,0));\n\tvvc<int> buf(a+1,vi(b+1,0));\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint d;cin>>d;\n\t\tbuf[x][y]=d;\n\t\trep(i,v)rep(j,v){\n\t\t\tchmax(lw[i][j],d-i*x-(v-1-j)*y);\n\t\t}\n\t}\n\t\n\trng(x,1,a+1)rng(y,1,b+1){\n\t\tint n=v*2;\n\t\tstruct E{int to,cost;};\n\t\tvvc<E> g(n);\n\t\trep(i,v-1)\n\t\t\tg[i].pb(E{i+1,x});\n\t\trep(i,v-1)\n\t\t\tg[v+i].pb(E{v+i+1,y});\n\t\trep(i,v)rep(j,v)\n\t\t\tg[i].pb(E{v+j,lw[i][j]});\n\t\tint d=dijkstra(g,0)[n-1];\n\t\tif(d!=buf[x][y]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\t\n\tint n=v*2;\n\tprint(n,2);\n\tprint((v-1)*2+v*v);\n\trep(i,v-1){\n\t\tcout<<i+1<<\" \"<<i+1+1<<\" X\\n\";\n\t}\n\trep(i,v-1){\n\t\tcout<<v+i+1<<\" \"<<v+i+1+1<<\" Y\\n\";\n\t}\n\trep(i,v)rep(j,v)\n\t\tcout<<i+1<<\" \"<<v+j+1<<\" \"<<lw[i][j]<<\"\\n\";\n\tcout<<1<<\" \"<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, d[102][102], a, b, ok[102][102];\nstruct skrr {\n  int i, j, c;\n} v[20002];\n\nint main()\n{\n  cin >> a >> b;\n  for (int i = 1; i <= a; i++)\n    for (int j = 1; j <= b; j++)\n      cin >> d[i][j];\n  for (int i = 0; i <= 100; i++)\n    for (int j = 0; j <= 100; j++) {\n      int mx = 0;\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          mx = max (mx, d[x][y] - i * x - j * y);\n      v[++m] = {i + 1, 202 - j, mx};\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          if (mx + i * x + j * y == d[x][y])\n            ok[x][y] = 1;\n    }\n  for (int x = 1; x <= a; x++)\n    for (int y = 1; y <= b; y++)\n    if (!ok[x][y]) {\n      cout << \"Impossible\";\n      return 0;\n    }\n  cout << \"202 \" << m + 200;\n  for (int i = 1; i <= 100; i++)\n    cout << i << \" \" << i + 1 << \" X\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i + 101 << \" \" << i + 102 << \" Y\\n\";\n  for (int i = 1; i <= m; i++)\n    cout << v[i].i << \" \" << v[i].j << \" \" << v[i].c << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\n\nint dis[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int A,B;cin>>A>>B;\n    int N=16*16+1;\n    int M=15*17+16*16;\n    \n    vector<pair<int,int>> ans;\n    \n    for(int i=0;i<256;i+=16){\n        for(int j=0;j<15;j++){\n            ans.push_back(mp(i+j,i+j+1));\n        }\n    }\n    \n    for(int i=0;i+16<256;i+=16) ans.push_back(mp(i,i+16));\n    \n    for(int i=0;i<256;i++) ans.push_back(mp(i,256));\n    \n    vector<vector<int>> S(A+1,vector<int>(B+1));\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            cin>>S[i][j];\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    int sum=a*i+b*j;\n                    chmax(dis[16*b+a][256],S[i][j]-sum);\n                }\n            }\n        }\n    }\n    \n    bool ok=true;\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            int mini=INF;\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    chmin(mini,a*i+b*j+dis[16*b+a][256]);\n                }\n            }\n            \n            if(mini!=S[i][j]) ok=false;\n        }\n    }\n    \n    if(ok){\n        cout<<\"Possible\\n\";\n        cout<<N<<\" \"<<M<<endl;\n        for(int i=0;i<M;i++){\n            cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<\" \";\n            if(ans[i].se==256) cout<<dis[ans[i].fi][256]<<\"\\n\";\n            else if(ans[i].se-ans[i].fi==1) cout<<\"X\\n\";\n            else if(ans[i].se-ans[i].fi==16) cout<<\"Y\\n\";\n        }\n        cout<<1<<\" \"<<257<<endl;\n    }else if(A==1){\n        ok=true;\n        for(int j=2;j<=B;j++){\n            if(S[1][1]*j!=S[1][j]) ok=false;\n        }\n        if(ok){\n            cout<<\"Possible\\n\";\n            cout<<S[1][1]+1<<\" \"<<S[1][1]<<endl;\n            for(int i=1;i<=S[1][1];i++){\n                cout<<i<<\" \"<<i+1<<\" \"<<\"Y\\n\";\n            }\n            cout<<1<<\" \"<<S[1][1]+1<<\"\\n\";\n        }else{\n            cout<<\"Impossible\\n\";\n        }\n    }else if(B==1){\n        ok=true;\n        for(int j=2;j<=B;j++){\n            if(S[1][1]*j!=S[j][1]) ok=false;\n        }\n        if(ok){\n            cout<<\"Possible\\n\";\n            cout<<S[1][1]+1<<\" \"<<S[1][1]<<endl;\n            for(int i=1;i<=S[1][1];i++){\n                cout<<i<<\" \"<<i+1<<\" \"<<\"X\\n\";\n            }\n            cout<<1<<\" \"<<S[1][1]+1<<\"\\n\";\n        }else{\n            cout<<\"Impossible\\n\";\n        }\n    }else{\n        cout<<\"Impossible\\n\";\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> II;\n#define fi first\n#define se second\n\nconst int N = 550;\n\nint A, B;\nint n, S, T;\nint nx[N][N], ny[N][N];\nint a[N][N];\n\nbool check(int x, int y, int ni, int nj) {\n\tint rem = a[x][y] - ni * x - nj * y;\n\tif (rem < 0) return false;\n\n\tfor (int i = 1; i <= A; ++i) for (int j = 1; j <= B; ++j) {\n\t\tif (rem + ni * i + nj * j < a[i][j]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) cin >> a[i][j], nx[i][j] = -1, ny[i][j] = -1;\n\t}\t\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tfor (int ni = 0; ni <= 100; ++ni) for (int nj = 0; nj <= 100; ++nj) {\n\t\t\t\tif (check(i, j, ni, nj)) {\n\t\t\t\t\tnx[i][j] = ni, ny[i][j] = nj; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tS = ++n;\n\tT = ++n;\n\tvector<II> X, edges;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (nx[i][j] == -1 || ny[i][j] == -1) return cout << \"Impossible\\n\", 0;\n\t\t\t\n\t\t\tint rem = a[i][j] - nx[i][j] * i - ny[i][j] * j;\n\n\t\t\tint last = S;\n\t\t\tfor (int k = 0; k < min(nx[i][j], (int)X.size()); ++k) {\n\t\t\t\tedges.push_back(X[k]);\n\t\t\t\tlast = X[k].se.se;\n\t\t\t}\n\t\t\tnx[i][j] -= X.size();\n\t\t\twhile (nx[i][j]-- > 0) {\n\t\t\t\t++n; X.push_back(II(-1, ii(last, n))); last = n;\n\t\t\t\tedges.push_back(X.back());\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < ny[i][j]; ++k) {\n\t\t\t\t++n; edges.push_back(II(-2, ii(last, n))); last = n;\n\t\t\t}\n\n\t\t\tedges.push_back(II(rem, ii(last, T)));\n\t\t}\n\t}\n\n\tsort(edges.begin(), edges.end());\n\tedges.erase(unique(edges.begin(), edges.end()), edges.end());\n\tcout << n << ' ' << edges.size() << endl;\n\tcout << \"Possible\\n\";\n\tfor (auto e : edges) {\n\t\tcout << e.se.fi << ' ' << e.se.se << ' ';\n\t\tif (e.fi < 0) cout << (e.fi == -1 ? 'X' : 'Y') << endl;\n\t\telse cout << e.fi << endl;\n\t}\n\tcout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    ll V = 0;\n    vector<ll> id(101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=100;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++) if(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+1<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=2*M;i++) cout<<i<<' '<<i+1<<' '<<(i<=M?'X':'Y')<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+1-j<<' '<<b[i][j]<<endl;\n\t}\n\telse cout<<\"Impossble\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nint o[191][111];\nint l[110][199];\nint j[111];\n\nlong long x,y,z,mod=1000000007;\n//string r,r1;\nchar r[1];\n\nP u[10];\nqueue<P> q;\n//stack<int> s;\nmap<int,int> p;\nvector<int> v;\n\nbool as(P a,P b)\n{\n  return a.x>b.x;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&a,&b);\n  for(int t=1;t<=a;t++)\n    for(int w=1;w<=b;w++)\n    {\n      scanf(\"%d\",&l[t][w]);\n      for(int i=0;i*t<=l[t][w];i++)\n      for(int j=0;i*t+j*w<=l[t][w];j++)\n      o[i][j]=max(o[i][j],l[t][w]-i*t-j*w);\n    }\n  for(int t=1;t<=a;t++)\n  for(int w=1;w<=b;w++)\n  {\n    int p=mod;\n    for(int i=0;i*t<=l[t][w];i++)\n    for(int j=0;i*t+j*w<=l[t][w];j++)\n    p=min(p,i*t+j*w+o[i][j]);\n    if(p!=l[t][w])\n    {\n      puts(\"Impossible\");\n      return 0;\n    }\n  }\n  puts(\"Possible\");\n  for(int t=1;t<=a;t++)\n    printf(\"%d %d X\\n\",t,t+1);\n  for(int t=a+2;t<a+b+2;t++)\n    printf(\"%d %d Y\\n\",t,t+1);\n  for(int i=1,t=0;i<=a+1;t++,i++)\n  for(int j=a+b+2,w=0;j>=a+2;j--,w++)\n    printf(\"%d %d %d\\n\",i,j,o[t][w]);\n  printf(\"1 %d\",a+b+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nint mx[305][305], dis[305][305]; \nint main()\n{\n\tfreopen(\"ARC089-E.in\", \"r\", stdin); \n\tint a, b, n = 300; \n\tscanf(\"%d%d\", &a, &b); \n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\tscanf(\"%d\", dis[i] + j); \n\t}\n\tfor (int x = 0; x <= 100; x++)\n\t{\n\t\tfor (int y = 0; y <= 100; y++)\n\t\t{\n\t\t\tfor (int i = 1; i <= a; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= b; j++)\n\t\t\t\t\tmx[x][y] = std::max(mx[x][y], dis[i][j] - (i * x + j * y)); \n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tbool f = false; \n\t\t\tfor (int x = 0; x <= 100 && !f; x++)\n\t\t\t{\n\t\t\t\tfor (int y = 0; y <= 100 && !f; y++)\n\t\t\t\t\tf |= mx[x][y] + i * x + j * y == dis[i][j]; \n\t\t\t}\n\t\t\tif (!f)\n\t\t\t{\n\t\t\t\tputs(\"Impossible\"); \n\t\t\t\treturn 0; \n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n, 101 * 101 + 100 * 2);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d Y\\n\", n - i, n - i + 1);\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, n - j, mx[i][j]);\n\t}\n\tprintf(\"%d %d\\n\", 1, n);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      vector<Int> dp1(100,INF),dp2(100,INF);\n      for(Int k=100-1;k>=0;k--){\n\tdp1[k]=C[k];\n\tdp2[k]=D[k];\n\tif(k+1<100){\n\t  chmin(dp1[k],dp1[k+1]);\n\t  chmin(dp2[k],dp2[k+1]);\n\t}\n      }\n      for(Int k=0;k<100;k++){\n\tfor(Int l=0;l<100;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*(k+1)+dp2[l]));\n\t  chmax(F[k][l],d[i][j]-((j+1)*(k+1)+dp1[l]));\n\t}\n      }\n    }\n  }\n  \n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  for(Int k=0;k<100;k++){\n    for(Int l=0;l<100;l++){\n      //if(E[k][l]) cout<<k<<\" \"<<l<<\":E:\"<<E[k][l]<<endl;\n      //if(F[k][l]) cout<<k<<\" \"<<l<<\":F:\"<<F[k][l]<<endl;\n      \n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint A, B;\nint D[15][15];\nint f[105][105];\n\nint main(){\n\n  cin >> A >> B;\n  rep(i,A){\n    rep(j,B){\n      cin >> D[i][j];\n    }\n  }\n\n  rep(a,101){\n    rep(b,101){\n      rep(x,A){\n        rep(y,B){\n          f[a][b] = max(f[a][b], D[x][y] - (x+1)*a - (y+1)*b);\n        }\n      }\n    }\n  }\n\n  rep(x,A){\n    rep(y,B){\n      int mn = 1000000000;\n      rep(a,101){\n        rep(b,101){\n          mn = min(mn, (x+1)*a + f[a][b] + (y+1)*b);\n        }\n      }\n      if(D[x][y] != mn){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  \n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i,100){\n    cout << i+1 << \" \" << i+2 << \" X\" << endl;\n  }\n  rep(i,100){\n    cout << 102+i << \" \" << 102+i+1 << \" Y\" << endl;\n  }\n  rep(i,101){\n    rep(j,101){\n      cout << i+1 << \" \" << 202-j << \" \" << f[i][j] << endl;\n    }\n  }\n  \n  cout << 1 << \" \" << 202 << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,s,t;\nint a,b,d[15][15];\n\ninline void init(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tscanf(\"%d\",d[i]+j);\n}\n\nint fl;\nstruct edge{\n\tint u,v,w;\n}ge[100005];\n\ninline int check(int x,int y,int c){\n\tfor(int i=1;i<=a;++i)\n\t\tfor(int j=1;j<=b;++j)\n\t\t\tif(i*x+j*y+c<d[i][j])return 0;\n\treturn 1;\n}\n\ninline void solve(){\n\ts=1;t=n=202;\n\tfor(int i=1;i<=100;++i)\n\t\tge[m++]=(edge){i,i+1,-1};\n\tfor(int i=102;i<n;++i)\n\t\tge[m++]=(edge){i,i+1,101};\n\t\n\tfor(int i=1;i<=a;++i){\n\t\tfor(int j=1;j<=b;++j){\n\t\t\tint ok=0;\n\t\t\tfor(int x=0;x<=d[i][j]/i;++x){\n\t\t\t\tfor(int y=0;y<=(d[i][j]-x*i)/j;++y){\n\t\t\t\t\tint c=d[i][j]-x*i-y*j;\n\t\t\t\t\tif(check(x,y,c)){\n\t\t\t\t\t\tge[m++]=(edge){x+1,n-y,c};\n\t\t\t\t\t\tok=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)break;\n\t\t\t}\n\t\t\tif(!ok){fl=1;break;}\n\t\t}\n\t\tif(fl)break;\n\t}\n\t\n\tif(fl){puts(\"Impossible\");return;}\n\tprintf(\"Possible\\n%d %d\\n\",n,m);\n\tfor(int i=0;i<m;++i){\n\t\tprintf(\"%d %d \",ge[i].u,ge[i].v);\n\t\tif(ge[i].w<0)puts(\"X\");\n\t\telse if(ge[i].w>100)puts(\"Y\");\n\t\telse printf(\"%d\\n\",ge[i].w);\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nll Xnum;\nll Ynum;\n\nll f(ll x, ll y) {\n\treturn (y - 1)*(Xnum + 1)+x;\n}\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\tvector<vector<ll>> d(B + 1, vector<ll>(A + 1, 0));\n\tfor (int i = 1;i <= A;i++)\n\t\tfor (int j = 1;j <= B;j++)\n\t\t\tcin >> d[j][i]; // d[y][x]\n\tXnum = 0;\n\tYnum = 0;\n\tfor (int x = 1;x <= A;x++)\n\t\tfor (int y = 1;y <= B;y++) {\n\t\t\tif (x < A)\n\t\t\t\tXnum = max(Xnum, abs(d[y][x] - d[y][x+1]));\n\t\t\tif(y < A)\n\t\t\t\tYnum = max(Ynum, abs(d[y][x] - d[y+1][x]));\n\t\t}\n\tbool ok = true;\n\tfor (int x = 1;x <= A;x++) {\n\t\tll diff = 0;\n\t\tfor (int y = B - 1;y >= 1;y--) {\n\t\t\tll nowdiff = d[y + 1][x] - d[y][x];\n\t\t\tif (nowdiff < diff)\n\t\t\t\tok = false;\n\t\t\tdiff = nowdiff;\n\t\t}\n\t}\n\tfor (int y= 1;y <= B;y++) {\n\t\tll diff = 0;\n\t\tfor (int x = A - 1;x >= 1;x--) {\n\t\t\tll nowdiff = d[y][x+1] - d[y][x];\n\t\t\tif (nowdiff < diff)\n\t\t\t\tok = false;\n\t\t\tdiff = nowdiff;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\tvector<T> ans;\n\tfor (int y = 1;y <= B;y++)\n\t\tfor (int x = 1;x <= A;x++) {\n\t\t\tif (x < A)\n\t\t\t\tans.push_back(T(f(x, y), f(x+1, y), -1)); // X = -1\n\t\t\tif (y < B)\n\t\t\t\tans.push_back(T(f(x, y), f(x, y+1), -2)); // Y = -2\n\t\t}\n\tll goal = f(A, B) + 1;\n\tvector<vector<ll>> visited(B+1, vector<ll>(A+1));\n\tfor (int y = B;y >= 1;y--)\n\t\tfor (int x = A;x >= 1;x--) {\n\t\t\tll xd = 0; ll yd = 0;\n\t\t\tif (x < A)\n\t\t\t\txd = d[y][x + 1] - d[y][x];\n\t\t\tif (y < B)\n\t\t\t\tyd = d[y + 1][x] - d[y][x];\n\t\t\tif (!visited[yd][xd]) {\n\t\t\t\tans.push_back(T(f(xd + 1, yd + 1), goal, d[y][x] - x * xd - y * yd));\n\t\t\t\tif (d[y][x] - x * xd - y * yd < 0 || 100 < d[y][x] - x * xd - y * yd)\n\t\t\t\t\tok = false;\n\t\t\t\tvisited[yd][xd] = true;\n\t\t\t}\n\t\t}\n\tif(!ok)\n\t\tcout << \"Impossible\" << endl;\n\telse {\n\t\tcout << goal << \" \" << ans.size() << endl;\n\t\tfor (int i = 0;i < ans.size();i++) {\n\t\t\tll x, y, z;\n\t\t\ttie(x, y, z) = ans[i];\n\t\t\tcout << x << \" \" << y << \" \";\n\t\t\tif (z == -2)\n\t\t\t\tcout << \"Y\" << endl;\n\t\t\telse if (z == -1)\n\t\t\t\tcout << \"X\" << endl;\n\t\t\telse\n\t\t\t\tcout << z << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n\n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      flg&=(dist==d[i][j]);\n      assert(dist>=d[i][j]);\n      \n      //cout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n      //return 0;\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define chmax(x,y) x = max(x,y)\n#define chmin(x,y) x = min(x,y)\n\nint A,B;\nint d[11][11];\nconst int C = 101;\nint S = 1 , T = 2 * C;\nint N = T , M = 2 * (C-1) + C * C;\nint e[C][C];\n \nint main(){\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\trep(i,C) rep(j,C){\n\t\tfor (int x = 1; x <= A; ++x) {\n\t\t\tfor (int y = 1; y <= B; ++y) {\n\t\t\t\te[i][j] = max(e[i][j] , d[x][y]-i*x-j*y);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = 1; x <= A; ++x) {\n\t\tfor (int y = 1; y <= B; ++y) {\n\t\t\tint z = C;\n\t\t\trep(i,C) rep(j,C) z = min(z,e[i][j]+i*x+j*y);\n\t\t\tif(z != d[x][y]) return cout << \"Impossible\" << endl , 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << N << ' ' << M << endl;\n\tfor (int i = 1; i < C; ++i) {\n\t\tcout << i << ' ' << i+1 << \" X\" << endl;\n\t\tcout << C+i << ' ' << C+i+1 << \" Y\" << endl;\n\t}\n\trep(i,C) rep(j,C) cout << i+1 << ' ' << N-j << ' ' << e[i][j] << endl;\n\tcout << S << ' ' << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 505\n#define MAXN 149\n#define INF 1000000000\nusing namespace std;\nint n,m,f[M][M],g[M][M],S,T;\nint read(){\n\tchar c=getchar();int ans=0;\n    while (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans;\n}\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n\tn=read(),m=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++) f[i][j]=read();\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tfor (register int k=1;k<=n;k++)\n\t\t\t\tfor (register int l=1;l<=m;l++)\n\t\t\t\t\tg[i][j]=max(g[i][j],f[k][l]-k*i-l*j);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++){\n\t\t\tint now=INF;\n\t\t\tfor (register int k=0;k<=MAXN;k++)\n\t\t\t\tfor (register int l=0;l<=MAXN;l++)\n\t\t\t\t\tnow=min(now,k*i+l*j+g[k][l]);\n\t\t\tif (now!=f[i][j]){printf(\"Impossible\");return 0;}\n\t\t}\n\tprintf(\"Possible\\n%d %d\\n\",MAXN+MAXN+1,(MAXN+1)*(MAXN+1)+2*MAXN);\n\tS=1,T=MAXN+MAXN+1;\n\tfor (register int i=1;i<=MAXN;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (register int i=MAXN+1;i<=MAXN+MAXN;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,MAXN+MAXN-j,g[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define ll long long\n#define X first\n#define Y second\n#define pb push_back\n#define E Maxke_pair\n#define pii pair<int, int>\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define sz(x) (int)(x).sze()\n#define ALL(x) (x).insgin(), (x).end()\n#define vi vector<int>\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int mod = 1e9 + 7;\nconst int INF = 1e9 + 7;\nconst int N = 110;\nconst int M = 2e6 + 10; \nint m,n,a[N][N],b[N][N]; \nbool vis[N][N];\nint main()\n{\n\tm = read();\n\tn = read();\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\ta[i][j] = read();\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\trep(x, 0, 100)\n\t\t\t\trep(y, 0, 100)\n\t\t\t\t\tb[x][y] = max(b[x][y], a[i][j] - i * x - j * y);\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\trep(x, 0, 100)\n\t\t\t\trep(y, 0, 100)\n\t\t\t\t\tif (b[x][y] == a[i][j] - i * x - j * y) vis[i][j] = 1;\n\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\tif(!vis[i][j]) \n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\", 200 + 101 * 101);\n\trep(i, 1, 100) printf(\"%d %d X\\n\", i, i + 1);\n\trep(i, 102, 201) printf(\"%d %d Y\\n\",i + 1, i);\n\trep(i, 0, 100)\n\t\trep(j, 0, 100) \n\t\t\tprintf(\"%d %d %d\\n\", i + 1, j + 102, b[i][j]);\n\tputs(\"1 102\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 105;\nconst int INF = 1e9;\n\nint A,B;\nint d[11][11];\nint f[N][N];\nint m,ed[N*4][3];\nbool bz[11][11];\nbool v[N][N];\nint n;\nint id0[N],id1[N],S,T;\n\nint main(){\n\tA=get();B=get();\n\tfo(i,1,A)fo(j,1,B)d[i][j]=get();\n\tfo(i,0,100)\n\t\tfo(j,0,100){\n\t\t\tf[i][j]=-INF;\n\t\t\tfo(x,1,A)\n\t\t\t\tfo(y,1,B)\n\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-x*i-y*j);\n\t\t}\n\tint cnt=0;\n\tS=n=1;\n\tfo(i,0,100)id0[i]=++n;\n\tfo(i,0,100)id1[i]=++n;\n\tT=++n;\n\ted[m=1][0]=S;ed[1][1]=id0[0];ed[1][2]=0;\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id0[i];ed[m][1]=id0[i+1];ed[m][2]=-1;\n\t}\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id1[i+1];ed[m][1]=id1[i];ed[m][2]=-2;\n\t}\n\tm++;\n\ted[m][0]=id1[0];ed[m][1]=T;ed[m][2]=0;\n\twhile(cnt<A*B){\n\t\tbool pd=0;\n\t\tfo(i,0,100){\n\t\t\tfo(j,0,100)\n\t\t\tif (!v[i][j]&&f[i][j]<=100&&f[i][j]>=0){\n\t\t\t\tint ct=0;\n\t\t\t\tfo(x,1,A)\n\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\tif (!bz[x][y]&&d[x][y]-x*i-y*j==f[i][j])ct++;\n\t\t\t\tif (ct){\n\t\t\t\t\tpd=1;\n\t\t\t\t\tfo(x,1,A)\n\t\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\t\tif (d[x][y]-x*i-y*j==f[i][j])bz[x][y]=1;\n\t\t\t\t\ted[++m][0]=id0[i];ed[m][1]=id1[j];ed[m][2]=f[i][j];\n\t\t\t\t\tcnt=cnt+ct;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse v[i][j]=1;\n\t\t\t}\n\t\t\tif (pd)break;\n\t\t}\n\t\tif (!pd)break;\n\t}\n\tif (cnt!=A*B)printf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\",n,m);\n\t\tfo(i,1,m){\n\t\t\tprintf(\"%d %d \",ed[i][0],ed[i][1]);\n\t\t\tif (ed[i][2]==-1)printf(\"X\\n\");\n\t\t\tif (ed[i][2]==-2)printf(\"Y\\n\");\n\t\t\tif (ed[i][2]>=0)printf(\"%d\\n\",ed[i][2]);\n\t\t}\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=310,M=100010;\nbool w[N][N];\nint s1[N],s2[N];\nstruct Dat {\n    int x,y,z;\n} g[N],v[M];\ninline int gi() {\n    int x=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint main() {\n    int A,B,cnt=0,n=0,m=0;\n    cin>>A>>B;\n    for(int i=0;i<=100;i++) {\n\ts1[i]=++n,s2[i]=++n;\n\tif(i) {\n\t    v[++m]=(Dat){s1[i-1],s1[i],-1};\n\t    v[++m]=(Dat){s2[i],s2[i-1],-2};\n\t}\n    }\n    for(int i=1;i<=A;i++)\n\tfor(int j=1;j<=B;j++) g[++cnt]=(Dat){i,j,gi()};\n    for(int i=1;i<=cnt;i++) {\n\tint x=g[i].x,y=g[i].y,z=g[i].z;\n\tfor(int p=0;p*x<=z;p++)\n\t    for(int q=0;p*x+q*y<=z;q++) {\n\t\tint c=z-p*x-q*y;\n\t\tbool flg=1;\n\t\tfor(int j=1;j<=cnt;j++) {\n\t\t    int X=g[j].x,Y=g[j].y;\n\t\t    if(p*X+q*Y+c<g[j].z) {flg=0;break;}\n\t\t}\n\t\tif(flg) {\n\t\t    if(!w[s1[p]][s2[q]])\n\t\t\tw[s1[p]][s2[q]]=1,v[++m]=(Dat){s1[p],s2[q],c};\n\t\t    goto ed;\n\t\t}\n\t    }\n\treturn puts(\"Impossible\"),0;\n    ed:;\n    }\n    puts(\"Possible\");\n    cout<<n<<' '<<m<<endl;\n    for(int i=1;i<=m;i++) {\n\tprintf(\"%d %d \",v[i].x,v[i].y);\n\tif(v[i].z==-1) puts(\"X\");\n\telse if(v[i].z==-2) puts(\"Y\");\n\telse printf(\"%d\\n\",v[i].z);\n    }\n    cout<<1<<' '<<2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool solve(int A, int B) {\n  int dist[10][10];\n  for (int i = 0; i < A; i++) {\n    for (int j = 0; j < B; j++) {\n      cin >> dist[i][j];\n    }\n  }\n\n  int T = 101;\n  vector<vector<int>> data(T, vector<int>(T, -1));\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int basecost = 0;\n          basecost += (i + 1) * x;\n          basecost += (j + 1) * y;\n          int amari = dist[i][j] - basecost;\n          data[x][y] = max(data[x][y], amari);\n        }\n    }\n  }\n\n  int cnt = 0;\n  vector<vector<int>> ans(A, vector<int>(B, 200));\n  for (int x = 0; x < T; x++)\n    for (int y = 0; y < T; y++) {\n      // cout << x << \" \" << y << \" \" << data[x][y] << endl;\n      if (data[x][y] < 0) continue;\n      cnt++;\n      for (int i = 0; i < A; i++)\n        for (int j = 0; j < B; j++) {\n          int cost = (i + 1) * x + (j + 1) * y + data[x][y];\n          ans[i][j] = min(ans[i][j], cost);\n        }\n    }\n  for (int i = 0; i < A; i++)\n    for (int j = 0; j < B; j++)\n      if (ans[i][j] != dist[i][j]) return false;\n\n  cout << \"Possible\" << endl;\n  cout << 2 * T + 1 << \" \" << 2 * T + cnt << endl;\n  for (int i = 0; i < T; i++) {\n    cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n  }\n  for (int i = 0; i < T; i++) {\n    cout << i + T + 1 << \" \" << i + T + 2 << \" Y\" << endl;\n  }\n  int s = 1;\n  int t = T + T + 1;\n\n  for (int x = 0; x < T; x++) {\n    for (int y = 0; y < T; y++) {\n      if (data[x][y] < 0) continue;\n      cout << s + x << \" \" << t - y << \" \" << data[x][y] << endl;\n    }\n  }\n  cout << s << \" \" << t << endl;\n  return true;\n}\nint main() {\n  int A, B;\n  cin >> A >> B;\n  bool ok = solve(A, B);\n  if (!ok) {\n    cout << \"Impossible\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<time.h>\n#include<math.h>\n#include<memory>\n#include<vector>\n#include<bitset>\n#include<fstream>\n#include<stdio.h>\n#include<utility>\n#include<sstream>\n#include<string.h>\n#include<iostream>\n#include<stdlib.h>\n#include<algorithm>\nusing namespace std;\nint d[15][15];\nint weight[15][105];\nint xy[105][105];\nvoid wa()\n{\n    puts(\"Impossible\");\n}\nint check_ans[15];\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    int i,j;\n    for (i=1;i<=a;i++)\n    {\n        for (j=1;j<=b;j++)\n        {\n            scanf(\"%d\",&d[i][j]);\n        }\n    }\n    int x,y;\n    int sum=10401;\n    for (x=0;x<=100;x++)\n    {\n        for (y=0;y<=100;y++)\n        {\n            xy[x][y]=-1;\n            for (i=1;i<=a;i++)\n            {\n                for (j=1;j<=b;j++)\n                {\n                    xy[x][y]=max(xy[x][y],d[i][j]-i*x-j*y);\n                }\n            }\n            if (xy[x][y]<0) sum--;\n        }\n    }\n    for (i=1;i<=a;i++)\n    {\n        for (j=1;j<=b;j++)\n        {\n            int ans=105;\n            for (x=0;x<=100;x++)\n            {\n                for (y=0;y<=100;y++)\n                {\n                    if (xy[x][y]<0) continue;\n                    ans=min(ans,xy[x][y]+i*x+j*y);\n                }\n            }\n            if (ans!=d[i][j])\n            {\n                wa();\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"202 %d\\n\",sum);\n    for (i=1;i<=100;i++)\n    {\n        printf(\"%d %d X\\n\",i,i+1);\n    }\n    for (i=102;i<=201;i++)\n    {\n        printf(\"%d %d Y\\n\",i,i+1);\n    }\n    for (i=0;i<=100;i++)\n    {\n        for (j=0;j<=100;j++)\n        {\n            if (xy[i][j]<0) continue;\n            printf(\"%d %d %d\\n\",i+1,202-j,xy[i][j]);\n        }\n    }\n    printf(\"1 202\\n\");\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nint low[123][123],req[12][12];\nint main(){\n    std::ios::sync_with_stdio(false);\n    int a,b;\n    cin>>a>>b;\n    int i,j;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tcin>>req[i][j];\n    \t}\n    }\n    rep(i,101){\n    \trep(j,101){\n    \t\tlow[i][j]=0;\n    \t}\n    }\n    int val,p,q;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q;\n    \t\t\t\tif(req[i][j]>val){\n    \t\t\t\t\tlow[p][q]=max(low[p][q],req[i][j]-val);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int flag;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tflag=0;\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q+low[p][q];\n    \t\t\t\tif(val==req[i][j])\n    \t\t\t\t\tflag=1;\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t\tif(flag==0){\n    \t\t\tcout<<\"Impossible\"<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t}\n    }\n    int edg=0;\n    cout<<\"Possible\"<<endl;\n    cout<<202<<\" \"<<10401;\n    cout<<201<<\" \"<<1<<\" X\"<<endl;\n    edg++;\n    f(i,1,100){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" X\"<<endl;\n    }\n    edg++;\n    cout<<200<<\" \"<<202<<\" Y\"<<endl;\n    f(i,101,200){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n    }\n    f(i,1,101){\n    \tf(j,1,101){\n    \t\tedg++;\n    \t\tcout<<i<<\" \"<<200-j+1<<\" \"<<low[i][j]<<endl;\n    \t}\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<201<<\" \"<<200-i+1<<\" \"<<low[0][i]<<endl;\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<i<<\" \"<<202<<\" \"<<low[i][0]<<endl;\n    }\n    edg++;\n    cout<<201<<\" \"<<202<<\" \"<<low[0][0]<<endl;\n    cout<<edg<<endl;\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ll long long\nconst int INF = 1000 * 1000 * 1000;\nconst ll LINF = (ll)INF * INF;\nint A , B;\nint d[11][11];\nint f[101][101];\nint dist[202];\n\nint main()\n{\n\t//freopen(\"input.txt\" , \"r\" , stdin);\n\t//freopen(\"output.txt\" , \"w\" , stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i++)\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\tfor(int a = 0; a <= 100; a++)\n\t\tfor(int b = 0; b <= 100; b++)\n\t\t{\n\t\t\tfor(int x = 1; x <= A; x++)\n\t\t\t\tfor(int y = 1; y <= B; y++)\n\t\t\t\t{\n\t\t\t\t\tf[a][b] = max(f[a][b] , d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t}\n\tbool good = true;\n\tfor(int x = 1; x <= A; x++)\n\t\tfor(int y = 1; y <= B; y++)\n\t\t{\n\t\t\tfor(int i = 0; i < 202; i++)\n\t\t\t\tdist[i] = INF;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tdist[i] = x * i;\n\t\t\tfor(int i = 100; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif(i != 100)\n\t\t\t\t\tdist[i + 101] = dist[i + 1 + 101] + y;\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist[i + 101] = min(dist[i + 101] , f[j][i] + dist[j]);\n\t\t\t}\n\t\t\tif(dist[101] != d[x][y])\n\t\t\t\tgood = false;\n\t\t}\n\n\tif(good)\n\t{\n\t\tprintf(\"Possible\\n\");\n\t\tint n = 202;\n\t\tprintf(\"%d %d\\n\" , n ,  (n - 2) + n * n / 4);\n\t\tfor(int i = 1; i <= 100; i++)\n\t\t{\n\t\t\tprintf(\"%d %d X\\n\" , i - 1 + 1 , i + 1);\n\t\t\tprintf(\"%d %d Y\\n\" , i + 101 + 1 , i + 101 - 1 + 1);\n\t\t}\n\t\tfor(int i = 0; i <= 100; i++)\n\t\t{\n\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\" , i + 1 , j + 101 + 1 , f[i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"1 102\\n\");\n\t}\n\telse\n\t\tprintf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      f[i][j] = inf;\n      rep(x, a){\n        rep(y, b){\n          chmin(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n      if(f[i][j] < 0)f[i][j] = 0;\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][100-j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=101;\nint qa,qb,qr[11][11],mp[N+1][N+1];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nbool jdg(){\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tint res=1e9;\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapn(res,(k-1)*i+(N-l)*j+mp[k][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(res>=qr[i][j]);\n\t\t\tif(res>qr[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\tqa=nxi(),qb=nxi();\n\tfor(int i=1; i<=qa; ++i){\n\t\tfor(int j=1; j<=qb; ++j){\n\t\t\tconst int v=qr[i][j]=nxi();\n\t\t\tfor(int k=1; k<=N; ++k){\n\t\t\t\tfor(int l=1; l<=N; ++l){\n\t\t\t\t\tapx(mp[k][l],v-i*(k-1)-j*(N-l));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!jdg()){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N<<1,N*N+2*(N-1));\n\tfor(int i=1; i<N; ++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+N,i+N+1);\n\t}\n\tfor(int i=1; i<=N; ++i){\n\t\tfor(int j=1; j<=N; ++j){\n\t\t\tprintf(\"%d %d %d\\n\",i,j+N,mp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,N*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n//////////////////////////\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\n\tvvll d(A + 1, vll(B + 1));\n\trepn(i, A)repn(j, B) cin >> d[i][j];\n\n\tvll a, b, c;\n\n\tll k = 1;\n\trep(x, 101)rep(y, 101) {\n\t\tll k = -1;\n\n\t\trepn(i, A)repn(j, B) {\n\t\t\tk = max(d[i][j] - x * i - y * j, k);\n\t\t}\n\t\t\n\t\tif (k >= 0) { a.push_back(x); b.push_back(y); c.push_back(k);}\n\t}\n\n\tll M = a.size();\n\n\tbool tf = 1;\n\n\trepn(i, A)repn(j, B) {\n\t\tll dis = INF;\n\t\trep(l, M) {\n\t\t\tdis = min(dis, a[l] * i + b[l] * j + c[l]);\n\t\t}\n\t\tif (dis != d[i][j]) { tf = 0; }\n\t}\n\n\tif (tf == 0) { cout << \"Impossible\" << endl; return 0; }\n\n\tcout << \"Possible\" << endl;\n\n\tcout << 202 << \" \" << 200 + M << endl;\n\n\trepn(i, 100) {\n\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t}\n\trepn(i, 100) {\n\t\tcout << 101 + i << \" \" << 101 + i + 1 << \" \" << \"Y\" << endl;\n\t}\n\trep(i, M) {\n\t\tcout << a[i] + 1 << \" \" << 202 - b[i] << \" \" << c[i] << endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nbool exi[301][301];\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 2, cur = 3;\n  v.push_back({1,3,\"X\"});\n\tRep1(i, 4, 102) {\n\t\tv.push_back({ i - 1,i,\"X\" });\n\t}\n\tRep(i, 103, 202) {\n\t\tv.push_back({ i,i + 1,\"Y\" });\n\t}\n\tv.push_back({ 202,2,\"Y\" });\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\trep(k, 101) {\n\t\t\t\tint l = k;\n\t\t\t\tif (l*i > d[i][j]) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t\tint r = (d[i][j] - l*i) / j;\n\t\t\t\tint z = d[i][j] - l*i - r * j;\n\t\t\t\tbool f = true;\n\t\t\t\trep1(i_, a) {\n\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tint sta = 2 + l; if (l == 0)sta = 1;\n\t\t\t\t\tint goa = 203 - r; if (r == 0)goa = 2;\n\t\t\t\t\tif(!exi[sta][goa])v.push_back({ sta,goa,to_string(z) });\n\t\t\t\t\texi[sta][goa] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == 100)valid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << cur - 1 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 2\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\nstring YES[2] = {\"NO\", \"YES\"};\nstring Yes[2] = {\"No\", \"Yes\"};\nstring yes[2] = {\"no\", \"yes\"};\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define si(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class T, class S> inline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class S> inline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\n#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end())\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return move(res);\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        cin >> a >> b >> c;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return move(res);\n}\n\n#define i128 __int128_t\n#define ull unsigned long long int\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n    for(auto &e : v) cout << e << \" \";\n    cout << endl;\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    cout << \"(\" << p.fi << \", \" << p.se << \")\";\n    return os;\n}\ntemplate <class S, class T> string to_string(pair<S, T> p) { return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\"; }\ntemplate <class A> string to_string(A v) {\n    if(v.empty()) return \"{}\";\n    string ret = \"{\";\n    for(auto &x : v) ret += to_string(x) + \",\";\n    ret.back() = '}';\n    return ret;\n}\n\nvoid dump() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump(Head head, Tail... tail) {\n    cerr << to_string(head) << \" \";\n    dump(tail...);\n}\n#define endl '\\n'\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    dump(x)\n#else\n#define debug(x)\n#endif\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n// int rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n// ll rndll(ll n) { return uniform_int_distribution<ll>(0, n - 1)(rng); }\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nmain() {\n    INT(n, m);\n    VV(int, a, n, m);\n    int N = 101;\n    vv(int, d, N + 1, N + 1);\n    vv(bool, ok, n, m);\n    rep(x, N + 1) {\n        rep(y, N + 1) {\n            rep(i, n) rep(j, m) { chmax(d[x][y], a[i][j] - (i + 1) * x - (j + 1) * y); }\n            rep(i, n) rep(j, m) if(a[i][j] == d[x][y] + (i + 1) * x + (j + 1) * y) ok[i][j] = true;\n            // cout << d[x][y] << \" \";\n        }\n        // cout << endl;\n    }\n    rep(i, n) rep(j, m) {\n        if(!ok[i][j]) {\n            cout << \"Impossible\\n\";\n            exit(0);\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << N * 2 + 2 << \" \" << N * 2 + (N + 1) * (N + 1) << endl;\n    rep2(i, 1, N) cout << i << \" \" << i + 1 << \" \" << 'X' << endl;\n    rep2(i, N + 2, N * 2 + 1) cout << i << \" \" << i + 1 << \" \" << 'Y' << endl;\n    rep(i, N + 1) rep(j, N + 1) {\n        int t = 1 + i, s = N * 2 + 2 - j;\n        cout << t << \" \" << s << \" \" << d[i][j] << endl;\n    }\n    cout << 1 << \" \" << N * 2 + 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\n\nint main(){\n//\tfreopen(\"graphxy.in\",\"r\", stdin);\n//\tfreopen(\"graphxy.out\",\"w\", stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i+1 << \" \" << 200-j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tfor(int i=0; i<99; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i=100; i<199; i++) cout << i+1 << \" \" << i+2 << \" Y\\n\";\n\tcout << \"1 200\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=210;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint A,B,n,D[N][N],d[N][N],G[N][N];\nint main()\n{\n\tfile();\n\tread(A),read(B);\n\tn=100;\n\tFor(i,1,A)For(j,1,B)read(d[i][j]);\n\tFor(i,0,n)\n\t\tFor(j,0,n)\n\t\t\tFor(a,1,A)\n\t\t\t\tFor(b,1,B)\n\t\t\t\t{\n\t\t\t\t\t//printf(\"(%d %d %d %d) %d\\n\",i,j,a,b,d[a][b]-a*i-b*j);\n\t\t\t\t\tchkmax(D[i][j],d[a][b]-a*i-b*j);\n\t\t\t\t}\n\tFor(a,1,A)\n\t\tFor(b,1,B)\n\t\t{\n\t\t\tG[a][b]=inf;\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tchkmin(G[a][b],D[i][j]+a*i+b*j);\n\t\t\tif(G[a][b]!=d[a][b]){puts(\"Impossible\");exit(0);}\n\t\t}\n\tputs(\"Possible\");\n\tn=101;\n\tprintf(\"%d %d\\n\",2*n,n*n+2*n-2);\n\tFor(i,2,n)printf(\"%d %d %c\\n\",i-1,i,'X');\n\tFor(i,2,n)printf(\"%d %d %c\\n\",n+i,n+i-1,'Y');\n\tFor(i,1,n)For(j,1,n)printf(\"%d %d %d\\n\",i,j+n,D[i-1][j-1]);\n\tprintf(\"%d %d\\n\",1,n+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntypedef int Weight;\nstruct Edge {\n    int from, to;\n    Weight wei;\n    Edge(int from_, int to_, Weight wei_) :from(from_), to(to_), wei(wei_) {}\n};\ntypedef vector<Edge> Edges;\nconst Weight INFW = numeric_limits<Weight>::max();\nstruct Graph : public vector<Edges> {\n    Graph() { }\n    Graph(int V) : vector<Edges>(V) { }\n    /*\n    有向辺を追加する\n    */\n    void addEdge(int from, int to, Weight wei = 1) {\n        (*this)[from].push_back(Edge(from, to, wei));\n    }\n    /*\n    無向辺を追加する\n    */\n    void addUEdge(int u, int v, Weight wei = 1) {\n        (*this)[u].push_back(Edge(u, v, wei));\n        (*this)[v].push_back(Edge(v, u, wei));\n    }\n};\nbool operator>(const Edge &a, const Edge &b) {\n    return a.wei>b.wei;\n}\n\nvector<Weight> dijkstra(const Graph &G, int src, int x, int y) {\n    typedef pair<Weight, int> pwi;\n    priority_queue<pwi, vector<pwi>, greater<pwi>> pq;\n    pq.push(mp(0, src));\n    int V = (int)G.size();\n    vector<Weight> res(V, -1);\n    while (pq.size()) {\n        auto p = pq.top(); pq.pop();\n        Weight d = p.first;\n        int v = p.second;\n        if (res[v] > -1)continue;\n        res[v] = d;\n        for (const auto &edge : G[v]) {\n            int to = edge.to;\n            Weight wei = edge.wei;\n            if (wei == -1)wei = x;\n            if (wei == -2)wei = y;\n            pq.push(make_pair(d + wei, to));\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int A, B;\n    cin >> A >> B;\n\n    const int N = 101 * 2, M = N*(N - 1) / 2;\n    auto d = vv(int, A + 1, B + 1, 0);\n    FOR(x, 1, A + 1)FOR(y, 1, B + 1)cin >> d[x][y];\n    auto f = vv(int, 101, 101, 0);\n\n    Graph G(N);\n    rep(a, 101)rep(b, 101) {\n        FOR(x, 1, A + 1)FOR(y, 1, B + 1) {\n            smax(f[a][b], d[x][y] - x*a - y*b);\n        }\n        G.addEdge(a, N-1-b, f[a][b]);\n    }\n    rep(i, 100) {\n        G.addEdge(i, i + 1, -1);\n        G.addEdge(101 + i, 101 + i + 1, -2);\n    }\n\n    FOR(x, 1, A + 1)FOR(y, 1, B + 1) {\n        int dist = dijkstra(G, 0, x, y)[N - 1];\n        if (dist != d[x][y]) {\n            cout << \"Impossible\" << endl;\n            RT 0;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << N << ' ' << M << endl;\n    rep(i, N)each(e, G[i]) {\n        cout << e.from+1 << ' ' << e.to+1 << ' ';\n        if (e.wei == -1)cout << 'X';\n        else if (e.wei == -2)cout << 'Y';\n        else cout << e.wei;\n        cout << endl;\n    }\n    cout << 1 << ' ' << N << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 0; i < 100; i++) {\n        adj[ X(i) ].push_back(pii(X(i + 1), -1));\n    }\n    for(int i = 100; i >= 1; i--) {\n        adj[ Y(i) ].push_back(pii(Y(i - 1), -2));\n    }\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"%d\\n\", V);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                if(w == -1) printf(\"%d %d X\\n\", u + 1, v + 1);\n                else if(w == -2) printf(\"%d %d Y\\n\", u + 1, v + 1);\n                else printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n            }\n        }\n    }\n    \n    printf(\"%d %d\", src, snk);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nchar s[100];\n\nint a[310][310];\nint aa[310][310];\n\nint main()\n{\n  int i,j,k,l,o,p,ss,tt,n,m,x,y;\n  scanf(\"%s\",s);\n  scanf(\"%d%d\",&n,&m);\n\n  memset(a,-1,sizeof(a));\n  \n  for (i=0;i<m;i++)\n  {\n    scanf(\"%d%d%s\",&x,&y,s);\n    x--;y--;\n    if (s[0]=='X') a[x][y]=-2;\n    else if (s[0]=='Y') a[x][y]=-3;\n    else a[x][y]=atoi(s);\n    //cout<<x<<\" \"<<y<<\" \"<<a[x][y]<<endl;\n  }\n  scanf(\"%d%d\",&ss,&tt);\n  ss--;tt--;\n  for (i=1;i<=2;i++)\n  {\n    for (j=1;j<=3;j++)\n    {\n      for (k=0;k<n;k++)\n        for (l=0;l<n;l++)\n        {\n          aa[k][l]=a[k][l];\n          if (aa[k][l]==-2) aa[k][l]=i;\n          if (aa[k][l]==-3) aa[k][l]=j;\n          //if (aa[k][l]>=0) cout<<k<<\" \"<<l<<\" \"<<aa[k][l]<<endl;\n        }\n      //printf(\"\\n\");\n      for (o=0;o<n;o++)\n        for (k=0;k<n;k++)\n          for (l=0;l<n;l++)\n            if ((aa[k][o]>=0)&&(aa[o][l]>=0)&&((aa[k][o]+aa[o][l]<aa[k][l])||(aa[k][l]==-1)))\n              aa[k][l]=aa[k][o]+aa[o][l];\n      printf(\"%d \",aa[ss][tt]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <iterator>\n#include <utility>\n#include <map>\n#include <array>\n#include <functional>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(A))\n        RDV(d[i], d[i] + B);\n\n    vector<pair<int, int>> adj[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(A + 1))\n        for(int j: RG(B + 1))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    bool check = true;\n                    for(int ii = 0; ii <= A && check; ii++)\n                        for(int jj: RG(B))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nvector <int> dv;\nvector <int> av;\nvector <int> bv;\nint mn, mx;\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nvoid reconstruct(int x1, int y1, int c1, int x2, int y2, int c2) {\n  puts(\"Possible\");\n  // cerr << x1 << \" \" << y1 << \" \" << c1 << \" \" << x2 << \" \" << y2 << \" \" << c2 << endl;\n  int mxX = max(x1, x2);\n  int mxY = max(y1, y2);\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= mxX; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= mxY; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  addEdge(2 + x1, n - 1 - y1, c1);\n\n  if (x2 != -1) {\n    addEdge(2 + x2, n - 1 - y2, c2);\n  }\n\n  addEdge(1, n, mx);\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  exit(0);\n}\n\nvoid go(int x1, int y1, int c1, int pos) {\n  if (pos == sz(dv)) {\n    reconstruct(x1, y1, c1, -1, -1, -1);\n  }\n  if (x1 * av[pos] + y1 * bv[pos] + c1 == dv[pos] || dv[pos] == mx) {\n    go(x1, y1, c1, pos + 1);\n  }\n  for (int x2 = 0; x2 <= 100; x2++) {\n    if (av[pos] * x2 > dv[pos]) {\n      continue;\n    }\n    for (int y2 = 0; y2 <= 100; y2++) {\n      if (av[pos] * x2 + bv[pos] * y2 > dv[pos]) {\n        continue;\n      }\n      if (x2 == 0 && y2 == 0 && dv[pos] != mx) {\n        continue;\n      }\n      int c2 = dv[pos] - (av[pos] * x2 + bv[pos] * y2);\n      bool good = true;\n      for (int i = pos; i < sz(dv); i++) {\n        if (!(x2 * av[i] + y2 * bv[i] + c2 == dv[i] || \n              x1 * av[i] + y1 * bv[i] + c1 == dv[i] ||\n              dv[i] == mx)) {\n          good = false;\n          break;\n        }\n        if (x1 * av[i] + y1 * bv[i] + c1 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      for (int i = 0; i < pos; i++) {\n        if (x2 * av[i] + y2 * bv[i] + c2 < dv[i]) {\n          good = false;\n          break;\n        }\n      }\n      if (good) {\n        reconstruct(x1, y1, c1, x2, y2, c2);\n      }\n    }\n  }\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  mx = -1, mn = 105;\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n      mn = min(mn, d[i][j]);\n      mx = max(mx, d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      if (j > 0 && d[i][j] < d[i][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n      if (i > 0 && d[i][j] < d[i - 1][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  if (mn == mx) {\n    puts(\"Possible\");\n    cout << 2 << \" \" << 1 << endl;\n    cout << 1 << \" \" << 2 << \" \" << mx << endl;\n    cout << 1 << \" \" << 2 << endl;\n    return 0;\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      dv.push_back(d[i][j]);\n      av.push_back(i + 1);\n      bv.push_back(j + 1);\n    }\n  }\n\n  for (int x1 = 0; x1 <= 100; x1++) {\n    if (1 * x1 > d[0][0]) {\n      continue;\n    }\n    for (int y1 = 0; y1 <= 100; y1++) {\n      if (1 * x1 + 1 * y1 > d[0][0]) {\n        continue;\n      }\n      if (x1 == 0 && y1 == 0 && d[0][0] != mx) {\n        continue;\n      }\n      int c1 = d[0][0] - x1 - y1;\n      go(x1, y1, c1, 0);\n    }\n  }\n\n  puts(\"Impossible\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void addX(ll from, ll to) {\n        edges.pb({from, to, \"X\"});\n    }\n    void addY(ll from, ll to) {\n        edges.pb({from, to, \"Y\"});\n    }\n    void add(ll from, ll to, ll cost) {\n        edges.pb({from, to, to_string(cost)});\n    }\n    void output() {\n        assert(n <= 300);\n        cout << \"Possible\" << endl;\n        cout << n << \" \" << edges.size() << endl;\n        each(e, edges) {\n            cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    ll w = mx(X);\n    ll h = mx(Y);\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<vector<ll>> id(h+1, vector<ll>(w+1));\n    vector<vector<ll>> vid(A, vector<ll>(B));\n    rep(y, h+1) rep(x, w+1) id[y][x] = V++;\n    rep(a, A) rep(b, B) vid[a][b] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    rep(y, h) rep(x, w-1) {\n        // G.addX(id[y][x+1], id[y][x]);\n    }\n    rep(y, h-1) rep(x, w) {\n        // G.addY(id[y+1][x], id[y][x]);\n    }\n    G.add(id[0][0], t, 0);\n    rep(a, A) rep(b, B) {\n        G.add(s, vid[a][b], 0);\n        G.add(vid[a][b], id[Y[a][b]][X[a][b]], Z[a][b]);\n    }\n    G.output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<vector>\n#include<stack>\n#include<cmath>\n#include<random>\n//This code is written by Itst\nusing namespace std;\n\ninline int read(){\n    int a = 0;\n    char c = getchar();\n    bool f = 0;\n    while(!isdigit(c) && c != EOF){\n        if(c == '-')\n            f = 1;\n        c = getchar();\n    }\n    if(c == EOF)\n        exit(0);\n    while(isdigit(c)){\n\ta = a * 10 + c - 48;\n        c = getchar();\n    }\n    return f ? -a : a;\n}\n\nint d[12][12] , f[107][107];\n\nsigned main(){\n    int A = read() , B = read();\n    for(int i = 1 ; i <= A ; ++i)\n\tfor(int j = 1 ; j <= B ; ++j)\n\t    d[i][j] = read();\n    for(int i = 0 ; i <= 100 ; ++i)\n\tfor(int j = 0 ; j <= 100 ; ++j)\n\t    for(int p = 1 ; p <= A ; ++p)\n\t\tfor(int q = 1 ; q <= B ; ++q)\n\t\t    f[i][j] = max(f[i][j] , d[p][q] - i * p - j * q);\n    for(int i = 1 ; i <= A ; ++i)\n\tfor(int j = 1 ; j <= B ; ++j){\n\t    int minN = 1e9;\n\t    for(int p = 0 ; p <= 100 ; ++p)\n\t\tfor(int q = 0 ; q <= 100 ; ++q)\n\t\t    minN = min(minN , f[p][q] + p * i + q * j);\n\t    if(minN != d[i][j]){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t    }\n\t}\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1 ; i <= 100 ; ++i)\n\tprintf(\"%d %d X\\n\" , i , i + 1);\n    for(int i = 102 ; i < 202 ; ++i)\n\tprintf(\"%d %d Y\\n\" , i , i + 1);\n    for(int i = 0 ; i <= 100 ; ++i)\n\tfor(int j = 0 ; j <= 100 ; ++j)\n\t    printf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"impossible\");\n\telse\n\t{\n\t\tputs(\"possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + (A+1)*(B+1));\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a <= A; ++a)\n\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint To[10005], Next[10005], Head[305], W[10005], S, T, Cnt, Dis[305], M;\nbool Vis[305];\nstruct Node{\n\tint X, V;\n\tbool operator < (const Node &B)const\n\t{\n\t\treturn V > B.V;\n\t}\n};\ninline void Insert(int U, int V, int Val)\n{\n\tTo[++Cnt] = V, Next[Cnt] = Head[U], Head[U] = Cnt, W[Cnt] = Val;\n}\npriority_queue<Node>Q;\ninline int Dij(int X, int Y)\n{\n\tmemset(Dis, 0x3f, sizeof(Dis));\n\tmemset(Vis, 0, sizeof(Vis));\n\tDis[S] = 0;\n\tQ.push((Node){S, 0});\n\tint U, V;\n\twhile(!Q.empty()){\n\t\tU = Q.top().X;\n\t\tQ.pop();\n\t\tif(Vis[U])continue;\n\t\tVis[U] = true;\n\t\tfor(int I = Head[U], Val, V; I; I = Next[I]){\n\t\t\tVal = (W[I] == -1) ? X : (W[I] == -2) ? Y : W[I];\n\t\t\tV = To[I];\n\t\t\tif(Dis[U] + Val < Dis[V]){\n\t\t\t\tDis[V] = Dis[U] + Val;\n\t\t\t\tQ.push((Node){V, Dis[V]});\n\t\t\t}\n\t\t}\n\t}\n\treturn Dis[T];\n}\nint main()\n{\n\tmemset(F, -1, sizeof(F));\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\tfor(int I = 1; I <= 100; ++I)\n\t\tInsert(I, I + 1, -1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tInsert(I, I + 1, -2);\n\tM = 200;\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1)\n\t\t\t\tInsert(1 + I, 102 + J, F[I][100 - J]), ++M;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\tif(Dij(X, Y) != D[X][Y]){cout<<Dij(X, Y)<<endl;puts(\"Impossilble\"); return 0;}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J] != -1){\n\t\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\t\t\t}\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#define LL long long\n#define Re register int\nusing namespace std;\nconst int N=103,M=13;\nint n,m,d[13][13],f[103][103];\ninline void in(Re &x){\n    int f=0;x=0;char c=getchar();\n    while(c<'0'||c>'9')f|=c=='-',c=getchar();\n    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();\n    x=f?-x:x;\n}\nint main(){\n//\tfreopen(\"123.txt\",\"r\",stdin);\n\tin(n),in(m);\n\tfor(Re i=1;i<=n;++i)\n\t\tfor(Re j=1;j<=n;++j)\n\t\t\tin(d[i][j]);\n\tfor(Re i=0;i<=100;++i)\n\t\tfor(Re j=0;j<=100;++j)\n\t\t\tfor(Re x=1;x<=n;++x)\n\t\t\t\tfor(Re y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(Re x=1;x<=n;++x)\n\t\tfor(Re y=1;y<=m;++y){\n\t\t\tRe dis=2e9;\n\t\t\tfor(Re i=0;i<=100;++i)\n\t\t\t\tfor(Re j=0;j<=100;++j)\n\t\t\t\t\tdis=min(dis,f[i][j]+i*x+j*y);\n\t\t\tif(dis!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n    for(Re i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n    for(Re i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n    for(Re i=0;i<=100;i++)\n        for(Re j=0;j<=100;j++)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    puts(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 202 << \" \" << 10401 << \"\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<=100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nconst int INF = 999999999;\n\nint n, m, d[55][55], f[55][55], tmp[55][55];\n\nvoid Read(int &x)\n{\n    x = 0; int p = 0; char st = getchar();\n    while (st < '0' || st > '9') p = (st == '-'), st = getchar();\n    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();\n    x = p ? -x : x;\n    return;\n}\n\nint Max(int a, int b)\n{\n    return a > b ? a : b;\n}\n\nint Min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            scanf(\"%d\", &d[i][j]);\n\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++) \n            for (int x = 1; x <= n; x++)\n                for (int y = 1; y <= m; y++)\n                    f[i][j] = Max(f[i][j], d[x][y] - i * x - j * y);\n\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            tmp[x][y] = INF;\n            for (int i = 0; i <= 100; i++)\n                for (int j = 0; j <= 100; j++)\n                    tmp[x][y] = Min(tmp[x][y], i * x + j * y + f[i][j]);\n        }\n\n\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if(tmp[i][j] != d[i][j])\n            {\n                puts(\"Impossible\"); return 0;\n            }\n\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 10401);\n    for (int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", i + 1, 220 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint A, B;\nint d[11][11];\npair<pii, int> info[11][11];\n\nint main() {\n\tcin >> A >> B;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\n\tint maxi = 0;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tvector<pii> cand;\n\t\t\tfor (int k = 0; k <= 100; ++k) {\n\t\t\t\tfor (int l = 0; l <= 100; ++l) {\n\t\t\t\t\tif (k * i + l * j > d[i][j]) continue;\n\t\t\t\t\tint c = d[i][j] - k * i - l * j;\n\t\t\t\t\tbool ok = 1;\n\n\t\t\t\t\tfor (int p = 1; p <= A; ++p) {\n\t\t\t\t\t\tfor (int q = 1; q <= B; ++q) {\n\t\t\t\t\t\t\tif (p * k + q * l + c < d[p][q]) {\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tcand.eb(k, l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cand.size() == 0) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tpii la = cand.back();\n\t\t\t\tmaxi = max(maxi, la.se);\n\t\t\t\tint zan = d[i][j] - la.fi * i - la.se * j;\n\t\t\t\tinfo[i][j] = mp(la, zan);\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\n\tvector<pair<pii, int>> vec;\n\n\tint S = 0;\n\tint now = 101;\n\n\trep(i, 100) {\n\t\tvec.eb(mp(i, i + 1), -1);\n\t}\n\n\tint T = now;\n\n\trep(i, maxi) {\n\t\t++now;\n\t\tvec.eb(mp(now, now - 1), -2);\n\t}\n\t++now;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tpii p = info[i][j].fi;\n\t\t\tint c = info[i][j].se;\n\t\t\tvec.eb(mp(p.fi, now), c);\n\t\t\tvec.eb(mp(now, T + p.se), 0);\n\t\t\t++now;\n\t\t}\n\t}\n\n\tcout << now << \" \" << vec.size() << endl;\n\tfor (auto e : vec) {\n\t\tprintf(\"%d %d \", e.fi.fi + 1, e.fi.se + 1);\n\t\tif (e.se == -1) {\n\t\t\tputchar('X');\n\t\t} else if (e.se == -2) {\n\t\t\tputchar('Y');\n\t\t} else {\n\t\t\tprintf(\"%d\", e.se);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\tcout << S + 1 << \" \" << T + 1 << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint main() {\n    // input\n    int a, b; cin >> a >> b;\n    auto d = vectors(a, b, int());\n    REP (x, a) REP (y, b) cin >> d[x][y];\n    // solve\n    constexpr int n = 300;\n    constexpr int max_d = 100;\n    // // prepare the structure\n    vector<tuple<int, int, char> > char_edge;\n    vector<int> xs(max_d + 1);\n    vector<int> ys(max_d + 1);\n    xs[0] = 0;\n    ys[0] = n - 1;\n    REP (i, max_d) {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.emplace_back(xs[i], xs[i + 1], 'X');\n        char_edge.emplace_back(ys[i + 1], ys[i], 'Y');\n    }\n    // // construct the required graph\n    auto used = vectors(a, b, bool());\n    vector<tuple<int, int, int> > int_edge;\n    REP (i, a + 1) REP (j, b + 1) {\n        REP (c, 101) {\n            REP (x, a) REP (y, b) {\n                int f = i * (x + 1) + j * (y + 1) + c;\n                if (f < d[x][y]) {\n                    goto invalid;\n                } else if (f == d[x][y]) {\n                    used[x][y] = true;\n                }\n            }\n            int_edge.emplace_back(xs[i], ys[j], c);\n            break;\ninvalid: ;\n        }\n    }\n    // // check the result\n    bool possible = true;\n    REP (x, a) REP (y, b) {\n        if (not used[x][y]) {\n            possible = false;\n        }\n    }\n    // output\n    cout << (possible ? \"Possible\" : \"Impossible\") << endl;\n    if (possible) {\n        int m = int_edge.size() + char_edge.size();\n        cout << n << ' ' << m << endl;\n        for (auto e : char_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        for (auto e : int_edge) {\n            cout << get<0>(e) << ' ' << get<1>(e) << ' ' << get<2>(e) << endl;\n        }\n        int s = xs[0];\n        int t = ys[0];\n        cout << s << ' ' << t << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\n#define int long long\n\nconst int MOD = 1e9 + 7;\n\nint a, b;\nint d[50][50];\nint go[200][200];\n\nsigned main()\n{\n    //freopen(\"input_02.txt\", \"r\", stdin);\n    //freopen(\"output_02.txt\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> d[i][j];\n        }\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            int max_c = -1e9;\n            for (int x = 1; x <= a; x++)\n            {\n                for (int y = 1; y <= b; y++)\n                {\n                    int moved = i * x + j * y;\n                    int add = d[x][y] - moved;\n                    max_c = max(max_c, add);\n                }\n            }\n            if (max_c <= 100 && 0 <= max_c)\n            {\n                go[i][j] = max_c;\n            }\n            else\n            {\n                go[i][j] = 1e9;\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (x * i + go[i][j] + y * j < d[i][j])\n                    {\n                        go[i][j] = 1e9;\n                    }\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= a; x++)\n    {\n        for (int y = 1; y <= b; y++)\n        {\n            int min_c = 1e9;\n            for (int i = 0; i <= 100; i++)\n            {\n                for (int j = 0; j <= 100; j++)\n                {\n                    if (min_c > i * x + go[i][j] + j * y)\n                    {\n                        min_c = i * x + go[i][j] + j * y;\n                    }\n                }\n            }\n            if (min_c != d[x][y])\n            {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    int cnt = 0;\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j]) cnt++;\n        }\n    }\n    cout << 202 << \" \" << cnt << \"\\n\";\n    for (int i = 0; i < 100; i++)\n    {\n        cout << i + 1 << \" \" << i + 2 << \" \" << 'X' << \"\\n\";\n    }\n    for (int j = 0; j < 100; j++)\n    {\n        cout << 202 - j - 1 << \" \" << 202 - j << \" \" << 'Y' << \"\\n\";\n    }\n    for (int i = 0; i <= 100; i++)\n    {\n        for (int j = 0; j <= 100; j++)\n        {\n            if (go[i][j] <= 100 && 0 <= go[i][j])\n            {\n                cout << i + 1 << \" \" << 202 - j << \" \" << go[i][j] << \"\\n\";\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e3 + 5;\n\nint mx[MAXN][MAXN];\nint d[MAXN][MAXN];\nint used[MAXN][MAXN];\n\nvoid solve(){\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tREPN(i, 1, A){\n\t\tREPN(j, 1, B){\n\t\t\tscanf(\"%d\", &d[i][j]);\n\t\t}\n\t}\n\tint lim = 100;\n\tREPN(i, 0, lim){\n\t\tREPN(j, 0, lim){\n\t\t\tREPN(k, 1, A){\n\t\t\t\tREPN(l, 1, B){\n\t\t\t\t\tint delta = d[k][l] - (i * k + j * l);\n\t\t\t\t\tmx[i][j] = max(mx[i][j], delta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREPN(k, 1, A){\n\t\t\t\tREPN(l, 1, B){\n\t\t\t\t\tint delta = d[k][l] - (i * k + j * l);\n\t\t\t\t\tif (delta == mx[i][j]){\n\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\", i, j, k, l, d[k][l]);\n\t\t\t\t\t\tused[k][l] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t/*if (k == 1 && l == 1){\n\t\t\t\t\t\tprintf(\"%d %d %d %d\\n\", i, j, i * k + j * l + mx[i][j], d[1][1]);\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint good = 1;\n\tREPN(k, 1, A){\n\t\tREPN(l, 1, B){\n\t\t\t//printf(\"%d %d %d\\n\", k, l, used[k][l]);\n\t\t\tgood &= used[k][l];\n\t\t}\n\t}\n\t\n\tif (!good){\n\t\tprintf(\"Impossible\\n\");\n\t\treturn;\n\t}\n\tprintf(\"Possible\\n\");\n\tint n = lim + lim + 2;\n\tprintf(\"%d %d\\n\", n, (lim + 1) * (lim + 1) + lim + lim);\n\tREPN(i, 1, lim){\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t}\n\tREPN(i, 1, lim){\n\t\tprintf(\"%d %d Y\\n\", lim + 1 + i, lim + 1 + i + 1);\n\t}\n\tREPN(i, 0, lim){\n\t\tREPN(j, 0, lim){\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, n - j, mx[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 1, n);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      rep(x, a){\n        rep(y, b){\n          chmax(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <time.h>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdlib.h>\n#include <deque>\n#include <iomanip>\n#include <complex>\n//#include <ext/rope>\n\nusing namespace std;\n//using namespace __gnu_cxx;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fast_read cin.sync_with_stdio(0)\n#define PREX(number) cout << fixed << setprecision(number)\n#define nul point(0, 0)\n#define random srand(time(NULL))\n#define rand_int abs((rand() << 15) | rand())\n#define str_to_int(stroka) atoi(stroka.c_str())\n#define str_to_ll(stroka) atoll(stroka.c_str())\n#define str_to_double(stroka) atof(stroka.c_str())\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; forn(i, 0, number) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); forn(i, 0, number) solve()\n\n//easy functions\ntemplate< typename T >\nT gcd(T a, T b) { return a ? gcd(b % a, a) : b; }\ntemplate< typename T >\nT lcm(T a, T b) { return (a / gcd(a, b)) * b; }\nbool is_down(char x) { return ('a' <= x && x <= 'z'); }\nbool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\nbool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//constants\nconst ld pi = 3.141592653589793238462643383279;\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ld zero = 0;\nconst ll INF = 1e18;\nconst int COUT = 30;\nconst int prost = 239;\nconst ll prost64 = 239;\nconst int two = 2;\nconst int thr = 3;\nconst ll sr = 31;\nconst int MOD = 1e9 + 7;\nconst int BIG = 2 * 1e9 + 1;\nconst int alf = 26;\nconst int MAX_N = 2 * 1e5 + 10;\nconst int MAX_M = 11;\nconst int MAX_T = (1 << 20);\nconst int BLOCK = trunc(sqrt(MAX_N)) + 1;\nconst int MAX_LOG = 19;\nconst int km = (1 << 18);\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int bit_max = 32;\nconst int dig = 10;\nconst string str_alf = \"abcdefghijklmnopqrstuvwxyz\";\nconst string str_alf_big = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n// Code starts here\n\nint n, m, d[MAX_M][MAX_M];\nbool used[MAX_M][MAX_M];\n\nbool check(int a, int b, int c)\n{\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            int now = (x * a + y * b + c);\n            if (now < d[x - 1][y - 1])\n                return false;\n        }\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            int now = (x * a + y * b + c);\n            if (d[x - 1][y - 1] == now)\n                used[x - 1][y - 1] = true;\n        }\n    return 1;\n}\n\nint main()\n{   /*\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif /**/\n    fast_read;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            cin >> d[i][j];\n    vector<tuple<int, int, int> > ans;\n    for (int a = 0; a <= 100; a++)\n        for (int b = 0; b <= 100; b++)\n            for (int c = 0; c <= 100; c++)\n                if (check(a, b, c))\n                {\n                    ans.push_back(make_tuple(a, b, c));\n                    break;\n                }\n    bool ch = true;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            ch &= used[i][j];\n    if (!ch)\n    {\n        cout << \"Impossible\";\n        return 0;\n    }\n    cout << \"Possible\\n\";\n    int N = (202);\n    vector<tuple<int, int, int> > r;\n    for (tuple<int, int, int> t : ans)\n        r.push_back(make_tuple(get<0>(t), get<1>(t) + 101, get<2>(t)));\n    cout << N << \" \" << r.size() + 200 << \"\\n\";\n    for (tuple<int, int, int> t : r)\n        cout << get<0>(t) + 1 << \" \" << get<1>(t) + 1 << \" \" << get<2>(t) << \"\\n\";\n    for (int i = 0; i < 100; i++)\n        cout << i + 1 << \" \" << i + 2 << \" \" << \"X\\n\";\n    for (int i = 0; i < 100; i++)\n        cout << i + 1 + 101 << \" \" << i + 2 + 101 << \" \" << \"Y\\n\";\n    cout << \"1 202\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\tM = 200 + 101 * 101;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, const char * argv[]) {\n    int queries, checkSize;\n    scanf(\"%d%d\", &queries, &checkSize);\n\n    int count = 0, maxCount;\n    int qx[100000], qy[100000];\n    bool qBlack[100000];\n    int totalX[1000] = {};\n    int countX[1000] = {};\n\n    for (int i = 0; i < queries; ++i) {\n        int x, y;\n        char colorChar[10];\n        scanf(\"%d%d%s\", &x, &y, colorChar);\n\n        bool black = colorChar[0] == 'B';\n\n        if ((x / checkSize + y / checkSize) % 2 != 0) {\n            black = !black;\n        }\n\n        x %= checkSize;\n        y %= checkSize;\n\n        qx[i] = x;\n        qy[i] = y;\n        qBlack[i] = black;\n\n        totalX[x]++;\n    }\n\n    maxCount = 0;\n\n    for (int i = 0; i < checkSize; ++i) {\n        count = 0;\n        for (int l = 0; l < checkSize; ++l) {\n            countX[l] = 0;\n        }\n\n        for (int k = 0; k < queries; ++k) {\n            if (qBlack[k] && qy[k] >= i) {\n                count++;\n                countX[qx[k]]++;\n            }\n        }\n        for (int j = 0; j < checkSize * 2; ++j) {\n            maxCount = max(maxCount, count);\n            count -= countX[j%2];\n            count += totalX[j%2] - countX[j%2];\n        }\n    }\n\n    printf(\"%d\\n\", maxCount);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int M = 12, N = 310;\n\nint d[M][M], dis[M][M], A, B;\nint f[N][N];\n\nint main(){\n\n\tscanf(\"%d%d\", &A, &B);\n\tFor(i, 1, A) For(j, 1, B) scanf(\"%d\", &d[i][j]), dis[i][j] = 1e9;\n\tFor(i, 0, 100) For(j, 0, 100) For(u, 1, A) For(v, 1, B) \n\t\tf[i][j] = max(f[i][j], d[u][v] - u * i - v * j);\n\tFor(u, 1, A) For(v, 1, B) For(i, 0, 100) For(j, 0, 100)\n\t\tdis[u][v] = min(dis[u][v], f[i][j] + i * u + j * v);\n\tFor(u, 1, A) For(v, 1, B) if(d[u][v] != dis[u][v]){\n\t\tputs(\"IMPOSSIBLE\");\n\t\treturn 0;\n\t}\n\n\n\tputs(\"POSSIBLE\");\n\tint n = 101;\n\tprintf(\"%d %d\\n\", n * 2, n * n + 2 * (n - 1));\n\tFor(i, 1, n) For(j, 1, n) printf(\"%d %d %d\\n\", i, j + n, f[i - 1][j - 1]);\n\tFor(i, 2, n) printf(\"%d %d X\\n\", i - 1, i);\n\tFor(i, 2, n) printf(\"%d %d Y\\n\", i + n, i + n - 1);\n\tprintf(\"%d %d\\n\", 1, n + 1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntypedef int Weight;\nstruct Edge {\n    int from, to;\n    Weight wei;\n    Edge(int from_, int to_, Weight wei_) :from(from_), to(to_), wei(wei_) {}\n};\ntypedef vector<Edge> Edges;\nconst Weight INFW = numeric_limits<Weight>::max();\nstruct Graph : public vector<Edges> {\n    Graph() { }\n    Graph(int V) : vector<Edges>(V) { }\n    /*\n    有向辺を追加する\n    */\n    void addEdge(int from, int to, Weight wei = 1) {\n        (*this)[from].push_back(Edge(from, to, wei));\n    }\n    /*\n    無向辺を追加する\n    */\n    void addUEdge(int u, int v, Weight wei = 1) {\n        (*this)[u].push_back(Edge(u, v, wei));\n        (*this)[v].push_back(Edge(v, u, wei));\n    }\n};\nbool operator>(const Edge &a, const Edge &b) {\n    return a.wei>b.wei;\n}\n\nvector<Weight> dijkstra(const Graph &G, int src, int x, int y) {\n    typedef pair<Weight, int> pwi;\n    priority_queue<pwi, vector<pwi>, greater<pwi>> pq;\n    pq.push(mp(0, src));\n    int V = (int)G.size();\n    vector<Weight> res(V, -1);\n    while (pq.size()) {\n        auto p = pq.top(); pq.pop();\n        Weight d = p.first;\n        int v = p.second;\n        if (res[v] > -1)continue;\n        res[v] = d;\n        for (const auto &edge : G[v]) {\n            int to = edge.to;\n            Weight wei = edge.wei;\n            if (wei == -1)wei = x;\n            if (wei == -2)wei = y;\n            pq.push(make_pair(d + wei, to));\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    int A, B;\n    cin >> A >> B;\n\n    const int N = 101 * 2, M = 100 * 2 + 101 * 101;\n    auto d = vv(int, A + 1, B + 1, 0);\n    FOR(x, 1, A + 1)FOR(y, 1, B + 1)cin >> d[x][y];\n    auto f = vv(int, 101, 101, 0);\n\n    Graph G(N);\n    rep(a, 101)rep(b, 101) {\n        FOR(x, 1, A + 1)FOR(y, 1, B + 1) {\n            smax(f[a][b], d[x][y] - x*a - y*b);\n        }\n        G.addEdge(a, N-1-b, f[a][b]);\n    }\n    rep(i, 100) {\n        G.addEdge(i, i + 1, -1);\n        G.addEdge(101 + i, 101 + i + 1, -2);\n    }\n\n    FOR(x, 1, A + 1)FOR(y, 1, B + 1) {\n        int dist = dijkstra(G, 0, x, y)[N - 1];\n        if (dist != d[x][y]) {\n            cout << \"Impossible\" << endl;\n            RT 0;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << N << ' ' << M << endl;\n    rep(i, N)each(e, G[i]) {\n        cout << e.from+1 << ' ' << e.to+1 << ' ';\n        if (e.wei == -1)cout << 'X';\n        else if (e.wei == -2)cout << 'Y';\n        else cout << e.wei;\n        cout << endl;\n    }\n    cout << 1 << ' ' << N << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[N], Y[N], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 0, yy = 0;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      xx = std::max(xx, d[i][j] / i);\n      yy = std::max(yy, d[i][j] / j);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = -100000000;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d\\n\", cnt);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[550];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 550; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  //cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 110;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = 1<<29;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  if (chmin(se, tse)) {\n\t\t\t\tdx = tdx, dy = tdy, se = tse;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (dx == -1) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\t/*\n\t\tint p = se / 100;\n\t\tint q = se % 100;\n\t\tG.resize(G.size() + p);\n\t\tG[dx].push_back(pint(t-dy, se));\n\t\t*/\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\t\n\t\tputs(\"Possible\");\n\n\t\tset<pair<int,pint> > S;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (auto e : G[i]) {\n\t\t\tS.insert(make_pair(i, e));\n\t\t  }\n\t\t}\n\t\t\n\t\tcout << G.size() << \" \" << S.size() << endl;\n\t\tfor (set<pair<int,pint> >::iterator it = S.begin(); it != S.end(); ++it) {\n\t\t  int from = (*it).first;\n\t\t  int to = (*it).second.first;\n\t\t  int w = (*it).second.second;\n\t\t  cout << from+1 << \" \" << to+1 << \" \";\n\t\t  if (w == -1) cout << \"X\";\n\t\t  else if (w == -2) cout << \"Y\";\n\t\t  else cout << w;\n\t\t  cout << endl;\n\t\t}\n\t\tcout << s+1 << \" \" << t+1 << endl;\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll X, Y; cin >> X >> Y;\n    vvll d(X, vll(Y)); cin >> d;\n\n    // X=x, Y=y (1 <= x <= X, 1 <= y <= Y)\n    // a = xの数、b = yの数 (0 <= a, b <= 100)\n    //\n    // for all x,y  \n    //      d_xy = min_ab ax+by+c_ab\n    //\n    // c_ab = max(0, max_xy d_xy - ax - by)\n    ll abmax = 101;\n    rep(x, X) rep(y, Y) {\n        chmin(abmax, d[x][y]); \n    }\n    abmax++;\n\n    vvll c(abmax, vll(abmax));\n    rep(a, c.size()) rep(b, c[0].size()) {\n        repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n            chmax(c[a][b], d[x-1][y-1]-a*x-b*y);\n        }\n    }\n    repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n        ll tmp = INF;\n        rep(a, abmax) rep(b, abmax) {\n            chmin(tmp, a*x+b*y+c[a][b]);\n        }\n        if (d[x-1][y-1] != tmp) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    ll n = 2 * (abmax+1);\n    ll m = 2 + c.size() * c[0].size() + abmax * 2;\n    cout << n << \" \" << m << endl;\n    rep(i, c.size()) {\n        cout << i+1 << \" \" << i+1+1 << \" \" << \"X\" << endl;\n        cout << 2*abmax+1-i-1+1 << \" \" << 2*abmax+1-i+1 << \" \" << \"Y\" << endl;\n    }\n    rep(a, c.size()) rep(b, c[0].size()) {\n        cout << a+1 << \" \" << 2 * abmax + 1 - b+1 << \" \" << c[a][b] << endl;\n    }\n    cout << 1 << \" \" << n << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint A, B;\nint d[20][20];\n\nint N, M;\nint cost[101][101];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> A >> B;\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) cin >> d[x][y];\n\n    N = 202;\n    M = 10401;\n\n    rep(i, 101) rep(j, 101) FOR(x, 1, A + 1) FOR(y, 1, B + 1)\n        chmax(cost[i][j], d[x][y] - i * x - j * y);\n\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) {\n        int mn = 1 << 30;\n        rep(i, 101) rep(j, 101) chmin(mn, x * i + y * j + cost[i][j]);\n        if(mn != d[x][y]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    cout << N << \" \" << M << \"\\n\";\n\n    rep(i, 100) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    rep(j, 100) cout << A + j + 2 << \" \" << A + j + 3 << \" Y\\n\";\n\n    rep(i, 101) rep(j, 101) cout << i + 1 << \" \" << N - j << \" \" << cost[i][j]\n                                 << \"\\n\";\n\n    cout << \"1 \" << N << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 17;\nconst int Maxm = 305;\nconst int Inf = 1000000000;\n\nint A, B;\nint D[Maxn][Maxn];\nint mn[Maxn][Maxn];\nint N;\nvector <ii> neigh[Maxm];\nint dist[Maxm];\n\nint getFirst(int r, int c)\n{\n\treturn r * Maxn + c + 1;\n}\n\nint Get(int v, int t, int X, int Y)\n{\n\t//printf(\"(%d, %d, %d, %d)\\n\", v, t, X, Y);\n\tfill(dist, dist + Maxm, Inf); dist[v] = 0;\n\tpriority_queue <ii> Q; Q.push(ii(-dist[v], v));\n\twhile (!Q.empty()) {\n\t\tint v = Q.top().second, d = -Q.top().first; Q.pop();\n\t\tif (dist[v] != d) continue;\n\t//\tprintf(\"v = %d, d = %d\\n\", v, d);\n\t\tif (t == v) return d;\n\t\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\t\tii u = neigh[v][i];\n\t\t\tif (u.second == -1) u.second = X;\n\t\t\tif (u.second == -2) u.second = Y;\n\t\t\t//printf(\"u = (%d, %d)  d = %d\\n\", u.first, u.second, dist[u.first]);\n\t\t\tif (d + u.second < dist[u.first]) {\n\t\t\t\tdist[u.first] = d + u.second;\n\t\t\t\tQ.push(ii(-dist[u.first], u.first));\n\t\t\t}\n\t\t}\n\t}\n\treturn Inf;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &A, &B);\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tscanf(\"%d\", &D[i][j]);\n\t\t\tfor (int koefi = 0; koefi < Maxn; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < Maxn; koefj++)\n\t\t\t\t\tmn[koefi][koefj] = max(mn[koefi][koefj], D[i][j] - koefi * (i + 1) - koefj * (j + 1));\n\t\t}\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (int koefi = 0; koefi < Maxn && !ok; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < Maxn && !ok; koefj++)\n\t\t\t\t\tok = koefi * (i + 1) + koefj * (j + 1) + mn[koefi][koefj] == D[i][j];\n\t\t\tif (!ok) { printf(\"Impossible\\n\"); return 0; }\n\t\t}\n\tN = Maxn * Maxn + 1;\n\tfor (int i = 0; i < Maxn; i++)\n\t\tfor (int j = 0; j < Maxn; j++) {\n\t\t\tneigh[getFirst(i, j)].push_back(ii(N, mn[i][j]));\n\t\t\tif (j + 1 < Maxn)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i, j + 1), -2));\n\t\t\tif (i + 1 < Maxn)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i + 1, j), -1));\n\t\t}\n\tint M = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tM += neigh[i].size();\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", N, M);\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 0; j < neigh[i].size(); j++) {\n\t\t\tprintf(\"%d %d \", i, neigh[i][j].first);\n\t\t\tif (neigh[i][j].second == -1) printf(\"X\\n\");\n\t\t\telse if (neigh[i][j].second == -2) printf(\"Y\\n\");\n\t\t\telse printf(\"%d\\n\", neigh[i][j].second);\n\t\t}\n\tprintf(\"%d %d\\n\", getFirst(0, 0), N);\n\t/*for (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tint g = Get(getFirst(0, 0), N, i + 1, j + 1);\n\t\t\tif (D[i][j] != g) \n\t\t\t\tprintf(\"(%d, %d) (%d, %d)\\n\", i, j, D[i][j], g);\n\t\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n#include <queue>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n    }\n  }\n  auto calc = [&](int x, int y) {\n    std::vector<std::vector<std::pair<int, int>>> graph(N);\n    for (int i: range(1, N / 2)) {\n      graph[i - 1].emplace_back(i, x);\n    }\n    for (int i: range(N / 2 + 1, N)) {\n      graph[i - 1].emplace_back(i, y);\n    }\n    for (int i: range(0, A)) {\n      for (int j: range(0, B)) {\n        if (length[i][j] != -1) {\n          graph[i].emplace_back(N - j - 1, length[i][j]);\n        }\n      }\n    }\n    std::vector<int> dist(N, d_max);\n    dist.front() = 0;\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> que;\n    que.emplace(dist[0], 0);\n    while (!que.empty()) {\n      auto tmp = que.top();\n      que.pop();\n      int d = tmp.first;\n      int v = tmp.second;\n      if (d > dist[v]) {\n        continue;\n      }\n      for (auto e: graph[v]) {\n        if (chmin(dist[e.first], dist[v] + e.second)) {\n          que.emplace(dist[e.first], e.first);\n        }\n      }\n    }\n    return dist.back();\n  };\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      int tmp = calc(i + 1, j + 1);\n      if (tmp > dist[i][j]) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      else if (tmp < dist[i][j]) {\n        return 1;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  std::cout << \"Possible\\n\";\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint A,B;\nint C[11][11];\nint DX[11][11];\nint DY[11][11];\nint NV;\nint V[303][303];\nint YV[101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(V);\n\t\n\tvector<int> Xs,Ys;\n\tNV=1;\n\tXs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV][NV+1]=-2;\n\t\tNV++;\n\t\tXs.push_back(NV);\n\t}\n\tNV++;\n\tYs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV+1][NV]=-3;\n\t\tNV++;\n\t\tYs.push_back(NV);\n\t}\n\treverse(ALL(Ys));\n\t\n\t\n\tcin>>A>>B;\n\tfor(y=1;y<=A;y++) {\n\t\tfor(x=1;x<=B;x++) {\n\t\t\tcin>>C[y][x];\n\t\t}\n\t}\n\tfor(y=A;y>=1;y--) {\n\t\tfor(x=B;x>=1;x--) {\n\t\t\tif(y<A) {\n\t\t\t\tDY[y][x]=max({DY[y][x],C[y+1][x]-C[y][x],DY[y+1][x]});\n\t\t\t\tDX[y][x]=max({DX[y][x],DX[y+1][x]});\n\t\t\t}\n\t\t\tif(x<B) {\n\t\t\t\tDX[y][x]=max({DX[y][x],C[y][x+1]-C[y][x],DX[y][x+1]});\n\t\t\t\tDY[y][x]=max({DY[y][x],DY[y][x+1]});\n\t\t\t\n\t\t\tif(C[y][x]>DY[y][x]*y+DX[y][x]*x) return _P(\"Impossible\\n\");}\n\t\t\tV[Xs[DX[y][x]]][NV]=C[y][x]-(DY[y][x]*y+DX[y][x]*x);\n\t\t\tV[NV][Ys[DY[y][x]]]=0;\n\t\t\tNV++;\n\t\t}\n\t}\n\t\n\tint cnt=0;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) cnt++;\n\tcout<<cnt<<endl;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) {\n\t\tcout<<x<<\" \"<<y<<\" \";\n\t\tif(V[x][y]==-2) cout<<\"X\"<<endl;\n\t\tif(V[x][y]==-3) cout<<\"Y\"<<endl;\n\t\tif(V[x][y]>=0) cout<<V[x][y]<<endl;\n\t}\n\tcout<<Xs[0]<<\" \"<<Ys[0]<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tvvi c(110,vi(110));\n\trep(i,110)rep(j,110){\n\t\tint ma=0;\n\t\trep(k,n)rep(l,m)ma=max(ma,in[k][l]-i*(k+1)-j*(l+1));\n\t\tc[i][109-j]=ma;\n\t}\n\tbool h=true;\n\trep(i,n)rep(j,m){\n\t\tint mi=inf;\n\t\trep(k,110)rep(l,110)mi=min(mi,(i+1)*k+(j+1)*l+c[k][109-l]);\n\t\tif(mi!=in[i][j])h=false;\n\t}\n\t\n\tif(!h)cout<<\"Impossible\"<<endl;\n\telse{\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<\"220 \"<<218+110*110<<endl;\n\t\trep(i,109)cout<<1+i<<\" \"<<2+i<<\" X\"<<endl;\n\t\trep(i,109)cout<<219-i<<\" \"<<220-i<<\" Y\"<<endl;\n\t\trep(i,110)rep(j,110){\n\t\t\tcout<<1+i<<\" \"<<n+2+j<<\" \"<<c[i][j]<<endl;\n\t\t}\n\t\tcout<<\"1 220\"<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nll mp[11][11];\nll dist[222][222];\nll mi[22][22];\n\nint main()\n{\n\tint a,b;cin >> a >> b;\n\tREP(i,22)REP(j,22)mi[i][j] = 10000;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\t\n\tREP(i,101)\n\t{\n\t\tREP(j,101)\n\t\t{\n\t\t\tll tmp = 0;\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\ttmp = max(tmp,mp[x][y]-(i*(x+1))-(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tREP(x,a)\n\t\t\t{\n\t\t\t\tREP(y,b)\n\t\t\t\t{\n\t\t\t\t\tmi[x][y] = min(mi[x][y],tmp+(i*(x+1))+(j*(y+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdist[i][j] = tmp;\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\t\n\tREP(i,a)\n\t{\n\t\tREP(j,b)\n\t\t{\n\t\t\tif(mi[i][j] != mp[i][j])\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(!flag)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t\n\t\tcout << 202 << ' ' << 101*101 + 200 << endl;\n\t\t\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+1 << ' ' << i+2 << ' ' << 'X' << endl;\n\t\t}\n\t\t\n\t\tREP(i,100)\n\t\t{\n\t\t\tcout << i+102 << ' ' << i+103 << ' ' << 'X' << endl;\n\t\t}\n\t\t\n\t\tREP(i,101)\n\t\t{\n\t\t\tREP(j,101)\n\t\t\t{\n\t\t\t\tcout << 1+i << ' ' << 202-j << ' ' << dist[i][j] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << ' ' << 202 << endl;\n\t\t\n\t\treturn 0;\n\t}\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint a[15][15];\n\nint id[15][15];\n\ntypedef pair<int, int> pii;\n\nvector<pair<pii, int> > edges;\n\nint d[15][15];\n\nint A, B;\n\nint idX(int i){\n    return i + 1;\n}\n\nint idY(int i){\n    return 202 - i;\n}\n\nint c[105][105];\n\nint main(){\n    cin >> A >> B;\n    for(int i = 1;i <= A;i++){\n        for(int j = 1;j <= B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i = 0;i <= 100;i++){\n        for(int j = 0;j <= 100;j++){\n            int mx = 0;\n            for(int i1 = 1;i1 <= A;i1++){\n                for(int j1 = 1;j1 <= B;j1++){\n                    int len = i1 * i + j1 * j;\n                    mx = max(mx, d[i1][j1] - len);\n                }\n            }\n            c[i][j] = mx;\n        }\n    } \n    bool flag = true;\n    for(int i1 = 1;i1 <= A;i1++){\n        for(int j1 = 1;j1 <= B;j1++){\n            bool find = false;\n            for(int i = 0;i <= 100;i++){\n                for(int j = 0;j <= 100;j++){\n                    if(i * i1 + j * j1 + c[i][j] == d[i1][j1])\n                        find = true;\n                }\n            }\n            flag &= find;\n        }\n    }\n    if(flag){\n        puts(\"Possible\");\n        for(int i = 1;i <= 100;i++){\n            edges.push_back(make_pair(make_pair(i, i + 1), -2));\n        }\n        for(int i = 102;i <= 201;i++){\n            edges.push_back(make_pair(make_pair(i, i + 1), -1));\n        }\n        for(int i = 0;i <= 100;i++){\n            for(int j = 0;j <= 100;j++){\n                if(c[i][j] <= 100)\n                    edges.push_back(make_pair(make_pair(idX(i), idY(j)), c[i][j]));\n            }\n        }\n        cout << 202 << \" \" << edges.size() << endl;\n        for(auto e : edges){\n            pii p = e.first;\n            int val = e.second; \n            if(val == -2){\n                cout << p.first << \" \" << p.second << \" X\" << endl;\n            }else if(val == -1){\n                cout << p.first << \" \" << p.second << \" Y\" << endl;\n            }else{\n                cout << p.first << \" \" << p.second << \" \" << val << endl;\n            }\n        }\n        cout << 1 << \" \" << 202 << endl;\n    }else{\n        puts(\"Impossible\"); \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    int matrix[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++) cin >> matrix[i][j];\n    }\n    int mnx[a][b], mny[a][b], mxx[a][b], mxy[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            mnx[i][j] = 0;\n            mny[i][j] = 0;\n            mxx[i][j] = matrix[i][j] / (i+1);\n            mxy[i][j] = matrix[i][j] / (j+1);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b-1; j++){\n            int D = matrix[i][j+1] - matrix[i][j];\n            mny[i][j] = max(mny[i][j], D);\n            mxy[i][j] = min(mxy[i][j], D);\n        }\n    }\n    for (int i=0; i < a-1; i++){\n        for (int j=0; j < b; j++){\n            int D = matrix[i+1][j] - matrix[i][j];\n            mnx[i][j] = max(mnx[i][j], D);\n            mxx[i][j] = min(mxx[i][j], D);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            if (mnx[i][j] > mxx[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mny[i][j] > mxy[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mnx[i][j] * (i+1) + mny[i][j] * (j+1) > matrix[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    int sv = 3;\n    vector<pair<int, int> > reb;\n    vector<int> wh;\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            int K, L, res = 1e9;\n            for (int k=mnx[i][j]; k <= mxx[i][j]; k++){\n                for (int l=mny[i][j]; l <= mxy[i][j]; l++){\n                    int re = k * (i+1) + l * (j+1);\n                    if (re > matrix[i][j]) continue;\n                    int N = k+l+(re != matrix[i][j]);\n                    if (N < res){\n                        res = N;\n                        K = k;\n                        L = l;\n                    }\n                }\n            }\n            int last = 1;\n            for (int k=0; k < K; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-1);\n                last = sv;\n                sv++;\n            }\n            for (int k=0; k < L; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-2);\n                last = sv;\n                sv++;\n            }\n            reb.push_back(make_pair(last, 300));\n            wh.push_back(matrix[i][j] - K * (i+1) - L * (j+1));\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << reb.size() << endl;\n    for (int i=0; i < reb.size(); i++){\n        cout << reb[i].first << \" \" << reb[i].second << \" \";\n        if (wh[i] == -1) cout << \"X\" << endl;\n        else if (wh[i] == -2) cout << \"Y\" << endl;\n        else cout << wh[i] << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n\n// This solution is written after the author read the editorial.\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int a, b;\n  cin >> a >> b;\n  vector<VI> d(a, VI(b));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      cin >> d[i][j];\n    }\n  }\n  vector<VI> f(101, VI(101, 0));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      REP(v, 0, 101) {\n\tREP(w, 0, 101) {\n\t  f[v][w] = max(f[v][w], d[i][j] - (i + 1) * v - (j + 1) * w);\n\t}\n      }\n    }\n  }\n  vector<VI> nd(a, VI(b, 1e8));\n  REP(i, 0, a) {\n    REP(j, 0, b) {\n      REP(v, 0, 101) {\n\tREP(w, 0, 101) {\n\t  nd[i][j] = min(nd[i][j], f[v][w] + (i + 1) * v + (j + 1) * w);\n\t}\n      }\n    }\n  }\n  bool ok = true;\n  if (nd != d) {\n    ok = false;\n  }\n  if (ok) {\n    REP(i, 0, 101) {\n      REP(j, 0, 101) {\n\tif (f[i][j] < 0 || f[i][j] > 100) {\n\t  ok = false;\n\t}\n      }\n    }\n  }\n  if (ok) {\n    cout << \"Possible\\n\";\n    int n = 202;\n    int m = 101 * 101 + 2 * 100;\n    cout << n << \" \" << m << \"\\n\";\n    REP(i, 0, 100) {\n      cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    }\n    REP(i, 0, 100) {\n      cout << i + 103 << \" \" << i + 102 << \" Y\\n\";\n    }\n    REP(i, 0, 101) {\n      REP(j, 0, 101) {\n\tcout << i + 1 << \" \" << j + 101 << \" \" << f[i][j] << \"\\n\";\n      }\n    }\n    cout << 1 << \" \" << 102 << \"\\n\";\n  } else {\n    cout << \"Impossible\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\n\nvoid Set(int a, int b)\n{\n\tint d = D[a - 1][b - 1];\n\n\tint min_f = 999;\n\tint min_i;\n\tint min_j;\n\n\tfor (int i = 100; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tint f = d - ((i * b) + ((100 - j) * a));\n\t\t\tif (f == F[i][j])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (f >= 0 && F[i][j] > 100)\n\t\t\t{\n\t\t\t\tif (min_f > f)\n\t\t\t\t{\n\t\t\t\t\tmin_f = f;\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (min_f > 100)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\telse\n\t{\n\t\tF[min_i][min_j] = min_f;\n\t}\n}\n\nbool Check(int a,int b)\n{\n\tint d = D[a - 1][b - 1];\n\tint min = INT_MAX;\n\tREP(i, 101)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tint m = (i * b) + ((100 - j) * a) + F[i][j];\n\t\t\tmin = MIN(m, min);\n\t\t}\n\t}\n\tif (min == d)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\n\tREP(i, 101) REP(j, 101) F[i][j] = 1000;\n\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tSet(a + 1, b + 1);\n\t\t}\n\t}\n\n\tint m = 202;\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tif (!Check(a + 1, b + 1))\n\t\t\t{\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << m << endl;\n\t\n\tREP(i, 100)\n\t{\n\t\tcout << i << \" \" << (i + 1) << \" X\"  << endl;\n\t}\n\tREP(i, 100)\n\t{\n\t\tcout << (101 + i) << \" \" << (101 + i + 1) << \" Y\" << endl;\n\t}\n\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tcout << a << \" \" << (101 + b) << \" \" << F[a][b] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"0 201\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e2 + 2;\n\nset < pp > S;\nset < pp > :: iterator it; \nint A[11][11],M[N][N],m,n,i,j,k,l,kk,ll,x,mn;\n\nsigned main(){\n    cin >> m >> n;\n    for(i=1;i<=m;i++)\n        for(j=1;j<=n;j++){\n            cin >> x;\n            A[i][j] = x;\n            for(k=0;k<N;k++)\n                for(l=0;l<N;l++)\n                    M[k][l] = max(M[k][l] , x - i*k - j*l);\n        }\n    for(i=1;i<=m;i++)\n        for(j=1;j<=n;j++){\n            mn = mod;\n            for(k=0;k<N;k++)\n                for(l=0;l<N;l++)\n                    if(mn > (x = i*k + j*l + M[k][l])){\n                        mn = x;\n                        kk = k;\n                        ll = l;\n                    }\n        \n            if(mn != A[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n            S.insert(mp(kk,ll));\n        }\n        \n    puts(\"Possible\");\n    printf(\"%d %d\\n\", N+N, N+N-2+(int)S.size());\n    for(i=1;i<N;i++) printf(\"%d %d X\\n\", i, i+1);\n    for(i++;i<N+N;i++) printf(\"%d %d Y\\n\", i, i+1);\n    \n    for(it=S.begin();it!=S.end();it++)\n        printf(\"%d %d %d\\n\", it->st + 1, N+N - it->nd, M[it->st][it->nd]);\n    \n    printf(\"1 %d\\n\",N+N);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// X: -1, Y: -2\ntypedef pair<int,int> pint;\nint A, B;\nint d[21][21];\n\nint mid, s, t;\nvector<vector<pint> > G;\n\nint dp[55];\nbool check() {\n  for (int x = 1; x <= A; ++x) {\n\tfor (int y = 1; y <= B; ++y) {\n\t  for (int i = 0; i < 55; ++i) dp[i] = 1<<29;\n\t  dp[0] = 0;\n\t  for (int i = 0; i < G.size(); ++i) {\n\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t  int to = G[i][j].first;\n\t\t  int add = G[i][j].second;\n\t\t  if (add == -1) add = x;\n\t\t  else if (add == -2) add = y;\n\n\t\t  chmin(dp[to], dp[i] + add);\n\t\t}\n\t  }\n\t  //cout << x << \", \" << y << \": \" << dp[t] << endl;\n\t  if (dp[t] != d[x][y]) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\t   \n\nint main() {\n  while (cin >> A >> B) {\n\tmemset(d, 0, sizeof(d));\n\tfor (int i = 0; i < A; ++i) for (int j = 0; j < B; ++j) cin >> d[i+1][j+1];\n\n\tmid = 10;\n\ts = 0, t = mid*2;\n\n\tint V = mid*2+1;\n\tG.clear();\n\tG.resize(V);\n\tint E = 0;\n\tfor (int i = 0; i < mid; ++i) {\n\t  G[i].push_back(pint(i+1, -1));\n\t  G[mid+i].push_back(pint(mid+i+1, -2));\n\t}\n\n\tbool ok = true;\n\tG[s].push_back(pint(t, d[A][B]));\n\tfor (int i = 1; i <= A; ++i) {\n\t  for (int j = 1; j <= B; ++j) {\n\t\tif (!ok) break;\n\t\tint dx = -1, dy = -1, se = -1;\n\t\tbool finish = false;\n\t\tfor (int tdx = 0; tdx <= 100; ++tdx) {\n\t\t  for (int tdy = 0; tdy <= 100; ++tdy) {\n\t\t\tif (finish) break;\n\t\t\tint tse = d[i][j] - tdx * i - tdy * j;\n\t\t\tif (tse < 0) continue;\n\n\t\t\tbool tmp = true;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t  for (int j = 1; j <= B; ++j) {\n\t\t\t\tif (!tmp) break;\n\t\t\t\tint val = tdx * i + tdy * j + tse;\n\t\t\t\tif (val < d[i][j]) tmp = false;\n\t\t\t  }\n\t\t\t}\n\t\t\tif (tmp) {\n\t\t\t  dx = tdx, dy = tdy, se = tse;\n\t\t\t  finish = true;\n\t\t\t}\n\t\t  }\n\t\t}\n\n\t\tif (!finish) {\n\t\t  ok = false;\n\t\t  break;\n\t\t}\n\n\t\tG[dx].push_back(pint(t-dy, se));\n\t  }\n\t}\n\n\tif (!ok) {\n\t  puts(\"Impossible\");\n\t}\n\telse {\n\t  bool res = check();\n\t  if (res) {\n\t\tputs(\"Possible\");\n\n\t\tset<pair<int,pint> > S;\n\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t  for (auto e : G[i]) {\n\t\t\tS.insert(make_pair(i, e));\n\t\t  }\n\t\t}\n\t\t\n\t\tcout << G.size() << \" \" << S.size() << endl;\n\t\tfor (set<pair<int,pint> >::iterator it = S.begin(); it != S.end(); ++it) {\n\t\t  int from = (*it).first;\n\t\t  int to = (*it).second.first;\n\t\t  int w = (*it).second.second;\n\t\t  cout << from+1 << \" \" << to+1 << \" \";\n\t\t  if (w == -1) cout << \"X\";\n\t\t  else if (w == -2) cout << \"Y\";\n\t\t  else cout << w;\n\t\t  cout << endl;\n\t\t}\n\t\tcout << s+1 << \" \" << t+1 << endl;\n\t  }\n\t  else {\n\t\tputs(\"Impossible\");\n\t  }\n\t}\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nint d[11][11];\nint c[101][101];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint a,b;\n\tcin>>a>>b;\n\trep(i,1,a)\n\trep(j,1,b)cin>>d[i][j];\n\tint n=101+101;\n\trep(x,0,100)\n\trep(y,0,100)\n\t{\n\t\trep(i,1,a)\n\t\trep(j,1,b)chmax(c[x][y],d[i][j]-(i*x+j*y));\n\t}\n\trep(i,1,a)\n\trep(j,1,b)\n\t{\n\t\trep(x,0,100)\n\t\trep(y,0,100)\n\t\tif(i*x+j*y+c[x][y]==d[i][j])goto have;\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t\thave : ;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,101*101+100*2);\n\trep(x,1,100)printf(\"%d %d x\\n\",x-1,x);\n\trep(y,1,100)printf(\"%d %d y\\n\",n-y,n-y+1);\n\trep(x,0,100)\n\trep(y,0,100)printf(\"%d %d %d\\n\",1+x,n-y,c[x][y]);\n\tprintf(\"%d %d\\n\",1,n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint A, B;\n\tcin >> A >> B;\n\tvector<vector<int> >d(A + 1, vector<int>(B + 1, 0));\n\tvector<vector<int> >noneed(A + 1, vector<int>(B + 1, 0));\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool f;\n\tint mn = 100;\n\tint sc = 0;\n\tint xx, yy;\n\tint xmax = 0;\n\tbool ok = true;\n\tvector<pair<pair<int, int>, int> > vp;\n\tfor (int a = 1; a <= A; a++) {\n\t\tfor (int b = 1; b <= B; b++) {\n\t\t\tif (noneed[a][b] == 0) {\n\t\t\t\txx = -1;\n\t\t\t\tmn = 10000;\n\t\t\t\tfor (int x = 0; x <= 100; x++) {\n\t\t\t\t\tfor (int y = 0; y <= 100; y++) {\n\t\t\t\t\t\tint z = d[a][b] - x*a - y*b;\n\t\t\t\t\t\tif (z < 0)break;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\t\t\tif (d[a2][b2] > x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tsc = max(x, y);\n\t\t\t\t\t\t\tif (mn > sc) {\n\t\t\t\t\t\t\t\tmn = sc;\n\t\t\t\t\t\t\t\txx = x;\n\t\t\t\t\t\t\t\tyy = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (xx == -1) {\n\t\t\t\t\tcerr << a << \" \" << b << endl;\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\tif (d[a2][b2] == xx*a2 + yy*b2 + d[a][b] - xx*a - yy*b) {\n\t\t\t\t\t\t\tnoneed[a2][b2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txmax = max(xx, xmax);\n\t\t\t\tvp.push_back(make_pair(make_pair(xx, yy), d[a][b] - xx*a - yy*b));\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif (ok) {\n\t\tint v = 0;\n\t\tsort(vp.begin(), vp.end());\n\t\tvector<int> ymax(xmax + 1, -1);\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\tymax[vp[i].first.first] = max(ymax[vp[i].first.first], vp[i].first.second);\n\t\t\t//cerr << vp[i].first.first << \" \" << vp[i].first.second << \" \" << vp[i].second << endl;\n\t\t}\n\t\tmap<pair<int, int>, int> mp;\n\t\tvector<pair<pair<int, int>, int> >ed;\n\t\tmp[make_pair(0, 0)] = 0;\n\t\tfor (int i = 0; i < xmax; i++) {\n\t\t\tv++;\n\t\t\ted.push_back(make_pair(make_pair(v, v - 1), -1));\n\t\t\tmp[make_pair(v, 0)] = v;\n\t\t}\n\t\tfor (int i = 0; i <= xmax; i++) {\n\t\t\tfor (int j = 0; j < ymax[i]; j++) {\n\t\t\t\tv++;\n\t\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(i, j)], v), -2));\n\t\t\t\tmp[make_pair(i, j + 1)] = v;\n\t\t\t}\n\t\t}\n\t\tv++;\n\t\tint fc = v;\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(vp[i].first.first, vp[i].first.second)], fc), vp[i].second));\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\n\t\tcout << fc + 1 << \" \" << (int)ed.size() << endl;\n\t\tfor (int i = 0; i < ed.size(); i++) {\n\t\t\tcout << ed[i].first.first + 1 << \" \" << ed[i].first.second + 1 << \" \";\n\t\t\tif (ed[i].second == -1) {\n\t\t\t\tcout << \"X\" << endl;\n\t\t\t}\n\t\t\telse if (ed[i].second == -2) {\n\t\t\t\tcout << \"Y\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << ed[i].second << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << \" \" << fc + 1 << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i<r;i++)\n#define vi vector<int>\n#define all(v) v.begin(),v.end()\n#define pb(c) push_back(c)\n#define vii vector<pair<int,int>>\n#define ii pair<int,int>\n#define max(a, b) (((a)<(b))?b:a)\n#define min(a, b) ((a>b)?b:a)\n#define mp(i, j) make_pair(i,j)\n#define ull unsigned long long int\n#define ll  long long int\n#define pi 3.141592653589793238\n#define inf ((ll)1e18)\n#define eps 1e-14\n#define maxlg 18\n#define left(i) ((i)<<1)\n#define right(i) (((i)<<1)+1)\n#define maxn 2006\nint a,b;\nint d[20][20];\nint f[101][101];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#ifndef ONLINE_JUDGE\n    freopen(\"input\", \"r\", stdin);\n#endif\n    cin>>a>>b;\n    rep (i,0,a)\n        rep (j,0,b)\n            cin>>d[i+1][j+1];\n\n    rep (i,0,100+1)\n        rep (j,0,100+1)\n            rep (x,1,a+1)\n                rep (y,1,b+1) {\n                    f[i][j] = max(f[i][j],d[x][y]-i*x-j*y);\n                }\n\n    rep (x,1,a+1)\n        rep (y,1,b+1) {\n            int dist = 1e9;\n            rep (i,0,100+1)\n                rep (j,0,100+1) {\n                    dist= min(dist,f[i][j]+i*x +j*y);\n                }\n            if (dist!=d[x][y]){\n                cout<<\"Impossible\";\n                return 0;\n            }\n        }\n    cout<<\"Possible\\n\";\n    vector<string>  ans;\n    rep (i,1,102) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" X\\n\");\n        rep (j,102,203) {\n            ans.push_back(to_string(i)+ \" \"+to_string(j)+\" \"+ to_string(f[i-1][202-j])+\"\\n\");\n\n        }\n    }\n    rep (i,102,203) {\n        ans.push_back(to_string(i)+ \" \"+to_string(i+1)+ \" Y\\n\");\n    }\n    cout<<202<<\" \"<<ans.size()<<endl;\n    rep (i,0,ans.size()) {\n        cout<<ans[i];\n    }\n    return 0;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=105;\nint a,b,f[N][N],d[N][N],s[N][N];\nint main()\n{\n    scanf(\"%d%d\",&a,&b);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        scanf(\"%d\",&d[x][y]);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        f[i][j]=max(f[i][j],d[x][y]-(i-1)*x-(101-j)*y);\n    memset(s,inf,sizeof(s));\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n            for(int x=1;x<=a;x++)\n            for(int y=1;y<=b;y++)\n            s[x][y]=min(s[x][y],f[i][j]+(i-1)*x+(101-j)*y);\n    for(int x=1;x<=a;x++)\n        for(int y=1;y<=b;y++)\n        if(d[x][y]!=s[x][y])\n    {\n        printf(\"Impossible\\n\");\n        return 0;\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\",100+100+101*101);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d X\\n\",i,i+1);\n    for(int i=1;i<101;i++)\n        printf(\"%d %d Y\\n\",101+i,101+i+1);\n    for(int i=1;i<=101;i++)\n        for(int j=1;j<=101;j++)\n        printf(\"%d %d %d\\n\",i,j+101,f[i][j]);\n    printf(\"%d %d\\n\",1,202);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll A, B;\n    cin >> A >> B;\n    vector<vector<ll>> d(A + 1, vector<ll>(B + 1));\n    for (ll i = 1; i <= A; i++) {\n        for (ll j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    constexpr ll MAX = 100;\n    vector<vector<ll>> f(MAX + 1, vector<ll>(MAX + 1, 0));\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            for (ll x = 1; x <= A; x++) {\n                for (ll y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n\n    for (ll x = 1; x <= A; x++) {\n        for (ll y = 1; y <= B; y++) {\n            ll D = LLONG_MAX;\n            for (ll a = 0; a <= MAX; a++) {\n                for (ll b = 0; b <= MAX; b++) {\n                    D = min(D, x * a + y * b + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    const ll N = (MAX + 1) * 2;\n    const ll M = MAX * (MAX + 2) + MAX + 1;\n    cout << N << \" \" << M << endl;\n    for (ll i = 0; i < N - 1; i++) {\n        if (i <= MAX) {\n            //次に辺を張る\n            if (i < MAX) {\n                cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n            }\n            //下側へ辺を張る\n            for (ll j = 0; j <= MAX; j++) {\n                cout << i + 1 << \" \" << j + MAX + 2 << \" \" << f[i][j] << endl;\n            }\n        } else {\n            //次に辺を張る\n            cout << i + 1 << \" \" << i + 2 << \" Y\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x_max;\n  int y_max;\n  cin >> x_max >> y_max;\n\n  auto d_matrix = Make2DVector(x_max + 1, y_max + 1, 0);\n  for (int x = 1; x <= x_max; x++) {\n    for (int y = 1; y <= y_max; y++) {\n      cin >> d_matrix[x][y];\n    }\n  }\n\n  auto c_matrix = Make2DVector(100 + 1, 100 + 1, 0);\n  for (int a = 0; a <= 100; a++) {\n    for (int b = 0; b <= 100; b++) {\n      for (int x = 1; x <= x_max; x++) {\n        for (int y = 1; y <= y_max; y++) {\n          UpdateMax(c_matrix[a][b], d_matrix[x][y] - a * x - b * y);\n        }\n      }\n    }\n  }\n\n  auto check_fn = [&]() -> bool {\n    for (int x = 1; x <= x_max; x++) {\n      for (int y = 1; y <= y_max; y++) {\n        int d = INT32_MAX;\n        for (int a = 0; a <= 100; a++) {\n          for (int b = 0; b <= 100; b++) {\n            UpdateMin(d, a * x + b * y + c_matrix[a][b]);\n          }\n        }\n        // cout << d << endl;\n        if (d > d_matrix[x][y]) return false;\n      }\n    }\n    return true;\n  };\n\n  if (!check_fn()) {\n    cout << \"Impossible\" << endl;\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 100 + 100 + 101 * 101 << endl;\n  for (int i = 0; i <= 100; i++) {\n    cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n  }\n  for (int i = 0; i <= 100; i++) {\n    cout << 101 + i << \" \" << 101 + i + 1 << \" \" << \"Y\" << endl;\n  }\n  for (int a = 0; a <= 100; a++) {\n    for(int b = 0; b <= 100; b++) {\n      cout << 1 + a << \" \" << 202 - b << \" \" << c_matrix[a][b] << endl;\n    }\n  }\n  cout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define M 505\n#define MAXN 149\n#define INF 1000000000\nusing namespace std;\nint n,m,f[M][M],g[M][M],S,T;\nint read(){\n\tchar c=getchar();int ans=0;\n    while (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans;\n}\nint max(int x,int y){return x>y?x:y;}\nint min(int x,int y){return x<y?x:y;}\nint main(){\n\tn=read(),m=read();\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++) f[i][j]=read();\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tfor (register int k=1;k<=n;k++)\n\t\t\t\tfor (register int l=1;l<=m;l++)\n\t\t\t\t\tg[i][j]=max(g[i][j],f[k][l]-k*i-l*j);\n\tfor (register int i=1;i<=n;i++)\n\t\tfor (register int j=1;j<=m;j++){\n\t\t\tint now=INF;\n\t\t\tfor (register int k=0;k<=MAXN;k++)\n\t\t\t\tfor (register int l=0;l<=MAXN;l++)\n\t\t\t\t\tnow=min(now,k*i+l*j+g[k][l]);\n\t\t\tif (now!=f[i][j]){printf(\"Impossible\");return 0;}\n\t\t}\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tif (g[i][j]>100){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n%d %d\\n\",MAXN+MAXN+1,(MAXN+1)*(MAXN+1)+2*MAXN);\n\tS=1,T=MAXN+MAXN+1;\n\tfor (register int i=1;i<=MAXN;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (register int i=MAXN+1;i<=MAXN+MAXN;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor (register int i=0;i<=MAXN;i++)\n\t\tfor (register int j=0;j<=MAXN;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,MAXN+MAXN-j,g[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXSIZE=10000020;\nint bufpos;\nchar buf[MAXSIZE];\n#define NEG 0\nvoid init(){\n    #ifdef LOCAL\n        freopen(\"E.txt\",\"r\",stdin);\n    #endif\n    buf[fread(buf,1,MAXSIZE,stdin)]='\\0';\n    bufpos=0;\n}\n#if NEG\nint readint(){\n    bool isneg;\n    int val=0;\n    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);\n    bufpos+=(isneg=buf[bufpos]=='-');\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return isneg?-val:val;\n}\n#else\nint readint(){\n    int val=0;\n    for(;!isdigit(buf[bufpos]);bufpos++);\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return val;\n}\n#endif\nchar readchar(){\n    for(;isspace(buf[bufpos]);bufpos++);\n    return buf[bufpos++];\n}\nint readstr(char* s){\n    int cur=0;\n    for(;isspace(buf[bufpos]);bufpos++);\n    for(;!isspace(buf[bufpos]);bufpos++)\n        s[cur++]=buf[bufpos];\n    s[cur]='\\0';\n    return cur;\n}\nint d[13][13];\nstruct edge{\n    int x,y,z;\n}e[2333];\nbool vis[103][103];\nint main(){\n    init();\n    int a=readint(),b=readint(),cur=0;\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            d[i][j]=readint();\n    // memset(vis,-1,sizeof(vis));\n    for(int i=0;i<=100;i++)\n        for(int j=0;j<=100;j++)\n            for(int k=0;k<=100;k++){\n                bool flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++){\n                        if (i*o+j*t+k<d[o][t]){\n                            flag=1;\n                            goto hell;\n                        }\n                    }\n                hell:;\n                if (flag)\n                    continue;\n                flag=0;\n                for(int o=1;o<=a;o++)\n                    for(int t=1;t<=b;t++)\n                        if (!vis[o][t] && i*o+j*t+k==d[o][t])\n                            vis[o][t]=flag=1;\n                if (flag)\n                    e[++cur]=(edge){i,j,k};\n            }\n    // puts(\"WTF\");\n    for(int i=1;i<=a;i++)\n        for(int j=1;j<=b;j++)\n            if (!vis[i][j])\n                return puts(\"Impossible\"),0;\n    puts(\"Possible\");\n    printf(\"%d %d\\n\",202,cur+200);\n    for(int i=0;i<100;i++)\n        printf(\"%d %d X\\n\",i+1,i+2);\n    for(int j=1;j<=100;j++)\n        printf(\"%d %d Y\\n\",j+102,j+101);\n    for(int i=1;i<=cur;i++)\n        printf(\"%d %d %d\\n\",e[i].x+1,e[i].y+102,e[i].z);\n    puts(\"1 102\");\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<utility>\n#include<bitset>\n#include<complex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define REP(i,a,b) for(int i=a; i<=b; ++i)\n#define FOR(i,a,b) for(int i=a; i<b; ++i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 100;\n\nint A, B, dis[12][12];\nint D[maxn + 5][maxn + 5];\n\nint main() {\n    scanf(\"%d%d\", &A, &B);\n    REP(i,1,A) REP(k,1,B) scanf(\"%d\", &dis[i][k]);\n    for(int a = 0; a <= 100; ++a)\n        for(int b = 0; b <= 100; ++b) {\n            REP(i,1,A) REP(k,1,B)\n                D[a][b] = max(D[a][b], dis[i][k] - a*i - b*k);\n        }\n    for(int i = 1; i <= A; ++i)\n        for(int k = 1; k <= B; ++k) {\n            int d = 1 << 30;\n            REP(a,0,100) REP(b,0,100)\n                d = min(d, D[a][b] + a*i + b*k);\n            if(d != dis[i][k]) exit(0 * puts(\"Impossible\"));\n        }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 101*101 + 100*2);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d X\\n\", i, i+1);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d Y\\n\", i+101, i+1+101);\n    for(int i = 0; i <= 100; ++i)\n        for(int k = 0; k <= 100; ++k)\n            printf(\"%d %d %d\\n\", i+1, 101-k + 101, D[i][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int oo = 1e9;\nconst int MOD = 1000000007;\nconst int BASE = 26;\nconst int N = 200011;\n\n#define pb push_back\n#define mp make_pair\n\nint f[110][110], d[11][11], A, B, cnt = 1, S, T, fx[110], fy[110];\nvector< pair<int, pii> > E;\nvoid addEdge(int u , int v , int w) {\n\tE.pb(mp(w, mp(u, v)));\n}\nint main() {\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B ; ++j) {\n\t\t\tscanf(\"%d\", &d[i][j]);\n\t\t}\n\t}\n\tfor (int x = 0 ; x <= 100 ; x++) {\n\t\tfor (int y = 0 ; y <= 100 ; y++) {\n\t\t\tf[x][y] = -oo;\n\t\t\tfor (int i = 1; i <= A; ++i) {\n\t\t\t\tfor (int j = 1; j <= B ; ++j) {\n\t\t\t\t\tf[x][y] = max(f[x][y], d[i][j] - i * x - j * y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B ; ++j) {\n\t\t\tint mn = 1e9;\n\t\t\tfor (int x = 0 ; x <= 100 ; x++) {\n\t\t\t\tfor (int y = 0 ; y <= 100 ; y++) {\n\t\t\t\t\tif (f[x][y] < 0)continue;\n\t\t\t\t\tmn = min(mn, f[x][y] + x * i + y * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mn != d[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0 ; i <= 100 ; ++i) {\n\t\tfx[i] = cnt++;\n\t\tif (i > 0)\n\t\t\taddEdge(fx[i - 1], fx[i], -1);\t\n\t}\n\tfor (int i = 0 ; i <= 100 ; ++i) {\n\t\tfy[i] = cnt++;\n\t\tif (i > 0)\n\t\t\taddEdge(fy[i - 1], fy[i], -2);\n\t}\t\t\t\n\tfor (int x = 0 ; x <= 100 ; x++) {\n\t\tfor (int y = 0 ; y <= 100 ; y++) {\n\t\t\tif (f[x][y] < 0)continue;\n\t\t\taddEdge(fx[x],fy[100-y],f[x][y]);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", cnt - 1, (int)E.size() );\n\tfor (int i = 0; i < E.size(); ++i){\n\t\tif(E[i].first == -1){\n\t\t\tprintf(\"%d %d %c\\n\",E[i].second.first,E[i].second.second,'X');\n\t\t}else if(E[i].first == -2){\n\t\t\tprintf(\"%d %d %c\\n\",E[i].second.first,E[i].second.second,'Y');\n\t\t}else{\n\t\t\tprintf(\"%d %d %d\\n\",E[i].second.first,E[i].second.second,E[i].first );\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",fx[0],fy[100]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nconst int maxn = 303, M = 5;\nint a, b, d[14][14], C[M+3][M+3], sz = 1;\nsigned main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> a >> b;\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++)\n\t\t\tcin >> d[i][j];\n\tfor(int as = 0; as <= M; as++) {\n\t\tfor(int bs = 0; bs <= M; bs++) {\n\t\t\tint mn = 0;\n\t\t\tfor(int i =1; i <= a; i++)\n\t\t\t\tfor(int j = 1; j <= b; j++)\n\t\t\t\t\tmn = max(mn, d[i][j] - as*i - bs*j);\n\t\t\tC[as][bs] = mn;\n\t\t}\n\t}\n\tfor(int i = 1; i <= a; i++)\n\t\tfor(int j = 1; j <= b; j++) {\n\t\t\tint cst = 1<<30;\n\t\t\tfor(int as = 0; as <= M; as++)\n\t\t\t\tfor(int bs = 0; bs <= M; bs++)\n\t\t\t\t\tcst = min(cst, as*i + bs*j + C[as][bs]);\n\t\t\tif(cst != d[i][j]) return cout << \"Impossible\\n\", 0;\n\t\t}\n\t\n\tcout << \"Possible\\n\";\n\tcout << 2*M+2 << \" \" << (M+1)*(M+1) + 2*M << '\\n';\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" X\\n\", sz++;\n\tsz++;\n\tfor(int i = 1; i <= M; i++)\n\t\tcout << sz << \" \" << sz+1 << \" Y\\n\", sz++;\n\tfor(int i = 0; i <= M; i++)\n\t\tfor(int j = 0; j <= M; j++)\n\t\t\tcout << 1+i << \" \" << M+2+j << \" \" << C[i][j] << '\\n';\n\tcout << 1 << \" \" << 2*M+2 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ll long long\nconst int INF = 1000 * 1000 * 1000;\nconst ll LINF = (ll)INF * INF;\nint A , B;\nint d[11][11];\nint f[101][101];\nint dist[202];\n\nint main()\n{\n\t//freopen(\"input.txt\" , \"r\" , stdin);\n\t//freopen(\"output.txt\" , \"w\" , stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i <= A; i++)\n\t\tfor(int j = 1; j <= B; j++)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\tfor(int a = 0; a <= 100; a++)\n\t\tfor(int b = 0; b <= 100; b++)\n\t\t{\n\t\t\tfor(int x = 1; x <= A; x++)\n\t\t\t\tfor(int y = 1; y <= B; y++)\n\t\t\t\t{\n\t\t\t\t\tf[a][b] = max(f[a][b] , d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t}\n\tbool good = true;\n\tfor(int x = 1; x <= A; x++)\n\t\tfor(int y = 1; y <= B; y++)\n\t\t{\n\t\t\tfor(int i = 0; i < 202; i++)\n\t\t\t\tdist[i] = INF;\n\t\t\tfor(int i = 0; i <= 100; i++)\n\t\t\t\tdist[i] = x * i;\n\t\t\tfor(int i = 100; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif(i != 100)\n\t\t\t\t\tdist[i + 101] = dist[i + 1 + 101] + y;\n\t\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t\t\tdist[i + 101] = min(dist[i + 101] , f[j][i] + dist[j]);\n\t\t\t}\n\t\t\tif(dist[101] != d[x][y])\n\t\t\t\tgood = false;\n\t\t}\n\n\tif(good)\n\t{\n\t\tprintf(\"Possible\\n\");\n\t\tint n = 202;\n\t\tprintf(\"%d %d\\n\" , n ,  (n - 2) + n * n / 4);\n\t\tfor(int i = 1; i <= 100; i++)\n\t\t{\n\t\t\tprintf(\"%d %d X\\n\" , i - 1 , i);\n\t\t\tprintf(\"%d %d Y\\n\" , i + 101 , i + 101 - 1);\n\t\t}\n\t\tfor(int i = 0; i <= 100; i++)\n\t\t{\n\t\t\tfor(int j = 0; j <= 100; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d %d\\n\" , i , j + 101 , f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tprintf(\"Impossible\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 300, link = 101, inf = ~0U >> 2;\n\nint a, b, d[11][11], d2[11][11];\nint n, m, x[link + 1], y[link + 1];\npair<pair<int, int>, int> edge[1000000];\n\nvoid AddEdge(int u, int v, int c) {\n  edge[m++] = {{u, v}, c};\n}\n\nint main(void) {\n  scanf(\"%d%d\", &a, &b);\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      scanf(\"%d\", d[i] + j);\n    }\n  }\n  n = 2;\n  x[0] = 0;\n  for (int i = 1; i <= link; ++i) {\n    x[i] = n++;\n    AddEdge(x[i - 1], x[i], -1);\n  }\n  y[0] = 1;\n  for (int i = 1; i <= link; ++i) {\n    y[i] = n++;\n    AddEdge(y[i], y[i - 1], -2);\n  }\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      d2[i][j] = inf;\n    }\n  }\n  for (int dx = 0; dx <= link; ++dx) {\n    for (int dy = 0; dy <= link; ++dy) {\n      int delta = -inf;\n      for (int i = 1; i <= a; ++i) {\n        for (int j = 1; j <= b; ++j) {\n          delta = max(delta, d[i][j] - dx * i - dy * j);\n        }\n      }\n      if (delta >= 0 && delta <= 100) {\n        AddEdge(x[dx], y[dy], delta);\n        for (int i = 1; i <= a; ++i) {\n          for (int j = 1; j <= b; ++j) {\n            d2[i][j] = min(d2[i][j], dx * i + dy * j + delta);\n          }\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= a; ++i) {\n    for (int j = 1; j <= b; ++j) {\n      if (d2[i][j] != d[i][j]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", edge[i].first.first + 1, edge[i].first.second + 1);\n    if (edge[i].second == -1) {\n      puts(\"X\");\n    } else if (edge[i].second == -2) {\n      puts(\"Y\");\n    } else {\n      printf(\"%d\\n\", edge[i].second);\n    }\n  }\n  puts(\"1 2\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\tvector<vector<ll>> d(A+1, vector<ll>(B+1));\n\tfor (int i = 1;i <= A;i++)\n\t\tfor (int j = 1;j <= B;j++)\n\t\t\tcin >> d[i][j];\n\tvector<vector<ll>> e(101, vector<ll>(101, 0));\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++)\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\te[ua][ub] = max(e[ua][ub], d[a][b] - (a * ua + b * ub));\n\tbool ok = true;\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++) {\n\t\t\tbool nowok = false;\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\tif (e[ua][ub] + a * ua + b * ub == d[a][b])\n\t\t\t\t\t\tnowok = true;\n\t\t\tok &= nowok;\n\t\t}\n\tif (!ok)\n\t\tcout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << \"202 \" << 101 * 101 + 100 + 100 << endl;\n\t\tfor (int i = 1;i <= 101;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t\tfor (int i = 102;i <= 202;i++)\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"Y\" << endl;\n\t\tfor (int ua = 0;ua <= 100;ua++)\n\t\t\tfor (int ub = 0;ub <= 100;ub++)\n\t\t\t\tcout << ua + 1 << \" \" << 202 - ub << \" \" << min(100LL, e[ua][ub]) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nint low[123][123],req[12][12];\nint main(){\n    std::ios::sync_with_stdio(false);\n    int a,b;\n    cin>>a>>b;\n    int i,j;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tcin>>req[i][j];\n    \t}\n    }\n    rep(i,101){\n    \trep(j,101){\n    \t\tlow[i][j]=0;\n    \t}\n    }\n    int val,p,q;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q;\n    \t\t\t\tif(req[i][j]>val){\n    \t\t\t\t\tlow[p][q]=max(low[p][q],req[i][j]-val);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    int flag;\n    f(i,1,a+1){\n    \tf(j,1,b+1){\n    \t\tflag=0;\n    \t\trep(p,101){\n    \t\t\trep(q,101){\n    \t\t\t\tval=i*p+j*q+low[p][q];\n    \t\t\t\tif(val==req[i][j])\n    \t\t\t\t\tflag=1;\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t\tif(flag==0){\n    \t\t\tcout<<\"Impossible\"<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t}\n    }\n    int edg=0;\n    cout<<\"Possible\"<<endl;\n    cout<<202<<\" \"<<10401<<endl;\n    cout<<201<<\" \"<<1<<\" X\"<<endl;\n    edg++;\n    f(i,1,100){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" X\"<<endl;\n    }\n    edg++;\n    cout<<200<<\" \"<<202<<\" Y\"<<endl;\n    f(i,101,200){\n    \tedg++;\n    \tcout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n    }\n    f(i,1,101){\n    \tf(j,1,101){\n    \t\tedg++;\n    \t\tcout<<i<<\" \"<<200-j+1<<\" \"<<low[i][j]<<endl;\n    \t}\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<201<<\" \"<<200-i+1<<\" \"<<low[0][i]<<endl;\n    }\n    f(i,1,101){\n    \tedg++;\n    \tcout<<i<<\" \"<<202<<\" \"<<low[i][0]<<endl;\n    }\n    edg++;\n    cout<<201<<\" \"<<202<<\" \"<<low[0][0]<<endl;\n    //cout<<edg<<endl;\n\n\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nint A , B , d[20][20] , mn[20][20];\n\nint main(){\n  cin >> A >> B;\n  rep(i,1,A+1) rep(j,1,B+1)\n    cin >> d[i][j];\n  rep(i,1,A+1) rep(j,1,B+1)\n    mn[i][j] = d[i][j] + 1;\n  vi X , Y;\n  int _ = 0;\n  rep(i,0,101) X.pb(++_) , Y.pb(++_);\n  vector<pair<pii,int> > edge;\n  rep(i,1,sz(X)) edge.pb(mp(mp(X[i - 1] , X[i]) , -1));\n  rep(i,1,sz(Y)) edge.pb(mp(mp(Y[i] , Y[i - 1]) , -2));\n  rep(i,0,sz(X)) rep(j,0,sz(Y)) {\n    int add = 0;\n    rep(x,1,A+1) rep(y,1,B+1) {\n      int cost = i * x + j * y;\n      if(cost < d[x][y])\n        add = max(add , d[x][y] - cost);\n    }\n    edge.pb(mp(mp(X[i] , Y[j]) , add));\n    rep(x,1,A+1) rep(y,1,B+1) {\n      mn[x][y] = min(mn[x][y] , i * x + j * y + add);\n    }\n  }\n  bool ok = true;\n  rep(i,1,A+1) rep(j,1,B+1) ok &= mn[i][j] == d[i][j];\n  if(!ok) cout << \"Impossible\" << endl;\n  else {\n    cout << \"Possible\" << endl;\n    cout << sz(X) + sz(Y) << \" \" << sz(edge) << endl;\n    for(auto e : edge) {\n      cout << e.fi.fi << \" \" << e.fi.se << \" \";\n      if(e.se == -1) cout << \"X\" << endl;\n      else if(e.se == -2) cout << \"Y\" << endl;\n      else cout << e.se << endl;\n    }\n    cout << X[0] << \" \" << Y[0] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst double pi = acos(-1.0);\nconst double EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nstruct edge{\n    int u, v, c;\n    edge(int u, int v, int c) : u(u), v(v), c(c) {}\n};\n\nint main(){\n    int A, B;\n    cin >> A >> B;\n    int d[A][B];\n    rep(i, A){\n        rep(j, B) cin >> d[i][j];\n    }\n    int N = 202, s = 1, t = 202;\n    vector<edge> es;\n    rep2(i, 1, 100){\n        es.eb(i, i+1, -1), es.eb(202-i, 203-i, -2);\n    }\n    bool flag[A][B];\n    memset(flag, false, sizeof flag);\n    rep2(a, 0, 100){\n        rep2(b, 0, 100){\n            int M = -inf;\n            rep(i, A){\n                rep(j, B) chmax(M, d[i][j]-(a*(i+1)+b*(j+1)));\n            }\n            if(M >= 0){\n                es.eb(a+1, 202-b, M);\n                rep(i, A){\n                    rep(j, B){\n                        if(d[i][j]-(a*(i+1)+b*(j+1)) == M) flag[i][j] = true;\n                    }\n                }\n            }\n        }\n    }\n    rep(i, A){\n        rep(j, B){\n            if(!flag[i][j]) {cout << \"Impossible\" << endl; return 0;}\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << N << ' '<< sz(es) << endl;\n    for(auto &e: es){\n        cout << e.u << ' ' << e.v << ' ';\n        if(e.c < 0){\n            cout << (e.c == -1? \"X\" : \"Y\") << endl;\n        }\n        else cout << e.c << endl;\n    }\n    cout << s << ' ' << t << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[100][100];\nint a,b,c[100][100],flag[100][100];\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");cout<<300<<' '<<200+a*b<<endl;\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)cout<<f[i][j].x<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nchar buf[1<<21], *p1, *p2;\n#define getc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin)), p1 == p2 ? EOF : *p1++)\n#define lint long long\n#define isnum(x) ('0' <= (x) && (x) <= '9')\ntemplate<typename tint>\ninline void readint(tint& x) {\n\tint f = 1; char ch = getc(); x = 0;\n\tfor(; !isnum(ch); ch = getc()) if(ch == '-') f = -1;\n\tfor(; isnum(ch); ch = getc()) x = x * 10 + ch - '0';\n\tx *= f;\n}\nusing namespace std;\nconst int maxa = 12;\nconst int maxn = 204;\n\n// dist[x][y] = min{i * x + j * y + f[i][j]}\n// dist[x][y] - i * x - j * y <= f[i][j]\n// f[i][j] = max{dist[x][y] - i * x - j * y}\n\n// f[i][j] = max{dist[x][y] - i * x - j * y}\n\nint n = 202, m = 100;\nint A, B;\nint dist[maxa][maxa], f[maxn][maxn];\nint edge[maxn][maxn];\nint now[maxn];\nbool vis[maxn];\n\nint main() {\n\tmemset(f, -1, sizeof(f)), memset(edge, -1, sizeof(edge));\n\treadint(A), readint(B);\n\tfor(int i=1; i<=A; i++) {\n\t\tfor(int j=1; j<=B; j++) readint(dist[i][j]);\n\t}\n\n\tint cnt = 0;\n\tfor(int i=0; i<=m; i++) {\n\t\tfor(int j=0; j<=m; j++) {\n\t\t\tfor(int x=1; x<=A; x++) {\n\t\t\t\tfor(int y=1; y<=B; y++) {\n\t\t\t\t\tf[i][j] = max(f[i][j], dist[x][y] - i * x - j * y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// i个x, j个y的最短路\n\t\t\tedge[i + 1][202 - j] = f[i][j];\n\t\t\tif(edge[i + 1][202 - j] != -1) cnt++;\n\t\t}\n\t}\n\n\n\tfor(int a=1; a<=A; a++) {\n\t\tfor(int b=1; b<=B; b++) {\n\t\t\tfor(int i=1; i<=100; i++) edge[i][i+1] = a;\n\t\t\tfor(int i=102; i<=201; i++) edge[i][i+1] = b;\n\t\t\tmemset(vis, 0, sizeof(vis)), memset(now, 0x3f, sizeof(now));\n\t\t\tnow[1] = 0;\n\t\t\twhile(true) {\n\t\t\t\tint x = 0;\n\t\t\t\tfor(int i=1; i<=n; i++) if(!vis[i] && now[i] < now[x]) x = i;\n\t\t\t\tif(x == 0) break;\n\t\t\t\tvis[x] = 1;\n\t\t\t\tfor(int y=1; y<=n; y++)\n\t\t\t\t\tif(edge[x][y] != -1 && now[y] > now[x] + edge[x][y]) now[y] = now[x] + edge[x][y];\n\t\t\t}\n\t\t\tif(now[n] != dist[a][b]) { puts(\"Impossible\"); return 0; }\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\", n, cnt + 200);\n\tfor(int i=1; i<=100; i++) printf(\"%d %d X\\n\", i, i+1);\n\tfor(int i=102; i<=201; i++) printf(\"%d %d Y\\n\", i, i+1);\n\tfor(int i=0; i<=m; i++) {\n\t\tfor(int j=0; j<=m; j++) {\n\t\t\tif(f[i][j] == -1) continue;\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\t\t}\n\t}\n\t// [1, 101] [102, 202]\n\t//\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n\n// Y\n// X + 1\n// X + X\n// 3\n\n// x = 2, y = 3\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1001][1001];\nint f[1001][1001];\nsigned main()\n{\n\tint a,b;\n\tconst int n=100;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=1;i<=a;i++)\n\t\tfor(int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int x=1;x<=a;x++)\n\t\t\t\tfor(int y=1;y<=b;y++)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\n\tfor(int x=1;x<=a;x++)\n\t\tfor(int y=1;y<=b;y++)\n\t\t{\n\t\t\tint val=999999999;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tval=min(val,f[i][j]+i*x+j*y);\n\t\t\tif(val!=d[x][y])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\t\n\tprintf(\"Possible\\n\");\n\t\n\tprintf(\"201 10401\\n\");\n\t\n\tfor(int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\n\tfor(int i=101;i<=200;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,201-j,f[i][j]);\n\tprintf(\"1 201\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> d(A+1, vector<int>(B+1));\n    for(int i=1; i<=A; i++)\n        for(int j=1; j<=B; j++)\n            cin >> d[i][j];\n    vector<vector<int>> f(101, vector<int>(101, 0));\n    for(int a=0; a<=100; a++)\n        for(int b=0; b<=100; b++)\n            for(int x=1; x<=A; x++)\n                for(int y=1; y<=B; y++)\n                    f[a][b] = max(f[a][b], d[x][y]-a*x-b*y);\n\n    for(int x=1; x<=A; x++)\n        for(int y=1; y<=B; y++){\n            int tmp = 1<<30;\n            for(int a=0; a<=100; a++)\n                for(int b=0; b<=100; b++)\n                    tmp = min(tmp, f[a][b]+a*x+b*y);\n            if(tmp != d[x][y]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n\n    cout << \"Possible\" << endl;\n    int N = 202;\n    int M = 200 + 101*101;\n    vector<tuple<int, int, int>> edges;\n    for(int i=0; i<100; i++)\n        edges.push_back(make_tuple(i, i+1, -1));\n    for(int i=101; i<201; i++)\n        edges.push_back(make_tuple(i, i+1, -2));\n    for(int i=0; i<=100; i++)\n        for(int j=0; j<=100; j++)\n            edges.push_back(make_tuple(i, 201-j, f[i][j]));\n    cout << N << \" \" << M << endl;\n    for(auto e : edges){\n        int u, v, c;\n        tie(u, v, c) = e;\n        cout << u+1 << \" \" << v+1 << \" \";\n        if(c == -1) cout << \"X\" << endl;\n        else if(c == -2) cout << \"Y\" << endl;\n        else cout << c << endl;\n    }\n    cout << 1 << \" \" << N << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0 && c <= 100)C[a][b] = min(C[a][b], c);\n        }\n    }\n    if (A == 1){\n        for(int y=1;y<B;y++){\n            int b = d[1][y+1] - d[1][y];\n            int c = d[1][y] - b*y;\n            if (b >= 0 && c >= 0 && c <= 100)C[0][b] = min(C[0][b],c);\n        }\n    }\n    if (B == 1){\n        for(int x=1;x<A;x++){\n            int a = d[x+1][1] - d[x][1];\n            int c = d[x][1] - a*x;\n            if (a >= 0 && c >= 0 && c <= 100)C[a][0] = min(C[a][0],c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*d[x][y]=min{f[i][j]+i*x+j*y\n  f[x][y]=max{d[i][j]-i*x-j*y*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read() {\n\tint x(0),neg(1);char ch(getchar());\n\twhile(!isdigit(ch)) {\n\t\tif (ch=='-') neg=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) {\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*neg;\n}\nconst int maxn=300;\nint f[maxn+5][maxn+5],d[maxn+5][maxn+5];\nsigned main() {\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n(read()),m(read());\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=1;j<=m;++j) {\n\t\t\td[i][j]=read(); \n\t\t}\n\t}\n\tfor (int x=0;x<=100;++x) {\n\t\tfor (int y=0;y<=100;++y) {\n\t\t\tfor (int i=1;i<=n;++i) {\n\t\t\t\tfor (int j=1;j<=m;++j) {\n\t\t\t\t\tf[x][y]=max(f[x][y],d[i][j]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint minv;\n\tfor (int x=1;x<=n;++x) {\n\t\tfor (int y=1;y<=m;++y) {\n\t\t\tminv=2147483647;\n\t\t\tfor (int i=0;i<=100;++i) {\n\t\t\t\tfor (int j=0;j<=100;++j) {\n\t\t\t\t\tminv=min(minv,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (minv!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor (int i=1;i<=100;++i) {\n\t\tprintf(\"%lld %lld X\\n\",i,i+1);\n\t}\n\tfor (int j=102;j<=201;++j) {\n\t\tprintf(\"%lld %lld Y\\n\",j,j+1);\n\t}\n\tfor (int i=0;i<=100;++i) {\n\t\tfor (int j=0;j<=100;++j) {\n\t\t\tprintf(\"%lld %lld %lld\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      vector<Int> dp1(100,INF),dp2(100,INF);\n      for(Int k=100-1;k>=0;k--){\n\tdp1[k]=C[k];\n\tdp2[k]=D[k];\n\tif(k+1<100){\n\t  chmin(dp1[k],dp1[k+1]);\n\t  chmin(dp2[k],dp2[k+1]);\n\t}\n      }\n      for(Int k=0;k<100;k++){\n\tfor(Int l=0;l<100;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*(k+1)+dp2[l]));\n\t  chmax(F[k][l],d[i][j]-((j+1)*(k+1)+dp1[l]));\n\t}\n      }\n    }\n  }\n  \n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  for(Int k=0;k<100;k++){\n    for(Int l=0;l<100;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(int i=(x),i##_max_for_repmacro=(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int A,B;\n    cin >> A >> B;\n    vector<vector<int>> d(A,vector<int>(B));\n    rep(i,0,A) rep(j,0,B) cin >> d[i][j];\n\n    int N=202,M=101*101,S=0,T=N-1;\n    static int f[101][101]={};\n    rep(i,0,101) rep(j,0,101){\n        int ma=0;\n        rep(x,0,A) rep(y,0,B) ma=max(ma,d[x][y]-(x+1)*i-(y+1)*(100-j));\n        f[i][j]=ma;\n    }\n\n    auto min_dist=[&](int x,int y){\n        int dist[202];\n        fill_n((int*)dist,202,inf);\n        dist[0]=0;\n        rep(i,0,202){\n            rep(j,0,101) rep(k,0,101) dist[k+101]=min(dist[k+101],dist[j]+f[j][k]);\n            rep(j,0,100) dist[j+1]=min(dist[j+1],dist[j]+x);\n            rep(j,0,100) dist[j+1+101]=min(dist[j+1+101],dist[j+101]+y);\n        }\n        return dist[201];\n    };\n\n    rep(x,1,A+1) rep(y,1,B+1) if(min_dist(x,y)!=d[x-1][y-1]){\n        cout << \"Impossible\" << endl;\n        return;\n    }\n\n    cout << \"Possible\" << endl;\n    cout << N << \" \" << M << endl;\n    rep(i,0,100) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    rep(i,0,100) cout << i+1+101 << \" \" << i+2+101 << \" Y\" << endl;\n    rep(i,0,101) rep(j,0,101) cout << i+1 << \" \" << j+102 << \" \" << f[i][j] << endl;\n    cout << S+1 << \" \" << T+1 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint u, v, w; \n\n\tEdge (int u, int v, int w) :\n\t\tu(u), v(v), w(w) {}\n};\n\nint n, m, a[10][10];\nint S, T, id;\nvector<Edge> vres;\n\nvoid add(int x, int y, int z) {\n\tint cur = S;\n\t// -1 : A, -2 : B\n\twhile (x--) vres.push_back(Edge(cur, ++id, -1)), cur = id;\n\twhile (y--) vres.push_back(Edge(cur, ++id, -2)), cur = id;\n\tvres.push_back(Edge(cur, T, z));\n}\n\nbool check(int x, int y, int z) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint tmp = z + x * (i + 1) + y * (j + 1);\n\t\t\tif (tmp < a[i][j]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid run(int A, int B) {\n\tfor (int x = 0; x <= 100; ++x) for (int y = 0; y <= 100; ++y) {\n\t\tint z = a[A][B] - x * (A + 1) - y * (B + 1);\n\t\tif (z < 0) continue;\n\t\tif (check(x, y, z)) { add(x, y, z); return; } \n\t}\n\tcout << \"Impossible\"; exit(0);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tS = 1, T = 2, id = 2;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\trun(i, j);\n\t\t}\n\t}\n\tcout << id << ' ' << vres.size() << '\\n';\n\tfor (auto i : vres) {\n\t\tcout << i.u << ' ' << i.v << ' ';\n\t\tif (i.w == -1) cout << \"A\\n\";\n\t\tif (i.w == -2) cout << \"B\\n\";\n\t\tif (i.w >= 0) cout << i.w << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+1;\n\t\tnumn+=ans[i].a+ans[i].b;\n\t}\n\tnumn+=2;\n\tif (numn>300) {while(1);printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tprintf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'X'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\t{\n\t\t\t\t\tint c=s-a-b;\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[100][100];\nint a,b,c[100][100],flag[100][100];\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");cout<<300<<' '<<200+a*b<<endl;\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)cout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint A, B;\nint D[10][10];\nint f[101][101];\nint main(){\n    cin >> A >> B;\n\n    for (int i = 0; i < A; ++i) {\n        for (int j = 0; j < B; ++j) {\n            cin >> D[i][j];\n        }\n    }\n\n    for (int a = 0; a <= 100; ++a) {\n        for (int b = 0; b <= 100; ++b) {\n            int fmax = 0;\n            for (int x = 1; x <= A; ++x) {\n                for (int y = 1; y <= B; ++y) {\n                    int tmp = max(0, D[x - 1][y - 1] - a * x - b * y);\n                    if (tmp > fmax) fmax = tmp;\n                }\n            }\n            f[a][b] = fmax;\n            cout << fmax << \" \";\n        }\n        cout << endl;\n    }\n\n    bool possible = true;\n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            int dmin = 1000;\n            for (int a = 0; a <= 100; ++a) {\n                for (int b = 0; b <= 100; ++b) {\n                    int dist = a * x + b * y + f[a][b];\n                    if (dmin > dist) dmin = dist;\n                }\n            }\n            if (dmin != D[x - 1][y - 1]) {\n                possible = false;\n                break;\n            }\n        }\n        if (!possible) break;\n    }\n\n    if (possible) {\n        \n        cout << 202 << \" \" << 101 * 101 + 200 << endl;\n        for (int i = 1; i <= 100; ++i) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n            cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n        }\n\n        for (int a = 0; a <= 100; ++a) {\n            for (int b = 0; b <= 100; ++b) {\n                cout << a + 1 << \" \" << b + 102 << \" \" << f[a][b] << endl;\n            }\n        }\n        cout << \"1 202\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tcout << \"0 199\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(E[k],d[i][j]-(100-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(100-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n\n  G[s].emplace_back(z,0);\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n    G[z].emplace_back(idx(i),E[i]);\n    G[z].emplace_back(idy(i),F[i]);\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      flg&=dist==d[i][j];\n      assert(dist>=d[i][j]);\n    }\n  }\n  if(flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i ? i : 201, j ? j + 100 : 202, d[i][j]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n        if(p==1&&q==0) {db(x); db(y); dbg(D[x][y] - p * (x+1) - q * (y+1));}\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << 300 sp << 100*2+101*101 ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> d(A+1, vector<int>(B+1));\n    for(int i=1; i<=A; i++)\n        for(int j=1; j<=B; j++)\n            cin >> d[i][j];\n    vector<vector<int>> f(101, vector<int>(101, 0));\n    for(int a=0; a<=100; a++)\n        for(int b=0; b<=100; b++)\n            for(int x=1; x<=A; x++)\n                for(int y=1; y<=B; y++)\n                    f[a][b] = max(f[a][b], d[x][y]-a*x-b*y);\n\n    for(int x=1; x<=A; x++)\n        for(int y=1; y<=B; y++){\n            int tmp = 1<<30;\n            for(int a=0; a<=100; a++)\n                for(int b=0; b<=100; b++)\n                    tmp = min(tmp, f[a][b]+a*x+b*y);\n            if(tmp != d[x][y]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n\n    cout << \"Possible\" << endl;\n    int N = 202;\n    int M = 200 + 101*101;\n    vector<tuple<int, int, int>> edges;\n    for(int i=0; i<99; i++)\n        edges.push_back(make_tuple(i, i+1, -1));\n    for(int i=101; i<N-1; i++)\n        edges.push_back(make_tuple(i, i+1, -2));\n    for(int i=0; i<=100; i++)\n        for(int j=0; j<=100; j++)\n            edges.push_back(make_tuple(i, 201-j, f[i][j]));\n    cout << N << \" \" << M << endl;\n    for(auto e : edges){\n        int u, v, c;\n        tie(u, v, c) = e;\n        cout << u+1 << \" \" << v+1 << \" \";\n        if(c == -1) cout << \"X\" << endl;\n        else if(c == -2) cout << \"Y\" << endl;\n        else cout << c << endl;\n    }\n    cout << 1 << \" \" << N << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\nclass GRAPH \n{\n\tpublic:\n\t\tint to[MAXM],next[MAXM],weight[MAXM];\n\t\tint head[MAXN];\n\t\tint cnt;\n\t\t\n\tGRAPH()\n\t{\n\t\tcnt=1;\n\t} \n\t\n\tvoid add(int x,int y,int z)\n\t{\n\t\tnext[cnt]=head[x];\n\t\tweight[cnt]=z;\n\t\tto[cnt]=y;\n\t\thead[x]=cnt++;\n\t}\n};\n\nGRAPH g;\n\nint n,m;\nint a[12][12],b[12][12],c[12][12];\n\nint main()\n{\n\t//WRT(ceil(111.0));\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\t//cout<<i<<' '<<j<<endl;\n\t\t\tDRPT(k,n,i)\n\t\t\t{\n\t\t\t\t//WRT(k);\n\t\t\t\ta[i][j]=max(a[i][j],(int)ceil(((DB)c[k][j]-c[i][j])/(k-i)));\n\t\t\t}\n\t\t\tDRPT(k,i-1,0)\n\t\t\t\tif (ceil(((DB)c[k][j]-c[i][j])/(k-i))<a[i][j])\n\t\t\t\t{\n\t\t\t\t\t//WRT(k);\n\t\t\t\t\t//WRT(ceil(((DB)c[k][j]-c[i][j])/(k-i)));\n\t\t\t\t\t//WRT(a[i][j]);\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t\t//MRK();\n\t\t\tDRPT(k,m,j)\n\t\t\t\tb[i][j]=max(b[i][j],(int)ceil(((DB)c[i][k]-c[i][j])/(k-j)));\n\t\t\tDRPT(k,j-1,0)\n\t\t\t\tif (ceil(((DB)c[i][k]-c[i][j])/(k-j))<b[i][j])\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tif (c[i][j]-i*a[i][j]-j*b[i][j]<0)\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t//RPT(i,1,n+1)\n\t//\tRPT(j,1,m+1)\n\t//\t\tcout<<i<<' '<<j<<' '<<a[i][j]<<' '<<b[i][j]<<endl;\n\tcout<<\"Possible\"<<endl;\n\tcout<<200<<' '<<198+m*n<<endl;\n\tRPT(i,1,100)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,101,200)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tcout<<a[i][j]+1<<' '<<b[i][j]+101<<' '<<c[i][j]-i*a[i][j]-j*b[i][j]<<endl;\n\tcout<<1<<' '<<101;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 110;\nint d[12][12], c[N][N];\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    FOR(i,1,a) FOR(j,1,b){\n        cin >> d[i][j];\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        c[cx][cy] = max(c[cx][cy], d[i][j] - cx * i - cy * j);\n    }\n\n    REP(cx,N) REP(cy,N) FOR(i,1,a) FOR(j,1,b){\n        if (cx * i + cy * j + c[cx][cy] < d[i][j]){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    int m = 2 * (N-1) + N * N;\n\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << m << endl;\n    REP(i,N-1) cout << i+1 << \" \" << i+2 << \" x\" << endl;\n    REP(i,N-1) cout << 300-i << \" \" << 299-i << \" y\" << endl;\n    REP(i,N) REP(j,N) cout << i+1 << \" \" << 300-j << \" \" << c[i][j] << endl;\n    cout << \"1 300\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define ll long long\n#define X first\n#define Y second\n#define pb push_back\n#define E Maxke_pair\n#define pii pair<int, int>\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define sz(x) (int)(x).sze()\n#define ALL(x) (x).insgin(), (x).end()\n#define vi vector<int>\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\nconst int mod = 1e9 + 7;\nconst int INF = 1e9 + 7;\nconst int N = 110;\nconst int M = 2e6 + 10; \nint m,n,a[N][N],b[N][N]; \nbool vis[N][N];\nint main()\n{\n\tm = read();\n\tn = read();\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\ta[i][j] = read();\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\trep(x, 0, 100)\n\t\t\t\trep(y, 0, 100)\n\t\t\t\t\tb[x][y] = max(b[x][y], a[i][j] - i * x - j * y);\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\trep(x, 0, 100)\n\t\t\t\trep(y, 0, 100)\n\t\t\t\t\tif (b[x][y] == a[i][j] - i * x - j * y) vis[i][j] = 1;\n\n\trep(i, 1, m)\n\t\trep(j, 1, n)\n\t\t\tif(!vis[i][j]) \n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\", 200 + 101 * 101);\n\trep(i, 1, 100) printf(\"%d %d X\\n\", i, i + 1);\n\trep(i, 102, 201) printf(\"%d %d Y\\n\",i + 1, i);\n\trep(i, 1, 100)\n\t\trep(j, 1, 100) \n\t\t\tprintf(\"%d %d %d\\n\", i + 1, j + 102, b[i][j]);\n\tputs(\"1 102\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\n\nvoid test_edge(int a,int b, int x, int y){\n    int c = d[x][y] - a*x - b*y;\n    if (a >= 0 && b >= 0 && c >= 0 && c <= 100){\n        for(int i=1;i<=A;i++){\n            for(int j=1;j<=B;j++){\n                if (a*i + b*j + c < d[i][j])return;\n            }\n        }\n        C[a][b] = min(C[a][b], c);\n    }\n    else return;\n}\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a0 = d[x+1][y] - d[x][y];\n            int a1 = d[x+1][y+1] - d[x][y+1];\n            int b0 = d[x][y+1] - d[x][y];\n            int b1 = d[x+1][y+1] - d[x+1][y];\n            test_edge(a0, b0, x,y);\n            test_edge(a0, b1, x,y);\n            test_edge(a1, b0, x,y);\n            test_edge(a1, b1, x+1,y+1);\n        }\n    }\n    for(int y=1;y<B;y++){\n        int b = d[A][y+1] - d[A][y];\n        int c = d[A][y] - b*y;\n        if (b >= 0 && c >= 0 && c <= 100)C[0][b] = min(C[0][b],c);\n    }\n    for(int x=1;x<A;x++){\n        int a = d[x+1][B] - d[x][B];\n        int c = d[x][B] - a*x;\n        if (a >= 0 && c >= 0 && c <= 100)C[a][0] = min(C[a][0],c);\n    }\n    C[0][0] = min(C[0][0], d[A][B]);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(decltype(t) i##0_to = (t), i = (f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(decltype(t) i##0_to = (t), i = (f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(decltype(f) i##0_to = (t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(decltype(f) i##0_to = (t), i = (f); i >  i##0_to; i--)\n// types\n    typedef long double LD;\n    #define long long long\n    #define int long\n    using VI = vector<int>;\n    using WI = vector<VI>;\n    using PI = pair<int, int>;\n    using VPI = vector<PI>;\n    using WPI = vector<VPI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define db(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define dbg(x) if(debug) cerr << #x << \" = \" << (x) ln\n\nconstexpr long INF = 1LL << 60;\n\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n// IO\n    template<class T>\n    istream& operator>>(istream& s, vector<T>& v) {\n        for(auto&& p : v) s >> p; return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<T> v) {\n        int i = 0;\n        for(const auto& p : v) s << (i++?\" \":\"\") << p;\n        return s;\n    }\n    template<class T>\n    ostream& operator<<(ostream& s, vector<vector<T>> w) {\n        for(const auto& v : w) {\n            int i = 0;\n            for(const auto& p : v) s << (i++?\" \":\"\") << p;\n            s ln;\n        }\n        return s;\n    }\n    template<class T, class... A>\n    T RD(A... a) { T t(a...); cin >> t; return t; }\n// other\n    #define all(x) (x).begin(), (x).end()\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n\n/****************************** optional library ******************************/\n//-mod constexpr long MOD = 1000000009; // 1000000007; // 998244353;\n\n/************************************ main ************************************/\n\nvoid solve() {\n    int A, B; scanf(\"%lld%lld\", &A, &B);\n    WI D = RD<WI>(A,VI(B));\n\n    WI f(101, VI(101, -INF));\n\n    times(A, x) times(B, y) times(101, p) times(101, q) {\n        f[p][q] = max(f[p][q], D[x][y] - p * (x+1) - q * (y+1));\n        if(p==1&&q==0) {db(x); db(y); dbg(D[x][y] - p * (x+1) - q * (y+1));}\n    }\n    times(101, p) times(101, q) if(f[p][q] < 0) f[p][q] = 0;\n    times(A, x) times(B, y) {\n        int a = INF;\n        times(101, p) times(101, q) {\n            a = min(a, f[p][q] + p * (x+1) + q * (y+1));\n        }\n        if(a != D[x][y]) {\n            cout << \"Impossible\" ln;\n            return;\n        }\n    }\n    cout << \"Possible\" ln << 300 sp << 100*2+101*101 ln;\n    times(100, p) cout << p+1 sp << p+2 sp << \"X\" ln;\n    times(100, q) cout << q+102 sp << q+103 sp << \"Y\" ln;\n    times(101, p) times(101, q) {\n        cout << p+1 sp << q+102 sp << f[p][q] ln;\n    }\n    cout << \"1 102\" ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint A, B;\nint d[20][20];\n\nint N, M;\nint cost[101][101];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> A >> B;\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) cin >> d[x][y];\n\n    N = 202;\n    M = 10401;\n\n    rep(i, 101) rep(j, 101) FOR(x, 1, A + 1) FOR(y, 1, B + 1)\n        chmax(cost[i][j], d[x][y] - i * x - j * y);\n\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) {\n        int mn = 1 << 30;\n        rep(i, 101) rep(j, 101) chmin(mn, x * i + y * j + cost[i][j]);\n        if(mn != d[x][y]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    cout << N << \" \" << M << \"\\n\";\n\n    rep(i, 100) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    rep(j, 100) cout << j + 102 << \" \" << j + 103 << \" Y\\n\";\n\n    rep(i, 101) rep(j, 101) cout << i + 1 << \" \" << N - j << \" \" << cost[i][j]\n                                 << \"\\n\";\n\n    cout << \"1 \" << N << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10401\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint c[101][101], d[11][11];\n\nbool judge(int a, int b) {\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            int dist = 114514;\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    dist = min(dist, i * k + j * l + c[k][l]);\n                }\n            }\n            if (dist != d[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    for (int i = 1; i <= a; i++) {\n        for (int j = 1; j <= b; j++) {\n            for (int k = 0; k <= 100; k++) {\n                for (int l = 0; l <= 100; l++) {\n                    c[k][l] = max(c[k][l], d[i][j] - i * k - j * l);\n                }\n            }\n        }\n    }\n\n    if (judge(a, b)) {\n        cout << \"Possible\" << endl;\n        for (int i = 1; i <= 100; i++) {\n            cout << i << \" \" << i + 1 << \" X\" << endl;\n        }\n        for (int i = 102; i < 202; i++) {\n            cout << i + 1 << \" \" << i << \" Y\" << endl;\n        }\n        for (int i = 0; i <= 100; i++) {\n            for (int j = 0; j <= 100; j++) {\n                cout << i + 1 << \" \" << j + 102 << \" \" << c[i][j] << endl;\n            }\n        }\n        cout << 0 << \" \" << 102 << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 0x7fffffff\n\nint A,B;\nint D[15][15],F[305][305];\n\nvoid init(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++){\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tscanf(\"%d\",&D[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tF[i][j]=max(F[i][j],D[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++){\n\t\tfor(int y=1;y<=B;y++){\n\t\t\tint f=INF;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tf=min(f,F[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f!=D[x][y]){\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor(int i=102;i<202;i++){\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,F[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}\n\nint main(void){\n\tinit();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint A, B;\n\tcin >> A >> B;\n\tint d[10][10];\n\tfor(int i=0; i<A; ++i)\n\t\tfor(int j=0; j<B; ++j)\n\t\t{\n\t\t\tcin >> d[i][j];\n\t\t}\n\t\t\n\tint nx[10][10], ny[10][10];\n\tfor(int y=A; y--;)\n\t\tfor(int x=B; x--;)\n\t\t{\n\t\t\tif(x == B-1)\n\t\t\t{\n\t\t\t\tnx[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnx[y][x] = max(nx[y][x+1], d[y][x+1] - d[y][x]);\n\t\t\t\t//if(y < A-1)\n\t\t\t\t//\tnx[y][x] = max(nx[y][x], nx[y+1][x]);\n\t\t\t\tif((0 < x && d[y][x] - d[y][x-1] < nx[y][x]))// || 200/max(A,B) < nx[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y == A-1)\n\t\t\t{\n\t\t\t\tny[y][x] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tny[y][x] = max(ny[y+1][x], d[y+1][x] - d[y][x]);\n\t\t\t\t//if(x < B-1)\n\t\t\t\t//\tny[y][x] = max(ny[y][x], ny[y][x+1]);\n\t\t\t\tif((0 < y && d[y][x] - d[y-1][x] < ny[y][x]))// || 200/max(A,B) < ny[y][x])\n\t\t\t\t{\n\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t*(int*)0=0;\n\tcout << \"Possible\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[N], Y[N], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 0, yy = 0;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      xx = std::max(xx, d[i][j] / i);\n      yy = std::max(yy, d[i][j] / j);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = -100000000;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      if (ans < 0 || ans > 100) continue;\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d %d\\n\", cnt, m);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      vector<Int> dp1(100,INF),dp2(100,INF);\n      for(Int k=100-1;k>=0;k--){\n\tdp1[k]=C[k];\n\tdp2[k]=D[k];\n\tif(k+1<100){\n\t  chmin(dp1[k],dp1[k+1]+i);\n\t  chmin(dp2[k],dp2[k+1]+j);\n\t}\n      }\n      for(Int k=0;k<100;k++){\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*(k+1)+dp2[l]));\n\t  chmax(F[k][l],d[i][j]-((j+1)*(k+1)+dp1[l]));\n\t}\n      }\n    }\n  }\n  \n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n  }\n  \n  for(Int k=0;k<100;k++){\n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long \n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define N ((ll)(2e6+100))\n#define MAX ((ll)(1e16+100))\n#define ARRS ((ll)(3e5+100))\n#define MOD ((ll)(1e9+7))\n#define M1 ((ll)(1001783))\n#define M2 ((ll)(1001941))\n#define M3 ((ll)(1002073))\n#define pb push_back\n\n\nll w[200][200];\nll fi[200][200];\nll f[105][105][105];\n\nstruct va{\n\tll a,b,c;\n};\nvector<va> v;\nint main(){\n\n\tll n,m;\n\tcin>>n>>m;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=m; j++)\n\t\t\tcin>>w[i][j];\n\n\tfor(int a=0; a<=100; a++){\n\t\tfor(int b=0; b<=100; b++){\n\t\t\tfor(int c=0; c<=100; c++){\n\n\t\t\t\tf[a][b][c]=1;\n\t\t\t\tfor(int x=1; x<=n; x++)\n\t\t\t\t\tfor(int y=1; y<=m; y++)\n\t\t\t\t\t\tif(w[x][y]>x*a+y*b+c)\n\t\t\t\t\t\t\tf[a][b][c]=0;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a=0; a<=100; a++){\n\t\tfor(int b=0; b<=100; b++){\n\t\t\tfor(int c=0; c<=100; c++){\n\n\t\t\t\tfor(int x=1; x<=n; x++)\n\t\t\t\t\tfor(int y=1; y<=m; y++)\n\t\t\t\t\t\tif(f[a][b][c]&&w[x][y]==x*a+y*b+c)\n\t\t\t\t\t\t\tfi[x][y]=1;\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\tbool e=1;\n\tfor(int x=1; x<=n; x++)\n\t\tfor(int y=1; y<=m; y++)\n\t\t\te&=fi[x][y];\n\n\n\tif(e){\n\t\tfor(int i=1; i<=100; i++)\n\t\t\tv.pb({i,i+1,-1});\n\t\tfor(int j=1; j<=100; j++)\n\t\t\tv.pb({j+101,101+j+1,-2});\n\n\t\tfor(int a=0; a<=100; a++)\n\t\t\tfor(int b=0; b<=100; b++)\n\t\t\t\tfor(int c=0; c<=100; c++)\n\t\t\t\t\tif(f[a][b][c])\n\t\t\t\t\tv.pb({a+1,202-b,c});\n\n\t\tcout<<\"Possible\\n\";\n\t\tcout<<202<<\" \"<<v.size()<<endl;\n\t\tfor(auto x:v)\n\t\t\tif(x.c==-1)\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<\"X\"<<endl;\n\t\t\telse if(x.c==-2)\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<\"Y\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<x.c<<endl;\n\t\tcout<<1<<\" \"<<202;\n\t}\n\telse {\n\t\tcout<<\"Impossible\";\n\t}\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[200][200];\nint a,b,c[200][200],flag[200][200],fff[200][200][200];\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=100;i++)\n\t\tfor (int j=0;j<=100;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");cout<<300<<' '<<200+a*b<<endl;\n\tfor (int i=1;i<=100;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=100;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y][f[i][j].z])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y][f[i][j].z]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+(ans[i].c!=0);\n\t\tnumn+=ans[i].a+ans[i].b+(ans[i].c!=0)-1;\n\t}\n\tnumn+=2;\n\tif (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,++t,'Y'),pre=t;\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,++t,'X'),pre=t;\n\t\tif (ans[i].c) printf(\"%d %d %d\\n\",pre,++t,ans[i].c);\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\tfor (int c=0;c<=s-a-b&&c<=100;c++)\n\t\t\t\t{\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  rep(l, 101) rep(m, 101) {\n    reps(x, 1, a+1) reps(y, 1, b+1) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n    //if(n[l][m]) cout<<l<<\" \"<<m<<\" \"<<n[l][m]<<endl;\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e[202];\n    fill(e, e+202, inf);\n    rep(l, 101) e[l] = l*x;\n    rep(l, 101) rep(m, 101) {\n      //if(!m) cout<<e[m+101]<<\" \"<<l<<\":\"<<e[l]<<\"+\"<<n[l][m]<<endl;\n      chmin(e[m+101], e[l]+n[l][m]);\n    }\n    //cout<<e[101]<<endl;\n    for(int m = 100; m > 0; --m) chmin(e[m-1+101], e[m+101]+y);\n    if(e[101] != d[x][y]) {\n      cout<<x<<\" \"<<y<<\" \"<<e[101]<<endl;\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl;\n  cout << 1 << \" \" << 102 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint mn[105][105];\nint in[105][105];\nint main() {\n\tint A, B, i, j, k, l;\n\tscanf(\"%d %d\", &A, &B);\n\tfor (i = 1; i <= A; i++) for (j = 1; j <= B; j++) scanf(\"%d\", &in[i][j]);\n\n\tfor (i = 1; i <= A; i++) {\n\t\tfor (j = 1; j <= B; j++) {\n\t\t\tfor (k = 0; k <= 100; k++) {\n\t\t\t\tfor (l = 0; l <= 100; l++) {\n\t\t\t\t\tint t = i*k + j*l;\n\t\t\t\t\tmn[k][l] = max(mn[k][l], in[i][j] - t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= A; i++) {\n\t\tfor (j = 1; j <= B; j++) {\n\t\t\tint v = INF;\n\t\t\tfor (k = 0; k <= 100; k++) for (l = 0; l <= 100; l++) v = min(v, i*k + j*l + mn[k][l]);\n\t\t\tif (v != in[i][j]) return !printf(\"Impossible\\n\");\n\t\t}\n\t}\n\n    printf(\"Possible\\n\");\n\tprintf(\"202 %d\\n\", 101*101+200);\n\tfor (i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n\tfor (i = 1; i <= 101; i++) for (j = 1; j <= 101; j++) printf(\"%d %d %d\\n\", i, j + 101, mn[i - 1][101 - j]);\n\treturn !printf(\"%d %d\\n\", 1, 202);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<100; a++)\n\t\tfor(int b=0; b<100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<100; x++){\n\t\t\t\tfor(int y=0; y<100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tfor(int i=0; i<99; i++) cout << i << \" \" << i+1 << \" X\\n\";\n\tfor(int i=100; i<199; i++) cout << i << \" \" << i << \" Y\\n\";\n\tcout << \"0 199\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > d(A,vector<int>(B));\n\tfor(int i =0; i < A*B; i++) cin >> d[i/B][i%B];\n\n\tvector< vector<int> > mincost(101,vector<int>(101,0));\n\tfor(int i =1; i <= A; i++) for(int j =1; j <= B; j++)\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\t mincost[k][l] =max(d[i-1][j-1]-k*i-l*j,mincost[k][l]);\n\n\tfor(int i =1; i <= A; i++) for(int j =1; j <= B; j++) {\n\t\tint m =101;\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\tm =min(m,mincost[k][l]+k*i+l*j);\n\t\tif(m != d[i-1][j-1]) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tint N =2*(100+1), M =(N/2)*(N/2)+2*(N/2-1);\n\tcout << N << \" \" << M << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i =0; i <= N/2-1; i++) for(int j =0; j <= N/2-1; j++)\n\t\tcout << i+1 << \" \" << N-j << \" \" << mincost[i][j] << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+N/2+1 << \" \" << i+N/2+2 << \" Y\\n\";\n\tcout << \"1 \" << N << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool flg[101][101][101];\n\nint main()\n{\n    cin.tie(0);\n\n    int a, b;\n    cin >> a >> b;\n\n    vector<vector<int>> bd(a, vector<int>(b));\n\n    for (int i = 0; i < a; i++) {\n        for (int j = 0; j < b; j++) {\n            cin >> bd[i][j];\n        }\n    }\n\n    memset(flg, 0, sizeof(flg));\n    bool possible = true;\n    for (int x = 1; x <= a; x++) {\n        for (int y = 1; y <= b; y++) {\n            int t = bd[x - 1][y - 1];\n            bool ok = false;\n            for (int a = 0; a <= 100; a++) {\n                for (int b = 0; b <= 100; b++) {\n                    for (int c = 0; c <= 100; c++) {\n                        if (flg[a][b][c])\n                            continue;\n\n                        if (a * x + b * y + c == t) {\n                            ok = true;\n                        }\n\n                        if (a * x + b * y + c < t) {\n                            flg[a][b][c] = true;\n                        }\n                    }\n                }\n            }\n            if (!ok) {\n                possible = false;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n\n    cout << \"Possible\" << endl;\n\n    map<pair<int, int>, int> es;\n    es[make_pair(100, 101)] = 100;\n    for (int i = 0; i < 100; i++) {\n        es[make_pair(i, i + 1)] = -1;\n        es[make_pair(101 + i, 101 + i + 1)] = -2;\n    }\n    for (int a = 0; a <= 100; a++) {\n        for (int b = 0; b <= 100; b++) {\n            for (int c = 0; c <= 100; c++) {\n                if (flg[a][b][c]) {\n                    es[make_pair(a, 202 - b)] = c;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << 202 << \" \" << es.size() << endl;\n\n    for (auto& it : es) {\n        cout << it.first.first + 1 << \" \" << it.first.second + 1 << \" \";\n        if (it.second == -1) {\n            cout << \"X\";\n        } else if (it.second == -2) {\n            cout << \"Y\";\n        } else {\n            cout << it.second;\n        }\n        cout << endl;\n    }\n\n    cout << 1 << \" \" << 202 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 111\n\nconst int val = 100;\n\nint A, B, i, j, n, m;\nint v[maxN][maxN];\nint least[maxN][maxN];\nvector< pair<pair<int, int>, int> > edges;\n\nvoid execute(int x, int y, int need) {\n    int i, j;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            least[i][j] = max(least[i][j], need - (x * i + y * j));\n\n}\n\nbool check(int x, int y, int need) {\n    int i, j;\n\n    int act = 1 << 30;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            act = min(act, i * x + j * y + least[i][j]);\n\n    if (act != need) return false;\n    return true;\n}\n\nvoid add_edge(int x, int y, int v) {\n    edges.pb(mp(mp(x, y), v));\n    m++;\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    cin >> A >> B;\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            cin >> v[i][j];\n\n            execute(i, j, v[i][j]);\n        }\n    }\n\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            if (!check(i, j, v[i][j])) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    add_edge(1, 2, 0);\n    for (i = 2; i + 1 <= val + 2; i++)\n        add_edge(i, i + 1, -1);\n\n    for (i = val + 3; i + 1 <= 2 * val + 3; i++)\n        add_edge(i, i + 1, -2);\n\n    add_edge(2 * val + 3, 2 * val + 4, 0);\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            add_edge(i + 2, j + val + 3, least[i][j]);\n\n    n = 2 * val + 4;\n\n    cout << n << ' ' << m << '\\n';\n    for (auto e : edges) {\n        cout << e.first.first << ' ' << e.first.second << ' ';\n        if (e.second == -1) cout << \"X\\n\";\n        if (e.second == -2) cout << \"Y\\n\";\n        if (e.second >= 0) cout << e.second << \"\\n\";\n    }\n\n    cout << 1 << ' ' << n;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint A,B;\nint d[11][11];\nconst int C = 101;\nint S = 1 , T = 2 * C;\nint N = T , M = 2 * (C-1) + C * C;\nint e[C][C];\n\nint main(){\n\tcin >> A >> B;\n\trepp(i,1,A+1) repp(j,1,B+1) cin >> d[i][j];\n\trepp(i,0,C) repp(j,0,C){\n\t\trepp(x,1,A+1) repp(y,1,B+1) e[i][j] = max(e[i][j] , d[x][y]-i*x-j*y);\n\t}\n\trepp(x,1,A+1) repp(y,1,B+1){\n\t\tint z = C;\n\t\trepp(i,0,C) repp(j,0,C) z = min(z,e[i][j]+i*x+j*y);\n\t\tif(z != d[x][y]) return cout << \"Impossible\" << endl , 0;\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << N << ' ' << M << endl;\n\trepp(i,1,C){\n\t\tcout << i << ' ' << i+1 << \" X\" << endl;\n\t\tcout << C+i << ' ' << C+i+1 << \" Y\" << endl;\n\t}\n\trepp(i,0,C) repp(j,0,C) cout << i+1 << ' ' << N-j << ' ' << e[i][j] << endl;\n\tcout << S << ' ' << T << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define se second\n#define fi first\n#define mk(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pii;\n\nint A,B;\nint D[10][10];\nint mem[110][110];\nvector<pii> G[300];\nint dis[300];\n\nint main()\n{\n    scanf(\"%d%d\",&A,&B);\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            scanf(\"%d\",&D[i][j]);\n        }\n    }\n\n    for(int i = 0; i <= 100; i++)\n    {\n        for(int j = 0; j <= 100; j++)\n        {\n            int res = 0;\n            for(int k = 1; k <= A; k++)\n            {\n                for(int l = 1; l <= B; l++)\n                {\n                    res = max(res,D[k][l] - i * k - j * l);\n                }\n            }\n            if(res > 100)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            mem[i][j] = res;\n        }\n    }\n\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            int MIN = 1001001001;\n            for(int k = 0; k <= 100; k++)\n            {\n                for(int l = 0; l <= 100; l++)\n                {\n                    MIN = min(MIN,k * i + l * j + mem[k][l]);\n                }\n            }\n            if(MIN != D[i][j])\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"202 10401\\n\");\n    for(int i = 0; i < 100; i++)\n    {\n        printf(\"%d %d X\\n\",i + 1,i + 2);\n        printf(\"%d %d Y\\n\",i + 2 + 101,i + 1 + 101);\n    }\n\n    for(int i = 0; i < 101; i++)\n    {\n        for(int j = 0; j < 101; j++)\n        {\n            printf(\"%d %d %d\\n\",i + 1,j + 1 + 101,mem[i][j]);\n        }\n    }\n\n    printf(\"1 102\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint d[11][11];\nint val[11][11];\n\nusing edge = tuple<int, int, int>;\nvector<edge> graph;\n\nusing edge2 = tuple<int, int, char>;\nvector<edge2> graph2;\n\n\nint main(void) {\n\tint a, b;\n\tcin >> a >> b;\n\n\trep(i, a)rep(j, b) cin >> d[i][j];\n\trep(i, a)rep(j, b) val[i][j] = 1010;\n\n\tconst int total = 17;\n\tconst int n = total * total + 1;\n\tconst int s = 0, t = n - 1;\n\n\trep(ca, total)rep(cb, total) {\n\t\tint tmp[11][11];\n\t\trep(x, a)rep(y, b) tmp[x][y] = ca * (x + 1) + cb * (y + 1);\n\t\tint cmax = 0;\n\t\trep(x, a)rep(y, b) chmax(cmax, d[x][y] - tmp[x][y]);\n\t\tif (cmax > 100) continue;\n\t\t\n\t\t/*\t\n\t\trep(x, a){\n\t\t\trep(y, b) cerr << tmp[x][y] << \" \";\n\t\t\tcerr << endl;\n\t\t}\n\t\t*/\n\n\t\t//cerr << cmax << endl;\n\n\t\t//cerr << ca << \" \" << cb << endl;\n\t\trep(x, a)rep(y, b) chmin(val[x][y], tmp[x][y] +  cmax);\n\t\tconst int idx = total * ca + cb;\n\t\tgraph.push_back(edge(idx, t, cmax));\n\t}\n\n\trep(ca, total - 1) {\n\t\tgraph2.push_back(edge(total * ca, total * (ca + 1), 'X'));\n\t}\n\n\trep(ca, total)rep(cb, total - 1) {\n\t\tgraph2.push_back(edge(total * ca + cb , total * ca + cb + 1, 'Y'));\n\t}\n\n\n\trep(x, a)rep(y, b) {\n\t\t//cerr << val[x][y] << \" \" << d[x][y] << endl;\n\t\tif (val[x][y] != d[x][y]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tconst int m = graph.size() + graph2.size();\n\tcout << n << \" \" << m << endl;\n\tfor (auto &it : graph) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tfor (auto &it : graph2) {\n\t\tint a, b;\n\t\tchar  c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tcout << s + 1 << \" \" << t + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 1002, M = 500000;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[M],st2[M],st3[M];\nbool mrk[M];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=1; t=2;\n\trep(a,0,100) rep(b,0,100) {\n\t\tint mx=-1;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-a*i-b*j); if (mx==-1) continue;\n\t\tbool flag=0;\n\t\trep(i,1,n) rep(j,1,m) if (!ok[i][j]&&d[i][j]-a*i-b*j==mx) {ok[i][j]=1; flag=1;}\n\t\tif (!flag) continue;\n\t\tif (sz==300) break; C[a][b]=mx; dy[a][b]=++sz;\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\trep(a,0,100) rep(b,0,100) {\n\t\tif (dy[a][b]&&dy[a+1][b]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a+1][b]; st3[tot]=1;}\n\t\tif (dy[a][b]&&dy[a][b+1]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a][b+1]; st3[tot]=2;}\n\t}\n\trep(a,0,100) rep(b,0,100) if (dy[a][b]) {\n\t\ttot++; st1[tot]=dy[a][b]; st2[tot]=t;\n\t\tmrk[tot]=1; st3[tot]=C[a][b];\n\t}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[0][1]; st3[tot]=2;}\n\tif (dy[1][0]) {tot++; st1[tot]=s; st2[tot]=dy[1][0]; st3[tot]=1;}\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",sz,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"1 2\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  const ll N = 202, S = 1, T = 102, LabelX = -1, LabelY = -2;\n\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct edge { ll u, v, c; };\n  vector<edge> edges;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(i, S, S + 100) edges.push_back((edge) { i, i + 1, LabelX });\n  REP(i, T, T + 100) edges.push_back((edge) { i + 1, i, LabelY });\n\n  REP(p, 0, 101) REP(q, 0, 101) REP(r, 0, 100 + 1) {\n    bool f = true;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) f = f && D[x][y] <= p * x + q * y + r;\n    if(!f) continue;\n    ll cnt = 0;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      if(!ok[x][y] && D[x][y] == p * x + q * y + r) {\n        ok[x][y] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) edges.push_back((edge) { S + p, T + q, r });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n  } else {\n    cout << \"Possible\" << endl;\n    cout << N << \" \" << edges.size() << endl;\n    for(edge e : edges) {\n      if(e.c >= 0) cout << e.u << \" \" << e.v << \" \" << e.c << endl;\n      else cout << e.u << \" \" << e.v << \" \" << (e.c == LabelX ? \"X\" : \"Y\") << endl;\n    }\n    cout << S << \" \" << T << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t{\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\t\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\tcout<<1<<' '<<102<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint c[102][102];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, a, b);\n\tMAT(int, d, a, b);\n\tREP(ai, 101) REP(bi, 101) REP(x, a) REP(y, b) {\n\t\tCHMAX(c[ai][bi], d[x][y] - ai * (x + 1) - bi * (y + 1));\n\t}\n\tREP(x, a) REP(y, b) {\n\t\tint dist = INFINT;\n\t\tREP(ai, 101) REP(bi, 101) {\n\t\t\tCHMIN(dist, ai * (x + 1) + bi * (y + 1) + c[ai][bi]);\n\t\t}\n\t\tif (dist != d[x][y]) {\n\t\t\tOUT(\"Impossible\")BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tOUT(\"Possible\")BR;\n\tOUT(\"202 10401\")BR;\n\tREP(i, 100) {\n\t\tOUT(i + 1)SP OUT(i + 2)SP OUT('X')BR;\n\t\tOUT(i + 2 + 101)SP OUT(i + 1 + 101)SP OUT('Y')BR;\n\t}\n\tREP(i, 101) REP(j, 101) {\n\t\tOUT(i + 1)SP OUT(j + 1 + 101)SP OUT(c[i][j])BR;\n\t}\n\tOUT(\"1 102\")BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(101, vector<int>(101, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[i][j] - i * k - j * l);\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            minDistance = min(minDistance, i * k + j * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[i][j]) impossible();\n      }\n    }\n    cout << \"202 10401\" << endl;\n    for (int k = 0; k <= 100; ++k) {\n      for (int l = 0; l <= 100; ++l) {\n        cout << k + 1 << ' ' << 102 + l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < 100; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + 102 << ' ' << i + 103 << \" Y\" << endl;\n    }\n\n    cout << \"1 202\" << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <array>\n#include <vector>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\nusing RG = Range;\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint d[16][16];\n\nint main()\n{\n    int A, B;\n    RD(A, B);\n\n    for(int i: RG(1, A + 1))\n        RDV(d[i] + 1, d[i] + B + 1);\n\n    vector<pair<int, int>> adj[300];\n\n    for(int i = 1; i <= 100; i++)\n        adj[i].push_back({i + 1, -1});\n    for(int i = 102; i <= 201; i++)\n        adj[i].push_back({i + 1, -2});\n\n    bool solved = true;\n    for(int i: RG(1, A + 1))\n        for(int j: RG(1, B + 1))\n        {\n            int xx = -1, yy = -1;\n            for(int x = 0; x <= 100 && xx == -1; x++)\n                for(int y = 0; y <= 100 && xx == -1; y++)\n                {\n                    bool check = true;\n                    for(int ii = 1; ii <= A && check; ii++)\n                        for(int jj: RG(1, B + 1))\n                            if(!(i == ii && j == jj))\n                            {\n                                int dx = ii - i;\n                                int dy = jj - j;\n                                int dd = d[ii][jj] - d[i][j];\n\n                                if(x * dx + y * dy < dd)\n                                {\n                                    check = false;\n                                    break;\n                                }\n\n\n                            }\n                    if(check)\n                    {\n                        xx = x;\n                        yy = y;\n                    }\n                }\n            if(xx == -1)\n                solved = false;\n            else\n                adj[xx + 1].push_back({202 - yy, d[i][j] - xx * i - yy * j});\n        }\n\n    if(!solved)\n        WTL(\"Impossible\");\n    else\n    {\n        WTL(\"Possible\");\n        int N = 202;\n        int M = 0;\n        for(int i: RG(1, N + 1))\n            M += adj[i].size();\n        WTL(N, M);\n        for(int i: RG(1, N + 1))\n            for(auto p: adj[i])\n            {\n                WT(i, p.first, \"\");\n                if(p.second == -1)\n                    WTL(\"X\");\n                else if(p.second == -2)\n                    WTL(\"Y\");\n                else\n                    WTL(p.second);\n            }\n        WTL(1, 202);\n\n\n\n    }\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\t\t\td[0] = 0;\n\t\t\tpriority_queue<p>Q;\n\t\t\tQ.push({0,0});\n\t\t\twhile (Q.size()) {\n\t\t\t\tp t = Q.top(); Q.pop();\n\t\t\t\tif (d[t.second] < t.first)continue;\n\t\t\t\tfor (P u : V) {\n\t\t\t\t\tif (u.second.first == t.second) {\n\t\t\t\t\t\tint h = 0;\n\t\t\t\t\t\tif (u.first >= 0) {\n\t\t\t\t\t\t\th = u.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (u.first == -1) {\n\t\t\t\t\t\t\th = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse h = j + 1;\n\t\t\t\t\t\tif (d[u.second.second] > t.first + h) {\n\t\t\t\t\t\t\td[u.second.second] = t.first + h;\n\t\t\t\t\t\t\tQ.push({ u.second.second,t.first + h });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \"  Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nconst int MAXA = 17;\n\nint D[MAXA][MAXA];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint a, b;\n\tcin >> a >> b;\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t\tcin >> D[i][j];\n\tREP(c1, 101)\n\t\tREP(c2, 101)\n\t{\n\t\tbool ok = true;\n\t\tint c3;\n\t\tfor (c3 = 0; c3 < 100; ++c3)\n\t\t{\n\t\t\tFOR(x, 1, a + 1)\n\t\t\t\tFOR(y, 1, b + 1)\n\t\t\t\tif (D[x][y] != min(c1 + x + y, min(c2 + x, c3 + y)))\n\t\t\t\t\tok = false;\n\t\t\tif (ok)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ok)\n\t\t{\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcout << \"6 7\\n\";\n\t\t\tcout << \"1 2 \" << c1 << '\\n';\n\t\t\tcout << \"2 3 X\\n\";\n\t\t\tcout << \"1 4 \" << c2 << '\\n';\n\t\t\tcout << \"1 5 \" << c3 << '\\n';\n\t\t\tcout << \"3 6 Y\\n\";\n\t\t\tcout << \"4 6 X\\n\";\n\t\t\tcout << \"5 6 Y\\n\";\n\t\t\tcout << \"1 6\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Impossible\\n\";\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\nusing namespace std;\nstruct p {\n\tint x, y, z;\n\tbool operator<(const p &A) const {\n\t\tif (x != A.x) return x < A.x;\n\t\tif (y != A.y) return y < A.y;\n\t\treturn z < A.z;\n\t}\n\tp& operator-=(const p &A) {\n\t\tx -= A.x; y -= A.y; z -= A.z;\n\t\treturn *this;\n\t}\n};\np cross(const p &A, const p &B) {\n\treturn { A.y*B.z - B.y*A.z, A.z*B.x - B.z*A.x, A.x*B.y - B.x*A.y };\n}\nstruct Plane {\n\tint a, b, c; // z = ax + by + c\n\tbool valid;\n\tPlane(p u, p v, p z) {\n\t\tvalid = false;\n\t\tu -= z; v -= z;\n\t\tp t = cross(u, v);\n\t\tif (t.z == 0 || t.x%t.z != 0 || t.y % t.z != 0) return;\n\t\ta = -t.x / t.z; b = -t.y / t.z;\n\t\tc = z.z - a * z.x - b * z.y;\n\t\tif (c < 0) return;\n\t\tvalid = true;\n\t}\n\tbool operator<(const Plane &A) const {\n\t\tif (a != A.a) return a < A.a;\n\t\tif (b != A.b) return b < A.b;\n\t\treturn c < A.c;\n\t}\n\tbool operator()(const p &A) const {\n\t\treturn a * A.x + b * A.y + c;\n\t}\n};\nvector<p> v;\nint chk[111];\nbool isunder(Plane c, p x) {\n\treturn c(x) <= x.z;\n}\nset<Plane> ans;\nint main() {\n\tint a, b, n, t;\n\tscanf(\"%d%d\", &a, &b);\n\tn = a * b;\n\tfor (int i = 1; i <= a; i++)for (int j = 1; j <= b; j++) {\n\t\tscanf(\"%d\", &t);\n\t\tv.push_back({ i, j, t });\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) for (int k = j + 1; k < n; k++) {\n\t\tPlane t(v[i], v[j], v[k]);\n\t\tif (!t.valid) continue;\n\t\tint succ = 1;\n\t\tfor (auto x : v) {\n\t\t\tif (!isunder(t, x)) {\n\t\t\t\tsucc = 0; break;\n\t\t\t}\n\t\t}\n\t\tif (succ) {\n\t\t\tchk[i] = chk[j] = chk[k] = 1;\n\t\t\tans.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (chk[i] == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"200 %d\\n\", 198 + ans.size());\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d Y\\n\", i + 100, i + 101);\n\tfor (auto t : ans) {\n\t\tprintf(\"%d %d %d\\n\", t.a + 1, 200 - t.b, t.c);\n\t}\n\tprintf(\"1 200\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#endif\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\nusing ld = long double;\n\nconstexpr int nax = 300;\nconstexpr int infty = 1000 * 1000 * 1000 + 5;\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\n\nconstexpr int MaxWsp = 13;\n\nint n, s, t, A, B;\nint D[11][11];\nint gdziex[MaxWsp + 1][MaxWsp + 1];\nvoid DajKrawedz(int a, int b, int d);\n\nvoid Algos() {\n  for (int x = 1; x <= A; x++) {\n    for (int y = 1; y <= B; y++) {\n      for (int a = 0; a <= MaxWsp; a++) {\n        for (int b = 0; b <= MaxWsp; b++) {\n          const int c = D[x][y] - a * x - b * y;\n          if (!(0 <= c and c <= 100)) {\n            goto out;\n          }\n          for (int x2 = 1; x2 <= A; x2++) {\n            for (int y2 = 1; y2 <= B; y2++) {\n              if (a * x2 + b * y2 + c < D[x2][y2]) {\n                goto out;\n              }\n            }\n          }\n          DajKrawedz(s, gdziex[a][b], c);\n          goto mam_juz;\n          out:;\n        }\n      }\n      mam_juz:;\n    }\n  }\n}\n\nmap<int, string> graf[nax];\n\nint mac[nax][nax];\nint odl[nax];\nbool nakol[nax];\n\nint Odl() {\n  for (int i = 0; i < n; i++) {\n    odl[i] = numeric_limits<int>::max();\n    nakol[i] = false;\n  }\n  odl[s] = 0;\n  queue<int> kol;\n  kol.push(s);\n  while (!kol.empty()) {\n    const int w = kol.front();\n    kol.pop();\n    nakol[w] = false;\n    for (int i = 0; i < n; i++) {\n      if (mac[w][i] == numeric_limits<int>::max()) continue;\n      const int o = odl[w] + mac[w][i];\n      if (o < odl[i]) {\n        odl[i] = o;\n        if (!nakol[i]) {\n          nakol[i] = true;\n          kol.push(i);\n        }\n      }\n    }\n  }\n  return odl[t];\n}\n\nbool Check() {\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      for (int k = 0; k < n; k++) {\n        for (int l = 0; l < n; l++) {\n          mac[k][l] = numeric_limits<int>::max();\n        }\n      }\n      for (int k = 0; k < n; k++) {\n        for (auto& it : graf[k]) {\n          if (it.second == \"X\") mac[k][it.first] = i;\n          else if (it.second == \"Y\") mac[k][it.first] = j;\n          else {\n            stringstream str(it.second);\n            int d;\n            str >> d;\n            mac[k][it.first] = d;\n          }\n        }\n      }\n      const int o = Odl();\n      if (o != D[i][j]) {\n        debug() << imie(i) imie(j) imie(D[i][j]) imie(o);\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid DajKrawedz(int a, int b, int d) {\n  assert(0 <= a and a < n);\n  assert(0 <= b and b < n);\n  assert(a != b);\n  graf[a][b] = to_string(d);\n}\n\nint DajId() {\n  assert(n < nax);\n  return n++;\n}\n\nint main() {\n  scanf(\"%d%d\", &A, &B);\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      scanf(\"%d\", &D[i][j]);\n    }\n  }\n\n  s = DajId();\n  t = DajId();\n  for (int y = 0; y <= MaxWsp; y++) {\n    int last = t;\n    for (int j = 0; j < y; j++) {\n      const int nowy = DajId();\n      graf[nowy][last] = \"Y\";\n      last = nowy;\n    }\n    for (int x = 0; true; x++) {\n      gdziex[x][y] = last;\n      if (x == MaxWsp) break;\n      const int nowy = DajId();\n      graf[nowy][last] = \"X\";\n      last = nowy;\n    }\n  }\n  Algos();\n  if (!Check()) {\n    printf(\"Impossible\\n\");\n    return 0;\n  }\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    m += (int) graf[i].size();\n  }\n  printf(\"Possible\\n\");\n  printf(\"%d %d\\n\", n, m);\n  for (int i = 0; i < n; i++) {\n    for (auto& it : graf[i]) {\n      printf(\"%d %d %s\\n\", i + 1, it.first + 1, it.second.c_str());\n    }\n  }\n  printf(\"%d %d\\n\", s + 1, t + 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint A, B;\nint D[11][11];\nint U[111][111];\nint idx[111][111];\nint cnt;\nvoid add(int s, int t) {\n    if (idx[s][t] == 0) idx[s][t] = cnt++;\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &A, &B);\n    REP (i, A) REP (j, B) scanf(\"%d\", &D[i][j]);\n\n    REP (i, A) REP (j, B) REP (s, 101) REP (t, 101) {\n\tamax(U[s][t], D[i][j] - s*(i+1) - t*(j+1));\n    }\n\n    cnt = 1;\n    add(0, 0);\n    REP (i, A) REP (j, B) {\n\tREP (s, 101) REP (t, 101) {\n\t    if (s*(i+1) + t*(j+1) + U[s][t] == D[i][j]) {\n\t\tadd(s, t);\n\t\tgoto BREAK;\n\t    }\n\t}\n\n\tputs(\"Impossible\");\n\treturn;\nBREAK:\n\t;\n    }\n\n    for (int s=101; s--;) for (int t=101; t--;) if (idx[s][t]) {\n\tif (s == 0 && t == 0) continue;\n\tif (s && idx[s-1][t]) continue;\n\tif (t && idx[s][t-1]) continue;\n\tif (s < t) add(s, t-1);\n\telse add(s-1, t);\n    }\n\n    puts(\"Possible\");\n    VI from, to, cst;\n    REP (s, 101) REP (t, 101) {\n\tif (idx[s][t]) {\n\t    if (idx[s][t+1]) {\n\t\tfrom.push_back(idx[s][t]);\n\t\tto.push_back(idx[s][t+1]);\n\t\tcst.push_back(-2);  // Y\n\t    }\n\t    if (idx[s+1][t]) {\n\t\tfrom.push_back(idx[s][t]);\n\t\tto.push_back(idx[s+1][t]);\n\t\tcst.push_back(-1);  // X\n\t    }\n\t    from.push_back(idx[s][t]);\n\t    to.push_back(cnt);\n\t    cst.push_back(U[s][t]);\n\t}\n    }\n\n    printf(\"%d %d\\n\", cnt, (int)from.size());\n    REP (i, from.size()) {\n\tprintf(\"%d %d \", from[i], to[i]);\n\tif (cst[i] == -2) puts(\"Y\");\n\telse if (cst[i] == -1) puts(\"X\");\n\telse printf(\"%d\\n\", cst[i]);\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible1\\n\";\n        return 0;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <limits>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n\nconstexpr int INF = std::numeric_limits<int>::max()>>2;\n\nint A, B;\nint d[10][10];\nint c[100][100];\n\nint main()\n{\n  scanf( \"%d%d\", &A, &B );\n  rep( i, A ) rep( j, B )\n    scanf( \"%d\", &d[i][j] );\n\n  rep( i, 101 ) rep( j, 101 )\n  {\n    rep( a, A ) rep( b, B )\n      c[i][j] = std::max( c[i][j], d[a][b]-i*(a+1)-j*(b+1) );\n  }\n\n  bool fl = true;\n  rep( a, A ) rep( b, B )\n  {\n    int D = INF;\n    rep( i, 101 ) rep( j, 101 )\n      D = std::min( D, i*(a+1)+j*(b+1)+c[i][j] );\n    \n    fl &= D == d[a][b];\n  }\n\n  if( !fl )\n    puts( \"Impossible\" );\n  else\n  {\n    puts( \"Possible\" );\n  \n    printf( \"%d %d\\n\", 202, 101*101+200 );\n\n    rep( i, 100 )\n      printf( \"%d %d X\\n\", i+1, i+2 );\n    rep( i, 100 )\n      printf( \"%d %d Y\\n\", i+102, i+103 );  \n    rep( i, 101 ) rep( j, 101 )\n      printf( \"%d %d %d\\n\", i+1, 202-j, c[i][j] );\n    printf( \"%d %d\\n\", 1, 202 );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 111\n\nconst int val = 100;\n\nint A, B, i, j, n, m;\nint v[maxN][maxN];\nint least[maxN][maxN];\nvector< pair<pair<int, int>, int> > edges;\n\nvoid execute(int x, int y, int need) {\n    int i, j;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            least[i][j] = max(least[i][j], need - (x * i + y * j));\n\n}\n\nbool check(int x, int y, int need) {\n    int i, j;\n\n    int act = 1 << 30;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            act = min(act, i * x + j * y + least[i][j]);\n\n    if (act != need) return false;\n    return true;\n}\n\nvoid add_edge(int x, int y, int v) {\n    edges.pb(mp(mp(x, y), v));\n    m++;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    cin >> A >> B;\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            cin >> v[i][j];\n\n            execute(i, j, v[i][j]);\n        }\n    }\n\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            if (!check(i, j, v[i][j])) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    add_edge(1, 2, 0);\n    for (i = 2; i + 1 <= val + 2; i++)\n        add_edge(i, i + 1, -1);\n\n    add_edge(1, val + 3, 0);\n    for (i = val + 3; i + 1 <= 2 * val + 3; i++)\n        add_edge(i, i + 1, -2);\n\n    add_edge(2 * val + 3, 2 * val + 4, 0);\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            add_edge(i + 2, j + val + 3, least[i][j]);\n\n    n = 2 * val + 4;\n\n    cout << n << ' ' << m << '\\n';\n    for (auto e : edges) {\n        cout << e.first.first << ' ' << e.first.second << ' ';\n        if (e.second == -1) cout << \"X\\n\";\n        if (e.second == -2) cout << \"Y\\n\";\n        if (e.second >= 0) cout << e.second << \"\\n\";\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+(ans[i].c!=0);\n\t\tnumn+=ans[i].a+ans[i].b+(ans[i].c!=0)-1;\n\t}\n\tnumn+=2;\n\tif (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tif (ans[i].c) printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'X'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\t{\n\t\t\t\t\tint c=s-a-b;\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 111\n\nconst int val = 100;\n\nint A, B, i, j, n, m;\nint v[maxN][maxN];\nint least[maxN][maxN];\nvector< pair<pair<int, int>, int> > edges;\n\nvoid execute(int x, int y, int need) {\n    int i, j;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            least[i][j] = max(least[i][j], need - (x * i + y * j));\n\n}\n\nbool check(int x, int y, int need) {\n    int i, j;\n\n    int act = 1 << 30;\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            act = min(act, i * x + j * y + least[i][j]);\n\n    if (act != need) return false;\n    return true;\n}\n\nvoid add_edge(int x, int y, int v) {\n    edges.pb(mp(mp(x, y), v));\n    m++;\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n   // freopen(\"test.out\",\"w\",stdout);\n\n    cin >> A >> B;\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            cin >> v[i][j];\n\n            execute(i, j, v[i][j]);\n        }\n    }\n\n    for (i = 1; i <= A; i++) {\n        for (j = 1; j <= B; j++) {\n            if (!check(i, j, v[i][j])) {\n                cout << \"Impossible\";\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    add_edge(1, 2, 0);\n    for (i = 2; i + 1 <= val + 2; i++)\n        add_edge(i, i + 1, -1);\n\n    for (i = val + 3; i + 1 <= 2 * val + 3; i++)\n        add_edge(i + 1, i, -2);\n\n    add_edge(val + 3, 2 * val + 4, 0);\n\n    for (i = 0; i <= val; i++)\n        for (j = 0; j <= val; j++)\n            add_edge(i + 2, j + val + 3, least[i][j]);\n\n    n = 2 * val + 4;\n\n    cout << n << ' ' << m << '\\n';\n    for (auto e : edges) {\n        cout << e.first.first << ' ' << e.first.second << ' ';\n        if (e.second == -1) cout << \"X\\n\";\n        if (e.second == -2) cout << \"Y\\n\";\n        if (e.second >= 0) cout << e.second << \"\\n\";\n    }\n\n    cout << 1 << ' ' << n;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\nbool P[101][101][101]; // X, Y, 1;\nstruct e {\n    int from, to, cost;\n};\n\nstruct edge {int to; ll cost;};\nstruct node {int pos; ll cost;};\nbool operator < (const node &a, const node &b){\n    return a.cost > b.cost;\n}\n\nvector<ll> dijkstra(vector<vector<edge>> &G, int root){\n    vector<ll> ret(G.size(), inf);\n    priority_queue<node> pq;\n    pq.push({root, 0});\n    while (!pq.empty()) {\n        node t = pq.top();\n        pq.pop();\n        \n        if (ret[t.pos] == inf) ret[t.pos] = t.cost;\n        else continue;\n        \n        for (edge e : G[t.pos]) {\n            pq.push({e.to, t.cost + e.cost});\n        }\n    }\n    return ret;\n}\n\n\nconst int N = 101;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> D(A, vector<int> (B));\n    rep(i, A) rep(j, B) cin >> D[i][j];\n    rep(i, N) rep(j, N) rep(k, N) P[i][j][k] = 1;\n    rep(i, N) rep(j, N) rep(k, N){\n        rep(a, A) rep(b, B){\n            if(D[a][b] > (a + 1) * i + (b + 1) * j + k) P[i][j][k] = 0;\n        }\n    }\n    \n    vector<e> ret;\n    rep(i, N) rep(j, N){\n        rep(k, N) {\n            if(P[i][j][k]){\n                ret.pb({i, 201 - j, k});\n                break;\n            }\n        }\n    }\n    \n    rep(a, A) rep(b, B){\n        vector<vector<edge>> G(202);\n        rep(i, N) G[i].pb({i + 1, a + 1});\n        rep(i, N) G[i + N].pb({i + N + 1, b + 1});\n        for(auto e: ret) {\n            G[e.from].pb({e.to, e.cost});\n        }\n        \n        auto dist = dijkstra(G, 0);\n        if(dist[201] != D[a][b]){\n            output(\"Impossible\");\n            return 0;\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 200 + (int)ret.size() << endl;\n    \n    rep(i, N){\n        cout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n    }\n    rep(i, N){\n        cout << i + N << \" \" << i + N + 1 << \" \" << \"Y\" << endl;\n    }\n    \n    for(auto e: ret) {\n        cout << e.from << \" \" << e.to << \" \" << e.cost << endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++){\n\t\t\tassert(b[k][l]+k*i+l*j<a[i][j]);\n\t\t\tif(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\t}\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll A, B;\n    cin >> A >> B;\n    vector<vector<ll>> d(A + 1, vector<ll>(B + 1));\n    for (ll i = 1; i <= A; i++) {\n        for (ll j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    constexpr ll MAX = 100;\n    vector<vector<ll>> f(MAX + 1, vector<ll>(MAX + 1, 0));\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            for (ll x = 1; x <= A; x++) {\n                for (ll y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n\n    for (ll x = 1; x <= A; x++) {\n        for (ll y = 1; y <= B; y++) {\n            ll D = LLONG_MAX;\n            for (ll a = 0; a <= MAX; a++) {\n                for (ll b = 0; b <= MAX; b++) {\n                    D = min(D, x * a + y * b + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    const ll N = (MAX + 1) * 2;\n    const ll M = MAX * (MAX + 2) + 2 * MAX + 1;\n    cout << N << \" \" << M << endl;\n    for (ll i = 0; i < N - 1; i++) {\n        if (i <= MAX) {\n            //次に辺を張る\n            if (i < MAX) {\n                cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n            }\n            //下側へ辺を張る\n            for (ll j = 0; j <= MAX; j++) {\n                cout << i + 1 << \" \" << j + MAX + 2 << \" \" << f[i][j] << endl;\n            }\n        } else {\n            //次に辺を張る\n            cout << i + 1 << \" \" << i + 2 << \" Y\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\nusing namespace std;\n#pragma region define\n#define M_PI 3.141592653589793238\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\n#pragma endregion\n#pragma region Inner Class\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n#pragma endregion\nusing mint = modint<998244353>;\n//using mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\n#pragma region mint\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nvem kai, inv_kai;\nvoid make_kai(int n) {\n\tkai = vem(n + 1, 1);\n\tinv_kai = vem(n + 1, 1);\n\trep(i, n) { kai[i + 1] = kai[i] * (i + 1); }\n\tinv_kai[n] = (mint)1 / kai[n];\n\tfor (int i = n; i > 0; i--) { inv_kai[i - 1] = inv_kai[i] * i; }\n}\nmint com(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r] * inv_kai[n - r];\n}\nmint per(int n, int r) {\n\tif (n < 0 || r < 0 || n < r) { return 0; }\n\treturn kai[n] * inv_kai[r];\n}\n#pragma endregion\nsigned main() {\n\tomajinai;\n\tint a, b; cin >> a >> b;\n\tvvel d(a, vel(b));\n\trep(i, a) { rep(j, b) { cin >> d[i][j]; } }\n\tvvel vx(a, vel(b,-1));\n\tvvel vy(a, vel(b,-1));\n\tvvel vex(a, vel(b,-1));\n\tvvel way;\n\trep(i, a) {\n\t\trep(j, b) {\n\t\t\tfor (int x = 0; x * (i + 1) <= d[i][j]; x++) {\n\t\t\t\tint ex = d[i][j] - x * (i + 1);\n\t\t\t\tfor (int y = 0; y * (j + 1) <= ex; y++) {\n\t\t\t\t\tint qex = ex - y * (j + 1);\n\t\t\t\t\tbool fl = true;\n\t\t\t\t\trep(mi, a) {\n\t\t\t\t\t\trep(mj, b) {\n\t\t\t\t\t\t\tif (d[mi][mj] > qex + x * (mi + 1) + y * (mj + 1)) {\n\t\t\t\t\t\t\t\tfl = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fl) {\n\t\t\t\t\t\tvx[i][j] = x;\n\t\t\t\t\t\tvy[i][j] = y;\n\t\t\t\t\t\tvex[i][j] = qex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vx[i][j]==-1) {\n\t\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tway.push_back({ vx[i][j],vy[i][j] + 101,vex[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tmk_uni(way);\n\tcout << 202 << \" \" << 200+way.size();\n\trep(i, 100) {\n\t\tcout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n\t\tcout << i + 102 << \" \" << i + 103 << \" Y\" << endl;\n\t}\n\tfor (auto v : way) {\n\t\tcout << v[0] + 1 << \" \" << 303-v[1] << \" \" << v[2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint A, B;\n\tcin >> A >> B;\n\tvector<vector<int> >d(A + 1, vector<int>(B + 1, 0));\n\tvector<vector<int> >noneed(A + 1, vector<int>(B + 1, 0));\n\tfor (int i = 1; i <= A; i++) {\n\t\tfor (int j = 1; j <= B; j++) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool f;\n\tint mn = 100;\n\tint sc = 0;\n\tint xx, yy;\n\tint xmax = 0;\n\tbool ok = true;\n\tvector<pair<pair<int, int>, int> > vp;\n\tfor (int a = 1; a <= A; a++) {\n\t\tfor (int b = 1; b <= B; b++) {\n\t\t\tif (noneed[a][b] == 0) {\n\t\t\t\txx = -1;\n\t\t\t\tmn = 10000;\n\t\t\t\tfor (int x = 0; x <= 100; x++) {\n\t\t\t\t\tfor (int y = 0; y <= 100; y++) {\n\t\t\t\t\t\tint z = d[a][b] - x*a - y*b;\n\t\t\t\t\t\tif (z < 0)break;\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tsc = 0;\n\t\t\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\t\t\tif (d[a2][b2] > x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (noneed[a2][b2] == 0 && d[a2][b2] == x*a2 + y*b2 + z) {\n\t\t\t\t\t\t\t\t\tsc--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tif (mn > sc) {\n\t\t\t\t\t\t\t\tmn = sc;\n\t\t\t\t\t\t\t\txx = x;\n\t\t\t\t\t\t\t\tyy = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (xx == -1) {\n\t\t\t\t\tcerr << a << \" \" << b << endl;\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int a2 = 1; a2 <= A; a2++) {\n\t\t\t\t\tfor (int b2 = 1; b2 <= B; b2++) {\n\t\t\t\t\t\tif (d[a2][b2] == xx*a2 + yy*b2 + d[a][b] - xx*a - yy*b) {\n\t\t\t\t\t\t\tnoneed[a2][b2] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txmax = max(xx, xmax);\n\t\t\t\tvp.push_back(make_pair(make_pair(xx, yy), d[a][b] - xx*a - yy*b));\n\t\t\t}\n\t\t}\n\t\tif (!ok)break;\n\t}\n\tif (ok) {\n\t\tint v = 0;\n\t\tsort(vp.begin(), vp.end());\n\t\tvector<int> ymax(xmax + 1, -1);\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\tymax[vp[i].first.first] = max(ymax[vp[i].first.first], vp[i].first.second);\n\t\t\t//cerr << vp[i].first.first << \" \" << vp[i].first.second << \" \" << vp[i].second << endl;\n\t\t}\n\t\tmap<pair<int, int>, int> mp;\n\t\tvector<pair<pair<int, int>, int> >ed;\n\t\tmp[make_pair(0, 0)] = 0;\n\t\tfor (int i = 0; i < xmax; i++) {\n\t\t\tv++;\n\t\t\ted.push_back(make_pair(make_pair(v - 1, v), -1));\n\t\t\tmp[make_pair(v, 0)] = v;\n\t\t}\n\t\tfor (int i = 0; i <= xmax; i++) {\n\t\t\tfor (int j = 0; j < ymax[i]; j++) {\n\t\t\t\tv++;\n\t\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(i, j)], v), -2));\n\t\t\t\tmp[make_pair(i, j + 1)] = v;\n\t\t\t}\n\t\t}\n\t\tv++;\n\t\tint fc = v;\n\t\tfor (int i = 0; i < vp.size(); i++) {\n\t\t\ted.push_back(make_pair(make_pair(mp[make_pair(vp[i].first.first, vp[i].first.second)], fc), vp[i].second));\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\n\t\tcout << fc + 1 << \" \" << (int)ed.size() << endl;\n\t\tfor (int i = 0; i < ed.size(); i++) {\n\t\t\tcout << ed[i].first.first + 1 << \" \" << ed[i].first.second + 1 << \" \";\n\t\t\tif (ed[i].second == -1) {\n\t\t\t\tcout << \"X\" << endl;\n\t\t\t}\n\t\t\telse if (ed[i].second == -2) {\n\t\t\t\tcout << \"Y\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << ed[i].second << endl;\n\t\t\t}\n\t\t}\n\t\tcout << 1 << \" \" << fc + 1 << endl;\n\t}\n\telse {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e5+10;\nconst int M=4e3+10;\n\nint n1,n2,w[12][12];\n\n\nint gw[205][205];\n\n\nvoid buildgraph(){\n        for(int u1=0;u1<=100;u1++)\n                for(int u2=0;u2<=100;u2++){\n                        int& rwei=gw[u1][201-u2];\n                        for(int w1=1;w1<=n1;w1++)\n                                for(int w2=1;w2<=n2;w2++)\n                                        rwei=max(rwei,w[w1][w2]-u1*w1-u2*w2);\n                }\n}\nint d[205];\nint dijkstra(int w1,int w2){\n        d[100]=200;\n        for(int i=101;i<=201;i++){\n                d[i]=d[i-1]+w2;\n                for(int u1=0;u1<=100;u1++) d[i]=min(d[i],gw[u1][i]+u1*w1);\n        }\n        return d[201];\n}\nint main(){\n        cin>>n1>>n2;\n        for(int i=1;i<=n1;i++)\n                for(int j=1;j<=n2;j++) cin>>w[i][j];\n        buildgraph();\n        for(int w1=1;w1<=n1;w1++)\n                for(int w2=1;w2<=n2;w2++){\n                        cout<<w1<<\" \"<<w2<<\" \"<<dijkstra(w1,w2)<<'\\n';\n                        if (dijkstra(w1,w2)!=w[w1][w2]) {\n                                cout<<\"Impossible\";\n                                return 0;\n                        }\n        }\n        cout<<\"Possible\\n202 10401\\n\";\n        for(int i=1;i<=100;i++) cout<<i<<\" \"<<i+1<<\" X\\n\";\n        for(int i=102;i<=201;i++) cout<<i<<\" \"<<i+1<<\" Y\\n\";\n        for(int i=0;i<=100;i++)\n                for(int j=101;j<=201;j++) cout<<i+1<<\" \"<<j+1<<\" \"<<gw[i][j]<<'\\n';\n        cout<<\"1 202\";\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long \n#define pb push_back\n//#define mp make_pair\n#define fr first\n#define sc second\n#define N ((ll)(2e6+100))\n#define MAX ((ll)(1e16+100))\n#define ARRS ((ll)(3e5+100))\n#define MOD ((ll)(1e9+7))\n#define M1 ((ll)(1001783))\n#define M2 ((ll)(1001941))\n#define M3 ((ll)(1002073))\n#define pb push_back\n\n\nll w[200][200];\nll fi[200][200];\nll f[105][105][105];\n\nstruct va{\n\tll a,b,c;\n};\nvector<va> v;\nint main(){\n\n\tll n,m;\n\tcin>>n>>m;\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=m; j++)\n\t\t\tcin>>w[i][j];\n\n\tfor(int a=0; a<=100; a++){\n\t\tfor(int b=0; b<=100; b++){\n\t\t\tfor(int c=0; c<=100; c++){\n\n\t\t\t\tf[a][b][c]=1;\n\t\t\t\tfor(int x=1; x<=n; x++)\n\t\t\t\t\tfor(int y=1; y<=m; y++)\n\t\t\t\t\t\tif(w[x][y]>x*a+y*b+c)\n\t\t\t\t\t\t\tf[a][b][c]=0;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a=0; a<=100; a++){\n\t\tfor(int b=0; b<=100; b++){\n\t\t\tfor(int c=0; c<=100; c++){\n\n\t\t\t\tfor(int x=1; x<=n; x++)\n\t\t\t\t\tfor(int y=1; y<=m; y++)\n\t\t\t\t\t\tif(f[a][b][c]&&w[x][y]==x*a+y*b+c)\n\t\t\t\t\t\t\tfi[x][y]=1;\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\tbool e=1;\n\tfor(int x=1; x<=n; x++)\n\t\tfor(int y=1; y<=m; y++)\n\t\t\te&=fi[x][y];\n\n\n\tif(e){\n\t\tfor(int i=1; i<=100; i++)\n\t\t\tv.pb({i,i+1,-1});\n\t\tfor(int j=1; j<=100; j++)\n\t\t\tv.pb({j+101,101+j+1,-2});\n\n\t\tfor(int a=0; a<=100; a++)\n\t\t\tfor(int b=0; b<=100; b++)\n\t\t\t\tfor(int c=0; c<=100; c++)\n\t\t\t\t\tif(f[a][b][c])\n\t\t\t\t\t\t{v.pb({a+1,202-b,c});break;}\n\n\t\tcout<<\"Possible\\n\";\n\t\tcout<<202<<\" \"<<v.size()<<endl;\n\t\tfor(auto x:v)\n\t\t\tif(x.c==-1)\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<\"X\"<<endl;\n\t\t\telse if(x.c==-2)\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<\"Y\"<<endl;\n\t\t\telse\n\t\t\t\tcout<<x.a<<\" \"<<x.b<<\" \"<<x.c<<endl;\n\t\tcout<<1<<\" \"<<202;\n\t}\n\telse {\n\t\tcout<<\"Impossible\";\n\t}\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=300;\nint a,b,d[maxn][maxn],w[maxn][maxn];\n\nint main(){\n\tcin>>a>>b;\n\tfor(int x=1;x<=a;++x)\n\t\tfor(int y=1;y<=b;++y){\n\t\t\tcin>>d[x][y];\n\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\tif(w[i][j]<d[x][y]-i*x-j*y)\n\t\t\t\t\t\tw[i][j]=d[x][y]-i*x-j*y;\n\t\t}\n\tfor(int x=1;x<=a;++x)\n\t\tfor(int y=1;y<=b;++y){\n\t\t\tint dis=1e9;\n\t\t\tfor(int i=0;i<=100;++i)\n\t\t\t\tfor(int j=0;j<=100;++j)\n\t\t\t\t\tif(dis>i*x+j*y+w[i][j])\n\t\t\t\t\t\tdis=i*x+j*y+w[i][j];\n\t\t\tif(dis!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",202,2*100+101*101);\n\tfor(int i=1;i<=100;++i)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=1;i<=100;++i)\n\t\tprintf(\"%d %d Y\\n\",i+102,i+101);\n\tfor(int i=0;i<=100;++i)\n\t\tfor(int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,w[i][j]);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\n#define min(x,y) (x<y?x:y)\n#define max(x,y) (x>y?x:y)\nconst int M=305;\n\nint n,m,f[M][M],d[M][M];\n\nint read(){\n\tint x=0,y=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-') y=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*y;\n}\n\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tint now=1e9+7;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<=201;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, d[102][102], a, b, ok[102][102];\nstruct skrr {\n  int i, j, c;\n} v[20002];\n\nint main()\n{\n  cin >> a >> b;\n  for (int i = 1; i <= a; i++)\n    for (int j = 1; j <= b; j++)\n      cin >> d[i][j];\n  for (int i = 0; i <= 100; i++)\n    for (int j = 0; j <= 100; j++) {\n      int mx = 0;\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          mx = max (mx, d[x][y] - i * x - j * y);\n      v[++m] = {i + 1, 202 - j, mx};\n      for (int x = 1; x <= a; x++)\n        for (int y = 1; y <= b; y++)\n          if (mx + i * x + j * y == d[x][y])\n            ok[x][y] = 1;\n    }\n  for (int x = 1; x <= a; x++)\n    for (int y = 1; y <= b; y++)\n    if (!ok[x][y]) {\n      cout << \"Impossible\";\n      return 0;\n    }\n  cout << \"Possible\\n\";\n  cout << \"202 \" << m + 200 << \"\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i << \" \" << i + 1 << \" X\\n\";\n  for (int i = 1; i <= 100; i++)\n    cout << i + 101 << \" \" << i + 102 << \" Y\\n\";\n  for (int i = 1; i <= m; i++)\n    cout << v[i].i << \" \" << v[i].j << \" \" << v[i].c << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nint d[N][N], f[N][N];\nstruct data {\n  int x, y, w;\n} g[N * N * 10];\nint dx[N], dy[N];\n\nint check(int x, int y) {\n  int ans = 1e9;\n  for(int i = 0; i <= 100; ++i)\n   for(int j = 0; j <= 100; ++j)\n    ans = min(ans, i * x + j * y + f[i][j]);\n  return ans;\n}\n\nint main() {\n  int A, B;\n  cin >> A >> B;\n  for(int i = 1; i <= A; ++i)\n    for(int j = 1; j <= B; ++j)\n      scanf(\"%d\", &d[i][j]);\n  for(int i = 0; i <= 100; ++i)\n    for(int j = 0; j <= 100; ++j) {\n      for(int k = 1; k <= A; ++k)\n       for(int t = 1; t <= B; ++t)\n        f[i][j] = max(f[i][j], d[k][t] - i * k - j * t);\n    }\n  for(int i = 1; i <= A; ++i)\n    for(int j = 1; j <= B; ++j) {\n      if(check(i, j) != d[i][j]) {\n        puts(\"Impossible\");\n        exit(0);\n      }\n    }\n  puts(\"Possible\");\n  int tot = 0, res = 0;\n  int S = ++tot;\n  dx[0] = S;\n  for(int i = 1; i <= 100; ++i) {\n    dx[i] = ++tot;\n    g[++res] = (data){dx[i - 1], dx[i], -1};\n  }\n  int T = ++tot;\n  dy[0] = T;\n  for(int i = 1; i <= 100; ++i) {\n    dy[i] = ++tot;\n    g[++res] = (data){dy[i - 1], dy[i], -2};\n  }\n  for(int i = 0; i <= 100; ++i)\n    for(int j = 0; j <= 100; ++j) {\n      g[++res] = (data){dx[i], dy[j], f[i][j]};\n    }\n  printf(\"%d %d\\n\", tot, res);\n  for(int i = 1; i <= res; ++i) {\n    printf(\"%d %d \", g[i].x, g[i].y);\n    if(g[i].w < 0) {\n      if(g[i].w == -1) puts(\"X\");\n      else puts(\"Y\");\n    } else printf(\"%d\\n\", g[i].w);\n  }\n  printf(\"%d %d\\n\", S, T);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - ((t + 1) * (i) + (k + 1) * (j)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_A=10,MAX_B=10,INF=1e5;\nint A,B,d[MAX_A][MAX_B];\n\nint f[101][101];\n\nint main(){\n\tcin>>A>>B;\n\tREP(i,A)REP(j,B){\n\t\tcin>>d[i][j];\n\t}\n\tREP(a,101){\n\t\tREP(b,101){\n\t\t\tREP(x,A){\n\t\t\t\tREP(y,B){\n\t\t\t\t\tf[a][b]=max(f[a][b],d[x][y]-(x+1)*a-(y+1)*b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool ans=true;\n\tREP(x,A){\n\t\tREP(y,B){\n\t\t\tint td=INF;\n\t\t\tREP(a,101){\n\t\t\t\tREP(b,101){\n\t\t\t\t\ttd=min(td,(x+1)*a+(y+1)*b+f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (td!=d[x][y]){\n\t\t\t\tans=false;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans){\n\t\tcout<<\"Possible\"<<endl<<101*2<<\" \"<<101*101+200<<endl;\n\t\tREP(i,100){\n\t\t\tcout<<i+1<<\" \"<<i+2<<\" X\"<<endl;\n\t\t}\n\t\tREP(i,100){\n\t\t\tcout<<i+102<<\" \"<<i+103<<\" Y\"<<endl;\n\t\t}\n\t\tREP(a,101){\n\t\t\tREP(b,101){\n\t\t\t\tcout<<a+1<<\" \"<<202-b<<\" \"<<f[a][b]<<endl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tcout<<\"Impossible\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nvector<T> Vec(int n, T v)\n{\n    return vector<T>(n, v);\n}\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = (ll)1e9 + 7LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int A, B;\n    cin >> A >> B;\n    vector<vector<int>> d(A, vector<int>(B, 0));\n    for (int i = 0; i < A; i++) {\n        for (int j = 0; j < B; j++) {\n            cin >> d[i][j];\n        }\n    }\n    constexpr int MAX = 100;\n    vector<vector<int>> c(MAX + 1, vector<int>(MAX + 1, -1));\n    int M = 0;\n    constexpr int N = MAX + 1;\n    for (int a = 0; a <= MAX; a++) {\n        for (int b = 0; b <= MAX; b++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    c[a][b] = max(c[a][b], d[x - 1][y - 1] - x * a - y * b);\n                }\n            }\n            if (c[a][b] >= 0) {\n                M++;\n            }\n        }\n    }\n\n    for (int a = 1; a <= A; a++) {\n        for (int b = 1; b <= B; b++) {\n            int mini = INF<int>;\n            for (int i = 0; i <= MAX; i++) {\n                for (int j = 0; j <= MAX; j++) {\n                    mini = min(mini, a * i + b * j + c[i][j]);\n                }\n            }\n            if (mini != d[a - 1][b - 1]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n\n    constexpr int S = 1;\n    constexpr int T = 2 * MAX + 2;\n    cout << \"Possible\" << endl;\n    cout << T << \" \" << M + 2 * MAX << endl;\n    for (int i = 0; i < MAX; i++) {\n        cout << i + 1 << \" \" << i + 2 << \" \"\n             << \"X\" << endl;\n        cout << N + i + 1 << \" \" << N + i + 2 << \" \"\n             << \"Y\" << endl;\n    }\n    for (int i = 0; i <= MAX; i++) {\n        for (int j = 0; j <= MAX; j++) {\n            if (c[i][j] >= 0) {\n                cout << i + 1 << \" \" << 2 * MAX + 2 - j << \" \" << c[i][j] << endl;\n            }\n        }\n    }\n    cout << S << \" \" << T << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint n,m,cnt,ans;\nint w[110][110],v[110][110];\nbool flag=1,fl;\nint main()\n{\n\t//freopen(\"ans.txt\",\"w\",stdout);\n\tint i,s,a,b,j,k,c;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\tfor(s=1;s<=m;s++)\n\t{\n\t\tscanf(\"%d\",&w[i][s]);\n\t\tfor(k=0;k<=100;k++)\n\t\tfor(j=0;j<=100;j++)v[k][j]=max(v[k][j],w[i][s]-i*k-s*j);\n\t}\n\tfor(i=1;i<=n && flag;i++)\n\tfor(s=1;s<=m && flag;s++)\n\t{\n\t\tc=1e9;\n\t\tfor(k=0;k<=100;k++)\n\t\tfor(j=0;j<=100;j++)c=min(v[k][j]+i*k+s*j,c);\n\t\tif(c!=w[i][s])flag=0;\n\t}\n\tif(!flag){printf(\"Impossible\");return 0;}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1),printf(\"%d %d Y\\n\",i+101,i+102);\n\tfor(i=0;i<=100;i++)\n\tfor(s=0;s<=100;s++)printf(\"%d %d %d\\n\",1+i,102+s,v[i][100-s]);\n\tprintf(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint d[11][11];\nint val[11][11];\n\nusing edge = tuple<int, int, int>;\nvector<edge> graph;\n\nusing edge2 = tuple<int, int, char>;\nvector<edge2> graph2;\n\n\nint main(void) {\n\tint a, b;\n\tcin >> a >> b;\n\n\trep(i, a)rep(j, b) cin >> d[i][j];\n\trep(i, a)rep(j, b) val[i][j] = 1010;\n\n\tconst int total = 15;\n\tconst int n = total * total + 1;\n\tconst int s = 1, t = n;\n\n\trep(ca, total)rep(cb, total) {\n\t\tint tmp[11][11];\n\t\trep(x, a)rep(y, b) tmp[x][y] = ca * (x + 1) + cb * (y + 1);\n\t\tint cmin = 1010;\n\t\trep(x, a)rep(y, b) chmin(cmin, tmp[x][y] - d[x][y]);\n\t\tif (cmin < 0 or cmin > 100) continue;\n\t\t//cerr << ca << \" \" << cb << endl;\n\t\trep(x, a)rep(y, b) chmin(val[x][y], tmp[x][y] + cmin);\n\t\tconst int idx = total * ca + cb;\n\t\tgraph.push_back(edge(idx, t, cmin));\n\t}\n\n\trep(ca, total - 1) {\n\t\tgraph2.push_back(edge(total * ca, total * (ca + 1), 'X'));\n\t}\n\n\trep(ca, total)rep(cb, total - 1) {\n\t\tgraph2.push_back(edge(total * ca + cb , total * ca + cb + 1, 'Y'));\n\t}\n\n\n\trep(x, a)rep(y, b) {\n\t\t//cerr << val[x][y] << \" \" << d[x][y] << endl;\n\t\tif (val[x][y] != d[x][y]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tconst int m = graph.size() + graph2.size();\n\tcout << n << \" \" << m << endl;\n\tfor (auto &it : graph) {\n\t\tint a, b, c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tfor (auto &it : graph2) {\n\t\tint a, b;\n\t\tchar  c;\n\t\ttie(a, b, c) = it;\n\t\tcout << a + 1 << \" \" << b + 1 << \" \" << c << endl;\n\t}\n\n\tcout << s << \" \" << t << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint A,B;\nint C[12][12];\nint D[101][101];\nint DX[12][12];\nint DY[12][12];\nint NV;\nint V[303][303];\n\nint K=100;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(V);\n\t\n\tcin>>A>>B;\n\tfor(x=1;x<=A;x++) {\n\t\tfor(y=1;y<=B;y++) {\n\t\t\tcin>>C[x][y];\n\t\t}\n\t}\n\t\n\tvector<int> Xs,Ys;\n\tNV=1;\n\tXs.push_back(NV);\n\tFOR(i,K) {\n\t\tV[NV][NV+1]=-2;\n\t\tNV++;\n\t\tXs.push_back(NV);\n\t}\n\tNV++;\n\tYs.push_back(NV);\n\tFOR(i,K) {\n\t\tV[NV+1][NV]=-3;\n\t\tNV++;\n\t\tYs.push_back(NV);\n\t}\n\t\n\tfor(x=0;x<=K;x++) {\n\t\tfor(y=0;y<=K;y++) {\n\t\t\tint ret=0;\n\t\t\tfor(i=1;i<=A;i++) {\n\t\t\t\tfor(j=1;j<=B;j++) {\n\t\t\t\t\tret=max(ret,C[i][j]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tD[x][y]=V[Xs[x]][Ys[y]]=ret;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=A;i++) {\n\t\tfor(j=1;j<=B;j++) {\n\t\t\tint mi=1010;\n\t\t\tfor(x=0;x<=K;x++) {\n\t\t\t\tfor(y=0;y<=K;y++) {\n\t\t\t\t\tmi=min(mi,x*i+j*y+D[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi!=C[i][j]) return _P(\"Impossible\\n\");\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\t\n\tint cnt=0;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) cnt++;\n\tcout<<\"Possible\"<<endl;\n\tcout<<NV<<\" \"<<cnt<<endl;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) {\n\t\tcout<<x<<\" \"<<y<<\" \";\n\t\tif(V[x][y]==-2) cout<<\"X\"<<endl;\n\t\tif(V[x][y]==-3) cout<<\"Y\"<<endl;\n\t\tif(V[x][y]>=0) cout<<V[x][y]<<endl;\n\t}\n\tcout<<Xs[0]<<\" \"<<Ys[0]<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            rep(k,i+1,a){\n                Max(dx,(d[k][j]-d[i][j]+k-i-1)/(k-i));\n            }\n            rep(l,j+1,b){\n                Max(dy,(d[i][l]-d[i][j]+l-j-1)/(l-j));\n            }\n            vector<pipi> w;\n            rep(k,0,100){\n                rep(l,0,100){\n                    int rrr=0;\n                    rep(ii,i,a){\n                        rep(jj,j,b){\n                            int sa=k*(ii-i)+l*(jj-j);\n                            if(d[i][j]+sa<d[ii][jj]){\n                                rrr=1;\n                                break;\n                            }\n                        }\n                        if(rrr)break;\n                    }\n                    if(rrr==0){\n                        w.push_back({(i+1)*k+(j+1)*l,{k,l}});\n                    }\n                }\n            }\n            sort(w.begin(),w.end());\n            dx=w[0].second.first;\n            dy=w[0].second.second;\n            //cout<<dx<<\" \"<<dy<<endl;\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(101, vector<int>(101, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 0; i <= a; ++i) {\n      for (int j = 0; j <= b; ++j) {\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[i][j] - i * k - j * l);\n          }\n        }\n      }\n    }\n    for (int i = 0; i <= a; ++i) {\n      for (int j = 0; j <= b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= 100; ++k) {\n          for (int l = 0; l <= 100; ++l) {\n            minDistance = min(minDistance, a * k + b * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[a][b]) impossible();\n      }\n    }\n    cout << \"202 10401\" << endl;\n    for (int k = 0; k <= 100; ++k) {\n      for (int l = 0; l <= 100; ++l) {\n        cout << k + 1 << ' ' << 102 + l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < 100; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + 102 << ' ' << i + 103 << \" Y\" << endl;\n    }\n\n    cout << \"1 202\" << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=305,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint A,B,S,T,d[15][15];\nint f[105][105],ans[N];\nbool vis[N],use[105][105];\nvector<pii> g[N];\n\nint X[N],Y[N];\nvector<pair<pii,int> > edge;\ninline void push(int x,int y,int k){\n\tedge.pb(mp(mp(x,y),k));\n}\ninline void putans(){\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",300,SZ(edge));\n\tfor(auto i:edge){\n\t\tprintf(\"%d %d \",i.FF.FF,i.FF.SS);\n\t\tif(i.SS>=0) printf(\"%d\\n\",i.SS); else if(i.SS==-1) puts(\"X\"); else puts(\"Y\");\n\t}\n\tprintf(\"%d %d\\n\",S,T);\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tread(A,B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tread(d[i][j]);\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++){\n\t\t\t\t\tint tmp=a*i+b*j;\n\t\t\t\t\tgmax(f[a][b],d[i][j]-tmp);\n\t\t\t\t}\n\t\t}\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tbool isok=0;\n\t\t\tfor(int a=0;a<=100;a++)\n\t\t\t\tfor(int b=0;b<=100;b++)\n\t\t\t\t\tif(f[a][b]+a*i+b*j==d[i][j])\n\t\t\t\t\t\tisok=1,use[a][b]=1;\n\t\t\tif(!isok){puts(\"Impossible\");return 0;}\n\t\t}\n\tS=233;T=234;\n\tX[0]=S;Y[0]=T;\n\tfor(int i=1;i<=100;i++)\n\t\tX[i]=i;\n\tfor(int i=1;i<=100;i++)\n\t\tY[i]=i+105;\n\tfor(int i=0;i<100;i++)\n\t\tpush(X[i],X[i+1],-1);\n\tfor(int i=0;i<100;i++)\n\t\tpush(Y[i+1],Y[i],-2);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tif(use[i][j]) push(X[i],Y[j],f[i][j]);\n\tputans();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b){\n\t\tscanf(\"%d\",d[i]+j);\n\t\tif(i>1&&d[i][j]<d[i-1][j]) return puts(\"Impossible\"),0;\n\t\tif(j>1&&d[i][j]<d[i][j-1]) return puts(\"Impossible\"),0;\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,102,200) add(i,i-1,inf+2);\n\trep(i,1,a-1){\n\t\trep(j,1,b-1){\n\t\t\tint kx=d[i+1][j]-d[i][j],ky=d[i][j+1]-d[i][j];\n\t\t\tint idx=(!kx?s:kx),idy=(!ky?t:100+ky);\n\t\t\tint val=d[i][j]-kx*i-ky*j;\n\t\t\tadd(idx,idy,val);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"201 202\\n\");\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nint main(void){\n  int n = 100;\n  int a, b;\n  int f = 1;\n  cin >> a >> b;\n  vector<vi> d(a, vi(b));\n  vector<vi> finished(a, vi(b, 0));\n  REP(i, a) REP(j, b) cin >> d[i][j];\n  vector<vector<pii> > g(2 * n + 2);\n  REP(i, n + 1) {\n    REP(j, n + 1) {\n      int min_cost = 0;\n      REP(k, a) {\n        REP(l, b) {\n          int x = k * i + l * j;\n          int y = x - d[k][l];\n          if(y < 0) min_cost = max(min_cost, -y);\n        }\n      }\n      g[i+10].push_back(pii(220 - j, min_cost));\n      REP(k, a) {\n        REP(l, b){\n          if(k * i + l * j + min_cost == d[k][l]) finished[k][l] = 1;\n        }\n      }\n    }\n  }\n  REP(i, a) REP(j, b) if(!finished[i][j]) f = 0;\n\n  if(!f) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  int m = 2 * n + 1;\n  REP(i, g.size()) m += g[i].size();\n  cout << \"300 \" << m << endl;\n  cout << \"1 10 0\" << endl;\n  cout << \"220 2 0\" << endl;\n  REP(i, 99) {\n    cout << i + 10 << \" \" << i + 11 << \" X\" << endl;\n    cout << i + 120 << \" \" << i + 121 << \" Y\" << endl;\n  }\n  REP(i, g.size()) {\n    REP(j, g[i].size()) {\n      cout << i << \" \" << g[i][j].first << \" \" << g[i][j].second << endl;\n    }\n  }\n  cout << \"1 2\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[0].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\n\n\nsigned main(){\n\n    int A, B; cin >> A >> B;\n    mat d(A, vec(B));\n    REP(i, A) readv(d[i]);\n\n    mat c(101, vec(101, 0));\n    REP(i, A){\n        REP(j, B){\n            REP(Nx, 101) REP(Ny, 101){\n                c[Nx][Ny] = max(c[Nx][Ny], d[i][j] - (i + 1) * Nx - (j + 1) * Ny);\n            }\n        }\n    }\n\n    REP(i, A){\n        REP(j, B){\n            int tmp = INF;\n            REP(Nx, 101) REP(Ny, 101){\n                tmp = min(tmp, (i + 1) * Nx + (j + 1) * Ny + c[Nx][Ny]);\n            }\n            if(tmp != d[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 202 << \" \" << 200 + 101 * 101 << endl;\n    REP(i, 100) cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n    REP(i, 100) cout << i + 102 << \" \" << i + 103 << \" Y\" << endl;\n    REP(Nx, 101) REP(Ny, 101) cout << Nx + 1 << \" \" << 202 - Ny << \" \" << c[Nx][Ny] << endl;\n    cout << \"1 202\" << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n#define N 305\n#define db double\n#define ll long long\nint A,B,dist[12][12],f[N][N],d;\nint cal(int a,int b)\n{\n\tint res=0;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) res=max(res,dist[i][j]-i*a-j*b);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) scanf(\"%d\",&dist[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++) f[i][j]=cal(i,j);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)\n\t\t{\n\t\t\td=1e9;\n\t\t\tfor(int i2=0;i2<=100;i2++)\n\t\t\t\tfor(int j2=0;j2<=100;j2++)\n\t\t\t\t\td=min(d,f[i2][j2]+i*i2+j*j2);\n\t\t\tif(d^dist[i][j]) {puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"202 10401\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++) if(f[i][j])\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\tfor(int i=1;i<=100;i++) printf(\"%d %d Y\\n\",102+i,101+i);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a <= N; ++a)\n\t\t\t\tfor(int b = 0; b <= N; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a <= N; ++a)\n\t\t\t\tfor(int b = 0; b <= N; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"Impossible\");\n\telse\n\t{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + (N+1)*(N+1));\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a <= N; ++a)\n\t\t\tfor(int b = 0; b <= N; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 210;\nint d[N][N];\n\nstruct Edge {\n    int u, v;\n    string c;\n};  \n\nint f[N][N];\n\nint g[N][N];\n\n//change to 100!\nconst int LEN = 100;\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int A, B;\n    cin >> A >> B;\n    for (int i = 1; i <= A; ++i)\n        for (int j = 1; j <= B; ++j)\n            cin >> d[i][j];    \n\n    int S = 1;\n    int T = 2;\n    int ptr = 3;\n    vector <Edge> ans;\n\n    int lx = ptr;\n    ans.app({S, ptr, \"X\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"X\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"X\"});\n    int rx = ptr - 1;\n\n    \n    int ly = ptr;\n    ans.app({S, ptr, \"Y\"});\n    ++ptr;\n    for (int i = 1; i <= LEN; ++i) {\n        ans.app({ptr - 1, ptr, \"Y\"});\n        ++ptr;\n    }   \n    ans.app({ptr - 1, T, \"Y\"});\n    int ry = ptr - 1;\n    \n    for (int i = 1; i <= A; ++i) {\n        for (int j = 1; j <= B; ++j) {\n            for (int x = 0; x <= 100; ++x) {\n                for (int y = 0; y <= 100; ++y) {\n\n                    int have = x * i + y * j;\n                    if (have < d[i][j]) {\n                        f[x][y] = max(f[x][y], d[i][j] - have);\n                    }   \n                \n                }   \n            }   \n        }   \n    }   \n\n    for (int x = 0; x <= LEN/2; ++x) {\n        for (int y = 0; y <= LEN/2; ++y) {\n\n            int u = lx + x - 1;\n            if (x == 0)\n                u = S;\n\n            int v = ry - y + 1;\n            if (y == 0)\n                v = T;\n\n            ans.app({u, v, to_string(f[x][y])});\n        }   \n    }   \n\n    for (int x = 1; x <= A; ++x) {\n        for (int y = 1; y <= B; ++y) {\n            const int INF = 1e9+7;\n            for (int i = 0; i < N; ++i)\n                for (int j = 0; j < N; ++j)\n                    g[i][j] = INF;\n            for (auto e : ans) {\n                if (e.c == \"X\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], x);\n                }   \n                else if (e.c == \"Y\") {\n                    g[e.u][e.v] = min(g[e.u][e.v], y);\n                }\n                else {\n                    g[e.u][e.v] = min(g[e.u][e.v], stoi(e.c));\n                }   \n            }\n            \n            for (int k = 0; k < N; ++k)\n                for (int u = 0; u < N; ++u)\n                    for (int v = 0; v < N; ++v)\n                        g[u][v] = min(g[u][v], g[u][k]+g[k][v]);       \n\n            if (g[S][T] != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                exit(0);\n            }   \n        }\n    }    \n    \n    for (auto e : ans) {\n        if (e.u == e.v) {\n            cout << \"LMAO\" << endl;\n            exit(1);                        \n        }   \n    }   \n    for (int i = 0; i < ans.size(); ++i)\n        for (int j = i + 1; j < ans.size(); ++j) {\n            if (ans[i].u == ans[j].u && ans[i].v == ans[j].v) {\n                cout << \"LMAO\" << endl;\n                exit(1);\n            }   \n        }   \n\n    cout << \"Possible\" << endl;\n    for (auto e : ans)\n        cout << e.u << ' ' << e.v << ' ' << e.c << endl;\n    cout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint constexpr MAXVAL=3;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=std::min(sum,MAXVAL);++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint maxd1=INT_MIN;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmaxd1=std::max(maxd1,d1[x][y]-=(x+1)*nx+(y+1)*ny);\n\t\t\t}\n\t\t\tif(maxd1<0)\n\t\t\t\tcontinue; // useless line (all value strictly > d)\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==maxd1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tconnval[nx][ny]=maxd1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tint const source=1;\n\tint const dest=MAXVAL+2;\n\t// 1 --(X)-- 2 --(X)-- ... MAXVAL+1\n\t//\n\t// MAXVAL+2 --(Y)-- ... 2*MAXVAL+2\n\n\tint const nnode=2*MAXVAL+2;\n\n\tassert(nnode<=300);\n\tstd::cout<<\"Possible\\n\"<<nnode<<' '<<MAXVAL*2+n_connedge<<'\\n';\n\n\tfor(int i=0;i<MAXVAL;++i){\n\t\tstd::cout<<i+1<<' '<<i+2<<\" X\\n\";\n\t\tstd::cout<<i+MAXVAL+2<<' '<<i+MAXVAL+3<<\" Y\\n\";\n\t}\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const v=connval[nx][ny];\n\t\tif(v>=0)\n\t\t\tstd::cout<<1+nx<<' '<<MAXVAL+2+ny<<' '<<connval[nx][ny]<<'\\n';\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10 + 5;\n\nint n, m, d[N][N], f[105][105];\n\nint main() {\n    printf(\"%d\\n\", 101 * 101);\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, 103 + i, 102 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 102 + j, f[i][j]);\n    puts(\"1 102\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint A, B;\nint d[20][20];\n\nint N, M;\nint cost[20][20];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> A >> B;\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) cin >> d[x][y];\n\n    N = A + B + 2;\n    M = A + B + (A + 1) * (B + 1);\n\n    rep(i, A + 1) rep(j, B + 1) FOR(x, 1, A + 1) FOR(y, 1, B + 1)\n        chmax(cost[i][j], d[x][y] - i * x - j * y);\n\n    FOR(x, 1, A + 1) FOR(y, 1, B + 1) {\n        int mn = 1 << 30;\n        rep(i, A + 1) rep(j, B + 1) chmin(mn, x * i + y * j + cost[i][j]);\n        if(mn != d[x][y]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Possible\\n\";\n\n    cout << N << \" \" << M << \"\\n\";\n\n    rep(i, A) cout << i + 1 << \" \" << i + 2 << \" X\\n\";\n    rep(j, B) cout << A + j + 2 << \" \" << A + j + 3 << \" Y\\n\";\n\n    rep(i, A + 1) rep(j, B + 1) cout << i + 1 << \" \" << N - j << \" \"\n                                     << cost[i][j] << \"\\n\";\n\n    cout << \"1 \" << N << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            rep(k,i+1,a){\n                Max(dx,(d[k][j]-d[i][j]+k-i-1)/(k-i));\n            }\n            rep(l,j+1,b){\n                Max(dy,(d[i][l]-d[i][j]+l-j-1)/(l-j));\n            }\n            vector<pipi> w;\n            rep(k,0,100){\n                rep(l,0,100){\n                    int rrr=0;\n                    rep(ii,0,a){\n                        rep(jj,0,b){\n                            int sa=k*(ii-i)+l*(jj-j);\n                            if(d[i][j]+sa<d[ii][jj]){\n                                rrr=1;\n                                break;\n                            }\n                        }\n                        if(rrr)break;\n                    }\n                    if(rrr==0){\n                        w.push_back({(i+1)*k+(j+1)*l,{k,l}});\n                    }\n                }\n            }\n            sort(w.begin(),w.end());\n            dx=w[0].second.first;\n            dy=w[0].second.second;\n            //cout<<dx<<\" \"<<dy<<endl;\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 200 << \" \" << 10200 << \"\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n\treturn puts(\"Impossible\"),0;\n\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b){\n\t\tscanf(\"%d\",d[i]+j);\n\t\tif(i>1&&d[i][j]<d[i-1][j]) return puts(\"Impossible\"),0;\n\t\tif(j>1&&d[i][j]<d[i][j-1]) return puts(\"Impossible\"),0;\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,102,200) add(i,i-1,inf+2);\n\trep(i,1,a-1){\n\t\trep(j,1,b-1){\n\t\t\tint kx=d[i+1][j]-d[i][j],ky=d[i][j+1]-d[i][j];\n\t\t\tint idx=(!kx?s:kx),idy=(!ky?t:100+ky);\n\t\t\tint val=d[i][j]-kx*i-ky*j;\n\t\t\tadd(idx,idy,val);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"201 202\\n\");\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    int matrix[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++) cin >> matrix[i][j];\n    }\n    int mnx[a][b], mny[a][b], mxx[a][b], mxy[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            mnx[i][j] = 0;\n            mny[i][j] = 0;\n            mxx[i][j] = matrix[i][j] / (i+1);\n            mxy[i][j] = matrix[i][j] / (j+1);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b-1; j++){\n            int D = matrix[i][j+1] - matrix[i][j];\n            mny[i][j] = max(mny[i][j], D);\n            mxy[i][j+1] = min(mxy[i][j+1], D);\n        }\n    }\n    for (int i=0; i < a-1; i++){\n        for (int j=0; j < b; j++){\n            int D = matrix[i+1][j] - matrix[i][j];\n            mnx[i][j] = max(mnx[i][j], D);\n            mxx[i+1][j] = min(mxx[i+1][j], D);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            if (mnx[i][j] > mxx[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mny[i][j] > mxy[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mnx[i][j] * (i+1) + mny[i][j] * (j+1) > matrix[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    //cout << mxx[0][1] << \" \" << mxy[0][1] << endl;\n    int sv = 3;\n    vector<pair<int, int> > reb;\n    vector<int> wh;\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            int K, L, res = -1;\n            for (int k=mnx[i][j]; k <= mxx[i][j]; k++){\n                for (int l=mny[i][j]; l <= mxy[i][j]; l++){\n                    int re = k * (i+1) + l * (j+1);\n                    if (re > matrix[i][j]) continue;\n                    int N = k+l+(re != matrix[i][j]);\n                    if (N > res){\n                        res = N;\n                        K = k;\n                        L = l;\n                    }\n                }\n            }\n            int last = 1;\n            for (int k=0; k < K; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-1);\n                last = sv;\n                sv++;\n            }\n            for (int k=0; k < L; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-2);\n                last = sv;\n                sv++;\n            }\n            reb.push_back(make_pair(last, 300));\n            wh.push_back(matrix[i][j] - K * (i+1) - L * (j+1));\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << reb.size() << endl;\n    for (int i=0; i < reb.size(); i++){\n        cout << reb[i].first << \" \" << reb[i].second << \" \";\n        if (wh[i] == -1) cout << \"X\" << endl;\n        else if (wh[i] == -2) cout << \"Y\" << endl;\n        else cout << wh[i] << endl;\n    }\n    cout << \"1 300\" << endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll A, B;\n    cin >> A >> B;\n    vector<vector<ll>> d(A + 1, vector<ll>(B + 1));\n    for (ll i = 1; i <= A; i++) {\n        for (ll j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    constexpr ll MAX = 100;\n    vector<vector<ll>> f(MAX + 1, vector<ll>(MAX + 1, 0));\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            for (ll x = 1; x <= A; x++) {\n                for (ll y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n\n    for (ll x = 1; x <= A; x++) {\n        for (ll y = 1; y <= B; y++) {\n            ll D = LLONG_MAX;\n            for (ll a = 0; a <= MAX; a++) {\n                for (ll b = 0; b <= MAX; b++) {\n                    D = min(D, x * a + y * b + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    const ll N = (MAX + 1) * 2;\n    const ll M = MAX * (MAX + 2) + 2 * MAX + 1;\n    cout << N << \" \" << M << endl;\n    for (ll i = 0; i < N - 1; i++) {\n        if (i <= MAX) {\n            //次に辺を張る\n            if (i < MAX) {\n                cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n            }\n            //下側へ辺を張る\n            for (ll j = 0; j <= MAX; j++) {\n                cout << i + 1 << \" \" << j + MAX + 2 << \" \" << f[i][j] << endl;\n            }\n        } else {\n            //次に辺を張る\n            cout << i + 1 << \" \" << i + 2 << \" Y\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1 ; i <= 100 ; ++i)\n    printf(\"%d %d X\\n\" , i , i + 1);\n    for(int i = 102 ; i < 202 ; ++i)\n    printf(\"%d %d Y\\n\" , i , i + 1);\n    for(int i = 0 ; i <= 100 ; ++i)\n    for(int j = 0 ; j <= 100 ; ++j)\n        printf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n    puts(\"1 202\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\n// struct edge {\n//   ll v, dist;\n// };\n//\n// struct state {\n//   ll v, cost;\n//\n//   bool operator>(const state s) const {\n//     return cost > s.cost;\n//   }\n// };\n//\n// vector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n//   vector<ll> dp(E.size(), INF);\n//   priority_queue<state, vector<state>, greater<state> > q;\n//   q.push((state) { S, 0 });\n//\n//   while(!q.empty()) {\n//     ll v = q.top().v, cost = q.top().cost;\n//     q.pop();\n//\n//     if(dp[v] <= cost) continue;\n//     dp[v] = cost;\n//\n//     REP(i, 0, E[v].size()) {\n//       ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n//       if(dp[nv] > ncost) q.push((state) { nv, ncost });\n//     }\n//   }\n//\n//   return dp;\n// }\n\nint main(void) {\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct data { ll x, y, z; };\n  vector<data> e;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(x, 0, 11) REP(y, 0, 11) REP(z, 0, 100 + 1) {\n    bool f = true;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      f = f && D[a][b] <= v;\n    }\n    if(!f) continue;\n    ll cnt = 0;\n    REP(a, 1, A + 1) REP(b, 1, B + 1) {\n      ll v = a * x + b * y + z;\n      if(!ok[a][b] && D[a][b] == v) {\n        ok[a][b] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) e.push_back((data) { x, y, z });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  ll N = 22, M = 20 + e.size(), S = 1, T = 12;\n  cout << \"Possible\" << endl;\n  cout << N << \" \" << M << endl;\n  REP(i, S, S + 10) cout << i << \" \" << i + 1 << \" X\" << endl;\n  REP(i, T, T + 10) cout << i + 1 << \" \" << i << \" Y\" << endl;\n  REP(i, 0, e.size()) cout << S + e[i].x << \" \" << T + e[i].y << \" \" << e[i].z << endl;\n  cout << S << \" \" << T << endl;\n\n  // REP(x, 1, A + 1) REP(y, 1, B + 1) {\n  //   vector< vector<edge> > E(N + 1);\n  //   REP(i, S, S + 10) E[i].push_back((edge) { i + 1, x });\n  //   REP(i, T, T + 10) E[i + 1].push_back((edge) { i, y });\n  //   REP(i, 0, e.size()) E[S + e[i].x].push_back((edge) { T + e[i].y, e[i].z });\n  //   ll d = dijkstra(E, S)[T];\n  //   assert(d == D[x][y]);\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64=int64_t;\n\n#define rep(i,x,y) for(int i=(x),i##_max_for_repmacro=(y); i<i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n \nconst int inf=1.01e9;\nconst i64 inf64=4.01e18;\nconst double eps=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int A,B;\n    cin >> A >> B;\n    vector<vector<int>> d(A,vector<int>(B));\n    rep(i,0,A) rep(j,0,B) cin >> d[i][j];\n\n    int N=202,M=101*101+200,S=0,T=N-1;\n    static int f[101][101]={};\n    rep(i,0,101) rep(j,0,101){\n        int ma=0;\n        rep(x,0,A) rep(y,0,B) ma=max(ma,d[x][y]-(x+1)*i-(y+1)*(100-j));\n        f[i][j]=ma;\n    }\n\n    auto min_dist=[&](int x,int y){\n        int dist[202];\n        fill_n((int*)dist,202,inf);\n        dist[0]=0;\n        rep(i,0,202){\n            rep(j,0,101) rep(k,0,101) dist[k+101]=min(dist[k+101],dist[j]+f[j][k]);\n            rep(j,0,100) dist[j+1]=min(dist[j+1],dist[j]+x);\n            rep(j,0,100) dist[j+1+101]=min(dist[j+1+101],dist[j+101]+y);\n        }\n        return dist[201];\n    };\n\n    rep(x,1,A+1) rep(y,1,B+1) if(min_dist(x,y)!=d[x-1][y-1]){\n        cout << \"Impossible\" << endl;\n        return;\n    }\n\n    cout << \"Possible\" << endl;\n    cout << N << \" \" << M << endl;\n    rep(i,0,100) cout << i+1 << \" \" << i+2 << \" X\" << endl;\n    rep(i,0,100) cout << i+1+101 << \" \" << i+2+101 << \" Y\" << endl;\n    rep(i,0,101) rep(j,0,101) cout << i+1 << \" \" << j+102 << \" \" << f[i][j] << endl;\n    cout << S+1 << \" \" << T+1 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nconst int inf=2147483647;\nvoid fmax(int&a,int b){\n\tif(b>a)a=b;\n}\nvoid fmin(int&a,int b){\n\tif(b<a)a=b;\n}\nint d[20][20],f[110][110];\nint main(){\n\tint A,B,i,j,k,l,t;\n\tscanf(\"%d%d\",&A,&B);\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++)scanf(\"%d\",d[i]+j);\n\t}\n\tfor(i=0;i<=100;i++){\n\t\tfor(j=0;j<=100;j++){\n\t\t\tt=0;\n\t\t\tfor(k=1;k<=A;k++){\n\t\t\t\tfor(l=1;l<=B;l++)fmax(t,d[k][l]-i*k-j*l);\n\t\t\t}\n\t\t\tf[i][j]=t;\n\t\t}\n\t}\n\tfor(i=1;i<=A;i++){\n\t\tfor(j=1;j<=B;j++){\n\t\t\tt=inf;\n\t\t\tfor(k=0;k<=100;k++){\n\t\t\t\tfor(l=0;l<=100;l++)fmin(t,i*k+j*l+f[k][l]);\n\t\t\t}\n\t\t\tif(t!=d[i][j]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n%d %d\\n\",202,200+101*101);\n\tfor(i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;i++){\n\t\tfor(j=0;j<=100;j++)printf(\"%d %d %d\\n\",1+i,202-j,f[i][j]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint const MAXVAL=5;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> used(MAXVAL+1,std::vector<int>(MAXVAL+1));\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=MAXVAL;++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint mind1=INT_MAX;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmind1=std::min(mind1,d1[x][y]=(x+1)*nx+(y+1)*ny-d1[x][y]);\n\t\t\t}\n\t\t\tif(mind1<0)\n\t\t\t\tcontinue; // cannot use function nx*x+ny*y+c because c can't be <0\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==mind1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tconnval[nx][ny]=mind1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tused[0][0]=true;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny]){\n\t\t\tfor(int sumd=1;sumd<=2*MAXVAL;++sumd){\n\t\t\t\tfor(int dx=std::max(0,sumd-ny),\n\t\t\t\t\t\tmax_dx=std::min({MAXVAL,sumd,nx});\n\t\t\t\t\t\tdx<=max_dx;++dx){\n\t\t\t\t\tint dy=sumd-dx; // 0 <= dy && dy <= ny\n\t\t\t\t\tif(used[nx-dx][ny-dy]){\n\t\t\t\t\t\tint nx1=nx,ny1=ny;\n\t\t\t\t\t\twhile(dy--)\n\t\t\t\t\t\t\tused[nx1][--ny1]=true;\n\t\t\t\t\t\twhile(dx--)\n\t\t\t\t\t\t\tused[--nx1][ny1]=true;\n\t\t\t\t\t\tgoto break_outer_2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nbreak_outer_2:;\n\t\t}\n\n\tauto& index=used;\n\tint lastindex=0;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny])\n\t\t\tindex[nx][ny]=++lastindex;\n\n\tint const n_used=lastindex; // 1 .. lastindex\n\tint const n_used_edge=n_used-1;\n\tint const source=1;\n\tint const dest=lastindex+1;\n\n\tstd::cout<<\"Possible\\n\"<<dest+1<<' '<<n_used_edge+n_connedge<<'\\n';\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const curindex=index[nx][ny];\n\t\tif(curindex){\n\t\t\tif(nx!=0&&index[nx-1][ny])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx-1][ny]<<\" X\\n\";\n\t\t\telse if(ny!=0&&index[nx][ny-1])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx][ny-1]<<\" Y\\n\";\n\t\t\telse\n\t\t\t\tassert(nx==0&&ny==0);\n\t\t\tif(connval[nx][ny]>=0)\n\t\t\t\tstd::cout<<curindex<<' '<<dest<<' '<<connval[nx][ny]<<'\\n';\n\t\t}else\n\t\t\tassert(connval[nx][ny]<0);\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int inf=0x3f3f3f3f;\ninline bool chkmax(int &x,int y){return (y>x)?(x=y,1):0;}\ninline bool chkmin(int &x,int y){return (y<x)?(x=y,1):0;}\nint d[11][11],f[101][101];\nint main(){\n\tint A=read(),B=read();\n\tREP(i,1,A) REP(j,1,B) d[i][j]=read();\n\tREP(i,0,100) REP(j,0,100)\n\t\tREP(x,1,A) REP(y,1,B)\n\t\t\tchkmax(f[i][j],d[x][y]-x*i-y*j);\n\tREP(x,1,A) REP(y,1,B){\n\t\tint dis=inf;\n\t\tREP(i,0,100) REP(j,0,100) chkmin(dis,f[i][j]+i*x+j*y);\n\t\tif(dis!=d[x][y]){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint n=202,m=101*101+200;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",n,m);\n\tREP(i,1,100) printf(\"%d %d x\\n\",i,i+1);\n\tREP(i,102,201) printf(\"%d %d y\\n\",i,i+1);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 105 \nusing namespace std;\nint d[maxn][maxn];\nint D[maxn][maxn];\nint f[maxn][maxn]; \nint main() {\n\tint A, B;\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int i = 1; i <= A; ++i) for(int j = 1; j <= B; ++j) scanf(\"%d\", d[i] + j);\n\tfor(int a = 0; a <= 100; ++a) {\n\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\tfor(int x = 1; x <= A; ++x) {\n\t\t\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\t\t\tf[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(D, 0x3f, sizeof D);\n\tfor(int x = 1; x <= A; ++x) {\n\t\tfor(int y = 1; y <= B; ++y) {\n\t\t\tfor(int a = 0; a <= 100; ++a) {\n\t\t\t\tfor(int b = 0; b <= 100; ++b) {\n\t\t\t\t\tD[x][y] = min(D[x][y], x * a + y * b + f[a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool same = true;\n\tfor(int x = 1; x <= A; ++x) \n\t\tfor(int y = 1; y <= B; ++y) \n\t\t\tif(D[x][y] != d[x][y]) same = false;\n\tputs(same ? \"Possible\" : \"Impossible\");\n\tif(same) {\n\t\tputs(\"202 10401\");\n\t\tfor(int i = 1; i <= 100; ++i) {\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + 101, i + 102);\n\t\t}\n\t\tfor(int a = 0; a <= 100; ++a) \n\t\t\tfor(int b = 0; b <= 100; ++b) \n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, 202 - b, f[a][b]);\n\t\tputs(\"1 202\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nuisng namespace std;\n\nint main()\n{\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nset<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = 1;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i < 50; ++i) {\n\t\tedge.insert({{lenXY[i + 1], s}, -2});\n\t\tedge.insert({{s, lenXY[i]}, -1});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 100; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.insert({{lenX[i + 1], lenX[i]}, -1});\n\t\tedge.insert({{lenY[i + 1], lenY[i]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.insert({{lenXY[Y[i][j]], lenX[X[i][j] - Y[i][j]]}, d[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.insert({{lenXY[X[i][j]], lenY[Y[i][j] - X[i][j]]}, d[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define exec_time() (1.0 * clock()/CLOCKS_PER_SEC)\n#define fst first\n#define snd second\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\ntemplate <typename T> inline bool maximum(T &a, T b) { return a < b? a = b, 1 : 0; }\ntemplate <typename T> inline bool minimum(T &a, T b) { return a > b? a = b, 1 : 0; }\ntemplate <typename T>\nT read(T &x, T f = 0)\n{\n\tchar c = getchar(); x = 0;\n\tfor(; !isdigit(c); c = getchar())\n\t\tf |= c == '-';\n\tfor(;  isdigit(c); c = getchar())\n\t\tx = x*10 + c-'0';\n\treturn x = f? -x : x;\n}\n\nconst int N = 1e2 + 1;\n\nint A, B;\nint d[N + 5][N + 5], f[N + 5][N + 5];\n\nvoid Init()\n{\n\tread(A), read(B);\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y) read(d[x][y]);\n\n\treturn ;\n}\n\nbool check()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y){\n\t\t\tint dist = ~0U >> 1;\n\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tminimum(dist, f[a][b] + x*a + y*b);\n\n\t\t\tif(dist != d[x][y]) return false;\n\t\t}\n\treturn true;\n}\n\nvoid Exec()\n{\n\tfor(int x = 1; x <= A; ++x)\n\t\tfor(int y = 1; y <= B; ++y)\n\t\t\tfor(int a = 0; a <= A; ++a)\n\t\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\t\tmaximum(f[a][b], d[x][y] - x*a - y*b);\n\tif(!check()) puts(\"impossible\");\n\telse\n\t{\n\t\tputs(\"possible\");\n\t\tprintf(\"%d %d\\n\", N*2, 2*(N-1) + A*B);\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\t\tprintf(\"%d %d Y\\n\", i + N + 1, i + N);\n\t\t}\n\t\tfor(int a = 0; a <= A; ++a)\n\t\t\tfor(int b = 0; b <= B; ++b)\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, N + b + 1, f[a][b]);\n\t\tprintf(\"%d %d\\n\", 1, N + 1);\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\tInit();\n\tExec();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nvector<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = 1;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i < 50; ++i) {\n\t\tedge.pb({{lenXY[i + 1], s}, -2});\n\t\tedge.pb({{s, lenXY[i]}, -1});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 100; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.pb({{lenX[i + 1], lenX[i]}, -1});\n\t\tedge.pb({{lenY[i + 1], lenY[i]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.pb({{lenXY[Y[i][j]], lenX[X[i][j] - Y[i][j]]}, d[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.pb({{lenXY[X[i][j]], lenY[Y[i][j] - X[i][j]]}, d[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[13][13];\nconst int N = 100; \nint f[N+1][N+1];\n\nvoid solve() {\n    int A,B;\n    cin >> A >> B;\n    for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n    memset(f, 0, sizeof f);\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            for (int x = 1; x <= A; x++) {\n                for (int y = 1; y <= B; y++) {\n                    f[i][j] = max(f[i][j], d[x][y] - x*i - y*j);\n                }\n            }\n        }\n    }\n    for (int x = 1; x <= A; x++) {\n        for (int y = 1; y <= B; y++) {\n            int mi =  1e5;\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= N; j++) {\n                    mi = min(mi, x*i+y*j + f[i][j]);\n                }\n            }\n            if (mi != d[x][y]) {\n                cout << \"Impossible\"; return;\n            }\n        }\n    }\n    vector<int> a(N+1), b(N+1);\n    iota(a.begin(), a.end(), 1);\n    iota(b.begin(), b.end(), 102);\n    int s = a[0], t = b[0];\n    int m = 100*2 + 101*101;\n    cout << \"Possible\\n\";\n    cout << \"202 \" << m << \"\\n\";\n    for (int i = 1; i <= N; i++) {\n        cout << a[i-1] << ' ' << a[i] << \" X\\n\";\n        cout << b[i] << ' ' << b[i-1] << \" Y\\n\";\n    }\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            cout << a[i] << ' ' << b[j] << ' ' << f[i][j] << \"\\n\";\n        }\n    }\n    cout << s << ' ' << t;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver2 {\n public:\n  const int sizeG = 100;\n  int a, b;\n  vector<vector<int>> d, lBound;\n  Solver2(LL n, LL m) : a(n), b(m), d(a + 1, vector<int>(b + 1)), lBound(sizeG + 1, vector<int>(sizeG + 1, 0)){};\n  void impossible() {\n    cout << \"Impossible\" << endl;\n    exit(0);\n  }\n  void solve() {\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        cin >> d[i][j];\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        for (int k = 0; k <= sizeG; ++k) {\n          for (int l = 0; l <= sizeG; ++l) {\n            //path with 'X' : k times\n            //path with 'Y' : l times\n            lBound[k][l] = max(lBound[k][l], d[i][j] - i * k - j * l);\n          }\n        }\n      }\n    }\n    for (int i = 1; i <= a; ++i) {\n      for (int j = 1; j <= b; ++j) {\n        int minDistance = INF;\n        for (int k = 0; k <= sizeG; ++k) {\n          for (int l = 0; l <= sizeG; ++l) {\n            minDistance = min(minDistance, i * k + j * l + lBound[k][l]);\n          }\n        }\n        if (minDistance > d[i][j]) impossible();\n      }\n    }\n    cout << sizeG * 2 + 2 << ' ' << (sizeG + 1) * (sizeG + 1) + 2 * sizeG << endl;\n    for (int k = 0; k <= sizeG; ++k) {\n      for (int l = 0; l <= sizeG; ++l) {\n        cout << k + 1 << ' ' << sizeG * 2 + 2 - l << ' ' << lBound[k][l] << endl;\n      }\n    }\n    for (int i = 0; i < sizeG; ++i) {\n      cout << i + 1 << ' ' << i + 2 << \" X\" << endl;\n      cout << i + sizeG + 2 << ' ' << i + sizeG + 3 << \" Y\" << endl;\n    }\n\n    cout << 1 << ' ' << sizeG * 2 + 2 << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nint d[11][11];\nint c[101][101];\n\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tint a,b;\n\tcin>>a>>b;\n\trep(i,1,a)\n\trep(j,1,b)cin>>d[i][j];\n\tint n=101+101;\n\trep(x,0,100)\n\trep(y,0,100)\n\t{\n\t\trep(i,1,a)\n\t\trep(j,1,b)chmax(c[x][y],d[i][j]-(i*x+j*y));\n\t}\n\trep(i,1,a)\n\trep(j,1,b)\n\t{\n\t\trep(x,0,100)\n\t\trep(y,0,100)\n\t\tif(i*x+j*y+c[x][y]==d[i][j])goto have;\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t\thave : ;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",n,101*101+100*2);\n\trep(x,1,100)printf(\"%d %d X\\n\",x,x+1);\n\trep(y,1,100)printf(\"%d %d Y\\n\",n-y,n-y+1);\n\trep(x,0,100)\n\trep(y,0,100)printf(\"%d %d %d\\n\",1+x,n-y,c[x][y]);\n\tprintf(\"%d %d\\n\",1,n);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n#define N 305\n#define db double\n#define ll long long\nint A,B,dist[12][12],f[N][N],d;\nint cal(int a,int b)\n{\n\tint res=-1e9;\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) res=max(res,dist[i][j]-i*a-j*b);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++) scanf(\"%d\",&dist[i][j]);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t{\n\t\t\tf[i][j]=cal(i,j);\n\t\t\tif(f[i][j]<0) {puts(\"Impossible\");return 0;}\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++)\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,j+102,f[i][j]);\n\tfor(int i=1;i<=100;i++) printf(\"%d %d Y\\n\",101+i,102+i);\n\tputs(\"1 102\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int a,b;cin>>a>>b;\n    int d[a][b];\n    rep(i,0,a)rep(j,0,b)cin>>d[i][j];\n    rep(i,0,a){\n        rep(j,0,b-1){\n            if(d[i][j+1]<d[i][j]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-1){\n            if(d[j+1][i]<d[j][i]){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,a){\n        rep(j,0,b-2){\n            int sa1=d[i][j+1]-d[i][j],sa2=d[i][j+2]-d[i][j+1];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    rep(i,0,b){\n        rep(j,0,a-2){\n            int sa1=d[j+1][i]-d[j][i],sa2=d[j+2][i]-d[j+1][i];\n            if(sa1<sa2||sa1<0||sa2<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n        }\n    }\n    vector<pii> v[301];\n    int now=201;\n    int m=199;\n    rep(i,0,a){\n        rep(j,0,b){\n            int dx=0,dy=0;\n            vector<pipi> w;\n            rep(k,0,100){\n                rep(l,0,100){\n                    int rrr=0;\n                    rep(ii,0,a){\n                        rep(jj,0,b){\n                            int sa=k*(ii-i)+l*(jj-j);\n                            //if(i==1&&j==3&&k==3&&l==1)cout<<ii<<\" \"<<jj<<endl;\n                            if(d[i][j]+sa<d[ii][jj]){\n                                rrr=1;\n                                break;\n                            }\n                        }\n                        if(rrr)break;\n                    }\n                    if(rrr==0){\n                        w.push_back({(i+1)*k+(j+1)*l,{k,l}});\n                    }\n                }\n            }\n            sort(w.begin(),w.end());\n            if(w.size()==0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            //cout<<i<<\" \"<<j<<endl;\n            dx=w[0].second.first;\n            dy=w[0].second.second;\n            //cout<<dx<<\" \"<<dy<<endl;\n            int ama=d[i][j]-dx*(i+1)-dy*(j+1);\n            if(ama<0){\n                cout<<\"Impossible\"<<endl;\n                return 0;\n            }\n            v[dx+1].push_back({now,0});\n            v[now].push_back({200-dy,ama});\n            now++;\n            m+=2;\n        }\n    }\n    cout<<\"Possible\"<<endl;\n    cout<<300<<\" \"<<m<<endl;\n    rep(i,1,100){\n        cout<<i<<\" \"<<i+1<<\" \"<<'X'<<endl;\n    }\n    cout<<100<<\" \"<<101<<\" \"<<0<<endl;\n    rep(i,101,200)cout<<i<<\" \"<<i+1<<\" \"<<'Y'<<endl;\n    rep(i,1,301){\n        rep(j,0,v[i].size())cout<<i<<\" \"<<v[i][j].first<<\" \"<<v[i][j].second<<endl;\n    }\n    cout<<1<<\" \"<<200<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int inf=0x3f3f3f3f;\ninline bool chkmax(int &x,int y){return (y>x)?(x=y,1):0;}\ninline bool chkmin(int &x,int y){return (y<x)?(x=y,1):0;}\nint d[11][11],f[101][101];\nint main(){\n\tint A=read(),B=read();\n\tREP(i,1,A) REP(j,1,B) d[i][j]=read();\n\tREP(i,0,100) REP(j,0,100)\n\t\tREP(x,1,A) REP(y,1,B)\n\t\t\tchkmax(f[i][j],d[x][y]-x*i-y*j);\n\tREP(x,1,A) REP(y,1,B){\n\t\tint dis=inf;\n\t\tREP(i,0,100) REP(j,0,100) chkmin(dis,f[i][j]+i*x+j*y);\n\t\tif(dis!=d[x][y]){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint n=202,m=101*101+200;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",n,m);\n\tREP(i,1,100) printf(\"%d %d X\\n\",i,i+1);\n\tREP(i,102,201) printf(\"%d %d Y\\n\",i,i+1);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > d(A,vector<int>(B));\n\tfor(int i =0; i < A*B; i++) cin >> d[i/B][i%B];\n\n\tvector< vector<int> > mincost(101,vector<int>(101,0));\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++)\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\t mincost[k][l] =max(d[i][j]-k*i-l*j,mincost[k][l]);\n\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++) {\n\t\tint m =101;\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\tm =min(m,mincost[k][l]+k*i+l*j);\n\t\tif(m != d[i][j]) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tint N =202, M =101*101+200;\n\tcout << N << \" \" << M << \"\\n\";\n\tfor(int i =0; i < 100; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i =0; i <= 100; i++) for(int j =0; j <= 100; j++)\n\t\tcout << i+1 << \" \" << i+102 << \" \" << mincost[i][j] << \"\\n\";\n\tfor(int i =0; i < 100; i++) cout << i+102 << \" \" << i+103 << \" Y\\n\";\n\tcout << \"1 202\" << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n/*\trep0(i,3){\n\t\trep0(j,3) cerr<<mx[i][j]<<\" \";\n\t\tcerr<<endl;\n\t}*/\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx,idy;\n\t\trep0(x,101){\n\t\t\trep0(y,101){\n\t\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\t\tidx=x,idy=y;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tused[idx][idy]=true;\n\t\tadd(!idx?s:idx,!idy?t:idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int inf=0x3f3f3f3f;\ninline bool chkmax(int &x,int y){return (y>x)?(x=y,1):0;}\ninline bool chkmin(int &x,int y){return (y<x)?(x=y,1):0;}\nint d[11][11],f[101][101];\nint main(){\n\tint A=read(),B=read();\n\tREP(i,1,A) REP(j,1,B) d[i][j]=read();\n\tREP(i,0,100) REP(j,0,100)\n\t\tREP(x,1,A) REP(y,1,B)\n\t\t\tchkmax(f[i][j],d[x][y]-x*i-y*j);\n\tREP(x,1,A) REP(y,1,B){\n\t\tint dis=inf;\n\t\tREP(i,0,100) REP(j,0,100) chkmin(dis,f[i][j]+i*x+j*y);\n\t\tif(dis!=d[x][y]){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint n=202,m=101*101+200;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",n,m);\n\tREP(i,1,100) printf(\"%d %d x\\n\",i,i+1);\n\tREP(i,102,201) printf(\"%d %d y\\n\",i,i+1);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 1002, M = 500000;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz=2,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[M],st2[M],st3[M];\nbool mrk[M];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=1; t=2;\n\tif (n==1&&m==1) {\n\t\tputs(\"Possible\");\n\t\tprintf(\"2 1\\n\");\n\t\tprintf(\"1 2 %d\\n\",d[1][1]);\n\t\tprintf(\"1 2\");\n\t\treturn 0;\n\t}\n\trep(a,0,100) rep(b,0,100) {\n\t\tint mx=-1;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-a*i-b*j); if (mx==-1) continue;\n\t\tbool flag=0;\n\t\trep(i,1,n) rep(j,1,m) if (!ok[i][j]&&d[i][j]-a*i-b*j==mx) {ok[i][j]=1; flag=1;}\n\t\tif (!flag&&a>5&&b>5) continue;\n\t\tif (sz==300) break; C[a][b]=mx; dy[a][b]=++sz;\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\trep(a,0,100) rep(b,0,100) {\n\t\tif (dy[a][b]&&dy[a+1][b]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a+1][b]; st3[tot]=1;}\n\t\tif (dy[a][b]&&dy[a][b+1]) {tot++; st1[tot]=dy[a][b]; st2[tot]=dy[a][b+1]; st3[tot]=2;}\n\t}\n\trep(a,0,100) rep(b,0,100) if (dy[a][b]) {\n\t\ttot++; st1[tot]=dy[a][b]; st2[tot]=t;\n\t\tmrk[tot]=1; st3[tot]=C[a][b];\n\t}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[0][1]; st3[tot]=2;}\n\tif (dy[0][1]) {tot++; st1[tot]=s; st2[tot]=dy[1][0]; st3[tot]=1;}\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",sz,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[tot]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"1 2\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){ for (ll o=63, x=-1;;){ ll m=(o+x)/2; if (a<(1LL<<m))o=m; else x=m; if (o-x==1)return x; } }\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvdd Gauss_jordan(vvdd &A, vdd &b){\n\tll n = A.size();\n\tvvdd B(n, vdd(n+1));\n\tREP(i, n) REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n){\n\t\tll pivot = i;\n\t\tREPS(j, i, n-1) if (abs(B[pivot][i])<abs(B[j][i])) pivot=j;\n\t\tswap(B[i], B[pivot]);\n\t\tif (abs(B[i][i]) < EPS) return vdd();//解がないor一意でない\n\t\tREPS(j, i+1, n) B[i][j] /= B[i][i];\n\t\tREP(j, n) if (j!=i) REPS(k, i+1, n) B[j][k] -= B[j][i] * B[i][k];\n\t}\n\tvdd x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn move(x);\n}\n\n\nvoid solve()\n{\n\tll A, B;  cin >> A >> B;\n\tvector<vector<ll>> D = cinvv<ll>(A, B);\n\trep(i, 0, A-1){\n\t\tD[i].push_back(D[i].back());\n\t}\n\tD.emplace_back();\n\trep(j, 0, B-1){\n\t\tD[A].push_back(D[A-1][j]);\n\t}\n\tD[A].push_back(D[A].back());\n\n\tauto DD = [&](ll i, ll j)->ll&{\n\t\treturn D[i-1][j-1];\n\t};\n\n\tset<tll> buf;\n\n\trep(i, 1, A)rep(j, 1, B){\n\t\tvector<tuple<ll, ll, ll, ll, ll,ll>> tmp;\n\n\t\trep(k, 1, B){\n\t\t\ttmp.emplace_back(i,j, i,j+1, i+1,k);\n\t\t}\n\t\trep(k, 1, A){\n\t\t\ttmp.emplace_back(i,j, i+1,j, k,j+1);\n\t\t}\n\t\t//if (j>=2) { tmp.emplace_back(i, j, i+1, j+1, i, j-1); }\n\t\t//if (i>=2) { tmp.emplace_back(i, j, i+1, j+1, i-1, j); }\n\n\t\tbool kai=false;\n\t\tEACH(e, tmp){\n\t\t\tll I,J,II,JJ,III,JJJ;  tie(I, J, II, JJ,III,JJJ) = e;\n\t\t\tvvdd AA ={\n\t\t\t\t{(dd)I,  (dd)J,  1.},\n\t\t\t\t{(dd)II, (dd)JJ, 1.},\n\t\t\t\t{(dd)III,(dd)JJJ,1.}\n\t\t\t};\n\t\t\tvdd bb ={(dd)DD(I,J), (dd)DD(II,JJ), (dd)DD(III,JJJ)};\n\t\t\tvdd x = Gauss_jordan(AA, bb);\n\t\t\tif (x.empty()) continue;\n\t\t\tll a = (ll)(x[0]+.01);\n\t\t\tll b = (ll)(x[1]+.01);\n\t\t\tll c = (ll)(x[2]+.01);\n\t\t\tif (abs((dd)a-x[0])>EPS) continue;\n\t\t\tif (abs((dd)b-x[1])>EPS) continue;\n\t\t\tif (abs((dd)c-x[2])>EPS) continue;\n\t\t\tif (a<0 || b<0 || c<0) continue;\n\n\t\t\tbool isOK = true;\n\t\t\trep(ii, 1, A)rep(jj, 1, B){\n\t\t\t\tll f = a*ii+b*jj+c;\n\t\t\t\tif (DD(ii, jj) > f) isOK=false;\n\t\t\t}\n\t\t\tif (!isOK) continue;\n\t\t\tbuf.emplace(a, b, c);\n\t\t\tkai=true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!kai) bye(\"Impossible\");\n\t}\n\n\t//グラフ構成\n\tcout << \"Possible\" << '\\n';\n\tll N = 200;\n\tll M = 198+sz(buf);\n\tcout << N << \" \" << M << '\\n';\n\trep(i, 1, 99){\n\t\tcout << i << \" \" << i+1 << \" X\" << '\\n';\n\t}\n\trep(i, 101, 199){\n\t\tcout << i << \" \" << i+1 << \" Y\" << '\\n';\n\t}\n\tEACH(e, buf){\n\t\tll a; ll b; ll c;  tie(a, b, c) = e;\n\t\tcout << (a+1) << \" \" << (200-b) << \" \" << c << '\\n';\n\t}\n\tcout << \"1 200\" << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; int f=1; char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}\n\twhile(isdigit(ch)) {x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\n\nconst int MAXN = 115;\nint mp[MAXN][MAXN],f[MAXN][MAXN];\nint n,m;\n\nint main(int argc, char const *argv[])\n{\n\tn=read(),m=read();\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j)\n\t\t\tmp[i][j]=read();\n\tfor(int i=0; i<=100; ++i)\n\t\tfor(int j=0; j<=100; ++j)\n\t\t\tfor(int p=1; p<=n; ++p)\n\t\t\t\tfor(int q=1; q<=m; ++q)\n\t\t\t\t\tf[i][j]=max(f[i][j],mp[p][q]-i*p-j*q);\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j)\n\t\t{\n\t\t\tint mn=1e9;\n\t\t\tfor(int p=0; p<=100; ++p)\n\t\t\t\tfor(int q=0; q<=100; ++q)\n\t\t\t\t\tmn=min(mn,f[p][q]+p*i+q*j);\n\t\t\tif(mn!=mp[i][j])\n\t\t\t{puts(\"Impossible\"); return 0;}\n\t\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i=1; i<=100; ++i)\n\t\tprintf(\"%d %d X\\n\",i,i + 1);\n\tfor(int i=102; i < 202; ++i)\n\t\tprintf(\"%d %d Y\\n\",i,i + 1);\n\tfor(int i=0; i<=100; ++i)\n\t\tfor(int j=0; j<=100; ++j)\n\t\t\tprintf(\"%d %d %d\\n\",1+i,202-j,f[i][j]);\n\tputs(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct ans {\n\tint from, to; string cost;\n};\nvector<ans> v;\nbool exi[301][301];\nvoid solve() {\n\n\tint a, b; cin >> a >> b;\n\tint d[11][11];\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tbool valid = true;\n\tint s = 1, t = 202, cur = 3;\n\tRep1(i, 2, 101) {\n\t\tv.push_back({ i - 1,i,\"X\" });\n\t}\n\tRep1(i, 102, 201) {\n\t\tv.push_back({ i,i + 1,\"Y\" });\n\t}\n\trep1(i, a) {\n\t\trep1(j, b) {\n\t\t\trep(k, 101) {\n\t\t\t\tint l = k;\n\t\t\t\tif (l*i > d[i][j]) {\n\t\t\t\t\tvalid = false; break;\n\t\t\t\t}\n\t\t\t\tint r = (d[i][j] - l*i) / j;\n\t\t\t\tint z = d[i][j] - l*i - r * j;\n\t\t\t\tbool f = true;\n\t\t\t\trep1(i_, a) {\n\t\t\t\t\trep1(j_, b) {\n\t\t\t\t\t\tint sum = i_ * l + j_ * r + z;\n\t\t\t\t\t\tif (sum < d[i_][j_])f = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tint sta = 1 + l;\n\t\t\t\t\tint goa = 202 - r;\n\t\t\t\t\tif(!exi[sta][goa])v.push_back({ sta,goa,to_string(z) });\n\t\t\t\t\texi[sta][goa] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (k == 100)valid = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!valid) {\n\t\tcout << \"Impossible\" << endl;\n\t}\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tcout << 202 << \" \" << v.size() << endl;\n\t\trep(i, v.size()) {\n\t\t\tcout << v[i].from << \" \" << v[i].to << \" \" << v[i].cost << endl;\n\t\t}\n\t\tcout << \"1 202\" << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\n\nint d[16][16] = {};\nbool pass[16][16] = {};\n\n\nint stu[12345][3];\n\nint main() {\n\tint A, B;\n\tcin >> A >> B;\n\n\trep(i, A)rep(j, B) {\n\t\tcin >> d[i][j];\n\t}\n\n\tint stuN = 0;\n\n\trep(s, A)rep(t, B) {\n\t\tint u = 0;\n\t\trep(i, A)rep(j, B) {\n\t\t\tint x = i + 1;\n\t\t\tint y = j + 1;\n\t\t\tu = max(u, d[i][j] - s*x - t*y);\n\t\t}\n\t\tbool f = true;\n\t\t\n\t\tif ([&]() {\n\t\t\tbool f = false;\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u < d[i][j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}()) {\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tpass[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstu[stuN][0] = s;\n\t\t\tstu[stuN][1] = t;\n\t\t\tstu[stuN][2] = u;\n\t\t\tstuN++;\n\t\t\t//cout << s << \"x + \" << t << \"y + \"<<u << endl;\n\t\t}\n\t}\n\trep(i, A)rep(j, B) {\n\t\tif (!pass[i][j]) {\n\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\n\tint E = A*B+1;\n\n\tcout << A*B+1 << \" \" << A*(B - 1) + (A - 1)*B + stuN << endl;\n\n\trep(i, A) {\n\t\trep(j, B - 1) {\n\t\t\tcout << i*B + j + 1 << \" \" << i*B + j + 2 << \" Y\\n\";\n\t\t}\n\t}\n\trep(i, A - 1) {\n\t\trep(j, B) {\n\t\t\tcout << i*B + j + 1 << \" \" << (i+1)*B + j + 1 << \" X\\n\";\n\t\t}\t\n\t}\n\n\n\n\trep(k, stuN) {\n\t\t//cout << stu[k][0] << \"x + \" << stu[k][1] << \"y + \"<< stu[k][2] << endl;\n\t\tint i = stu[k][0];\n\t\tint j = stu[k][1];\n\t\tint c = stu[k][2];\n\t\tcout << i*B + j + 1 << \" \" << E << \" \"<<c << endl;\n\t}\n\n\tcout << \"1 \" << E << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=105;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,maxm-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nconst int N = 12;\nconst int x = 0x7fffffff;\nconst int y = 0x7ffffffe;\nint d[N][N];\nbool v[N][N];\nint X[N], Y[N], S, T, cnt, m;\nint from[1000000], to[1000000], cost[1000000];\ninline void addEdge(int x, int y, int z) {\n  cost[m] = z;\n  from[m] = x;\n  to[m++] = y;\n}\nint main() {\n  int A, B;\n  scanf(\"%d%d\", &A, &B);\n  int xx = 0, yy = 0;\n  for (int i = 1; i <= A; ++i)\n    for (int j = 1; j <= B; ++j) {\n      scanf(\"%d\", &d[i][j]);\n      xx = std::max(xx, d[i][j] / i);\n      yy = std::max(yy, d[i][j] / j);\n      v[i][j] = 0;\n    }\n  cnt = 0;\n  m = 0;\n  for (int i = 0; i <= xx; ++i) X[i] = cnt++;\n  for (int i = 0; i <= yy; ++i) Y[i] = cnt++;\n  S = X[0];\n  T = Y[0];\n  for (int i = 0; i < xx; ++i) addEdge(X[i], X[i + 1], x);\n  for (int i = 0; i < yy; ++i) addEdge(Y[i + 1], Y[i], y);\n  for (int i = 0; i <= xx; ++i)\n    for (int j = 0; j <= yy; ++j) {\n      int ans = -100000000;\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          ans = std::max(ans, d[a][b] - i * a - j * b);\n      if (ans < 0 || ans > 100) continue;\n      addEdge(X[i], Y[j], ans);\n      for (int a = 1; a <= A; ++a)\n        for (int b = 1; b <= B; ++b)\n          if (d[a][b] == i * a + j * b + ans)\n            v[a][b] = true;\n    }\n  for (int a = 1; a <= A; ++a)\n    for (int b = 1; b <= B; ++b)\n      if (!v[a][b]) return puts(\"Impossible\") & 0;\n  puts(\"Possible\");\n  printf(\"%d\\n\", cnt);\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d %d \", 1 + from[i], 1 + to[i]);\n    if (cost[i] == x) printf(\"X\");\n    else if (cost[i] == y) printf(\"Y\");\n    else printf(\"%d\", cost[i]);\n    printf(\"\\n\");\n  }\n  printf(\"%d %d\\n\", 1 + S, 1 + T);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint A, B;\nint D[20][20];\nint E[MAX_N], F[MAX_N], C[MAX_N];\nmap<pi, int> M;\n\nvoid add_edge(int a, int b, int c) {\n\tE[N] = a; F[N] = b; C[N] = c;\n\tN++;\n}\n\nvoid solve() {\n\tcin >> A >> B;\n\trep(i, 0, A) {\n\t\trep(j, 0, B) {\n\t\t\tcin >> D[i][j];\n\t\t}\n\t}\n\trep(x, 1, A + 1) {\n\t\trep(y, 1, B + 1) {\n\t\t\tbool found = false;\n\t\t\trep(a, 0, 100 + 1) {\n\t\t\t\trep(b, 0, 100 + 1) {\n\t\t\t\t\tint c = D[x - 1][y - 1] - (a * x + b * y);\n\t\t\t\t\tif(c < 0 || c > 100 || found) continue;\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\trep(i, 1, A + 1) {\n\t\t\t\t\t\trep(j, 1, B + 1) {\n\t\t\t\t\t\t\tif(D[i - 1][j - 1] > a * i + b * j + c) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tM[pi(a, 201 - b)] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) {\n\t\t\t\tcout << \"Impossible\" << \"\\n\"; return;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto p: M) {\n\t\tadd_edge(p.fst.fst, p.fst.sec, p.sec);\n\t}\n\trep(i, 0, 100) {\n\t\tadd_edge(i, i + 1, 101);\n\t\tadd_edge(101 + i, 102 + i, 102);\n\t}\n\tcout << \"Possible\\n\";\n\tcout << 202 << \" \" << N << \"\\n\";\n\trep(i, 0, N) {\n\t\tif(C[i] == 101) cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << \"X\\n\";\n\t\telse if(C[i] == 102) cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << \"Y\\n\";\n\t\telse cout << E[i] + 1 << \" \" << F[i] + 1 << \" \" << C[i] << \"\\n\";\n\t}\n\tcout << 1 << \" \" << 202 << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define re register\n#define N 3010\n#define id(x,y) (y?102+x:1+x)\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\nint n,m,d[N][N],f[N][N];\nsigned main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i)\t\n\t\tfor (int j=1;j<=m;++j)\n\t\t\td[i][j]=read();\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tfor (int x=1;x<=n;++x)\n\t\t\t\tfor (int y=1;y<=m;++y)\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor (int x=1;x<=n;++x)\n\t\tfor (int y=1;y<=m;++y){\n\t\t\tint mn=inf;\n\t\t\tfor (int i=0;i<=100;++i)\n\t\t\t\tfor (int j=0;j<=100;++j)\n\t\t\t\t\tmn=min(mn,f[i][j]+i*x+j*y);\n\t\t\tif (mn!=d[x][y]){puts(\"Impossible\");return 0;}\n\t\t}\n\tint S=1,T=300;puts(\"Possible\");\n\tprintf(\"%d %d\\n\",300,10401);\n\tfor (int i=1;i<=100;++i)printf(\"%d %d X\\n\",id(i-1,0),id(i,0));\n\tfor (int i=1;i<=100;++i)printf(\"%d %d Y\\n\",id(i-1,1),id(i,1));\n\tfor (int i=0;i<=100;++i)\n\t\tfor (int j=0;j<=100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",id(i,0),id(100-j,1),f[i][j]);\n\tprintf(\"%d %d\\n\",S,T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\nusing namespace std;\n#define DEBUG(x) cout<<#x<<\"=\"<<x<<endl\n#define DEBUG2(x,y) cout<<#x<<\"=\"<<x<<\",\"<<#y<<\"=\"<<y<<endl\ntypedef long long ll;\nclass Solver{\npublic:\n    static const int MAXD=11;\n    int A,B;\n    int d[MAXD][MAXD];\n    int f[MAXD*MAXD][MAXD*MAXD];\n    void solve(){\n        cin>>A>>B;\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++)\n                cin>>d[x][y];\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        f[a][b]=max(0,d[x][y]-x*a-y*b);\n                    }\n                }\n            }\n        }\n        for(int x=1;x<=A;x++){\n            for(int y=1;y<=B;y++){\n                int mmin=1e9;\n                for(int a=0;a<=100;a++){\n                    for(int b=0;b<=100;b++){\n                        mmin=min(mmin,x*a+y*b+f[a][b]);\n                    }\n                }\n                if(mmin!=d[x][y]){\n                    cout<<\"Impossible\\n\";\n                    return;\n                }\n            }\n        }\n        cout<<\"Possible\\n\";\n        cout<<300<<\" \"<<101*101+298<<\"\\n\";\n        for(int u=1;u<150;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'X'<<\"\\n\";\n        }\n        for(int u=150;u<300;u++){\n            cout<<u<<\" \"<<u+1<<\" \"<<'Y'<<\"\\n\";\n        }\n        for(int u=0;u<=100;u++){\n            for(int v=0;v<=100;v++){\n                cout<<u+1<<\" \"<<300-v<<\"  \"<<f[u][v]<<\"\\n\";\n            }\n        }\n        cout<<1<<\" \"<<300;\n    }\n};\nint main()\n{\n    // freopen(\"in.txt\",\"r\",stdin);\n    (new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dprint(Exp,...) if(Exp){fprintf(stderr, __VA_ARGS__);}\n#define printe(...) fprintf(stderr, __VA_ARGS__);\n#define PrtExp(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp)\n#define PrtExpN(_Exp)  cerr<< #_Exp <<\" = \"<< (_Exp) <<\"\\n\"\n\n#define SINT(n) scanf(\"%d\",&n)\n#define SINT2(n,m) scanf(\"%d %d\",&n,&m)\n#define SINT3(n,m,o) scanf(\"%d %d %d\",&n,&m,&o)\n#define SINT4(n,m,o,p) scanf(\"%d %d %d %d\",&n,&m,&o,&p)\n#define SINT5(n,m,o,p,q) scanf(\"%d %d %d %d %d\",&n,&m,&o,&p,&q)\n#define SLL(n) scanf(\"%lld\",&n)\n#define SLL2(n,m) scanf(\"%lld %lld\",&n,&m)\n#define SLL3(n,m,o) scanf(\"%lld %lld %lld\",&n,&m,&o)\n#define SST(s) scanf(\"%s\",s)\n#define SCH(c) scanf(\"%c\",&c)\n\n#define GC() getchar()\n\n#define PINT(n) printf(\"%d\",(int)(n))\n#define PINT2(n,m) printf(\"%d %d\",(int)(n),(int)(m))\n#define PINT3(n,m,l) printf(\"%d %d %d\",(int)(n),(int)(m),(int)(l))\n#define PLL(n) printf(\"%lld\",(long long)(n))\n#define PST(s) printf(\"%s\",(s))\n#define PCH(s) printf(\"%c\",(s))\n\n#define PINTN(n) printf(\"%d\\n\",(int)(n))\n#define PINT2N(n,m) printf(\"%d %d\\n\",(int)(n),(int)(m))\n#define PINT3N(n,m,l) printf(\"%d %d %d\\n\",(int)(n),(int)(m),(int)(l))\n#define PLLN(n) printf(\"%lld\\n\",(long long)(n))\n#define PSTN(s) printf(\"%s\\n\",(s))\n#define PCHN(s) printf(\"%c\\n\",(s))\n\n#define PSP() printf(\" \")\n#define PN() printf(\"\\n\")\n\n#define PC(c) putchar(c)\n#define CSP (' ')\n#define SN (\"\\n\")\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define reP(i,a) for(int i=0;i<=a;i++)\n#define Rep(i,a) for(int i=a-1;i>=0;i--)\n#define ReP(i,a) for(int i=a;i>=0;i--)\n\n#define rEp(i,a) for(i=0;i<a;i++)\n#define rEP(i,a) for(i=0;i<=a;i++)\n#define REp(i,a) for(i=a-1;i>=0;i--)\n#define REP(i,a) for(i=a;i>=0;i--)\n\n#define repft(i,a,b) for(int i=a;i<b;i++)\n#define repfT(i,a,b) for(int i=a;i<=b;i++)\n#define Repft(i,a,b) for(int i=a-1;i>=b;i--)\n#define RepfT(i,a,b) for(int i=a;i>=b;i--)\n\n#define foreach(a,it) for(auto it = a.begin(); it != a.end(); ++it)\n\n#define FILL(a,v) fill(begin(a),end(a), v)\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll>   Pll;\n\n\nconst int INF = 0x2aaaaaaa; // 715,827,882\nconst ll INFLL = 0x1f1f1f1f1f1f1f1fLL;//2,242,545,357,980,376,863\n\ntemplate <class A, class B> inline ostream& operator<<(ostream& st, const pair<A, B>& P) { return st << \"(\" << P.first << \",\" << P.second << \")\"; };\ntemplate <class A, class B> inline pair<A, B> operator+(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first + Q.first, P.second + Q.second); };\ntemplate <class A, class B> inline pair<A, B> operator-(const pair<A, B>& P, const pair<A, B>& Q) { return pair<A, B>(P.first - Q.first, P.second - Q.second); };\n\n#define fs  first\n#define sc  second\n\n\n\nint d[16][16] = {};\nbool pass[16][16] = {};\n\n\nint stu[12345][3];\n\nint main() {\n\tint A, B;\n\tcin >> A >> B;\n\n\trep(i, A)rep(j, B) {\n\t\tcin >> d[i][j];\n\t}\n\n\tint stuN = 0;\n\n\trep(s, 100)rep(t, 100) {\n\t\tint u = 0;\n\t\trep(i, A)rep(j, B) {\n\t\t\tint x = i + 1;\n\t\t\tint y = j + 1;\n\t\t\tu = max(u, d[i][j] - s*x - t*y);\n\t\t}\n\t\tbool f = true;\n\t\t\n\t\tif ([&]() {\n\t\t\tbool f = false;\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u < d[i][j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f;\n\t\t}()) {\n\t\t\trep(i, A)rep(j, B) {\n\t\t\t\tint x = i + 1;\n\t\t\t\tint y = j + 1;\n\t\t\t\tif (s*x + t*y + u == d[i][j]) {\n\t\t\t\t\tpass[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstu[stuN][0] = s;\n\t\t\tstu[stuN][1] = t;\n\t\t\tstu[stuN][2] = u;\n\t\t\tstuN++;\n\t\t\t//cout << s << \"x + \" << t << \"y + \"<<u << endl;\n\t\t}\n\t}\n\trep(i, A)rep(j, B) {\n\t\tif (!pass[i][j]) {\n\t\t\tcout << \"Impossible\" << endl; return 0;\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\n\tint E = A*B+1;\n\n\tcout << A*B+1 << \" \" << A*(B - 1) + (A - 1)*B + stuN << endl;\n\n\trep(i, A) {\n\t\trep(j, B - 1) {\n\t\t\tcout << i*B + j + 1 << \" \" << i*B + j + 2 << \" Y\\n\";\n\t\t}\n\t}\n\trep(i, A - 1) {\n\t\trep(j, B) {\n\t\t\tcout << i*B + j + 1 << \" \" << (i+1)*B + j + 1 << \" X\\n\";\n\t\t}\n\t}\n\n\n\n\trep(k, stuN) {\n\t\t//cout << stu[i][0] << \"x + \" << stu[i][1] << \"y + \"<< stu[i][2] << endl;\n\t\tint i = stu[k][1];\n\t\tint j = stu[k][0];\n\t\tint c = stu[k][2];\n\t\tcout << i*B + j + 1 << \" \" << E << \" \"<<c << endl;\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntypedef tuple<ll, ll, ll> tp;\nint main(int argc, char const *argv[]) {\n  // aX + bY + c = d11 不可能な(a, b, c)がわかる\n  // 10000条件×10000試行\n  // 不可能なものを削る\n\n  ll a, b;std::cin >> a >> b;\n  vvl d = VV(a+1, b+1, 0, ll);\n  re(i, a) re(j, b) scanf(\"%lld\", &d[i+1][j+1]);\n  ll x = d[1][1];\n  ll INF = 1000000000;\n  vvl cost = VV(a+1, b+1, INF, ll);\n\n\n  vector<tp> use;\n  for(ll i=0;i<=x;i++){\n    for(ll j=0;i+j<=x;j++){\n      for(ll k=0;k<=x;k++){\n        //i, j, kの時のコストが下回ったら絶対に使えない\n        for(ll A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            if(i*A+j*B+k<d[A][B]) goto nxt;\n          }\n        }\n        use.push_back(tp(i, j, k));//採用\n        for(int A=1;A<=a;A++){\n          for(int B=1;B<=b;B++){\n            cost[A][B] = min(cost[A][B], i*A+j*B+k);\n          }\n        }\n        nxt:;\n      }\n    }\n  }\n\n  //verify\n  std::cout << \"---\" << '\\n';\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      std::cout << cost[i][j] << \" \";\n    }\n    std::cout << '\\n';\n  }\n  for(int i=1;i<=a;i++){\n    for(int j=1;j<=b;j++){\n      if(cost[i][j]!=d[i][j]){\n        std::cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n\n  throw runtime_error(\"error\");\n  std::cout << \"Possible\" << '\\n';\n  if(x==100){\n    std::cout << \"2 1\" << '\\n';\n    std::cout << \"1 2 100\" << '\\n';\n    std::cout << \"1 2\" << '\\n';\n    return 0;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define iinf 2000000000\n#define linf 1000000000000000000LL\n#define ulinf 10000000000000000000ull\n#define MOD1 1000000007\n#define lson(v) ((v)<<1)\n#define rson(v) (((v)<<1)^1)\n#define mpr make_pair\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned long UL;\ntypedef unsigned short US;\ntypedef pair < int , int > pii;\ntypedef pair < pii , int > p3i;\nclock_t __stt;\ninline void TStart(){__stt=clock();}\ninline void TReport(){printf(\"\\nTaken Time : %.3lf sec\\n\",(double)(clock()-__stt)/CLOCKS_PER_SEC);}\ntemplate < typename T > T MIN(T a,T b){return a<b?a:b;}\ntemplate < typename T > T MAX(T a,T b){return a>b?a:b;}\ntemplate < typename T > T ABS(T a){return a>0?a:(-a);}\ntemplate < typename T > void UMIN(T &a,T b){if(b<a) a=b;}\ntemplate < typename T > void UMAX(T &a,T b){if(b>a) a=b;}\nint A,B,arr[15][15];\nvector < p3i > paths;\nint main(){\n    // inputing start\n    scanf(\"%d%d\",&A,&B);\n\tint xb,x2,x3,x4,x5,mmax=0,mmay=0;\n\tfor(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tscanf(\"%d\",&arr[xb][x2]);\n\t\t}\n\t}\n    #ifdef LOCAL\n        TStart();\n    #endif\n    // calculation start\n    for(xb=0;xb<A;++xb){\n\t\tfor(x2=0;x2<B;++x2){\n\t\t\tint a=xb+1,b=x2+1,k=arr[xb][x2],maxy=105,miny=0;\n\t\t\tfor(x5=0;x5<=105;++x5){\n\t\t\t\tmaxy=105;miny=0;\n\t\t\t\tfor(x3=0;x3<A;++x3){\n\t\t\t\t\tfor(x4=0;x4<B;++x4){\n\t\t\t\t\t\tint n=x3+1,m=x4+1,c=arr[x3][x4],coe=m-b,val=c-k-x5*(n-a);\n\t\t\t\t\t\tif(x3==xb && x4==x2){\n\t\t\t\t\t\t\tn=-a;m=-b;c=-k;\n\t\t\t\t\t\t\tval=c-k-x5*(n-a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe*val<0){\n\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(val==0){\n\t\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\t\tUMIN(maxy,0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe==0){\n\t\t\t\t\t\t\tif(val>0){\n\t\t\t\t\t\t\t\tminy=110;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe<0){\n\t\t\t\t\t\t\tUMIN(maxy,(-val)/(-coe));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(coe>0){\n\t\t\t\t\t\t\tUMAX(miny,(val+coe-1)/coe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(miny<=maxy){\n\t\t\t\t\tpaths.push_back(mpr(mpr(x5,miny),k-x5*a-miny*b));\n\t\t\t\t\tUMAX(mmax,x5);\n\t\t\t\t\tUMAX(mmay,miny);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x5>105){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\tax+by+z=k\n\t\t\t *  -ax-by>=-k\n\t\t\t\tz=k-ax-by\n\t\t\t\tnx+my+k-ax-by>=c\n\t\t\t\t(n-a)x+(m-b)y>=c-k  \n\t\t\t\tcoe*y>=val  \n\t\t\t\tor\n\t\t\t\t-coe*y<=-val  */\n\t\t}\n\t}\n\tsort(paths.begin(),paths.end());\n\tpaths.erase(unique(paths.begin(),paths.end()),paths.end());\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",mmax+1+mmay+1,mmax+mmay+(int)paths.size());\n\tfor(xb=0;xb<mmax;++xb){\n\t\tprintf(\"%d %d x\\n\",xb+1,xb+2);\n\t}\n\tfor(xb=mmay-1;xb>=0;--xb){\n\t\tprintf(\"%d %d y\\n\",mmax+xb+3,mmax+xb+2);\n\t}\n\tfor(xb=0;xb<paths.size();++xb){\n\t\tprintf(\"%d %d %d\\n\",paths[xb].first.first+1,paths[xb].first.second+mmax+2,paths[xb].second);\n\t}\n\tprintf(\"%d %d\\n\",1,mmax+2);\n    #ifdef LOCAL\n        TReport();\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B, E;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 0; i < 100; i++) {\n        adj[ X(i) ].push_back(pii(X(i + 1), -1));\n    }\n    for(int i = 100; i >= 1; i--) {\n        adj[ Y(i) ].push_back(pii(Y(i - 1), -2));\n    }\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    E = 0;\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                E++;\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", V, E);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) {\n                if(w == -1) printf(\"%d %d X\\n\", u + 1, v + 1);\n                else if(w == -2) printf(\"%d %d Y\\n\", u + 1, v + 1);\n                else printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n            }\n        }\n    }\n\n    printf(\"%d %d\", src + 1, snk + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ninline void check_max(int a,int &b){if(a>b)b=a;}\ninline void check_min(int a,int &b){if(a<b)b=a;}\n\nnamespace YouQu____o_o________nyg_tai_qiang_le\n{\n\ttypedef std::pair<int,int> pii;\n\tconst int N=12,M=202;\n\n\tstruct outputer\n\t{\n\t\tint n,m,S,T;\n\t\tint w[M*M];\n\t\tpii E[M*M];\n\t\tvoid reset(int n_){n=n_,m=0;}\n\t\tvoid insert(int u,int v,int k){E[++m]=pii(u,v);w[m]=k;}\n\t\tvoid output()\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",n+1,m);\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d \",E[i].first+1,E[i].second+1);\n\t\t\t\tif(w[i]==-1)printf(\"X\\n\");\n\t\t\t\telse if(w[i]==-2)printf(\"Y\\n\");\n\t\t\t\telse printf(\"%d\\n\",w[i]);\n\t\t\t}\n\t\t\tprintf(\"%d %d\\n\",S+1,T+1);\n\t\t}\n\t}d;\n\n#define idx(p) (p)\n#define idy(p) (201-(p))\n\n\tint dis[N][N],G[M][M];\n\tint A,B,lim;\n\n\tint calc(int x,int y)\n\t{\n\t\tint ret=23333;\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\tcheck_min(x*i+y*j+G[i][j],ret);\n\t\treturn ret;\n\t}\n\n\tvoid solve()\n\t{\n\t\tlim=100;\n\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tscanf(\"%d\",&dis[i][j]);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t{\n\t\t\t\tG[i][j]=0;\n\t\t\t\tfor(int x=1;x<=A;x++)\n\t\t\t\t\tfor(int y=1;y<=B;y++)\n\t\t\t\t\t\tcheck_max(dis[x][y]-x*i-y*j,G[i][j]);\n\t\t\t}\n\n\t\tfor(int i=1;i<=A;i++)\n\t\t\tfor(int j=1;j<=B;j++)\n\t\t\t\tif(calc(i,j)!=dis[i][j]){printf(\"Impossible\\n\");return;}\n\n\t\tprintf(\"Possible\\n\");\n\n\t\td.reset(idy(0));d.S=idx(0),d.T=idy(0);\n\n\t\tfor(int i=0;i<lim;i++)d.insert(idx(i),idx(i+1),-1);\n\t\tfor(int i=lim;i;i--)d.insert(idy(i),idy(i-1),-2);\n\n\t\tfor(int i=0;i<=lim;i++)\n\t\t\tfor(int j=0;j<=lim;j++)\n\t\t\t\td.insert(idx(i),idy(j),G[i][j]);\n\n\t\td.output();\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"out\",\"w\",stdout);\n\tYouQu____o_o________nyg_tai_qiang_le::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n        cout << \"Impossible\";\nreturn 0;\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tif(i<99){\n\t\t\tcout << i << \" \" << i+1 << \" X\\n\";\n\t\t\tcout << i+100 << \" \" << i+101 << \" Y\\n\";\n\t\t}\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tcout << \"1 199\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <utility>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define unique(x) x.erase(unique(x.begin(), x.end()), x.end())\n#define all(a) a.begin(), a.end()\n#define sqr(x) ((x) * (x)) \n#define y1 aksjdaskdjksjfksdjf\n#define left kdnvldvoiwejifejg\n#define right lkdsjflksdjfdjfk\n#define prev asdasfsadjkjsdfjs\n#define tm aklsjdasjdasjdkdjjf\n#define lcm hddalkwjeidjjhasda\n#define random_shuffle asdasdd\n\nconst int MAXN = 105;\n\nint a, b;\nint d[MAXN][MAXN];\nint f[MAXN][MAXN];\nvector < pair< pair<int, int>, int > > ans;\n\nvoid addEdge(int from, int to, int w) {\n  ans.push_back({{from, to}, w});\n}\n\nint main() { \n\n  scanf(\"%d %d\", &a, &b);\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      scanf(\"%d\", &d[i][j]);\n    }\n  }\n\n  for (int i = 0; i < a; i++) {\n    for (int j = 0; j < b; j++) {\n      for (int x = 0; x <= 100; x++) {\n        for (int y = 0; y <= 100; y++) {\n          int cur = (i + 1) * x + (j + 1) * y;\n          f[x][y] = max(f[x][y], d[i][j] - cur);\n        }\n      }\n    }\n  }\n\n  for (int i = 1; i <= a; i++) {\n    for (int j = 1; j <= b; j++) {\n      int dist = 1e9;\n      for (int x = 0; x <= 100; x++) {\n        for (int y = 0; y <= 100; y++) {\n          dist = min(dist, i * x + j * y + f[x][y]);\n        }\n      }\n      if (dist != d[i - 1][j - 1]) {\n        puts(\"Impossible\");\n        return 0;\n      }\n    }\n  }\n\n  int n = 2;\n  addEdge(1, 2, 0);\n  for (int i = 1; i <= 100; i++) {\n    n++;\n    addEdge(n - 1, n, -1);\n  }\n\n  n++;\n  for (int i = 1; i <= 100; i++) {\n    n++;\n    addEdge(n - 1, n, -2);\n  }\n  n++;\n  addEdge(n - 1, n, 0);\n\n  for (int x = 0; x <= 100; x++) {\n    for (int y = 0; y <= 100; y++) {\n      addEdge(2 + x, n - 1 - y, f[x][y]);\n    }\n  }\n\n  printf(\"%d %d\\n\", n, sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d \", ans[i].first.first, ans[i].first.second);\n    if (ans[i].second >= 0) {\n      printf(\"%d\\n\", ans[i].second);\n    } else if (ans[i].second == -1) {\n      printf(\"X\\n\");\n    } else {\n      printf(\"Y\\n\");\n    }\n  }\n  printf(\"%d %d\\n\", 1, n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int a, b;\n  cin >> a >> b;\n  int d[11][11];\n  reps(x, 1, a+1) reps(y, 1, b+1) cin >> d[x][y];\n\n  int n[101][101] = {{}};\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    rep(l, 101) rep(m, 101) {\n      chmax(n[l][m], d[x][y]-l*x-m*y);\n    }\n  }\n\n  reps(x, 1, a+1) reps(y, 1, b+1) {\n    int e = inf;\n    rep(l, 101) rep(m, 101) {\n      chmin(e, l*x+m*y+n[l][m]);\n    }\n    if(e != d[x][y]) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n\n  int cnt = 0;\n  cout << \"Possible\" << endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  rep(i, 100) cout << i+1 << \" \" << i+2 << \" \" << 'X' << endl, cnt++;\n  rep(i, 100) cout << i+101+2 << \" \" << i+101+1 << 'Y' << endl, cnt++;\n  rep(l, 101) rep(m, 101) cout << l+1 << \" \" << m+101+1 << \" \" << n[l][m] << endl, cnt++;\n  cout << 1 << \" \" << 102 << endl;\n  //cout << cnt << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll X, Y; cin >> X >> Y;\n    vvll d(X, vll(Y)); cin >> d;\n\n    // X=x, Y=y (1 <= x <= X, 1 <= y <= Y)\n    // a = xの数、b = yの数 (0 <= a, b <= 100)\n    //\n    // for all x,y  \n    //      d_xy = min_ab ax+by+c_ab\n    //\n    // c_ab = max(0, max_xy d_xy - ax - by)\n    ll abmax = 101;\n\n    vvll c(abmax, vll(abmax));\n    rep(a, abmax) rep(b, abmax) {\n        repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n            chmax(c[a][b], d[x-1][y-1]-a*x-b*y);\n        }\n    }\n    repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n        ll tmp = INF;\n        rep(a, abmax) rep(b, abmax) {\n            chmin(tmp, a*x+b*y+c[a][b]);\n        }\n        if (d[x-1][y-1] != tmp) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    ll n = 2 * (abmax+1);\n    ll m = abmax*abmax + abmax * 2;\n    cout << n << \" \" << m << endl;\n    rep(i, abmax) {\n        cout << i+1 << \" \" << i+1+1 << \" \" << \"X\" << endl;\n        cout << 2*abmax+1-i-1+1 << \" \" << 2*abmax+1-i+1 << \" \" << \"Y\" << endl;\n    }\n    rep(a, abmax) rep(b, abmax) {\n        cout << a+1 << \" \" << 2 * abmax + 1 - b+1 << \" \" << c[a][b] << endl;\n    }\n    cout << 1 << \" \" << n << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\n\nint main(){\n//\tfreopen(\"graphxy.in\",\"r\", stdin);\n//\tfreopen(\"graphxy.out\",\"w\", stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<=100; a++)\n\t\tfor(int b=0; b<=100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<=100; x++){\n\t\t\t\tfor(int y=0; y<=100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i+1 << \" \" << 200-j << \" \" << ans[i][j] << \"\\n\";\n\t}\n\tfor(int i=1; i<100; i++) cout << i << \" \" << i+1 << \" X\\n\";\n\tfor(int i=101; i<200; i++) cout << i << \" \" << i+1 << \" Y\\n\";\n\tcout << \"1 200\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <tuple>\nusing namespace std;\n\n#define FOR(i,init,a) for(int i=init; i<a; i++)\n#define rep(i,a) FOR(i,0,a)\n#define rrep(i,a) for(int i=a; i>=0; i--)\n#define rep1(i,a) for(int i=1; i<=a; i++)\n#define cout1(a) cout << a << endl;\n#define cout2(a,b) cout << a << \" \" << b << endl;\n#define cout3(a,b,c) cout << a << \" \" << b << \" \" << c << endl;\n#define cout4(a,b,c,d) cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n#define mem(a,n) memset( a, n, sizeof(a))\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LLINF = 1e18;\nstatic const double pi = 3.141592653589793;\n\nint A, B, C[12][12], D[101][101], DX[12][12], DY[12][12], NV, V[303][303], K=100;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    rep(i,303)rep(j,303) V[i][j]=-1;\n    cin>>A>>B;\n    rep1(x,A)rep1(y,B) cin>>C[x][y];\n    \n    vector<int> Xs, Ys;\n    NV=1;\n    Xs.push_back(NV);\n    rep(i,K){\n        V[NV][NV+1]=-2;\n        NV++;\n        Xs.push_back(NV);\n    }\n    \n    NV++;\n    Ys.push_back(NV);\n    rep(i,K){\n        V[NV+1][NV]=-3;\n        NV++;\n        Ys.push_back(NV);\n    }\n    \n    rep(x,K+1)rep(y,K+1){\n        int ret=0;\n        rep1(i,A)rep1(j,B){\n            ret=max(ret,C[i][j]-x*i-y*j);\n        }\n        D[x][y]=V[Xs[x]][Ys[y]]=ret;\n    }\n    \n    rep1(i,A)rep1(j,B){\n        int mi=1010;\n        rep(x,K+1)rep(y,K+1){\n            mi=min(mi,x*i+j*y+D[x][y]);\n        }\n        if(mi!=C[i][j]){\n            cout1(\"Impossible\");\n            return 0;\n        }\n    }\n    \n    int cnt=0;\n    rep(x,303)rep(y,303) if(V[x][y]!=-1) cnt++;\n    cout1(\"Possible\");\n    cout2(NV,cnt);\n    rep(x,303)rep(y,303) if(V[x][y]!=-1){\n        cout<<x<<\" \"<<y<<\" \";\n        if(V[x][y]==-2) cout1(\"X\");\n        if(V[x][y]==-3) cout1(\"Y\");\n        if(V[x][y]>=0) cout1(V[x][y]);\n    }\n    cout2(Xs[0],Ys[0]);\n}"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint constexpr MAXVAL=101;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=std::min(sum,MAXVAL);++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint maxd1=INT_MIN;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmaxd1=std::max(maxd1,d1[x][y]-=(x+1)*nx+(y+1)*ny);\n\t\t\t}\n\t\t\tif(maxd1<0)\n\t\t\t\tcontinue; // useless line (all value strictly > d)\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==maxd1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tconnval[nx][ny]=maxd1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tint const source=1;\n\tint const dest=MAXVAL+2;\n\t// 1 --(X)-- 2 --(X)-- ... MAXVAL+1\n\t//\n\t// MAXVAL+2 --(Y)-- ... 2*MAXVAL+2\n\n\tint const nnode=2*MAXVAL+2;\n\n\tassert(nnode<=300);\n\tstd::cout<<\"Possible\\n\"<<nnode<<' '<<MAXVAL*2+n_connedge<<'\\n';\n\n\tfor(int i=0;i<MAXVAL;++i){\n\t\tstd::cout<<i+1<<' '<<i+2<<\" X\\n\";\n\t\tstd::cout<<i+MAXVAL+2<<' '<<i+MAXVAL+3<<\" Y\\n\";\n\t}\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const v=connval[nx][ny];\n\t\tif(v>=0)\n\t\t\tstd::cout<<1+nx<<' '<<MAXVAL+2+ny<<' '<<connval[nx][ny]<<'\\n';\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\tif (d[x][y] == f[i][j] + i * x + j * y) goto end;\n\t\t\treturn puts(\"Impossible\"), 0;\n\t\tend:;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i ? i : 201, j ? j + 100 : 202, d[i][j]);\n\tputs(\"201 202\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint A,B;\nint d[11][11];\nconst int T = 100;\n \nint c[T+1][T+1];\n \nint main(){\n\tcin>>A>>B;\n\trep1(x,A) rep1(y,B) cin>>d[x][y];\n\trep(i,T+1) rep(j,T+1){\n\t\tint cij = 0;\n\t\trep1(x,A) rep1(y,B) chmax(cij,d[x][y]-x*i-y*j);\n\t\tc[i][j] = cij;\n\t}\n \n\trep1(x,A) rep1(y,B){\n\t\tint dxy = 1e9;\n\t\trep(i,T+1) rep(j,T+1) chmin(dxy,x*i+y*j+c[i][j]);\n\t\tif(dxy != d[x][y]){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tint N = (T+1)*2, M = T*2 + (T+1)*(T+1);\n\tcout<<N<<\" \"<<M<<endl;\n\trep(t,T){\n\t\tcout<<1+t<<\" \"<<2+t<<\" X\"<<endl;\n\t}\n\trep(t,T){\n\t\tcout<<T+3+t<<\" \"<<T+2+t<<\" Y\"<<endl;\n\t}\n\trep(i,T+1) rep(j,T+1){\n\t\tcout<<1+i<<\" \"<<T+2+j<<\" \"<<c[i][j]<<endl;\n\t}\n\tcout<<1<<\" \"<<T+2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > d(A,vector<int>(B));\n\tfor(int i =0; i < A*B; i++) cin >> d[i/B][i%B];\n\n\tvector< vector<int> > mincost(101,vector<int>(101,0));\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++)\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\t mincost[k][l] =max(d[i][j]-k*i-l*j,mincost[k][l]);\n\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++) {\n\t\tint m =101;\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\tm =min(m,mincost[k][l]+k*i+l*j);\n\t\tif(m != d[i][j]) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tint N =2*(100+1), M =(N/2)*(N/2)+2*(N/2-1);\n\tcout << N << \" \" << M << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i =0; i <= N/2-1; i++) for(int j =0; j <= N/2-1; j++)\n\t\tcout << i+1 << \" \" << j+N/2+1 << \" \" << mincost[i][j] << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+N/2+1 << \" \" << i+N/2+2 << \" Y\\n\";\n\tcout << \"1 \" << N << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define reg register\n#define MAXN 101\n#define MAXI 11\nusing namespace std;\n\nint dis[MAXI][MAXI];\nint f[MAXN][MAXN];\nint n,m;\n\ninline int max(int a,int b)\n{return(a>b?a:b);}\n\ninline int min(int a,int b)\n{return(a<b?a:b);}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&dis[i][j]);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tfor(reg int px=1;px<=n;px++)\n\t\t\t\tfor(reg int py=1;py<=m;py++)\n\t\t\t\t\tf[i][j]=max(f[i][j],dis[px][py]-i*px-j*py);\n\tfor(reg int px=1;px<=n;px++)\n\t\tfor(reg int py=1;py<=m;py++)\n\t\t{\n\t\t\tint tmp=2147483647;\n\t\t\tfor(reg int i=0;i<=100;i++)\n\t\t\t\tfor(reg int j=0;j<=100;j++)\n\t\t\t\t\ttmp=min(tmp,f[i][j]+i*px+j*py);\n\t\t\tif(tmp!=dis[px][py])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tputs(\"202 10401\");\n\tfor(reg int i=1;i<=100;i++)\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(reg int i=102;i<=201;i++)\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor(reg int i=0;i<=100;i++)\n\t\tfor(reg int j=0;j<=100;j++)\n\t\t\tprintf(\"%d %d %d\",1+i,202-j,f[i][j]);\n\tprintf(\"1 202\");\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nusing Data = pair<pii, int>;\nusing Edge = pair<pii, char>;\n\nint A;\nint B;\nint d[114][114];\n\nvoid Output(vector<Data> &ds) {\n  int N = 202;\n  vector<Edge> es;\n\n  puts(\"Possible\");\n  rep(i, 100) {\n    es.eb(Edge(pii(i, i+1), 'X'));\n    es.eb(Edge(pii(i+100, i+101), 'Y'));\n  }\n\n  map<pii, int> cnt;\n  for (auto &d : ds) {\n    int p, q;\n    tie(p, q) = d.X;\n    assert(!cnt.count(d.X));\n    cnt[d.X]++;\n    assert(p <= 100 && q <= 100);\n    int t = d.Y;\n    es.eb(Edge(pii(p, N-1-q), -t));\n  }\n\n  cout << N << \" \" << es.size() << endl;\n  for (auto &e : es) {\n    int u, v;\n    tie(u, v) = e.X;\n    char c = e.Y;\n    if (c <= 0) {\n      int l = -c;\n      cout << u+1 << \" \" << v+1 << \" \" << l << endl;\n    } else {\n      assert(c == 'X' || c == 'Y');\n      cout << u+1 << \" \" << v+1 << \" \" << c << endl;\n    }\n  }\n  cout << 1 << \" \" << N << endl;\n}\n\nint main() {\n  cin >> A >> B;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      cin >> d[i][j];\n    }\n  }\n\n  vector<Data> ds;\n  reps(i, 1, A+1) {\n    reps(j, 1, B+1) {\n      int p = 1000;\n      int q = 1000;\n      rep(a, 101) {\n        rep(b, 101) {\n          int t = d[i][j] - a*i - b*j;\n          if (t < 0) break;\n\n          bool ok = true;\n          reps(k, 1, A+1) {\n            reps(l, 1, B+1) {\n              if ((k-i)*a + (l-j)*b < d[k][l] - d[i][j]) {\n                ok = false;\n                goto L_OUT;\n              }\n            }\n          }\nL_OUT:\n          if (ok) {\n            if (p+q > a+b) {\n              p = a;\n              q = b;\n            }\n          }\n        }\n      }\n\n      if (p == 1000) {\n        puts(\"Impossible\");\n        return 0;\n      }\n\n      ds.eb(Data(pii(p, q), d[i][j] - p*i - q*j));\n    }\n  }\n  sort(all(ds));\n  ds.erase(unique(all(ds)), ds.end());\n  Output(ds);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 150;\nconst int M = (int) 20;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nconst int nx[4] = {0, 0, -1, 1};\nconst int ny[4] = {1, -1, 0, 0};\n\nint A, B;\nint d[N][N];\nint f[N][N];\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n  //    freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> A >> B;\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      cin >> d[i][j];\n    }\n  }\n  for (int a = 0; a < N; a++) {\n    for (int b = 0; b < N; b++) {\n      for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++) {\n          f[a][b] = max(f[a][b], d[i][j] - i * a - j * b);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      bool cur = false;\n      for (int a = 0; a < N; a++) {\n        for (int b = 0; b < N; b++) {\n          if (d[i][j] == f[a][b] + a * i + b * j) {\n            cur = true;\n          }\n        }\n      }\n      if (!cur) {\n        cout << \"Impossible\";\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\\n\";\n  cout << 200 << ' ' << 100 * 100 + 99 * 2 << endl;\n  for (int a = 0; a + 1 < 100; a++) {\n    cout << a + 1 << ' ' << a + 2 << \" X\\n\";\n  }\n  for (int b = 0; b + 1 < 100; b++) {\n    cout << b + 1 << ' ' << b + 2 << \" Y\\n\";\n  }\n  for (int a = 0; a < 100; a++) {\n    for (int b = 0; b < 100; b++) {\n      cout << a + 1 << ' ' << 100 + 100 - b << ' ' << f[a][b] << \"\\n\";\n    }\n  }\n  cout << 1 << ' ' << 200;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 150;\nconst int M = (int) 20;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nconst int nx[4] = {0, 0, -1, 1};\nconst int ny[4] = {1, -1, 0, 0};\n\nint A, B;\nint d[N][N];\nint f[N][N];\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n  //    freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> A >> B;\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      cin >> d[i][j];\n    }\n  }\n  for (int a = 0; a < N; a++) {\n    for (int b = 0; b < N; b++) {\n      for (int i = 1; i <= A; i++) {\n        for (int j = 1; j <= B; j++) {\n          f[a][b] = max(f[a][b], d[i][j] - i * a - j * b);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= A; i++) {\n    for (int j = 1; j <= B; j++) {\n      int mn = INF;\n      for (int a = 0; a < N; a++) {\n        for (int b = 0; b < N; b++) {\n          mn = min(mn, f[a][b] + a * i + b * j);\n        }\n      }\n      if (mn != d[i][j]) {\n        cout << \"Impossible\";\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\\n\";\n  cout << 200 << ' ' << 100 * 100 + 99 * 2 << endl;\n  for (int a = 0; a + 1 < 100; a++) {\n    cout << a + 1 << ' ' << a + 2 << \" X\\n\";\n  }\n  for (int b = 0; b + 1 < 100; b++) {\n    cout << 100 + b + 1 << ' ' << 100 + b + 2 << \" Y\\n\";\n  }\n  for (int a = 0; a < 100; a++) {\n    for (int b = 0; b < 100; b++) {\n      cout << a + 1 << ' ' << 100 + 100 - b << ' ' << f[a][b] << \"\\n\";\n    }\n  }\n  cout << 1 << ' ' << 200;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\nstruct edge{\n    int x,y,u;\n};\nvector<edge> conn;\nconst int MAX=12,INF=0x3f3f3f3f;\nint a,b,d[MAX][MAX],d_est[MAX][MAX],val[110][110],x_max,y_max;\nint update(int x,int y,int z){\n    if(x<0||y<0||z<0) return 0;\n    val[x][y]=z;\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++){\n            d_est[i][j]=min(d_est[i][j],val[x][y]+i*x+j*y);\n            if(d[i][j]>d_est[i][j]) return 0;\n        }\n    }\n    return 1;\n}\nint main(){\n    scanf(\" %d %d\",&a,&b);\n    for(int i=1;i<=a;i++){\n        for(int j=1;j<=b;j++) scanf(\" %d\",&d[i][j]);\n    }\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++) val[i][j]=-1;\n    for(int i=0;i<=a;i++) for(int j=0;j<=b;j++) d_est[i][j]=INF;\n    for(int i=a;i>=1;i--){\n        if(b==1){\n            int x=0,y=0,z=0;\n            if(i==a) x=0,y=0,z=d[i][1]-x*i-y;\n            else y=0,x=d[i+1][1]-d[i][1],z=d[i][1]-x*i-y;\n            if(!update(x,y,z)){\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n        else for(int j=b;j>=2;j--){\n            int x=0,y=0,z=0;\n            if(i==a) x=0,y=d[i][j]-d[i][j-1],z=d[i][j]-x*i-y*j;\n            else y=d[i][j]-d[i][j-1],x=max(d[i+1][j]-d[i][j],d[i+1][j-1]-d[i][j-1]),z=d[i][j]-x*i-y*j;\n            if(!update(x,y,z)){\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n    printf(\"Possible\\n\");\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) x_max=max(i,x_max),y_max=max(j,y_max);\n    }\n    for(int i=1;i<=x_max;i++) conn.push_back({i,i+1,-1});\n    for(int i=x_max+2;i<=x_max+y_max+1;i++) conn.push_back({i+1,i,-2});\n    for(int i=0;i<=100;i++) for(int j=0;j<=100;j++){\n        if(val[i][j]>=0) conn.push_back({i+1,x_max+2+j,val[i][j]});\n    }\n    printf(\"%d %d\\n\",x_max+y_max+2,conn.size());\n    for(int i=0;i<conn.size();i++){\n        if(conn[i].u==-1) printf(\"%d %d X\\n\",conn[i].x,conn[i].y);\n        else if(conn[i].u==-2) printf(\"%d %d Y\\n\",conn[i].x,conn[i].y);\n        else printf(\"%d %d %d\\n\",conn[i].x,conn[i].y,conn[i].u);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nconst int INF = 999999999;\n\nint n, m, d[550][550], f[550][550], tmp[550][550];\n\nvoid Read(int &x)\n{\n    x = 0; int p = 0; char st = getchar();\n    while (st < '0' || st > '9') p = (st == '-'), st = getchar();\n    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();\n    x = p ? -x : x;\n    return;\n}\n\nint Max(int a, int b)\n{\n    return a > b ? a : b;\n}\n\nint Min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            scanf(\"%d\", &d[i][j]);\n\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++) \n            for (int u = 1; u <= n; u++)\n                for (int v = 1; v <= m; v++)\n                    f[i][j] = Max(f[i][j], d[u][v] - i * u - j * v);\n\n    for (int x = 1; x <= n; x++)\n        for (int y = 1; y <= m; y++)\n        {\n            tmp[x][y] = INF;\n            for (int i = 0; i <= 100; i++)\n                for (int j = 0; j <= 100; j++)\n                    tmp[x][y] = Min(tmp[x][y], i * x + j * y + f[i][j]);\n        }\n\n\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            if(tmp[i][j] != d[i][j])\n            {\n                puts(\"Impossible\"); return 0;\n            }\n\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 10401);\n    for (int i = 1; i <= 100; i++) printf(\"%d %d X\\n\", i, i + 1);\n    for (int i = 102; i <= 201; i++) printf(\"%d %d Y\\n\", i, i + 1);\n    for (int i = 0; i <= 100; i++)\n        for (int j = 0; j <= 100; j++)\n            printf(\"%d %d %d\\n\", i + 1, 220 - j, f[i][j]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<set>\nusing namespace std;\nstruct p {\n\tint x, y, z;\n\tbool operator<(const p &A) const {\n\t\tif (x != A.x) return x < A.x;\n\t\tif (y != A.y) return y < A.y;\n\t\treturn z < A.z;\n\t}\n\tp& operator-=(const p &A) {\n\t\tx -= A.x; y -= A.y; z -= A.z;\n\t\treturn *this;\n\t}\n};\np cross(const p &A, const p &B) {\n\treturn { A.y*B.z - B.y*A.z, A.z*B.x - B.z*A.x, A.x*B.y - B.x*A.y };\n}\nstruct Plane {\n\tint a, b, c; // z = ax + by + c\n\tbool valid;\n\tPlane(p u, p v, p z) {\n\t\tvalid = false;\n\t\tu -= z; v -= z;\n\t\tp t = cross(u, v);\n\t\tif (t.z == 0 || t.x%t.z != 0 || t.y % t.z != 0) return;\n\t\ta = -t.x / t.z; b = -t.y / t.z;\n\t\tc = z.z - a * z.x - b * z.y;\n\t\tif (c < 0 || a < 0 || b < 0) return;\n\t\tvalid = true;\n\t}\n\tbool operator<(const Plane &A) const {\n\t\tif (a != A.a) return a < A.a;\n\t\tif (b != A.b) return b < A.b;\n\t\treturn c < A.c;\n\t}\n\tint operator()(const p &A) const {\n\t\treturn a * A.x + b * A.y + c;\n\t}\n};\nvector<p> v;\nint chk[111];\nbool isunder(Plane c, p x) {\n\treturn c(x) >= x.z;\n}\nset<Plane> ans;\nint main() {\n\tint a, b, n, t;\n\tscanf(\"%d%d\", &a, &b);\n\tn = a * b;\n\tfor (int i = 1; i <= a; i++)for (int j = 1; j <= b; j++) {\n\t\tscanf(\"%d\", &t);\n\t\tv.push_back({ i, j, t });\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) for (int k = j + 1; k < n; k++) {\n\t\tPlane t(v[i], v[j], v[k]);\n\t\tif (!t.valid) continue;\n\t\tint succ = 1;\n\t\tfor (auto x : v) {\n\t\t\tif (!isunder(t, x)) {\n\t\t\t\tsucc = 0; break;\n\t\t\t}\n\t\t}\n\t\tif (succ) {\n\t\t\tchk[i] = chk[j] = chk[k] = 1;\n\t\t\tans.insert(t);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (chk[i] == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"Possible\\n200 %d\\n\", 198 + ans.size());\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 1; i <= 99; i++) printf(\"%d %d Y\\n\", i + 100, i + 101);\n\tfor (auto t : ans) {\n\t\tprintf(\"%d %d %d\\n\", t.a + 1, 200 - t.b, t.c);\n\t}\n\tprintf(\"1 200\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[10][10], f[111][111];\nint main()\n{\n\tint a, b;\n\tcin >> a >> b;\n\tfor (int i = 0; i < a; i++)\n\t\tfor (int j = 0; j < b; j++)\n\t\t\tcin >> d[i][j];\n\tfor (int i = 0; i < 101; i++) {\n\t\tfor (int j = 0; j < 101; j++) {\n\t\t\tfor (int k = 0; k < a; k++)\n\t\t\t\tfor (int l = 0; l < b; l++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[k][l] - k * i - l * j);\n\t\t}\n\t}\n\tfor (int k = 0; k < a; k++) {\n\t\tfor (int l = 0; l < b; l++) {\n\t\t\tint m = 114514;\n\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\tfor (int j = 0; j < 101; j++)\n\t\t\t\t\tm = min(m, f[i][j] + k * i + l * j);\n\t\t\tif (m != d[k][l]) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n202 \" << 101 * 101 + 200 << \"\\n\";\n\tfor (int i = 0; i < 100; i++) {\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\t\tcout << i + 102 << ' ' << i + 103 << \" Y\\n\";\n\t}\n\tfor (int i = 1; i < 102; i++)\n\t\tfor (int j = 102; j < 203; j++)\n\t\t\tcout << i << ' ' << j << ' ' << f[i - 1][202 - j] << '\\n';\n\tcout << \"1 202\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int sz=200;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return 100+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n  //G[s].emplace_back(t,d[a-1][b-1]);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(C[k],d[i][j]-(k+1)*(i+1));\n\tchmax(D[k],d[i][j]-(k+1)*(j+1));\n      }\n    }\n  }\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<100;k++){\n\tchmax(E[k],d[i][j]-(100-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(100-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n\n  G[s].emplace_back(z,0);\n  for(Int i=0;i<100;i++){\n    G[idx(i)].emplace_back(t,C[i]);\n    G[idy(i)].emplace_back(t,D[i]);\n    G[z].emplace_back(idx(i),E[i]);\n    G[z].emplace_back(idy(i),F[i]);\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=0;k<100;k++){\n\tT[k?idx(k-1):s].emplace_back(idx(k),i+1);\n\tT[k?idy(k-1):s].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      flg&=dist==d[i][j];\n      assert(dist>=d[i][j]);\n    }\n  }\n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=0;i<100;i++){\n    X[i?idx(i-1):s].emplace_back(idx(i));\n    Y[i?idy(i-1):s].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//vjudge.net/contest/313071#problem/C\n\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<climits>\n\nint constexpr MAXVAL=100;\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint a,b;std::cin>>a>>b;\n\tstd::vector<std::vector<int>> d(a,std::vector<int>(b));\n\tfor(auto& row:d)for(int& x:row)std::cin>>x;\n\n\tstd::vector<std::vector<char>> done(a,std::vector<char>(b));\n\tstd::vector<std::vector<int>> d1;\n\n\tstd::vector<std::vector<int>> used(MAXVAL+1,std::vector<int>(MAXVAL+1));\n\tstd::vector<std::vector<int>> connval(MAXVAL+1,std::vector<int>(MAXVAL+1,-1));\n\tint n_connedge=0;\n\n\tfor(int sum=0;sum<=2*MAXVAL;++sum)\n\t\tfor(int nx=std::max(0,sum-MAXVAL);nx<=MAXVAL;++nx){\n\t\t\tint const ny=sum-nx;\n\t\t\td1=d;\n\t\t\tint maxd1=INT_MIN;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tmaxd1=std::max(maxd1,d1[x][y]-=(x+1)*nx+(y+1)*ny);\n\t\t\t}\n\t\t\tif(maxd1<0)\n\t\t\t\tcontinue; // useless line\n\n\t\t\tbool doneall=true,current_useful=false;\n\t\t\tfor(int x=0;x<a;++x)\n\t\t\tfor(int y=0;y<b;++y){\n\t\t\t\tif(done[x][y])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(d1[x][y]==maxd1){\n\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\tcurrent_useful=true;\n\t\t\t\t}else\n\t\t\t\t\tdoneall=false;\n\t\t\t}\n\n\t\t\tif(current_useful){\n\t\t\t\tused[nx][ny]=true;\n\t\t\t\tconnval[nx][ny]=maxd1;\n\t\t\t\t++n_connedge;\n\t\t\t}\n\t\t\tif(doneall)\n\t\t\t\tgoto break_outer;\n\t\t}\n\n\tstd::cout<<\"Impossible\\n\";\n\treturn 0;\n\nbreak_outer:\n\tused[0][0]=true;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny]){\n\t\t\tfor(int sumd=1;sumd<=2*MAXVAL;++sumd){\n\t\t\t\tfor(int dx=std::max(0,sumd-ny),\n\t\t\t\t\t\tmax_dx=std::min({MAXVAL,sumd,nx});\n\t\t\t\t\t\tdx<=max_dx;++dx){\n\t\t\t\t\tint dy=sumd-dx; // 0 <= dy && dy <= ny\n\t\t\t\t\tif(used[nx-dx][ny-dy]){\n\t\t\t\t\t\tint nx1=nx,ny1=ny;\n\t\t\t\t\t\twhile(dy--)\n\t\t\t\t\t\t\tused[nx1][--ny1]=true;\n\t\t\t\t\t\twhile(dx--)\n\t\t\t\t\t\t\tused[--nx1][ny1]=true;\n\t\t\t\t\t\tgoto break_outer_2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nbreak_outer_2:;\n\t\t}\n\n\tauto& index=used;\n\tint lastindex=0;\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny)\n\t\tif(used[nx][ny])\n\t\t\tindex[nx][ny]=++lastindex;\n\n\tint const n_used=lastindex; // 1 .. lastindex\n\tint const n_used_edge=n_used-1;\n\tint const source=1;\n\tint const dest=lastindex+1;\n\n\tstd::cout<<\"Possible\\n\"<<dest+1<<' '<<n_used_edge+n_connedge<<'\\n';\n\n\tfor(int nx=0;nx<=MAXVAL;++nx)\n\tfor(int ny=0;ny<=MAXVAL;++ny){\n\t\tint const curindex=index[nx][ny];\n\t\tif(curindex){\n\t\t\tif(nx!=0&&index[nx-1][ny])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx-1][ny]<<\" X\\n\";\n\t\t\telse if(ny!=0&&index[nx][ny-1])\n\t\t\t\tstd::cout<<curindex<<' '<<index[nx][ny-1]<<\" Y\\n\";\n\t\t\telse\n\t\t\t\tassert(nx==0&&ny==0);\n\t\t\tif(connval[nx][ny]>=0)\n\t\t\t\tstd::cout<<curindex<<' '<<dest<<' '<<connval[nx][ny]<<'\\n';\n\t\t}else\n\t\t\tassert(connval[nx][ny]<0);\n\t}\n\tstd::cout<<source<<' '<<dest<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\n\nconst ll INF = 1e15;\nconst double eps = 1e-6;\nconst ll MOD = 1000000007;\n\nint main() {\n\tll A, B;\n\tcin >> A >> B;\n\tvector<vector<ll>> d(A+1, vector<ll>(B+1));\n\tfor (int i = 1;i <= A;i++)\n\t\tfor (int j = 1;j <= B;j++)\n\t\t\tcin >> d[i][j];\n\tvector<vector<ll>> e(101, vector<ll>(101, 0));\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++)\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\te[ua][ub] = max(e[ua][ub], d[a][b] - (a * ua + b * ub));\n\tbool ok = true;\n\tfor (ll a = 1;a <= A;a++)\n\t\tfor (ll b = 1;b <= B;b++) {\n\t\t\tbool nowok = false;\n\t\t\tfor (ll ua = 0;ua <= 100;ua++)\n\t\t\t\tfor (ll ub = 0;ub <= 100;ub++)\n\t\t\t\t\tif (e[ua][ub] + a * ua + b * ub == d[a][b])\n\t\t\t\t\t\tnowok = true;\n\t\t\tok &= nowok;\n\t\t}\n\tif (!ok)\n\t\tcout << \"Impossible\" << endl;\n\telse {\n\t\tll cnt = 0;\n\t\tcout << \"Possible\" << endl;\n\t\tcout << \"202 \" << 101 * 101 + 100 + 100 << endl;\n\t\tfor (int i = 1;i <= 100;i++) {\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"X\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int i = 102;i <= 201;i++) {\n\t\t\tcout << i << \" \" << i + 1 << \" \" << \"Y\" << endl;\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int ua = 0;ua <= 100;ua++)\n\t\t\tfor (int ub = 0;ub <= 100;ub++) {\n\t\t\t\tcout << ua + 1 << \" \" << 202 - ub << \" \" << min(100LL, e[ua][ub]) << endl;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tcout << \"1 202\" << endl;\n\n//\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 350;\nconst int INF = 1<<30;\n\nint a, b, s, t, sum, d[N][N], f[N][N];\n\ninline void ck_min( int &a, int b ) { if( a > b ) a = b; }\ninline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\ninline bool check( int x, int y, int val )\n{\n    int res = INF;\n    for( int i = 0; i <= 100; i ++ )\n        for( int j = 0; j <= 100; j ++ )\n            if( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\n//  printf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n    return res == val;\n}\n\nint main()\n{\n    memset( f, -1, sizeof( f ) );\n\n    scanf( \"%d%d\", &a, &b );\n    for( int i = 1; i <= a; i ++ )\n        for( int j = 1; j <= b; j ++ )\n            scanf( \"%d\", &d[i][j] );\n\n    s = 201, t = 202; \n    // s --> 1 --> 2 --> ... --> 100\n    // t <-- 101 <-- 102 <-- ... <-- 200\n\n    for( int i = 0; i <= 100; i ++ )\n        for( int j = 0; j <= 100; j ++ )\n        {\n            int tmp = -INF;\n            for( int _a = 1; _a <= a; _a ++ )\n                for( int _b = 1; _b <= b; _b ++ )\n                    ck_max( tmp, d[_a][_b] - i*_a - j*_b ); \n            f[i][j] = tmp; \n            if( f[i][j] < 0 ) break;\n\n            sum ++;\n//          printf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n        }\n\n    for( int i = 1; i <= a; i ++ )\n        for( int j = 1; j <= b; j ++ )  \n            if( !check( i, j, d[i][j] ) ) {\n                printf( \"Impossible\\n\" ); return 0;\n            } \n\n    printf( \"Possible\\n\" );\n\n    printf( \"%d %d\\n\", 202, sum+200 );\n    for( int i = 1; i < 100; i ++ )\n        printf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\n    printf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n    for( int i = 0; i <= 100; i ++ )\n        for( int j = 0; j <= 100; j ++ )\n            if( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\n    printf( \"%d %d\\n\", s, t );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nint nxt() {\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\ntemplate <class T>\nT remin(T &x, T val) {\n    if (x > val) {x = val;}\n    return x;\n}\n\ntemplate <class T>\nT remax(T &x, T val) {\n    if (x < val) {x = val;}\n    return x;\n}\nusing pii = pair<int, int>;\n\nstruct F{\n    int a, b, c;\n};\n\nvoid solve() {\n    int n = nxt();\n    int m = nxt();\n    vector<vector<int> > d(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            d[i][j] = nxt();\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j + 1 < m; ++j) {\n            if (d[i][j + 1] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (d[i + 1][j] < d[i][j]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n\n    vector<F> v;\n    const int T = 101;\n    for (int i = 0; i < T; ++i) {\n        for (int j = 0; j < T; ++j) {\n            int k = -10000;\n            for (int x = 0; x < n; ++x) {\n                for (int y = 0; y < m; ++y) {\n                    int cd = (x + 1) * i + (y + 1) * j;\n                    int delta = d[x][y] - cd;\n                    k = max(k, delta);\n                }\n            }\n            v.push_back(F{i, j, k});\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            int val = 10000;\n            for (const F&f : v) {\n                int cv = f.a * (x + 1) + f.b * (y + 1) + f.c;\n                assert(cv >= d[x][y]);\n                val = min(val, cv);\n            }\n            if (val != d[x][y]) {\n                cout << \"Impossible\\n\";\n                return;\n            }\n        }\n    }\n    int s = 0;\n    int t = 299;\n    vector<pii> e;\n    vector<int> c;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i, i + 1));\n        c.push_back(INT_MIN);\n    }\n    int YY = T + 1;\n    for (int i = 0; i < T; ++i) {\n        e.push_back(make_pair(i + YY, i + 1 + YY));\n        c.push_back(INT_MIN + 1);\n    }\n\n    for (const auto &f : v) {\n        e.push_back(make_pair(f.a, YY));\n        c.push_back(0);\n        e.push_back(make_pair(YY + f.b, t));\n        c.push_back(f.c);\n    }\n    cout << t + 1 << \" \" << e.size() << \"\\n\";\n    for (int i = 0; i < e.size(); ++i) {\n        cout << e[i].first + 1 << \" \" << e[i].second + 1 << \" \";\n        if (c[i] == INT_MIN) {\n            cout << \"X\";\n        } else if (c[i] == INT_MIN + 1) {\n            cout << \"Y\";\n        } else {\n            cout << c[i];\n        }\n        cout << \"\\n\";\n    }\n    cout << s + 1 << \" \" << t + 1 << \"\\n\";\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"r\", stdout);\n#endif\n\n//    int t = nxt();\n//    for (int i = 0; i < t; ++i) {\n//        solve();\n//    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n \nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N];\n \nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\\n202 10401\");\n\tfor (int i = 0; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i + 1, i + 2, i + 103, i + 102);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) printf(\"%d %d %d\\n\", i + 1, j + 102, f[i][j]);\n\tputs(\"1 102\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint d[11][11];\nint dist[101][101];\nint done[11][11];\nint main() {\n\tint A,B;\n\tcin >> A >> B;\n\tfor(int i=1;i<=A;i++){\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<101;i++){\n\t\tfor(int j=0;j<101;j++){\n\t\t\tint m=0;\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tm=max(m,d[x][y]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tif(m==d[x][y]-x*i-y*j){\n\t\t\t\t\t\tdone[x][y]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[i][j]=m;\n\t\t\tif (i<5&&j<5){\n\t\t\t\tcerr << i << \", \" << j << \": \" << dist[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++){\n\t\tfor(int y=1;y<=B;y++){\n\t\t\tif(!done[x][y]){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << 2*100+101*101 << endl;\n\tfor(int i=0;i<100;i++){\n\t\tcout << i+1 << \" \" << i+2 << \" X\" << endl;\n\t}\n\tfor(int i=0;i<100;i++){\n\t\tcout << i+103 << \" \" << i+102 << \" Y\" << endl;\n\t}\n\tfor(int i=0;i<101;i++){\n\t\tfor(int j=0;j<101;j++){\n\t\t\tcout << i+1 << \" \" << j+102 << \" \" << dist[i][j] << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 102 << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nstruct lsg{int x,y,z;}f[1000][1000];\nint a,b,c[1000][1000],flag[1000][1000],fff[1000][1000],ii,jj,sum;\nsigned main(){\n\ta=read();b=read();for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)c[i][j]=read();\n\tfor (int i=0;i<=120;i++)\n\t\tfor (int j=0;j<=120;j++)\n\t\t\tfor (int k=0;k<=100;k++){\n\t\t\t\tint ff=0;if (ii==i&&jj==j)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)if (c[x][y]>i*x+j*y+k)ff=1;\n\t\t\t\tif (ff)continue;\n\t\t\t\tfor (int x=1;x<=a;x++)\n\t\t\t\t\tfor (int y=1;y<=b;y++)\n\t\t\t\t\t\tif (c[x][y]==i*x+j*y+k)f[x][y].x=i,f[x][y].y=j,f[x][y].z=k,flag[x][y]=1;\n\t\t\t\tii=i;jj=j;\n\t\t\t}\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)if (!flag[i][j]){puts(\"Impossible\");return 0;}\n\tputs(\"Possible\");for (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])sum++,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<300<<' '<<250+sum<<endl;memset(fff,0,sizeof(fff));\n\tfor (int i=1;i<=125;i++)cout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tfor (int i=1;i<=125;i++)cout<<300-i<<' '<<300-i+1<<' '<<'Y'<<endl;\n\tfor (int i=1;i<=a;i++)for (int j=1;j<=b;j++)\n\t\tif (!fff[f[i][j].x][f[i][j].y])\n\t\t\tcout<<f[i][j].x+1<<' '<<300-f[i][j].y<<' '<<f[i][j].z<<endl,fff[f[i][j].x][f[i][j].y]=1;\n\tcout<<1<<' '<<300<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\trep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define min(a,b) ((a)<(b)? (a):(b))\n#define max(a,b) ((a)>(b)? (a):(b))\nint d[15][15],f[105][105];\nint main() {\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tfor(register int x=1;x<=n;++x) {\n\t\t\t\tfor(register int y=1;y<=m;++y) {\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=n;++x) {\n\t\tfor(register int y=1;y<=m;++y) {\n\t\t\tint minn=105;\n\t\t\tfor(register int i=0;i<=100;++i) {\n\t\t\t\tfor(register int j=0;j<=100;++j) {\n\t\t\t\t\tminn=min(minn,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minn!=d[x][y])  {printf(\"Impossible\\n\");return 0;}\n\t\t}\n\t}\n\tprintf(\"202 10401\\n\");\n\tfor(register int x=1;x<=100;++x) printf(\"%d %d X\\n\",x,x+1);\n\tfor(register int x=101;x<=201;++x) printf(\"%d %d Y\\n\",x,x+1);\n\tfor(register int i=0;i<=100;++i) {\n\t\tfor(register int j=0;j<=100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 301\nll d[N][N];\nll g[M+10][M+10];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j]) ng = true;\n\t\tif(j+2<=b&&d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1]) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?d[i+1][j]-d[i][j]:0;\n\t\t\tll y = j<b?d[i][j+1]-d[i][j]:0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\tif(x<0||y<0||(g[x+1][201-y]!=-1)||(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=310,M=100010;\nbool w[N][N];\nint s1[N],s2[N];\nstruct Dat {\n    int x,y,z;\n} g[N],v[M];\ninline int gi() {\n    int x=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint main() {\n    int A,B,cnt=0,n=0,m=0;\n    cin>>A>>B;\n    for(int i=0;i<=100;i++) {\n\ts1[i]=++n,s2[i]=++n;\n\tif(i) {\n\t    v[++m]=(Dat){s1[i-1],s1[i],-1};\n\t    v[++m]=(Dat){s2[i],s2[i-1],-2};\n\t}\n    }\n    for(int i=1;i<=A;i++)\n\tfor(int j=1;j<=B;j++) g[++cnt]=(Dat){i,j,gi()};\n    for(int i=1;i<=cnt;i++) {\n\tint x=g[i].x,y=g[i].y,z=g[i].z;\n\tfor(int p=0;p*x<=z;p++)\n\t    for(int q=0;p*x+q*y<=z;q++) {\n\t\tint c=z-p*x-q*y;\n\t\tbool flg=1;\n\t\tfor(int j=1;j<=cnt;j++) {\n\t\t    int X=g[j].x,Y=g[j].y;\n\t\t    if(p*X+q*Y<g[j].z) {flg=0;break;}\n\t\t}\n\t\tif(flg) {\n\t\t    if(!w[s1[p]][s2[q]])\n\t\t\tw[s1[p]][s2[q]]=1,v[++m]=(Dat){s1[p],s2[q],c};\n\t\t    goto ed;\n\t\t}\n\t    }\n\treturn puts(\"Impossible\"),0;\n    ed:;\n    }\n    puts(\"Possible\");\n    cout<<n<<' '<<m<<endl;\n    for(int i=1;i<=m;i++) {\n\tprintf(\"%d %d \",v[i].x,v[i].y);\n\tif(v[i].z==-1) puts(\"X\");\n\telse if(v[i].z==-2) puts(\"Y\");\n\telse printf(\"%d\\n\",v[i].z);\n    }\n    cout<<1<<' '<<2;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint m[15][15];\nvoid no()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\ntypedef pair<int, int>pii;\ntypedef pair<pii, int>pi3;\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 1; i <= mx; i++)for (int j = 1; j <= my; j++)scanf(\"%d\", &m[i][j]);\n\tset<pi3>se;\n\tfor (int i = 1; i <= mx; i++)\n\t{\n\t\tfor (int j = 1; j <= my; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l <= 100; l++)\n\t\t\t\t{\n\t\t\t\t\tint c = m[i][j] - k*i - l*j;\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (int p = 1; p <= mx; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int q = 1; q <= my; q++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (c + k*p + l*q < m[p][q])f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f)\n\t\t\t\t\t{\n\t\t\t\t\t\tse.insert(make_pair(make_pair(k, l), c));\n\t\t\t\t\t\tgoto l01;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tno();\n\t\tl01:;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 222, 220 + se.size());\n\tfor (int i = 1; i < 111; i++)printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 112; i < 222; i++)printf(\"%d %d Y\\n\", i, i + 1);\n\tset<pi3>::iterator it = se.begin();\n\tfor (;;)\n\t{\n\t\tif (it == se.end())break;\n\t\tpi3 z = *it;\n\t\tit++;\n\t\tprintf(\"%d %d %d\\n\", 1 + z.first.first, 222 - z.first.second, z.second);\n\t}\n\tprintf(\"%d %d\\n\", 1, 222);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int edge_count = 200;\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            edge_count += 1;\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 201 << \" \" << edge_count << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            cout << xuse + 1 << \" \" << 201 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 201\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[12][12],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tputs(\"Impossible\");return 0;/*\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ 0,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[i][j] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint A,B,d[15][15],ans[105][105];\ntypedef pair<int, int> pi;\nvector<pi> adjlist[205];\n\nint main(){\n//\tfreopen(\"graphxy.in\",\"r\", stdin);\n//\tfreopen(\"graphxy.out\",\"w\", stdout);\n\tcin >> A >> B;\n\tfor(int i = 1; i<=A; i++){ for(int j = 1; j<=B; j++) cin >> d[i][j]; }\n\tfor(int a=0; a<100; a++)\n\t\tfor(int b=0; b<100; b++)\n\t\t\tfor(int x=1; x<=A; x++)\n\t\t\t\tfor(int y=1; y<=B; y++)\n\t\t\t\t\tans[a][b] = max(ans[a][b], d[x][y]-a*x-b*y);\n\tfor(int i=1; i<=A; i++){\n\t\tfor(int j = 1; j<=B; j++){\n\t\t\tint best = INT_MAX;\n\t\t\tfor(int x=0; x<100; x++){\n\t\t\t\tfor(int y=0; y<100; y++){\n\t\t\t\t\tbest = min(best, ans[x][y]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best == d[i][j]){}\n\t\t\telse{\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"200 10200\\n\";\n\tint m=0;\n\tfor(int i=0; i<100; i++){\n\t\tfor(int j=0; j<100; j++) cout << i << \" \" << 100+j << \" \" << ans[i][j] << \"\\n\";\n\t\tm+=100;\n\t}\n\tm+=100+100;\n\tassert(m == 10200);\n\tfor(int i=0; i<99; i++) cout << i << \" \" << i+1 << \" X\\n\";\n\tfor(int i=100; i<199; i++) cout << i << \" \" << i+1 << \" Y\\n\";\n\tcout << \"0 199\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\n\n// struct edge {\n//   ll v, dist;\n// };\n//\n// struct state {\n//   ll v, cost;\n//\n//   bool operator>(const state s) const {\n//     return cost > s.cost;\n//   }\n// };\n//\n// vector<ll> dijkstra(vector< vector<edge> > &E, ll S) {\n//   vector<ll> dp(E.size(), INF);\n//   priority_queue<state, vector<state>, greater<state> > q;\n//   q.push((state) { S, 0 });\n//\n//   while(!q.empty()) {\n//     ll v = q.top().v, cost = q.top().cost;\n//     q.pop();\n//\n//     if(dp[v] <= cost) continue;\n//     dp[v] = cost;\n//\n//     REP(i, 0, E[v].size()) {\n//       ll nv = E[v][i].v, ncost = cost + E[v][i].dist;\n//       if(dp[nv] > ncost) q.push((state) { nv, ncost });\n//     }\n//   }\n//\n//   return dp;\n// }\n\nint main(void) {\n  ll A, B;\n  cin >> A >> B;\n  vector< vector<ll> > D(A + 1, vector<ll>(B + 1));\n  REP(i, 1, A + 1) REP(j, 1, B + 1) cin >> D[i][j];\n\n  struct data { ll p, q, r; };\n  vector<data> e;\n  vector< vector<bool> > ok(A + 1, vector<bool>(B + 1, false));\n\n  REP(p, 0, 101) REP(q, 0, 101) REP(r, 0, 100 + 1) {\n    bool f = true;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      ll v = p * x + q * y + r;\n      f = f && D[x][y] <= v;\n    }\n    if(!f) continue;\n    ll cnt = 0;\n    REP(x, 1, A + 1) REP(y, 1, B + 1) {\n      ll v = p * x + q * y + r;\n      if(!ok[x][y] && D[x][y] == v) {\n        ok[x][y] = true;\n        cnt++;\n      }\n    }\n    if(cnt > 0) e.push_back((data) { p, q, r });\n  }\n\n  bool possible = true;\n  REP(a, 1, A + 1) REP(b, 1, B + 1) possible = possible && ok[a][b];\n\n  if(!possible) {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n\n  ll N = 202, M = 20 + e.size(), S = 1, T = 102;\n  cout << \"Possible\" << endl;\n  cout << N << \" \" << M << endl;\n  REP(i, S, S + 100) cout << i << \" \" << i + 1 << \" X\" << endl;\n  REP(i, T, T + 100) cout << i + 1 << \" \" << i << \" Y\" << endl;\n  REP(i, 0, e.size()) cout << S + e[i].p << \" \" << T + e[i].q << \" \" << e[i].r << endl;\n  cout << S << \" \" << T << endl;\n\n  // REP(x, 1, A + 1) REP(y, 1, B + 1) {\n  //   vector< vector<edge> > E(N + 1);\n  //   REP(i, S, S + 10) E[i].push_back((edge) { i + 1, x });\n  //   REP(i, T, T + 10) E[i + 1].push_back((edge) { i, y });\n  //   REP(i, 0, e.size()) E[S + e[i].x].push_back((edge) { T + e[i].y, e[i].z });\n  //   ll d = dijkstra(E, S)[T];\n  //   assert(d == D[x][y]);\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAXN 105\n#define N 100\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9'){\n        if (ch=='-') f=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9'){\n        x=(x<<3)+(x<<1)+(ch^'0');\n        ch=getchar();\n    }\n    return x*f;\n}\nint d[MAXN][MAXN],f[MAXN][MAXN];\nint main(){\n\t// freopen(\"AT3877.out\",\"w\",stdout);\n\tint A=read(),B=read();\n\tfor (register int i=1;i<=A;++i){\n\t\tfor (register int j=1;j<=B;++j){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\t//f[i][j]=0;//构造f[i][j]\n\t\t\tfor (register int x=1;x<=A;++x){\n\t\t\t\tfor (register int y=1;y<=B;++y){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// printf(\"%d \",f[i][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\tfor (register int x=1;x<=A;++x){\n\t\tfor (register int y=1;y<=B;++y){\n\t\t\tint ans=0x7fffffff;\n\t\t\tfor (register int i=0;i<=N;++i){\n\t\t\t\tfor (register int j=0;j<=N;++j){\n\t\t\t\t\tans=min(ans,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",ans,d[x][y]);\n\t\t\tif (ans!=d[x][y]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N*2+2,N+N+(N+1)*(N+1));\n\tfor (register int i=1;i<=N;++i){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor (register int i=N+2;i<=(N+1)*2;++i){//反着搞\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor (register int i=0;i<=N;++i){\n\t\tfor (register int j=0;j<=N;++j){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",1,(N+1)*2);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nconst int MAXA = 17;\n\nint D[MAXA][MAXA];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint a, b;\n\tcin >> a >> b;\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t\tcin >> D[i][j];\n\tREP(c1, 101)\n\t\tREP(c2, 101)\n\t{\n\t\tbool ok = true;\n\t\tint c3;\n\t\tfor (c3 = 0; c3 < 100; ++c3)\n\t\t{\n\t\t\tFOR(x, 1, a + 1)\n\t\t\t\tFOR(y, 1, b + 1)\n\t\t\t\tif (D[x][y] != c1 + min(x + y, min(c2 + x, c3 + y)))\n\t\t\t\t\tok = false;\n\t\t\tif (ok)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ok)\n\t\t{\n\t\t\tcout << \"Possible\\n\";\n\t\t\tcout << \"6 7\\n\";\n\t\t\tcout << \"1 2 \" << c1 << '\\n';\n\t\t\tcout << \"2 3 X\\n\";\n\t\t\tcout << \"2 4 \" << c2 << '\\n';\n\t\t\tcout << \"2 5 \" << c3 << '\\n';\n\t\t\tcout << \"3 6 Y\\n\";\n\t\t\tcout << \"4 6 X\\n\";\n\t\t\tcout << \"5 6 Y\\n\";\n\t\t\tcout << \"1 6\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Impossible\\n\";\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=101;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm<<endl;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,2*maxm-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\t\t\td[0] = 0;\n\t\t\tpriority_queue<p>Q;\n\t\t\tQ.push({0,0});\n\t\t\twhile (Q.size()) {\n\t\t\t\tp t = Q.top(); Q.pop();\n\t\t\t\tif (d[t.second] < t.first)continue;\n\t\t\t\tfor (P u : V) {\n\t\t\t\t\tif (u.second.first == t.second) {\n\t\t\t\t\t\tint h = 0;\n\t\t\t\t\t\tif (u.first >= 0) {\n\t\t\t\t\t\t\th = u.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (u.first == -1) {\n\t\t\t\t\t\t\th = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { h = j + 1; }\n\t\t\t\t\t\tif (d[u.second.second] > t.first + h) {\n\t\t\t\t\t\t\td[u.second.second] = t.first + h;\n\t\t\t\t\t\t\tQ.push({t.first+h,u.second.second });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << V.size()<< endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \" X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \" Y\" <<endl;\n\t\t}\n\t\telse {\n\t\t\tcout << i.second.first + 1 << \" \" << i.second.second + 1 << \" \" << i.first<< endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10 + 5;\n\nint n, m, d[N][N], f[105][105];\n\nint main() {\n    printf(\"%d\\n\", 101 * 101);\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            scanf(\"%d\", &d[i][j]);\n    memset(f, 0xcf, sizeof(f));\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j)\n            for (int x = 1; x <= n; ++x)\n                for (int y = 1; y <= m; ++y)\n                    f[i][j] = max(f[i][j], d[x][y] - i * x - j * y);\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y) {\n            int tmp = INT_MAX;\n            for (int i = 0; i <= 100; ++i)\n                for (int j = 0; j <= 100; ++j)\n                    tmp = min(tmp, i * x + j * y + f[i][j]);\n            if (tmp != d[x][y]) { puts(\"Impossible\"); return 0; }\n        }\n    printf(\"Possible\\n%d %d\\n\", 202, 10401);\n    for (int i = 0; i < 100; ++i) printf(\"%d %d X\\n%d %dY\\n\", i + 1, i + 2, 102 + i, 103 + i);\n    for (int i = 0; i <= 100; ++i)\n        for (int j = 0; j <= 100; ++j) printf(\"%d %d %d\\n\", 1 + i, 202 - j, f[i][j]);\n    puts(\"1 202\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <queue>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 17;\nconst int Maxm = 301;\nconst int Inf = 1000000000;\n\nint GN, GM;\nint A, B;\nint D[Maxn][Maxn];\nint mn[Maxm][Maxm];\nint N;\nvector <ii> neigh[Maxm];\nint dist[Maxm];\n\nint getFirst(int r, int c)\n{\n\treturn r * GM + c + 1;\n}\n\nbool Check(int val1)\n{\n\tGN = val1; GM = 299 / GN;\n\tfor (int i = 0; i < GN; i++)\n\t\tfor (int j = 0; j < GM; j++)\n\t\t\tmn[i][j] = 0;\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++)\n\t\t\tfor (int koefi = 0; koefi < GN; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < GM; koefj++)\n\t\t\t\t\tmn[koefi][koefj] = max(mn[koefi][koefj], D[i][j] - koefi * (i + 1) - koefj * (j + 1));\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tbool ok = false;\n\t\t\tfor (int koefi = 0; koefi < GN && !ok; koefi++)\n\t\t\t\tfor (int koefj = 0; koefj < GM && !ok; koefj++)\n\t\t\t\t\tok = koefi * (i + 1) + koefj * (j + 1) + mn[koefi][koefj] == D[i][j];\n\t\t\tif (!ok) return false;\n\t\t}\n\treturn true;\n}\n\nint Get(int v, int t, int X, int Y)\n{\n\t//printf(\"(%d, %d, %d, %d)\\n\", v, t, X, Y);\n\tfill(dist, dist + Maxm, Inf); dist[v] = 0;\n\tpriority_queue <ii> Q; Q.push(ii(-dist[v], v));\n\twhile (!Q.empty()) {\n\t\tint v = Q.top().second, d = -Q.top().first; Q.pop();\n\t\tif (dist[v] != d) continue;\n\t//\tprintf(\"v = %d, d = %d\\n\", v, d);\n\t\tif (t == v) return d;\n\t\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\t\tii u = neigh[v][i];\n\t\t\tif (u.second == -1) u.second = X;\n\t\t\tif (u.second == -2) u.second = Y;\n\t\t\t//printf(\"u = (%d, %d)  d = %d\\n\", u.first, u.second, dist[u.first]);\n\t\t\tif (d + u.second < dist[u.first]) {\n\t\t\t\tdist[u.first] = d + u.second;\n\t\t\t\tQ.push(ii(-dist[u.first], u.first));\n\t\t\t}\n\t\t}\n\t}\n\treturn Inf;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &A, &B);\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++)\n\t\t\tscanf(\"%d\", &D[i][j]);\n\tint siz;\n\tfor (siz = 1; siz <= 299; siz++)\n\t\tif (Check(siz)) break;\n\tif (siz > 299) { printf(\"Impossible\\n\"); return 0; }\n\tN = GN * GM + 1;\n\tfor (int i = 0; i < GN; i++)\n\t\tfor (int j = 0; j < GM; j++) {\n\t\t\tneigh[getFirst(i, j)].push_back(ii(N, mn[i][j]));\n\t\t\tif (j + 1 < GM)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i, j + 1), -2));\n\t\t\tif (i + 1 < GN)\n\t\t\t\tneigh[getFirst(i, j)].push_back(ii(getFirst(i + 1, j), -1));\n\t\t}\n\tint M = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tM += neigh[i].size();\n\tfor (int i = 0; i < A; i++)\n\t\tfor (int j = 0; j < B; j++) {\n\t\t\tint g = Get(getFirst(0, 0), N, i + 1, j + 1);\n\t\t\tif (D[i][j] != g) assert(false);\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", N, M);\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 0; j < neigh[i].size(); j++) {\n\t\t\tprintf(\"%d %d \", i, neigh[i][j].first);\n\t\t\tif (neigh[i][j].second == -1) printf(\"X\\n\");\n\t\t\telse if (neigh[i][j].second == -2) printf(\"Y\\n\");\n\t\t\telse printf(\"%d\\n\", neigh[i][j].second);\n\t\t}\n\tprintf(\"%d %d\\n\", getFirst(0, 0), N);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n//#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll a,b;cin>>a>>b;\n  auto d=vec(a+1,b+1,0LL);\n  rep(i,0,a)rep(j,0,b)cin>>d[i+1][j+1];\n  vector<ll>ru,rv,rc1,rc2;\n  stringstream output;\n  ll cnt=0;\n  auto add=[&](ll u,ll v,ll c){\n    cnt++;\n    if(c==-1){\n      output<<u spa v spa \"X\"<<endl;\n    }\n    else if(c==-2){\n      output<<u spa v spa \"Y\"<<endl;\n    }\n    else output<<u spa v spa c<<endl;\n  };\n  ll num=100;\n  ll start=1,goal=1+num+1;\n  {\n    //1...101:xの道\n    //102...203:yの道\n    //1->102\n    rep(i,start,start+num)add(i,i+1,-1);\n    rep(i,goal,goal+num)add(i+1,i,-2);\n  }\n  auto add_edge=[&](ll ai,ll bi,ll ci){\n    //aix + biy + ciを加える\n    add(start+ai,goal+bi,ci);\n  };\n  auto t=vec(a+1,b+1,false);\n  rep(i,0,num+1)rep(j,0,num+1){\n    ll mic=0;\n    rep(x,1,a+1)rep(y,1,b+1){\n      ll c=d[x][y]-i*x-j*y;\n      //if(i==0&&j==1)cout<<x spa y spa c spa d[x][y] spa -i*x spa -j*y<<endl;\n      chmax(mic,c);\n    }\n    if(mic>num)continue;\n    bool sw=false;\n    rep(x,1,a+1)rep(y,1,b+1){\n      ll c=d[x][y]-i*x-j*y;\n      if(c==mic&&!t[x][y]){\n        sw=true;\n        t[x][y]=true;\n      }\n    }\n    //if(sw)cout<<i spa j spa mic<<endl;\n    if(sw)add_edge(i,j,mic);\n  }\n  rep(i,1,a+1)rep(j,1,b+1)if(!t[i][j])judge=false;\n  if(judge){\n    cout<<\"Possible\"<<endl;\n    cout<<2*(num+1) spa cnt<<endl;\n    cout<<output.str();\n    cout<<start spa goal<<endl;\n  }\n  else cout<<\"Impossible\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 105;\nconst int INF = 1e9;\n\nint A,B;\nint d[11][11];\nint f[N][N];\nint m,ed[N*4][3];\nbool bz[11][11];\nbool v[N][N];\nint n;\nint id0[N],id1[N],S,T;\n\nint main(){\n\tA=get();B=get();\n\tfo(i,1,A)fo(j,1,B)d[i][j]=get();\n\tfo(i,0,100)\n\t\tfo(j,0,100){\n\t\t\tf[i][j]=-INF;\n\t\t\tfo(x,1,A)\n\t\t\t\tfo(y,1,B)\n\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-x*i-y*j);\n\t\t}\n\tint cnt=0;\n\tS=n=1;\n\tfo(i,0,100)id0[i]=++n;\n\tfo(i,0,100)id1[i]=++n;\n\tT=++n;\n\ted[m=1][0]=S;ed[1][1]=id0[0];ed[1][0]=0;\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id0[i];ed[m][1]=id0[i+1];ed[m][2]=-1;\n\t}\n\tfo(i,0,99){\n\t\tm++;\n\t\ted[m][0]=id1[i+1];ed[m][1]=id1[i];ed[m][2]=-2;\n\t}\n\tm++;\n\ted[m][0]=id1[0];ed[m][1]=T;ed[m][2]=0;\n\twhile(cnt<A*B){\n\t\tbool pd=0;\n\t\tfo(i,0,100){\n\t\t\tfo(j,0,100)\n\t\t\tif (!v[i][j]&&f[i][j]<=100&&f[i][j]>=0){\n\t\t\t\tint ct=0;\n\t\t\t\tfo(x,1,A)\n\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\tif (!bz[x][y]&&d[x][y]-x*i-y*j==f[i][j])ct++;\n\t\t\t\tif (ct){\n\t\t\t\t\tpd=1;\n\t\t\t\t\tfo(x,1,A)\n\t\t\t\t\t\tfo(y,1,B)\n\t\t\t\t\t\tif (d[x][y]-x*i-y*j==f[i][j])bz[x][y]=1;\n\t\t\t\t\ted[++m][0]=id0[i];ed[m][1]=id1[j];ed[m][2]=f[i][j];\n\t\t\t\t\tcnt=cnt+ct;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse v[i][j]=1;\n\t\t\t}\n\t\t\tif (pd)break;\n\t\t}\n\t\tif (!pd)break;\n\t}\n\tif (cnt!=A*B)printf(\"Impossible\\n\");\n\telse{\n\t\tprintf(\"Possbile\\n\");\n\t\tprintf(\"%d %d\\n\",n,m);\n\t\tfo(i,1,m){\n\t\t\tprintf(\"%d %d \",ed[i][0],ed[i][1]);\n\t\t\tif (ed[i][2]==-1)printf(\"X\\n\");\n\t\t\tif (ed[i][2]==-2)printf(\"Y\\n\");\n\t\t\tif (ed[i][2]>=0)printf(\"%d\\n\",ed[i][2]);\n\t\t}\n\t\tprintf(\"%d %d\\n\",S,T);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<int, ii> II;\n#define fi first\n#define se second\n\nconst int N = 550;\n\nint A, B;\nint n, S, T;\nint nx[N][N], ny[N][N];\nint a[N][N];\n\nbool check(int x, int y, int ni, int nj) {\n\tint rem = a[x][y] - ni * x - nj * y;\n\tif (rem < 0) return false;\n\n\tfor (int i = 1; i <= A; ++i) for (int j = 1; j <= B; ++j) {\n\t\tif (rem + ni * i + nj * j < a[i][j]) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) cin >> a[i][j], nx[i][j] = -1, ny[i][j] = -1;\n\t}\t\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tfor (int ni = 0; ni <= 100; ++ni) for (int nj = 0; nj <= 100; ++nj) {\n\t\t\t\tif (check(i, j, ni, nj)) {\n\t\t\t\t\tnx[i][j] = ni, ny[i][j] = nj; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tS = ++n;\n\tT = ++n;\n\tvector<II> X, Y, edges;\n\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (nx[i][j] == -1 || ny[i][j] == -1) return cout << \"Impossible\\n\", 0;\n\t\t\tint rem = a[i][j] - nx[i][j] * i - ny[i][j] * j;\n\n\t\t\tint lastS = S;\n\t\t\tfor (int k = 0; k < min(nx[i][j], (int)X.size()); ++k) {\n\t\t\t\tedges.push_back(X[k]);\n\t\t\t\tlastS = X[k].se.se;\n\t\t\t}\n\t\t\tnx[i][j] -= X.size();\n\t\t\twhile (nx[i][j]-- > 0) {\n\t\t\t\t++n; X.push_back(II(-1, ii(lastS, n))); lastS = n;\n\t\t\t\tedges.push_back(X.back());\n\t\t\t}\n\n\n\t\t\tint lastT = T;\n\t\t\tfor (int k = 0; k < min(ny[i][j], (int)Y.size()); ++k) {\n\t\t\t\tedges.push_back(Y[k]);\n\t\t\t\tlastT = Y[k].se.fi;\n\t\t\t}\n\t\t\tny[i][j] -= Y.size();\n\t\t\twhile (ny[i][j]-- > 0) {\n\t\t\t\t++n; Y.push_back(II(-2, ii(n, lastT))); lastT = n;\n\t\t\t\tedges.push_back(Y.back());\n\t\t\t}\n\n\t\t\tedges.push_back(II(rem, ii(lastS, lastT)));\n\t\t}\n\t}\n\n\tassert(n <= 300);\n\n\tsort(edges.begin(), edges.end());\n\tedges.erase(unique(edges.begin(), edges.end()), edges.end());\n\tcout << \"Possible\\n\";\n\tcout << n << ' ' << edges.size() << endl;\n\tfor (auto e : edges) {\n\t\tcout << e.se.fi << ' ' << e.se.se << ' ';\n\t\tif (e.fi < 0) cout << (e.fi == -1 ? 'X' : 'Y') << endl;\n\t\telse cout << e.fi << endl;\n\t}\n\tcout << S << ' ' << T << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint A,B;\nint C[12][12];\nint D[101][101];\nint DX[12][12];\nint DY[12][12];\nint NV;\nint V[303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tMINUS(V);\n\t\n\tcin>>A>>B;\n\tfor(x=1;x<=A;x++) {\n\t\tfor(y=1;y<=B;y++) {\n\t\t\tcin>>C[x][y];\n\t\t}\n\t}\n\t\n\tvector<int> Xs,Ys;\n\tNV=1;\n\tXs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV][NV+1]=-2;\n\t\tNV++;\n\t\tXs.push_back(NV);\n\t}\n\tNV++;\n\tYs.push_back(NV);\n\tFOR(i,100) {\n\t\tV[NV+1][NV]=-3;\n\t\tNV++;\n\t\tYs.push_back(NV);\n\t}\n\treverse(ALL(Ys));\n\t\n\tfor(x=0;x<=100;x++) {\n\t\tfor(y=0;y<=100;y++) {\n\t\t\tint ret=0;\n\t\t\tfor(i=1;i<=A;i++) {\n\t\t\t\tfor(j=1;j<=B;j++) {\n\t\t\t\t\tret=max(ret,C[i][j]-x*i-y*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tD[x][y]=ret;\n\t\t\tNV++;\n\t\t\tV[Xs[x]][Ys[y]]=ret;\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=A;i++) {\n\t\tfor(j=1;j<=B;j++) {\n\t\t\tint mi=1010;\n\t\t\tfor(x=0;x<=100;x++) {\n\t\t\t\tfor(y=0;y<=100;y++) {\n\t\t\t\t\tmi=min(mi,x*i+j*y+D[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi!=C[i][j]) return _P(\"Impossible\\n\");\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\t\n\tint cnt=0;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) cnt++;\n\tcout<<\"Possible\"<<endl;\n\tcout<<cnt<<endl;\n\tFOR(x,303) FOR(y,303) if(V[x][y]!=-1) {\n\t\tcout<<x<<\" \"<<y<<\" \";\n\t\tif(V[x][y]==-2) cout<<\"X\"<<endl;\n\t\tif(V[x][y]==-3) cout<<\"Y\"<<endl;\n\t\tif(V[x][y]>=0) cout<<V[x][y]<<endl;\n\t}\n\tcout<<Xs[0]<<\" \"<<Ys[0]<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  vector<Int> E(sz,0),F(sz,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*k);\n\tchmax(D[k],d[i][j]-(j+1)*k);\n      }\n    }\n  }\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(E[k],d[i][j]-(N-(k+1))*(i+1));\n\tchmax(F[k],d[i][j]-(N-(k+1))*(j+1));\n\tchmax(E[k],d[i][j]-C[k]);\n\tchmax(F[k],d[i][j]-D[k]);\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[idx(k)].emplace_back(t,C[k]);\n    G[idy(k)].emplace_back(t,D[k]);\n    G[z].emplace_back(idx(k),E[k]);\n    G[z].emplace_back(idy(k),F[k]);\n  }\n  \n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      //cout<<dist<<\" \"<<d[i][j]<<endl;\n      flg&=(dist>=d[i][j]);\n      assert(dist>=d[i][j]);\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tM = 200;\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY){\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\t\t\tif(F[numX][numY])++M;\n\t\t}\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tif(F[I][100 - J])printf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<utility>\n#include<bitset>\n#include<complex>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define REP(i,a,b) for(int i=a; i<=b; ++i)\n#define FOR(i,a,b) for(int i=a; i<b; ++i)\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef pair<int,int> pii;\n\nconst int maxn = 100;\n\nint A, B, dis[12][12];\nint D[maxn + 5][maxn + 5];\n\nint main() {\n    scanf(\"%d%d\", &A, &B);\n    REP(i,1,A) REP(k,1,B) scanf(\"%d\", &dis[i][k]);\n    for(int a = 0; a <= 100; ++a)\n        for(int b = 0; b <= 100; ++b) {\n            REP(i,1,A) REP(k,1,B)\n                D[a][b] = max(D[a][b], dis[i][k] - a*i - b*k);\n            D[a][b] = min(D[a][b], 100);\n        }\n    for(int i = 1; i <= A; ++i)\n        for(int k = 1; k <= B; ++k) {\n            int d = 1 << 30;\n            REP(a,0,100) REP(b,0,100)\n                d = min(d, D[a][b] + a*i + b*k);\n            if(d != dis[i][k]) exit(0 * puts(\"Impossible\"));\n        }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 202, 101*101 + 100*2);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d X\\n\", i, i+1);\n    for(int i = 1; i <= 100; ++i) printf(\"%d %d Y\\n\", i+101, i+1+101);\n    for(int i = 0; i <= 100; ++i)\n        for(int k = 0; k <= 100; ++k)\n            printf(\"%d %d %d\\n\", i+1, 101-k + 101, D[i][k]);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\nint G[101][101];\n\nvoid Set(int p, int q)\n{\n\tint min_f = INT_MAX;\n\n\tfor (int f = 0; f <= 100; f++)\n\t{\n\t\tbool is_update = false;\n\n\t\tREP(x, A) REP(y, B)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + f;\n\t\t\tif (D[x][y] > d)\n\t\t\t{\n\t\t\t\tis_update = false;\n\t\t\t\tgoto BREAK;\n\t\t\t}\n\t\t\tif (G[x][y] > d && D[x][y] == d)\n\t\t\t{\n\t\t\t\tis_update = true;\n\t\t\t}\n\t\t}\n\tBREAK:\n\t\tif (is_update)\n\t\t{\n\t\t\tmin_f = MIN(f, min_f);\n\t\t}\n\t}\n\n\tif (min_f <= 100)\n\t{\n\t\tF[p][q] = min_f;\n\n\t\tREP(x, 101) REP(y, 101)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + min_f;\n\t\t\tG[x][y] = MIN(G[x][y], d);\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\tREP(i, 101) REP(j, 101)\n\t{\n\t\tF[i][j] = 100;\n\t\tG[i][j] = 100;\n\t}\n\n\tREP(p, 101) REP(q, 101)\n\t{\n\t\tSet(p, q);\n\t}\n\n\tREP(x, A) REP(y, B)\n\t{\n\t\tint min = INT_MAX;\n\t\tREP(p, 101) REP(q, 101)\n\t\t{\n\t\t\tint d = p * (x + 1) + q * (y + 1) + F[p][q];\n\t\t\tmin = MIN(min, d);\n\t\t}\n\t\tif (D[x][y] != min)\n\t\t{\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << \"202 10201\" << endl;\n\tREP(i, 100) cout << (i + 1) << \" \" << (i + 2) << \" X\" << endl;\n\tREP(i, 100) cout << (i + 102) << \" \" << (i + 103) << \" Y\" <<  endl;\n\n\tREP(p, 101) REP(q, 101)\n\t{\n\t\tcout << (p + 1) << \" \" << (202 - q) << \" \" << F[p][q] << endl;\n\t}\n\n\tcout << \"1 202\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long li;\n\nint main() {\n    li a, b;\n    cin >> a >> b;\n    vector<vector<li>> ds(a, vector<li>(b));\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            cin >> ds[i][j];\n        }\n    }\n\n    const li size = 101;\n    vector<vector<li>> offset(size, vector<li>(size, -1));\n    for (int a_ = 0; a_ < a; ++a_) {\n        int xc = a_ + 1;\n        for (int b_ = 0; b_ < b; ++b_) {\n            int yc = b_ + 1;\n            int dist = ds[a_][b_];\n\n            for (int xuse = 0; xuse < size; ++xuse) {\n                for (int yuse = 0; yuse < size; ++yuse) {\n                    offset[xuse][yuse] = max<li>(offset[xuse][yuse], dist - xc * xuse - yc * yuse);\n                }\n            }\n\n        }\n    }\n\n    vector<vector<li>> exists(a, vector<li>(b));\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            for (int a_ = 0; a_ < a; ++a_) {\n                int xc = a_ + 1;\n                for (int b_ = 0; b_ < b; ++b_) {\n                    int yc = b_ + 1;\n                    if (offset[xuse][yuse] + xc * xuse + yc * yuse == ds[a_][b_]) {\n                        exists[a_][b_] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < a; ++i) {\n        for (int j = 0; j < b; ++j) {\n            if (not exists[i][j]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    cout << 201 << endl;\n    for (int i = 0; i < 100; ++i) {\n        cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n        cout << i + 101 << \" \" << i + 102 << \" Y\" << endl;\n    }\n    for (int xuse = 0; xuse < size; ++xuse) {\n        for (int yuse = 0; yuse < size; ++yuse) {\n            if (offset[xuse][yuse] < 0) {\n                continue;\n            }\n            cout << xuse + 1 << \" \" << 201 - yuse << \" \" << offset[xuse][yuse] << endl;\n        }\n    }\n\n    cout << \"1 201\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\nconst int inf = 9999;\nint A, B;\nint d[11][11];\nint C[111][111];\nvector<piii> E;\nint main(){\n    scanf(\"%d%d\",&A,&B);\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            C[i][j] = inf;\n        }\n    }\n    for(int x=1;x<A;x++){\n        for(int y=1;y<B;y++){\n            int a = d[x+1][y] - d[x][y];\n            int b = d[x+1][y+1] - d[x+1][y];\n            int c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n            b = d[x][y+1] - d[x][y];\n            a = d[x+1][y+1] - d[x][y+1];\n            c = d[x][y] - a*x - b*y;\n            if (a >= 0 && b >= 0 && c >= 0)C[a][b] = min(C[a][b], c);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(C[i][j] < inf){\n                E.emplace_back(pii(i,j),C[i][j]);\n                //printf(\"%d %d %d\\n\", i, j, C[i][j]);\n            }\n        }\n    }\n    for(int i=1;i<=A;i++){\n        for(int j=1;j<B;j++){\n            int mn = inf;\n            for(auto e : E){\n                mn = min(mn, e.first.first * i + e.first.second * j + e.second);\n            }\n            //printf(\"- %d %d %d %d\\n\",i, j, d[i][j], mn); \n            if(mn != d[i][j]){\n                puts(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n    puts(\"Possible\");\n    printf(\"%d %d\\n\", 200, (int)E.size() + 198);\n    for(int i=1;i<100;i++){\n        printf(\"%d %d X\\n\", i, i+1);\n    }\n    for(int j=101;j<200;j++){\n        printf(\"%d %d Y\\n\", j+1, j);\n    }\n    for(auto e : E){\n        int a = e.first.first;\n        int b = e.first.second;\n        int c = e.second;\n        printf(\"%d %d %d\\n\", 1+a, 101+b, c);\n    }\n    printf(\"%d %d\\n\", 1, 101);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a, b, d[12][12], f[107][107];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c<'0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint main()\n{\n\ta = read();\n\tb = read();\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t\td[i][j] = read();\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tfor (int k = 1; k <= a; k++)\n\t\t\t\tfor (int l = 1; l <= b; l++)\n\t\t\t\t\tf[i][j] = max(f[i][j], d[k][l] - i * k - j * l);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tint mn = 1e9;\n\t\t\tfor (int p = 0; p <= 100; p++)\n\t\t\t\tfor (int q = 0; q <= 100; q++)\n\t\t\t\t\tmn = min(mn, f[p][q] + p * i + q * j);\n\t\t\tif (mn != d[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor (int i = 1; i <= 100; i++)\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 102; i < 202; i++)\n\t\tprintf(\"%d %d Y\\n\", i, i + 1);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 20\n#define M 221\nll d[N][N];\nll g[M+10][M+10];\nll gg[M][M];\n\nint main(){\n\tll a, b;\n\tcin>>a>>b;\n\trep1(i, a) rep1(j, b) cin>>d[i][j];\n\tmset(g, -1);\n\tbool ng = false;\n\trep1(i, a-1) rep1(j, b-1){\n\t\tif(d[i+1][j]-d[i][j]<0) ng = true;\n\t\tif(d[i][j+1]-d[i][j]<0) ng = true;\n\t\tif(i+2<=a&&(d[i+1][j]-d[i][j]<d[i+2][j]-d[i+1][j])) ng = true;\n\t\tif(j+2<=b&&(d[i][j+1]-d[i][j]<d[i][j+2]-d[i][j+1])) ng = true;\n\t}\n\tif(ng){\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n\tll m = 200;\n\tfor(ll i = a; i >= 1; i--){\n\t\tfor(ll j = b; j >= 1; j--){\n\t\t\tll x = i<a?(d[a][j]-d[i][j]+a-i-1)/(a-i):0;\n\t\t\tll y = j<b?(d[i][b]-d[i][j]+b-j-1)/(b-j):0;\n\t\t\tll c = d[i][j]-x*i-y*j;\n\t\t\t//cerr<<i<<\" \"<<j<<endl;\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tif(x<0||y<0||/*(g[x+1][201-y]!=-1)||*/(c<0||c>100)){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(g[x+1][201-y]==-1) m++;\n\t\t\tchmax(g[x+1][201-y], c);\n\t\t\t//cerr<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t}\n\t}\n\t/*rep1(i, a) rep1(j, b){\n\t\trep(i2, M) fill(gg[i2], gg[i2]+M, INF);\n\t\trep(i2, M) gg[i2][i2] = 0;\n\t\tREP(i2, 1, 101) gg[i2][i2+1] = i;\n\t\tREP(i2, 101, 201) gg[i2][i2+1] = j;\n\t\trep(i2, M) rep(j2, M) if(g[i2][j2]!=-1) gg[i2][j2] = g[i2][j2];\n\t\trep(k, M) rep(i2, M) rep(j2, M) chmin(gg[i2][j2], gg[i2][k]+gg[k][j2]);\n\t\tif(gg[1][201]!=d[i][j]){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}*/\n\tcout<<\"Possible\"<<endl;\n\tcout<<201<<\" \"<<m<<endl;\n\tfor(ll i = 1; i <= 100; i++) cout<<i<<\" \"<<i+1<<\" X\"<<endl;\n\tfor(ll i = 101; i <= 200; i++) cout<<i<<\" \"<<i+1<<\" Y\"<<endl;\n\trep(i, M) rep(j, M) if(g[i][j]!=-1) cout<<i<<\" \"<<j<<\" \"<<g[i][j]<<endl;\n\tcout<<\"1 201\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1000000007;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 100007;\nconst LD EPS = 1e-7;\n\nconst int MAXA = 17;\n\nint D[MAXA][MAXA], C[MAXA][MAXA];\nvector <pair <PII, int> > E;\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tint a, b;\n\tcin >> a >> b;\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tcin >> D[i][j];\n\t\tC[i][j] = INF;\n\t}\n\tREP(c1, 101)\n\t\tREP(c2, 101)\n\t\tREP(c3, 101)\n\t{\n\t\tbool ok = true, s = false;\n\t\tFOR(i, 1, a + 1)\n\t\t\tFOR(j, 1, b + 1)\n\t\t{\n\t\t\tint d = c1 * i + c2 * j + c3;\n\t\t\tif (d < D[i][j])\n\t\t\t\tok = false;\n\t\t\tif (d == D[i][j] && C[i][j] > D[i][j])\n\t\t\t\ts = true;\n\t\t}\n\t\tif (ok && s)\n\t\t{\n\t\t\tFOR(i, 1, a + 1)\n\t\t\t\tFOR(j, 1, b + 1)\n\t\t\t\tC[i][j] = min(C[i][j], c1 * i + c2 * j + c3);\n\t\t\tE.push_back(MP(MP(c1 + 1, 22 - c2), c3));\n\t\t}\n\t}\n\tFOR(i, 1, a + 1)\n\t\tFOR(j, 1, b + 1)\n\t{\n\t\tif (C[i][j] > D[i][j])\n\t\t{\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"Possible\\n\";\n\tcout << \"22 \" << SZ(E) + 20 << '\\n';\n\tREP(i, 10)\n\t\tcout << i + 1 << ' ' << i + 2 << \" X\\n\";\n\tREP(i, 10)\n\t\tcout << 22 - i << ' ' << 22 - i - 1 << \" Y\\n\";\n\tREP(i, SZ(E))\n\t\tcout << E[i].first.first << ' ' << E[i].first.second << ' ' << E[i].second << '\\n';\n\tcout << \"1 22\";\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint A,B;\nint d[11][11];\nconst int T = 100;\n\nint c[T+1][T+1];\n\nint main(){\n\tcin>>A>>B;\n\trep1(x,A) rep1(y,B) cin>>d[x][y];\n\trep(i,T+1) rep(j,T+1){\n\t\tint cij = 0;\n\t\trep1(x,A) rep1(y,B) chmax(cij,d[x][y]-x*i-y*j);\n\t\tc[i][j] = cij;\n\t}\n\n\trep1(x,A) rep1(y,B){\n\t\tint dxy = 1e9;\n\t\trep(i,T+1) rep(j,T+1) chmin(dxy,x*i+y*j+c[i][j]);\n\t\tif(dxy != d[x][y]){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tint N = (T+1)*2, M = T*2 + (T+1)*(T+1);\n\tcout<<N<<\" \"<<M<<endl;\n\trep(t,T){\n\t\tcout<<1+t<<\" \"<<2+t<<\" X\"<<endl;\n\t}\n\trep(t,T){\n\t\tcout<<T+3+t<<\" \"<<T+2+t<<\" Y\"<<endl;\n\t}\n\trep(i,T+1) rep(j,T+1){\n\t\tcout<<1+i<<\" \"<<T+2+j<<\" \"<<c[i][j]<<endl;\n\t}\n\tcout<<1<<\" \"<<T+2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register int\nusing namespace std;\nint n,m,d[15][15],f[110][110];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re i=1;i<=n;i++)\n\tfor(re j=1;j<=m;j++)scanf(\"%d\",&d[i][j]);\n\tfor(re i=0;i<=100;i++){\n\t\tfor(re j=0;j<=100;j++){\n\t\t\tfor(re k=1;k<=n;k++){\n\t\t\t\tfor(re l=1;l<=m;l++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[k][l]-i*k-j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(re i=1;i<=n;i++){\n\t\tfor(re j=1;j<=m;j++){\n\t\t\tint now=0x3f3f3f3f;\n\t\t\tfor(re k=0;k<=100;k++){\n\t\t\t\tfor(re l=0;l<=100;l++){\n\t\t\t\t\tnow=min(now,f[k][l]+i*k+j*l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[i][j]){\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<=202;i++)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define fi first\n#define se second\n#define pb push_back\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\n#define L(i,u) for (int i=head[u]; i!=0; i=edge[i].nxt)\n#define abs(a) ((a)>0 ? (a) : -(a))\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntypedef long long ll;\ntypedef long double ld;\nconst int N = 1002, M = 500000;\n\n\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') {x=10*x+c-'0'; c=getchar();} x*=f;\n}\nint n,m,d[N][N],sz,dy[N][N],s,t,C[N][N];\nbool ok[N][N];\nint tot,st1[M],st2[M],st3[M],a[N],b[N];\nbool mrk[M];\nint main() { //freopen(\"1.in\",\"r\",stdin);\n\tread(n); read(m); rep(i,1,n) rep(j,1,m) read(d[i][j]);\n\ts=203; t=s+1;\n\tif (n==1&&m==1) {\n\t\tputs(\"Possible\");\n\t\tprintf(\"2 1\\n\");\n\t\tprintf(\"1 2 %d\\n\",d[1][1]);\n\t\tprintf(\"1 2\");\n\t\treturn 0;\n\t}\n\t\n\t\n\trep(A,0,100) rep(B,0,100) {\n\t\tint mx=0;\n\t\trep(i,1,n) rep(j,1,m) mx=max(mx,d[i][j]-A*i-B*j);\n\t\trep(i,1,n) rep(j,1,m) if (d[i][j]-A*i-B*j==mx) ok[i][j]=1;\n\t\tC[A][B]=mx;\n\t}\n\trep(i,1,n) rep(j,1,m) if (!ok[i][j]) {puts(\"Impossible\"); return 0;}\n\t\n\t\n\trep(i,0,100) a[i]=++sz;\n\trep(i,0,100) b[i]=++sz;\n\tst1[++tot]=s; st2[tot]=a[0]; st3[tot]=0;\n\tst1[++tot]=b[0]; st2[tot]=t; st3[tot]=0;\n\trep(i,0,99) {st1[++tot]=a[i]; st2[tot]=a[i+1]; st3[tot]=1; mrk[tot]=1;}\n\trep(i,0,99) {st1[++tot]=b[i+1]; st2[tot]=b[i]; st3[tot]=2; mrk[tot]=1;}\t\n\trep(i,0,100) rep(j,0,100) {st1[++tot]=a[i]; st2[tot]=b[j]; st3[tot]=C[i][j];}\n\t\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",t,tot);\n\trep(i,1,tot) {\n\t\tprintf(\"%d %d \",st1[i],st2[i]);\n\t\tif (!mrk[i]) printf(\"%d\",st3[i]); else printf(\"%c\",st3[i]==1?'X':'Y');\n\t\tputs(\"\");\n\t}\n\tprintf(\"%d %d\",s,t);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    //freopen(\"inp.in\", \"r\", stdin);\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n    vector< vector<int> > constraints(A+1, vector<int>(B+1,-1));\n    for(int i=1; i<=A; i++)\n    {\n        for(int j=1; j<=B; j++)\n        {\n            scanf(\"%d\", &constraints[i][j]);\n        }\n    }\n    int nb_nodes=202;\n    vector< vector<int> > adjacency_matrix(nb_nodes, vector<int>(nb_nodes, -1));\n    for(int i=1; i<=A; i++)\n    {\n        for(int j=1; j<=B; j++)\n        {\n            int use1=-1;\n            int use2=-1;\n            for(int k1=0; k1<=100 && use1==-1; k1++)\n            {\n                for(int k2=0; k2<=100 && i*k1+j*k2 <= constraints[i][j] && use1==-1; k2++)\n                {\n                    bool ok=true;\n                    int t=constraints[i][j]-i*k1-j*k2;\n                    for(int l=1; l<=A && ok; l++)\n                    {\n                        for(int m=1; m<=B && ok; m++)\n                        {\n                            if(!(k1*l+k2*m+t >= constraints[l][m])) ok=false;\n                        }\n                    }\n                    if(!ok) continue;\n                    use1=k1;\n                    use2=k2;\n                }\n            }\n            //cerr << use1 << \" \" << use2 << endl;\n            if(use1==-1)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            int t=constraints[i][j]-i*use1-j*use2;\n            adjacency_matrix[use1][201-use2]=t;\n        }\n    }\n    int extra=0;\n    for(int i=0; i<nb_nodes; i++)\n    {\n        for(int j=0; j<nb_nodes; j++)\n        {\n            if(adjacency_matrix[i][j] != -1) extra++;\n        }\n    }\n    printf(\"Possible\\n\");\n    printf(\"202 %d\\n\", 200+extra);\n    for(int i=0; i<=99; i++)\n    {\n        printf(\"%d %d X\\n\", i+1, i+2);\n    }\n    for(int i=101; i<=200; i++)\n    {\n        printf(\"%d %d Y\\n\", i+1, i+2);\n    }\n    for(int i=0; i<nb_nodes; i++)\n    {\n        for(int j=0; j<nb_nodes; j++)\n        {\n            if(adjacency_matrix[i][j] != -1)\n            {\n                printf(\"%d %d %d\\n\", i+1, j+1, adjacency_matrix[i][j]);\n            }\n        }\n    }\n    printf(\"%d %d\\n\", 1, 202);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n\n  bool flg=1;\n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      flg&=(dist==d[i][j]);\n      assert(dist<=d[i][j]);\n      \n      //cout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n      //return 0;\n    }\n  }\n  \n  if(!flg){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n/*\nstruct point\n{\nlong long dist; long long name;\nbool operator<(const point& rhs) const {\nreturn dist > rhs.dist;\n}\n};\n*/\n\nll d[20][20];\nll color[20][20] = {};\nll a, b;\n\nvll ansx, ansy, ansc;\nll cnt = 2;\nll edge = 0;\nll flag = 0;\n\nbool check(ll i, ll j) {\n\tif (color[i][j] == 1) {\n\t\treturn 0;\n\t}\n\tll x = d[i + 1][j] - d[i][j];\n\tll y = d[i][j + 1] - d[i][j];\n\tll c = d[i][j] - x * i - y * j;\n\tcnt += ((c != 0) + x + y - 1);\n\tedge += (c != 0) + x + y;\n\tif (min({ x,y,c }) < 0 || cnt > 300) {\n\t\treturn 1;\n\t}\n\tREP(i_, 1, a) {\n\t\tREP(j_, 1, b) {\n\t\t\tif (d[i_][j_] == x * i_ + y * j_ + c) {\n\t\t\t\tcolor[i_][j_] = 1;\n\t\t\t}\n\t\t\telse if (d[i_][j_] > x*i_ + y * j_ + c) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tansx.push_back(x);\n\tansy.push_back(y);\n\tansc.push_back(c);\n\treturn 0;\n}\n\nint main() {\n\tcin >> a >> b;\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tREP(i, 1, a + 1) {\n\t\td[i][b + 1] = d[i][b];\n\t}REP(j, 1, b + 1) {\n\t\td[a + 1][j] = d[a][j];\n\t}\n\tREP(i, 1, a) {\n\t\tREP(j, 1, b) {\n\t\t\tif(check(i, j)){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << cnt << \" \" << edge << endl;\n\tll ver = 3;\n\tREP(i, 0, ansx.size() - 1) {\n\t\tll x = ansx[i];\n\t\tll y = ansy[i];\n\t\tll c = ansc[i];\n\t\tvll ans;\n\t\tvector<char> ansc;\n\t\tans.push_back(1);\n\t\tREP(i, 1, x) {\n\t\t\tans.push_back(ver);\n\t\t\tansc.push_back('X');\n\t\t\tver++;\n\t\t}\n\t\tREP(i, 1, y) {\n\t\t\tans.push_back(ver);\n\t\t\tver++;\n\t\t\tansc.push_back('Y');\n\t\t}\n\t\tif (c != 0) {\n\t\t\tans.push_back(ver);\n\t\t\tver++;\n\t\t\tansc.push_back('Z');\n\t\t}\n\t\tans.pop_back();\n\t\tver--;\n\t\tans.push_back(2);\n\t\t/*\n\t\tREP(i, 0, SIZE(ans) - 1) cout << ans[i] << \" \";\n\t\tcout << endl;\n\t\tREP(i, 0, SIZE(ansc) - 1) cout << ansc[i] << \" \";\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i, 0, SIZE(ans) - 2) {\n\t\t\tif (ansc[i] != 'Z') {\n\t\t\t\tcout << ans[i] << \" \" << ans[i + 1] << \" \" << \n\t\t\t\t\tansc[i] << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << ans[i] << \" \" << ans[i + 1] << \" \" << c << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << 1 << \" \" << 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<pair<int, int>, int> > ans;\nmap<pair<int, int>, int> res;\nint d[15][15];\nint a, b;\n\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++) scanf(\"%d\", d[i]+j);\n\tfor (int i = 1;i <= a;i++) for (int j = 1;j <= b;j++)\n\t{\n\t\tbool done = false;\n\t\tint nA = 0, nB = 0, c = 0;\n\t\tfor (;nA*i <= d[i][j];nA++)\n\t\t{\n\t\t\tfor (nB=0;nA*i+nB*j <= d[i][j];nB++)\n\t\t\t{\n\t\t\t\tc = d[i][j]-nA*i-nB*j;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int x = 1;x <= a;x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1;y <= b;y++) if (nA*x+nB*y+c < d[x][y])\n\t\t\t\t\t{\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ok) break;\n\t\t\t\t}\n\t\t\t\tif (ok)\n\t\t\t\t{\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (done) break;\n\t\t}\n\t\tif (!done)\n\t\t{\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tres[make_pair(nA, nB)] = c;\n\t}\n\ta = 0, b = 0;\n\tfor (auto u: res) a = max(a, u.first.first), b = max(b, u.first.second);\n\tfor (int i = 1;i <= a;i++) ans.emplace_back(make_pair(i-1, i), -1);\n\tfor (int i = 0;i <= a;i++) for (int j = 1;j <= b;j++) ans.emplace_back(make_pair((j-1)*(a+1)+i, j*(a+1)+i), -2);\n\tfor (auto u: res) ans.emplace_back(make_pair(u.first.second*(a+1)+u.first.first, 299), u.second);\n\tprintf(\"Possible\\n300 %ld\\n\", ans.size());\n\tfor (auto u: ans)\n\t{\n\t\tprintf(\"%d %d \", u.first.first+1, u.first.second+1);\n\t\tif (u.second >= 0) printf(\"%d\\n\", u.second);\n\t\telse if (u.second == -1) printf(\"X\\n\");\n\t\telse printf(\"Y\\n\");\n\t}\n\tprintf(\"1 300\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n    ll A, B;\n    cin >> A >> B;\n    vector<vector<ll>> d(A + 1, vector<ll>(B + 1));\n    for (ll i = 1; i <= A; i++) {\n        for (ll j = 1; j <= B; j++) {\n            cin >> d[i][j];\n        }\n    }\n\n    constexpr ll MAX = 100;\n    vector<vector<ll>> f(MAX + 1, vector<ll>(MAX + 1, 0));\n    for (ll a = 0; a <= MAX; a++) {\n        for (ll b = 0; b <= MAX; b++) {\n            for (ll x = 1; x <= A; x++) {\n                for (ll y = 1; y <= B; y++) {\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n                }\n            }\n        }\n    }\n\n    for (ll x = 1; x <= A; x++) {\n        for (ll y = 1; y <= B; y++) {\n            ll D = LLONG_MAX;\n            for (ll a = 0; a <= MAX; a++) {\n                for (ll b = 0; b <= MAX; b++) {\n                    D = min(D, x * a + y * b + f[a][b]);\n                }\n            }\n            if (D != d[x][y]) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"Possible\" << endl;\n    const ll N = (MAX + 1) * 2;\n    const ll M = MAX * (MAX + 2) + 2 * MAX + 1;\n    cout << N << \" \" << M << endl;\n    for (ll i = 0; i < N - 1; i++) {\n        if (i <= MAX) {\n            //次に辺を張る\n            if (i < MAX) {\n                cout << i + 1 << \" \" << i + 2 << \" X\" << endl;\n            }\n            //下側へ辺を張る\n            for (ll j = 0; j <= MAX; j++) {\n                cout << i + 1 << \" \" << j + MAX + 2 << \" \" << f[i][j] << endl;\n            }\n        } else {\n            //次に辺を張る\n            cout << i + 1 << \" \" << i + 2 << \" Y\" << endl;\n        }\n    }\n    cout << \"1 202\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint A, B;\nint d[11][11];\nint targ[11][11];\nvector<tuple<int, int, int> > ans;\nbool valid(int x, int y, int c)\n{\n    for(int i=1; i<=A; ++i)\n        for(int j=1; j<=B; ++j)\n            if(d[i][j] > i*x+j*y+c)\n                return false;\n    for(int i=1; i<=A; ++i)\n        for(int j=1; j<=B; ++j)\n            targ[i][j] = min(targ[i][j], i*x+j*y+c);\n    return true;\n}\nvoid find(int a, int b)\n{\n    for(int xpy = 0; xpy <= 100; ++ xpy)\n    {\n        for(int x = 0; x<=xpy; ++x)\n        {\n            int y = xpy - x;\n            int c = d[a][b] - a*x-b*y;\n            if(c<0) continue;\n            if(valid(x, y, c))\n            {\n                ans.emplace_back(x, y, c);\n                return;\n            }\n        }\n    }\n    puts(\"Impossible\");\n    exit(0);\n}\nint main()\n{\n    scanf(\"%d%d\", &A, &B);\n    for(int i=1; i<=A; ++i)\n        for(int j=1; j<=B; ++j)\n        {\n            scanf(\"%d\", &d[i][j]);\n            targ[i][j] = 101;\n        }\n    for(int i=1; i<=A; ++i)\n        for(int j=1; j<=B; ++j)\n        {\n            if(targ[i][j] != d[i][j])\n                find(i, j);\n        }\n    int M = 0;\n    int N = 2;\n    for(auto t: ans)\n    {\n        int x, y, c; tie(x, y, c) = t;\n        N += x + y + !!c - 1;\n        M += x + y + !!c;\n    }\n    printf(\"Possible\\n%d %d\\n\", N, M);\n    int tp = 1;\n    for(auto t: ans)\n    {\n        vector<pair<pair<int, int>,int>>V;\n        int x, y, c; tie(x, y, c) = t;\n        for(int i=0; i<x; ++i)\n        {\n            V.emplace_back(make_pair(tp, tp+1), -1);\n            ++tp;\n        }\n        for(int i=0; i<y; ++i)\n        {\n            V.emplace_back(make_pair(tp, tp+1), -2);\n            ++tp;\n        }\n        if(c)\n        {\n            V.emplace_back(make_pair(tp, tp+1), c);\n            ++tp;\n        }\n        --tp;\n        V[0].first.first = 1;\n        V[V.size()-1].first.second = N;\n        for(auto x: V)\n        {\n            printf(\"%d %d \", x.first.first, x.first.second);\n            if(x.second == -2) puts(\"Y\");\n            else if(x.second == -1) puts(\"X\");\n            else printf(\"%d\\n\", x.second);\n        }\n    }\n    printf(\"%d %d\\n\", 1, N);\n    assert(N<=300);\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define max(a,b) ((a>b)?a:b)\n#define min(a,b) ((a<b)?a:b)\nusing namespace std;\nnamespace fio {\n\tstreambuf* in = cin.rdbuf();\n\tchar bb[1000000], * s = bb, * t = bb;\n#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)\n\tinline int read() {\n\t\tint x = 0;\n\t\tchar ch = gc();\n\t\twhile (ch < 48)ch = gc();\n\t\twhile (ch >= 48)x = x * 10 + ch - 48, ch = gc();\n\t\treturn x;\n\t}\n}using fio::read;\nint n, m;\nint arr[15][15];\nint dp[305][305];\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++)for (int u = 1; u <= m; u++)arr[i][u] = read();\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)for (int x = 1; x <= n; x++)for (int y = 1; y <= n; y++)dp[i][u] = max(dp[i][u], arr[x][y] - i * x - u * y);\n\tfor (int x = 0; x <= n; x++)for (int y = 0, now = 0x7fffffff; y <= m; now = 0x7fffffff, y++) {\n\t\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)\n\t\t\tnow = min(now, dp[i][u] + i * x + u * y);\n\t\tif (now != arr[x][y])cout << \"Impossible\", exit(0);\n\t}\n\tputs(\"Possible\"), puts(\"202 10401\");\n\tfor (int i = 1; i <= 201; i++)if (i != 101)cout << i << ' ' << i + 1 << ' ' << (i <= 100 ? 'X' : 'Y') << endl;\n\tfor (int i = 0; i <= 100; i++)for (int u = 0; u <= 100; u++)printf(\"%d %d %d\\n\", i + 1, 202 - u, f[i][u]);\n\tcout << 1 << ' ' << 202;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long\n#define up(i,a,b) for (int i = a, _b = (b); i <= _b; i++)\n#define down(i,a,b) for (int i = a, _b = (b); i >= b; i--)\n#define endl '\\n'\n#define X first\n#define Y second\n#define II pair<int, int>\n#define debug(X) cerr<< #X << \"=\" <<X << endl\n#define debug2(X,Y)  cerr<< #X << \"=\" <<X << \", \" << #Y << \"=\" <<Y << endl\n#define show(X,a,b) {cerr << #X << \" = \"; up(__,a,b) cerr << X[__] << ' '; cerr << endl;}\n#define gc getchar\n#define pc putchar\nusing namespace std;\n\ninline void read(int &x) {\n    register int c = gc();\n    x = 0;\n    int neg = 0;\n    for (;((c<48 || c>57) && c != '-') ;c = gc());\n    if(c=='-') {neg=1;c=gc();}\n    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}\n    if(neg) x=-x;\n}\ninline void writeln(int x) {\n\n         char buffor[21];\n         register int i=0;\n         int neg=0; if (x<0) {neg=1; x= -x;}\n         do{\n               buffor[i++]=(x%10)+'0';\n               x/=10;\n            } while(x);\n           i--;\n           if (neg) pc('-');\n           while(i>=0) pc(buffor[i--]);\n           pc('\\n');\n       }\nint X, Y, d[12][12], f[102][102];\nvector<II> edge;\nvoid input() {\n    cin >> X >> Y;\n    up(i, 1, X)\n        up(j, 1, Y)\n            cin >> d[i][j];\n}\n\nvoid solve() {\n    //s = 201, t= 202\n    up(a, 0, 100)\n        up(b, 0, 100) {\n            f[a][b] = 0;\n            up(x, 1, X)\n                up(y, 1, Y)\n                    f[a][b] = max(f[a][b], d[x][y] - x * a - y * b);\n        }\n\n    up(x, 1, X)\n        up(y, 1, Y) {\n            int cur_d = 1e9;\n            up(a, 0, 100)\n                up(b, 0, 100)\n                    cur_d = min(cur_d, f[a][b] + x * a + y * b);\n            if (cur_d != d[x][y]) {\n                cout << \"Impossible\"; return;\n            }\n        }\n    cout << \"Possible\" << endl;\n    int s = 201, t = 202;\n    cout << 202 << \" \" << 10401 << endl;\n    cout << s << \" \" << 1 << \" X\" << endl;\n    up(i, 1, 99) cout << i << \" \" << i + 1 << \" X\" << endl;\n    up(i, 101, 199) cout << i << \" \" << i + 1 << \" Y\" << endl;\n    cout << 200 << \" \" << t << \" Y\" << endl;\n    up(i, 101, 200) cout << s << \" \" << i << f[0][200 - i + 1] << endl;\n    up(i, 1, 100)\n        up(j, 101, 200)\n            cout << i << \" \" << j << \" \" << f[i][200 - j + 1] << endl;\n    cout << s << \" \" << t << \" \" << f[0][0] << endl;\n    up(i, 1, 100) cout << i << \" \" << t << \" \" << f[i][0] << endl;\n    cout << s << \" \" << t << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    #ifdef I_Love_Pork\n    #define TASK \"tmp\"\n    freopen(TASK\".inp\",\"r\",stdin);\n    freopen(TASK\".out\",\"w\",stdout);\n    #endif\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int inf=1000000000;\nstruct edge{\n\tint t,next,v;\n}g[210001];\nstruct data{\n\tint a,b,v;\n}e[210001];\nint te,i,j,k,n,m,a[21][21],h[411],tot,dis[411],q[210001],v[411],num,s,t,w,tx,ty,fl;\nvoid addedge(int x,int y,int z){\n\t//printf(\"%d %d %d\\n\",x,y,z);\n\tg[++tot].t=y;g[tot].next=h[x];h[x]=tot;g[tot].v=z;\n\te[++te].a=x;e[te].b=y;e[te].v=z;\n}\nint gv(int x){\n\tif (x>=0) return x;\n\tif (x==-1) return tx;else return ty;\n}\nint work(int x,int y){\n\tint i,j,res=0;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) res=max(res,a[i][j]-i*x-j*y);\n\treturn res;\n}\nint spfa(){\n\tint i,j,k,l,r;\n\tmemset(v,0,sizeof(v));\n\tfor (i=1;i<=num;i++) dis[i]=inf;\n\tl=0;r=1;q[1]=1;dis[1]=0;\n\twhile (l<r){\n\t\tj=q[++l];v[j]=0;\n\t\tfor (i=h[j];i;i=g[i].next)\n\t\t if (dis[g[i].t]>dis[j]+gv(g[i].v)){\n\t\t \tdis[g[i].t]=dis[j]+gv(g[i].v);\n\t\t \tif (!v[g[i].t]) v[g[i].t]=1,q[++r]=g[i].t;\n\t\t }\n\t}\n\treturn dis[num];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);w=15;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tnum=w*w+1;s=1;t=num;tot=te=0;memset(h,0,sizeof(h));\n\tfor (i=1;i<=w;i++)\n\t for (j=1;j<=w;j++){\n\t \tk=(i-1)*w+j;\n\t \tif (i<w) addedge(k,k+w,-1);\n\t \tif (j<w) addedge(k,k+1,-2);\n\t \taddedge(k,t,work(i-1,j-1));\n\t }\n\tfor (i=fl=1;fl&&i<=n;i++)\n\t for (j=1;fl&&j<=m;j++){\n\t \ttx=i;ty=j;\n\t\tk=spfa();\n\t\tif (k!=a[i][j]) fl=0;//,printf(\"** %d %d %d\\n\",i,j,k);\n\t }\n\tif (!fl){\n\t\tputs(\"Impossible\");\n\t}else{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\",num,te);\n\t\tfor (i=1;i<=te;i++){\n\t\t\tprintf(\"%d %d \",e[i].a,e[i].b);\n\t\t\tif (e[i].v==-1) printf(\"X\\n\");\n\t\t\tif (e[i].v==-2) printf(\"Y\\n\");\n\t\t\tif (e[i].v>=0) printf(\"%d\\n\",e[i].v);\n\t\t}\n\t\tprintf(\"%d %d\\n\",1,num);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n\tassert(dist>=d[i][j]);\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint d[11][11],n,m,tot,now,sum;\nint pa[110],pb[110];\nbool vis[11][11];\nstruct edg{\n\tint a,b,c;\n}ans[310];\nvoid print()\n{\n\t//for (int i=1;i<=sum;i++)\n\t//\tprintf(\"%d %d %d\\n\",ans[i].a,ans[i].b,ans[i].c);\n\t\n\tint numn=0,numm=0;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tnumm+=ans[i].a+ans[i].b+(ans[i].c!=0);\n\t\tnumn+=ans[i].a+ans[i].b+(ans[i].c!=0)-1;\n\t}\n\tnumn+=2;\n\tif (numn>300) {printf(\"Impossible\\n\");return;}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",numn,numm);\n\tint t=1,pre=1;\n\tfor (int i=1;i<=sum;i++)\n\t{\n\t\tpre=1;\n\t\tif (ans[i].c) printf(\"%d %d %d\\n\",pre,++t,ans[i].c),pre=t;\n\t\tfor (int j=1;j<=ans[i].a;j++)\n\t\t{\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].a)?numn:++t,'X'),pre=t;\n\t\t\t\n\t\t}\n\t\tfor (int j=1;j<=ans[i].b;j++)\n\t\t\tprintf(\"%d %d %c\\n\",pre,(j==ans[i].b)?numn:++t,'Y'),pre=t;\n\t\t\n\t}\n\tprintf(\"%d %d\\n\",1,numn);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=m;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tfor (int s=0;s<=300;s++)\n\t\tfor (int a=0;a<=s&&a<=100;a++)\n\t\t\tfor (int b=0;b<=s-a&&b<=100;b++)\n\t\t\t\tfor (int c=0;c<=s-a-b&&c<=100;c++)\n\t\t\t\t{\n\t\t\t\t\tbool p=0,q=0;\n\t\t\t\t\tint now=0;\n\t\t\t\t\tfor (int i=1;i<=n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=1;j<=m;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (a*i+b*j+c==d[i][j]&&!vis[i][j]) q=1,now++,pa[now]=i,pb[now]=j;\n\t\t\t\t\t\t\telse if (a*i+b*j+c<d[i][j]) {p=1;break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p==1) break;\n\t\t\t\t\t}\n\t\t\t\t\tif ((!p)&&q) \n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i=1;i<=now;i++)\n\t\t\t\t\t\t\tvis[pa[i]][pb[i]]=1;\n\t\t\t\t\t\ttot+=now,ans[++sum].a=a,ans[sum].b=b,ans[sum].c=c;\n\t\t\t\t\t\tif (tot==n*m){print();return 0;}\n\t\t\t\t\t}\n\t\t\t\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nint a[15][15],g[105][105];\nint main()\n{\n\tint n,m,i,j,x,y,k,l,o,O,cnt=200;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)for(j=1;j<=m;++j)scanf(\"%d\",&a[i][j]);\n\tmemset(g,-1,sizeof(g));\n\tfor(i=1;i<=n;++i)for(j=1;j<=m;++j)\n\t{\n\t\tfor(o=x=0;x<=100&&!o;++x)for(y=0;y<=100&&!o;++y)if(g[x][y]>=0&&g[x][y]+x*i+y*j==a[i][j])o=1;\n\t\tif(o)continue;\n\t\tfor(x=0;x<=100&&!o;++x)for(y=0;y<=100&&!o;++y)if(g[x][y]<0&&x*i+y*j<=a[i][j])\n\t\t{\n\t\t\tfor(O=0,k=1;k<=n&&!O;++k)for(l=1;l<=m&&!O;++l)if(x*k+y*l+a[i][j]-x*i-y*j<a[k][l])O=1;\n\t\t\tif(!O){g[x][y]=a[i][j]-x*i-y*j;o=1;++cnt;}\n\t\t}\n\t\tif(!o)return 0*puts(\"Impossible\");\n\t}\n\tprintf(\"Possible\\n202 %d\\n\",cnt);\n\tfor(i=1;i<=100;++i)printf(\"%d %d X\\n\",i,i+1);\n\tfor(i=102;i<=201;++i)printf(\"%d %d Y\\n\",i,i+1);\n\tfor(i=0;i<=100;++i)for(j=0;j<=100;++j)if(g[i][j]>=0)printf(\"%d %d %d\\n\",i+1,202-j,g[i][j]);\n\tputs(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAXN = 305;\nint A, B, D[15][15], F[105][105];\nint S, T, M;\nint main()\n{\n\tscanf(\"%d%d\", &A, &B);\n\tfor(int I = 1; I <= A; ++I)\n\t\tfor(int J = 1; J <= B; ++J)\n\t\t\tscanf(\"%d\", &D[I][J]);\n\tfor(int numX = 0; numX <= 100; ++numX)\n\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\tfor(int X = 1; X <= A; ++X)\n\t\t\t\tfor(int Y = 1; Y <= B; ++Y)\n\t\t\t\t\tF[numX][numY] = max(F[numX][numY], D[X][Y] - numX * X - numY * Y);\n\tM = 200 + 101 * 101;\n\tS = 1, T = 202;\n\tfor(int X = 1; X <= A; ++X)\n\t\tfor(int Y = 1; Y <= B; ++Y){\n\t\t\tint minDis = 0x3f3f3f3f;\n\t\t\tfor(int numX = 0; numX <= 100; ++numX)\n\t\t\t\tfor(int numY = 0; numY <= 100 && numX + numY <= 100; ++numY)\n\t\t\t\t{\n\t\t\t\t\tminDis = min(minDis, X * numX + Y * numY + F[numX][numY]);\n\t\t\t\t}\n\t\t\tif(minDis != D[X][Y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tputs(\"Possible\");\n\tcout<<202<<\" \"<<M<<endl;\n\tfor(int I = 1; I <= 100; ++I)\n\t\tprintf(\"%d %d X\\n\", I, I + 1);\n\tfor(int I = 102; I <= 201; ++I)\n\t\tprintf(\"%d %d Y\\n\", I, I + 1);\n\tfor(int I = 0; I <= 100; ++I)\n\t\tfor(int J = 0; J <= 100; ++J)\n\t\t\tprintf(\"%d %d %d\\n\", 1 + I, 102 + J, F[I][100 - J]);\n\tcout<<S<<\" \"<<T<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nint main(){\n    int a,b;\n    cin >> a >> b;\n    vector<vector<int> > d(a,vector<int>(b));\n    rep(i,a){\n        rep(j,b){\n            cin >> d[i][j];\n        }\n    }\n    int n,m;\n    n = 200;\n    int s = 203;\n    int t = 204;\n    bool flag = 0;\n    vector<vector< int > > p(101,vector<int>(101,-inf));\n    rep(i,101){\n        rep(j,101){\n            rep(k,a){\n                rep(l,b){\n                    p[i][j] = max(d[k][l]-i*(k+1)-j*(l+1),p[i][j]);\n                }\n            }\n        }\n    }\n    // rep(i,3){\n    //     rep(j,3){\n    //         cerr << i << \" \" << j << \" \" <<  p[i][j] << endl;\n    //     }\n    // }\n    vector<pair<pair<int,int>,int> > edge;\n    vector<vector<pair<int,int> > > g(210);\n    vector<int> x(101);\n    vector<int> y(101);\n    rep(i,101){\n        x[i] = 1+i;\n        y[i] = 202-i;\n    }\n    g[s].push_back(MP(x[0],0));\n    g[y[0]].push_back(MP(t,0));\n    edge.push_back(MP(MP(s,x[0]),0));\n    edge.push_back(MP(MP(y[0],t),0));\n    rep(i,100){\n        g[x[i]].push_back(MP(x[i+1],mod));\n        g[y[i+1]].push_back(MP(y[i],mod/2));\n        edge.push_back(MP(MP(x[i],x[i+1]),mod));\n        edge.push_back(MP(MP(y[i+1],y[i]),mod/2));\n    }\n    rep(i,101){\n        rep(j,101){\n            if(p[i][j]>=0){\n                g[x[i]].push_back(MP(y[j],p[i][j]));\n                edge.push_back(MP(MP(x[i],y[j]),p[i][j]));\n            }\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            int cx = i+1;\n            int cy = j+1;\n            priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >  pq;\n            pq.push(MP(s,0));\n            vector<int> dst(400,inf);\n            dst[s] = 0;\n            while(!pq.empty()){\n                auto x = pq.top();\n                int id = x.first;\n                \n                pq.pop();\n                if(x.second > dst[id])continue;\n                //cerr << id << \" \" << dst[id] << endl;\n                for(auto y:g[id]){\n                    int cs = 0;\n                    if(y.second==mod){\n                        cs = cx;\n                    }else if(y.second==mod/2){\n                        cs = cy;\n                    }else{\n                        cs = y.second;\n                    }\n                    if(dst[y.first]>dst[id]+cs){\n                        dst[y.first] = dst[id]+cs;\n                        pq.push(MP(y.first,dst[y.first]));\n                    }\n                }\n            }\n            //cerr << i << \" \" << j << \" \" << d[i][j] << \" \" <<  dst[t] << endl;\n            if(dst[t]!=d[i][j]){\n                cout <<\"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << edge.size() << endl;\n    for(auto x:edge){\n        cout << x.first.first << \" \" << x.first.second << \" \" ;\n        if(x.second==mod){\n            cout << \"X\" << endl;\n        }else if(x.second==mod/2){\n            cout << \"Y\" << endl;\n        }else{\n            cout << x.second << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nset<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = s;\n\t++s;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i < 50; ++i) {\n\t\tedge.insert({{lenXY[i + 1], s}, -2});\n\t\tedge.insert({{s, lenXY[i]}, -1});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 100; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.insert({{lenX[i + 1], lenX[i]}, -1});\n\t\tedge.insert({{lenY[i + 1], lenY[i]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.insert({{lenXY[Y[i][j]], lenX[X[i][j] - Y[i][j]]}, d[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.insert({{lenXY[X[i][j]], lenY[Y[i][j] - X[i][j]]}, d[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <climits>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <time.h>\n#include <utility>\n#include <vector>\n\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,a,b) for(int32 i = (a); i < (b); ++i)\n#define ALL(x) (x).begin(),(x).end()\n#define scanf scanf_s\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\n\n\nint main(void) {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tuint32 a, b;\n\tstd::cin >> a >> b;\n\tbool f = 1;\n\tstd::vector<std::vector<int32>> d(a, std::vector<int32>(b)), x(a, std::vector<int32>(b)), y(a, std::vector<int32>(b)), n(a, std::vector<int32>(b));\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tstd::cin >> d[i][j];\n\t\t}\n\t}\n\trep(i, 0, a) {\n\t\trep(j, 0, b-1) {\n\t\t\ty[i][j] = d[i][j + 1] - d[i][j];\n\t\t\tif (y[i][j] < 0) f = 0;\n\t\t\tif (j != 0) {\n\t\t\t\tif (y[i][j] - y[i][j - 1] > 0) f = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, a-1) {\n\t\trep(j, 0, b) {\n\t\t\tx[i][j] = d[i + 1][j] - d[i][j];\n\t\t\tif (x[i][j] < 0) f = 0;\n\t\t\tif (i != 0) {\n\t\t\t\tif (x[i][j] - x[i-1][j] > 0) f = 0;\n\t\t\t}\n\t\t}\n\t}\n\tstd::queue < std::pair<std::pair<uint32, uint32>, int32>> Q;\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tn[i][j] = d[i][j] - (i + 1)*x[i][j] - (j + 1)*y[i][j];\n\t\t\tif (n[i][j] < 0) f = 0;\n\t\t\tif (n[i][j] > 100) f = 0;\n\t\t}\n\t}\n\tif (!f) {\n\t\tstd::cout << \"Impossible\"; return 0;\n\t}\n\trep(i, 0, 101) {\n\t\tQ.push({ {i,i + 1},-2 });\n\t}\n\trep(i, 0, 101) {\n\t\tQ.push({ {i + 102,i + 101},-1 });\n\t}\n\trep(i, 0, a) {\n\t\trep(j, 0, b) {\n\t\t\tQ.push({ {y[i][j],x[i][j] + 101},n[i][j] });\n\t\t}\n\t}\n\tstd::cout << \"Possible\\n\";\n\tstd::cout << 202 << \" \" << Q.size() << \"\\n\";\n\twhile (!Q.empty()) {\n\t\t\tstd::cout << Q.front().first.first << \" \" << Q.front().first.second << \" \";\n\t\t\tif (Q.front().second >= 0) {\n\t\t\t\tstd::cout<<Q.front().second << \"\\n\";\n\t\t\t}\n\t\t\telse if (Q.front().second == -1) {\n\t\t\t\tstd::cout << \"X\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstd::cout << \"Y\\n\";\n\t\t\t}\n\t\tQ.pop();\n\t}\n\tstd::cout << \"0 101\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\nint mx[101][101];\nbool used[101][101];\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep0(x,101) rep0(y,101){\n\t\tmx[x][y]=-inf;\n\t\trep(i,1,a) rep(j,1,b){\n\t\t\tgetmax(mx[x][y],d[i][j]-i*x-j*y);\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,101,199) add(i+1,i,inf+2);\n\trep(i,1,a) rep(j,1,b){\n\t\tbool flag=false;\n\t\tint idx,idy;\n\t\trep0(x,101) rep0(y,101){\n\t\t\tif(d[i][j]-i*x-j*y==mx[x][y]){\n\t\t\t\tidx=x,idy=y;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) return puts(\"Impossible\"),0;\n\t\tif(used[idx][idy]) continue;\n\t\tused[idx][idy]=true;\n\t\tadd(!idx?s:idx,!idy?t:idy+100,mx[idx][idy]);\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"%d %d\\n\",s,t);\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i <= a; i++) {\n\t\tfor (int j = 0; j <= b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * (i + 1) + (k + 1) * (j + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 1, unus - (j + 1), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=15;\nconst int maxm=105;\nint a,b;\nint d[maxn][maxn],e[maxm][maxm];\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tfor(register int i=1;i<=a;i++){\n\t\tfor(register int j=1;j<=b;j++)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tfor(register int x=1;x<=a;x++){\n\t\t\t\tfor(register int y=1;y<=b;y++){\n\t\t\t\t\te[i][j]=max(e[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int x=1;x<=a;x++){\n\t\tfor(register int y=1;y<=b;y++){\n\t\t\tint tmp=maxm;\n\t\t\tfor(register int i=0;i<maxm;i++){\n\t\t\t\tfor(register int j=0;j<maxm;j++){\n\t\t\t\t\ttmp=min(tmp,e[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp!=d[x][y]){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"possible\"<<endl;\n\tcout<<2*maxm<<' '<<2*(maxm-1)+maxm*maxm;\n\tfor(register int i=1;i<maxm;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",maxm+i,maxm+i+1);\n\t}\n\tfor(register int i=0;i<maxm;i++){\n\t\tfor(register int j=0;j<maxm;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,maxm-j,e[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 %d\\n\",2*maxm);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 100;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::vector<std::vector<int>> lb_A(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> lb_B(A, std::vector<int>(B, 0));\n  std::vector<std::vector<int>> ub_A(A, std::vector<int>(B, d_max));\n  std::vector<std::vector<int>> ub_B(A, std::vector<int>(B, d_max));\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (i > 0) {\n        chmax(lb_A[i - 1][j], dist[i][j] - dist[i - 1][j]);\n        chmin(ub_A[i][j], dist[i][j] - dist[i - 1][j]);\n      }\n      if (j > 0) {\n        chmax(lb_B[i][j - 1], dist[i][j] - dist[i][j - 1]);\n        chmin(ub_B[i][j], dist[i][j] - dist[i][j - 1]);\n      }\n    }\n  }\n  int N = 2 * (d_max + 1);\n  std::array<std::array<int, d_max + 1>, d_max + 1> length{};\n  for (auto &vec: length) {\n    for (auto &x: vec) {\n      x = -1;\n    }\n  }\n  for (int i: range(0, A)) {\n    for (int j: range(0, B)) {\n      if (![&] {\n        for (int a: range(lb_A[i][j], ub_A[i][j] + 1)) {\n          for (int b: range(lb_B[i][j], ub_B[i][j] + 1)) {\n            int rem = dist[i][j] - (i + 1) * a - (j + 1) * b;\n            if (0 <= rem && rem <= d_max) {\n              length[a][b] = rem;\n              return true;\n            }\n          }\n        }\n        return false;\n      }()) {\n        std::cout << \"Impossible1\\n\";\n        return 0;\n      }\n    }\n  }\n  int M = 2 * d_max;\n  for (const auto &vec: length) {\n    for (auto x: vec) {\n      if (x != -1) {\n        ++M;\n      }\n    }\n  }\n  std::cout << N << ' ' << M << '\\n';\n  for (int i: range(1, N / 2)) {\n    std::cout << i << ' ' << i + 1 << \" X\\n\";\n  }\n  for (int i: range(N / 2 + 1, N)) {\n    std::cout << i << ' ' << i + 1 << \" Y\\n\";\n  }\n  for (int i: range(0, d_max + 1)) {\n    for (int j: range(0, d_max + 1)) {\n      if (length[i][j] != -1) {\n        std::cout << i + 1 << ' ' << N - j << ' ' << length[i][j] << '\\n';\n      }\n    }\n  }\n  std::cout << \"1 \" << N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b;\nint v[20][20];\nbool taken[20][20];\nvector<pair<int, int> > adj[110];\nbool taken2[101][101];\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &v[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tif (taken2[i][j]) break;\n\t\t\t\tif (i + j + k > 100) break;\n\t\t\t\tbool works = true;\n\t\t\t\tbool canhelp = false;\n\t\t\t\tfor (int x = 1; x <= a && works; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k < v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworks = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i * x + j * y + k == v[x][y] && !taken[x][y]) canhelp = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!works) continue;\n\t\t\t\tif (!canhelp) continue;\n\t\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k == v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttaken[x][y] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttaken2[i][j] = true;\n\t\t\t\tadj[i].emplace_back(j, k);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tif (!taken[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint constant = 10*10;\n\t// 1 = sink\n\t// 2 - 101 = that many xs\n\t// 102 - 201 = that many ys\n\t// 202 (2*constant + 2) sink\n\tprintf(\"Possible\\n\");\n\tvector<pair<pair<int, int> , char> > out;\n\tvector<pair<pair<int, int> , int> > out2;\n\tprintf(\"%d \", 2*constant+2);\n\tfor (int i = 1; i <= constant; i++)\n\t{\n\t\tout.emplace_back(make_pair(i, i+1), 'X');\n\t//\tprintf(\"%d %d X\\n\", i, i+1);\n\t\tout.emplace_back(make_pair(i+constant+1, i+constant+2), 'Y');\n\t//\tprintf(\"%d %d Y\\n\", i+constant+1, i + constant+2);\n\t}\n\tfor (int i = 0; i <= constant; i++)\n\t{\n\t\tfor (auto a : adj[i])\n\t\t{\n\t\t\tint y = a.first;\n\t\t\ty = constant-y;\n\t\t\t// 0 if 100\n\t\t\ty += constant+2;\n\t\t\tint wei = a.second;\n\t\t\tout2.emplace_back(make_pair(i+1, y), wei);\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", out.size() + out2.size());\n\tfor (auto a : out) printf(\"%d %d %c\\n\", a.first.first, a.first.second, a.second);\n\tfor (auto a : out2) printf(\"%d %d %d\\n\", a.first.first, a.first.second, a.second);\n\tprintf(\"%d %d\\n\", 1, 2*constant+2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<P,string> PP;\n\nstring S(ll x){\n  string s;\n  stringstream ss;\n  ss << x;ss >> s;\n  return s;\n}\n\nll N(string s){\n  ll x;\n  stringstream ss;\n  ss << s;ss >> x;\n  return x;\n}\n\nvoid Main() {\n  ll X,Y;\n  cin >> X >> Y;\n  ll a[X+1][Y+1];\n  REP(i,1,X+1)REP(j,1,Y+1) R a[i][j];\n  REP(i,1,X+1) {\n    REP(j,1,Y) {\n      if(a[i][j]>a[i][j+1]) {\n        pr(\"Impossible\");\n        return;\n      }\n    }\n  }\n  REP(j,1,Y+1) {\n    REP(i,1,X) {\n      if(a[i][j]>a[i+1][j]) {\n        pr(\"Impossible\");\n        return;\n      }\n    }\n  }\n  vector<PP> v;\n  map<P,string> mm;\n  ll k=3;\n  REP(x,1,X+1) {\n    REP(y,1,Y+1) {\n      ll d=a[x][y]-x-y;\n      if(d>=0) {\n        v.pb(PP(P(1,k),\"X\"));\n        while(d) {\n          v.pb(PP(P(k,k+1),S(min(100LL,d))));\n          d-=min(100LL,d);\n          k++;\n        }\n        v.pb(PP(P(k,2),\"Y\"));\n        k++;\n      } else {\n        string t=\"X\";\n        d=a[x][y]-x;\n        if(x==X&&y==Y);\n        else if(x==X||a[x][y+1]>=a[x+1][y]) {\n          d=a[x][y]-y;\n          t=\"Y\";\n        }\n        if(d<0) {\n          if(t==\"X\") {\n            d=a[x][y]-y;\n            t=\"Y\";\n          } else {\n            d=a[x][y]-x;\n            t=\"X\";\n          }\n        }\n        if(d<0) {\n          d=a[x][y];\n          t=\"\";\n        }\n        if(t!=\"\") {\n          v.pb(PP(P(1,k),t));\n          v.pb(PP(P(k,2),S(d)));\n          k++;\n        } else {\n          if(mm[P(1,2)]!=S(d)) {\n            pr(\"Impossible\");\n            return;\n          } \n          v.pb(PP(P(1,2),S(d)));\n          mm[P(1,2)]=S(d);\n        }\n      }\n    }\n  }\n  if(k>301) {\n    pr(\"Impossible\");\n    return;\n  }\n  REP(xx,1,X+1) {\n    REP(yy,1,Y+1) {\n      vector<P> g[k];\n      rep(i,v.size()) {\n        if(v[i].S==\"X\") g[v[i].F.F].pb(P(v[i].F.S,xx));\n        else if(v[i].S==\"Y\") g[v[i].F.F].pb(P(v[i].F.S,yy));\n        else g[v[i].F.F].pb(P(v[i].F.S,N(v[i].S)));\n      }\n      ll d[k];\n      fill(d,d+k,MAX);\n      d[1]=0;\n      priority_queue<P,vector<P>,greater<P> > que;\n      que.push(P(0,1));\n      while(!que.empty()) {\n        P p=que.top();que.pop();\n        ll x=p.S,c=p.F;\n        if(x==2) {\n          if(d[x]!=a[xx][yy]) {\n            pr(\"Impossible\");\n            return;\n          }\n          break;\n        }\n        if(d[x]<c) continue;\n        rep(i,g[x].size()) {\n          P q=g[x][i];\n          ll y=q.F,cc=q.S;\n          if(d[y]>cc+c) {\n            d[y]=cc+c;\n            que.push(P(d[y],y));\n          }\n        }\n      }\n    }\n  }\n  pr(\"Possible\");\n  pr(k-1,v.size());\n  rep(i,v.size()) pr(v[i].F.F,v[i].F.S,v[i].S);\n  pr(1,2);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\n\nvoid Set(int a, int b)\n{\n\tint d = D[a - 1][b - 1];\n\n\tint min_f = 999;\n\tint min_i;\n\tint min_j;\n\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tint f = d - ((i * a) + ((100 - j) * b));\n\t\t\tif (f == F[i][j])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (f >= 0 && F[i][j] > 100)\n\t\t\t{\n\t\t\t\tif (min_f > f)\n\t\t\t\t{\n\t\t\t\t\tmin_f = f;\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (min_f > 100)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\telse\n\t{\n\t\tF[min_i][min_j] = min_f;\n\t}\n}\n\nbool Check(int a,int b)\n{\n\tint d = D[a - 1][b - 1];\n\tint min = INT_MAX;\n\tREP(i, 101)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tint m = (i * a) + ((100 - j) * b) + F[i][j];\n\t\t\tmin = MIN(m, min);\n\t\t}\n\t}\n\tif (min == d)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\n\tREP(i, 101) REP(j, 101) F[i][j] = 1000;\n\n\tfor(int a = A - 1; a >= 0; a--)\n\t{\n\t\tfor (int b = B - 1; b >= 0; b--)\n\t\t{\n\t\t\tSet(a + 1, b + 1);\n\t\t}\n\t}\n\n\tint m = 202;\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tif (!Check(a + 1, b + 1))\n\t\t\t{\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << m << endl;\n\t\n\tREP(i, 100)\n\t{\n\t\tcout << i << \" \" << (i + 1) << \" X\"  << endl;\n\t}\n\tREP(i, 100)\n\t{\n\t\tcout << (101 + i) << \" \" << (101 + i + 1) << \" Y\" << endl;\n\t}\n\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tcout << a << \" \" << (101 + b) << \" \" << F[a][b] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"0 201\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define CLR(t, v) memset(t, (v), sizeof(t))\ntemplate <class T1, class T2>ostream &operator<<(ostream &os, const pair<T1, T2> &a){  return os << \"(\" << a.first << \",\" << a.second << \")\";}\ntemplate <class T>void pv(T a, T b){  for (T i = a; i != b; ++i)    cout << (*i) << \" \";  cout << endl;}\ntemplate <class T>void chmin(T &a, const T &b){  if (a > b)    a = b;}\ntemplate <class T>void chmax(T &a, const T &b){  if (a < b)    a = b;}\n\nint nextInt(){  int x;  scanf(\"%d\", &x);  return x;}\n\nconst int INF = 1000000;\nconst int K = 100;\n\nint D[105][105];\nint C[105][105];\n\nstruct E {\n  int from, to, cost;\n};\n\nint main2() {\n  int A = nextInt();\n  int B = nextInt();\n  REP(x, A) REP(y, B) D[x+1][y+1] = nextInt();\n\n  REP(i, K+1) REP(j, K+1) {\n    int c = 0;\n    for (int x = 1; x <= A; x++) for (int y = 1; y <= B; y++) {\n      chmax(c, D[x][y] - i*x - j*y);\n    }\n    C[i][j] = c;\n  }\n\n  bool possible = true;\n  for (int x = 1; x <= A; x++) for (int y = 1; y <= B; y++) {\n    int d = INF;\n    REP(i, K+1) REP(j, K+1) {\n      chmin(d, i*x + j*y + C[i][j]);\n    }\n    if (D[x][y] != d) possible = false;\n  }\n\n  if (possible) {\n    vector<E> es;\n    REP(i, K) es.push_back({i, i+1, -1});\n    REP(j, K) es.push_back({299-j-1, 299-j, -2});\n    REP(i, K) REP(j, K) {\n      es.push_back({i, 299-j, C[i][j]});\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << es.size() << endl;\n    for (auto e : es) {\n      cout << (e.from+1) << \" \" << (e.to + 1) << \" \";\n      if      (e.cost == -1) cout << \"X\";\n      else if (e.cost == -2) cout << \"Y\";\n      else                   cout << e.cost;\n      cout << endl;\n    }\n    cout << 1 << \" \" << 300 << endl;\n\n  } else {\n    cout << \"Impossible\" << endl;\n  }\n  return 0;\n}\n\nint main() {\n  for (; !cin.eof(); cin >> ws) main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 0x7fffffff\n\nint A,B;\nint D[15][15],F[305][305];\n\nvoid init(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++){\n\t\tfor(int j=1;j<=B;j++){\n\t\t\tscanf(\"%d\",&D[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=A;x++){\n\t\t\t\tfor(int y=1;y<=B;y++){\n\t\t\t\t\tF[i][j]=max(F[i][j],D[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++){\n\t\tfor(int y=1;y<=B;y++){\n\t\t\tint f=INF;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tf=min(f,F[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f!=D[x][y]){\n\t\t\t\tprintf(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor(int i=102;i<202;i++){\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,F[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}\n\nint main(void){\n\tinit();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nusing cost_type = int;\n\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge() {}\n\tedge(int to, cost_type cost) : to(to), cost(cost) {}\n};\ntypedef pair<cost_type, int> P;\n\nstatic void run(vector<vector<edge> >& edges, vector<cost_type>& cost_table, int s, vector<int>* _prev = NULL) {\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(), cost_table.end(), numeric_limits<cost_type>::max() / 3);\n\tif (_prev) _prev->resize(edges.size());\n\tif (_prev) fill(_prev->begin(), _prev->end(), -1);\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(0, s));\n\tcost_table[s] = 0;\n\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (cost_table[v] < p.first) continue;\n\t\tfor (const auto& e : edges[v]) {\n\t\t\tif (cost_table[e.to] > cost_table[v] + e.cost) {\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif (_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint d[10][10];\nint minx[10][10], miny[10][10];\n\nint solve(int s, int t, vector<vector<edge>>& e) {\n\tvector<int> costs;\n\trun(e, costs, s);\n\treturn costs[t];\n}\n\nint main() {\n\tint a, b; reader(a, b);\n\tFOR(i, a) FOR(j, b) {\n\t\treader(d[i][j]);\n\t}\n\tbool ok = true;\n\t//FOR(i, a - 2) FOR(j, b) {\n\t//\tint df1 = d[i + 1][j] - d[i][j];\n\t//\tint df2 = d[i + 2][j] - d[i + 1][j];\n\t//\tif (df1 > df2) {\n\t//\t\tok = false;\n\t//\t}\n\t//}\n\t//FOR(i, a) FOR(j, b - 2) {\n\t//}\n\n\tFOR(i, a - 1) FOR(j, b) {\n\t\tint df = d[i + 1][j] - d[i][j];\n\t\tchmax(minx[i][j], df);\n\t}\n\tFOR(i, a) FOR(j, b - 1) {\n\t\tint df = d[i][j + 1] - d[i][j];\n\t\tchmax(miny[i][j], df);\n\t}\n\n\tvector<int> xv, yv;\n\tconst int S = 198, T = 199;\n\txv.push_back(S);\n\tFOR(i, 99) xv.push_back(i);\n\txv.push_back(T);\n\tyv.push_back(S);\n\tFOR(i, 99) yv.push_back(i + 99);\n\tyv.push_back(T);\n\n\tconst int XW = ten(8), YW = -ten(8);\n\tvector<tuple<int, int, int>> vp;\n\tFOR(i, 100) {\n\t\tvp.emplace_back(xv[i], xv[i + 1], XW);\n\t\tvp.emplace_back(yv[i], yv[i + 1], YW);\n\t}\n\tFOR(w, 100) FOR(z, 100) {\n\t\tint maxdiff = -10000;\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tint xw = w * (i + 1);\n\t\t\tint yw = z * (j + 1);\n\t\t\tint additional = d[i][j] - xw - yw;\n\t\t\tchmax(maxdiff, additional);\n\t\t}\n\t\tif (maxdiff >= 0) {\n\t\t\tint from = xv[w], to = yv[100 - z];\n\t\t\t// printf(\"%dx + %dy + %d\\n\", w, z, maxdiff);\n\t\t\tvp.emplace_back(from, to, maxdiff);\n\t\t}\n\t}\n\n\t//FOR(i, a) FOR(j, b) {\n\t//\tint minad = 12345;\n\t//\tint cxw = minx[i][j], cyw = miny[i][j];\n\t//\tfor (int w = minx[i][j]; w <= 100; w++) {\n\t//\t\tfor (int z = miny[i][j]; z <= 100; z++) {\n\t//\t\t\tint xw = w * (i + 1);\n\t//\t\t\tint yw = z * (j + 1);\n\t//\t\t\tint additional = d[i][j] - xw - yw;\n\t//\t\t\tif (additional < 0) {\n\t//\t\t\t\tcontinue;\n\t//\t\t\t}\n\t//\t\t\tif (additional < minad) {\n\t//\t\t\t\tminad = additional;\n\t//\t\t\t\tcxw = w;\n\t//\t\t\t\tcyw = z;\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//\tif (minad == 12345) {\n\t//\t\tok = false;\n\t//\t\tcontinue;\n\t//\t}\n\t//\tint from = xv[cxw], to = yv[100 - cyw];\n\t//\t// printf(\"%d %d %d\\n\", cxw, cyw, minad);\n\t//\tvp.emplace_back(from, to, minad);\n\t//}\n\n\tif (ok) {\n\t\tFOR(i, a) FOR(j, b) {\n\t\t\tvector<vector<edge>> g(200);\n\t\t\tfor (auto& abc : vp) {\n\t\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\t\tif (c == XW) c = i + 1;\n\t\t\t\telse if (c == YW) c = j + 1;\n\t\t\t\tg[a].emplace_back(b, c);\n\t\t\t}\n\t\t\tint cans = solve(S, T, g);\n\t\t\tif (cans != d[i][j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tprintf(\"Possible\\n\");\n\t\tprintf(\"%d %d\\n\", 200, sz(vp));\n\t\tfor (auto& abc : vp) {\n\t\t\tint a, b, c; tie(a, b, c) = abc;\n\t\t\tif (c == XW) {\n\t\t\t\tprintf(\"%d %d X\\n\", a + 1, b + 1);\n\t\t\t} else if (c == YW) {\n\t\t\t\tprintf(\"%d %d Y\\n\", a + 1, b + 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d %d %d\\n\", a + 1, b + 1, c);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", S + 1, T + 1);\n\t} else {\n\t\tprintf(\"Impossible\\n\");\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\n#define min(x,y) (x<y?x:y)\n#define max(x,y) (x>y?x:y)\nconst int M=305;\n\nint n,m,f[M][M],d[M][M];\n\nint read(){\n\tint x=0,y=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-') y=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*y;\n}\n\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\td[i][j]=read();\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tint now=1e9+7;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tnow=min(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n202 10401\\n\");\n\tfor(int i=1;i<=100;i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=102;i<=201;i++) printf(\"%d %d Y\\n\",i,i+1);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tprintf(\"1 202\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n// }}}\n\nusing ll = long long;\n\nconst int INF = numeric_limits<int>::max();\n\nconstexpr int MAX_N = 105;\n\nint A, B, D[11][11];\n\nint F[MAX_N][MAX_N];\n\nint main() {\n    cin >> A >> B;\n    for (int j = 0; j < A; ++j) {\n        for (int k = 0; k < B; ++k) {\n            cin >> D[j][k];\n        }\n    }\n\n    for (int j = 0; j < MAX_N; ++j) for (int k = 0; k < MAX_N; ++k) {\n        for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n            F[j][k] = max(F[j][k], D[a][b] - (a+1) * j - (b+1) * k);\n        }\n    }\n\n    for (int a = 0; a < A; ++a) for (int b = 0; b < B; ++b) {\n        int min_dist = INF;\n        for (int j = 0; j < MAX_N; ++j) {\n            for (int k = 0; k < MAX_N; ++k) {\n                min_dist = min(min_dist, (a+1) * j + (b+1) * k + F[j][k]);\n            }\n        }\n        if (min_dist != D[a][b]) {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n%d %d\\n\", 2*MAX_N, 2*(MAX_N-1) + MAX_N*MAX_N);\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d X\\n\", (j+1), (j+2));\n    }\n    for (int j = 0; j < MAX_N-1; ++j) {\n        printf(\"%d %d Y\\n\", MAX_N+(j+1), MAX_N+(j+2));\n    }\n    for (int j = 0; j < MAX_N; ++j) {\n        for (int k = 0; k < MAX_N; ++k) {\n            printf(\"%d %d %d\\n\", (j+1), MAX_N+(k+1), F[j][k]);\n        }\n    }\n    printf(\"%d %d\\n\", 1, 2*MAX_N);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvoid solve(){\n  int A,B;\n  cin >> A >> B;\n\n  vector<vector<int>> d(A,vector<int>(B));\n  REP(i,A) REP(j,B) cin >> d[i][j];\n  \n  int s = 1, t = 300;\n  mat e(A,vec(B,LINF));\n  vector<T> ans; \n  REP2(i,100) REP2(j,100){\n    int f = 0;\n    REP(a,A) REP(b,B){\n      chmax(f,d[a][b]-(a+1)*i-(b+1)*j);\n    }\n    assert(f <= 100);\n    REP(a,A) REP(b,B){\n      chmin(e[a][b],(a+1)*i+(b+1)*j+f);\n    }\n    ans.emplace_back(i+1,300-j,f);\n  }\n\n  REP(i,A) REP(j,B){\n    if(d[i][j]!=e[i][j]){\n      cout << \"Impossible\" << endl;\n      return;\n    }\n  }\n\n  cout << \"Possible\" << endl;\n  cout << 300 SP 200+ans.size() << endl;\n  REP(i,100) cout << i+1 SP i+2 SP \"X\" << endl;\n  REP(i,100) cout << 200+i SP 201+i SP \"Y\" << endl;\n  REP(i,ans.size()){\n    int x,y,z;\n    tie(x,y,z) = ans[i];\n    cout << x SP y SP z << endl;\n  }\n  cout << s SP t << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=15;\nconst int M=105; \nconst int t=100;\nint m,n,d[N][N],f[M][M],p;\nint read()\n{\tchar x=getchar();\n\twhile(x<48||x>57) x=getchar();\n\tint ans=0;\n\twhile(x>=48&&x<=57)\n\t{\tans=(ans<<1)+(ans<<3)+(x^48);\n\t\tx=getchar();\n\t}\n\treturn ans;\n}\nint main()\n{\tm=read();n=read();\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=n;j++)\n\td[i][j]=read();\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\t{\tp=0x7ffffff;\n\t\tfor(int i=0;i<=t;i++)\n\t\tfor(int j=0;j<=t;j++)\n\t\tp=min(p,i*x+j*y+f[i][j]);\n\t\tif(p!=d[x][y]) {printf(\"Impossible\\n\");return 0;}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(int i=1;i<=t;i++)\n\t{\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,i+102);\n\t}\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\n\nint dis[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int A,B;cin>>A>>B;\n    int N=16*16+1;\n    int M=15*17+16*16;\n    \n    vector<pair<int,int>> ans;\n    \n    for(int i=0;i<256;i+=16){\n        for(int j=0;j<15;j++){\n            ans.push_back(mp(i+j,i+j+1));\n        }\n    }\n    \n    for(int i=0;i+16<256;i+=16) ans.push_back(mp(i,i+16));\n    \n    for(int i=0;i<256;i++) ans.push_back(mp(i,256));\n    \n    vector<vector<int>> S(A+1,vector<int>(B+1));\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            cin>>S[i][j];\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    int sum=a*i+b*j;\n                    chmax(dis[16*b+a][256],S[i][j]-sum);\n                }\n            }\n        }\n    }\n    \n    bool ok=true;\n    \n    for(int i=1;i<=A;i++){\n        for(int j=1;j<=B;j++){\n            int mini=INF;\n            \n            for(int a=0;a<16;a++){\n                for(int b=0;b<16;b++){\n                    chmin(mini,a*i+b*j+dis[16*b+a][256]);\n                }\n            }\n            \n            if(mini!=S[i][j]) ok=false;\n        }\n    }\n    \n    if(ok){\n        cout<<\"Possible\\n\";\n        cout<<N<<\" \"<<M<<endl;\n        for(int i=0;i<M;i++){\n            cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<\" \";\n            if(ans[i].se==256) cout<<dis[ans[i].fi][256]<<\"\\n\";\n            else if(ans[i].se-ans[i].fi==1) cout<<\"X\\n\";\n            else if(ans[i].se-ans[i].fi==16) cout<<\"Y\\n\";\n        }\n        cout<<1<<\" \"<<257<<endl;\n    }else if(A==1){\n        ok=true;\n        for(int j=2;j<=B;j++){\n            if(S[1][1]*j!=S[1][j]) ok=false;\n        }\n        if(ok){\n            cout<<\"Possible\\n\";\n            cout<<S[1][1]+1<<\" \"<<S[1][1]<<endl;\n            for(int i=1;i<=S[1][1];i++){\n                cout<<i<<\" \"<<i+1<<\" \"<<\"Y\\n\";\n            }\n            cout<<1<<\" \"<<S[1][1]+1<<\"\\n\";\n        }else{\n            cout<<\"Impossible\\n\";\n        }\n    }else if(B==1){\n        ok=true;\n        for(int j=2;j<=A;j++){\n            if(S[1][1]*j!=S[j][1]) ok=false;\n        }\n        if(ok){\n            cout<<\"Possible\\n\";\n            cout<<S[1][1]+1<<\" \"<<S[1][1]<<endl;\n            for(int i=1;i<=S[1][1];i++){\n                cout<<i<<\" \"<<i+1<<\" \"<<\"X\\n\";\n            }\n            cout<<1<<\" \"<<S[1][1]+1<<\"\\n\";\n        }else{\n            cout<<\"Impossible\\n\";\n        }\n    }else{\n        cout<<\"Impossible\\n\";\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<vector<T> > d;\n  vector<vector<int> > path;\n  Graph(int n): n(n) {\n    d = vector<vector<T>>(n, vector<T>(n, numeric_limits<T>::max() / 10));\n    path = vector<vector<int>>(n, vector<int>(n, -1));\n    for(int i = 0; i < n; i++)d[i][i] = 0;\n  }\n  void warshall_floyd(){\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          if(d[i][j] > d[i][k] + d[k][j]){\n            d[i][j] = d[i][k] + d[k][j];\n            path[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n  void adde(int at, int to, T cost){\n    d[at][to] = cost;\n  }\n  vector<T>& operator[](size_t i){\n    return d[i];\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\n\nint d[11][11];\nint f[101][101];\n\n\nint main(int argc, char const* argv[])\n{\n  int a, b;\n  cin >> a >> b;\n  rep(i, a)rep(j, b)cin >> d[i][j];\n  rep(i, 101){\n    rep(j, 101){\n      f[i][j] = inf;\n      rep(x, a){\n        rep(y, b){\n          chmin(f[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n        }\n      }\n      if(f[i][j] < 0)f[i][j] = 0;\n    }\n  }\n\n  rep(x, a){\n    rep(y, b){\n      int mini = inf;\n      rep(i, 101){\n        rep(j, 101){\n          mini = min(mini, f[i][j] + (x + 1) * i + (y + 1) * j);\n        }\n      }\n      if(mini != d[x][y]){\n        cout << \"Impossible\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<P, int>> e1;\n  vector<pair<P, char>> e2;\n  rep(i, 100){\n    e2.pb(mk(i + 1, i + 2), 'X');\n  }\n  rep(i, 100){\n    e2.pb(mk(102 + i, 103 + i), 'Y');\n  }\n  rep(i, 101){\n    rep(j, 101){\n      e1.pb(mk(i + 1, 102 + j), f[i][100^j]);\n    }\n  }\n  cout << 202 << \" \" << sz(e1) + sz(e2) << endl;\n  rep(i, sz(e1)){\n    cout << e1[i].first.first << \" \" << e1[i].first.second << \" \" << e1[i].second << endl;\n  }\n  rep(i, sz(e2)){\n    cout << e2[i].first.first << \" \" << e2[i].first.second << \" \" << e2[i].second << endl;\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> a >> b;\n    int matrix[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++) cin >> matrix[i][j];\n    }\n    int mnx[a][b], mny[a][b], mxx[a][b], mxy[a][b];\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            mnx[i][j] = 0;\n            mny[i][j] = 0;\n            mxx[i][j] = matrix[i][j] / (i+1);\n            mxy[i][j] = matrix[i][j] / (j+1);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b-1; j++){\n            int D = matrix[i][j+1] - matrix[i][j];\n            mny[i][j] = max(mny[i][j], D);\n            mxy[i][j+1] = min(mxy[i][j+1], D);\n        }\n    }\n    for (int i=0; i < a-1; i++){\n        for (int j=0; j < b; j++){\n            int D = matrix[i+1][j] - matrix[i][j];\n            mnx[i][j] = max(mnx[i][j], D);\n            mxx[i+1][j] = min(mxx[i+1][j], D);\n        }\n    }\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            if (mnx[i][j] > mxx[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mny[i][j] > mxy[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if (mnx[i][j] * (i+1) + mny[i][j] * (j+1) > matrix[i][j]){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    //cout << mxx[0][1] << \" \" << mxy[0][1] << endl;\n    int sv = 3;\n    vector<pair<int, int> > reb;\n    vector<int> wh;\n    for (int i=0; i < a; i++){\n        for (int j=0; j < b; j++){\n            int K, L, res = -1;\n            for (int k=mnx[i][j]; k <= mxx[i][j]; k++){\n                for (int l=mny[i][j]; l <= mxy[i][j]; l++){\n                    int re = k * (i+1) + l * (j+1);\n                    if (re > matrix[i][j]) continue;\n                    int N = k+l+1;\n                    if (N > res){\n                        res = N;\n                        K = k;\n                        L = l;\n                    }\n                }\n            }\n            int last = 1;\n            for (int k=0; k < K; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-1);\n                last = sv;\n                sv++;\n            }\n            for (int k=0; k < L; k++){\n                reb.push_back(make_pair(last, sv));\n                wh.push_back(-2);\n                last = sv;\n                sv++;\n            }\n            reb.push_back(make_pair(last, 300));\n            wh.push_back(matrix[i][j] - K * (i+1) - L * (j+1));\n        }\n    }\n    if (reb.size() > 299){\n        vector<int> kappa;\n        kappa[0] = -1;\n    }\n    cout << \"Possible\" << endl;\n    cout << 300 << \" \" << reb.size() << endl;\n    for (int i=0; i < reb.size(); i++){\n        cout << reb[i].first << \" \" << reb[i].second << \" \";\n        if (wh[i] == -1) cout << \"X\" << endl;\n        else if (wh[i] == -2) cout << \"Y\" << endl;\n        else cout << wh[i] << endl;\n    }\n    cout << \"1 300\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\treturn x;\n}\nint n,m;\nint d[12][12],f[110][110];\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;++i)\n\tfor(register int j=1;j<=m;++j)\n\td[i][j]=read();\n\tfor(register int i=0;i<=100;++i)\n\tfor(register int j=0;j<=100;++j)\n\tfor(register int x=1;x<=n;++x)\n\tfor(register int y=1;y<=m;++y)\n\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tint now;\n\tfor(register int x=1;x<=n;++x)\n\tfor(register int y=1;y<=m;++y)\n\t{\n\t\tnow=1000000;\n\t\tfor(register int i=0;i<=100;++i)\n\t\tfor(register int j=0;j<=100;++j)\n\t\tnow=min(now,f[i][j]+i*x+j*y);\n\t\tif(now!=d[x][y])\n\t\t{\n\t\t\tcout<<\"Impossible\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<\" \"<<10401<<endl;\n\tfor(register int i=1;i<101;++i)\n\tprintf(\"%d %d X\\n\",i,i+1);\n\tfor(register int i=102;i<202;++i)\n\tprintf(\"%d %d Y\\n\",i,i+1);\n\tfor(register int i=0;i<=100;++i)\n\tfor(register int j=0;j<=100;++j)\n\t{\n\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t}\n\tcout<<1<<\" \"<<202<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<random>\n#include<ctime>\n#include<cstdlib>\n#include<unordered_map>\n#include<string.h>\n#include<iostream>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint d[202];\nvector<P>V;\nint k[10][10];\nsigned main() {\n\tint a, b; cin >> a >> b;\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tcin >> k[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -1,{i,i + 1} });\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tV.push_back({ -2,{ 101+i,i + 102 } });\n\t}\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 101; j <= 201; j++) {\n\t\t\tint MAX = 0;//余裕の最大値\n\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\tfor (int l = 0; l < b; l++) {\n\t\t\t\t\tMAX = max(MAX, ::k[k][l] - i*(k + 1) - (201 - j)*(l + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tV.push_back({ MAX,{i,j} });\n\t\t}\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tmemset(d, 0x3f, sizeof(d));\n\n\t\t\tif (d[201] != k[i][j]) {\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tcout << 202 << \" \" << 101 * 101 << endl;\n\tfor (P i : V) {\n\t\tif (i.first == -1) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" X\" << endl;\n\t\t}\n\t\telse if (i.first == -2) {\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" Y\" <<endl;\n\t\t}\n\t\telse {\n\n\t\t\tcout << i.second.first << \" \" << i.second.second << \" \" << i.first << endl;\n\t\t}\n\t}\n\tcout << 1 << \" \" << 202 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <iomanip>\n#include <tuple>\n#include <functional>\n#include <deque>\n#include <bitset>\n\n#define int long long\n#define CONTAINS(v,n) (find((v).begin(), (v).end(), (n)) != (v).end())\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ARY_SORT(a, size) sort((a), (a)+(size))\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#define REMOVE(v,a) v.erase(remove(v.begin(), v.end(), a), v.end())\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define REPE(i, n) for (int (i) = 0; (i) <= (n); (i)++)\nusing namespace std;\n\nint A, B;\nint D[100][100];\n\nint F[101][101];\n\nvoid Set(int a, int b)\n{\n\tint d = D[a - 1][b - 1];\n\n\tint min_f = 999;\n\tint min_i;\n\tint min_j;\n\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tint f = d - ((i * a) + ((100 - j) * b));\n\t\t\tif (f == F[i][j])\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (f >= 0 && F[i][j] > 100)\n\t\t\t{\n\t\t\t\tif (min_f > f)\n\t\t\t\t{\n\t\t\t\t\tmin_f = f;\n\t\t\t\t\tmin_i = i;\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (min_f > 100)\n\t{\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\telse\n\t{\n\t\tF[min_i][min_j] = min_f;\n\t}\n}\n\nbool Check(int a,int b)\n{\n\tint d = D[a - 1][b - 1];\n\tint min = INT_MAX;\n\tREP(i, 101)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tint m = (i * a) + ((100 - j) * b) + F[i][j];\n\t\t\tmin = MIN(m, min);\n\t\t}\n\t}\n\tif (min == d)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nsigned main()\n{\n\tcin >> A >> B;\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tcin >> D[a][b];\n\t\t}\n\t}\n\n\tREP(i, 101) REP(j, 101) F[i][j] = 1000;\n\n\tfor(int a = A - 1; a >= 0; a--)\n\t{\n\t\tfor (int b = B - 1; b >= 0; b--)\n\t\t{\n\t\t\tSet(a + 1, b + 1);\n\t\t}\n\t}\n\n\tint m = 200;\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(a, A)\n\t{\n\t\tREP(b, B)\n\t\t{\n\t\t\tif (!Check(a + 1, b + 1))\n\t\t\t{\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << 202 << \" \" << m << endl;\n\t\n\tREP(i, 100)\n\t{\n\t\tcout << (i + 1) << \" \" << (i + 2) << \" X\"  << endl;\n\t}\n\tREP(i, 100)\n\t{\n\t\tcout << (102 + i) << \" \" << (102 + i + 1) << \" Y\" << endl;\n\t}\n\n\tREP(a, 101)\n\t{\n\t\tREP(b, 101)\n\t\t{\n\t\t\tif (F[a][b] <= 100)\n\t\t\t{\n\t\t\t\tcout << (a + 1) << \" \" << (101 + b + 1) << \" \" << F[a][b] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"1 202\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 350;\nconst int INF = 1<<30;\n\nint a, b, s, t, sum, d[N][N], f[N][N];\n\ninline void ck_min( int &a, int b ) { if( a > b ) a = b; }\ninline void ck_max( int &a, int b ) { if( a < b ) a = b; }\n\ninline bool check( int x, int y, int val )\n{\n\tint res = INF;\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 ) ck_min( res, i*x + j*y + f[i][j] );\n\t\n//\tprintf( \"x:%d, y:%d, res:%d\\n\", x, y, res );\n\treturn res == val;\n}\n\nint main()\n{\n\tmemset( f, -1, sizeof( f ) );\n\t\n\tscanf( \"%d%d\", &a, &b );\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\n\t\t\tscanf( \"%d\", &d[i][j] );\n\t\t\t\n\ts = 201, t = 202; \n\t// s --> 1 --> 2 --> ... --> 100\n\t// t <-- 101 <-- 102 <-- ... <-- 200\n\t\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t{\n\t\t\tint tmp = -INF;\n\t\t\tfor( int _a = 1; _a <= a; _a ++ )\n\t\t\t\tfor( int _b = 1; _b <= b; _b ++ )\n\t\t\t\t\tck_max( tmp, d[_a][_b] - i*_a - j*_b );\t\n\t\t\tf[i][j] = tmp; \n\t\t\tif( f[i][j] < 0 ) break;\n\t\t\t\n\t\t\tsum ++;\n//\t\t\tprintf( \"i:%d, j:%d, f:%d\\n\", i, j, f[i][j] );\n\t\t}\n\n\tfor( int i = 1; i <= a; i ++ )\n\t\tfor( int j = 1; j <= b; j ++ )\t\n\t\t\tif( !check( i, j, d[i][j] ) ) {\n\t\t\t\tprintf( \"Impossible\\n\" ); return 0;\n\t\t\t} \n\t\t\t\n\tprintf( \"Possible\\n\" );\n\t\n\tprintf( \"%d %d\\n\", 202, sum+200 );\n\tfor( int i = 1; i < 100; i ++ )\n\t\tprintf( \"%d %d X\\n%d %d Y\\n\", i, i+1, i+101, i+100 );\n\tprintf( \"%d %d X\\n%d %d Y\\n\", s, 1, 101, t );\n\tfor( int i = 0; i <= 100; i ++ )\n\t\tfor( int j = 0; j <= 100; j ++ )\n\t\t\tif( f[i][j] >= 0 )  printf( \"%d %d %d\\n\", !i ? s : i, !j ? t : j+100, f[i][j] );\n\tprintf( \"%d %d\\n\", s, t );\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int inf=0x3f3f3f3f;\ninline bool chkmax(int &x,int y){return (y>x)?(x=y,1):0;}\ninline bool chkmin(int &x,int y){return (y<x)?(x=y,1):0;}\nint d[11][11],f[101][101];\nint main(){\n\tint A=read(),B=read();\n\tREP(i,1,A) REP(j,1,B) d[i][j]=read();\n\tREP(i,0,100) REP(j,0,100)\n\t\tREP(x,1,A) REP(y,1,B)\n\t\t\tchkmax(f[i][j],d[x][y]-x*i-y*j);\n\tREP(x,1,A) REP(y,1,B){\n\t\tint dis=inf;\n\t\tREP(i,0,100) REP(j,0,100) chkmin(dis,f[i][j]+i*x+j*y);\n\t\tif(dis!=d[x][y]){\n\t\t\tprintf(\"Impossible\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint n=202,m=101*101+200;\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\",n,m);\n\tREP(i,1,100) printf(\"%d %d x\\n\",i,i+1);\n\tREP(i,102,201) printf(\"%d %d y\\n\",i,i+1);\n\tREP(i,0,100)\n\t\tREP(j,0,100)\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"%d %d\\n\",1,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 2e2 + 22;\nint a, b, d[N][N], f[N][N], ox[N], oy[N], m;\n\nint main() {\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t\tfor (int j = 1; j <= b; j++) scanf(\"%d\", d[i] + j);\n\tfor (int i = 0; i <= 100; i++)\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tf[i][j] = 0;\n\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\tf[i][j] = std::max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\tif (f[i][j]) ox[++m] = i, oy[m] = j;\n\t\t}\n\tfor (int x = 1; x <= a; x++)\n\t\tfor (int y = 1; y <= b; y++) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor (int i = 0; i <= 100; i++)\n\t\t\t\tfor (int j = 0; j <= 100; j++)\n\t\t\t\t\ttmp = std::min(tmp, f[i][j] + i * x + j * y);\n\t\t\tif (tmp != d[x][y]) return puts(\"Impossible\"), 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"200 %d\\n\", 200 + m);\n\tputs(\"201 1 X\\n101 202 Y\");\n\tfor (int i = 1; i < 100; i++)\n\t\tprintf(\"%d %d X\\n%d %d Y\\n\", i, i + 1, i + 101, i + 100);\n\tfor (int i = 1; i <= m; i++)\n\t\tprintf(\"%d %d %d\\n\", ox[i] ? ox[i] : 201, oy[i] ? 100 + oy[i] : 202,\n\t\t\t   f[ox[i]][oy[i]]);\n\tputs(\"201 202\");\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nconstexpr int d_max = 105;\n\nint main() {\n  int A, B;\n  std::cin >> A >> B;\n  std::vector<std::vector<int>> dist(A, std::vector<int>(B));\n  for (auto &vec: dist) {\n    for (auto &x: vec) {\n      std::cin >> x;\n    }\n  }\n  for (int i: range(0, A)) {\n    int dif = d_max;\n    for (int j: range(1, B)) {\n      int tmp = dist[i][j] - dist[i][j - 1];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  for (int j: range(0, B)) {\n    int dif = d_max;\n    for (int i: range(1, A)) {\n      int tmp = dist[i][j] - dist[i - 1][j];\n      if (tmp < 0 || tmp > dif) {\n        std::cout << \"Impossible\\n\";\n        return 0;\n      }\n      dif = tmp;\n    }\n  }\n  std::exit(EXIT_FAILURE);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=15;\nconst int M=105; \nconst int t=100;\nint m,n,d[N][N],f[M][M],p;\nint read()\n{\tchar x=getchar();\n\twhile(x<48||x>57) x=getchar();\n\tint ans=0;\n\twhile(x>=48&&x<=57)\n\t{\tans=(ans<<1)+(ans<<3)+(x^48);\n\t\tx=getchar();\n\t}\n\treturn ans;\n}\nint main()\n{\tm=read();n=read();\n\tfor(int i=1;i<=m;i++)\n\tfor(int j=1;j<=n;j++)\n\td[i][j]=read();\n\tfor(int i=0;i<=t;i++)\n\tfor(int j=0;j<=t;j++)\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\tf[i][j]=max(f[i][j],d[x][y]-i*x-j*y);\n\tfor(int x=1;x<=m;x++)\n\tfor(int y=1;y<=n;y++)\n\t{\tp=0x7ffffff;\n\t\tfor(int i=0;i<=t;i++)\n\t\tfor(int j=0;j<=t;j++)\n\t\tp=min(p,i*x+j*y+f[i][j]);\n\t\tif(p!=d[x][y]) {printf(\"Impossible\\n\");return 0;}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"202 10401\\n\");\n\tfor(int i=1;i<=t;i++)\n\t{\tprintf(\"%d %d X\\n\",i,i+1);\n\t\tprintf(\"%d %d Y\\n\",i+101,1+102);\n\t}\n\tfor(int i=1;i<=t;i++)\n\tfor(int j=1;j<=t;j++)\n\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\tprintf(\"1 202\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define Maxn 300\n#define Maxk 10\n#define Inf 0x3f3f3f3f\nint f[Maxn+5][Maxn+5];\nint d[Maxk+5][Maxk+5];\n//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 \n//d[x][y]=min{f[i][j]+i*x+j*y}\n//f[i][j]=max{d[x][y]-i*x-j*y}\nint mx(int a,int b){\n\treturn a>b?a:b;\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nstruct Edge{\n\tint u,v,w;\n}edge[Maxn*Maxn+5];\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=n;x++){\n\t\t\t\tfor(int y=1;y<=m;y++){\n\t\t\t\t\tf[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now;\n\tfor(int x=1;x<=n;x++){\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tnow=Inf;\n\t\t\tfor(int i=0;i<=100;i++){\n\t\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\t\tnow=mn(now,f[i][j]+i*x+j*y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now!=d[x][y]){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tputs(\"202 10401\");\n\tfor(int i=1;i<=100;i++){\n\t\tprintf(\"%d %d X\\n\",i,i+1);\n\t}\n\tfor(int i=102;i<202;i++){\n\t\tprintf(\"%d %d Y\\n\",i,i+1);\n\t}\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tprintf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n\t\t}\n\t}\n\tputs(\"1 202\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MAXN 15\n#define MAXT 100\n\nconst int inf=0x3f3f3f3f;\n\nint n,m,d[MAXN][MAXN],f[MAXT+5][MAXT+5];\n\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            int mx=0;\n            for(int ii=1;ii<=n;ii++){\n                for(int jj=1;jj<=m;jj++){\n                    if(mx<d[ii][jj]-ii*i-jj*j)\n                        mx=d[ii][jj]-ii*i-jj*j;\n                }\n            }\n            f[i][j]=mx;\n        }\n    }\n    int psb=1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            int mn=inf;\n            for(int ii=0;ii<=100;ii++){\n                for(int jj=0;jj<=100;jj++){\n                    if(mn>f[ii][jj]+ii*i+jj*j)\n                        mn=f[ii][jj]+ii*i+jj*j;\n                }\n            }\n            if(d[i][j]!=mn){\n                psb=0;\n                break;\n            }\n        }\n        if(!psb){\n            break;\n        }\n    }\n    if(!psb){\n        printf(\"Impossible\\n\");\n    }\n    else{\n        printf(\"Possible\\n\");\n        printf(\"202 10401\\n\");\n        for(int i=1;i<=100;i++){\n            printf(\"%d %d X\\n\",i,i+1);\n        }\n        for(int j=1;j<=100;j++){\n            printf(\"%d %d Y\\n\",j+101,j+102);\n        }\n        for(int i=0;i<=100;i++){\n            for(int j=0;j<=100;j++){\n                printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n            }\n        }\n        printf(\"1 202\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 109\nusing namespace std;\n\nint m,n,a[N][N],b[N][N]; bool vis[N][N];\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tint i,j,x,y;\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++) scanf(\"%d\",&a[i][j]);\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++)\n\t\t\tfor (x=0; x<=100; x++)\n\t\t\t\tfor (y=0; y<=100; y++) b[x][y]=max(b[x][y],a[i][j]-i*x-j*y);\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++)\n\t\t\tfor (x=0; x<=100; x++)\n\t\t\t\tfor (y=0; y<=100; y++)\n\t\t\t\t\tif (b[x][y]==a[i][j]-i*x-j*y) vis[i][j]=1;\n\tfor (i=1; i<=m; i++)\n\t\tfor (j=1; j<=n; j++) if (!vis[i][j]){\n\t\t\tputs(\"Impossible\"); return 0;\n\t\t}\n\tputs(\"Possible\");\n\tprintf(\"202 %d\\n\",200+101*101);\n\tfor (i=1; i<=100; i++) printf(\"%d %d X\\n\",i,i+1);\n\tfor (i=102; i<=201; i++) printf(\"%d %d Y\\n\",i+1,i);\n\tfor (i=0; i<=100; i++)\n\t\tfor (j=0; j<=100; j++) printf(\"%d %d %d\\n\",i+1,j+102,b[i][j]);\n\tputs(\"1 102\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint A,B;\n\tcin >> A >> B;\n\tvector< vector<int> > d(A,vector<int>(B));\n\tfor(int i =0; i < A*B; i++) cin >> d[i/B][i%B];\n\n\tvector< vector<int> > mincost(101,vector<int>(101,0));\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++)\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\t mincost[k][l] =max(d[i][j]-k*i-l*j,mincost[k][l]);\n\n\tfor(int i =0; i < A; i++) for(int j =0; j < B; j++) {\n\t\tint m =101;\n\t\tfor(int k =0; k <= 100; k++) for(int l =0; l <= 100; l++)\n\t\t\tm =min(m,mincost[k][l]+k*i+l*j);\n\t\tif(m != d[i][j]) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tint N =2*(3+1), M =(N/2)*(N/2)+2*(N/2-1);\n\tcout << N << \" \" << M << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+1 << \" \" << i+2 << \" X\\n\";\n\tfor(int i =0; i <= N/2-1; i++) for(int j =0; j <= N/2-1; j++)\n\t\tcout << i+1 << \" \" << N-j << \" \" << mincost[i][j] << \"\\n\";\n\tfor(int i =0; i < N/2-1; i++) cout << i+N/2+1 << \" \" << i+N/2+2 << \" Y\\n\";\n\tcout << \"1 \" << N << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; } // これを使うならば、tieとかを消して！！\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nint main(void) {\n    ll X, Y; cin >> X >> Y;\n    vvll d(X, vll(Y)); cin >> d;\n\n    // X=x, Y=y (1 <= x <= X, 1 <= y <= Y)\n    // a = xの数、b = yの数 (0 <= a, b <= 100)\n    //\n    // for all x,y  \n    //      d_xy = min_ab ax+by+c_ab\n    //\n    // c_ab = max(0, max_xy d_xy - ax - by)\n    ll abmax = 101;\n    vvll c(abmax, vll(abmax));\n    rep(a, c.size()) rep(b, c[0].size()) {\n        repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n            chmax(c[a][b], d[x-1][y-1]-a*x-b*y);\n        }\n    }\n    repi(x, 1, 1+X) repi(y, 1, 1+Y) {\n        ll tmp = INF;\n        rep(a, abmax) rep(b, abmax) {\n            chmin(tmp, a*x+b*y+c[a][b]);\n        }\n        if (d[x-1][y-1] != tmp) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n\n    cout << 2 * (abmax+1) << \" \" << 2 + c.size() * c[0].size() + abmax * 2<< endl;\n    rep(i, c.size()) {\n        cout << i+1 << \" \" << i+1+1 << \" \" << \"X\" << endl;\n        cout << 2*abmax+1-i-1+1 << \" \" << 2*abmax+1-i+1 << \" \" << \"Y\" << endl;\n    }\n    rep(a, c.size()) rep(b, c[0].size()) {\n        cout << a+1 << \" \" << 2 * abmax + 1 - b+1 << \" \" << c[a][b] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <cassert>\n#include <iomanip>      \n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n \ntypedef pair<int, int> point;\n \nconst string FILENAME = \"input\";\n\nint A, B;\nint s = 2;\nint d[11][11];\nint X[11][11], Y[11][11], D[11][11];\n\nint lenX[101], lenY[101], lenXY[101];\nset<pair<pair<int, int>, int>> edge;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tsrand(time(0));\n\t//read(FILENAME);\n\tcin >> A >> B;\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tcin >> d[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tX[i][j] = -1;\n\t\t\tfor (int fX = 0; (fX * i) <= d[i][j];  ++fX) {\n\t\t\t\tfor (int fY = 0; (fX * i + fY * j) <= d[i][j]; ++fY) {\n\t\t\t\t\tint fD = d[i][j] - fX * i - fY * j;\n\t\t\t\t\tbool OK = true;\n\t\t\t\t\tfor (int a = 1; a <= A; ++a) {\n\t\t\t\t\t\tfor (int b = 1; b <= B; ++b) {\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t\tif (a * fX + b * fY + fD < d[a][b]) {\n\t\t\t\t\t\t\t\tOK = false;\n\t\t\t\t\t\t\t\ta = b = 1e9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OK) {\n\t\t\t\t\t\tX[i][j] = fX;\n\t\t\t\t\t\tY[i][j] = fY;\n\t\t\t\t\t\tD[i][j] = fD;\n\t\t\t\t\t\t//cout << cnt << endl;\n\t\t\t\t\t\t//cout << i << ' ' << j << ' ' << fX << ' ' << fY << ' ' << fD << endl;\n\t\t\t\t\t\tfX = fY = d[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (X[i][j] == -1) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tlenXY[0] = s;\n\t++s;\n\tlenXY[50] = 0;\n\tfor (int i = 1; i < 50; ++i) {\n\t\tlenXY[i] = s++;\n\t}\n\tfor (int i = 0; i < 50; ++i) {\n\t\tedge.insert({{lenXY[i + 1], s}, -2});\n\t\tedge.insert({{s, lenXY[i]}, -1});\n\t\t++s;\n\t}\n\tlenX[0] = lenY[0] = 1; \n\tlenX[100] = lenY[100] = 0;\n\tfor (int i = 1; i < 100; ++i) {\n\t\tlenX[i] = s++;\n\t\tlenY[i] = s++;\n\t}\n\tfor (int i = 0; i < 99; ++i) {\n\t\tedge.insert({{lenX[i + 1], lenX[i]}, -1});\n\t\tedge.insert({{lenY[i + 1], lenY[i]}, -2});\n\t}\n\tfor (int i = 1; i <= A; ++i) {\n\t\tfor (int j = 1; j <= B; ++j) {\n\t\t\tif (X[i][j] >= Y[i][j]) {\n\t\t\t\tedge.insert({{lenXY[50 - Y[i][j]], lenX[X[i][j] - Y[i][j]]}, d[i][j]});\n\t\t\t} else {\n\t\t\t\tedge.insert({{lenXY[50 - X[i][j]], lenY[Y[i][j] - X[i][j]]}, d[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << s << ' ' << edge.size() << endl;\n\tfor (auto i : edge) {\n\t\tcout << i.x.x + 1 << ' ' << i.x.y + 1 << ' ';\n\t\tif (i.y < 0) {\n\t\t\tif (i.y == -1) cout << \"X\";\n\t\t\telse cout << \"Y\";\n\t\t} else {\n\t\t\tcout << i.y;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << 1 << ' ' << 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MAXN 15\n\nconst int inf=0x3f3f3f3f;\n\nint n,m,d[MAXN][MAXN],f[MAXN][MAXN];\n\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\"%d\", &d[i][j]);\n        }\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<=m;j++){\n            int mx=0;\n            for(int ii=1;ii<=n;ii++){\n                for(int jj=1;jj<=m;jj++){\n                    if(mx<d[ii][jj]-ii*i-jj*j)\n                        mx=d[ii][jj]-ii*i-jj*j;\n                }\n            }\n            f[i][j]=mx;\n        }\n    }\n    int psb=1;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            int mn=inf;\n            for(int ii=0;ii<=n;ii++){\n                for(int jj=0;jj<=m;jj++){\n                    if(mn>f[ii][jj]+ii*i+jj*j)\n                        mn=f[ii][jj]+ii*i+jj*j;\n                }\n            }\n            if(d[i][j]!=mn){\n                psb=0;\n                break;\n            }\n        }\n        if(!psb){\n            break;\n        }\n    }\n    if(!psb){\n        printf(\"Impossible\\n\");\n    }\n    else{\n        printf(\"Possible\\n\");\n        printf(\"%d %d\\n\",n+m+4,n+m+4+n*m);\n        printf(\"%d %d 0\\n\",n+m+3,1);\n        printf(\"%d %d 0\\n\",n+m+3,n+2);\n        printf(\"%d %d 0\\n\",n+1,n+m+4);\n        printf(\"%d %d 0\\n\",n+m+2,n+m+4);\n        for(int i=1;i<=n;i++){\n            printf(\"%d %d X\\n\",i,i+1);\n        }\n        for(int j=1;j<=m;j++){\n            printf(\"%d %d Y\\n\",n+1+j,n+1+j+1);\n        }\n        for(int i=0;i<=n;i++){\n            for(int j=0;j<=m;j++){\n                printf(\"%d %d %d\\n\",i+1,n+m+2-j,f[i][j]);\n            }\n        }\n        printf(\"%d %d\\n\",n+m+3,n+m+4);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b;\nint v[20][20];\nbool taken[20][20];\nvector<pair<int, int> > adj[110];\nint main()\n{\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &v[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i <= 100; i++)\n\t{\n\t\tfor (int j = 0; j <= 100; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tif (i + j + k > 100) break;\n\t\t\t\tbool works = true;\n\t\t\t\tbool canhelp = false;\n\t\t\t\tfor (int x = 1; x <= a && works; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k < v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworks = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (i * x + j * y + k == v[x][y] && !taken[x][y]) canhelp = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!works) continue;\n\t\t\t\tif (!canhelp) continue;\n\t\t\t\tfor (int x = 1; x <= a; x++)\n\t\t\t\t{\n\t\t\t\t\tfor (int y = 1; y <= b; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i * x + j * y + k == v[x][y])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttaken[x][y] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tadj[i].emplace_back(j, k);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++)\n\t{\n\t\tfor (int j = 1; j <= b; j++)\n\t\t{\n\t\t\tif (!taken[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint constant = a*b;\n\t// 1 = sink\n\t// 2 - 101 = that many xs\n\t// 102 - 201 = that many ys\n\t// 202 (2*constant + 2) sink\n\tprintf(\"Possible\\n\");\n\tvector<pair<pair<int, int> , char> > out;\n\tvector<pair<pair<int, int> , int> > out2;\n\tprintf(\"%d \", 2*constant+2);\n\tfor (int i = 1; i <= constant; i++)\n\t{\n\t\tout.emplace_back(make_pair(i, i+1), 'X');\n\t//\tprintf(\"%d %d X\\n\", i, i+1);\n\t\tout.emplace_back(make_pair(i+constant+1, i+constant+2), 'Y');\n\t//\tprintf(\"%d %d Y\\n\", i+constant+1, i + constant+2);\n\t}\n\tfor (int i = 0; i <= constant; i++)\n\t{\n\t\tfor (auto a : adj[i])\n\t\t{\n\t\t\tint y = a.first;\n\t\t\ty = constant-y;\n\t\t\t// 0 if 100\n\t\t\ty += constant+2;\n\t\t\tint wei = a.second;\n\t\t\tout2.emplace_back(make_pair(i+1, y), wei);\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", out.size() + out2.size());\n\tfor (auto a : out) printf(\"%d %d %c\\n\", a.first.first, a.first.second, a.second);\n\tfor (auto a : out2) printf(\"%d %d %d\\n\", a.first.first, a.first.second, a.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define Maxn 300\n#define Maxk 10\n#define Inf 0x3f3f3f3f\nint f[Maxn+5][Maxn+5];\nint d[Maxk+5][Maxk+5];\n//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 \n//d[x][y]=min{f[i][j]+i*x+j*y}\n//f[i][j]=max{d[x][y]-i*x-j*y}\nint mx(int a,int b){\n    return a>b?a:b;\n}\nint mn(int a,int b){\n    return a<b?a:b;\n}\nint n,m;\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&d[i][j]);\n    for(int i=0;i<=100;i++)\n        for(int j=0;j<=100;j++)\n            for(int x=1;x<=n;x++)\n                for(int y=1;y<=m;y++)\n                    f[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);\n    for(int x=1;x<=n;x++)\n        for(int y=1;y<=m;y++){\n            int now=Inf;\n            for(int i=0;i<=100;i++)\n                for(int j=0;j<=100;j++)\n                    now=mn(now,f[i][j]+i*x+j*y);\n            if(now!=d[x][y]){puts(\"Impossible\");return 0;}\n        }\n    puts(\"Possible\");puts(\"202 10401\");\n    for(int i=1;i<=100;i++)printf(\"%d %d X\\n\",i,i+1);\n    for(int i=102;i<202;i++)printf(\"%d %d Y\\n\",i,i+1);\n    for(int i=0;i<=100;i++)\n        for(int j=0;j<=100;j++)\n            printf(\"%d %d %d\\n\",i+1,202-j,f[i][j]);\n    puts(\"1 202\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    //cout<<v<<\":\"<<d[v]<<endl;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n\t//cout<<v<<\"->\"<<u<<\":\"<<c<<endl;\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int a,b;\n  cin>>a>>b;\n  auto d=make_v<Int>(a,b);\n  for(Int i=0;i<a;i++)\n    for(Int j=0;j<b;j++)\n      cin>>d[i][j];\n\n  Int N=101;\n  Int sz=N*2;\n  Int s=sz++,t=sz++,z=sz++;\n  auto idx=[&](Int x){return x;};\n  auto idy=[&](Int y){return N+y;};\n  using P = pair<Int, Int>;\n  vector<vector<P> > G(sz);\n\n  vector<Int> C(sz,0),D(sz,0);\n  auto E=make_v<Int>(sz,sz);\n  auto F=make_v<Int>(sz,sz);\n  fill_v(E,0);\n  fill_v(F,0);\n  \n  const Int INF = 1e5;\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      for(Int k=0;k<N;k++){\n\tchmax(C[k],d[i][j]-(i+1)*(N-(k+1)));\n\tchmax(D[k],d[i][j]-(j+1)*(N-(k+1)));\n\tfor(Int l=0;l<=k;l++){\n\t  chmax(E[k][l],d[i][j]-((i+1)*k+(j+1)*(N-(l+1))));\n\t  chmax(F[k][l],d[i][j]-((j+1)*k+(i+1)*(N-(l+1))));\n\t}\n      }\n    }\n  }\n  \n  G[s].emplace_back(z,0);\n  for(Int k=0;k<N;k++){\n    G[z].emplace_back(idx(k),C[k]);\n    G[z].emplace_back(idy(k),D[k]);\n    \n    for(Int l=0;l<=k;l++){\n      G[idx(k)].emplace_back(idy(l),E[k][l]);\n      G[idy(k)].emplace_back(idx(l),F[k][l]);\n    }\n  }\n  \n  G[s].emplace_back(idx(0),0);\n  G[s].emplace_back(idy(0),0);\n  G[idx(N-1)].emplace_back(t,0);\n  G[idy(N-1)].emplace_back(t,0);\n  \n  for(Int i=0;i<a;i++){\n    for(Int j=0;j<b;j++){\n      auto T=G;\n      for(Int k=1;k<N;k++){\n\tT[idx(k-1)].emplace_back(idx(k),i+1);\n\tT[idy(k-1)].emplace_back(idy(k),j+1);\n      }\n      Int dist=dijkstra(s,T,INF)[t];\n      if(dist!=d[i][j]){\n\t//cout<<i+1<<\" \"<<j+1<<\":\"<<dist<<\" \"<<d[i][j]<<endl;\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n      }\n    }\n  }\n  \n  //assert(0);\n  vector<vector<Int> > X(sz),Y(sz);\n  for(Int i=1;i<N;i++){\n    X[idx(i-1)].emplace_back(idx(i));\n    Y[idy(i-1)].emplace_back(idy(i));\n  }\n  \n  assert(sz<=300);\n  auto cnt=make_v<Int>(sz,sz);\n  fill_v(cnt,0);\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) assert(v!=p.first);\n    for(auto u:X[v]) assert(v!=u);\n    for(auto u:Y[v]) assert(v!=u);\n    \n    for(auto p:G[v]) cnt[v][p.first]++;\n    for(auto u:X[v]) cnt[v][u]++;\n    for(auto u:Y[v]) cnt[v][u]++;\n    for(Int u=0;u<sz;u++) assert(cnt[v][u]<=1);\n\n    for(auto p:G[v]) assert(0<=p.second&&p.second<=100);\n  }\n  \n  Int es=0;\n  for(Int v=0;v<sz;v++) es+=X[v].size()+Y[v].size()+G[v].size();\n  cout<<\"Possible\"<<endl;\n  cout<<sz<<\" \"<<es<<endl;\n  for(Int v=0;v<sz;v++){\n    for(auto p:G[v]) cout<<v+1<<\" \"<<p.first+1<<\" \"<<p.second<<endl;\n    for(Int u:X[v]) cout<<v+1<<\" \"<<u+1<<\" X\"<<endl;\n    for(Int u:Y[v]) cout<<v+1<<\" \"<<u+1<<\" Y\"<<endl;\n  }\n  cout<<s+1<<\" \"<<t+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b;\nvector<vector<int> > d;\n\nint saitan(vector<vector<pair<int, int> > > edges)\n{\n    vector<int> dist_tmp(202, 101);\n    dist_tmp[0] = 0;\n\n    for (int i=0; i<201; i++)\n    {\n        for (auto to : edges[i])\n        {\n            dist_tmp[to.first] = min(dist_tmp[to.first], dist_tmp[i] + to.second);\n        }\n    }\n    return dist_tmp[201];\n}\n\nint main()\n{\n    cin >> a >> b;\n    d = vector<vector<int> >(a, vector<int>(b, 0));\n\n    for (int i=0; i<a; i++) for (int j=0; j<b; j++) cin >> d[i][j];\n\n    vector<vector<int> > length(101, vector<int>(101, 0));\n    for (int ii=0; ii<a; ii++)\n        for (int jj=0; jj<b; jj++)\n            for (int i=0; i<=100; i++)\n                for (int j=0; j<=100; j++)\n                    length[i][j] = max(length[i][j], d[ii][jj] - i * (ii+1) - j * (jj+1));\n\n    vector<vector<pair<int, int> > > edge(201);\n    for (int i=0; i<=100; i++)\n    {\n        for (int j=0; j<=100; j++)\n        {\n            edge[i].push_back(make_pair(201-j, length[i][j]));\n        }\n    }\n\n    for (int x=1; x<=a; x++)\n    {\n        for (int y=1; y<=b; y++)\n        {\n            vector<vector<pair<int, int> > > edge_copy = edge;\n            for (int i=0; i<100; i++)\n            {\n                edge_copy[i].push_back(make_pair(i+1, x));\n                edge_copy[101+i].push_back(make_pair(i+102, y));\n            }\n            if (saitan(edge_copy) != d[x-1][y-1])\n            {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"Possible\" << endl;\n\n    cout << \"202 10401\" << endl;\n    for (int i=1; i<=100; i++)\n    {\n        cout << i << \" \" << i+1 << \" X\" << endl;\n        cout << i+101 << \" \" << i+102 << \" Y\" << endl;\n    }\n    for (int i=0; i<=100; i++)\n    {\n        for (int j=0; j<=100; j++)\n        {\n            cout << i+1 << \" \" << 202-j << \" \" << length[i][j] << endl;\n        }\n    }\n    cout << \"1 202\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int inf=1<<30,N=100;\nint A,B,d[11][11],f[11][11],c[111][111];\nvoid cmax(int&a,int b){b>a?a=b:1;}\nvoid cmin(int&a,int b){b<a?a=b:1;}\nint main(){\n\tscanf(\"%d%d\",&A,&B);\n\tfor(int i=1;i<=A;i++)\n\t\tfor(int j=1;j<=B;j++)scanf(\"%d\",d[i]+j),f[i][j]=inf;\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tfor(int x=1;x<=A;x++)\n\t\t\t\tfor(int y=1;y<=B;y++)cmax(c[i][j],d[x][y]-i*x-j*y);\n\t\t\tfor(int x=1;x<=A;x++)\n\t\t\t\tfor(int y=1;y<=B;y++)cmin(f[x][y],i*x+j*y+c[i][j]);\n\t\t}\n\t}\n\tfor(int x=1;x<=A;x++)\n\t\tfor(int y=1;y<=B;y++)if(f[x][y]!=d[x][y])return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tprintf(\"%d %d\\n\",N+1<<1,(N+1)*(N+1)+N*2);\n\tfor(int i=1;i<=N;i++)printf(\"%d %d X\\n\",i,i+1);\n\tfor(int i=N;i>=1;i--)printf(\"%d %d Y\\n\",i+N+2,i+N+1);\n\tfor(int i=0;i<=N;i++)\n\t\tfor(int j=0;j<=N;j++)printf(\"%d %d %d\\n\",i+1,j+N+2,c[i][j]);\n\tprintf(\"%d %d\\n\",1,N+2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define se second\n#define fi first\n#define mk(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pii;\n\nint A,B;\nint D[10][10];\nint mem[110][110];\nvector<pii> G[300];\nint dis[300];\n\nint main()\n{\n    scanf(\"%d%d\",&A,&B);\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            scanf(\"%d\",&D[i][j]);\n        }\n    }\n\n    for(int i = 0; i <= 100; i++)\n    {\n        for(int j = 0; j <= 100; j++)\n        {\n            int res = 0;\n            for(int k = 1; k <= A; k++)\n            {\n                for(int l = 1; l <= B; l++)\n                {\n                    res = max(res,D[k][l] - i * k - j * l);\n                }\n            }\n            if(res > 100)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n            mem[i][j] = res;\n        }\n    }\n\n    for(int i = 1; i <= A; i++)\n    {\n        for(int j = 1; j <= B; j++)\n        {\n            int MIN = 1001001001;\n            for(int k = 0; k <= 100; k++)\n            {\n                for(int l = 0; l <= 100; l++)\n                {\n                    MIN = min(MIN,k * i + l * j + mem[k][l]);\n                }\n            }\n            if(1)\n            {\n                printf(\"Impossible\\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"202 10401\\n\");\n    for(int i = 0; i < 100; i++)\n    {\n        printf(\"%d %d X\\n\",i + 1,i + 2);\n        printf(\"%d %d Y\\n\",i + 2 + 101,i + 1 + 101);\n    }\n\n    for(int i = 0; i < 101; i++)\n    {\n        for(int j = 0; j < 101; j++)\n        {\n            printf(\"%d %d %d\\n\",j + 1,i + 1 + 101,mem[i][j]);\n        }\n    }\n\n    printf(\"1 102\\n\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 200\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint A,B,d[35][35],b[35][35],m;\nstruct edge{int x,y,w;}e[MN*MN+5];\nint main()\n{\n    A=read();B=read();\n    for(int i=1;i<=A;++i) for(int j=1;j<=B;++j) d[i][j]=read();\n    for(int i=0;i<=100;++i) for(int j=0;j<=100;++j)\n    {\n        int mn=0;\n        for(int k=1;k<=A;++k) for(int l=1;l<=B;++l) mn=max(mn,d[k][l]-k*i-l*j);\n        e[++m]=(edge){i+1,202-j,mn};\n        for(int k=1;k<=A;++k) for(int l=1;l<=B;++l) if(k*i+j*l+mn==d[k][l]) b[k][l]=1;\n    }\n    for(int i=1;i<=A;++i) for(int j=1;j<=B;++j) if(!b[i][j]) return 0*puts(\"Impossible\");\n    printf(\"Possible\\n%d %d\\n\",202,m+200);\n    for(int i=1;i<=100;++i) printf(\"%d %d X\\n\",i,i+1),printf(\"%d %d Y\\n\",i+101,i+102);\n    for(int i=1;i<=m;++i) printf(\"%d %d %d\\n\",e[i].x,e[i].y,e[i].w);\n    puts(\"1 202\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int A,B;cin>>A>>B;\n  vector<vll> d(A,vll(B));\n  repeat(i,A){\n    repeat(j,B){\n      cin>>d[i][j];\n    }\n  }\n  vector<vll> f(110,vll(110,0));\n  repeat(a,101){\n    repeat(b,101){\n      repeat(x,A){\n        repeat(y,B){\n          f[a][b]=max(f[a][b],d[x][y]-a*(x+1)-b*(y+1));\n        }\n      }\n    }\n  }\n  vector<vll> D(A,vll(B,INF));\n  bool isok=true;\n  repeat(x,A){\n    repeat(y,B){\n      repeat(a,101){\n        repeat(b,101){\n          D[x][y]=min(D[x][y],a*(x+1)+b*(y+1)+f[a][b]);\n        }\n      }\n      isok &= D[x][y]==d[x][y];\n    }\n  }\n  if(!isok){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  cout << 202 << \" \" << 200+101*101 << endl;\n  repeat(i,100){\n    cout << i+1 << \" \" << i+2 << \" x\" << endl;\n  }\n  repeat(i,100){\n    cout << i+102 << \" \" << i+103 << \" y\" << endl;\n  }\n  repeat(i,101){\n    repeat(j,101){\n      cout << i+1 << \" \" << 202-j << \" \"<< f[i][j] << endl;\n    }\n  }\n  cout << \"1 202\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INL inline\n#define REG register\n#define DB double\n#define LDB long double\n#define ULL unsigned long long\n#define LL long long\n\n#define RPT(i,x,y) for (REG int i=(x);i<(y);i++)\n#define DRPT(i,x,y) for (REG int i=(x);i>(y);i--)\n#define MST(a,b) memset((a),(b),sizeof(a))\n#define MRK() cout<<\"Mark\"<<endl; \n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define LINK(i,graph,pos) for (REG int i=graph.head[pos];i;i=graph.next[i])\n\n#define MAXN 10000\n#define MAXM 10000\n#define MOD 998244353\n#define INF 0x3f3f3f3f\n#define LLINF 0x3f3f3f3f3f3f3f3f\n#define EPS 1e-5\n\n#define _ 0\nusing namespace std;\n\n\n\nint n,m;\nint d[12][12];\nint dd[12][12];\nint c[110][110]; \nset <int> st;\n\nint main()\n{\n\tcin>>n>>m;\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tscanf(\"%d\",&d[i][j]);\n\tMST(dd,INF);\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tc[i][j]=max(c[i][j],d[ii][jj]-i*ii-j*jj);\n\tRPT(i,0,3)\n\t\tRPT(j,0,3)\n\t\t\tRPT(ii,1,n+1)\n\t\t\t\tRPT(jj,1,m+1)\n\t\t\t\t\tdd[ii][jj]=min(dd[ii][jj],jj*j+ii*i+c[i][j]);\n\tRPT(i,1,n+1)\n\t\tRPT(j,1,m+1)\n\t\t\tif (dd[i][j]!=d[i][j])\n\t\t\t{\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<202<<' '<<200+101*101<<endl;\n\tRPT(i,1,101)\n\t\tcout<<i<<' '<<i+1<<' '<<'X'<<endl;\n\tRPT(i,102,202)\n\t\tcout<<i+1<<' '<<i<<' '<<'Y'<<endl;\n\tRPT(i,0,101)\n\t\tRPT(j,0,101)\n\t\t\tcout<<i+1<<' '<<j+1+101<<' '<<c[i][j]<<endl;\n\treturn ~~(0^_^0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint m[15][15];\nvoid no()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\ntypedef pair<int, int>pii;\ntypedef pair<pii, int>pi3;\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tfor (int i = 1; i <= mx; i++)for (int j = 1; j <= my; j++)scanf(\"%d\", &m[i][j]);\n\tset<pi3>se;\n\tfor (int i = 1; i <= mx; i++)\n\t{\n\t\tfor (int j = 1; j <= my; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= 100; k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l <= 100; l++)\n\t\t\t\t{\n\t\t\t\t\tint c = m[i][j] - k*i - l*j;\n\t\t\t\t\tif (c < 0)continue;\n\t\t\t\t\tbool f = true;\n\t\t\t\t\tfor (int p = 1; p <= mx; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int q = 1; q <= my; q++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (c + k*p + l*q < m[p][q])f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (f)\n\t\t\t\t\t{\n\t\t\t\t\t\tse.insert(make_pair(make_pair(k, l), c));\n\t\t\t\t\t\tgoto l01;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tl01:;\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 222, 220 + se.size());\n\tfor (int i = 1; i < 111; i++)printf(\"%d %d X\\n\", i, i + 1);\n\tfor (int i = 112; i < 222; i++)printf(\"%d %d Y\\n\", i, i + 1);\n\tset<pi3>::iterator it = se.begin();\n\tfor (;;)\n\t{\n\t\tif (it == se.end())break;\n\t\tpi3 z = *it;\n\t\tit++;\n\t\tprintf(\"%d %d %d\\n\", 1 + z.first.first, 222 - z.first.second, z.second);\n\t}\n\tprintf(\"%d %d\\n\", 1, 222);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e6 * 2 + 10, INF = 1e9 * 1e9 + 10;\n\nll grid[302][302], mnx[302][302], mny[302][302];\n\nint main()\n{\n\tfastInp;\n\n\tll a, b;\n\tcin >> a >> b;\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) cin >> grid[i][j];\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll vl = 0, vl2 = 0;\n\t\t\tif (i > 0) vl = grid[i - 1][j];\n\t\t\tif (j > 0) vl2 = grid[i][j - 1];\n\n\t\t\tif (grid[i][j] < vl || grid[i][j] < vl2) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = abs(grid[i - 1][j] - grid[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = abs(grid[i][j - 1] - grid[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = a - 1; i >= 0; i--) {\n\t\tfor (int j = b - 1; j >= 0; j--) {\n\t\t\tif (i > 0) {\n\t\t\t\tmnx[i - 1][j] = max(mnx[i - 1][j], mnx[i][j]);\n\t\t\t\t//mny[i - 1][j] = max(mny[i - 1][j], mny[i][j]);\n\t\t\t}\n\t\t\tif (j > 0) {\n\t\t\t\tmny[i][j - 1] = max(mny[i][j - 1], mny[i][j]);\n\t\t\t\t//mnx[i][j - 1] = max(mnx[i][j - 1], mnx[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll m = 0, unus = 2, prv = 1;\n\tvector<tuple<ll, ll, string>> edges;\n\tfor (int i = 0; i < a; i++) {\n\t\tedges.push_back({ prv, unus, \"X\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tprv = unus;\n\tunus++;\n\tfor (int i = 0; i < b; i++) {\n\t\tedges.push_back({ prv, unus, \"Y\" });\n\t\tprv = unus;\n\t\tunus++;\n\t}\n\n\tedges.push_back({ prv, 300, \"0\" });\n\n\tfor (int i = 0; i < a; i++) {\n\t\tfor (int j = 0; j < b; j++) {\n\t\t\tll c = 0;\n\t\t\tfor (int t = 0; t < a; t++) {\n\t\t\t\tfor (int k = 0; k < b; k++) {\n\t\t\t\t\tc = max(c, grid[t][k] - (t + 1) * (i + 1) + (k + 1) * (j + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tedges.push_back({ i + 2, unus - (j + 2), to_string(c) });\n\t\t}\n\t}\n\n\n\tcout << \"Possible\\n\";\n\tcout << 300 << \" \" << edges.size() << \"\\n\";\n\n\tfor (auto cur : edges) {\n\t\tcout << get<0>(cur) << \" \" << get<1>(cur) << \" \" << get<2>(cur) << \"\\n\";\n\t}\n\n\tcout << 1 << \" \" << 300 << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int V = 204, src = V - 2, snk = V - 1;\n\nint X(int v) {\n    return v;\n}\nint Y(int v) {\n    return 101 + v;\n}\n\nint A, B;\nint D[12][12];\nvector<pii> adj[V];\n\nint main() {\n    scanf(\"%d %d\", &A, &B);\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    adj[src].push_back(pii(X(0), 0));\n    adj[Y(0)].push_back(pii(snk, 0));\n\n    for(int i = 1; i <= A; i++) {\n        for(int j = 1; j <= B; j++) {\n\n            bool f = false;\n            for(int a = 0; a <= 100 / i; a++) {\n                for(int b = 0; b <= 100 / j; b++) {\n                    int c = D[i][j] - a * i - b * j;\n                    if(c < 0 || 100 < c) continue;\n\n                    bool ok = true;\n                    for(int x = 1; x <= A; x++) {\n                        for(int y = 1; y <= B; y++) {\n                            if(D[x][y] > a * x + b * y + c) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(ok) {\n                        adj[X(a)].push_back(pii(Y(b), c));\n                        f = true;\n                        break;\n                    }\n                }\n                if(f) break;\n            }\n\n            if(!f) {\n                printf(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"Possible\\n\");\n\n    printf(\"%d\\n\", V);\n    for(int u = 0; u < V; u++) {\n        sort(adj[u].begin(), adj[u].end());\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i].first;\n            int w = adj[u][i].second;\n\n            if(i == 0 || adj[u][i - 1] != adj[u][i]) printf(\"%d %d %d\\n\", u + 1, v + 1, w);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nll mx(const vector<vector<ll>>& v) {\n    ll res = 0;\n    each(vv, v) {\n        chmax(res, *max_element(all(vv)));\n    }\n    return res;\n}\nclass Graph {\n    struct Edge {\n        ll from, to;\n        string label;\n    };\n    ll n;\n    set<P> s;\n    vector<Edge> edges;\npublic:\n    Graph(ll n) : n(n) {}\n    void add(ll from, ll to, string label) {\n        if (s.count({from, to}) > 0) return;\n        s.insert({from, to});\n        edges.pb({from, to, label});\n    }\n    void addX(ll from, ll to) {\n        add(from, to, \"X\");\n    }\n    void addY(ll from, ll to) {\n        add(from, to, \"Y\");\n    }\n    void add(ll from, ll to, ll cost) {\n        add(from, to, to_string(cost));\n    }\n    void output(ll s, ll t) {\n        assert(n <= 300);\n        if (n <= 300) {\n            cout << \"Possible\" << endl;\n            cout << n << \" \" << edges.size() << endl;\n            each(e, edges) {\n                cout << e.from+1 << \" \" << e.to+1 << \" \" << e.label << endl;\n            }\n            cout << s << \" \" << t << endl;\n        }\n        else {\n            cout << \"Impossible\" << endl;\n        }\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll A, B; cin >> A >> B;\n    vector<vector<ll>> d(A, vector<ll>(B)); cin >> d;\n    vector<vector<ll>> X(A, vector<ll>(B, -1));\n    vector<vector<ll>> Y(A, vector<ll>(B, -1));\n    vector<vector<ll>> Z(A, vector<ll>(B, -1));\n    rep(a, A) rep(b, B) {\n        bool is_find = false;\n        rep(x, 101) {\n            if (x * a > d[a][b]) break;\n            rep(y, 101) {\n                ll z = d[a][b] - (x * a + y * b);\n                if (z < 0) break;\n                if (z > 100) continue;\n                bool f = true;\n                rep(aa, A) rep(bb, B) {\n                    if (aa * x + bb * y + z < d[aa][bb]) {\n                        f = false;\n                        break;\n                    }\n                }\n                if (f) {\n                    X[a][b] = x;\n                    Y[a][b] = y;\n                    Z[a][b] = z;\n                    is_find = true;\n                    break;\n                }\n            }\n            if (is_find) break;\n        }\n        if (!is_find) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    // assert(false);\n    ll w = mx(X)+1;\n    ll h = mx(Y)+1;\n    // if (w * h > 300) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    ll V = 0;\n    vector<ll> xid(101), yid(101);\n    rep(i, 101) xid[i] = V++;\n    rep(i, 101) yid[i] = V++;\n    ll s = V++, t = V++;\n    Graph G(V);\n    G.add(s, xid[0], 0);\n    rep(i, 100) G.addX(xid[i], xid[i+1]);\n    rep(i, 100) G.addY(yid[i+1], yid[i]);\n    rep(a, A) rep(b, B) {\n        G.add(xid[X[a][b]], yid[Y[a][b]], Z[a][b]);\n    }\n    G.add(yid[0], t, 0);\n    G.output(s, t);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int inf=1000000000;\nstruct edge{\n\tint t,next,v;\n}g[210001];\nstruct data{\n\tint a,b,v;\n}e[210001];\nint te,i,j,k,n,m,a[21][21],h[411],tot,dis[411],q[210001],v[411],num,s,t,w,tx,ty,fl;\nvoid addedge(int x,int y,int z){\n\t//printf(\"%d %d %d\\n\",x,y,z);\n\tg[++tot].t=y;g[tot].next=h[x];h[x]=tot;g[tot].v=z;\n\te[++te].a=x;e[te].b=y;e[te].v=z;\n}\nint gv(int x){\n\tif (x>=0) return x;\n\tif (x==-1) return tx;else return ty;\n}\nint work(int x,int y){\n\tint i,j,res=0;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) res=max(res,a[i][j]-i*x-j*y);\n\treturn res;\n}\nint spfa(){\n\tint i,j,k,l,r;\n\tmemset(v,0,sizeof(v));\n\tfor (i=1;i<=num;i++) dis[i]=inf;\n\tl=0;r=1;q[1]=1;dis[1]=0;\n\twhile (l<r){\n\t\tj=q[++l];v[j]=0;\n\t\tfor (i=h[j];i;i=g[i].next)\n\t\t if (dis[g[i].t]>dis[j]+gv(g[i].v)){\n\t\t \tdis[g[i].t]=dis[j]+gv(g[i].v);\n\t\t \tif (!v[g[i].t]) v[g[i].t]=1,q[++r]=g[i].t;\n\t\t }\n\t}\n\treturn dis[num];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);w=17;\n\tfor (i=1;i<=n;i++)\n\t for (j=1;j<=m;j++) scanf(\"%d\",&a[i][j]);\n\tnum=w*w+1;s=1;t=num;tot=te=0;memset(h,0,sizeof(h));\n\tfor (i=1;i<=w;i++)\n\t for (j=1;j<=w;j++){\n\t \tk=(i-1)*w+j;\n\t \tif (i<w) addedge(k,k+w,-1);\n\t \tif (j<w) addedge(k,k+1,-2);\n\t \taddedge(k,t,work(i-1,j-1));\n\t }\n\tfor (i=fl=1;fl&&i<=n;i++)\n\t for (j=1;fl&&j<=m;j++){\n\t \ttx=i;ty=j;\n\t\tk=spfa();\n\t\tif (k!=a[i][j]) fl=0;//,printf(\"** %d %d %d\\n\",i,j,k);\n\t }\n\tif (!fl){\n\t\tputs(\"Impossible\");\n\t}else{\n\t\tputs(\"Possible\");\n\t\tprintf(\"%d %d\\n\",num,te);\n\t\tfor (i=1;i<=te;i++){\n\t\t\tprintf(\"%d %d \",e[i].a,e[i].b);\n\t\t\tif (e[i].v==-1) printf(\"X\\n\");\n\t\t\tif (e[i].v==-2) printf(\"Y\\n\");\n\t\t\tif (e[i].v>=0) printf(\"%d\\n\",e[i].v);\n\t\t}\n\t\tprintf(\"%d %d\\n\",1,num);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Vector.Unboxed as VU\n-- import qualified Data.Vector.Unboxed.Mutable as VUM\n-- import Control.Monad\n-- import Control.Monad.ST\n-- import Debug.Trace\ntrace _ = id\n\ndata Plane = Plane {p_rx::Int, p_ry::Int, p_z0::Int}\n           deriving (Eq, Ord, Show)\n\nsolve :: Int -> Int -> [[Int]] ->\n         Maybe (Int, Int, [(Int, Int, String)], Int, Int)\nsolve a b d | possible = Just build\n            | otherwise = Nothing\n  where\n    vd = VU.fromListN (a*b) (concat d)\n    enc x y = (x-1) * b + (y-1)\n    valyx x y | trace (\"valyx\" ++ show (x,y)) False = undefined\n    valyx x y = vd VU.! (enc (min x a) (min y b))\n    tri' = [ptPlane x y | x <- [1..a], y <- [1..b]]\n    ptPlane x y = catMaybes [mkPlane x y dx dy | dx <- [-1,1], dy <- [-1,1]]\n    mkPlane x y dx dy | trace (\"mkPlane(in) \" ++ show (x,y,dx,dy)) False\n      = undefined\n    mkPlane x y dx dy = trace (\"mkPlane \" ++ show (x,y,dx,dy,ddd)) ddd\n      where ddd = mkPlane' x y dx dy\n    mkPlane' x y dx dy\n      | outRangeX x || outRangeX (x+dx) || outRangeY y || outRangeY (y+dy)\n        || rx < 0 || ry < 0 || z0 < 0 || not (checkConvex rx ry z0)\n      = Nothing\n      | otherwise\n      = Just (Plane rx ry z0) \n      where v0 = valyx x y\n            rx = (valyx (x+dx) y - v0) `div` dx\n            ry = (valyx x (y+dy) - v0) `div` dy\n            z0 = v0 - rx*x - ry*y\n            outRangeX x = x < 1 || (a+1) < x\n            outRangeY y = y < 1 || (b+1) < y\n    xyPair = [(x,y) | x <- [1..a], y <- [1..b]]\n    checkConvex rx ry z0\n      = all (\\(x,y) -> rx*x + ry*y + z0 >= valyx x y) xyPair\n\n    possible = all (not . null) tri'\n    tri = nub $ map minimum tri'\n    yMax = maximum $ map p_ry tri\n    safeMax [] = 0\n    safeMax xs = maximum xs\n    lxMax = [safeMax $ map p_rx $ filter ((== ry) . p_ry) tri\n            | ry <- [0..yMax]]\n    board = [(u+1,v+1,c) | (u,v,c) <- boardM]\n    boardM = [connY y | y <- [0..yMax-1]]\n             ++ [connX y x | y <- [0..yMax-1], x <- [0 .. (lxMax !! y) - 1]]\n             ++ [connP p | p <- tri]\n    connY y = (bEncY y, bEncY (y+1), \"Y\")\n    connX y x = (bEncX y x, bEncX y (x+1), \"X\")\n    connP (Plane rx ry z0) = (bEncX ry rx, bEncT, show z0)\n    bEncY y = y\n    bEncX y 0 = bEncY y\n    bEncX y x = (yMax+1) + (accXMax !! y) + (x-1)\n    bEncT = (yMax+1) + (accXMax !! (yMax+1)) \n    accXMax = scanl' (+) 0 lxMax\n    build = (bEncT + 1, length board, board, 1, bEncT + 1)\n\nreadBInt :: B.ByteString -> Int\nreadBInt = fst . fromJust . B.readInt\n\ntmain :: B.ByteString -> Maybe (Int, Int, [(Int, Int, String)], Int, Int)\ntmain cont =\n  let remLines0 = map B.words (B.lines cont)\n      [bs_a,bs_b]:remLines1 = remLines0\n      a = readBInt bs_a\n      b = readBInt bs_b\n      d = map (map readBInt) remLines1\n  in solve a b d\n\noutAnswer :: Maybe (Int, Int, [(Int, Int, String)], Int, Int) -> IO ()\noutAnswer Nothing               = putStrLn \"Impossible\"\noutAnswer (Just (n,m,uvcs,s,t)) = do\n  putStrLn \"Possible\"\n  putStrLn $ unwords $ map show [n,m]\n  putStr $ unlines $ map (\\(u,v,s) -> unwords [show u, show v, s]) uvcs\n  putStrLn $ unwords $ map show [s,t]\n\nmain :: IO ()\nmain = outAnswer . tmain =<< B.getContents\n\ninp1 = \"2 3\\n1 2 2\\n1 2 3\\n\"\ninp2 = \"1 3\\n100 50 1\\n\"\ntv1 = tmain $ B.pack inp1\ntv2 = tmain $ B.pack inp2\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Vector.Unboxed as VU\n-- import qualified Data.Vector.Unboxed.Mutable as VUM\n-- import Control.Monad\n-- import Control.Monad.ST\n-- import Debug.Trace\ntrace _ = id\n\ndata Plane = Plane {p_ry::Int, p_rx::Int, p_z0::Int}\n           deriving (Eq, Ord, Show)\n\nsolve :: Int -> Int -> [[Int]] ->\n         Maybe (Int, Int, [(Int, Int, String)], Int, Int)\nsolve a b d | possible = Just build\n            | otherwise = Nothing\n  where\n    vd = VU.fromListN (a*b) (concat d)\n    enc y x = (y-1) * b + (x-1)\n    valyx y x | trace (\"valyx\" ++ show (y,x)) False = undefined\n    valyx y x = vd VU.! (enc (min y a) (min x b))\n    tri' = [ptPlane y x | y <- [1..a], x <- [1..b]]\n    ptPlane y x = catMaybes [mkPlane y x dy dx | dy <- [-1,1], dx <- [-1,1]]\n    mkPlane y x dy dx | trace (\"mkPlane(in) \" ++ show (y,x,dy,dx)) False\n      = undefined\n    mkPlane y x dy dx = trace (\"mkPlane \" ++ show (y,x,dy,dx,a)) a\n      where a = mkPlane' y x dy dx\n    mkPlane' y x dy dx\n      | outRangeY y || outRangeY (y+dy) || outRangeX x || outRangeX (x+dx)\n        || rx < 0 || ry < 0 || z0 < 0 || not (checkConvex ry rx z0)\n      = Nothing\n      | otherwise\n      = Just (Plane ry rx z0) \n      where v0 = valyx y x\n            ry = (valyx (y+dy) x - v0) `div` dy\n            rx = (valyx y (x+dx) - v0) `div` dx\n            z0 = v0 - ry*y - rx*x\n            outRangeY y = y < 1 || (a+1) < y\n            outRangeX x = x < 1 || (b+1) < x\n    yxPair = [(y,x) | y <- [1..a], x <- [1..b]]\n    checkConvex ry rx z0\n      = all (\\(y,x) -> ry*y + rx*x + z0 >= valyx y x) yxPair\n\n    possible = all (not . null) tri'\n    tri = nub $ map minimum tri'\n    yMax = maximum $ map p_ry tri\n    safeMax [] = 0\n    safeMax xs = maximum xs\n    lxMax = [safeMax $ map p_rx $ filter ((== ry) . p_ry) tri\n            | ry <- [0..yMax]]\n    board = [(u+1,v+1,c) | (u,v,c) <- boardM]\n    boardM = [connY y | y <- [0..yMax-1]]\n             ++ [connX y x | y <- [0..yMax-1], x <- [0 .. (lxMax !! y) - 1]]\n             ++ [connP p | p <- tri]\n    connY y = (bEncY y, bEncY (y+1), \"Y\")\n    connX y x = (bEncX y x, bEncX y (x+1), \"X\")\n    connP (Plane ry rx z0) = (bEncX ry rx, bEncT, show z0)\n    bEncY y = y\n    bEncX y 0 = bEncY y\n    bEncX y x = (yMax+1) + (accXMax !! y) + (x-1)\n    bEncT = (yMax+1) + (accXMax !! (yMax+1)) \n    accXMax = scanl' (+) 0 lxMax\n    build = (bEncT + 1, length board, board, 1, bEncT + 1)\n\nreadBInt :: B.ByteString -> Int\nreadBInt = fst . fromJust . B.readInt\n\ntmain :: B.ByteString -> Maybe (Int, Int, [(Int, Int, String)], Int, Int)\ntmain cont =\n  let remLines0 = map B.words (B.lines cont)\n      [bs_a,bs_b]:remLines1 = remLines0\n      a = readBInt bs_a\n      b = readBInt bs_b\n      d = map (map readBInt) remLines1\n  in solve a b d\n\noutAnswer :: Maybe (Int, Int, [(Int, Int, String)], Int, Int) -> IO ()\noutAnswer Nothing               = putStrLn \"Impossible\"\noutAnswer (Just (n,m,uvcs,s,t)) = do\n  putStrLn \"Possible\"\n  putStrLn $ unwords $ map show [n,m]\n  putStr $ unlines $ map (\\(u,v,s) -> unwords [show u, show v, s]) uvcs\n  putStrLn $ unwords $ map show [s,t]\n\nmain :: IO ()\nmain = outAnswer . tmain =<< B.getContents\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE TupleSections #-}\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Vector.Unboxed as VU\n-- import qualified Data.Vector.Unboxed.Mutable as VUM\n-- import Control.Monad\n-- import Control.Monad.ST\n-- import Debug.Trace\ntrace _ = id\n\ndata Plane = Plane {p_rx::Int, p_ry::Int, p_z0::Int}\n           deriving (Eq, Ord, Show)\n\nsolve :: Int -> Int -> [[Int]] ->\n         Maybe (Int, Int, [(Int, Int, String)], Int, Int)\nsolve a b d | possible = Just build\n            | otherwise = Nothing\n  where\n    vd = VU.fromListN (a*b) (concat d)\n    enc x y = (x-1) * b + (y-1)\n    valyx x y | trace (\"valyx\" ++ show (x,y)) False = undefined\n    valyx x y | x <= 0 || y <= 0 = 0\n              | otherwise      = vd VU.! (enc x y)\n    tri' = [ptPlane x y | x <- [1..a], y <- [1..b]]\n    ptPlane x y = [Plane rx ry z0\n                  | rx <- cands_rx, ry <- cands_ry,\n                    let z0 = calc_z rx ry, checkConvex rx ry z0]\n      where\n      calc_z rx ry = valyx x y - rx*x - ry*y\n      cands_rx\n        | x == a    = [0]\n        | otherwise = [valyx (x+1) y - valyx x y .. valyx x y - valyx (x-1) y]\n      cands_ry\n        | y == b    = [0]\n        | otherwise = [valyx x (y+1) - valyx x y .. valyx x y - valyx x (y-1)]\n    xyPair = [(x,y) | x <- [1..a], y <- [1..b]]\n    checkConvex rx ry z0\n      = all (\\(x,y) -> rx*x + ry*y + z0 >= valyx x y) xyPair\n\n    possible = all (not . null) tri'\n\n    tri = trace (\"tri \" ++ show tri0) tri0\n    tri0 = nub $ map head tri'\n\n    yMax = maximum $ map p_ry tri\n    safeMax [] = 0\n    safeMax xs = maximum xs\n    lxMax = [safeMax $ map p_rx $ filter ((== ry) . p_ry) tri\n            | ry <- [0..yMax]]\n    board = [(u+1,v+1,c) | (u,v,c) <- boardM]\n    boardM = [connY y | y <- [0..yMax-1]]\n             ++ [connX y x | y <- [0..yMax], x <- [0 .. (lxMax !! y) - 1]]\n             ++ [connP p | p <- tri]\n    connY y = (bEncY y, bEncY (y+1), \"Y\")\n    connX y x = (bEncX y x, bEncX y (x+1), \"X\")\n    connP (Plane rx ry z0) = (bEncX ry rx, bEncT, show z0)\n    bEncY y = y\n    bEncX y 0 = bEncY y\n    bEncX y x = (yMax+1) + (accXMax !! y) + (x-1)\n    bEncT = (yMax+1) + (accXMax !! (yMax+1)) \n    accXMax = scanl' (+) 0 lxMax\n    build = (bEncT + 1, length board, board, 1, bEncT + 1)\n\nreadBInt :: B.ByteString -> Int\nreadBInt = fst . fromJust . B.readInt\n\ntmain :: B.ByteString -> Maybe (Int, Int, [(Int, Int, String)], Int, Int)\ntmain cont =\n  let remLines0 = map B.words (B.lines cont)\n      [bs_a,bs_b]:remLines1 = remLines0\n      a = readBInt bs_a\n      b = readBInt bs_b\n      d = map (map readBInt) remLines1\n  in solve a b d\n\noutAnswer :: Maybe (Int, Int, [(Int, Int, String)], Int, Int) -> IO ()\noutAnswer Nothing               = putStrLn \"Impossible\"\noutAnswer (Just (n,m,uvcs,s,t)) = do\n  putStrLn \"Possible\"\n  putStrLn $ unwords $ map show [n,m]\n  putStr $ unlines $ map (\\(u,v,s) -> unwords [show u, show v, s]) uvcs\n  putStrLn $ unwords $ map show [s,t]\n\nmain :: IO ()\nmain = outAnswer . tmain =<< B.getContents\n"
  },
  {
    "language": "Text",
    "code": "Impossible\n"
  },
  {
    "language": "Text",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3;\nint A,B,b[M+1][M+1];\nvvi a;\n\nint main(){\n\tcin>>A>>B;\n\ta=vvi(A+1,vi(B+1));\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++) cin>>a[i][j];\n\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++){\n\t\tint res=0;\n\t\tfor(int k=1;k<=A;k++) for(int l=1;l<=B;l++) res=max(res,a[k][l]-k*i-l*j);\n\t\tb[i][j]=res;\n\t}\n\tbool flag=1;\n\tfor(int i=1;i<=A;i++) for(int j=1;j<=B;j++){\n\t\tbool BB=0;\n\t\tfor(int k=0;k<=M;k++) for(int l=0;l<=M;l++){\n\t\t\tassert(b[k][l]+k*i+l*j<a[i][j]);\n\t\t\tif(b[k][l]+k*i+l*j==a[i][j]) BB=1;\n\t\t}\n\t\tflag&=BB;\n\t}\n\tif(flag){\n\t\tcout<<\"Possible\"<<endl;\n\t\tcout<<2*M+2<<' '<<2*M+(M+1)*(M+1)<<endl;\n\t\tfor(int i=1;i<=M;i++) cout<<i<<' '<<i+1<<\" X\"<<endl;\n\t\tfor(int i=M+2;i<2*M+2;i++) cout<<i<<' '<<i+1<<\" Y\"<<endl;\n\t\tfor(int i=0;i<=M;i++) for(int j=0;j<=M;j++) cout<<i+1<<' '<<2*M+2-j<<' '<<b[i][j]<<endl;\n\t\tcout<<1<<' '<<2*M+2<<endl;\n\t}\n\telse cout<<\"Impossible\"<<endl;\n}"
  },
  {
    "language": "Text",
    "code": "2 3\n1 2 2\n1 2 3\nPossible\n8 23\n1 2 X\n2 3 X\n3 4 X\n4 5 0\n5 6 Y\n6 7 Y\n7 8 Y\n1 8 3\n1 7 0\n1 6 0\n1 5 0\n2 8 1\n2 7 0\n2 6 0\n2 5 0\n3 8 0\n3 7 0\n3 6 0\n3 5 0\n4 8 0\n4 7 0\n4 6 0\n4 5 0\n1 8"
  },
  {
    "language": "Text",
    "code": "Impossible"
  },
  {
    "language": "Text",
    "code": "Impossible\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll xnum[200][200], ynum[200][200];\nsll bridge[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\t\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (i < h) {\n\t\t\t\txnum[i][j] = table[i + 1][j] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, xnum[i][j]);\n\t\t\t\tif (i > 1 && xnum[i - 1][j] < xnum[i][j]) goto fail;\n\t\t\t}\n\t\t\tif (j < w) {\n\t\t\t\tynum[i][j] = table[i][j + 1] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, ynum[i][j]);\n\t\t\t\tif (j > 1 && ynum[i][j - 1] < ynum[i][j]) goto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tbridge[i][j] = BIG;\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tsll x = xnum[i][j];\n\t\t\tsll y = ynum[i][j];\n\t\t\tbridge[x][y] = table[i][j] - i * x - j * y;\n\t\t\tif (bridge[x][y] < 0) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tm = 200;\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] < BIG) m++;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll bridge[200][200];\nsll mydist[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tmydist[i][j] = BIG;\n\t\t}\n\t}\n\n\tm = 200;\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tsll x = -1;\n\t\t\t\n\t\t\tfor (ki = 1; ki <= h; ki++) {\n\t\t\t\tfor (li = 1; li <= w; li++) {\n\t\t\t\t\tx = smax(x, table[ki][li] - ki * i - li * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tbridge[i][j] = BIG;\n\t\t\t} else {\n\t\t\t\tbridge[i][j] = x;\n\t\t\t\tm++;\n\n\t\t\t\tfor (ki = 1; ki <= h; ki++) {\n\t\t\t\t\tfor (li = 1; li <= w; li++) {\n\t\t\t\t\t\tmydist[ki][li] = smin(mydist[ki][li], bridge[i][j] + ki * i + li * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (mydist[i][j] != table[i][j]) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll xnum[200][200], ynum[200][200];\nsll bridge[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\t\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (i < h) {\n\t\t\t\txnum[i][j] = table[i + 1][j] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, xnum[i][j]);\n\t\t\t\tif ((i > 1 && xnum[i - 1][j] < xnum[i][j]) || xnum[i][j] < 0) goto fail;\n\t\t\t}\n\t\t\tif (j < w) {\n\t\t\t\tynum[i][j] = table[i][j + 1] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, ynum[i][j]);\n\t\t\t\tif ((j > 1 && ynum[i][j - 1] < ynum[i][j]) || ynum[i][j] < 0) goto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tbridge[i][j] = BIG;\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tsll x = xnum[i][j];\n\t\t\tsll y = ynum[i][j];\n\t\t\tbridge[x][y] = table[i][j] - i * x - j * y;\n\t\t\tif (bridge[x][y] < 0) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tm = 200;\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] < BIG) m++;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint main(){\n\tint A, B, i, j, x, y, N = 100;\n\tscanf(\"%d%d\", &A, &B);\n\tint **d = (int **)malloc(sizeof(int *) * (A + 1));\n\tint **D = (int **)malloc(sizeof(int *) * (A + 1));\n\tfor(x = 1; x <= A; x++){\n\t\td[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tD[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tscanf(\"%d\", &d[x][y]);\n\t\t\tD[x][y] = inf;\n\t\t}\n\t}\n\tint **f = (int **)malloc(sizeof(int *) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tf[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tf[i][j] = 0;\n\t\t\tfor(x = 1; x <= A; x++){\n\t\t\t\tfor(y = 1; y <= B; y++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - (x * i + y * j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(x = 1; x <= A; x++){\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tfor(i = 0; i <= N; i++){\n\t\t\t\tfor(j = 0; j <= N; j++){\n\t\t\t\t\tD[x][y] = min(D[x][y], x * i + y * j + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[x][y] != D[x][y]){\n//\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 2 * (N + 1), 2 * N + (N + 1) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\tprintf(\"%d %d Y\\n\", N + 1 + i, N + 2 + i);\n\t}\n\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 2 * N + 2 - j, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 0, 2 * (N + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll xnum[200][200], ynum[200][200];\nsll bridge[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\t\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (i < h) {\n\t\t\t\txnum[i][j] = table[i + 1][j] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, xnum[i][j]);\n\t\t\t\tif (i > 1 && xnum[i - 1][j] < xnum[i][j]) goto fail;\n\t\t\t}\n\t\t\tif (j < w) {\n\t\t\t\tynum[i][j] = table[i][j + 1] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, ynum[i][j]);\n\t\t\t\tif (j > 1 && ynum[i][j - 1] < ynum[i][j]) goto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tbridge[i][j] = BIG;\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tsll x = xnum[i][j];\n\t\t\tsll y = ynum[i][j];\n\t\t\tbridge[x][y] = table[i][j] - i * x - j * y;\n\t\t\tif (bridge[x][y] < 0) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tm = 200;\n\tfor (i = 0; i <= h; i++) {\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tif (bridge[i][j] < BIG) m++;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= h; i++) {\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll xnum[200][200], ynum[200][200];\nsll bridge[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\t\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (i < h) {\n\t\t\t\txnum[i][j] = table[i + 1][j] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, xnum[i][j]);\n\t\t\t\tif (i > 1 && xnum[i - 1][j] < xnum[i][j] || xnum[i][j] < 0) goto fail;\n\t\t\t}\n\t\t\tif (j < w) {\n\t\t\t\tynum[i][j] = table[i][j + 1] - table[i][j];\n\t\t\t\t// printf(\"%lld:%lld: %lld\\n\", i, j, ynum[i][j]);\n\t\t\t\tif (j > 1 && ynum[i][j - 1] < ynum[i][j] || ynum[i][j] < 0) goto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tbridge[i][j] = BIG;\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tsll x = xnum[i][j];\n\t\t\tsll y = ynum[i][j];\n\t\t\tbridge[x][y] = table[i][j] - i * x - j * y;\n\t\t\tif (bridge[x][y] < 0) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tm = 200;\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] < BIG) m++;\n\t\t}\n\t}\n\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint main(){\n\tint A, B, i, j, x, y, N = 100;\n\tscanf(\"%d%d\", &A, &B);\n\tint **d = (int **)malloc(sizeof(int *) * (A + 1));\n\tint **D = (int **)malloc(sizeof(int *) * (A + 1));\n\tfor(x = 1; x <= A; x++){\n\t\td[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tD[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tscanf(\"%d\", &d[x][y]);\n\t\t\tD[x][y] = inf;\n\t\t}\n\t}\n\tint **f = (int **)malloc(sizeof(int *) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tf[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tf[i][j] = 0;\n\t\t\tfor(x = 1; x <= A; x++){\n\t\t\t\tfor(y = 1; y <= B; y++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - (x * i + y * j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(x = 1; x <= A; x++){\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tfor(i = 0; i <= N; i++){\n\t\t\t\tfor(j = 0; j <= N; j++){\n\t\t\t\t\tD[x][y] = min(D[x][y], x * i + y * j + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[x][y] != D[x][y]){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 2 * (N + 1), 2 * N + (N + 1) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\tprintf(\"%d %d Y\\n\", N + 1 + i, N + 2 + i);\n\t}\n\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 2 * N + 2 - j, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 0, 2 * (N + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define inf (int)(1e9)\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint main(){\n\tint A, B, i, j, x, y, N = 100;\n\tscanf(\"%d%d\", &A, &B);\n\tint **d = (int **)malloc(sizeof(int *) * (A + 1));\n\tint **D = (int **)malloc(sizeof(int *) * (A + 1));\n\tfor(x = 1; x <= A; x++){\n\t\td[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tD[x] = (int *)malloc(sizeof(int) * (B + 1));\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tscanf(\"%d\", &d[x][y]);\n\t\t\tD[x][y] = inf;\n\t\t}\n\t}\n\tint **f = (int **)malloc(sizeof(int *) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tf[i] = (int *)malloc(sizeof(int) * (N + 1));\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tf[i][j] = 0;\n\t\t\tfor(x = 1; x <= A; x++){\n\t\t\t\tfor(y = 1; y <= B; y++){\n\t\t\t\t\tf[i][j] = max(f[i][j], d[x][y] - (x * i + y * j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(x = 1; x <= A; x++){\n\t\tfor(y = 1; y <= B; y++){\n\t\t\tfor(i = 0; i <= N; i++){\n\t\t\t\tfor(j = 0; j <= N; j++){\n\t\t\t\t\tD[x][y] = min(D[x][y], x * i + y * j + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[x][y] != D[x][y]){\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d %d\\n\", 2 * (N + 1), 2 * N + (N + 1) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tprintf(\"%d %d X\\n\", i, i + 1);\n\t\tprintf(\"%d %d Y\\n\", N + 1 + i, N + 2 + i);\n\t}\n\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tprintf(\"%d %d %d\\n\", i + 1, 2 * N + 2 - j, f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", 1, 2 * (N + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "Impossible#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\n// char s[N_MAX + 1];\nchar s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\nsll bridge[200][200];\nsll mydist[200][200];\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tmydist[i][j] = BIG;\n\t\t}\n\t}\n\n\tm = 200;\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tsll x = -1;\n\t\t\t\n\t\t\tfor (ki = 1; ki <= h; ki++) {\n\t\t\t\tfor (li = 1; li <= w; li++) {\n\t\t\t\t\tx = smax(x, table[ki][li] - ki * i - li * j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tbridge[i][j] = BIG;\n\t\t\t} else {\n\t\t\t\tbridge[i][j] = x;\n\t\t\t\tm++;\n\n\t\t\t\tfor (ki = 1; ki <= h; ki++) {\n\t\t\t\t\tfor (li = 1; li <= w; li++) {\n\t\t\t\t\t\tmydist[ki][li] = smin(mydist[ki][li], bridge[i][j] + ki * i + li * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= h; i++) {\n\t\tfor (j = 1; j <= w; j++) {\n\t\t\tif (mydist[i][j] != table[i][j]) goto fail;\n\t\t}\n\t}\n\n\tn = 202;\n\tputs(\"Possible\");\n\tprintf(\"%llu %llu\\n\", n, m);\n\tfor (i = 0; i < 100; i++) {\n\t\tprintf(\"%llu %llu X\\n\", i * 2 + 1, (i + 1) * 2 + 1);\n\t\tprintf(\"%llu %llu Y\\n\", (i + 1) * 2 + 1 + 1, i * 2 + 1 + 1);\n\t}\n\tfor (i = 0; i <= 100; i++) {\n\t\tfor (j = 0; j <= 100; j++) {\n\t\t\tif (bridge[i][j] == BIG) continue;\n\n\t\t\tprintf(\"%llu %llu %lld\\n\", i * 2 + 1, j * 2 + 1 + 1, bridge[i][j]);\n\t\t}\n\t}\n\tputs(\"1 2\");\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\tputs(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tb[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%lld\", &table[i + 1][j + 1]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//d[x][y]=min(c[i][j]+i*x+j*y);\n\t\tint[][] c = new int[101][101];\n\t\tfor (int x = 0; x < A; ++x) {\n\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\t\t\tc[i][j] = Math.max(c[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tfor (int x = 0; x < A; ++x) {\n\t\t\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\t\t\td_now[x][y] = Math.min(d_now[x][y], c[i][j] + (x + 1) * i + (y + 1) * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x < A; ++x) {\n\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\tif (d[x][y] != d_now[x][y]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (101 + 101 + 101 * 101 + 2));\n\t\tfor (int i = 1; i <= 101; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 202; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(s + \" \" + t);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                planes.add(new IntPair3(0, d[0][y + 1] - d[0][y], d[0][y]));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                planes.add(new IntPair3(d[x + 1][0] - d[x][0], 0, d[x][0]));\n            }\n        } else {\n            int cnt = 0;\n            boolean[][] ok = new boolean[a][b];\n            {\n                int dx = d[1][0] - d[0][0];\n                int dy = d[0][1] - d[0][0];\n                int c = d[0][0] - dx - dy;\n                ng |= c < 0;\n                var pl = new IntPair3(dx, dy, c);\n                planes.add(pl);\n                for (int xx = 0; xx < a; xx++) {\n                    for (int yy = 0; yy < b; yy++) {\n                        if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                            ok[xx][yy] = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            while (cnt < a * b) {\n                for (int x = 0; x < a; x++) {\n                    for (int y = 0; y < b; y++) {\n                        if (ok[x][y]) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        IntPair3 p1 = null, p2 = null;\n                        for (int dr = 0; dr < 8; dr++) {\n                            int nx = x + dx8[dr];\n                            int ny = y + dy8[dr];\n                            if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                            if (p1 == null) {\n                                p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                            } else {\n                                p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                break;\n                            }\n                        }\n                        if (p2 == null) continue;\n                        var pl = plane(p0, p1, p2);\n                        ng |= pl.trd < 0;\n                        planes.add(pl);\n                        for (int xx = 0; xx < a; xx++) {\n                            for (int yy = 0; yy < b; yy++) {\n                                if (ok[xx][yy]) continue;\n                                if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                    ok[xx][yy] = true;\n                                    cnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        var op = outerProduct(b, c);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= cc; cb /= cc; d /= cc;\n        if (cc > 0) {\n            ca *= -1; cb *= -1; d *= -1;\n        }\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//d[x][y]=min(c[i][j]+i*x+j*y);\n\t\tint[][] c = new int[101][101];\n\t\tfor (int x = 0; x < A; ++x) {\n\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\t\t\tc[i][j] = Math.max(c[i][j], d[x][y] - (x + 1) * i - (y + 1) * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tfor (int x = 0; x < A; ++x) {\n\t\t\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\t\t\td_now[x][y] = Math.min(d_now[x][y], c[i][j] + (x + 1) * i + (y + 1) * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x < A; ++x) {\n\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\tif (d[x][y] != d_now[x][y]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (100 + 100 + 101 * 101 + 2));\n\t\tfor (int i = 1; i <= 100; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 201; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(s + \" \" + t);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private void solve() throws IOException {\n        int a = nextInt();\n        int b = nextInt();\n        int[][] d = new int[a + 1][b + 1];\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                d[x][y] = nextInt();\n            }\n        }\n\n        int n = 3;\n        int[][] c = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                c[i][j] = 0;\n                for (int x = 1; x <= a; x++) {\n                    for (int y = 1; y <= b; y++) {\n                        c[i][j] = Math.max(c[i][j], d[x][y] - i * x - j * y);\n                    }\n                }\n            }\n        }\n\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                int r = Integer.MAX_VALUE;\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        r = Math.min(r, i * x + j * y + c[i][j]);\n                    }\n                }\n                if (r != d[x][y]) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n        out.println(\"Possible\");\n        out.println((2 * n) + \" \" + (2 * (n - 1) + n * n));\n        for (int i = 0; i < n - 1; i++) {\n            out.println((i + 1) + \" \" + (i + 2) + \" X\");\n            out.println((n + i + 1) + \" \" + (n + i + 2) + \" Y\");\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                out.println((i + 1) + \" \" + (n + j + 1) + \" \" + c[i][j]);\n            }\n        }\n        out.println(1 + \" \" + (n + 1));\n    }\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(tot+\" \"+Integer.toString(tot-2));\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int d[][] = new int[A][B];\n        for(int i=0;i<A;++i){\n            for(int j=0;j<B;++j){\n                d[i][j] = scan.nextInt();\n            }\n        }\n        int S=1;\n        int T=202;\n        //S+X, T-Y;\n        int[][] dis = new int[T+1][T+1];\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)dis[i][j]=-1;\n\n        for(int i=0;i<A;++i){\n            for(int j=B-2;j>=0;--j){\n                int x = d[i][j+1]-d[i][j];\n                if(j>0 && x > d[i][j] - d[i][j-1] ){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n                if(x==0)continue;\n                dis[S+x][T]=d[i][j] - (j+1)*x;\n                if(x<0|| dis[S+x][T]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        for(int j=0;j<B;++j){\n            for(int i=A-2;i>=0;--i){\n                int x = d[i+1][j]-d[i][j];\n                if((i>0 && x > d[i][j] - d[i-1][j] )){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n                if(x==0)continue;\n                dis[S][T-x] = d[i][j] - (i+1)*x;\n                if(x<0 || dis[S][T-x]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        int N = T;\n        int M = T-S;\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)++M;\n        System.out.println(\"Possible\");\n        System.out.println(N+\" \"+M);\n        for(int i=S;i<101;++i)System.out.println(i+\" \"+(i+1)+\" \"+'X');\n        for(int i=101;i<T;++i)System.out.println(i+\" \"+(i+1)+\" \"+'Y');\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)System.out.println(i+\" \"+j+\" \"+dis[i][j]);\n        System.out.println(S+\" \"+T);\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int cnt = 0;\n            boolean[][] ok = new boolean[a][b];\n            {\n                int dx = d[1][0] - d[0][0];\n                int dy = d[0][1] - d[0][0];\n                int c = d[0][0] - dx - dy;\n                ng |= c < 0;\n                var pl = new IntPair3(dx, dy, c);\n                planes.add(pl);\n                for (int xx = 0; xx < a; xx++) {\n                    for (int yy = 0; yy < b; yy++) {\n                        if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                            ok[xx][yy] = true;\n                            System.err.println(\"(\" + (xx + 1) + \", \" + (yy + 1) + \") is ok\");\n                            cnt++;\n                        }\n                    }\n                }\n            }\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            while (cnt < a * b) {\n                for (int x = 0; x < a; x++) {\n                    for (int y = 0; y < b; y++) {\n                        if (ok[x][y]) continue;\n                        System.err.print(\"try (\" + (x + 1) + \", \" + (y + 1) + \") with \");\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        IntPair3 p1 = null, p2 = null;\n                        for (int dr = 0; dr < 8; dr++) {\n                            int nx = x + dx8[dr];\n                            int ny = y + dy8[dr];\n                            if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                            if (p1 == null) {\n                                p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                System.err.print(\"(\" + (nx + 1) + \", \" + (ny + 1) + \") and \");\n                            } else {\n                                if (x + 1 == p1.fst && x + 1 == nx + 1 || y + 1 == p1.snd && y + 1 == ny + 1) continue;\n                                p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                System.err.print(\"try (\" + (nx + 1) + \", \" + (ny + 1) + \").\");\n                                break;\n                            }\n                        }\n                        System.err.println();\n                        if (p2 == null) continue;\n                        var pl = plane(p0, p1, p2);\n                        ng |= pl.trd < 0;\n                        planes.add(pl);\n                        for (int xx = 0; xx < a; xx++) {\n                            for (int yy = 0; yy < b; yy++) {\n                                if (ok[xx][yy]) continue;\n                                if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                    System.err.println(\"(\" + (xx + 1) + \", \" + (yy + 1) + \") is ok\");\n                                    ok[xx][yy] = true;\n                                    cnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        System.err.println(\"A = \" + a);\n        System.err.println(\"AB = \" + b);\n        System.err.println(\"AC = \" + c);\n        var op = outerProduct(b, c);\n        System.err.println(\"AB * AC = \" + op);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int a = ni();\n    int b = ni();\n    int[][] d = ntable(a, b);\n\n    int m = 2;\n\n    int[][] c = new int[m + 1][m + 1];\n    for (int[] v : c)\n      Arrays.fill(v, Integer.MIN_VALUE);\n\n    \n    // d[x][y] <= i*x + j*y + c[i][j]\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            c[i][j] = Math.max(c[i][j], d[x - 1][y - 1] - i * x - j * y);\n          }\n        }\n      }\n    }\n\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        int test = Integer.MAX_VALUE;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            if (c[i][j] >= 0) {\n              test = Math.min(test, i * x + j * y + c[i][j]);\n            }\n          }\n        }\n        if (test != d[x - 1][y - 1]) {\n          System.out.println(\"Impossible\");\n          return;\n        }\n      }\n    }\n    int edges = m * 2;\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        if (c[i][j] >= 0) {\n          edges ++;\n        }\n      }\n    }\n\n    System.out.println(\"Possible\");\n    System.out.println((m + 1) * 2 + \" \" + edges);\n    for (int i = 1; i < m + 1; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" X\");\n    }\n    for (int i = m + 2; i < (m + 1) * 2; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" Y\");\n    }\n    for (int i = 0; i <= m; i ++) {\n      for (int j = 0; j <= m; j ++) {\n        if (c[i][j] >= 0)\n          System.out.println((i + 1) + \" \" + ((m + 1) * 2 - j) + \" \" + c[i][j]);\n      }\n    }\n    System.out.println(\"1 \" + (m + 1) * 2);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//dij=min(Xi+Yj+cXY)\n\t\t//dij<=Xi+Yj+cij\n\t\t//cXY>=d[i][j]-Xi-Yj;\n\n\t\tint[][] c = new int[101][101];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\tc[x][y] = Math.max(c[x][y], d[i][j] - x * i - y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\td_now[i][j] = Math.min(d_now[i][j], c[x][y] + x * i + y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tif (d[i][j] != d_now[i][j]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (100 + 100 + 10000 + 4));\n\t\tfor (int i = 1; i <= 101; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 202; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int[][] d = new int[A+1][B+1];\n        for(int i=1;i<=A;++i)for(int j=1;j<=B;++j)d[i][j]=scan.nextInt();\n\n        int[][] f = new int[101][101];\n        int[][] dd = new int[A+1][B+1];\n        for(int[] array : dd)Arrays.fill(array, 100);\n        for(int a=0;a<=100;++a)for(int b=0;b<=100;++b){\n            for(int i=1;i<=A;++i)for(int j=1;j<=B;++j)f[a][b] = Math.max(f[a][b] , d[i][j] - a*i - b*j);\n        }\n        for(int i=1;i<=A;++i)for(int j=1;j<=B;++j){\n            for(int a=0;a<101;++a)for(int b=0;b<101;++b)dd[i][j]=Math.min(dd[i][j], f[a][b] + a*i + b*j);\n            if(dd[i][j]!=d[i][j]){\n                System.out.println(\"Impossible\");\n                return;\n            }\n        }\n        System.out.println(\"Possible\");\n        System.out.println(202);\n        System.out.println(200 + 101*101);\n        for(int a=0;a<=100;++a)for(int b=0;b<=100;++b)System.out.println((a+1)+\" \"+(b+101+1)+\" \"+f[a][b]);\n        for(int i=0;i<100;++i)System.out.println(i+\" \"+(i+1)+\" X\");\n        for(int i=101;i<201;++i)System.out.println(i+\" \"+(i+1)+\" Y\");\n        System.out.println(\"0 201\");\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tint r=0;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tr+=i+j+1;\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tout.println(tot+\" \"+r);\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t\tcur++;\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tlong INF = Long.MAX_VALUE / 3;\n\n\tclass Graph {\n\t\tint n;\n\n\t\tclass Edge {\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tlong cost;\n\n\t\t\tpublic Edge(int from, int to, long cost) {\n\t\t\t\tsuper();\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t}\n\n\t\tList<Edge>[] graph;\n\t\tint m;\n\n\t\tpublic Graph(int n, List<Edge>[] graph, int m) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tthis.graph = graph;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\t\t\tgraph = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgraph[i] = new ArrayList<>();\n\t\t\t}\n\t\t}\n\n\t\tlong get(int x, int y) {\n\t\t\tlong[] dp = new long[n];\n\t\t\tArrays.fill(dp, INF);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tdp[e.to] = Math.min(dp[e.to], dp[i] + (e.cost == -1e9 ? x : (e.cost == -2e9 ? y : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n - 1];\n\t\t}\n\n\t\tvoid addEdge(int from, int to, long min) {\n\t\t\tm++;\n\t\t\tgraph[from].add(new Edge(from, to, min));\n\t\t}\n\n\t\tvoid print() {\n\t\t\tout.println(n + \" \" + m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tout.println((e.from + 1) + \" \" + (e.to + 1) + \" \"\n\t\t\t\t\t\t\t+ (e.cost == -1e9 ? \"X\" : (e.cost == -2e9 ? \"Y\" : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(1 + \" \" + n);\n\t\t}\n\t}\n\n\tint max = 17;\n\n\tList<Integer>[] graph;\n\n\tvoid solve() {\n\t\tint a = in.nextInt(), b = in.nextInt();\n\t\tint[][] d = new int[a][b];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\td[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\t\tGraph g = new Graph(max * max + 1);\n\t\tlong[][] min = new long[max][max];\n\t\tfor (long[] i : min) {\n\t\t\tArrays.fill(i, INF);\n\t\t}\n\t\tfor (int i = 0; i < max; i++) {\n\t\t\tfor (int j = 0; j < max; j++) {\n\t\t\t\tif (i + 1 < max) {\n\t\t\t\t\tg.addEdge(i * max + j, (i + 1) * max + j, (int) -1e9);\n\t\t\t\t}\n\t\t\t\tif (j + 1 < max) {\n\t\t\t\t\tg.addEdge(i * max + j, i * max + j + 1, (int) -2e9);\n\t\t\t\t}\n\t\t\t\tlong mx = Long.MIN_VALUE;\n\t\t\t\tfor (int p = 0; p < a; p++) {\n\t\t\t\t\tfor (int q = 0; q < b; q++) {\n\t\t\t\t\t\tlong path = (p + 1) * i + (q + 1) * j;\n\t\t\t\t\t\tmx = Math.max(mx, d[p][q] - path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg.addEdge(i * max + j, g.n - 1, mx);\n\t\t\t}\n\t\t}\n\n\t\tfor (int p = 0; p < a; p++) {\n\t\t\tfor (int q = 0; q < b; q++) {\n\t\t\t\tif (g.get(p + 1, q + 1) != d[p][q]) {\n\t\t\t\t\tSystem.err.println(p + \" \" + q + \" \" + g.get(p + 1, q + 1) + \" \" + d[p][q]);\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tg.print();\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int d[][] = new int[A][B];\n        for(int i=0;i<A;++i){\n            for(int j=0;j<B;++j){\n                d[i][j] = scan.nextInt();\n            }\n        }\n        int S=1;\n        int T=202;\n        //S+X, T-Y;\n        int[][] dis = new int[T+1][T+1];\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)dis[i][j]=-1;\n\n        for(int i=0;i<A;++i){\n            for(int j=B-2;j>=0;--j){\n                int x = d[i][j+1]-d[i][j];\n                if(j>0 && x > d[i][j] - d[i][j-1] ){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n                if(x==0)continue;\n                dis[S+x][T]=d[i][j] - (j+1)*x;\n                if(x<0|| dis[S+x][T]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        for(int j=0;j<B;++j){\n            for(int i=A-2;i>=0;--i){\n                int x = d[i+1][j]-d[i][j];\n                if((i>0 && x > d[i][j] - d[i-1][j] )){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n                if(x==0)continue;\n                dis[S][T-x] = d[i][j] - (i+1)*x;\n                if(x<0 || dis[S][T-x]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        int N = T;\n        int M = T-S;\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)++M;\n        System.out.println(N+\" \"+M);\n        for(int i=S;i<101;++i)System.out.println(i+\" \"+(i+1)+\" \"+'X');\n        for(int i=101;i<T;++i)System.out.println(i+\" \"+(i+1)+\" \"+'Y');\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)System.out.println(i+\" \"+j+\" \"+dis[i][j]);\n        System.out.println(S+\" \"+T);\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//dij=min(Xi+Yj+cXY)\n\t\t//dij<=Xi+Yj+cij\n\t\t//cXY>=d[i][j]-Xi-Yj;\n\n\t\tint[][] c = new int[101][101];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\tc[x][y] = Math.max(c[x][y], d[i][j] - x * i - y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\td_now[i][j] = Math.min(d_now[i][j], c[x][y] + x * i + y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tif (d[i][j] != d_now[i][j]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (100 + 100 + 10000 + 4));\n\t\tfor (int i = 1; i <= 101; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 202; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(100 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tint r=0;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tr+=i+j+1;\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(tot+\" \"+r);\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t\tcur++;\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int[][] d = new int[a][b];\n            int[][] useX = new int[a - 1][b];\n            int[][] useY = new int[a][b - 1];\n            int maxX = 0;\n            int maxY = 0;\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < b; j++) {\n                    d[i][j] = in.nextInt();\n                    if (i > 0) {\n                        useX[i - 1][j] = d[i][j] - d[i - 1][j];\n                        if (useX[i - 1][j] < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        maxX = Math.max(maxX, useX[i - 1][j]);\n                    }\n                    if (j > 0) {\n                        useY[i][j - 1] = d[i][j] - d[i][j - 1];\n                        if (useY[i][j - 1] < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        maxY = Math.max(maxY, useY[i][j - 1]);\n                    }\n                }\n            }\n            for (int i = a - 2; i >= 0; i--) {\n                for (int j = b - 2; j >= 0; j--) {\n                    if (i < a - 1) {\n                        useX[i][j] += useX[i][j + 1];\n                    }\n                    if (j < b - 1) {\n                        useY[i][j] += useY[i + 1][j];\n                    }\n//                if (i < a-2 && j < b-2) { useX[i][j] -= useY[i+1][j+1]; useX[i][j] -= useY[i+1][j+1]; }\n                }\n            }\n\n            int cur = 0;\n            int S = cur++;\n            int[][] g = new int[300][300];\n            for (int[] gg : g) Arrays.fill(gg, Integer.MIN_VALUE);\n            for (int i = 0; i < maxX; i++) {\n                g[cur - 1][cur] = -1;\n                cur++;\n            }\n            g[cur - 1][cur] = 100;\n            cur++;\n            for (int i = 0; i < maxY; i++) {\n                g[cur - 1][cur] = -2;\n                cur++;\n            }\n            int T = cur - 1;\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < b; j++) {\n                    if (i < a - 1 && j < b - 1) {\n                        int xi = useX[i][j];\n                        int yi = T - useY[i][j];\n                        int c = d[i][j] - (i + 1) * useX[i][j] - (j + 1) * useY[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[xi][cur] = c;\n                        g[cur++][yi] = 0;\n                    } else if (i < a - 1) {\n                        int xi = useX[i][j];\n                        int c = d[i][j] - (i + 1) * useX[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[xi][cur] = c;\n                        g[cur++][T] = 0;\n                    } else if (j < b - 1) {\n                        int yi = T - useY[i][j];\n                        int c = d[i][j] - (j + 1) * useY[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[S][cur] = c;\n                        g[cur++][yi] = 0;\n                    } else {\n                        g[S][cur] = d[i][j];\n                        g[cur++][T] = 0;\n                    }\n                }\n            }\n\n            int e = 0;\n            for (int i = 0; i < g.length; i++) {\n                for (int j = 0; j < g.length; j++) {\n                    if (g[i][j] != Integer.MIN_VALUE) {\n                        e++;\n                    }\n                }\n            }\n\n            out.println(\"Possible\");\n            out.println(cur + \" \" + e);\n            for (int i = 0; i < g.length; i++) {\n                for (int j = 0; j < g.length; j++) {\n                    if (g[i][j] != Integer.MIN_VALUE) {\n                        if (g[i][j] == -1) out.println((i + 1) + \" \" + (j + 1) + \" X\");\n                        if (g[i][j] == -2) out.println((i + 1) + \" \" + (j + 1) + \" Y\");\n                        if (g[i][j] >= 0) out.println((i + 1) + \" \" + (j + 1) + \" \" + g[i][j]);\n                    }\n                }\n            }\n            out.println((S + 1) + \" \" + (T + 1));\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        int cnt = 0;\n        boolean[][] ok = new boolean[a][b];\n        {\n            int dx = d[1][0] - d[0][0];\n            int dy = d[0][1] - d[0][0];\n            int c = d[0][0] - dx - dy;\n            ng |= c < 0;\n            var pl = new IntPair3(dx, dy, c);\n            // System.err.println(pl);\n            planes.add(pl);\n            for (int xx = 0; xx < a; xx++) {\n                for (int yy = 0; yy < b; yy++) {\n                    if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                        ok[xx][yy] = true;\n                        // System.err.println(\"(\" + xx + \", \" + yy + \") is ok\");\n                        cnt++;\n                    }\n                }\n            }\n        }\n        int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n        int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n        while (cnt < a * b) {\n            for (int x = 0; x < a; x++) {\n                for (int y = 0; y < b; y++) {\n                    if (ok[x][y]) continue;\n                    var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                    IntPair3 p1 = null, p2 = null;\n                    for (int dx : dx8) for (int dy : dy8) {\n                        int nx = x + dx;\n                        int ny = y + dy;\n                        if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                        if (p1 == null) {\n                            p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                        } else {\n                            p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                            break;\n                        }\n                    }\n                    if (p2 == null) continue;\n                    var pl = plane(p0, p1, p2);\n                    // System.err.println(pl);\n                    ng |= pl.trd < 0;\n                    planes.add(pl);\n                    for (int xx = 0; xx < a; xx++) {\n                        for (int yy = 0; yy < b; yy++) {\n                            if (ok[xx][yy]) continue;\n                            if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                ok[xx][yy] = true;\n                                // System.err.println(\"(\" + xx + \", \" + yy + \") is ok\");\n                                cnt++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        var op = outerProduct(b, c);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= cc; cb /= cc; d /= cc;\n        if (cc > 0) {\n            ca *= -1; cb *= -1; d *= -1;\n        }\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemE solver = new ProblemE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint[][] d = new int[a + 1][b + 1];\n\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\td[x][y] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal int N = 101;\n\t\t\tint[][] f = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\t\t\tf[i][j] = Math.max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\tint cur = Integer.MAX_VALUE;\n\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tcur = Math.min(cur, i * x + j * y + f[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cur != d[x][y]) {\n\t\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(\"Possible\");\n\t\t\tint m = 2 * (N - 1) + N * N;\n\t\t\tout.println((2 * N - 1) + \" \" + m);\n\t\t\tfor (int i = 0; i + 1 < N; i++) {\n\t\t\t\tout.println((i + 1) + \" \" + (i + 2) + \" X\");\n\t\t\t\tout.println((N + i + 1) + \" \" + (N + i + 2) + \" Y\");\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tout.println((i + 1) + \" \" + (2 * N - j) + \" \" + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(1 + \" \" + (2 * N));\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(tot+\" \"+Integer.toString(tot-2));\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\tvoid submit() {\n\t\tint a = nextInt();\n\t\tint b = nextInt();\n\t\tint[][] d = new int[a + 1][b + 1];\n\t\tfor (int i = 1; i <= a; i++) {\n\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\td[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] x = new int[X + 1][X + 1];\n\t\tfor (int[] row : x) {\n\t\t\tArrays.fill(row, -INF);\n\t\t}\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tfor (int i = 1; i <= a; i++) {\n\t\t\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\t\t\tx[ca][cb] = Math.max(x[ca][cb], d[i][j] - ca * i - cb * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= a; i++) {\n\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\tint got = Integer.MAX_VALUE;\n\t\t\t\tfor (int ca = 0; ca <= 100; ca++) {\n\t\t\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n\t\t\t\t\t\t\tgot = Math.min(got, x[ca][cb] + ca * i + cb * j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got != d[i][j]) {\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m = 2 * X;\n\t\t\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"Possible\");\n\t\tint n = 2 * (X + 1);\n\t\t\n\t\tout.println(n + \" \" + m);\n\t\t\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tout.println((i + 1) + \" \" + (i + 2) + \" X\");\n\t\t\tout.println((X + i + 3) + \" \" + (X + i + 2) + \" Y\");\n\t\t}\n\t\t\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n//\t\t\t\t\tm++;\n\t\t\t\t\tout.println((ca + 1) + \" \" + (X + 2 + cb) + \" \" + x[ca][cb]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic final int X = 100;\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - (y + 1) * dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - (x + 1) * dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                for (int dr1 = 0; dr1 < 8; dr1++) {\n                    int x1 = x + dx8[dr1];\n                    int y1 = y + dy8[dr1];\n                    if (x1 < 0 || x1 >= a || y1 < 0 || y1 >= b) continue;\n                    for (int dr2 = dr1 + 1; dr2 < 8; dr2++) {\n                        int x2 = x + dx8[dr2];\n                        int y2 = y + dy8[dr2];\n                        if (x2 < 0 || x2 >= a || y2 < 0 || y2 >= b) continue;\n                        if (x == x1 && x == x2 || y == y1 && y == y2) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        var p1 = new IntPair3(x1 + 1, y1 + 1, d[x1][y1]);\n                        var p2 = new IntPair3(x2 + 1, y2 + 1, d[x2][y2]);\n                        var p = plane(p0, p1, p2);\n                        if (p == null || p.trd < 0) continue;\n                        boolean ok = true;\n                        for (int xx = 0; xx < a; xx++) for (int yy = 0; yy < b; yy++) {\n                            int v = p.fst * (xx + 1) + p.snd * (yy + 1) + p.trd;\n                            ok &= v >= d[xx][yy];\n                        }\n                        if (ok) {\n                            planes.add(p);\n                        }\n                    }\n                }\n            }\n            ng &= check(planes, d);\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        var op = outerProduct(b, c);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (cc == 0 || ((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            return null;\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n\n    public static boolean check(TreeSet<IntPair3> planes, int[][] d) {\n        int a = d.length;\n        int b = d[0].length;\n        int[][] min = new int[a][b];\n        for (int[] e : min) Arrays.fill(e, 1000);\n        for (var p : planes) {\n            int cx = p.fst;\n            int cy = p.snd;\n            int c = p.trd;\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                min[x][y] = Math.min(min[x][y], (x + 1) * cx + (y + 1) * cy + c);\n            }\n        }\n        for (int x = 0; x < a; x++) {\n            for (int y = 0; y < b; y++) {\n                System.err.print(min[x][y] + \" \");\n            }\n            System.err.println();\n        }\n        for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n            if (min[x][y] != d[x][y]) return false;\n        }\n        return true;\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//d[x][y]=min(c[i][j]+i*x+j*y);\n\t\tint[][] c = new int[101][101];\n\t\tfor (int x = 1; x <= A; ++x) {\n\t\t\tfor (int y = 1; y <= B; ++y) {\n\t\t\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\t\t\tc[i][j] = Math.max(c[x][y], d[i][j] - x * i - y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tfor (int x = 0; x < A; ++x) {\n\t\t\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\t\t\td_now[x][y] = Math.min(d_now[x][y], c[i][j] + (x + 1) * i + (y + 1) * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int x = 0; x < A; ++x) {\n\t\t\tfor (int y = 0; y < B; ++y) {\n\t\t\t\tif (d[x][y] != d_now[x][y]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (101 + 101 + 101 * 101 + 2));\n\t\tfor (int i = 1; i <= 101; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 202; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(s + \" \" + t);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private void solve() throws IOException {\n        int a = nextInt();\n        int b = nextInt();\n        int[][] d = new int[a + 1][b + 1];\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                d[x][y] = nextInt();\n            }\n        }\n\n        int n = 150;\n        int[][] c = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                c[i][j] = 0;\n                for (int x = 1; x <= a; x++) {\n                    for (int y = 1; y <= b; y++) {\n                        c[i][j] = Math.max(c[i][j], d[x][y] - i * x - j * y);\n                    }\n                }\n            }\n        }\n\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                int r = Integer.MAX_VALUE;\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        r = Math.min(r, i * x + j * y + c[i][j]);\n                    }\n                }\n                if (r != d[x][y]) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n        out.println(\"Possible\");\n        out.println((2 * n) + \" \" + (2 * (n - 1) + n * n));\n        for (int i = 0; i < n - 1; i++) {\n            out.println((i + 1) + \" \" + (i + 2) + \" X\");\n            out.println((n + i + 1) + \" \" + (n + i + 2) + \" Y\");\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                out.println((i + 1) + \" \" + (n + j + 1) + \" \" + c[i][j]);\n            }\n        }\n        out.println(1 + \" \" + (n + 1));\n    }\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - (y + 1) * dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - (x + 1) * dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                for (int dr1 = 0; dr1 < 8; dr1++) {\n                    int x1 = x + dx8[dr1];\n                    int y1 = y + dy8[dr1];\n                    if (x1 < 0 || x1 >= a || y1 < 0 || y1 >= b) continue;\n                    for (int dr2 = dr1 + 1; dr2 < 8; dr2++) {\n                        int x2 = x + dx8[dr2];\n                        int y2 = y + dy8[dr2];\n                        if (x2 < 0 || x2 >= a || y2 < 0 || y2 >= b) continue;\n                        if (x == x1 && x == x2 || y == y1 && y == y2) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        var p1 = new IntPair3(x1 + 1, y1 + 1, d[x1][y1]);\n                        var p2 = new IntPair3(x2 + 1, y2 + 1, d[x2][y2]);\n                        var p = plane(p0, p1, p2);\n                        if (p == null || p.trd < 0) continue;\n                        boolean ok = true;\n                        for (int xx = 0; xx < a; xx++) for (int yy = 0; yy < b; yy++) {\n                            int v = p.fst * (xx + 1) + p.snd * (yy + 1) + p.trd;\n                            ok &= v >= d[xx][yy];\n                        }\n                        if (ok) {\n                            planes.add(p);\n                        }\n                    }\n                }\n            }\n            int[][] min = new int[a][b];\n            for (int[] e : min) Arrays.fill(e, 1000);\n            for (var p : planes) {\n                int cx = p.fst;\n                int cy = p.snd;\n                int c = p.trd;\n                for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                    min[x][y] = Math.min(min[x][y], (x + 1) * cx + (y + 1) * cy + c);\n                }\n            }\n            for (int x = 0; x < a; x++) {\n                for (int y = 0; y < b; y++) {\n                    if (min[x][y] != d[x][y]) {\n                        if (x > 0 && y > 0) {\n                            ng = true;\n                        } else if (x == 0) {\n                            F : for (int t = -1; t <= 1; t += 2) {\n                                int x1 = x;\n                                int y1 = y + t;\n                                if (y1 < 0 || y1 >= b) continue;\n                                for (int s = 0; s <= 100; s++) {\n                                    int x2 = -1;\n                                    int y2 = y;\n                                    int c = d[x][y] - s;\n                                    var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                                    var p1 = new IntPair3(x1 + 1, y1 + 1, d[x1][y1]);\n                                    var p2 = new IntPair3(x2 + 1, y2 + 1, c);\n                                    var p = plane(p0, p1, p2);\n                                    if (p == null || p.trd < 0) continue;\n                                    boolean ok = true;\n                                    for (int xx = 0; xx < a; xx++) for (int yy = 0; yy < b; yy++) {\n                                        int v = p.fst * (xx + 1) + p.snd * (yy + 1) + p.trd;\n                                        ok &= v >= d[xx][yy];\n                                    }\n                                    if (ok) {\n                                        planes.add(p);\n                                        break F;\n                                    }\n                                }\n                            }\n                        } else {\n                            F : for (int t = -1; t <= 1; t += 2) {\n                                int x1 = x + t;\n                                int y1 = y;\n                                if (x1 < 0 || x1 >= a) continue;\n                                for (int s = 0; s <= 100; s++) {\n                                    int x2 = x;\n                                    int y2 = -1;\n                                    int c = d[x][y] - s;\n                                    var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                                    var p1 = new IntPair3(x1 + 1, y1 + 1, d[x1][y1]);\n                                    var p2 = new IntPair3(x2 + 1, y2 + 1, c);\n                                    var p = plane(p0, p1, p2);\n                                    if (p == null || p.trd < 0) continue;\n                                    boolean ok = true;\n                                    for (int xx = 0; xx < a; xx++) for (int yy = 0; yy < b; yy++) {\n                                        int v = p.fst * (xx + 1) + p.snd * (yy + 1) + p.trd;\n                                        ok &= v >= d[xx][yy];\n                                    }\n                                    if (ok) {\n                                        planes.add(p);\n                                        break F;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            ng |= !check(planes, d);\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        var op = outerProduct(b, c);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (cc == 0 || ((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            return null;\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n\n    public static boolean check(TreeSet<IntPair3> planes, int[][] d) {\n        int a = d.length;\n        int b = d[0].length;\n        int[][] min = new int[a][b];\n        for (int[] e : min) Arrays.fill(e, 1000);\n        for (var p : planes) {\n            int cx = p.fst;\n            int cy = p.snd;\n            int c = p.trd;\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                min[x][y] = Math.min(min[x][y], (x + 1) * cx + (y + 1) * cy + c);\n            }\n        }\n        for (int x = 0; x < a; x++) {\n            for (int y = 0; y < b; y++) {\n                System.err.print(min[x][y] + \" \");\n            }\n            System.err.println();\n        }\n        for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n            if (min[x][y] != d[x][y]) return false;\n        }\n        return true;\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\tvoid submit() {\n\t\tint a = nextInt();\n\t\tint b = nextInt();\n\t\tint[][] d = new int[a + 1][b + 1];\n\t\tfor (int i = 1; i <= a; i++) {\n\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\td[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] x = new int[X + 1][X + 1];\n\t\tfor (int[] row : x) {\n\t\t\tArrays.fill(row, -INF);\n\t\t}\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tfor (int i = 1; i <= a; i++) {\n\t\t\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\t\t\tx[ca][cb] = Math.max(x[ca][cb], d[i][j] - ca * i - cb * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= a; i++) {\n\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\tint got = Integer.MAX_VALUE;\n\t\t\t\tfor (int ca = 0; ca <= 100; ca++) {\n\t\t\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n\t\t\t\t\t\t\tgot = Math.min(got, x[ca][cb] + ca * i + cb * j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (got != d[i][j]) {\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint m = 2 * X;\n\t\t\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(\"Possible\");\n\t\tint n = 2 * (X + 1);\n\t\t\n\t\tout.println(n + \" \" + m);\n\t\t\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tout.println((i + 1) + \" \" + (i + 2) + \" X\");\n\t\t\tout.println((X + i + 3) + \" \" + (X + i + 2) + \" Y\");\n\t\t}\n\t\t\n\t\tfor (int ca = 0; ca <= X; ca++) {\n\t\t\tfor (int cb = 0; ca + cb <= X; cb++) {\n\t\t\t\tif (0 <= x[ca][cb] && x[ca][cb] <= X) {\n//\t\t\t\t\tm++;\n\t\t\t\t\tout.println((ca + 1) + \" \" + (X + 2 + cb) + \" \" + x[ca][cb]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(1 + \" \" + (X + 2));\n\t}\n\t\n\tstatic final int X = 100;\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//dij=min(Xi+Yj+cXY)\n\t\t//dij<=Xi+Yj+cij\n\t\t//cXY>=d[i][j]-Xi-Yj;\n\n\t\tint[][] c = new int[101][101];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\tc[x][y] = Math.max(c[x][y], d[i][j] - x * i - y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\td_now[i][j] = Math.min(d_now[i][j], c[x][y] + x * i + y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tif (d[i][j] != d_now[i][j]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (101 + 101 + 10000 + 2));\n\t\tfor (int i = 1; i <= 101; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 102; i <= 202; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i <= 100; ++i) {\n\t\t\tfor (int j = 0; j <= 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (202 - j) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(202 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(s + \" \" + t);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tlong INF = Long.MAX_VALUE / 3;\n\n\tclass Graph {\n\t\tint n;\n\n\t\tclass Edge {\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tlong cost;\n\n\t\t\tpublic Edge(int from, int to, long cost) {\n\t\t\t\tsuper();\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t}\n\n\t\tList<Edge>[] graph;\n\t\tint m;\n\n\t\tpublic Graph(int n, List<Edge>[] graph, int m) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tthis.graph = graph;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\t\t\tgraph = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgraph[i] = new ArrayList<>();\n\t\t\t}\n\t\t}\n\n\t\tlong get(int x, int y) {\n\t\t\tlong[] dp = new long[n];\n\t\t\tArrays.fill(dp, INF);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tdp[e.to] = Math.min(dp[e.to], dp[i] + (e.cost == -1e9 ? x : (e.cost == -2e9 ? y : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n - 1];\n\t\t}\n\n\t\tvoid addEdge(int from, int to, long min) {\n\t\t\tm++;\n\t\t\tgraph[from].add(new Edge(from, to, min));\n\t\t}\n\n\t\tvoid print() {\n\t\t\tout.println(n + \" \" + m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tout.println((e.from + 1) + \" \" + (e.to + 1) + \" \"\n\t\t\t\t\t\t\t+ (e.cost == -1e9 ? \"X\" : (e.cost == -2e9 ? \"Y\" : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint max = 17;\n\n\tList<Integer>[] graph;\n\n\tvoid solve() {\n\t\tint a = in.nextInt(), b = in.nextInt();\n\t\tint[][] d = new int[a][b];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\td[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\t\tGraph g = new Graph(a * b + 1);\n\t\tlong[][] min = new long[a][b];\n\t\tfor (long[] i : min) {\n\t\t\tArrays.fill(i, INF);\n\t\t}\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tif (i + 1 < a) {\n\t\t\t\t\tg.addEdge(i * b + j, (i + 1) * b + j, (int) -1e9);\n\t\t\t\t}\n\t\t\t\tif (j + 1 < b) {\n\t\t\t\t\tg.addEdge(i * b + j, i * b + j + 1, (int) -2e9);\n\t\t\t\t}\n\n\t\t\t\t// for (int p = 0; p < a; p++) {\n\t\t\t\t// for (int q = 0; q < a; q++) {\n\t\t\t\t// long path = (p + 1) * i + (q + 1) * j;\n\t\t\t\t// min[i][j] = Math.min(min[i][j], d[p][q] - path);\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t\tint p = a - i - 1;\n\t\t\t\tint q = b - j - 1;\n\t\t\t\tif (p < a && q < b) {\n\t\t\t\t\tg.addEdge(i * b + j, g.n - 1, d[p][q] - (p + 1) * i - (q + 1) * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int p = 0; p < a; p++) {\n\t\t\tfor (int q = 0; q < b; q++) {\n\t\t\t\tif (g.get(p + 1, q + 1) != d[p][q]) {\n//\t\t\t\t\tSystem.err.println(p + \" \" + q + \" \" + g.get(p + 1, q + 1) + \" \" + d[p][q]);\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tg.print();\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tlong INF = Long.MAX_VALUE / 3;\n\n\tclass Graph {\n\t\tint n;\n\n\t\tclass Edge {\n\t\t\tint from;\n\t\t\tint to;\n\t\t\tlong cost;\n\n\t\t\tpublic Edge(int from, int to, long cost) {\n\t\t\t\tsuper();\n\t\t\t\tthis.from = from;\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t}\n\n\t\tList<Edge>[] graph;\n\t\tint m;\n\n\t\tpublic Graph(int n, List<Edge>[] graph, int m) {\n\t\t\tsuper();\n\t\t\tthis.n = n;\n\t\t\tthis.graph = graph;\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\t\t\tgraph = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgraph[i] = new ArrayList<>();\n\t\t\t}\n\t\t}\n\n\t\tlong get(int x, int y) {\n\t\t\tlong[] dp = new long[n];\n\t\t\tArrays.fill(dp, INF);\n\t\t\tdp[0] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tdp[e.to] = Math.min(dp[e.to], dp[i] + (e.cost == -1e9 ? x : (e.cost == -2e9 ? y : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n - 1];\n\t\t}\n\n\t\tvoid addEdge(int from, int to, long min) {\n\t\t\tm++;\n\t\t\tgraph[from].add(new Edge(from, to, min));\n\t\t}\n\n\t\tvoid print() {\n\t\t\tout.println(n + \" \" + m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (Edge e : graph[i]) {\n\t\t\t\t\tout.println((e.from + 1) + \" \" + (e.to + 1) + \" \"\n\t\t\t\t\t\t\t+ (e.cost == -1e9 ? \"X\" : (e.cost == -2e9 ? \"Y\" : e.cost)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(1 + \" \" + n);\n\t\t}\n\t}\n\n\tint max = 17;\n\n\tList<Integer>[] graph;\n\n\tvoid solve() {\n\t\tint a = in.nextInt(), b = in.nextInt();\n\t\tint[][] d = new int[a][b];\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\td[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\t\tGraph g = new Graph(a * b + 1);\n\t\tlong[][] min = new long[a][b];\n\t\tfor (long[] i : min) {\n\t\t\tArrays.fill(i, INF);\n\t\t}\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tif (i + 1 < a) {\n\t\t\t\t\tg.addEdge(i * b + j, (i + 1) * b + j, (int) -1e9);\n\t\t\t\t}\n\t\t\t\tif (j + 1 < b) {\n\t\t\t\t\tg.addEdge(i * b + j, i * b + j + 1, (int) -2e9);\n\t\t\t\t}\n\n\t\t\t\t// for (int p = 0; p < a; p++) {\n\t\t\t\t// for (int q = 0; q < a; q++) {\n\t\t\t\t// long path = (p + 1) * i + (q + 1) * j;\n\t\t\t\t// min[i][j] = Math.min(min[i][j], d[p][q] - path);\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t\tint p = a - i - 1;\n\t\t\t\tint q = b - j - 1;\n\t\t\t\tif (p < a && q < b) {\n\t\t\t\t\tg.addEdge(i * b + j, g.n - 1, d[p][q] - (p + 1) * i - (q + 1) * j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int p = 0; p < a; p++) {\n\t\t\tfor (int q = 0; q < b; q++) {\n\t\t\t\tif (g.get(p + 1, q + 1) != d[p][q]) {\n//\t\t\t\t\tSystem.err.println(p + \" \" + q + \" \" + g.get(p + 1, q + 1) + \" \" + d[p][q]);\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tg.print();\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int a = ni();\n    int b = ni();\n    int[][] d = ntable(a, b);\n\n    int m = 2;\n\n    int[][] c = new int[m + 1][m + 1];\n    for (int[] v : c)\n      Arrays.fill(v, Integer.MIN_VALUE);\n\n    \n    // d[x][y] <= i*x + j*y + c[i][j]\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            c[i][j] = Math.max(c[i][j], d[x - 1][y - 1] - i * x - j * y);\n          }\n        }\n      }\n    }\n\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        int test = Integer.MAX_VALUE;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            if (c[i][j] >= 0) {\n              test = Math.min(test, i * x + j * y + c[i][j]);\n            }\n          }\n        }\n        if (test != d[x - 1][y - 1]) {\n          System.out.println(\"Impossible\");\n          return;\n        }\n      }\n    }\n    int edges = m * 2;\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        if (c[i][j] >= 0) {\n          edges ++;\n        }\n      }\n    }\n\n    System.out.println((m + 1) * 2 + \" \" + edges);\n    for (int i = 1; i < m + 1; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" X\");\n    }\n    for (int i = m + 2; i < (m + 1) * 2; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" Y\");\n    }\n    for (int i = 0; i <= m; i ++) {\n      for (int j = 0; j <= m; j ++) {\n        if (c[i][j] >= 0)\n          System.out.println((i + 1) + \" \" + ((m + 1) * 2 - j) + \" \" + c[i][j]);\n      }\n    }\n    System.out.println(\"1 \" + (m + 1) * 2);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint[][] d = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\n\t\t//dij=min(Xi+Yj+cXY)\n\t\t//dij<=Xi+Yj+cij\n\t\t//cXY>=d[i][j]-Xi-Yj;\n\n\t\tint[][] c = new int[101][101];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\tc[x][y] = Math.max(c[x][y], d[i][j] - x * i - y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] d_now = new int[A][B];\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\td_now[i][j] = Integer.MAX_VALUE / 3;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tfor (int x = 0; x <= 100; ++x) {\n\t\t\t\t\tfor (int y = 0; y <= 100; ++y) {\n\t\t\t\t\t\td_now[i][j] = Math.min(d_now[i][j], c[x][y] + x * i + y * j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < A; ++i) {\n\t\t\tfor (int j = 0; j < B; ++j) {\n\t\t\t\tif (d[i][j] != d_now[i][j]) {\n\t\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Possible\");\n\t\tSystem.out.println(300 + \" \" + (100 + 100 + 10000 + 4));\n\t\tfor (int i = 1; i <= 100; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" X\");\n\t\t}\n\t\tfor (int i = 101; i <= 200; ++i) {\n\t\t\tSystem.out.println(i + \" \" + (i + 1) + \" Y\");\n\t\t}\n\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\tfor (int j = 0; j < 100; ++j) {\n\t\t\t\tSystem.out.println((i + 1) + \" \" + (j + 1 + 100) + \" \" + c[i][j]);\n\t\t\t}\n\t\t}\n\t\tint s = 299;\n\t\tint t = 300;\n\t\tSystem.out.println(s + \" \" + 1 + \" \" + 0);\n\t\tSystem.out.println(s + \" \" + 101 + \" \" + 0);\n\t\tSystem.out.println(100 + \" \" + t + \" \" + 0);\n\t\tSystem.out.println(200 + \" \" + t + \" \" + 0);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int a = in.nextInt();\n        int b = in.nextInt();\n        int[][] d = new int[a][b];\n        for (int i = 0; i < a ; i++) {\n            for (int j = 0; j < b ; j++) {\n                d[i][j] = in.nextInt();\n            }\n        }\n\n        List<int[]> edges = solve(d);\n\n        if (edges == null) {\n            out.println(\"Impossible\");\n        } else {\n            out.println(\"Possible\");\n            out.println(String.format(\"%d %d\", 202, edges.size()));\n            for (int[] e : edges) {\n                out.print(String.format(\"%d %d \", e[0]+1, e[1]+1));\n                if (e[2] == -1) {\n                    out.println('X');\n                } else if (e[2] == -2) {\n                    out.println('Y');\n                } else {\n                    out.println(e[2]);\n                }\n            }\n            out.println(\"201 202\");\n        }\n        out.flush();\n    }\n\n    private static List<int[]> solve(int[][] d) {\n        int a = d.length;\n        int b = d[0].length;\n\n\n        int[][] table = new int[101][101];\n        for (int i = 0; i < table.length ; i++) {\n            Arrays.fill(table[i], -1);\n        }\n\n        for (int i = 0 ; i < a ; i++) {\n            for (int j = 0; j < b ; j++) {\n                int x = i+1;\n                int y = j+1;\n                for (int useX = 0 ; useX <= 100 ; useX++) {\n                    for (int useY = 0 ; useY <= 100 ; useY++) {\n                        int leftCost = d[i][j] - x * useX - y * useY;\n                        if (leftCost >= 0) {\n                            table[useX][useY] = Math.max(table[useX][useY], leftCost);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!verify(d, table)) {\n            return null;\n        }\n\n        List<int[]> e = new ArrayList<>();\n        int S = 200;\n        int T = 201;\n        for (int i = 0 ; i < 100; i++) {\n            e.add(new int[]{ i == 0 ? S : i-1, i, -1});\n        }\n        for (int i = 100 ; i < 200 ; i++) {\n            e.add(new int[]{ i, i == 100 ? T : i-1, -2});\n        }\n        for (int i = 0; i < table.length ; i++) {\n            for (int j = 0; j < table[0].length ; j++) {\n                if (table[i][j] != -1) {\n                    int fi = i == 0 ? S : i-1;\n                    int ti = j == 0 ? T : 100+j-1;\n                    e.add(new int[]{ fi, ti, table[i][j] });\n                }\n            }\n        }\n        return e;\n    }\n\n    private static boolean verify(int[][] d, int[][] table) {\n        for (int i = 0 ; i < d.length ; i++) {\n            for (int j = 0; j < d[0].length ; j++) {\n                int x = i+1;\n                int y = j+1;\n\n                int cost = 101;\n                for (int useX = 0 ; useX <= 100 ; useX++) {\n                    for (int useY = 0 ; useY <= 100 ; useY++) {\n                        if (table[useX][useY] == -1) {\n                            continue;\n                        }\n                        cost = Math.min(cost, table[useX][useY] + x * useX + y * useY);\n                    }\n                }\n                if (cost != d[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - (y + 1) * dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - (x + 1) * dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int cnt = 0;\n            boolean[][] ok = new boolean[a][b];\n            {\n                int dx = d[1][0] - d[0][0];\n                int dy = d[0][1] - d[0][0];\n                int c = d[0][0] - dx - dy;\n                ng |= c < 0;\n                var pl = new IntPair3(dx, dy, c);\n                planes.add(pl);\n                for (int xx = 0; xx < a; xx++) {\n                    for (int yy = 0; yy < b; yy++) {\n                        if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                            ok[xx][yy] = true;\n                            System.err.println(\"(\" + (xx + 1) + \", \" + (yy + 1) + \") is ok\");\n                            cnt++;\n                        }\n                    }\n                }\n            }\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            while (cnt < a * b) {\n                for (int x = 0; x < a; x++) {\n                    for (int y = 0; y < b; y++) {\n                        if (ok[x][y]) continue;\n                        System.err.print(\"try (\" + (x + 1) + \", \" + (y + 1) + \") with \");\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        IntPair3 p1 = null, p2 = null;\n                        for (int dr = 0; dr < 8; dr++) {\n                            int nx = x + dx8[dr];\n                            int ny = y + dy8[dr];\n                            if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                            if (p1 == null) {\n                                p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                System.err.print(\"(\" + (nx + 1) + \", \" + (ny + 1) + \") and \");\n                            } else {\n                                if (x + 1 == p1.fst && x + 1 == nx + 1 || y + 1 == p1.snd && y + 1 == ny + 1) continue;\n                                p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                System.err.print(\"try (\" + (nx + 1) + \", \" + (ny + 1) + \").\");\n                                break;\n                            }\n                        }\n                        System.err.println();\n                        if (p2 == null) continue;\n                        var pl = plane(p0, p1, p2);\n                        ng |= pl.trd < 0;\n                        planes.add(pl);\n                        for (int xx = 0; xx < a; xx++) {\n                            for (int yy = 0; yy < b; yy++) {\n                                if (ok[xx][yy]) continue;\n                                if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                    System.err.println(\"(\" + (xx + 1) + \", \" + (yy + 1) + \") is ok\");\n                                    ok[xx][yy] = true;\n                                    cnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        System.err.println(\"A = \" + a);\n        System.err.println(\"AB = \" + b);\n        System.err.println(\"AC = \" + c);\n        var op = outerProduct(b, c);\n        System.err.println(\"AB * AC = \" + op);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int cnt = 0;\n            boolean[][] ok = new boolean[a][b];\n            {\n                int dx = d[1][0] - d[0][0];\n                int dy = d[0][1] - d[0][0];\n                int c = d[0][0] - dx - dy;\n                ng |= c < 0;\n                var pl = new IntPair3(dx, dy, c);\n                planes.add(pl);\n                for (int xx = 0; xx < a; xx++) {\n                    for (int yy = 0; yy < b; yy++) {\n                        if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                            ok[xx][yy] = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            while (cnt < a * b) {\n                for (int x = 0; x < a; x++) {\n                    for (int y = 0; y < b; y++) {\n                        if (ok[x][y]) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        IntPair3 p1 = null, p2 = null;\n                        for (int dr = 0; dr < 8; dr++) {\n                            int nx = x + dx8[dr];\n                            int ny = y + dy8[dr];\n                            if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                            if (p1 == null) {\n                                p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                            } else {\n                                p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                break;\n                            }\n                        }\n                        if (p2 == null) continue;\n                        var pl = plane(p0, p1, p2);\n                        ng |= pl.trd < 0;\n                        planes.add(pl);\n                        for (int xx = 0; xx < a; xx++) {\n                            for (int yy = 0; yy < b; yy++) {\n                                if (ok[xx][yy]) continue;\n                                if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                    ok[xx][yy] = true;\n                                    cnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        System.err.println(a);\n        System.err.println(b);\n        System.err.println(c);\n        var op = outerProduct(b, c);\n        System.err.println(op);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int d[][] = new int[A][B];\n        for(int i=0;i<A;++i){\n            for(int j=0;j<B;++j){\n                d[i][j] = scan.nextInt();\n            }\n        }\n        int S=1;\n        int T=202;\n        //S+X, T-Y;\n        int[][] dis = new int[T+1][T+1];\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)dis[i][j]=-1;\n\n        for(int i=0;i<A;++i){\n            for(int j=B-2;j>=0;--j){\n                int x = d[i][j+1]-d[i][j];\n                if(j>0 && x > d[i][j] - d[i][j-1] ){\n                    System.out.println(\"Impossible\");\n                }\n                if(x==0)continue;\n                dis[S+x][T]=d[i][j] - (j+1)*x;\n                if(x<0|| dis[S+x][T]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        for(int j=0;j<B;++j){\n            for(int i=A-2;i>=0;--i){\n                int x = d[i+1][j]-d[i][j];\n                if((i>0 && x > d[i][j] - d[i-1][j] )){\n                    System.out.println(\"Impossible\");\n                }\n                if(x==0)continue;\n                dis[S][T-x] = d[i][j] - (i+1)*x;\n                if(x<0 || dis[S][T-x]<0){\n                    System.out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n\n        int N = T;\n        int M = T-S;\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)++M;\n        System.out.println(N+\" \"+M);\n        for(int i=S;i<101;++i)System.out.println(i+\" \"+(i+1)+\" \"+'X');\n        for(int i=101;i<T;++i)System.out.println(i+\" \"+(i+1)+\" \"+'Y');\n        for(int i=0;i<T+1;++i)for(int j=0;j<T+1;++j)if(dis[i][j]>=0)System.out.println(i+\" \"+j+\" \"+dis[i][j]);\n        System.out.println(S+\" \"+T);\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int a = ni();\n    int b = ni();\n    int[][] d = ntable(a, b);\n\n    int m = 100;\n\n    int[][] c = new int[m + 1][m + 1];\n    for (int[] v : c)\n      Arrays.fill(v, Integer.MIN_VALUE);\n\n    \n    // d[x][y] <= i*x + j*y + c[i][j]\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            c[i][j] = Math.max(c[i][j], d[x - 1][y - 1] - i * x - j * y);\n          }\n        }\n      }\n    }\n\n    for (int x = 1; x <= a; x++) {\n      for (int y = 1; y <= b; y++) {\n        int test = Integer.MAX_VALUE;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            if (c[i][j] >= 0) {\n              test = Math.min(test, i * x + j * y + c[i][j]);\n            }\n          }\n        }\n        if (test != d[x - 1][y - 1]) {\n          System.out.println(\"Impossible\");\n          return;\n        }\n      }\n    }\n    int edges = m * 2;\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        if (c[i][j] >= 0) {\n          edges ++;\n        }\n      }\n    }\n\n    System.out.println(\"Possible\");\n    System.out.println((m + 1) * 2 + \" \" + edges);\n    for (int i = 1; i < m + 1; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" X\");\n    }\n    for (int i = m + 2; i < (m + 1) * 2; i++) {\n      System.out.println(i + \" \" + (i + 1) + \" Y\");\n    }\n    for (int i = 0; i <= m; i ++) {\n      for (int j = 0; j <= m; j ++) {\n        if (c[i][j] >= 0)\n          System.out.println((i + 1) + \" \" + ((m + 1) * 2 - j) + \" \" + c[i][j]);\n      }\n    }\n    System.out.println(\"1 \" + (m + 1) * 2);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            int[][] d = new int[a][b];\n            int[][] useX = new int[a - 1][b];\n            int[][] useY = new int[a][b - 1];\n            int maxX = 0;\n            int maxY = 0;\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < b; j++) {\n                    d[i][j] = in.nextInt();\n                    if (i > 0) {\n                        useX[i - 1][j] = d[i][j] - d[i - 1][j];\n                        if (useX[i - 1][j] < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        maxX = Math.max(maxX, useX[i - 1][j]);\n                    }\n                    if (j > 0) {\n                        useY[i][j - 1] = d[i][j] - d[i][j - 1];\n                        if (useY[i][j - 1] < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        maxY = Math.max(maxY, useY[i][j - 1]);\n                    }\n                }\n            }\n            int cur = 0;\n            int S = cur++;\n            int[][] g = new int[300][300];\n            for (int[] gg : g) Arrays.fill(gg, Integer.MIN_VALUE);\n            for (int i = 0; i < maxX; i++) {\n                g[cur - 1][cur] = -1;\n                cur++;\n            }\n            g[cur - 1][cur] = 100;\n            cur++;\n            for (int i = 0; i < maxY; i++) {\n                g[cur - 1][cur] = -2;\n                cur++;\n            }\n            int T = cur - 1;\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < b; j++) {\n                    if (i < a - 1 && j < b - 1) {\n                        int xi = useX[i][j];\n                        int yi = T - useY[i][j];\n                        int c = d[i][j] - (i + 1) * useX[i][j] - (j + 1) * useY[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[xi][cur] = c;\n                        g[cur++][yi] = 0;\n                    } else if (i < a - 1) {\n                        int xi = useX[i][j];\n                        int c = d[i][j] - (i + 1) * useX[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[xi][cur] = c;\n                        g[cur++][T] = 0;\n                    } else if (j < b - 1) {\n                        int yi = T - useY[i][j];\n                        int c = d[i][j] - (j + 1) * useY[i][j];\n                        if (c < 0) {\n                            out.println(\"Impossible\");\n                            return;\n                        }\n                        g[S][cur] = c;\n                        g[cur++][yi] = 0;\n                    } else {\n                        g[S][cur] = d[i][j];\n                        g[cur++][T] = 0;\n                    }\n                }\n            }\n\n            int e = 0;\n            for (int i = 0; i < g.length; i++) {\n                for (int j = 0; j < g.length; j++) {\n                    if (g[i][j] != Integer.MIN_VALUE) {\n                        e++;\n                    }\n                }\n            }\n\n            out.println(\"Possible\");\n            out.println(cur + \" \" + e);\n            for (int i = 0; i < g.length; i++) {\n                for (int j = 0; j < g.length; j++) {\n                    if (g[i][j] != Integer.MIN_VALUE) {\n                        if (g[i][j] == -1) out.println((i + 1) + \" \" + (j + 1) + \" X\");\n                        if (g[i][j] == -2) out.println((i + 1) + \" \" + (j + 1) + \" Y\");\n                        if (g[i][j] >= 0) out.println((i + 1) + \" \" + (j + 1) + \" \" + g[i][j]);\n                    }\n                }\n            }\n            out.println((S + 1) + \" \" + (T + 1));\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class Main {\n\n    private void solve() throws IOException {\n        int a = nextInt();\n        int b = nextInt();\n        int[][] d = new int[a + 1][b + 1];\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                d[x][y] = nextInt();\n            }\n        }\n\n        int n = 150;\n        int[][] c = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                c[i][j] = 0;\n                for (int x = 1; x <= a; x++) {\n                    for (int y = 1; y <= b; y++) {\n                        c[i][j] = Math.max(c[i][j], d[x][y] - i * x - j * y);\n                    }\n                }\n            }\n        }\n\n        for (int x = 1; x <= a; x++) {\n            for (int y = 1; y <= b; y++) {\n                int r = Integer.MAX_VALUE;\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        r = Math.min(r, i * x + j * y + c[i][j]);\n                    }\n                }\n                if (r != d[x][y]) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n        }\n        out.println(\"Possible\");\n        out.println((2 * n) + \" \" + (2 * (n - 1) + n * n));\n        for (int i = 0; i < n - 1; i++) {\n            out.println((i + 1) + \" \" + (i + 2) + \" X\");\n            out.println((n + i + 2) + \" \" + (n + i + 1) + \" Y\");\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                out.println((i + 1) + \" \" + (n + j + 1) + \" \" + c[i][j]);\n            }\n        }\n        out.println(1 + \" \" + (n + 1));\n    }\n\n    // ------------------\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(tot+\" \"+Integer.toString(tot-2));\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t\tcur++;\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                planes.add(new IntPair3(0, d[0][y + 1] - d[0][y], d[0][y]));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                planes.add(new IntPair3(d[x + 1][0] - d[x][0], 0, d[x][0]));\n            }\n        } else {\n            int cnt = 0;\n            boolean[][] ok = new boolean[a][b];\n            {\n                int dx = d[1][0] - d[0][0];\n                int dy = d[0][1] - d[0][0];\n                int c = d[0][0] - dx - dy;\n                ng |= c < 0;\n                var pl = new IntPair3(dx, dy, c);\n                planes.add(pl);\n                for (int xx = 0; xx < a; xx++) {\n                    for (int yy = 0; yy < b; yy++) {\n                        if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                            ok[xx][yy] = true;\n                            cnt++;\n                        }\n                    }\n                }\n            }\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            while (cnt < a * b) {\n                for (int x = 0; x < a; x++) {\n                    for (int y = 0; y < b; y++) {\n                        if (ok[x][y]) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        IntPair3 p1 = null, p2 = null;\n                        for (int dr = 0; dr < 8; dr++) {\n                            int nx = x + dx8[dr];\n                            int ny = y + dy8[dr];\n                            if (nx < 0 || nx >= a || ny < 0 || ny >= b || !ok[nx][ny]) continue;\n                            if (p1 == null) {\n                                p1 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                            } else {\n                                p2 = new IntPair3(nx + 1, ny + 1, d[nx][ny]);\n                                break;\n                            }\n                        }\n                        if (p2 == null) continue;\n                        var pl = plane(p0, p1, p2);\n                        ng |= pl.trd < 0;\n                        planes.add(pl);\n                        for (int xx = 0; xx < a; xx++) {\n                            for (int yy = 0; yy < b; yy++) {\n                                if (ok[xx][yy]) continue;\n                                if ((xx + 1) * pl.fst + (yy + 1) * pl.snd + pl.trd == d[xx][yy]) {\n                                    ok[xx][yy] = true;\n                                    cnt++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        System.err.println(a);\n        System.err.println(b);\n        System.err.println(c);\n        var op = outerProduct(b, c);\n        System.err.println(op);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            throw new IllegalArgumentException();\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint a=ir.nextInt();\n\t\tint b=ir.nextInt();\n\t\tint[][] d=new int[a][];\n\t\tfor(int i=0;i<a;i++)\n\t\t\td[i]=ir.nextIntArray(b);\n\t\tboolean[][] f=new boolean[a][b];\n\t\tint ct=0;\n\t\tint tot=2;\n\t\tint r=0;\n\t\tArrayList<int[]> list=new ArrayList<>();\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tfor(int j=0;j<=100;j++){\n\t\t\t\touter:\n\t\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\t\tboolean u=false;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]>i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k)\n\t\t\t\t\t\t\t\tu=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!u)\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\ttot+=i+j;\n\t\t\t\t\tr+=i+j+1;\n\t\t\t\t\tif(k==0&&!(i==0&&j==0)){\n\t\t\t\t\t\tr--;\n\t\t\t\t\t\ttot--;\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(new int[]{i,j,k});\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tfor(int m=0;m<b;m++){\n\t\t\t\t\t\t\tif(d[l][m]==i*(l+1)+j*(m+1)+k){\n\t\t\t\t\t\t\t\tif(!f[l][m])\n\t\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t\tf[l][m]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ct!=a*b||tot>300){\n\t\t\tout.println(\"Impossible\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tout.println(tot+\" \"+r);\n\t\tint cur=2;\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tint[] t=list.get(i);\n\t\t\tif(t[0]==0&&t[1]==0){\n\t\t\t\tout.println(1+\" \"+tot+\" \"+t[2]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<t[0];j++){\n\t\t\t\tif(t[1]==0&&j==t[0]-1&&t[2]==0){\n\t\t\t\t\tout.println(cur+\" \"+tot+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" X\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" X\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<t[1];j++){\n\t\t\t\tif(t[2]==0&&j==t[1]-1){\n\t\t\t\t\tout.println(cur+\" \"+tot+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tout.println(1+\" \"+cur+\" Y\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tout.println(cur+\" \"+Integer.toString(cur+1)+\" Y\");\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t[2]!=0)\n\t\t\t\tout.println(cur+\" \"+tot+\" \"+t[2]);\n\t\t\tcur++;\n\t\t}\n\t\tout.println(1+\" \"+tot);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int[][] d = new int[A+1][B+1];\n        for(int i=1;i<=A;++i)for(int j=1;j<=B;++j)d[i][j]=scan.nextInt();\n\n        int[][] f = new int[101][101];\n        int[][] dd = new int[A+1][B+1];\n        for(int[] array : dd)Arrays.fill(array, 100);\n        for(int a=0;a<=100;++a)for(int b=0;b<=100;++b){\n            for(int i=1;i<=A;++i)for(int j=1;j<=B;++j)f[a][b] = Math.max(f[a][b] , d[i][j] - a*i - b*j);\n        }\n        for(int i=1;i<=A;++i)for(int j=1;j<=B;++j){\n            for(int a=0;a<101;++a)for(int b=0;b<101;++b)dd[i][j]=Math.min(dd[i][j], f[a][b] + a*i + b*j);\n            if(dd[i][j]!=d[i][j]){\n                System.out.println(\"Impossible\");\n                return;\n            }\n        }\n        System.out.println(\"Possible\");\n        System.out.println(202+\" \"+(200 + 101*101));\n        for(int a=0;a<=100;++a)for(int b=0;b<=100;++b)System.out.println((a+1)+\" \"+(202-b)+\" \"+f[a][b]);\n        for(int i=0;i<100;++i)System.out.println((i+1)+\" \"+(i+2)+\" X\");\n        for(int i=101;i<201;++i)System.out.println((i+1)+\" \"+(i+2)+\" Y\");\n        System.out.println(\"1 202\");\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.TreeSet;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int[][] d = sc.ints(a, b);\n        boolean ng = false;\n        for (int x = 0; x < a; x++) {\n            for (int y = 1; y < b - 1; y++) {\n                int dy1 = d[x][y] - d[x][y - 1];\n                int dy2 = d[x][y + 1] - d[x][y];\n                ng |= dy1 < 0 || dy2 < 0 || dy1 < dy2;\n            }\n        }\n        for (int x = 1; x < a - 1; x++) {\n            for (int y = 0; y < b; y++) {\n                int dx1 = d[x][y] - d[x - 1][y];\n                int dx2 = d[x + 1][y] - d[x][y];\n                ng |= dx1 < 0 || dx2 < 0 || dx1 < dx2;\n            }\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var planes = new TreeSet<IntPair3>((p1, p2) -> {\n            if (p1.fst == p2.fst) {\n                if (p1.snd == p2.snd) {\n                    return p1.trd - p2.trd;\n                } else {\n                    return p1.snd - p2.snd;\n                }\n            } else {\n                return p1.fst - p2.fst;\n            }\n        });\n        if (a == 1 && b == 1) {\n            planes.add(new IntPair3(0, 0, d[0][0]));\n        } else if (a == 1) {\n            for (int y = 0; y < b - 1; y++) {\n                int x = 0;\n                int dy = d[0][y + 1] - d[0][y];\n                int c = d[0][y] - (y + 1) * dy;\n                ng |= c < 0;\n                planes.add(new IntPair3(x, dy, c));\n            }\n        } else if (b == 1) {\n            for (int x = 0; x < a - 1; x++) {\n                int dx = d[x + 1][0] - d[x][0];\n                int y = 0;\n                int c = d[x][0] - (x + 1) * dx;\n                ng |= c < 0;\n                planes.add(new IntPair3(dx, y, c));\n            }\n        } else {\n            int[] dx8 = new int[]{0, 1, -1, 0, 1, -1, 1, -1};\n            int[] dy8 = new int[]{1, 0, 0, -1, 1, -1, -1, 1};\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                for (int dr1 = 0; dr1 < 8; dr1++) {\n                    int x1 = x + dx8[dr1];\n                    int y1 = y + dy8[dr1];\n                    if (x1 < 0 || x1 >= a || y1 < 0 || y1 >= b) continue;\n                    for (int dr2 = dr1 + 1; dr2 < 8; dr2++) {\n                        int x2 = x + dx8[dr2];\n                        int y2 = y + dy8[dr2];\n                        if (x2 < 0 || x2 >= a || y2 < 0 || y2 >= b) continue;\n                        if (x == x1 && x == x2 || y == y1 && y == y2) continue;\n                        var p0 = new IntPair3(x + 1, y + 1, d[x][y]);\n                        var p1 = new IntPair3(x1 + 1, y1 + 1, d[x1][y1]);\n                        var p2 = new IntPair3(x2 + 1, y2 + 1, d[x2][y2]);\n                        var p = plane(p0, p1, p2);\n                        if (p == null || p.trd < 0) continue;\n                        boolean ok = true;\n                        for (int xx = 0; xx < a; xx++) for (int yy = 0; yy < b; yy++) {\n                            int v = p.fst * (xx + 1) + p.snd * (yy + 1) + p.trd;\n                            ok &= v >= d[xx][yy];\n                        }\n                        if (ok) {\n                            planes.add(p);\n                        }\n                    }\n                }\n            }\n            ng |= !check(planes, d);\n        }\n        if (ng) {\n            out.writeln(\"Impossible\");\n            return;\n        }\n        var edges = new ArrayList<Edge>();\n        int i = 2;\n        for (var p : planes) {\n            int xe = p.fst;\n            int ye = p.snd;\n            int ce = p.trd;\n            edges.add(new Edge(0, i, ce));\n            for (int x = 0; x < xe; x++) {\n                edges.add(new Edge(i++, i, \"X\"));\n            }\n            for (int y = 0; y < ye; y++) {\n                edges.add(new Edge(i++, i, \"Y\"));\n            }\n            edges.add(new Edge(i++, 1, 0));\n        }\n        out.writeln(\"Possible\");\n        out.write(i).writeSpace().writeln(edges.size());\n        edges.forEach(out::writeln);\n        out.write(1).writeSpace().writeln(2);\n    }\n    public static IntPair3 plane(IntPair3 a, IntPair3 b, IntPair3 c) {\n        b.fst -= a.fst; b.snd -= a.snd; b.trd -= a.trd;\n        c.fst -= a.fst; c.snd -= a.snd; c.trd -= a.trd;\n        var op = outerProduct(b, c);\n        int ca = op.fst;\n        int cb = op.snd;\n        int cc = op.trd;\n        int d = -(ca * a.fst + cb * a.snd + cc * a.trd);\n        if (cc == 0 || ((ca % cc) | (cb % cc) | (d % cc)) != 0) {\n            return null;\n        }\n        ca /= -cc; cb /= -cc; d /= -cc;\n        b.fst += a.fst; b.snd += a.snd; b.trd += a.trd;\n        c.fst += a.fst; c.snd += a.snd; c.trd += a.trd;\n        var plane = new IntPair3(ca, cb, d);\n        return plane;\n    }\n\n    public static IntPair3 outerProduct(IntPair3 a, IntPair3 b) {\n        int x = a.snd * b.trd - a.trd * b.snd;\n        int y = a.trd * b.fst - a.fst * b.trd;\n        int z = a.fst * b.snd - a.snd * b.fst;\n        return new IntPair3(x, y, z);\n    }\n\n    public static boolean check(TreeSet<IntPair3> planes, int[][] d) {\n        int a = d.length;\n        int b = d[0].length;\n        int[][] min = new int[a][b];\n        for (int[] e : min) Arrays.fill(e, 1000);\n        for (var p : planes) {\n            int cx = p.fst;\n            int cy = p.snd;\n            int c = p.trd;\n            for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n                min[x][y] = Math.min(min[x][y], (x + 1) * cx + (y + 1) * cy + c);\n            }\n        }\n        for (int x = 0; x < a; x++) for (int y = 0; y < b; y++) {\n            if (min[x][y] != d[x][y]) return false;\n        }\n        return true;\n    }\n}\n\nclass Edge {\n    int from;\n    int to;\n    Object cost;\n    Edge(int from, int to, Object cost) {\n        this.from = from + 1;\n        this.to = to + 1;\n        this.cost = cost;\n    }\n    public String toString() {\n        return from + \" \" + to + \" \" + cost;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair3 {\n    public int fst, snd, trd;\n    public IntPair3(final int fst, final int snd, final int trd) {this.fst = fst; this.snd = snd; this.trd = trd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair3)) return false;\n        final IntPair3 p = (IntPair3) o;\n        return this.fst == p.fst && this.snd == p.snd && this.trd == p.trd;\n    }\n    @Override\n    public int hashCode() {return Objects.hash(this.fst, this.snd, this.trd);}\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \", \" + this.trd + \")\";}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tProblemE solver = new ProblemE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class ProblemE {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint a = in.nextInt();\n\t\t\tint b = in.nextInt();\n\t\t\tint[][] d = new int[a + 1][b + 1];\n\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\td[x][y] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal int N = 101;\n\t\t\tint[][] f = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\t\t\tf[i][j] = Math.max(f[i][j], d[x][y] - i * x - j * y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= a; x++) {\n\t\t\t\tfor (int y = 1; y <= b; y++) {\n\t\t\t\t\tint cur = Integer.MAX_VALUE;\n\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\t\tcur = Math.min(cur, i * x + j * y + f[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cur != d[x][y]) {\n\t\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(\"Possible\");\n\t\t\tint m = 2 * (N - 1) + N * N;\n\t\t\tout.println((2 * N) + \" \" + m);\n\t\t\tfor (int i = 0; i + 1 < N; i++) {\n\t\t\t\tout.println((i + 1) + \" \" + (i + 2) + \" X\");\n\t\t\t\tout.println((N + i + 1) + \" \" + (N + i + 2) + \" Y\");\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tout.println((i + 1) + \" \" + (2 * N - j) + \" \" + f[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(1 + \" \" + (2 * N));\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\t// ax+by+c\n\t\tint A = ni(), B = ni();\n\t\tint[][] ds = new int[A][];\n\t\tfor(int i = 0;i < A;i++){\n\t\t\tds[i] = na(B);\n\t\t}\n\t\t\n\t\tint[][] es = new int[200000][];\n\t\tint p = 0;\n\t\tfor(int c = 0;c <= 100;c++){\n\t\t\tfor(int a = 0;a+c <= 100;a++){\n\t\t\t\tinner:\n\t\t\t\tfor(int b = 0;a+b+c <= 100;b++){\n\t\t\t\t\tboolean hit = false;\n\t\t\t\t\tfor(int i = 0;i < A;i++){\n\t\t\t\t\t\tfor(int j = 0;j < B;j++){\n\t\t\t\t\t\t\tif(a*(i+1)+b*(j+1)+c < ds[i][j]){\n\t\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(a*(i+1)+b*(j+1)+c == ds[i][j]){\n\t\t\t\t\t\t\t\thit = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(hit){\n\t\t\t\t\t\tes[p++] = new int[]{a, b, c};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < A;i++){\n\t\t\tfor(int j = 0;j < B;j++){\n\t\t\t\tboolean hit = false;\n\t\t\t\tfor(int k = 0;k < p;k++){\n\t\t\t\t\tif(es[k][0]*(i+1)+es[k][1]*(j+1)+es[k][2] == ds[i][j]){\n\t\t\t\t\t\thit = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!hit){\n\t\t\t\t\tout.println(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\t\n\t\tout.println(\"300 \" + (200+p));\n\t\tfor(int i = 1;i <= 100;i++){\n\t\t\tout.println(i + \" \" + (i+1) + \" X\");\n\t\t}\n\t\tfor(int i = 1;i <= 100;i++){\n\t\t\tout.println((i+110+1) + \" \" + (i+110) +  \" Y\");\n\t\t}\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint[] e = es[i];\n\t\t\tout.println((1 + e[0]) + \" \" + (111 + e[1]) + \" \" + e[2]);\n\t\t}\n\t\tout.println(1 + \" \" + 111);\n\t\t\n\t\ttr(p);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Solver {\n  public void solve() {\n    var buf = Console.ReadLine().Split();\n    int na = int.Parse(buf[0]);\n    int nb = int.Parse(buf[1]);\n    int[,] d = new int[na, nb];\n    for (int i = 0; i < na; i++) {\n      buf = Console.ReadLine().Split();\n      for (int j = 0; j < nb; j++) {\n        d[i, j] = int.Parse(buf[j]);\n      }\n    }\n    int m = 100;\n    int n = 2 + m + m;\n    int[,] c = new int[m + 1, m + 1];\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int cost = 0;\n        for (int a = 1; a <= na; a++) {\n          for (int b = 1; b <= nb; b++) {\n            int nd = d[a - 1, b - 1];\n            int bs = a * i + b * j;\n            cost = Math.Max(cost, nd - bs);\n          }\n        }\n        c[i, j] = cost;\n      }\n    }\n    for (int a = 1; a <= na; a++) {\n      for (int b = 1; b <= nb; b++) {\n        int nd = d[a - 1, b - 1];\n        bool ok = false;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            int cur = a * i + b * j + c[i, j];\n            if (cur == nd) ok = true;\n          }\n        }\n        if (!ok) {\n          Console.WriteLine(\"Impossible\");\n          return;\n        }\n      }\n    }\n    Console.WriteLine(\"Possible\");\n    int es = m * 2 + (m + 1) * (m + 1);\n    Console.WriteLine(n + \" \" + es);\n    {\n      int pv = 1;\n      for (int i = 0; i < m; i++) {\n        int nv = i + 2;\n        Console.WriteLine(pv + \" \" + nv + \" X\");\n        pv = nv;\n      }\n    }\n    {\n      int pv = n;\n      for (int i = 0; i < m; i++) {\n        int nv = n - i - 1;\n        Console.WriteLine(nv + \" \" + pv + \" Y\");\n        pv = nv;\n      }\n    }\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int u = i+1, v = n-j;\n        Console.WriteLine(u + \" \" + v + \" \" + c[i, j]);\n      }\n    }\n    Console.WriteLine(1 + \" \" + n);\n  }\n}\n\n/* Main */\nclass ReSha {\n  static void Main() {\n    new Solver().solve();\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random();\n        public void Solve() {\n            var a = ri; var b = ri;\n            var mat = Enumerate(a, x => new int[b]);\n            for (int i = 0; i < a; i++)\n                for (int j = 0; j < b; j++)\n                    mat[i][j] = ri;\n\n            var N = 300;\n            var g = Enumerate(N, x => new int[N]);\n            for (int i = 0; i < N; i++)\n                for (int j = i + 1; j < N; j++)\n                    g[i][j] = g[j][i] = 1000000;\n            var src = N - 2;\n            var sink = src + 1;\n            g[src][0] = 0;\n            g[src][150] = 0;\n            g[100][sink] = 0;\n            g[250][sink] = 0;\n            for (int i = 0; i < 100; i++)\n            {\n                g[i][i + 1] = -1;\n                g[i + 150][i + 151] = -2;\n            }\n            var ok = Enumerate(a, x => new bool[b]);\n            for (int i = 0; i <= 100; i++)\n                for (int j = 0; j <= 100; j++)\n                {\n                    var max = 0;\n                    for (int x = 1; x <= a; x++)\n                        for (int y = 1; y <= b; y++)\n                            max = Math.Max(max, mat[x - 1][y - 1] - i * x - j * y);\n                    g[i][250 - j] = max;\n                    for (int x = 1; x <= a; x++)\n                        for (int y = 1; y <= b; y++)\n                            if (max == mat[x - 1][y - 1] - i * x - j * y) ok[x - 1][y - 1] = true;\n                }\n            if (ok.SelectMany(x => x).All(x => x))\n            {\n                Console.WriteLine(\"Possible\");\n                var E = new List<int[]>();\n                for (int i = 0; i < N; i++)\n                    for (int j = 0; j < N; j++)\n                    {\n                        if (i == j) continue;\n                        if (g[i][j] == 1000000) continue;\n                        E.Add(new int[] { i + 1, j + 1, g[i][j] });\n                    }\n                Console.WriteLine($\"{N} {E.Count}\");\n                foreach (var x in E)\n                {\n                    var label = x[2].ToString();\n                    if (x[2] == -1) label = \"X\";\n                    if (x[2] == -2) label = \"Y\";\n                    Console.WriteLine($\"{x[0]} {x[1]} {label}\");\n                }\n                Console.WriteLine($\"{src + 1} {sink + 1}\");\n            }\n            else { Console.WriteLine(\"Impossible\"); }\n        }\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Solver {\n  public void solve() {\n    var buf = Console.ReadLine().Split();\n    int na = int.Parse(buf[0]);\n    int nb = int.Parse(buf[1]);\n    int[,] d = new int[na, nb];\n    for (int i = 0; i < na; i++) {\n      buf = Console.ReadLine().Split();\n      for (int j = 0; j < nb; j++) {\n        d[i, j] = int.Parse(buf[j]);\n      }\n    }\n    int m = 100;\n    int n = 2 + m + m;\n    int[,] c = new int[m + 1, m + 1];\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int cost = 0;\n        for (int a = 1; a <= na; a++) {\n          for (int b = 1; b <= nb; b++) {\n            int nd = d[a - 1, b - 1];\n            int bs = a * i + b * j;\n            cost = Math.Max(cost, nd - bs);\n          }\n        }\n        c[i, j] = cost;\n      }\n    }\n    for (int a = 1; a <= na; a++) {\n      for (int b = 1; b <= nb; b++) {\n        int nd = d[a - 1, b - 1];\n        bool ok = false;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            int cur = a * i + b * j + c[i, j];\n            if (cur == nd) ok = true;\n          }\n        }\n        if (!ok) {\n          Console.WriteLine(\"Impossible\");\n          return;\n        }\n      }\n    }\n    Console.WriteLine(\"Possible\");\n    int sv = m * 2 + 1, tv = sv + 1;\n    int es = m * 2 + (m + 1) * (m + 1);\n    Console.WriteLine(n + \" \" + es);\n    {\n      int pv = 1;\n      for (int i = 0; i < m; i++) {\n        int nv = i + 2;\n        Console.WriteLine(pv + \" \" + nv + \" X\");\n        pv = nv;\n      }\n    }\n    {\n      int pv = n;\n      for (int i = 0; i < m; i++) {\n        int nv = n - i - 1;\n        Console.WriteLine(nv + \" \" + pv + \" Y\");\n        pv = nv;\n      }\n    }\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int u = i+1, v = n-j;\n        Console.WriteLine(u + \" \" + v + \" \" + c[i, j]);\n      }\n    }\n  }\n}\n\n/* Main */\nclass ReSha {\n  static void Main() {\n    new Solver().solve();\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int a, b;\n        sc.Multi(out a, out b);\n        var d = new int[a][];\n        for (int i = 0; i < a; i++)\n        {\n            d[i] = sc.IntArr;\n        }\n        var cnst = new int[101][];\n        for (int i = 0; i < 101; i++)\n        {\n            cnst[i] = new int[101];\n            for (int j = 0; j < 101; j++)\n            {\n                int max = -1;\n                for (int k = 0; k < a; k++)\n                {\n                    for (int l = 0; l < b; l++)\n                    {\n                        max = Math.Max(max, d[k][l] - (k + 1) * i - (l + 1) * j);\n                    }\n                }\n                cnst[i][j] = max;\n            }\n        }\n        for (int i = 0; i < a; i++)\n        {\n            for (int j = 0; j < b; j++)\n            {\n                int cnt = 0;\n                for (int k = 0; k < 101; k++)\n                {\n                    for (int l = 0; l < 101; l++)\n                    {\n                        if (cnst[k][l] > -1 && cnst[k][l] + (i + 1) * k + (j + 1) * l == d[i][j]) {\n                            ++cnt;\n                        }\n                    }\n                }\n                if (cnt == 0) {\n                    DBG(\"Impossible\");\n                    return;\n                }\n            }\n        }\n        int n = 202;\n\n        var edge = new List<string>();\n        for (int i = 1; i < 101; i++)\n        {\n            edge.Add($\"{i} {i + 1} X\");\n        }\n        for (int i = 102; i < 202; i++)\n        {\n            edge.Add($\"{i} {i + 1} Y\");\n        }\n        for (int i = 0; i < 101; i++)\n        {\n            for (int j = 0; j < 101; j++)\n            {\n                if (cnst[i][j] > -1) {\n                    edge.Add($\"{i + 1} {n - j} {cnst[i][j]}\");\n                }\n            }\n        }\n        Prt(\"Possible\");\n        Prt(n, edge.Count);\n        foreach (var item in edge)\n        {\n            Prt(item);\n        }\n        Prt(1, n);\n\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int A = re.i();\n        int B = re.i();\n        int N = 202;\n        int M = 101*101+200;\n        int[,] Cost = new int[101,101];\n        int[,] D = new int[A,B];\n        for(int i=0;i<A;i++){\n            for(int j=0;j<B;j++){\n                D[i,j] = re.i();\n            }\n        }\n        for(int a=1;a<=A;a++){\n            for(int b=1;b<=B;b++){\n                for(int i=0;i<=100;i++){\n                    for(int j=0;j<=100;j++){\n                        Cost[i,j] = Math.Max(D[a-1,b-1]-a*i-b*j,Cost[i,j]);\n                    }\n                }\n            }\n        }\n        for(int a=1;a<=A;a++){\n            for(int b=1;b<=B;b++){\n                bool OK = false;\n                for(int i=0;i<=100;i++){\n                    for(int j=0;j<=100;j++){\n                        OK |= D[a-1,b-1] == Cost[i,j] + a*i + b*j;\n                    }\n                }\n                if(!OK){\n                    sb.Append(\"Impossible\\n\");\n                    return;\n                }\n            }\n        }\n        sb.Append(\"Possible\\n\");\n        sb.Append(N+\" \"+M+\"\\n\");\n        for(int i=1;i<=100;i++){\n            sb.Append(i+\" \"+(i+1)+\" X\\n\");\n        }\n        for(int i=102;i<=201;i++){\n            sb.Append(i+\" \"+(i+1)+\" Y\\n\");\n        }\n        for(int i=0;i<=100;i++){\n            for(int j=0;j<=100;j++){\n                sb.Append(i+1);\n                sb.Append(\" \");\n                sb.Append(202-j);\n                sb.Append(\" \");\n                sb.Append(Cost[i,j]+\"\\n\");\n            }\n        }\n        sb.Append(1+\" \"+202+\"\\n\");\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Solver {\n  public void solve() {\n    var buf = Console.ReadLine().Split();\n    int na = int.Parse(buf[0]);\n    int nb = int.Parse(buf[1]);\n    int[,] d = new int[na, nb];\n    for (int i = 0; i < na; i++) {\n      buf = Console.ReadLine().Split();\n      for (int j = 0; j < nb; j++) {\n        d[i, j] = int.Parse(buf[j]);\n      }\n    }\n    int m = 2;\n    int n = 2 + m + m;\n    int[,] c = new int[m + 1, m + 1];\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int cost = 0;\n        for (int a = 1; a <= na; a++) {\n          for (int b = 1; b <= nb; b++) {\n            int nd = d[a - 1, b - 1];\n            int bs = a * i + b * j;\n            cost = Math.Max(cost, nd - bs);\n          }\n        }\n        c[i, j] = cost;\n      }\n    }\n    for (int a = 1; a <= na; a++) {\n      for (int b = 1; b <= nb; b++) {\n        int nd = d[a - 1, b - 1];\n        bool ok = false;\n        for (int i = 0; i <= m; i++) {\n          for (int j = 0; j <= m; j++) {\n            int cur = a * i + b * j + c[i, j];\n            if (cur == nd) ok = true;\n          }\n        }\n        if (!ok) {\n          Console.WriteLine(\"Impossible\");\n          return;\n        }\n      }\n    }\n    Console.WriteLine(\"Possible\");\n    int es = m * 2 + (m + 1) * (m + 1);\n    Console.WriteLine(n + \" \" + es);\n    {\n      int pv = 1;\n      for (int i = 0; i < m; i++) {\n        int nv = i + 2;\n        Console.WriteLine(pv + \" \" + nv + \" X\");\n        pv = nv;\n      }\n    }\n    {\n      int pv = n;\n      for (int i = 0; i < m; i++) {\n        int nv = n - i - 1;\n        Console.WriteLine(nv + \" \" + pv + \" Y\");\n        pv = nv;\n      }\n    }\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= m; j++) {\n        int u = i+1, v = n-j;\n        Console.WriteLine(u + \" \" + v + \" \" + c[i, j]);\n      }\n    }\n    Console.WriteLine(1 + \" \" + n);\n  }\n}\n\n/* Main */\nclass ReSha {\n  static void Main() {\n    new Solver().solve();\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "A, B = gets.split.map(&:to_i)\nds = []\n(1..A).each do |i|\n    ds[i] = [nil] + gets.split.map(&:to_i)\nend\n\nfs = Array.new(101){Array.new(101, 0)}\n(0..100).each do |a|\n    (0..100).each do |b|\n        (1..A).each do |x|\n            (1..B).each do |y|\n                val = ds[x][y] - x*a - y*b\n                fs[a][b] = val if fs[a][b] < val\n            end\n        end\n    end\nend\n\n(1..A).each do |x|\n    (1..B).each do |y|\n        result = 10**10\n        (0..100).each do |a|\n            (0..100).each do |b|\n                val = x*a+y*b+fs[a][b]\n                result = val if result > val\n            end\n        end\n        if ds[x][y] != result\n            puts 'Impossible'\n            exit\n        end\n    end\nend\n\nN = 202\nS, T = 1, 202\nM = 200 + 101 ** 2\n\nputs 'Possible'\nputs [N, M].join(' ')\n(1..100).each do |i|\n    puts [i, i+1, 'X'].join(' ')\nend\n(101..201).each do |i|\n    puts [i, i+1, 'Y'].join(' ')\nend\n(0..100).each do |a|\n    (0..100).each do |b|\n        puts [S+a, T-b, fs[a][b]].join(' ')\n    end\nend\nputs [S, T].join(' ')"
  },
  {
    "language": "Ruby",
    "code": "A, B = gets.split.map(&:to_i)\nds = []\n(1..A).each do |i|\n    ds[i] = [nil] + gets.split.map(&:to_i)\nend\n\nfs = Array.new(101){Array.new(101, 0)}\n(0..100).each do |a|\n    (0..100).each do |b|\n        (1..A).each do |x|\n            (1..B).each do |y|\n                val = ds[x][y] - x*a - y*b\n                fs[a][b] = val if fs[a][b] < val\n            end\n        end\n    end\nend\n\n(1..A).each do |x|\n    (1..B).each do |y|\n        result = 10**10\n        (0..100).each do |a|\n            (0..100).each do |b|\n                val = x*a+y*b+fs[a][b]\n                result = val if result > val\n            end\n        end\n        if ds[x][y] != result\n            puts 'Impossible'\n            exit\n        end\n    end\nend\n\nN = 202\nS, T = 1, 202\nM = 200 + 101 ** 2\n\nputs 'Possible'\nputs [N, M].join(' ')\n(1..100).each do |i|\n    puts [i, i+1, 'X'].join(' ')\nend\n(102..201).each do |i|\n    puts [i, i+1, 'Y'].join(' ')\nend\n(0..100).each do |a|\n    (0..100).each do |b|\n        puts [S+a, T-b, fs[a][b]].join(' ')\n    end\nend\nputs [S, T].join(' ')"
  },
  {
    "language": "PHP",
    "code": "Impossible"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.graph.dijkstra;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) sc.read!true;\n\n    int a, b;\n    sc.read(a, b);\n\n    int[][] mp = new int[][a];\n    foreach (i; 0..a) {\n        sc.read(mp[i]);\n    }\n\n    import std.typecons;\n    alias E = Tuple!(int, \"to\", int, \"dist\", char, \"type\");\n\n    int s = 0, t = 220;\n    E[][] g = new E[][](221);\n\n    int getD(int x, int y) {\n        foreach (i; 0..221) {\n            foreach (ref e; g[i]) {\n                if (e.type == 'N') continue;\n                if (e.type == 'X') e.dist = x;\n                if (e.type == 'Y') e.dist = y;\n            }\n        }\n        auto dist = dijkstra!int(g, s).dist;\n        return dist[t];\n    }\n\n    foreach (i; 0..109) {\n        g[i] ~= E(i+1, 0, 'X');\n        g[t-i-1] ~= E(t-i, 0, 'Y');\n    }\n\n    foreach (i; 0..107) {\n        foreach (j; 0..107) {\n            int mi = 0;\n            foreach (r; 0..a) {\n                foreach (c; 0..b) {\n                    mi = max(mi, mp[r][c] - i*r - j*c);\n                }\n            }\n            g[i] ~= E(t-j, mi, 'N');\n        }\n    }\n\n    foreach (i; 0..a) {\n        foreach (j; 0..b) {\n            int u = getD(i, j);\n            if (u != mp[i][j]) {\n                writeln(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n    int m = iota(221).map!(i => g[i].length.to!int).sum;\n    writeln(221, \" \", m);\n    foreach (i; 0..221) {\n        foreach (e; g[i]) {\n            string st;\n            if (e.type == 'N') st = e.dist.to!string;\n            else {\n                st ~= e.type;\n            }\n            writeln(i+1, \" \", e.to+1, \" \", st);\n        }\n    }\n    writeln(s+1, \" \", t+1);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/radixheap.d */\n// module dkh.container.radixheap;\n\n// import dkh.container.stackpayload;\n\nimport std.functional : unaryFun;\nimport std.traits : isSigned, isUnsigned;\n\n \ntemplate RadixHeap(T, alias pred = \"a\") {\n    alias _pred = unaryFun!pred;  \n    alias K = typeof(_pred(T()));  \n     \n    static if (isUnsigned!K) {\n         \n\n        struct RadixHeap {\n            static struct Payload {\n                StackPayload!T[K.sizeof*8+1] v;\n                size_t len;\n                K last;\n\n                 \n                private static int bsr1(K x) {\n                    import core.bitop : bsr;\n                    return (x == 0) ? 0 : bsr(x)+1;\n                }\n                private void assign(T item) {\n                    K key = _pred(item);\n                    assert(last <= key);\n                    v[bsr1(key^last)] ~= item;\n                }\n                private void pull() {\n                    import std.range, std.algorithm;\n                    if (v[0].length) return;\n                    auto i = iota(K.sizeof*8+1).find!(a => v[a].length).front;\n                     \n                    last = v[i].data[].map!_pred.reduce!min;\n                    v[i].data.each!(a => assign(a));\n                    v[i].clear();\n                }\n\n                void insert(T item) {\n                    len++;\n                    assign(item);\n                }\n                T front() {\n                    pull();\n                    return v[0].back;\n                }\n                void removeFront() {\n                    pull();\n                    len--;\n                    v[0].removeBack();\n                }\n            }\n            Payload* p;\n\n            @property bool empty() const { return (!p || p.len == 0); }  \n            @property size_t length() const { return (!p ? 0 : p.len); }  \n            alias opDollar = length;  \n\n             \n            T front() {\n                assert(!empty, \"RadixHeap.front: heap is empty\");\n                return p.front;\n            }\n            void insert(T item) {\n                if (!p) p = new Payload();\n                p.insert(item);\n            }  \n            void removeFront() {\n                assert(!empty, \"RadixHeap.removeFront: heap is empty\");\n                p.removeFront();\n            }  \n        }\n    } else static if (isSigned!K) {\n         \n        import std.traits : Unsigned;\n        static Unsigned!K pred2(in T item) {\n            return _pred(item) ^ (K(1) << (K.sizeof*8 - 1));\n        }\n        alias RadixHeap = RadixHeap!(T, pred2);\n    } else {\n        static assert(false);\n    }\n}\n\n \n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/graph/dijkstra.d */\n// module dkh.graph.dijkstra;\n\n// import dkh.algorithm, dkh.container.radixheap;\n\nstruct DijkstraInfo(T) {\n    T[] dist;\n    int[] from;\n    this(int n, T inf) {\n        dist = new T[n]; dist[] = inf;\n        from = new int[n];\n    }\n}\n\nDijkstraInfo!D dijkstra(D, T)(T g, int s, D inf = D.max) {\n    import std.conv : to;\n    import std.typecons : Tuple;\n    import std.container : make, Array, heapify;\n    import std.container.binaryheap : BinaryHeap;\n    import std.traits : isIntegral;\n\n    int V = g.length.to!int;\n    auto dijk = DijkstraInfo!D(V, inf);\n    with (dijk) {        \n        alias P = Tuple!(int, \"to\", D, \"dist\");\n        auto q = (){\n            static if (isIntegral!D) {\n                return RadixHeap!(P, \"a.dist\")();\n            } else {\n                return heapify!\"a.dist>b.dist\"(make!(Array!P));\n            }\n        }();\n        q.insert(P(s, D(0)));\n        dist[s] = D(0);\n        from[s] = -1;\n        while (!q.empty) {\n            P p = q.front; q.removeFront();\n            if (dist[p.to] < p.dist) continue;\n            foreach (e; g[p.to]) {\n                if (p.dist+e.dist < dist[e.to]) {\n                    dist[e.to] = p.dist+e.dist;\n                    from[e.to] = p.to;\n                    q.insert(P(e.to, dist[e.to]));\n                }\n            }\n        }\n    }\n    return dijk;\n}\n\nDijkstraInfo!D dijkstraDense(D, T)(T g, int s, D inf = D.max) {\n    import std.conv : to;\n    import std.typecons : Tuple;\n    import std.container : make, Array, heapify;\n    import std.range : enumerate;\n    import std.algorithm : filter;\n\n    int V = g.length.to!int;\n    auto dijk = DijkstraInfo!D(V, inf);\n    with (dijk) {\n        alias P = Tuple!(int, \"to\", D, \"dist\");\n\n        bool[] used = new bool[](V);\n        dist[s] = D(0);\n        from[s] = -1;\n        while (true) {\n             \n            auto rng = dist.enumerate.filter!(a => !used[a.index]);\n            if (rng.empty) break;\n            auto nx = rng.minimum!\"a.value < b.value\";\n            used[nx.index] = true;\n            P p = P(nx.index.to!int, nx.value); \n            if (p.dist == inf) continue;\n            foreach (e; g[p.to]) {\n                if (p.dist+e.dist < dist[e.to]) {\n                    dist[e.to] = p.dist+e.dist;\n                    from[e.to] = p.to;\n                }\n            }\n        }\n    }\n    return dijk;\n}\n\n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nclass UnionFindTree {\npublic:\n    this(size_t n) {\n        parent = iota(n).array();\n        rank = new size_t[](n);\n    }\n    size_t find(size_t n) {\n        if(n == parent[n]) {\n            return n;\n        } else {\n            parent[n] = find(parent[n]);\n            return parent[n];\n        }\n    }\n    void unite(size_t n, size_t m) {\n        auto p1 = find(n);\n        auto p2 = find(m);\n        if(n == m) {\n            return;\n        }\n        if(rank[p1] < rank[p2]) {\n            swap(p1, p2);\n        }\n        if(rank[p1] == rank[p2]) {\n            ++rank[p1];\n        }\n        parent[p2] = p1;\n    }\nprivate:\n    size_t[] parent;\n    size_t[] rank;\n}\nunittest {\n    auto uft = new UnionFindTree(10);\n    foreach(i; iota(10)) {\n        assert(uft.find(i) == i);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0).drop(1)) {\n        uft.unite(i, i-3);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0)) {\n        assert(uft.find(0) == uft.find(i));\n    }\n    foreach(i; iota(10).filter!(a => a%3 != 0)) {\n        assert(uft.find(0) != uft.find(i));\n    }\n}\n\n//内部では1-based, 使うときは0-based\nclass BinaryIndexedTree(T, alias F = \"a + b\") if(is(typeof(binaryFun!F))) {\n    alias f = binaryFun!F;\npublic:\n    this(in size_t n, in T T0 = T.init) {\n        t.length = n+1;\n        t[] = T0;\n    }\n\n    void add(in size_t idx, in T v)\n    in {\n        assert(idx < t.length-1);\n    }\n    body {\n        one_based_add(idx+1, v);\n    }\n\n    T accumulate(size_t idx) {\n        return one_based_accumulate(idx+1);\n    }\n\nprivate:\n    T[] t;\n\n    //1-based\n    void one_based_add(size_t idx, in ref T v) {\n        if(idx >= t.length) {\n            return;\n        }\n        t[idx] = f(t[idx], v);\n        one_based_add(idx + (idx & (-idx)), v);\n    }\n    T one_based_accumulate(size_t idx) {\n        if(idx == 0) {\n            return t[0];\n        } else {\n            return f(one_based_accumulate(idx - (idx & (-idx))), t[idx]);\n        }\n    }\n}\nunittest {\n    auto bit = new BinaryIndexedTree!(long)(10);\n    foreach(i; iota(10)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    bit.add(5, 3);\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    foreach(i; iota(5, 10)) {\n        assert(bit.accumulate(i) == 3);\n    }\n\n    bit.add(7, 2);\n\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    foreach(i; iota(5, 7)) {\n        assert(bit.accumulate(i) == 3);\n    }\n    foreach(i; iota(7, 10)) {\n        assert(bit.accumulate(i) == 5);\n    }\n}\nunittest {\n    auto bit = new BinaryIndexedTree!(long, \"a*b\")(10, 1);\n    foreach(i; iota(10)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    bit.add(5, 3);\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    foreach(i; iota(5, 10)) {\n        assert(bit.accumulate(i) == 3);\n    }\n\n    bit.add(7, 2);\n\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    foreach(i; iota(5, 7)) {\n        assert(bit.accumulate(i) == 3);\n    }\n    foreach(i; iota(7, 10)) {\n        assert(bit.accumulate(i) == 6);\n    }\n}\n\n//最大流、O(|V||E|^2)\ntemplate Flow_Dinic() {\n    class Edge {\n    public:\n        this(long to, long capacity) {\n            this.to = to;\n            this.capacity = capacity;\n        }\n        long to;\n        long capacity;\n        Edge reverse;\n    }\n\n    //gを残余グラフにする\n    void residualise(Edge[][] g) {\n        foreach(u; iota(g.length)) {\n            foreach(e; g[u]) {\n                if(e.capacity != 0) {\n                    e.reverse = new Edge(u, 0);\n                    e.reverse.reverse = e;\n                    g[e.to] ~= e.reverse;\n                }\n            }\n        }\n    }\n\n    long INF = long.max / 2;\n\n    //gは残余グラフ\n    //gは計算の結果書き換わる\n    long solve(Edge[][] g, long s, long t) {\n        long ret;\n        while(true) {\n            auto level = new long[](g.length);\n            level[] = INF;\n            auto q = DList!long(s);\n            level[s] = 0;\n            //level graph\n            auto lg = new Edge[][](g.length, 0);\n            while(!q.empty()) {\n                auto u = q.front();\n                q.removeFront();\n                if(u == t) {\n                    break;\n                }\n                foreach(e; g[u]) {\n                    if(e.capacity > 0 && level[e.to] >= level[u] + 1) {\n                        level[e.to] = level[u] + 1;\n                        q.insertBack(e.to);\n                        lg[u] ~= e;\n                    }\n                }\n            }\n            if(level[t] == INF) {\n                break;\n            }\n            auto iter = new long[](g.length);\n            long dfs(long u, long c_min) {\n                if(u == t) {\n                    return c_min;\n                }\n                foreach(i; iota(iter[u], lg[u].length)) {\n                    iter[u] = i;\n                    long f = dfs(lg[u][i].to, min(c_min, lg[u][i].capacity));\n                    if(f > 0) {\n                        lg[u][i].capacity -= f;\n                        lg[u][i].reverse.capacity += f;\n                        return f;\n                    }\n                }\n                return 0;\n            }\n            while(true) {\n                long f = dfs(s, INF);\n                if(f == 0) {\n                    break;\n                }\n                ret += f;\n            }\n        }\n        return ret;\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nvoid main(){\n    long a, b;\n    readlnTo(a, b);\n    long[][] d;\n    foreach(i; iota(a)) {\n        d ~= readLongs();\n    }\n    auto x_mn = new long[][](a, b);\n    auto x_mx = new long[][](a, b);\n    auto y_mn = new long[][](a, b);\n    auto y_mx = new long[][](a, b);\n    long X, Y;\n    foreach(i; iota(a)) {\n        foreach(j; iota(b)) {\n            long mn = 0; \n            long mx = d[i][j] / (i + 1);\n            foreach(k; iota(i+1, a)) {\n                auto dif = d[k][j] - d[i][j];\n                if(dif < 0) {\n                    writeln(\"Impossible\");\n                    return;\n                }\n                mn = max(mn, dif / (k-i) + (dif % (k-i) != 0 ? 1: 0));\n            }\n            foreach(k; iota(i)) {\n                auto dif = d[i][j] - d[k][j];\n                if(dif < 0) {\n                    writeln(\"Impossible\");\n                    return;\n                }\n                mx = min(mx, dif / (i-k));\n            }\n            if(mn > mx) {\n                writeln(\"Impossible\");\n                return;\n            }\n            x_mn[i][j] = mn;\n            x_mx[i][j] = mx;\n            X = max(mx, X);\n        }\n    }\n    foreach(i; iota(a)) {\n        foreach(j; iota(b)) {\n            long mn = 0; \n            long mx = d[i][j] / (j+1);\n            foreach(k; iota(j+1, b)) {\n                auto dif = d[i][k] - d[i][j];\n                if(dif < 0) {\n                    writeln(\"Impossible\");\n                    return;\n                }\n                mn = max(mn, dif / (k-j) + (dif % (k-j) != 0 ? 1: 0));\n            }\n            foreach(k; iota(j)) {\n                auto dif = d[i][j] - d[i][k];\n                if(dif < 0) {\n                    writeln(\"Impossible\");\n                    return;\n                }\n                mx = min(mx, dif / (j-k));\n            }\n            if(mn > mx) {\n                writeln(\"Impossible\");\n                return;\n            }\n            y_mn[i][j] = mn;\n            y_mx[i][j] = mx;\n            Y = max(Y, mx);\n        }\n    }\n    \n    writeln(\"Possible\");\n    //S = 1, T = 1+X + 1, x = 1+x + 1, y = 1+X+y + 1\n    struct Edge {\n        long to;\n        long c;\n    }\n    auto g = new Edge[][](X+Y+2);\n    long[][long[]] used;\n    foreach(i; iota(a)) {\n        foreach(j; iota(b)) {\n            () {\n                foreach(x; iota(x_mn[i][j], x_mx[i][j]+1)) {\n                    foreach(y; iota(y_mn[i][j], y_mx[i][j] + 1)) {\n                        auto c = d[i][j] - (x * (i+1) + y * (j+1));\n                        if([x, y] !in used) {\n                            used[[x, y].idup] ~= c;\n                            g[x] ~= Edge((X+1)+y, c);\n                            return;\n                        } else {\n                            if(used[[x, y]].canFind(c)) {\n                                return;\n                            }\n                        }\n                    }\n                }\n                auto x = x_mn[i][j];\n                auto y = y_mn[i][j];\n                auto c = d[i][j] - (x * (i+1) + y * (j+1));\n                used[[x, y].idup] ~= c;\n                g[x] ~= Edge(g.length, c);\n                g ~= [Edge((X+1)+y, 0)];\n            }();\n        }\n    }\n    writeln(g.length, \" \", g.map!(a => a.length).sum(0L) + X + Y);\n    foreach(i; iota(X)) {\n        writefln(\"%d %d X\", i+1, i+2);\n    }\n    foreach(i; iota(Y)) {\n        writefln(\"%d %d Y\", 1+X+i+1 + 1, 1+X+i + 1);\n    }\n\n    foreach(i; iota(g.length)) {\n        foreach(e; g[i]) {\n            writefln(\"%d %d %d\", i + 1, e.to + 1, e.c);\n        }\n    }\n\n    writeln(1, \" \", 1+X + 1);\n\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array;\n\nvoid main() {\n    int a, b;\n    scan(a, b);\n\n    auto d = new int[][](a + 1, b + 1);\n\n    iota(1, a + 1).each!(i => d[i][1 .. $] = readln.split.to!(int[]));\n\n    debug {\n        writefln(\"%(%(%s %)\\n%)\", d);\n    }\n\n    auto c = new int[][](101, 101);\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            foreach (x ; 1 .. a + 1) {\n                foreach (y ; 1 .. b + 1) {\n                    c[i][j] = max(c[i][j], d[x][y] - i*x - j*y);\n                }\n            }\n        }\n    }\n\n    foreach (x ; 1 .. a + 1) {\n        foreach (y ; 1 .. b + 1) {\n            int dt = 101;\n\n            foreach (i ; 0 .. 101) {\n                foreach (j ; 0 .. 101) {\n                    dt = min(dt, i*x + j*y + c[i][j]);\n                }\n            }\n\n            if (d[x][y] != dt) {\n                writeln(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n    writeln(202, \" \", 100 + 100 + 101*101);\n\n    foreach (i ; 0 .. 100) {\n        writeln(i + 1, \" \", i + 2, \" \", 'X');\n        writeln(102 + i, \" \", 102 + i + 1, \" \", 'Y');\n    }\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            writeln(1 + i, \" \", 201 - j, \" \", c[i][j]);\n        }\n    }\n\n    writeln(0, \" \", 201);\n}\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.graph.dijkstra;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) sc.read!true;\n\n    int a, b;\n    sc.read(a, b);\n\n    int[][] mp = new int[][a];\n    foreach (i; 0..a) {\n        sc.read(mp[i]);\n    }\n\n    import std.typecons;\n    alias E = Tuple!(int, \"to\", int, \"dist\", char, \"type\");\n\n    int s = 0, t = 220;\n    E[][] g = new E[][](221);\n\n    int getD(int x, int y) {\n        foreach (i; 0..221) {\n            foreach (ref e; g[i]) {\n                if (e.type == 'N') continue;\n                if (e.type == 'X') e.dist = x;\n                if (e.type == 'Y') e.dist = y;\n            }\n        }\n        auto dist = dijkstra!int(g, s).dist;\n        return dist[t];\n    }\n\n    foreach (i; 0..109) {\n        g[i] ~= E(i+1, 0, 'X');\n        g[t-i-1] ~= E(t-i, 0, 'Y');\n    }\n\n    foreach (i; 0..107) {\n        foreach (j; 0..107) {\n            int mi = 0;\n            foreach (r; 0..a) {\n                foreach (c; 0..b) {\n                    mi = max(mi, mp[r][c] - i*(r+1) - j*(c+1));\n                }\n            }\n            g[i] ~= E(t-j, mi, 'N');\n        }\n    }\n\n    foreach (i; 0..a) {\n        foreach (j; 0..b) {\n            int u = getD(i+1, j+1);\n            if (u != mp[i][j]) {\n                writeln(\"Impossible\");\n                return 0;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n    int m = iota(221).map!(i => g[i].length.to!int).sum;\n    writeln(221, \" \", m);\n    foreach (i; 0..221) {\n        foreach (e; g[i]) {\n            string st;\n            if (e.type == 'N') st = e.dist.to!string;\n            else {\n                st ~= e.type;\n            }\n            writeln(i+1, \" \", e.to+1, \" \", st);\n        }\n    }\n    writeln(s+1, \" \", t+1);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/radixheap.d */\n// module dkh.container.radixheap;\n\n// import dkh.container.stackpayload;\n\nimport std.functional : unaryFun;\nimport std.traits : isSigned, isUnsigned;\n\n \ntemplate RadixHeap(T, alias pred = \"a\") {\n    alias _pred = unaryFun!pred;  \n    alias K = typeof(_pred(T()));  \n     \n    static if (isUnsigned!K) {\n         \n\n        struct RadixHeap {\n            static struct Payload {\n                StackPayload!T[K.sizeof*8+1] v;\n                size_t len;\n                K last;\n\n                 \n                private static int bsr1(K x) {\n                    import core.bitop : bsr;\n                    return (x == 0) ? 0 : bsr(x)+1;\n                }\n                private void assign(T item) {\n                    K key = _pred(item);\n                    assert(last <= key);\n                    v[bsr1(key^last)] ~= item;\n                }\n                private void pull() {\n                    import std.range, std.algorithm;\n                    if (v[0].length) return;\n                    auto i = iota(K.sizeof*8+1).find!(a => v[a].length).front;\n                     \n                    last = v[i].data[].map!_pred.reduce!min;\n                    v[i].data.each!(a => assign(a));\n                    v[i].clear();\n                }\n\n                void insert(T item) {\n                    len++;\n                    assign(item);\n                }\n                T front() {\n                    pull();\n                    return v[0].back;\n                }\n                void removeFront() {\n                    pull();\n                    len--;\n                    v[0].removeBack();\n                }\n            }\n            Payload* p;\n\n            @property bool empty() const { return (!p || p.len == 0); }  \n            @property size_t length() const { return (!p ? 0 : p.len); }  \n            alias opDollar = length;  \n\n             \n            T front() {\n                assert(!empty, \"RadixHeap.front: heap is empty\");\n                return p.front;\n            }\n            void insert(T item) {\n                if (!p) p = new Payload();\n                p.insert(item);\n            }  \n            void removeFront() {\n                assert(!empty, \"RadixHeap.removeFront: heap is empty\");\n                p.removeFront();\n            }  \n        }\n    } else static if (isSigned!K) {\n         \n        import std.traits : Unsigned;\n        static Unsigned!K pred2(in T item) {\n            return _pred(item) ^ (K(1) << (K.sizeof*8 - 1));\n        }\n        alias RadixHeap = RadixHeap!(T, pred2);\n    } else {\n        static assert(false);\n    }\n}\n\n \n \n\n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/graph/dijkstra.d */\n// module dkh.graph.dijkstra;\n\n// import dkh.algorithm, dkh.container.radixheap;\n\nstruct DijkstraInfo(T) {\n    T[] dist;\n    int[] from;\n    this(int n, T inf) {\n        dist = new T[n]; dist[] = inf;\n        from = new int[n];\n    }\n}\n\nDijkstraInfo!D dijkstra(D, T)(T g, int s, D inf = D.max) {\n    import std.conv : to;\n    import std.typecons : Tuple;\n    import std.container : make, Array, heapify;\n    import std.container.binaryheap : BinaryHeap;\n    import std.traits : isIntegral;\n\n    int V = g.length.to!int;\n    auto dijk = DijkstraInfo!D(V, inf);\n    with (dijk) {        \n        alias P = Tuple!(int, \"to\", D, \"dist\");\n        auto q = (){\n            static if (isIntegral!D) {\n                return RadixHeap!(P, \"a.dist\")();\n            } else {\n                return heapify!\"a.dist>b.dist\"(make!(Array!P));\n            }\n        }();\n        q.insert(P(s, D(0)));\n        dist[s] = D(0);\n        from[s] = -1;\n        while (!q.empty) {\n            P p = q.front; q.removeFront();\n            if (dist[p.to] < p.dist) continue;\n            foreach (e; g[p.to]) {\n                if (p.dist+e.dist < dist[e.to]) {\n                    dist[e.to] = p.dist+e.dist;\n                    from[e.to] = p.to;\n                    q.insert(P(e.to, dist[e.to]));\n                }\n            }\n        }\n    }\n    return dijk;\n}\n\nDijkstraInfo!D dijkstraDense(D, T)(T g, int s, D inf = D.max) {\n    import std.conv : to;\n    import std.typecons : Tuple;\n    import std.container : make, Array, heapify;\n    import std.range : enumerate;\n    import std.algorithm : filter;\n\n    int V = g.length.to!int;\n    auto dijk = DijkstraInfo!D(V, inf);\n    with (dijk) {\n        alias P = Tuple!(int, \"to\", D, \"dist\");\n\n        bool[] used = new bool[](V);\n        dist[s] = D(0);\n        from[s] = -1;\n        while (true) {\n             \n            auto rng = dist.enumerate.filter!(a => !used[a.index]);\n            if (rng.empty) break;\n            auto nx = rng.minimum!\"a.value < b.value\";\n            used[nx.index] = true;\n            P p = P(nx.index.to!int, nx.value); \n            if (p.dist == inf) continue;\n            foreach (e; g[p.to]) {\n                if (p.dist+e.dist < dist[e.to]) {\n                    dist[e.to] = p.dist+e.dist;\n                    from[e.to] = p.to;\n                }\n            }\n        }\n    }\n    return dijk;\n}\n\n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/algorithm.d */\n// module dkh.algorithm;\n\nimport std.traits : isFloatingPoint, isIntegral;\n\n \nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = l + (r-l) / 2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\n \n \n\nimport std.range.primitives;\n\n \nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\n \nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"minimum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\n \n \n\n \nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\n \nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"maximum: range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\n \n \n\n \nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\n \nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() const {\n        return now.empty;\n    }\n    @property auto front() const {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    int K = 100;\n    int A, B;\n    scanln(A, B);\n    int[][] dMat = A.rep!(() => readln.split.to!(int[]));\n\n    int[][] fMat = iota(0, K+1).map!(\n        i => iota(0, K+1).map!(\n            j => A.iota.map!(\n                x => B.iota.map!(\n                    y => dMat[x][y] - (x+1)*i - (y+1)*j\n                ).array.reduce!max\n            ).array.reduce!max.max(0)\n        ).array\n    ).array;\n\n    foreach(x; 0..A) foreach(y; 0..B) {\n        if (dMat[x][y] != iota(0, K+1).map!(\n            i => iota(0, K+1).map!(\n                j => (x+1)*i + (y+1)*j + fMat[i][j]\n            ).reduce!min\n        ).reduce!min) {\n            writeln(\"Impossible\");\n            return;\n        }\n    }\n\n    int N = (K+1)*2;\n    int M = K*2 + (K+1)^^2;\n    int S = 1;\n    int T = (K+1)*2;\n\n    writeln(\"Possible\");\n    \"%d %d\".format(N, M).writeln;\n    foreach(i; 0..K) {\n        \"%d %d %s\".format(i+1, i+2, 'X').writeln;\n        \"%d %d %s\".format(i+1 + (K+1), i+2 + (K+1), 'Y').writeln;\n    }\n    foreach(i; 0..K+1) foreach(j; 0..K+1) {\n        \"%d %d %d\".format(i+1, (K+1)*2 - j, fMat[i][j]).writeln;\n    }\n    \"%d %d\".format(S, T).writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    string getFormat(T)() {\n        static if (isIntegral!T) {\n            return \"%d\";\n        } else if (isFloatingPoint!T) {\n            return \"%g\";\n        } else if (isSomeString!T || isSomeChar!T) {\n            return \"%s\";\n        }\n        assert(false);\n    }\n    enum str = {\n        string res;\n        foreach(i, T; Args) {\n            res ~= getFormat!T;\n            res ~= i==Args.length-1 ? \"\\n\" : \" \";\n        }\n        return res;\n    }();\n    // readf!str(args);\n    mixin((){\n        string res = \"str.readf(\";\n        foreach(i; 0..Args.length) {\n            if (i>0) res ~= \", \";\n            res ~= \"&args[%d]\".format(i);\n        }\n        res ~= \");\";\n        return res;\n    }());\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array;\n\nvoid main() {\n    int a, b;\n    scan(a, b);\n\n    auto d = new int[][](a + 1, b + 1);\n\n    iota(1, a + 1).each!(i => d[i][1 .. $] = readln.split.to!(int[]));\n\n    debug {\n        writefln(\"%(%(%s %)\\n%)\", d);\n    }\n\n    auto c = new int[][](101, 101);\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            foreach (x ; 1 .. a + 1) {\n                foreach (y ; 1 .. b + 1) {\n                    c[i][j] = max(c[i][j], d[x][y] - i*x - j*y);\n                }\n            }\n        }\n    }\n\n    foreach (x ; 1 .. a + 1) {\n        foreach (y ; 1 .. b + 1) {\n            int dt = 101;\n\n            foreach (i ; 0 .. 101) {\n                foreach (j ; 0 .. 101) {\n                    dt = min(dt, i*x + j*y + c[i][j]);\n                }\n            }\n\n            if (d[x][y] != dt) {\n                writeln(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n    writeln(202, \" \", 100 + 100 + 101*101);\n\n    foreach (i ; 0 .. 100) {\n        writeln(i + 1, \" \", i + 2, \" \", 'X');\n        writeln(102 + i, \" \", 102 + i + 1, \" \", 'Y');\n    }\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            writeln(1 + i, \" \", 201 - j, \" \", c[i][j]);\n        }\n    }\n\n    writeln(1, \" \", 202);\n}\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    int K = 100;\n    int A, B;\n    scanln(A, B);\n    int[][] dMat = A.rep!(() => readln.split.to!(int[]));\n\n    int[][] fMat = iota(0, K+1).map!(\n        i => iota(0, K+1).map!(\n            j => A.iota.map!(\n                x => B.iota.map!(\n                    y => dMat[x][y] - (x+1)*i - (y+1)*j\n                ).reduce!max\n            ).reduce!max.max(0)\n        ).array\n    ).array;\n\n    foreach(x; 0..A) foreach(y; 0..B) {\n        if (dMat[x][y] != iota(0, K+1).map!(\n            i => iota(0, K+1).map!(\n                j => (x+1)*i + (y+1)*j + fMat[i][j]\n            ).reduce!min\n        ).reduce!min) {\n            writeln(\"Impossible\");\n            return;\n        }\n    }\n\n    int N = (K+1)*2;\n    int M = (K+1)^2;\n    int S = 1;\n    int T = (K+1)*2;\n\n    writeln(\"Possible\");\n    \"%d %d\".format(N, M).writeln;\n    foreach(i; 0..K) {\n        \"%d %d %s\".format(i+1, i+2, 'X').writeln;\n        \"%d %d %s\".format(i+1 + (K+1), i+2 + (K+1), 'Y').writeln;\n    }\n    foreach(i; 0..K+1) foreach(j; 0..K+1) {\n        \"%d %d %d\".format(i+1, (K+1)*2 - j, fMat[i][j]).writeln;\n    }\n    \"%d %d\".format(S, T).writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    string getFormat(T)() {\n        static if (isIntegral!T) {\n            return \"%d\";\n        } else if (isFloatingPoint!T) {\n            return \"%g\";\n        } else if (isSomeString!T || isSomeChar!T) {\n            return \"%s\";\n        }\n        assert(false);\n    }\n    enum str = {\n        string res;\n        foreach(i, T; Args) {\n            res ~= getFormat!T;\n            res ~= i==Args.length-1 ? \"\\n\" : \" \";\n        }\n        return res;\n    }();\n    // readf!str(args);\n    mixin((){\n        string res = \"str.readf(\";\n        foreach(i; 0..Args.length) {\n            if (i>0) res ~= \", \";\n            res ~= \"&args[%d]\".format(i);\n        }\n        res ~= \");\";\n        return res;\n    }());\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array;\n\nvoid main() {\n    int a, b;\n    scan(a, b);\n\n    auto d = new int[][](a + 1, b + 1);\n\n    iota(1, a + 1).each!(i => d[i][1 .. $] = readln.split.to!(int[]));\n\n    debug {\n        writefln(\"%(%(%s %)\\n%)\", d);\n    }\n\n    auto c = new int[][](101, 101);\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            foreach (x ; 1 .. a + 1) {\n                foreach (y ; 1 .. b + 1) {\n                    c[i][j] = max(c[i][j], d[x][y] - i*x - j*y);\n                }\n            }\n        }\n    }\n\n    foreach (x ; 1 .. a + 1) {\n        foreach (y ; 1 .. b + 1) {\n            int dt = 101;\n\n            foreach (i ; 0 .. 101) {\n                foreach (j ; 0 .. 101) {\n                    dt = min(dt, i*x + j*y + c[i][j]);\n                }\n            }\n\n            if (d[x][y] != dt) {\n                writeln(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n    writeln(202, \" \", 100 + 100 + 101*101);\n\n    foreach (i ; 0 .. 100) {\n        writeln(i + 1, \" \", i + 2, \" \", 'X');\n        writeln(102 + i, \" \", 102 + i + 1, \" \", 'Y');\n    }\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            writeln(1 + i, \" \", 202 - j, \" \", c[i][j]);\n        }\n    }\n\n    writeln(1, \" \", 202);\n}\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.range, std.algorithm, std.array;\n\nvoid main() {\n    int a, b;\n    scan(a, b);\n\n    auto d = new int[][](a + 1, b + 1);\n\n    iota(1, a + 1).each!(i => d[i][1 .. $] = readln.split.to!(int[]));\n\n    debug {\n        writefln(\"%(%(%s %)\\n%)\", d);\n    }\n\n    auto c = new int[][](101, 101);\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            foreach (x ; 1 .. a + 1) {\n                foreach (y ; 1 .. b + 1) {\n                    c[i][j] = max(c[i][j], d[x][y] - i*x - j*y);\n                }\n            }\n        }\n    }\n\n    foreach (x ; 1 .. a + 1) {\n        foreach (y ; 1 .. b + 1) {\n            int dt = 101;\n\n            foreach (i ; 0 .. 101) {\n                foreach (j ; 0 .. 101) {\n                    dt = min(dt, i*x + j*y + c[i][j]);\n                }\n            }\n\n            if (d[x][y] != dt) {\n                writeln(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    writeln(\"Possible\");\n\n    foreach (i ; 0 .. 101) {\n        writeln(i, \" \", i + 1, \" \", 'X');\n        writeln(101 + i, \" \", 101 + i + 1, \" \", 'Y');\n    }\n\n    foreach (i ; 0 .. 101) {\n        foreach (j ; 0 .. 101) {\n            writeln(1 + i, \" \", 201 - j, \" \", c[i][j]);\n        }\n    }\n\n    writeln(0, \" \", 201);\n}\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    int K = 100;\n    int A, B;\n    scanln(A, B);\n    int[][] dMat = A.rep!(() => readln.split.to!(int[]));\n\n    int[][] fMat = iota(0, K+1).map!(\n        i => iota(0, K+1).map!(\n            j => A.iota.map!(\n                x => B.iota.map!(\n                    y => dMat[x][y] - (x+1)*i - (y+1)*j\n                ).array.reduce!max\n            ).array.reduce!max.max(0)\n        ).array\n    ).array;\n\n    foreach(x; 0..A) foreach(y; 0..B) {\n        if (dMat[x][y] != iota(0, K+1).map!(\n            i => iota(0, K+1).map!(\n                j => (x+1)*i + (y+1)*j + fMat[i][j]\n            ).reduce!min\n        ).reduce!min) {\n            writeln(\"Impossible\");\n            return;\n        }\n    }\n\n    int N = (K+1)*2;\n    int M = K*2 + (K+1)^2;\n    int S = 1;\n    int T = (K+1)*2;\n\n    writeln(\"Possible\");\n    \"%d %d\".format(N, M).writeln;\n    foreach(i; 0..K) {\n        \"%d %d %s\".format(i+1, i+2, 'X').writeln;\n        \"%d %d %s\".format(i+1 + (K+1), i+2 + (K+1), 'Y').writeln;\n    }\n    foreach(i; 0..K+1) foreach(j; 0..K+1) {\n        \"%d %d %d\".format(i+1, (K+1)*2 - j, fMat[i][j]).writeln;\n    }\n    \"%d %d\".format(S, T).writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    string getFormat(T)() {\n        static if (isIntegral!T) {\n            return \"%d\";\n        } else if (isFloatingPoint!T) {\n            return \"%g\";\n        } else if (isSomeString!T || isSomeChar!T) {\n            return \"%s\";\n        }\n        assert(false);\n    }\n    enum str = {\n        string res;\n        foreach(i, T; Args) {\n            res ~= getFormat!T;\n            res ~= i==Args.length-1 ? \"\\n\" : \" \";\n        }\n        return res;\n    }();\n    // readf!str(args);\n    mixin((){\n        string res = \"str.readf(\";\n        foreach(i; 0..Args.length) {\n            if (i>0) res ~= \", \";\n            res ~= \"&args[%d]\".format(i);\n        }\n        res ~= \");\";\n        return res;\n    }());\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nclass UnionFindTree {\npublic:\n    this(size_t n) {\n        parent = iota(n).array();\n        rank = new size_t[](n);\n    }\n    size_t find(size_t n) {\n        if(n == parent[n]) {\n            return n;\n        } else {\n            parent[n] = find(parent[n]);\n            return parent[n];\n        }\n    }\n    void unite(size_t n, size_t m) {\n        auto p1 = find(n);\n        auto p2 = find(m);\n        if(n == m) {\n            return;\n        }\n        if(rank[p1] < rank[p2]) {\n            swap(p1, p2);\n        }\n        if(rank[p1] == rank[p2]) {\n            ++rank[p1];\n        }\n        parent[p2] = p1;\n    }\nprivate:\n    size_t[] parent;\n    size_t[] rank;\n}\nunittest {\n    auto uft = new UnionFindTree(10);\n    foreach(i; iota(10)) {\n        assert(uft.find(i) == i);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0).drop(1)) {\n        uft.unite(i, i-3);\n    }\n    foreach(i; iota(10).filter!(a => a%3 == 0)) {\n        assert(uft.find(0) == uft.find(i));\n    }\n    foreach(i; iota(10).filter!(a => a%3 != 0)) {\n        assert(uft.find(0) != uft.find(i));\n    }\n}\n\n//内部では1-based, 使うときは0-based\nclass BinaryIndexedTree(T, alias F = \"a + b\") if(is(typeof(binaryFun!F))) {\n    alias f = binaryFun!F;\npublic:\n    this(in size_t n, in T T0 = T.init) {\n        t.length = n+1;\n        t[] = T0;\n    }\n\n    void add(in size_t idx, in T v)\n    in {\n        assert(idx < t.length-1);\n    }\n    body {\n        one_based_add(idx+1, v);\n    }\n\n    T accumulate(size_t idx) {\n        return one_based_accumulate(idx+1);\n    }\n\nprivate:\n    T[] t;\n\n    //1-based\n    void one_based_add(size_t idx, in ref T v) {\n        if(idx >= t.length) {\n            return;\n        }\n        t[idx] = f(t[idx], v);\n        one_based_add(idx + (idx & (-idx)), v);\n    }\n    T one_based_accumulate(size_t idx) {\n        if(idx == 0) {\n            return t[0];\n        } else {\n            return f(one_based_accumulate(idx - (idx & (-idx))), t[idx]);\n        }\n    }\n}\nunittest {\n    auto bit = new BinaryIndexedTree!(long)(10);\n    foreach(i; iota(10)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    bit.add(5, 3);\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    foreach(i; iota(5, 10)) {\n        assert(bit.accumulate(i) == 3);\n    }\n\n    bit.add(7, 2);\n\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 0);\n    }\n    foreach(i; iota(5, 7)) {\n        assert(bit.accumulate(i) == 3);\n    }\n    foreach(i; iota(7, 10)) {\n        assert(bit.accumulate(i) == 5);\n    }\n}\nunittest {\n    auto bit = new BinaryIndexedTree!(long, \"a*b\")(10, 1);\n    foreach(i; iota(10)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    bit.add(5, 3);\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    foreach(i; iota(5, 10)) {\n        assert(bit.accumulate(i) == 3);\n    }\n\n    bit.add(7, 2);\n\n    foreach(i; iota(5)) {\n        assert(bit.accumulate(i) == 1);\n    }\n    foreach(i; iota(5, 7)) {\n        assert(bit.accumulate(i) == 3);\n    }\n    foreach(i; iota(7, 10)) {\n        assert(bit.accumulate(i) == 6);\n    }\n}\n\n//最大流、O(|V||E|^2)\ntemplate Flow_Dinic() {\n    class Edge {\n    public:\n        this(long to, long capacity) {\n            this.to = to;\n            this.capacity = capacity;\n        }\n        long to;\n        long capacity;\n        Edge reverse;\n    }\n\n    //gを残余グラフにする\n    void residualise(Edge[][] g) {\n        foreach(u; iota(g.length)) {\n            foreach(e; g[u]) {\n                if(e.capacity != 0) {\n                    e.reverse = new Edge(u, 0);\n                    e.reverse.reverse = e;\n                    g[e.to] ~= e.reverse;\n                }\n            }\n        }\n    }\n\n    long INF = long.max / 2;\n\n    //gは残余グラフ\n    //gは計算の結果書き換わる\n    long solve(Edge[][] g, long s, long t) {\n        long ret;\n        while(true) {\n            auto level = new long[](g.length);\n            level[] = INF;\n            auto q = DList!long(s);\n            level[s] = 0;\n            //level graph\n            auto lg = new Edge[][](g.length, 0);\n            while(!q.empty()) {\n                auto u = q.front();\n                q.removeFront();\n                if(u == t) {\n                    break;\n                }\n                foreach(e; g[u]) {\n                    if(e.capacity > 0 && level[e.to] >= level[u] + 1) {\n                        level[e.to] = level[u] + 1;\n                        q.insertBack(e.to);\n                        lg[u] ~= e;\n                    }\n                }\n            }\n            if(level[t] == INF) {\n                break;\n            }\n            auto iter = new long[](g.length);\n            long dfs(long u, long c_min) {\n                if(u == t) {\n                    return c_min;\n                }\n                foreach(i; iota(iter[u], lg[u].length)) {\n                    iter[u] = i;\n                    long f = dfs(lg[u][i].to, min(c_min, lg[u][i].capacity));\n                    if(f > 0) {\n                        lg[u][i].capacity -= f;\n                        lg[u][i].reverse.capacity += f;\n                        return f;\n                    }\n                }\n                return 0;\n            }\n            while(true) {\n                long f = dfs(s, INF);\n                if(f == 0) {\n                    break;\n                }\n                ret += f;\n            }\n        }\n        return ret;\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\nvoid main(){\n    long a, b;\n    readlnTo(a, b);\n    long[][] d;\n    foreach(i; iota(a)) {\n        d ~= readLongs();\n    }\n    auto XY = new long[][][](a, b, 0);\n    long X, Y;\n    foreach(i; iota(a)) {\n        foreach(j; iota(b)) {\n            bool test(long x, long y) {\n                if(x * (i+1) + y * (j+1) > d[i][j]) {\n                    return false;\n                }\n                foreach(k; iota(a)) {\n                    foreach(l; iota(b)) {\n                        if(i == k && j == l) {\n                            continue;\n                        }\n                        if(d[i][j] + x * (k-i) + y * (l-j) < d[k][l]) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            if(!() {\n                foreach(x; iota(0, 101)) {\n                    foreach(y; iota(0, 101)) {\n                        if(test(x, y)) {\n                            XY[i][j] = [x,y];\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }()) {\n                writeln(\"Impossible\");\n                return;\n            }\n\n            X = max(X, XY[i][j][0]);\n            Y = max(Y, XY[i][j][1]);\n        }\n    }\n\n    writeln(\"Possible\");\n\n    //S = 1, T = 1+X + 1, x = 1+x + 1, y = 1+X+y + 1\n    struct Edge {\n        long to;\n        long c;\n    }\n    auto g = new Edge[][](X+Y+2);\n    long[][long[]] used;\n    foreach(i; iota(a)) {\n        foreach(j; iota(b)) {\n            auto x = XY[i][j][0];\n            auto y = XY[i][j][1];\n            auto c = d[i][j] - (x * (i+1) + y * (j+1));\n            if([x, y] !in used) {\n                used[[x, y].idup] ~= c;\n                g[x] ~= Edge((X+1)+y, c);\n            } else {\n                if(!used[[x, y]].canFind(c)) {\n                    used[[x, y].idup] ~= c;\n                    g[x] ~= Edge(g.length, c);\n                    g ~= [Edge((X+1)+y, 0)];\n                }\n            }\n        }\n    }\n    writeln(g.length, \" \", g.map!(a => a.length).sum(0L) + X + Y);\n    foreach(i; iota(X)) {\n        writefln(\"%d %d X\", i+1, i+2);\n    }\n    foreach(i; iota(Y)) {\n        writefln(\"%d %d Y\", 1+X+i+1 + 1, 1+X+i + 1);\n    }\n\n    foreach(i; iota(g.length)) {\n        foreach(e; g[i]) {\n            writefln(\"%d %d %d\", i + 1, e.to + 1, e.c);\n        }\n    }\n\n    writeln(1, \" \", 1+X + 1);\n\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    int K = 100;\n    int A, B;\n    scanln(A, B);\n    int[][] dMat = A.rep!(() => readln.split.to!(int[]));\n\n    int[][] fMat = iota(0, K+1).map!(\n        i => iota(0, K+1).map!(\n            j => A.iota.map!(\n                x => B.iota.map!(\n                    y => dMat[x][y] - (x+1)*i - (y+1)*j\n                ).array.reduce!max\n            ).array.reduce!max.max(0)\n        ).array\n    ).array;\n\n    foreach(x; 0..A) foreach(y; 0..B) {\n        if (dMat[x][y] != iota(0, K+1).map!(\n            i => iota(0, K+1).map!(\n                j => (x+1)*i + (y+1)*j + fMat[i][j]\n            ).reduce!min\n        ).reduce!min) {\n            writeln(\"Impossible\");\n            return;\n        }\n    }\n\n    int N = (K+1)*2;\n    int M = (K+1)^2;\n    int S = 1;\n    int T = (K+1)*2;\n\n    writeln(\"Possible\");\n    \"%d %d\".format(N, M).writeln;\n    foreach(i; 0..K) {\n        \"%d %d %s\".format(i+1, i+2, 'X').writeln;\n        \"%d %d %s\".format(i+1 + (K+1), i+2 + (K+1), 'Y').writeln;\n    }\n    foreach(i; 0..K+1) foreach(j; 0..K+1) {\n        \"%d %d %d\".format(i+1, (K+1)*2 - j, fMat[i][j]).writeln;\n    }\n    \"%d %d\".format(S, T).writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    string getFormat(T)() {\n        static if (isIntegral!T) {\n            return \"%d\";\n        } else if (isFloatingPoint!T) {\n            return \"%g\";\n        } else if (isSomeString!T || isSomeChar!T) {\n            return \"%s\";\n        }\n        assert(false);\n    }\n    enum str = {\n        string res;\n        foreach(i, T; Args) {\n            res ~= getFormat!T;\n            res ~= i==Args.length-1 ? \"\\n\" : \" \";\n        }\n        return res;\n    }();\n    // readf!str(args);\n    mixin((){\n        string res = \"str.readf(\";\n        foreach(i; 0..Args.length) {\n            if (i>0) res ~= \", \";\n            res ~= \"&args[%d]\".format(i);\n        }\n        res ~= \");\";\n        return res;\n    }());\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1 ; i <= 100 ; ++i)\n    printf(\"%d %d X\\n\" , i , i + 1);\n    for(int i = 102 ; i < 202 ; ++i)\n    printf(\"%d %d Y\\n\" , i , i + 1);\n    for(int i = 0 ; i <= 100 ; ++i)\n    for(int j = 0 ; j <= 100 ; ++j)\n        printf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n    puts(\"1 202\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tprintf(\"%d %d X\\n\",S,++tot);\n\tX[0] = S;\n\tX[1] = tot;\n\t\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);++cnt;\n\tfor(int i = 0;i <= 100;++i) {\n\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[i],f[i][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",S,T);\n//\tprintf(\"%d\\n\",cnt);//cnt = 10403 tot = 202\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[12][12],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tputs(\"Impossible\");return 0;/*\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n*/\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tfreopen(\"1.out\",\"w\",stdout);\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n    puts(\"Possible\");\n    puts(\"202 10401\");\n    for(int i = 1 ; i <= 100 ; ++i)\n    printf(\"%d %d X\\n\" , i , i + 1);\n    for(int i = 102 ; i < 202 ; ++i)\n    printf(\"%d %d Y\\n\" , i , i + 1);\n    for(int i = 0 ; i <= 100 ; ++i)\n    for(int j = 0 ; j <= 100 ; ++j)\n        printf(\"%d %d %d\\n\" , 1 + i , 202 - j , f[i][j]);\n    puts(\"1 202\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i) {\n\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 210;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tputs(\"Impossible\");return 0;\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[12][12],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tputs(\"Impossible\");return 0;\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tX[0] = S;\n\t\n\tfor(int i = 1;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);\n\t\n\tprintf(\"%d %d Y\\n\",++tot,T);\n\t\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[j],f[i][j]);\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nll read() {\n\tll x = 0,f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1; c = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0'; c = getchar();\n\t}\n\treturn x * f;\n}\nint d[N][N],f[N][N],A,B,X[N],Y[N];\nint main() {\n\tA = read(),B = read();\n\t\n\tfor(int i = 1;i <= A;++i)\n\t\tfor(int j = 1;j <= B;++j)\n\t\t\td[i][j] = read();\n\t\n\t\n\tfor(int i = 0;i <= 100;++i)\n\t\tfor(int j = 0;j <= 100;++j)\n\t\t\tfor(int x = 1;x <= A;++x)\n\t\t\t\tfor(int y = 1;y <= B;++y)\n\t\t\t\t\tf[i][j] = max(f[i][j],d[x][y] - i * x - j * y);\n\t\n\tfor(int x = 1;x <= A;++x) {\n\t\tfor(int y = 1;y <= B;++y) {\n\t\t\tint tmp = 1e9;\n\t\t\tfor(int i = 0;i <= 100;++i) {\n\t\t\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\t\t\ttmp = min(tmp,f[i][j] + i * x + j * y);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp != d[x][y]) return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\t\n\t\n\t\n\tputs(\"Possible\");\n\t\n\tputs(\"202 10403\");\n\t\n\tint S = 2,T = 1,tot = 2;\n\tint cnt = 0;\n\t\n\tprintf(\"%d %d X\\n\",S,++tot);++cnt;\n\tX[0] = S;\n\tX[1] = tot;\n\t\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d X\\n\",tot,++tot);++cnt;\n\t\tX[i] = tot;\n\t}\n\tprintf(\"%d %d X\\n\",tot,T);++cnt;\n\tprintf(\"%d %d Y\\n\",++tot,T);++cnt;\n\tY[1] = tot;\n\tfor(int i = 2;i <= 100;++i) {\n\t\tprintf(\"%d %d Y\\n\",++tot,tot - 1);++cnt;\n\t\tY[i] = tot;\n\t}\n\tY[0] = T;\n\tprintf(\"%d %d Y\\n\",S,tot);++cnt;\n\tfor(int i = 0;i <= 100;++i) {\n\t\tfor(int j = 0;j <= 100;++j) {\n\t\t\tprintf(\"%d %d %d\\n\",X[i],Y[i],f[i][j]);++cnt;\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\",S,T);\n\tprintf(\"%d\\n\",cnt);//cnt = 10403 tot = 202\n\treturn 0;\n}\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype Plane = tuple [ p, q, r: int ]\n\nproc eval(a, b, p, q, r: int; d: seq2[int]): bool =\n  for y in 1..a:\n    for x in 1..b:\n      if p * y + q * x + r < d[y - 1][x - 1]:\n        return false\n  return true\n\nproc adjust(a, b, p, q: int; d: seq2[int]): int =\n  for i in 0..100:\n    if eval(a, b, p, q, i, d):\n      return i\n  return 100\n\ntype Edge = tuple [ to, cost: int ]\nconst Y = -1\nconst X = -2\n\nproc constructGraph(planes: seq[Plane]): seq2[Edge] =\n  var g = newSeq2[Edge](202, 0)\n  let s = 0\n  let t = 101\n\n  for i in 0..<100:\n    g[i].add((i + 1, Y))\n\n  for i in countdown(201, 102):\n    g[i].add((i - 1, X))\n\n  for plane in planes:\n    g[plane.p].add((plane.q + 101, plane.r))\n\n  return g\n\nproc solve(a, b: int; d: seq2[int]): seq2[Edge] =\n  var planes: seq[Plane] = @[]\n  for p in 0..100:\n    for q in 0..100:\n      let plane = (p, q, adjust(a, b, p, q, d))\n      planes.add(plane)\n\n  for y in 1..a:\n    for x in 1..b:\n      let v = planes.map(it => it.p * y + it.q * x + it.r).min()\n      if d[y - 1][x - 1] != v:\n        return nil\n\n  return constructGraph(planes)\n\nproc main() =\n  let (a, b) = readInt2()\n\n  var d = newSeq[seq[int]](a)\n  for i in 0..<a:\n    d[i] = readSeq().map(parseInt)\n\n  let g = solve(a, b, d)\n  if g == nil:\n    echo \"Impossible\"\n    return\n\n  echo \"Possible\"\n  var n = g.len()\n  var m = g.map(it => it.len()).sum()\n  echo n, \" \", m\n  for i in 0..<n:\n    for e in g[i]:\n      if e.cost == Y:\n        echo (i + 1), \" \", (e.to + 1), \" \", \"Y\"\n      elif e.cost == X:\n        echo (i + 1), \" \", (e.to + 1), \" \", \"X\"\n      else:\n        echo (i + 1), \" \", (e.to + 1), \" \", e.cost\n  echo \"1 102\"\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype Plane = tuple [ p, q, r: int ]\n\nproc eval(a, b, p, q, r: int; d: seq2[int]): bool =\n  for x in 1..a:\n    for y in 1..b:\n      if p * x + q * y + r < d[x - 1][y - 1]:\n        return false\n  return true\n\nproc adjust(a, b, p, q: int; d: seq2[int]): int =\n  for i in 0..100:\n    if eval(a, b, p, q, i, d):\n      return i\n  return 100\n\ntype Edge = tuple [ to, cost: int ]\nconst Y = -1\nconst X = -2\n\nproc constructGraph(planes: seq[Plane]): seq2[Edge] =\n  var g = newSeq2[Edge](202, 0)\n  let s = 0\n  let t = 101\n\n  for i in 0..<100:\n    g[i].add((i + 1, X))\n\n  for i in countdown(201, 102):\n    g[i].add((i - 1, Y))\n\n  for plane in planes:\n    g[plane.p].add((plane.q + 101, plane.r))\n\n  return g\n\nproc solve(a, b: int; d: seq2[int]): seq2[Edge] =\n  var planes: seq[Plane] = @[]\n\n  # p * x + q * x + r\n  for p in 0..100:\n    for q in 0..100:\n      let plane = (p, q, adjust(a, b, p, q, d))\n      planes.add(plane)\n\n  for x in 1..a:\n    for y in 1..b:\n      let v = planes.map(it => it.p * x + it.q * y + it.r).min()\n      if d[x - 1][y - 1] != v:\n        return nil\n\n  return constructGraph(planes)\n\nproc main() =\n  let (a, b) = readInt2()\n\n  var d = newSeq[seq[int]](a)\n  for i in 0..<a:\n    d[i] = readSeq().map(parseInt)\n\n  let g = solve(a, b, d)\n  if g == nil:\n    echo \"Impossible\"\n    return\n\n  echo \"Possible\"\n\n  let n = g.len()\n  let m = g.map(it => it.len()).sum()\n\n  echo n, \" \", m\n  for i in 0..<n:\n    for e in g[i]:\n      if e.cost == X:\n        echo ((i + 1), \" \", (e.to + 1), \" \", \"X\")\n      elif e.cost == Y:\n        echo ((i + 1), \" \", (e.to + 1), \" \", \"Y\")\n      else:\n        echo ((i + 1), \" \", (e.to + 1), \" \", e.cost)\n  echo \"1 102\"\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nwhen not defined(release):\n  addHandler(newFileLogger(stderr, lvlAll, \"[ $levelname ] \"))\n\nproc readInt1*(): int = stdin.readLine().strip().parseInt()\nproc readInt2*(): (int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1])\nproc readInt3*(): (int, int, int) =\n    let v = stdin.readLine().strip().split().map(parseInt)\n    return (v[0], v[1], v[2])\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype Plane = tuple [ p, q, r: int ]\n\nproc eval(a, b, p, q, r: int; d: seq2[int]): bool =\n  for y in 1..a:\n    for x in 1..b:\n      if p * y + q * x + r < d[y - 1][x - 1]:\n        return false\n  return true\n\nproc adjust(a, b, p, q: int; d: seq2[int]): int =\n  for i in 0..100:\n    if eval(a, b, p, q, i, d):\n      return i\n  return 100\n\ntype Edge = tuple [ to, cost: int ]\nconst Y = -1\nconst X = -2\n\nproc constructGraph(planes: seq[Plane]): seq2[Edge] =\n  var g = newSeq2[Edge](202, 0)\n  let s = 0\n  let t = 101\n\n  for i in 0..<100:\n    g[i].add((i + 1, Y))\n\n  for i in countdown(201, 102):\n    g[i].add((i - 1, X))\n\n  for plane in planes:\n    g[plane.p].add((plane.q + 101, plane.r))\n\n  return g\n\nproc solve(a, b: int; d: seq2[int]): seq2[Edge] =\n  var planes: seq[Plane] = @[]\n  for p in 0..100:\n    for q in 0..100:\n      let plane = (p, q, adjust(a, b, p, q, d))\n      planes.add(plane)\n\n  for y in 1..a:\n    for x in 1..b:\n      let v = planes.map(it => it.p * y + it.q * x + it.r).min()\n      if d[y - 1][x - 1] != v:\n        return nil\n\n  return constructGraph(planes)\n\nproc main() =\n  let (a, b) = readInt2()\n\n  var d = newSeq[seq[int]](a)\n  for i in 0..<a:\n    d[i] = readSeq().map(parseInt)\n\n  let g = solve(a, b, d)\n  if g == nil:\n    echo \"Impossible\"\n    return\n\n  echo \"Possible\"\n  var n = g.len()\n  var m = g.map(it => it.len()).sum()\n  echo n, \" \", m\n  for i in 0..<n:\n    for e in g[i]:\n      case e.cost:\n      of Y: echo (i + 1), \" \", (e.to + 1), \" \", \"Y\"\n      of X: echo (i + 1), \" \", (e.to + 1), \" \", \"X\"\n      else: echo (i + 1), \" \", (e.to + 1), \" \", e.cost\n  echo \"1 102\"\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nA, B = map(int, input().split())\nD = [list(map(int, input().split())) for i in range(A)]\n\nN = 101\nF = [[0]*N for i in range(N)]\nfor a in range(N):\n    for b in range(N):\n        res = 0\n        for x in range(A):\n            for y in range(B):\n                res = max(res, D[x][y] - (x+1)*a - (y+1)*b)\n        F[a][b] = res\n\nfor x in range(A):\n    for y in range(B):\n        v = 101\n        for a in range(N):\n            for b in range(N):\n                v = min(v, (x+1)*a + (y+1)*b + F[a][b])\n        if v != D[x][y]:\n            print(\"Impossible\")\n            exit(0)\nprint(\"Possible\")\nprint(2*N, N**2 + 2*(N-1))\nans = 0\nfor i in range(N-1):\n    print(i+1, i+2, \"X\")\n    print(103+i, 102+i, \"Y\")\n    ans += 2\nfor a in range(N):\n    for b in range(N):\n        ans += 1\n        print(a+1, 102+b, F[a][b])\nprint(1, 102)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    for i in range(h - 1):\n        if t[i][w - 1] > t[i + 1][w - 1]:\n            impossible()\n    edges = [[-1] * 201 for _ in range(201)]\n    number_edge = 201\n    for i in range(h):\n        for j in range(w - 1):\n            x, y = i + 1, j + 1\n            if i + 1 == h:\n                number_x = 0\n            else:\n                number_x = t[i + 1][j] - t[i][j]\n            if j + 1 == w:\n                number_y = 0\n            else:\n                number_y = t[i][j + 1] - t[i][j]\n            if number_x < 0 or number_y < 0:\n                impossible()\n            cost = t[i][j] - x * number_x - y * number_y\n            if cost < 0:\n                impossible()\n            u, v = number_x, 200 - number_y\n            if edges[u][v] == -1:\n                edges[u][v] = cost\n                number_edge += 1\n            elif edges[u][v] != cost:\n                impossible()\n\n    print(\"Possible\")\n    print(201, number_edge)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(101, 201):\n        print(u, u + 1, \"Y\")\n    for i in range(201):\n        for j in range(201):\n            cost = edges[i][j]\n            if cost != -1:\n                print(i + 1, j + 1, cost)\n    print(1, 201)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\n\"\"\"\nax + by + c という距離をたくさん作れる\n全ての(a,b)に対して作るとしてよい（cを大きくすれば無視できるので）\n悪さをしない範囲の最小のcを選ぶ\nそれで上手くいっているかを検証\n\"\"\"\n\nU = 100\nA,B = map(int,input().split())\nD = np.array([input().rstrip().split() for _ in range(A)], dtype=np.int64)\n\nax = np.arange(U+1)[:,None] * np.arange(1,A+1)[None,:] # (U+1, A)\nby = np.arange(U+1)[:,None] * np.arange(1,B+1)[None,:] # (U+1, B)\naxby = ax[:,:,None,None] + by[None,None,:,:] # (U+1,A,U+1,B)\n\nc = (D[None,:,None,:] - axby).max(axis = 3).max(axis = 1) # (U+1,U+1)\nc *= (c > 0)\n\nD2 = (axby + c[:,None,:,None]).min(axis = 2).min(axis = 0) # (A,B)\n\nif (D != D2).any():\n    print('Impossible')\n    exit()\n\n# ax + by + c[a,b] という1次式が距離になるようなグラフを作成\n\ngraph = []\nfor a in range(U+1):\n    for b in range(U+1):\n        graph.append((1+a, (U+2) + b, c[a,b]))\nfor a in range(U):\n    graph.append((a+1,a+2,'X'))\nfor b in range(U,0,-1):\n    graph.append((U+2+b,U+1+b,'Y'))\n\nstart = 1\ngoal = U+2\n\nprint('Possible')\nprint(2*(U+1), len(graph))\nfor e in graph:\n    print(*e)\nprint(start,goal)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nA, B = map(int, input().split())\nD = [list(map(int, input().split())) for i in range(A)]\n\nN = 101\nF = [[0]*N for i in range(N)]\nfor a in range(N):\n    for b in range(N):\n        res = 0\n        for x in range(A):\n            for y in range(B):\n                res = max(res, D[x][y] - (x+1)*a - (y+1)*b)\n        F[a][b] = res\n\nfor x in range(A):\n    for y in range(B):\n        v = 101\n        for a in range(N):\n            for b in range(N):\n                v = min(v, (x+1)*a + (y+1)*b + F[a][b])\n        if v != D[x][y]:\n            print(\"Impossible\")\n            exit(0)\nprint(\"Possible\")\nprint(2*N, N**2 + 2*(N-1))\nfor i in range(N-1):\n    print(i+1, i+2, \"X\")\n    print(103+i, 102+i, \"Y\")\nfor a in range(N):\n    for b in range(N):\n        print(a+1, 102+b, F[a][b])\nprint(1, 102)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    # 番兵を立てる\n    for tr in t:\n        tr.append(tr[-1])\n    t.append(t[-1])\n    # p2D(t)\n    edge = [[-1] * 101 for _ in range(101)]\n    hp = []\n    for i in range(h):\n        for j in range(w):\n            tij = t[i][j]\n            min_number_x = t[i + 1][j] - tij\n            min_number_y = t[i][j + 1] - tij\n            diff = tij - min_number_x * (i + 1) - min_number_y * (j + 1)\n            if min_number_x < 0 or min_number_y < 0 or diff < 0:\n                impossible()\n            heappush(hp, [diff, i, j, min_number_x, min_number_y])\n    number_edges = 200\n    while hp:\n        diff, i, j, min_number_x, min_number_y = heappop(hp)\n        x, y = i + 1, j + 1\n        tij = t[i][j]\n        candi = []\n        for number_x in range(min_number_x, 101):\n            if x * number_x > tij: break\n            for number_y in range(min_number_y, 101):\n                sum_xy = x * number_x + y * number_y\n                if sum_xy > tij: break\n                candi.append([sum_xy, number_x, number_y])\n        for sum_xy, number_x, number_y in sorted(candi, reverse=True):\n            diff = tij - sum_xy\n            if edge[number_x][number_y] == -1:\n                edge[number_x][number_y] = diff\n                number_edges += 1\n                break\n            if edge[number_x][number_y] == diff:\n                break\n        else:\n            impossible()\n    # p2D(edge)\n    print(202, number_edges)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for number_x in range(101):\n        for number_y in range(101):\n            diff = edge[number_x][number_y]\n            if diff == -1: continue\n            print(number_x + 1, 202 - number_y, diff)\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    edge = [[0] * 101 for _ in range(101)]\n\n    # XとYをつなぐ辺の作成\n    for n_x in range(101):\n        for n_y in range(101):\n            cost = 0\n            for i in range(h):\n                for j in range(w):\n                    x, y = i + 1, j + 1\n                    cur_cost = t[i][j] - x * n_x - y * n_y\n                    if cur_cost > cost: cost = cur_cost\n            edge[n_x][n_y] = cost\n    # p2D(edge)\n\n    # 条件を満たしているかのチェック\n    for i in range(h):\n        for j in range(w):\n            x, y = i + 1, j + 1\n            tij = t[i][j]\n            min_dist = 1000\n            for n_x in range(101):\n                for n_y in range(101):\n                    dist = x * n_x + y * n_y + edge[n_x][n_y]\n                    if dist < min_dist: min_dist = dist\n            if tij != min_dist: impossible()\n\n    print(\"Possible\")\n    print(202, 101 * 101 + 200)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for n_x in range(101):\n        for n_y in range(101):\n            print(n_x + 1, 202 - n_y, edge[n_x][n_y])\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\n\"\"\"\nax + by + c という距離をたくさん作れる\n全ての(a,b)に対して作るとしてよい（cを大きくすれば無視できるので）\n悪さをしない範囲の最小のcを選ぶ\nそれで上手くいっているかを検証\n\"\"\"\n\nU = 2\nA,B = map(int,input().split())\nD = np.array([input().rstrip().split() for _ in range(A)], dtype=np.int64)\n\nax = np.arange(U+1)[:,None] * np.arange(1,A+1)[None,:] # (U+1, A)\nby = np.arange(U+1)[:,None] * np.arange(1,B+1)[None,:] # (U+1, B)\naxby = ax[:,:,None,None] + by[None,None,:,:] # (U+1,A,U+1,B)\n\nc = (D[None,:,None,:] - axby).max(axis = 3).max(axis = 1) # (U+1,U+1)\nc *= (c > 0)\n\nD2 = (axby + c[:,None,:,None]).min(axis = 2).min(axis = 0) # (A,B)\n\nif (D != D2).any():\n    print('Impossible')\n    exit()\n\n# ax + by + c[a,b] という1次式が距離になるようなグラフを作成\n\ngraph = []\nfor a in range(U+1):\n    for b in range(U+1):\n        graph.append((1+a, (U+2) + b, c[a,b]))\nfor a in range(U):\n    graph.append((a+1,a+2,'X'))\nfor b in range(U,0,-1):\n    graph.append((U+2+b,U+1+b,'Y'))\n\nstart = 0\ngoal = U+1\n\nprint('Possible')"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    # 番兵を立てる\n    for tr in t:\n        tr.append(tr[-1])\n    t.append(t[-1])\n    #p2D(t)\n    edge = [[-1] * 101 for _ in range(101)]\n    hp = []\n    for i in range(h):\n        for j in range(w):\n            tij = t[i][j]\n            min_number_x = t[i + 1][j] - tij\n            min_number_y = t[i][j + 1] - tij\n            if min_number_x < 0 or min_number_y < 0:\n                impossible()\n            diff = tij - min_number_x * (i + 1) - min_number_y * (j + 1)\n            heappush(hp, [diff, i, j, min_number_x, min_number_y])\n    number_edges = 200\n    while hp:\n        diff, i, j, min_number_x, min_number_y = heappop(hp)\n        x, y = i + 1, j + 1\n        tij = t[i][j]\n        candi = []\n        for number_x in range(min_number_x, 101):\n            if x * number_x > tij: break\n            for number_y in range(min_number_y, 101):\n                sum_xy = x * number_x + y * number_y\n                if sum_xy > tij: break\n                candi.append([sum_xy, number_x, number_y])\n        for sum_xy, number_x, number_y in sorted(candi, reverse=True):\n            diff = tij - sum_xy\n            if edge[number_x][number_y] == -1:\n                edge[number_x][number_y] = diff\n                number_edges += 1\n                break\n            if edge[number_x][number_y] == diff:\n                break\n        else:\n            impossible()\n    #p2D(edge)\n    print(202, number_edges)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for number_x in range(101):\n        for number_y in range(101):\n            diff = edge[number_x][number_y]\n            if diff == -1: continue\n            print(number_x + 1, 202 - number_y, diff)\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "a, b = map(int, input().split())\ndistances = [list(map(int, input().split())) for _ in range(a)]\nn = 202\nm = 0\ng = [[] for _ in range(n)]\nfor i in range(100):\n    g[i].append((i + 1, 'X'))\n    m += 1\nfor i in range(100):\n    g[i + 101].append((i + 102, 'Y'))\n    m += 1\nfor p in range(0, 101):\n    for q in range(0, 101):\n        r = -10000000\n        for i in range(a):\n            for j in range(b):\n                r = max(r, distances[i][j] - p * (i + 1) - q * (j + 1))\n        if r >= 0:\n            g[p].append((n - q - 1, r))\n            m += 1\nfor i in range(a):\n    for j in range(b):\n        d = [float('inf')] * n\n        d[0] = 0\n        s = [0]\n        while s:\n            p = s.pop()\n            for to, dist in g[p]:\n                if dist == 'X':\n                    dist = i + 1\n                elif dist == 'Y':\n                    dist = j + 1\n                s.append(to)\n                d[to] = min(d[to], d[p] + dist)\n        if d[-1] != distances[i][j]:\n            print('Impossible')\n            exit(0)\nprint('Possible')\nprint(n, m)\nfor i in range(n):\n    for node, dist in g[i]:\n        print(i + 1, node + 1, dist)\nprint(1, n)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\n\"\"\"\nax + by + c という距離をたくさん作れる\n全ての(a,b)に対して作るとしてよい（cを大きくすれば無視できるので）\n悪さをしない範囲の最小のcを選ぶ\nそれで上手くいっているかを検証\n\"\"\"\n\nU = 100\nA,B = map(int,input().split())\nD = np.array([input().rstrip().split() for _ in range(A)], dtype=np.int64)\n\nax = np.arange(U+1)[:,None] * np.arange(1,A+1)[None,:] # (U+1, A)\nby = np.arange(U+1)[:,None] * np.arange(1,B+1)[None,:] # (U+1, B)\naxby = ax[:,:,None,None] + by[None,None,:,:] # (U+1,A,U+1,B)\n\nc = (D[None,:,None,:] - axby).max(axis = 3).max(axis = 1) # (U+1,U+1)\nc *= (c > 0)\n\nD2 = (axby + c[:,None,:,None]).min(axis = 2).min(axis = 0) # (A,B)\n\nif (D != D2).any():\n    print('Impossible')\n    exit()\n\n# ax + by + c[a,b] という1次式が距離になるようなグラフを作成\n\ngraph = []\nfor a in range(U+1):\n    for b in range(U+1):\n        graph.append((1+a, (U+2) + b, c[a,b]))\nfor a in range(U):\n    graph.append((a+1,a+2,'X'))\nfor b in range(U,0,-1):\n    graph.append((U+2+b,U+1+b,'Y'))\n\nstart = 0\ngoal = U+1\n\nprint('Possible')\nprint(2*(U+1), len(graph))\nfor e in graph:\n    print(*e)\nprint(start,goal)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef solve(x_max, y_max, d):\n\n    c_table = [[-1] * 100 for _ in range(100)]\n\n    for a in range(100):\n        c_table_a = c_table[a]\n        for x in range(x_max):\n            ax = a * (x + 1)\n            dx = d[x]\n            for b in range(100):\n                c = -1\n                for y in range(y_max):\n                    c = max(c, dx[y] - ax - b * (y + 1))\n                c_table_a[b] = max(c_table_a[b], c)\n\n    ab_max = 0\n    c_set = {}\n    for x in range(x_max):\n        dx = d[x]\n        for y in range(y_max):\n            dxy = d[x][y]\n            f = False\n            for a in range(100):\n                c_table_a = c_table[a]\n                ax = a * (x + 1)\n                for b in range(100):\n                    if dxy == ax + b * (y + 1) + c_table_a[b]:\n                        ab_max = max(ab_max, a, b)\n                        c_set[(a, b)] = c_table_a[b]\n                        f = True\n                        break\n                if f: break\n            if not f:\n                print('Impossible')\n                return\n\n\n    print('Possible')\n    print('{} {}'.format((ab_max + 1) * 2, ab_max * 2 + len(c_set)))\n    for i in range(ab_max):\n        print('{} {} X'.format(i + 1, i + 2))\n    for i in range(ab_max):\n        print('{} {} Y'.format(ab_max + i + 3, ab_max + i + 2))\n    for k, c in c_set.items():\n        print('{} {} {}'.format(k[0] + 1, k[1] + ab_max + 2, c))\n    print('{} {}'.format(1, ab_max + 2))\n\n\ndef main():\n    A, B = input().split()\n    A = int(A)\n    B = int(B)\n    d = [list(map(int, input().split())) for _ in range(A)]\n\n    solve(A, B, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    edge = [[0] * 101 for _ in range(101)]\n\n    # XとYをつなぐ辺の作成\n    for n_x in range(101):\n        for n_y in range(101):\n            cost = 0\n            for i in range(h):\n                for j in range(w):\n                    x, y = i + 1, j + 1\n                    cur_cost = t[i][j] - x * n_x - y * n_y\n                    if cur_cost > cost: cost = cur_cost\n            edge[n_x][n_y] = cost\n    p2D(edge)\n\n    # 条件を満たしているかのチェック\n    for i in range(h):\n        for j in range(w):\n            x, y = i + 1, j + 1\n            tij = t[i][j]\n            min_dist = 1000\n            for n_x in range(101):\n                for n_y in range(101):\n                    dist = x * n_x + y * n_y + edge[n_x][n_y]\n                    if dist < min_dist: min_dist = dist\n            if tij != min_dist: impossible()\n\n    print(\"Possible\")\n    print(202, 101 * 101)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for n_x in range(101):\n        for n_y in range(101):\n            print(n_x + 1, 202 - n_y, edge[n_x][n_y])\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\n\"\"\"\nax + by + c という距離をたくさん作れる\n全ての(a,b)に対して作るとしてよい（cを大きくすれば無視できるので）\n悪さをしない範囲の最小のcを選ぶ\nそれで上手くいっているかを検証\n\"\"\"\n\nU = 2\nA,B = map(int,input().split())\nD = np.array([input().rstrip().split() for _ in range(A)], dtype=np.int64)\n\nax = np.arange(U+1)[:,None] * np.arange(1,A+1)[None,:] # (U+1, A)\nby = np.arange(U+1)[:,None] * np.arange(1,B+1)[None,:] # (U+1, B)\naxby = ax[:,:,None,None] + by[None,None,:,:] # (U+1,A,U+1,B)\n\nc = (D[None,:,None,:] - axby).max(axis = 3).max(axis = 1) # (U+1,U+1)\nc *= (c > 0)\n\nD2 = (axby + c[:,None,:,None]).min(axis = 2).min(axis = 0) # (A,B)\n\nif (D != D2).any():\n    print('Impossible')\n    exit()\n\n# ax + by + c[a,b] という1次式が距離になるようなグラフを作成\n\ngraph = []\nfor a in range(U+1):\n    for b in range(U+1):\n        graph.append((1+a, (U+2) + b, c[a,b]))\nfor a in range(U):\n    graph.append((a+1,a+2,'X'))\nfor b in range(U,0,-1):\n    graph.append((U+2+b,U+1+b,'Y'))\n\nstart = 0\ngoal = U+1\n\nprint('Possible')\nprint(2*(U+1), len(graph))\nfor e in graph:\n    print(*e)\nprint(start,goal)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\n\"\"\"\nax + by + c という距離をたくさん作れる\n全ての(a,b)に対して作るとしてよい（cを大きくすれば無視できるので）\n悪さをしない範囲の最小のcを選ぶ\nそれで上手くいっているかを検証\n\"\"\"\n\nU = 2\nA,B = map(int,input().split())\nD = np.array([input().rstrip().split() for _ in range(A)], dtype=np.int64)\n\nax = np.arange(U+1)[:,None] * np.arange(1,A+1)[None,:] # (U+1, A)\nby = np.arange(U+1)[:,None] * np.arange(1,B+1)[None,:] # (U+1, B)\naxby = ax[:,:,None,None] + by[None,None,:,:] # (U+1,A,U+1,B)\n\nc = (D[None,:,None,:] - axby).max(axis = 3).max(axis = 1) # (U+1,U+1)\nc *= (c > 0)\n\nD2 = (axby + c[:,None,:,None]).min(axis = 2).min(axis = 0) # (A,B)\n\nif (D != D2).any():\n    print('Impossible')\n    exit()\n\n# ax + by + c[a,b] という1次式が距離になるようなグラフを作成\n\ngraph = []\nfor a in range(U+1):\n    for b in range(U+1):\n        graph.append((1+a, (U+2) + b, c[a,b]))\nfor a in range(U):\n    graph.append((a+1,a+2,'X'))\nfor b in range(U,0,-1):\n    graph.append((U+2+b,U+1+b,'Y'))\n\nstart = 1\ngoal = U+2\n\nprint('Possible')\nprint(2*(U+1), len(graph))\nfor e in graph:\n    print(*e)\nprint(start,goal)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef solve(x_max, y_max, d):\n\n    for x in range(1, x_max + 1):\n        p = 0\n        for y in range(1, y_max + 1):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if y < y_max:\n                if d[x][y] * 2 < p + d[x][y + 1]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    for y in range(1, y_max + 1):\n        p = 0\n        for x in range(1, x_max + 1):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if x < x_max:\n                if d[x][y] * 2 < p + d[x + 1][y]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    for x in range(1, x_max):\n        for y in range(1, y_max):\n            if d[x][y] * 2 < d[x - 1][y - 1] + d[x + 1][y + 1]:\n                print('Impossible')\n                return\n\n\n    ab_max = 1\n    c_set = {}\n    c_set[(0, 0)] = d[x_max][y_max]\n    for x in range(x_max - 1, 0, -1):\n        a = d[x + 1][y_max] - d[x][y_max]\n        c_set[(a, 0)] = d[x][y_max] - a * x\n    for y in range(y_max - 1, 0, -1):\n        b = d[x_max][y + 1] - d[x_max][y]\n        c_set[(0, b)] = d[x_max][y] - b * y\n    for x in range(x_max - 1, 0, -1):\n        for y in range(y_max - 1, 0, -1):\n            a = d[x + 1][y] - d[x][y]\n            b = d[x][y + 1] - d[x][y]\n            delta = d[x + 1][y + 1] - d[x][y]\n            while a + b < delta:\n                if a < d[x][y] - d[x - 1][y]:\n                    a += 1\n                elif b < d[x][y] - d[x][y - 1]:\n                    b += 1\n                else:\n                    print('Impossible')\n                    return\n            c = d[x][y] - a * x - b * y\n            c_set[(a, b)] = c\n            ab_max = max(ab_max, a, b)\n\n\n    print('Possible')\n    print('{} {}'.format((ab_max + 1) * 2, ab_max * 2 + len(c_set)))\n    for i in range(ab_max):\n        print('{} {} X'.format(i + 1, i + 2))\n    for i in range(ab_max):\n        print('{} {} Y'.format(ab_max + i + 3, ab_max + i + 2))\n    for k, c in c_set.items():\n        print('{} {} {}'.format(k[0] + 1, k[1] + ab_max + 2, c))\n    print('{} {}'.format(1, ab_max + 2))\n\n\ndef main():\n    A, B = input().split()\n    A = int(A)\n    B = int(B)\n    d = [[0] + list(map(int, input().split())) for _ in range(A)]\n    d = [[0] * (B + 1)] + d\n\n    solve(A, B, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    for i in range(h - 1):\n        if t[i][w - 1] > t[i + 1][w - 1]:\n            impossible()\n    edges = [[-1] * 201 for _ in range(201)]\n    number_edge = 200\n    for i in range(h):\n        for j in range(w - 1):\n            x, y = i + 1, j + 1\n            if i + 1 == h:\n                number_x = 0\n            else:\n                number_x = t[i + 1][j] - t[i][j]\n            if j + 1 == w:\n                number_y = 0\n            else:\n                number_y = t[i][j + 1] - t[i][j]\n            if number_x < 0 or number_y < 0:\n                impossible()\n            cost = t[i][j] - x * number_x - y * number_y\n            if cost < 0:\n                impossible()\n            u, v = number_x, 200 - number_y\n            if edges[u][v] == -1:\n                edges[u][v] = cost\n                number_edge += 1\n            elif edges[u][v] != cost:\n                impossible()\n\n    print(\"Possible\")\n    print(201, number_edge)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(101, 201):\n        print(u, u + 1, \"Y\")\n    for i in range(201):\n        for j in range(201):\n            cost = edges[i][j]\n            if cost != -1:\n                print(i + 1, j + 1, cost)\n    print(1, 201)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN = 101\n\nA, B = map(int, input().split())\nD = [([0] * (B+1))] + [[0] + list(map(int, input().split())) for _ in range(A)]\n\nL = [\n  [ max(max(D[x][y] - x * numx - y * numy for y in range(1, B+1)) for x in range(1, A+1)) for numy in range(0, N) ]\n  for numx in range(0, N)\n]\n\nif all( \n  all(D[x][y] == \n      min(min(L[numx][numy] + x * numx + y * numy \n              for numy in range(0, N)) for numx in range(0, N)) \n      for y in range(1, B+1)\n  ) for x in range(1, A+1) ):\n  print \"Possible\"\n  print \"%d %d\" % (2*N, (N-1)*2+N**2)\n  for i in range(1, N):\n    print \"%d %d X\" % (i, i+1)\n    print \"%d %d Y\" % (N+i, N+i+1)\n  for numx in range(N):\n    for numy in range(N):\n      print \"%d %d %d\" % (numx, 2*N-numy-1, max(L[numx][numy], 0))\n  print \"%d %d\" % (1, 2*N)\nelse:\n  print \"Impossible\""
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    edge = [[0] * 101 for _ in range(101)]\n\n    # XとYをつなぐ辺の作成\n    for n_x in range(101):\n        for n_y in range(101):\n            cost = 0\n            for i in range(h):\n                for j in range(w):\n                    x, y = i + 1, j + 1\n                    cur_cost = t[i][j] - x * n_x - y * n_y\n                    if cur_cost > cost: cost = cur_cost\n            edge[n_x][n_y] = cost\n    p2D(edge)\n\n    # 条件を満たしているかのチェック\n    for i in range(h):\n        for j in range(w):\n            x, y = i + 1, j + 1\n            tij = t[i][j]\n            min_dist = 1000\n            for n_x in range(101):\n                for n_y in range(101):\n                    dist = x * n_x + y * n_y + edge[n_x][n_y]\n                    if dist < min_dist: min_dist = dist\n            if tij != min_dist: impossible()\n\n    print(\"Possible\")\n    print(202, 101 * 101 + 200)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for n_x in range(101):\n        for n_y in range(101):\n            print(n_x + 1, 202 - n_y, edge[n_x][n_y])\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "a, b = map(int, input().split())\ndistances = [list(map(int, input().split())) for _ in range(a)]\ng = [[] for _ in range(201)]\nm = 0\nfor i in range(100):\n    g[i].append((i + 1, 'X'))\n    m += 1\nfor i in range(100):\n    g[i + 100].append((i + 101, 'Y'))\n    m += 1\nfor p in range(0, 101):\n    for q in range(0, 101):\n        r = -10000000\n        for i in range(a):\n            for j in range(b):\n                r = max(r, distances[i][j] - p * (i + 1) - q * (j + 1))\n        if r >= 0:\n            g[p].append((200 - q, r))\n            m += 1\nfor i in range(a):\n    for j in range(b):\n        d = [float('inf')] * 201\n        d[0] = 0\n        s = [0]\n        while s:\n            p = s.pop()\n            for to, dist in g[p]:\n                if dist == 'X':\n                    dist = i + 1\n                elif dist == 'Y':\n                    dist = j + 1\n                s.append(to)\n                d[to] = min(d[to], d[p] + dist)\n        if d[-1] != distances[i][j]:\n            print('Impossible')\n            exit(0)\nprint(201, m)\nfor i in range(201):\n    for node, dist in g[i]:\n        print(i + 1, node + 1, dist)\nprint(1, 201)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef solve(a, b, d):\n\n    for x in range(a):\n        p = 0\n        for y in range(b):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if y < b - 1:\n                if d[x][y] * 2 < p + d[x][y + 1]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    for y in range(b):\n        p = 0\n        for x in range(a):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if x < a - 1:\n                if d[x][y] * 2 < p + d[x + 1][y]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    c_max = 1\n    c_set = set()\n    for x in range(a - 1):\n        for y in range(b - 1):\n            l = d[x + 1][y] - d[x][y]\n            m = d[x][y + 1] - d[x][y]\n            n = d[x][y] - l * (x + 1) - m * (y + 1)\n            c_max = max(c_max, l, m)\n            c_set.add((l, m, n))\n\n    for x in range(a - 1):\n        l = d[x + 1][b - 1] - d[x][b - 1]\n        n = d[x][b - 1] - l * (x + 1)\n        c_max = max(c_max, l)\n        c_set.add((l, 0, n))\n\n    for y in range(b - 1):\n        m = d[a - 1][y + 1] - d[a - 1][y]\n        n = d[a - 1][y] - m * (y + 1)\n        c_max = max(c_max, m)\n        c_set.add((0, m, n))\n\n\n    print('Possible')\n    print('{} {}'.format((c_max + 1) * 2, c_max * 2 + len(c_set)))\n    for i in range(c_max):\n        print('{} {} X'.format(i + 1, i + 2))\n    for i in range(c_max):\n        print('{} {} Y'.format(c_max + i + 3, c_max + i + 2))\n    for t in c_set:\n        print('{} {} {}'.format(t[0] + 1, t[1] + c_max + 2, t[2]))\n    print('{} {}'.format(1, c_max + 2))\n\n\ndef main():\n    a, b = input().split()\n    a = int(a)\n    b = int(b)\n    d = [list(map(int, input().split())) for _ in range(a)]\n\n\n    solve(a, b, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    # 番兵を立てる\n    for tr in t:\n        tr.append(tr[-1])\n    t.append(t[-1])\n    # p2D(t)\n    edge = [[-1] * 101 for _ in range(101)]\n    hp = []\n    for i in range(h):\n        for j in range(w):\n            tij = t[i][j]\n            min_number_x = t[i + 1][j] - tij\n            min_number_y = t[i][j + 1] - tij\n            diff = tij - min_number_x * (i + 1) - min_number_y * (j + 1)\n            if min_number_x < 0 or min_number_y < 0 or diff < 0:\n                impossible()\n            heappush(hp, [diff, i, j, min_number_x, min_number_y])\n    number_edges = 200\n    while hp:\n        diff, i, j, min_number_x, min_number_y = heappop(hp)\n        x, y = i + 1, j + 1\n        tij = t[i][j]\n        candi = []\n        for number_x in range(min_number_x, 101):\n            if x * number_x > tij: break\n            for number_y in range(min_number_y, 101):\n                sum_xy = x * number_x + y * number_y\n                if sum_xy > tij: break\n                candi.append([sum_xy, number_x, number_y])\n        for sum_xy, number_x, number_y in sorted(candi, reverse=True):\n            diff = tij - sum_xy\n            if edge[number_x][number_y] == -1:\n                edge[number_x][number_y] = diff\n                number_edges += 1\n                break\n            if edge[number_x][number_y] == diff:\n                break\n        else:\n            impossible()\n    # p2D(edge)\n    print(\"Possible\")\n    print(202, number_edges)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for number_x in range(101):\n        for number_y in range(101):\n            diff = edge[number_x][number_y]\n            if diff == -1: continue\n            print(number_x + 1, 202 - number_y, diff)\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "a, b = map(int, input().split())\ndistances = [list(map(int, input().split())) for _ in range(a)]\ng = [[] for _ in range(201)]\nfor i in range(100):\n    g[i].append((i + 1, 'X'))\nfor i in range(100):\n    g[i + 100].append((i + 101, 'Y'))\nfor p in range(0, 101):\n    for q in range(0, 101):\n        r = -10000000\n        for i in range(a):\n            for j in range(b):\n                r = max(r, distances[i][j] - p * (i + 1) - q * (j + 1))\n        if r >= 0:\n            g[p].append((200 - q, r))\nfor i in range(a):\n    for j in range(b):\n        d = [float('inf')] * 201\n        d[0] = 0\n        s = [0]\n        while s:\n            p = s.pop()\n            for to, dist in g[p]:\n                if dist == 'X':\n                    dist = i + 1\n                elif dist == 'Y':\n                    dist = j + 1\n                s.append(to)\n                d[to] = min(d[to], d[p] + dist)\n        if d[-1] != distances[i][j]:\n            print('Impossible')\n            exit(0)\nfor i in range(201):\n    for node, dist in g[i]:\n        print(i + 1, node + 1, dist)\nprint(1, 201)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef solve(a, b, d):\n\n    for x in range(a):\n        p = 0\n        for y in range(b):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if y < b - 1:\n                if d[x][y] * 2 < p + d[x][y + 1]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    for y in range(b):\n        p = 0\n        for x in range(a):\n            if d[x][y] < p:\n                print('Impossible')\n                return\n            if x < a - 1:\n                if d[x][y] * 2 < p + d[x + 1][y]:\n                    print('Impossible')\n                    return\n            p = d[x][y]\n\n    c_max = 1\n    c_set = {}\n    for x in range(a - 1, 0, -1):\n        for y in range(b - 1, 0, -1):\n            l = d[x][y] - d[x - 1][y]\n            m = d[x - 1][y] - d[x - 1][y - 1]\n            n = d[x][y] - l * (x + 1) - m * (y + 1)\n            c_max = max(c_max, l, m)\n            k = (l, m)\n            if k in c_set.keys():\n                n = min(n, c_set[k])\n            c_set[k] = n\n\n    if 1 < a and 1 < b:\n        m = d[a - 1][1] - d[a - 1][0]\n        l = d[a - 1][0] - d[a - 2][0]\n        n = d[a - 1][1] - l * a - m\n        c_max = max(c_max, l, m)\n        k = (l, m)\n        if k in c_set.keys():\n            n = min(n, c_set[k])\n        c_set[k] = n\n\n\n    print('Possible')\n    print('{} {}'.format((c_max + 1) * 2, c_max * 2 + len(c_set)))\n    for i in range(c_max):\n        print('{} {} X'.format(i + 1, i + 2))\n    for i in range(c_max):\n        print('{} {} Y'.format(c_max + i + 3, c_max + i + 2))\n    for k, n in c_set.items():\n        print('{} {} {}'.format(k[0] + 1, k[1] + c_max + 2, n))\n    print('{} {}'.format(1, c_max + 2))\n\n\ndef main():\n    a, b = input().split()\n    a = int(a)\n    b = int(b)\n    d = [list(map(int, input().split())) for _ in range(a)]\n\n\n    solve(a, b, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "a, b = map(int, input().split())\ndistances = [list(map(int, input().split())) for _ in range(a)]\ng = [[] for _ in range(201)]\nm = 0\nfor i in range(100):\n    g[i].append((i + 1, 'X'))\n    m += 1\nfor i in range(100):\n    g[i + 100].append((i + 101, 'Y'))\n    m += 1\nfor p in range(0, 101):\n    for q in range(0, 101):\n        r = -10000000\n        for i in range(a):\n            for j in range(b):\n                r = max(r, distances[i][j] - p * (i + 1) - q * (j + 1))\n        if r >= 0:\n            g[p].append((200 - q, r))\n            m += 1\nfor i in range(a):\n    for j in range(b):\n        d = [float('inf')] * 201\n        d[0] = 0\n        s = [0]\n        while s:\n            p = s.pop()\n            for to, dist in g[p]:\n                if dist == 'X':\n                    dist = i + 1\n                elif dist == 'Y':\n                    dist = j + 1\n                s.append(to)\n                d[to] = min(d[to], d[p] + dist)\n        if d[-1] != distances[i][j]:\n            print('Impossible')\n            exit(0)\nprint('Possible')\nprint(201, m)\nfor i in range(201):\n    for node, dist in g[i]:\n        print(i + 1, node + 1, dist)\nprint(1, 201)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef impossible():\n    print(\"Impossible\")\n    exit()\n\ndef main():\n    h, w = map(int, input().split())\n    t = [list(map(int, input().split())) for _ in range(h)]\n    # 番兵を立てる\n    for tr in t:\n        tr.append(tr[-1])\n    t.append(t[-1])\n    # p2D(t)\n    edge = [[-1] * 101 for _ in range(101)]\n    hp = []\n    for i in range(h):\n        for j in range(w):\n            tij = t[i][j]\n            min_number_x = t[i + 1][j] - tij\n            min_number_y = t[i][j + 1] - tij\n            diff = tij - min_number_x * (i + 1) - min_number_y * (j + 1)\n            if min_number_x < 0 or min_number_y < 0 or diff < 0:\n                impossible()\n            heappush(hp, [diff, i, j, min_number_x, min_number_y])\n    number_edges = 200\n    number_ab = [[[-1, -1] for _ in range(w)] for _ in range(h)]\n    while hp:\n        diff, i, j, min_number_x, min_number_y = heappop(hp)\n        x, y = i + 1, j + 1\n        tij = t[i][j]\n        candi = []\n        for number_x in range(min_number_x, 101):\n            if x * number_x > tij: break\n            for number_y in range(min_number_y, 101):\n                sum_xy = x * number_x + y * number_y\n                if sum_xy > tij: break\n                candi.append([sum_xy, number_x, number_y])\n        for sum_xy, number_x, number_y in sorted(candi, reverse=True):\n            diff = tij - sum_xy\n            if edge[number_x][number_y] == -1:\n                edge[number_x][number_y] = diff\n                number_edges += 1\n                number_ab[i][j] = [number_x, number_y]\n                break\n            if edge[number_x][number_y] == diff:\n                number_ab[i][j] = [number_x, number_y]\n                break\n        else:\n            impossible()\n    #p2D(number_ab)\n    # p2D(edge)\n    for i in range(h):\n        for j in range(w):\n            tij = t[i][j]\n            x, y = i + 1, j + 1\n            for i0 in range(h):\n                for j0 in range(w):\n                    [number_x, number_y] = number_ab[i][j]\n                    if number_x * x + number_y * y + edge[number_x][number_y] < tij:\n                        impossible()\n    print(\"Possible\")\n    print(202, number_edges)\n    for u in range(1, 101):\n        print(u, u + 1, \"X\")\n    for u in range(102, 202):\n        print(u, u + 1, \"Y\")\n    for number_x in range(101):\n        for number_y in range(101):\n            diff = edge[number_x][number_y]\n            if diff == -1: continue\n            print(number_x + 1, 202 - number_y, diff)\n    print(1, 202)\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn main() {\n    input!(h: usize, w: usize, d: [[usize; w]; h]);\n    const MAX: usize = 100;\n    let z: Vec<Vec<usize>> = (0..=MAX)\n        .map(|i| {\n            (0..=MAX)\n                .map(|j| {\n                    iproduct!(0..h, 0..w)\n                        .map(|(x, y)| d[x][y].saturating_sub(i * (x + 1) + j * (y + 1)))\n                        .max()\n                        .unwrap()\n                })\n                .collect()\n        })\n        .collect();\n\n    if iproduct!(0..h, 0..w).any(|(x, y)| {\n        iproduct!(0..=MAX, 0..=MAX).all(|(i, j)| i * (x + 1) + j * (y + 1) + z[i][j] != d[x][y])\n    }) {\n        println!(\"Impossible\");\n        std::process::exit(0);\n    }\n    let mut edges = vec![];\n    let vertex_count = 2 * MAX + 2;\n    (0..MAX).for_each(|i| edges.push((i, i + 1, Label::X)));\n    (0..MAX).for_each(|i| edges.push((vertex_count - 2 - i, vertex_count - 1 - i, Label::Y)));\n    for (i, j) in iproduct!(0..=MAX, 0..=MAX) {\n        edges.push((i, vertex_count - 1 - j, Label::Integer(z[i][j])));\n    }\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, edge_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    // println!(\"{} {} {}\", y_cnt, x_cnt, ret);\n    ret\n}\n\nfn calc_use_node(y_cnt: usize, x_cnt: usize, c: i32, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>, use_node: &mut Vec<Vec<bool>>) -> usize {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            if visit[i][j] { continue; }\n            let v = (i as i32 + 1) * y_cnt as i32 + (j as i32 + 1) * x_cnt as i32 + c;\n            if v == ds[i][j] {\n                ret += 1;\n                visit[i][j] = true;\n                use_node[y_cnt][x_cnt] = true;\n                // println!(\"{} {} {} {} {} {}\", y_cnt, x_cnt, i, j, v, c);\n            }\n        }\n    }\n    ret\n}\n\nfn add_xy_edge(g: &mut Graph, e: &mut usize, from: usize, y_cnt: usize, x_cnt: usize, node_map: &mut HashMap<(usize, usize), usize>) {\n    if y_cnt == 0 && x_cnt == 0 { return; }\n    if g[from].len() == 1 { return; }\n    let mut ny_cnt = y_cnt;\n    let mut nx_cnt = x_cnt;\n    let cost;\n    if y_cnt != 0 {\n        ny_cnt -= 1;\n        cost = -1;\n    } else {\n        nx_cnt -= 1;\n        cost = -2;\n    }\n    let node = (ny_cnt, nx_cnt);\n    if !node_map.contains_key(&node) {\n        let to = g.len();\n        node_map.insert(node, to);\n        g.push(vec![]);\n    }\n    let to = *node_map.get(&node).unwrap();\n    add_uni_edge(g, e, from, to, cost);\n    add_xy_edge(g, e, to, ny_cnt, nx_cnt, node_map);\n}\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut visit = vec![vec![false; a]; b];\n    let mut min_c = vec![vec![0 as i32; 101]; 101];\n    let mut use_node = vec![vec![false; 101]; 101];\n    let mut total = 0;\n    // for i in 0..101 {\n    for i in 0..3 {\n        for x_cnt in 0..i {\n            let y_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n        for y_cnt in 0..i+1 {\n            let x_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n    }\n    // println!(\"{}\", total);\n    if total != a * b {\n        println!(\"Impossible\");\n        return;\n    }\n    let mut g = graph_new(1);\n    let mut node_map = HashMap::<(usize, usize), usize>::new();\n    let mut e = 0;\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            if !use_node[y_cnt][x_cnt] { continue; }\n            let to = g.len();\n            g.push(vec![]);\n            node_map.insert((y_cnt, x_cnt), to);\n            add_uni_edge(&mut g, &mut e, 0, to, min_c[y_cnt][x_cnt]);\n            add_xy_edge(&mut g, &mut e, to, y_cnt, x_cnt, &mut node_map);\n        }\n    }\n    assert!(g.len() <= 300);\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"X\"),\n                -2 => print!(\"Y\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"1 2\")\n}"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    // for i in 0..ans.len()-1 {\n    //     for j in 0..ans[i].len()-1 {\n    //         if ans[i][j].1 < ans[i][j+1].1 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //         if ans[i][j].0 < ans[i+1][j].0 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //     }\n    // }\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                // print!(\"{} \", calc(x as i32, y as i32));\n                if d[x-1][y-1] != calc(x as i32, y as i32) {\n                    printer.println(im);\n                    return;\n                }\n            }\n            // println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(MAX_D + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..MAX_D {\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for from in 0..(MAX_D + 1) {\n        for to in 0..(MAX_D + 1) {\n            if from + to > MAX_D {\n                continue;\n            }\n            let mut edge_cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    if edge_cost + base_cost < dist[i][j] {\n                        edge_cost = dist[i][j] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edge.push((xs[from], ys[to], edge_cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    assert!(dist[i][j] <= base_cost + edge_cost);\n                    if base_cost + edge_cost == dist[i][j] { used[i][j] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    if ret > 100 { return ret; }\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            if v == ret { visit[i][j] = true; }\n        }\n    }\n    ret\n}\n\nfn x_node(i: usize) -> usize { i }\nfn y_node(i: usize) -> usize { i + 110 }\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut g = graph_new(300);\n    let mut e = 0;\n    for i in 0..101 {\n        add_uni_edge(&mut g, &mut e, x_node(i), x_node(i + 1), -1);\n        add_uni_edge(&mut g, &mut e, y_node(i + 1), y_node(i), -2);\n    }\n    let mut visit = vec![vec![false; a]; b];\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            let c = calc_min_c(y_cnt, x_cnt, &ds, &mut visit);\n            if c <= 100 { add_uni_edge(&mut g, &mut e, x_node(x_cnt), y_node(y_cnt), c); }\n        }\n    }\n    for y in 0..b {\n        for x in 0..a {\n            if !visit[y][x] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"Y\"),\n                -2 => print!(\"X\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"{} {}\", x_node(0), y_node(0));\n}"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let d: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = 300;\n    let max_d = 100;\n    let max_c = 100;\n\n    let mut char_edge = Vec::new();\n    let mut xs = vec![0; max_d + 1];\n    let mut ys = vec![0; max_d + 1];\n    xs[0] = 0;\n    ys[0] = n - 1;\n    for i in 0..max_d {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i + 1], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for i in 0..(max_d + 1) {\n        for j in 0..(max_d + 1) {\n            if i + j > max_d {\n                continue;\n            }\n            let mut c = 0;\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    if c + f < d[x][y] {\n                        c = d[x][y] - f;\n                    }\n                }\n            }\n            if c > max_c {\n                continue;\n            }\n            int_edge.push((xs[i], ys[j], c));\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    assert!(d[x][y] <= f + c);\n                    if f + c == d[x][y] { used[x][y] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    // assert!(b != 1);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let ans = if b == 1 {\n        let mut ans = vec![vec![(0, 0, 0); 1]; a];\n        for i in 0..a-1 {\n            let ym = 0;\n            let xm = d[i+1][0]-d[i][0];\n            let c = d[i][0] - xm * (i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][0] = (xm, ym, c);\n        }\n        let i = a-1;\n        let ym = 0;\n        let xm = 0;\n        let c = d[i][0];\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][0] = (xm, ym, c);\n        \n        \n        ans\n    } else {\n        let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n        for i in 0..a-1 {\n            for j in 0..b-1 {\n                let ym = d[i][j+1]-d[i][j];\n                let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n                let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n                if xm < 0 || ym < 0 || c < 0 {\n                    // debug!((i, j, xm, ym, c));\n                    printer.println(im);\n                    return;\n                }\n                ans[i][j] = (xm, ym, c);\n            }\n        }\n        for j in 0..b-1 {\n            let i = a-1;\n            let ym = d[i][j+1]-d[i][j];\n            let xm = 0;\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n        ans\n    };\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n\n    // debug!(ls);\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                // print!(\"{} \", calc(x as i32, y as i32));\n                if d[x-1][y-1] != calc(x as i32, y as i32) {\n                    printer.println(im);\n                    return;\n                }\n            }\n            // println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    assert!(false);\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in iproduct!(0..=100, 0..=100) {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let cliff_size = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0.max(x.1) + 1))\n        .flatten()\n        .max()\n        .unwrap();\n    let vertex_count = cliff_size * 2;\n\n    let mut edges = vec![];\n    for i in 0..cliff_size - 1 {\n        edges.push((i, i + 1, Label::X));\n        edges.push((cliff_size + i, cliff_size + i + 1, Label::Y));\n    }\n    let mut ckd = vec![vec![false; cliff_size]; cliff_size];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[k][l] {\n            continue;\n        }\n        ckd[k][l] = true;\n        edges.push((k, 2 * cliff_size - 1 - l, Label::Integer(r)));\n    }\n    let edge_count = edges.len();\n\n    assert!(vertex_count <= 300);\n    if 300 < vertex_count {\n        err();\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn main() {\n    input!(h: usize, w: usize, d: [[usize; w]; h]);\n    const MAX: usize = 3;\n    let z: Vec<Vec<usize>> = (0..=MAX)\n        .map(|i| {\n            (0..=MAX)\n                .map(|j| {\n                    iproduct!(0..h, 0..w)\n                        .map(|(x, y)| d[x][y].saturating_sub(i * (x + 1) + j * (y + 1)))\n                        .max()\n                        .unwrap()\n                })\n                .collect()\n        })\n        .collect();\n\n    if iproduct!(0..h, 0..w).any(|(x, y)| {\n        iproduct!(0..=MAX, 0..=MAX).all(|(i, j)| i * (x + 1) + j * (y + 1) + z[i][j] != d[x][y])\n    }) {\n        println!(\"Impossible\");\n        std::process::exit(0);\n    }\n    let mut edges = vec![];\n    let vertex_count = 2 * MAX + 2;\n    (0..MAX).for_each(|i| edges.push((i, i + 1, Label::X)));\n    (0..MAX).for_each(|i| edges.push((vertex_count - 2 - i, vertex_count - 1 - i, Label::Y)));\n    for (i, j) in iproduct!(0..=MAX, 0..=MAX) {\n        edges.push((i, vertex_count - 1 - j, Label::Integer(z[i][j])));\n    }\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, edge_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(MAX_D + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..MAX_D {\n        char_edge.push((xs[i], xs[i + 1], 'X'));\n        char_edge.push((ys[i + 1], ys[i], 'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for from in 0..(MAX_D + 1) {\n        for to in 0..(MAX_D + 1) {\n            if from + to > MAX_D {\n                continue;\n            }\n            let mut edge_cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    if edge_cost + base_cost < dist[i][j] {\n                        edge_cost = dist[i][j] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edge.push((xs[from], ys[to], edge_cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    assert!(dist[i][j] <= base_cost + edge_cost);\n                    if base_cost + edge_cost == dist[i][j] { used[i][j] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    // assert!(b != 1);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let ans = if b == 1 {\n        let mut ans = vec![vec![(0, 0, 0); 1]; a];\n        for i in 0..a-1 {\n            let ym = 0;\n            let xm = d[i+1][0]-d[i][0];\n            let c = d[i][0] - xm * (i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][0] = (xm, ym, c);\n        }\n        let i = a-1;\n        let ym = 0;\n        let xm = 0;\n        let c = d[i][0];\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][0] = (xm, ym, c);\n        \n        \n        ans\n    } else {\n        let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n        for i in 0..a-1 {\n            for j in 0..b-1 {\n                let ym = d[i][j+1]-d[i][j];\n                let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n                let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n                if xm < 0 || ym < 0 || c < 0 {\n                    // debug!((i, j, xm, ym, c));\n                    printer.println(im);\n                    return;\n                }\n                ans[i][j] = (xm, ym, c);\n            }\n        }\n        for j in 0..b-1 {\n            let i = a-1;\n            let ym = d[i][j+1]-d[i][j];\n            let xm = 0;\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n        ans\n    };\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n\n    // debug!(ls);\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                // print!(\"{} \", calc(x as i32, y as i32));\n                if d[x-1][y-1] != calc(x as i32, y as i32) {\n                    printer.println(im);\n                    assert!(false);\n                    return;\n                }\n            }\n            // println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    \n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 201,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             print!(\"{} \", calc(x as i32, y as i32));\n    //         }\n    //         println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graph::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    printer.println(\"Possible\");\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nconst MAX_V: usize = 300;\nconst MAX_C: usize = 100;\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let table: Vec<Vec<usize>> = (0..a)\n        .map(|_| (0..b).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut edges = Vec::new();\n    let mut used = vec![vec![false; b]; a];\n    for x_count in 0..(MAX_C + 1) {\n        for y_count in 0..(MAX_C + 1) {\n            let from = x_count;\n            let to = MAX_V - 1 - y_count;\n\n            let mut cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if cost + base < table[i][j] {\n                        cost = table[i][j] - base;\n                    }\n                }\n            }\n            if cost > MAX_C {\n                continue;\n            }\n            edges.push((from, to, cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if base + cost == table[i][j] {\n                        used[i][j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    for i in 0..a {\n        for j in 0..b {\n            if !used[i][j] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", MAX_V, MAX_C * 2 + edges.len());\n    for i in 0..MAX_C {\n        println!(\"{} {} X\", i + 1, i + 2);\n        println!(\"{} {} Y\", MAX_V - i, MAX_V - i - 1);\n    }\n    for &(from, to, cost) in &edges {\n        println!(\"{} {} {}\", from + 1, to + 1, cost);\n    }\n    println!(\"1 {}\", MAX_V);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 201,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (i as i32 + 1);\n            if xm < 0 || ym < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (i+1) as i32;\n        if xm < 0 || ym < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    let mut g = Graph::new();\n    for vec in ans {\n        for (a, b, c) in vec {\n            g.add(a, b, c);\n        }\n    }\n    printer.println(\"Possible\");\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn main() {\n    input!(h: usize, w: usize, d: [[usize; w]; h]);\n    const MAX: usize = 100;\n    let z: Vec<Vec<usize>> = (0..=MAX)\n        .map(|i| {\n            (0..=MAX)\n                .map(|j| {\n                    iproduct!(0..h, 0..w)\n                        .map(|(x, y)| d[x][y].saturating_sub(i * (x + 1) + j * (y + 1)))\n                        .max()\n                        .unwrap()\n                })\n                .collect()\n        })\n        .collect();\n\n    if iproduct!(0..h, 0..w).any(|(x, y)| {\n        iproduct!(0..=MAX, 0..=MAX).all(|(i, j)| i * (x + 1) + j * (y + 1) + z[i][j] != d[x][y])\n    }) {\n        println!(\"Impossible\");\n        std::process::exit(0);\n    }\n    let vertex_count = 2 * MAX + 2;\n    let edges: Vec<_> = (0..MAX)\n        .map(|i| (i, i + 1, Label::X))\n        .chain((0..MAX).map(|i| (vertex_count - 2 - i, vertex_count - 1 - i, Label::Y)))\n        .chain(\n            iproduct!(0..=MAX, 0..=MAX)\n                .map(|(i, j)| (i, vertex_count - 1 - j, Label::Integer(z[i][j]))),\n        )\n        .collect();\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>) -> i32 {\n    let mut ret = -1;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    if ret < 0 || 100 < ret { return ret; }\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            if v == ret { visit[i][j] = true; }\n        }\n    }\n    ret\n}\n\nfn x_node(i: usize) -> usize { i }\nfn y_node(i: usize) -> usize { i + 110 }\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut g = graph_new(300);\n    let mut e = 0;\n    for i in 0..101 {\n        add_uni_edge(&mut g, &mut e, x_node(i), x_node(i + 1), -1);\n        add_uni_edge(&mut g, &mut e, y_node(i + 1), y_node(i), -2);\n    }\n    let mut visit = vec![vec![false; a]; b];\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            let c = calc_min_c(y_cnt, x_cnt, &ds, &mut visit);\n            if 0 <= c && c <= 100 { add_uni_edge(&mut g, &mut e, x_node(x_cnt), y_node(y_cnt), c); }\n        }\n    }\n    for y in 0..b {\n        for x in 0..a {\n            if !visit[y][x] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"Y\"),\n                -2 => print!(\"X\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"{} {}\", x_node(0) + 1, y_node(0) + 1);\n}"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn main() {\n    input!(h: usize, w: usize, d: [[usize; w]; h]);\n    const MAX: usize = 3;\n    let z: Vec<Vec<usize>> = (0..=MAX)\n        .map(|i| {\n            (0..=MAX)\n                .map(|j| {\n                    iproduct!(0..h, 0..w)\n                        .map(|(x, y)| d[x][y].saturating_sub(i * (x + 1) + j * (y + 1)))\n                        .max()\n                        .unwrap()\n                })\n                .collect()\n        })\n        .collect();\n\n    if iproduct!(0..h, 0..w).any(|(x, y)| {\n        iproduct!(0..=MAX, 0..=MAX).all(|(i, j)| i * (x + 1) + j * (y + 1) + z[i][j] != d[x][y])\n    }) {\n        println!(\"Impossible\");\n        std::process::exit(0);\n    }\n    let vertex_count = 2 * MAX + 2;\n    let edges: Vec<_> = (0..MAX)\n        .map(|i| (i, i + 1, Label::X))\n        .chain((0..MAX).map(|i| (vertex_count - 2 - i, vertex_count - 1 - i, Label::Y)))\n        .chain(\n            iproduct!(0..=MAX, 0..=MAX)\n                .map(|(i, j)| (i, vertex_count - 1 - j, Label::Integer(z[i][j]))),\n        )\n        .collect();\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    for i in 0..ans.len()-1 {\n        for j in 0..ans[i].len()-1 {\n            if ans[i][j].1 < ans[i][j+1].1 {\n                printer.println(im);\n                return;\n            }\n            if ans[i][j].0 < ans[i+1][j].0 {\n                printer.println(im);\n                return;\n            }\n        }\n    }\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                print!(\"{} \", calc(x as i32, y as i32));\n            }\n            println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 201,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1);\n            if xm < 0 || ym < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1);\n        if xm < 0 || ym < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n    // debug!(ls);\n    let mut g = Graph::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    printer.println(\"Possible\");\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let d: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = 300;\n    let max_d = 100;\n    let max_c = 100;\n\n    let mut char_edge = Vec::new();\n    let mut xs = vec![0; max_d + 1];\n    let mut ys = vec![0; max_d + 1];\n    xs[0] = 0;\n    ys[0] = n - 1;\n    for i in 0..max_d {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i + 1], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for i in 0..(max_d + 1) {\n        for j in 0..(max_d + 1) {\n            if i + j > max_d {\n                continue;\n            }\n            let mut c = 0;\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    if c + f < d[x][y] {\n                        c = d[x][y] - f;\n                    }\n                }\n            }\n            if c > max_c {\n                continue;\n            }\n            int_edge.push((xs[i], ys[i], c));\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    assert!(d[x][y] <= f + c);\n                    if f + c == d[x][y] { used[x][y] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    // println!(\"{} {} {}\", y_cnt, x_cnt, ret);\n    ret\n}\n\nfn calc_use_node(y_cnt: usize, x_cnt: usize, c: i32, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>, use_node: &mut Vec<Vec<bool>>) -> usize {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            if visit[i][j] { continue; }\n            let v = (i as i32 + 1) * y_cnt as i32 + (j as i32 + 1) * x_cnt as i32 + c;\n            if v == ds[i][j] {\n                ret += 1;\n                visit[i][j] = true;\n                use_node[y_cnt][x_cnt] = true;\n                // println!(\"{} {} {} {} {} {}\", y_cnt, x_cnt, i, j, v, c);\n            }\n        }\n    }\n    ret\n}\n\nfn add_xy_edge(g: &mut Graph, e: &mut usize, from: usize, y_cnt: usize, x_cnt: usize, node_map: &mut HashMap<(usize, usize), usize>) {\n    if y_cnt == 0 && x_cnt == 0 { return; }\n    if g[from].len() == 1 { return; }\n    let mut ny_cnt = y_cnt;\n    let mut nx_cnt = x_cnt;\n    let cost;\n    if y_cnt != 0 {\n        ny_cnt -= 1;\n        cost = -1;\n    } else {\n        nx_cnt -= 1;\n        cost = -2;\n    }\n    let node = (ny_cnt, nx_cnt);\n    if !node_map.contains_key(&node) {\n        let to = g.len();\n        node_map.insert(node, to);\n        g.push(vec![]);\n    }\n    let to = *node_map.get(&node).unwrap();\n    add_uni_edge(g, e, from, to, cost);\n    add_xy_edge(g, e, to, ny_cnt, nx_cnt, node_map);\n}\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut visit = vec![vec![false; a]; b];\n    let mut min_c = vec![vec![0 as i32; 101]; 101];\n    let mut use_node = vec![vec![false; 101]; 101];\n    let mut total = 0;\n    // for i in 0..101 {\n    for i in 0..3 {\n        for x_cnt in 0..i {\n            let y_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n        for y_cnt in 0..i+1 {\n            let x_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n    }\n    // println!(\"{}\", total);\n    if total != a * b {\n        println!(\"Impossible\");\n        return;\n    }\n    let mut g = graph_new(1);\n    let mut node_map = HashMap::<(usize, usize), usize>::new();\n    let mut e = 0;\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            if !use_node[y_cnt][x_cnt] { continue; }\n            let to = g.len();\n            g.push(vec![]);\n            node_map.insert((y_cnt, x_cnt), to);\n            add_uni_edge(&mut g, &mut e, 0, to, min_c[y_cnt][x_cnt]);\n            add_xy_edge(&mut g, &mut e, to, y_cnt, x_cnt, &mut node_map);\n        }\n    }\n    assert!(g.len() <= 300);\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"Y\"),\n                -2 => print!(\"X\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"1 2\")\n}"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in (0..=100)\n            .map(|k| (0..=100 - k).map(move |l| (k, l)))\n            .flatten()\n        {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let size = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0.max(x.1)))\n        .flatten()\n        .max()\n        .unwrap()\n        + 1;\n    let mut edges = vec![];\n    let coord = |k, l| k * size + l;\n    let term = size.pow(2);\n    for (k, l) in iproduct!(0..size, 0..size) {\n        if 0 < k {\n            edges.push((coord(k - 1, l), coord(k, l), Label::X));\n        }\n        if 0 < l {\n            edges.push((coord(k, l - 1), coord(k, l), Label::Y));\n        }\n    }\n    let mut ckd = vec![false; size.pow(2)];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[coord(k, l)] {\n            continue;\n        }\n        ckd[coord(k, l)] = true;\n        edges.push((coord(k, l), term, Label::Integer(r)));\n    }\n    let vertex_count = size.pow(2) + 1;\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nconst MAX_V: usize = 300;\nconst MAX_C: usize = 100;\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let table: Vec<Vec<usize>> = (0..a)\n        .map(|_| (0..b).map(|_| sc.read()).collect())\n        .collect();\n\n    let mut edges = Vec::new();\n    let mut used = vec![vec![false; b]; a];\n    for x_count in 0..(MAX_C + 1) {\n        for y_count in 0..(MAX_C + 1) {\n            let from = x_count;\n            let to = MAX_V - 1 - y_count;\n\n            let mut cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if cost + base < table[i][j] {\n                        cost = table[i][j] - base;\n                    }\n                }\n            }\n            if cost > MAX_C {\n                continue;\n            }\n            edges.push((from, to, cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if base + cost == table[i][j] {\n                        used[i][j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    for i in 0..a {\n        for j in 0..b {\n            if !used[i][j] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", MAX_V, MAX_C * 2 + edges.len());\n    for i in 0..(MAX_C + 1) {\n        println!(\"{} {} X\", i + 1, i + 2);\n        println!(\"{} {} Y\", MAX_V - i, MAX_V - i - 1);\n    }\n    for &(from, to, cost) in &edges {\n        println!(\"{} {} {}\", from + 1, to + 1, cost);\n    }\n    println!(\"1 {}\", MAX_V);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    // println!(\"{} {} {}\", y_cnt, x_cnt, ret);\n    ret\n}\n\nfn calc_use_node(y_cnt: usize, x_cnt: usize, c: i32, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>, use_node: &mut Vec<Vec<bool>>) -> usize {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            if visit[i][j] { continue; }\n            let v = (i as i32 + 1) * y_cnt as i32 + (j as i32 + 1) * x_cnt as i32 + c;\n            if v == ds[i][j] {\n                ret += 1;\n                visit[i][j] = true;\n                use_node[y_cnt][x_cnt] = true;\n                // println!(\"{} {} {} {} {} {}\", y_cnt, x_cnt, i, j, v, c);\n            }\n        }\n    }\n    ret\n}\n\nfn add_xy_edge(g: &mut Graph, e: &mut usize, from: usize, y_cnt: usize, x_cnt: usize, node_map: &mut HashMap<(usize, usize), usize>) {\n    if y_cnt == 0 && x_cnt == 0 { return; }\n    if g[from].len() == 1 { return; }\n    let mut ny_cnt = y_cnt;\n    let mut nx_cnt = x_cnt;\n    let cost;\n    if y_cnt != 0 {\n        ny_cnt -= 1;\n        cost = -1;\n    } else {\n        nx_cnt -= 1;\n        cost = -2;\n    }\n    let node = (ny_cnt, nx_cnt);\n    if !node_map.contains_key(&node) {\n        let to = g.len();\n        node_map.insert(node, to);\n        g.push(vec![]);\n    }\n    let to = *node_map.get(&node).unwrap();\n    add_uni_edge(g, e, from, to, cost);\n    add_xy_edge(g, e, to, ny_cnt, nx_cnt, node_map);\n}\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut visit = vec![vec![false; a]; b];\n    let mut min_c = vec![vec![0 as i32; 101]; 101];\n    let mut use_node = vec![vec![false; 101]; 101];\n    let mut total = 0;\n    // for i in 0..101 {\n    for i in 0..3 {\n        for x_cnt in 0..i {\n            let y_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n        for y_cnt in 0..i+1 {\n            let x_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n    }\n    // println!(\"{}\", total);\n    if total != a * b {\n        println!(\"Impossible\");\n        return;\n    }\n    let mut g = graph_new(2);\n    let mut node_map = HashMap::<(usize, usize), usize>::new();\n    node_map.insert((0, 0), 1);\n    let mut e = 0;\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            if !use_node[y_cnt][x_cnt] { continue; }\n            let to = g.len();\n            g.push(vec![]);\n            node_map.insert((y_cnt, x_cnt), to);\n            add_uni_edge(&mut g, &mut e, 0, to, min_c[y_cnt][x_cnt]);\n            add_xy_edge(&mut g, &mut e, to, y_cnt, x_cnt, &mut node_map);\n        }\n    }\n    assert(g.len() <= 300);\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"X\"),\n                -2 => print!(\"Y\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"1 2\")\n}"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    // for i in 0..ans.len()-1 {\n    //     for j in 0..ans[i].len()-1 {\n    //         if ans[i][j].1 < ans[i][j+1].1 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //         if ans[i][j].0 < ans[i+1][j].0 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //     }\n    // }\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             // print!(\"{} \", calc(x as i32, y as i32));\n    //             if d[x-1][y-1] != calc(x as i32, y as i32) {\n    //                 printer.println(im);\n    //                 return;\n    //             }\n    //         }\n    //         // println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    for i in 0..ans.len()-1 {\n        for j in 0..ans[i].len()-1 {\n            if ans[i][j].1 < ans[i][j+1].1 {\n                printer.println(im);\n                return;\n            }\n            if ans[i][j].0 < ans[i+1][j+1].0 {\n                printer.println(im);\n                return;\n            }\n        }\n    }\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                print!(\"{} \", calc(x as i32, y as i32));\n            }\n            println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             print!(\"{} \", calc(x as i32, y as i32));\n    //         }\n    //         println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graph::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    printer.println(\"Possible\");\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s, g.t));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in (0..=100)\n            .map(|sum| (0..=sum).map(move |k| (k, sum - k)))\n            .flatten()\n        {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let sum_max = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0 + x.1))\n        .flatten()\n        .max()\n        .unwrap();\n    let mut edges = vec![];\n    let coord =\n        |k, l| (sum_max + 1) * (sum_max + 2) / 2 - ((sum_max - k + 1) * (sum_max - k + 2)) / 2 + l;\n    let term = (sum_max + 1) * (sum_max + 2) / 2;\n    for (k, l) in (0..=sum_max)\n        .map(|sum| (0..=sum).map(move |k| (k, sum - k)))\n        .flatten()\n    {\n        if 0 < k {\n            edges.push((coord(k - 1, l), coord(k, l), Label::X));\n        }\n        if 0 < l {\n            edges.push((coord(k, l - 1), coord(k, l), Label::Y));\n        }\n    }\n    let mut ckd = vec![false; term + 1];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[coord(k, l)] {\n            continue;\n        }\n        ckd[coord(k, l)] = true;\n        edges.push((coord(k, l), term, Label::Integer(r)));\n    }\n    let vertex_count = term + 1;\n    let edge_count = edges.len();\n\n    if 300 < vertex_count {\n        err();\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    assert!(b != 1);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    // for i in 0..ans.len()-1 {\n    //     for j in 0..ans[i].len()-1 {\n    //         if ans[i][j].1 < ans[i][j+1].1 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //         if ans[i][j].0 < ans[i+1][j].0 {\n    //             printer.println(im);\n    //             return;\n    //         }\n    //     }\n    // }\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             // print!(\"{} \", calc(x as i32, y as i32));\n    //             if d[x-1][y-1] != calc(x as i32, y as i32) {\n    //                 printer.println(im);\n    //                 return;\n    //             }\n    //         }\n    //         // println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in iproduct!(0..=30, 0..=30) {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let size = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0.max(x.1)))\n        .flatten()\n        .max()\n        .unwrap()\n        + 1;\n    let mut edges = vec![];\n    let coord = |k, l| k * size + l;\n    let term = size.pow(2);\n    for (k, l) in iproduct!(0..size, 0..size) {\n        if 0 < k {\n            edges.push((coord(k - 1, l), coord(k, l), Label::X));\n        }\n        if 0 < l {\n            edges.push((coord(k, l - 1), coord(k, l), Label::Y));\n        }\n    }\n    let mut ckd = vec![false; size.pow(2)];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[coord(k, l)] {\n            continue;\n        }\n        ckd[coord(k, l)] = true;\n        edges.push((coord(k, l), term, Label::Integer(r)));\n    }\n    let vertex_count = size.pow(2) + 1;\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             print!(\"{} \", calc(x as i32, y as i32));\n    //         }\n    //         println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graph::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn main() {\n    input!(h: usize, w: usize, d: [[usize; w]; h]);\n    const MAX: usize = 3;\n    let z: Vec<Vec<usize>> = (0..=MAX)\n        .map(|i| {\n            (0..=MAX)\n                .map(|j| {\n                    iproduct!(0..h, 0..w)\n                        .map(|(x, y)| d[x][y].saturating_sub(i * (x + 1) + j * (y + 1)))\n                        .max()\n                        .unwrap()\n                })\n                .collect()\n        })\n        .collect();\n\n    if iproduct!(0..h, 0..w).any(|(x, y)| {\n        iproduct!(0..=MAX, 0..=MAX).all(|(i, j)| i * (x + 1) + j * (y + 1) + z[i][j] != d[x][y])\n    }) {\n        println!(\"Impossible\");\n        std::process::exit(0);\n    }\n    let mut edges = vec![];\n    let vertex_count = 2 * MAX + 2;\n    (0..MAX).for_each(|i| edges.push((i, i + 1, Label::X)));\n    (0..MAX).for_each(|i| edges.push((vertex_count - 2 - i, vertex_count - 1 - i, Label::Y)));\n    for (i, j) in iproduct!(0..=MAX, 0..=MAX) {\n        edges.push((i, vertex_count - 1 - j, Label::Integer(z[i][j])));\n    }\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    // println!(\"{} {} {}\", y_cnt, x_cnt, ret);\n    ret\n}\n\nfn calc_use_node(y_cnt: usize, x_cnt: usize, c: i32, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>, use_node: &mut Vec<Vec<bool>>) -> usize {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            if visit[i][j] { continue; }\n            let v = (i as i32 + 1) * y_cnt as i32 + (j as i32 + 1) * x_cnt as i32 + c;\n            if v == ds[i][j] {\n                ret += 1;\n                visit[i][j] = true;\n                use_node[y_cnt][x_cnt] = true;\n                // println!(\"{} {} {} {} {} {}\", y_cnt, x_cnt, i, j, v, c);\n            }\n        }\n    }\n    ret\n}\n\nfn add_xy_edge(g: &mut Graph, e: &mut usize, from: usize, y_cnt: usize, x_cnt: usize, node_map: &mut HashMap<(usize, usize), usize>) {\n    if y_cnt == 0 && x_cnt == 0 { return; }\n    if g[from].len() == 1 { return; }\n    let mut ny_cnt = y_cnt;\n    let mut nx_cnt = x_cnt;\n    let cost;\n    if y_cnt != 0 {\n        ny_cnt -= 1;\n        cost = -1;\n    } else {\n        nx_cnt -= 1;\n        cost = -2;\n    }\n    let node = (ny_cnt, nx_cnt);\n    if !node_map.contains_key(&node) {\n        let to = g.len();\n        node_map.insert(node, to);\n        g.push(vec![]);\n    }\n    let to = *node_map.get(&node).unwrap();\n    add_uni_edge(g, e, from, to, cost);\n    add_xy_edge(g, e, to, ny_cnt, nx_cnt, node_map);\n}\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut visit = vec![vec![false; a]; b];\n    let mut min_c = vec![vec![0 as i32; 101]; 101];\n    let mut use_node = vec![vec![false; 101]; 101];\n    let mut total = 0;\n    // for i in 0..101 {\n    for i in 0..3 {\n        for x_cnt in 0..i {\n            let y_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n        for y_cnt in 0..i+1 {\n            let x_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n    }\n    // println!(\"{}\", total);\n    if total != a * b {\n        println!(\"Impossible\");\n        return;\n    }\n    let mut g = graph_new(2);\n    let mut node_map = HashMap::<(usize, usize), usize>::new();\n    node_map.insert((0, 0), 1);\n    let mut e = 0;\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            if !use_node[y_cnt][x_cnt] { continue; }\n            let to = g.len();\n            g.push(vec![]);\n            node_map.insert((y_cnt, x_cnt), to);\n            add_uni_edge(&mut g, &mut e, 0, to, min_c[y_cnt][x_cnt]);\n            add_xy_edge(&mut g, &mut e, to, y_cnt, x_cnt, &mut node_map);\n        }\n    }\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"X\"),\n                -2 => print!(\"Y\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"1 2\")\n}"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nconst MAX_V: usize = 300;\nconst MAX_C: usize = 100;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist_table: Vec<Vec<usize>> = (0..a)\n        .map(|_| (0..b).map(|_| sc.read()).collect())\n        .collect();\n\n    let n = MAX_V;\n    let mut used = vec![vec![false; b]; a];\n    let mut edges = Vec::new();\n    for x_count in 0..(MAX_C + 1) {\n        for y_count in 0..(MAX_C + 1) {\n            let mut edge = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if dist_table[i][j] < base {\n                        continue;\n                    }\n                    edge = cmp::max(edge, dist_table[i][j] - base);\n                }\n            }\n\n            for i in 0..a {\n                for j in 0..b {\n                    let dx = i + 1;\n                    let dy = j + 1;\n                    let base = dx * x_count + dy * y_count;\n                    if edge + base == dist_table[i][j] {\n                        used[i][j] = true;\n                    }\n                }\n            }\n\n            let from = x_count;\n            let to = n - 1 - y_count;\n            edges.push((from, to, edge));\n        }\n    }\n\n    for i in 0..a {\n        for j in 0..b {\n            if !used[i][j] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, edges.len() + MAX_C * 2);\n    for i in 0..MAX_C {\n        println!(\"{} {} X\", i + 1, i + 2);\n    }\n    for i in 0..MAX_C {\n        println!(\"{} {} Y\", n - 1 - i, n - i);\n    }\n    for &(from, to, cost) in &edges {\n        println!(\"{} {} {}\", from + 1, to + 1, cost);\n    }\n    println!(\"{} {}\", 1, n);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in iproduct!(0..=10, 0..=10) {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let size = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0.max(x.1)))\n        .flatten()\n        .max()\n        .unwrap()\n        + 1;\n    let mut edges = vec![];\n    let coord = |k, l| k * size + l;\n    let term = size.pow(2);\n    for (k, l) in iproduct!(0..size, 0..size) {\n        if 0 < k {\n            edges.push((coord(k - 1, l), coord(k, l), Label::X));\n        }\n        if 0 < l {\n            edges.push((coord(k, l - 1), coord(k, l), Label::Y));\n        }\n    }\n    let mut ckd = vec![false; size.pow(2)];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[coord(k, l)] {\n            continue;\n        }\n        ckd[coord(k, l)] = true;\n        edges.push((coord(k, l), term, Label::Integer(r)));\n    }\n    let vertex_count = size.pow(2) + 1;\n    let edge_count = edges.len();\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    // assert!(b != 1);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let ans = if b == 1 {\n        let mut ans = vec![vec![(0, 0, 0); 1]; a];\n        for i in 0..a-1 {\n            let ym = 0;\n            let xm = d[i+1][0]-d[i][0];\n            let c = d[i][0] - xm * (i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][0] = (xm, ym, c);\n        }\n        let i = a-1;\n        let ym = 0;\n        let xm = 0;\n        let c = d[i][0];\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][0] = (xm, ym, c);\n        \n        \n        ans\n    } else {\n        let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n        for i in 0..a-1 {\n            for j in 0..b-1 {\n                let ym = d[i][j+1]-d[i][j];\n                let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n                let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n                if xm < 0 || ym < 0 || c < 0 {\n                    // debug!((i, j, xm, ym, c));\n                    printer.println(im);\n                    return;\n                }\n                ans[i][j] = (xm, ym, c);\n            }\n        }\n        for j in 0..b-1 {\n            let i = a-1;\n            let ym = d[i][j+1]-d[i][j];\n            let xm = 0;\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n        ans\n    };\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n\n    // debug!(ls);\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                // print!(\"{} \", calc(x as i32, y as i32));\n                if d[x-1][y-1] != calc(x as i32, y as i32) {\n                    printer.println(im);\n                    return;\n                }\n            }\n            // println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>) -> i32 {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    // println!(\"{} {} {}\", y_cnt, x_cnt, ret);\n    ret\n}\n\nfn calc_use_node(y_cnt: usize, x_cnt: usize, c: i32, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>, use_node: &mut Vec<Vec<bool>>) -> usize {\n    let mut ret = 0;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            if visit[i][j] { continue; }\n            let v = (i as i32 + 1) * y_cnt as i32 + (j as i32 + 1) * x_cnt as i32 + c;\n            if v == ds[i][j] {\n                ret += 1;\n                visit[i][j] = true;\n                use_node[y_cnt][x_cnt] = true;\n                // println!(\"{} {} {} {} {} {}\", y_cnt, x_cnt, i, j, v, c);\n            }\n        }\n    }\n    ret\n}\n\nfn add_xy_edge(g: &mut Graph, e: &mut usize, from: usize, y_cnt: usize, x_cnt: usize, node_map: &mut HashMap<(usize, usize), usize>) {\n    if y_cnt == 0 && x_cnt == 0 { return; }\n    if g[from].len() == 1 { return; }\n    let mut ny_cnt = y_cnt;\n    let mut nx_cnt = x_cnt;\n    let cost;\n    if y_cnt != 0 {\n        ny_cnt -= 1;\n        cost = -1;\n    } else {\n        nx_cnt -= 1;\n        cost = -2;\n    }\n    let node = (ny_cnt, nx_cnt);\n    if !node_map.contains_key(&node) {\n        let to = g.len();\n        node_map.insert(node, to);\n        g.push(vec![]);\n    }\n    let to = *node_map.get(&node).unwrap();\n    add_uni_edge(g, e, from, to, cost);\n    add_xy_edge(g, e, to, ny_cnt, nx_cnt, node_map);\n}\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut visit = vec![vec![false; a]; b];\n    let mut min_c = vec![vec![0 as i32; 101]; 101];\n    let mut use_node = vec![vec![false; 101]; 101];\n    let mut total = 0;\n    for i in 0..101 {\n    // for i in 0..3 {\n        for x_cnt in 0..i {\n            let y_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n        for y_cnt in 0..i+1 {\n            let x_cnt = i;\n            min_c[y_cnt][x_cnt] = calc_min_c(y_cnt, x_cnt, &ds);\n            total += calc_use_node(y_cnt, x_cnt, min_c[y_cnt][x_cnt], &ds, &mut visit, &mut use_node);\n        }\n    }\n    // println!(\"{}\", total);\n    if total != a * b {\n        println!(\"Impossible\");\n        return;\n    }\n    let mut g = graph_new(1);\n    let mut node_map = HashMap::<(usize, usize), usize>::new();\n    let mut e = 0;\n    for y_cnt in 0..101 {\n        for x_cnt in 0..101 {\n            if !use_node[y_cnt][x_cnt] { continue; }\n            let to = g.len();\n            g.push(vec![]);\n            node_map.insert((y_cnt, x_cnt), to);\n            add_uni_edge(&mut g, &mut e, 0, to, min_c[y_cnt][x_cnt]);\n            add_xy_edge(&mut g, &mut e, to, y_cnt, x_cnt, &mut node_map);\n        }\n    }\n    assert!(g.len() <= 300);\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"Y\"),\n                -2 => print!(\"X\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"1 2\")\n}"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graphmat {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graphmat {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graphmat {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    // assert!(b != 1);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let ans = if b == 1 {\n        let mut ans = vec![vec![(0, 0, 0); 1]; a];\n        for i in 0..a-1 {\n            for j in 0..b-1 {\n                let ym = 0;\n                let xm = d[i+1][j]-d[i][j];\n                let c = d[i][j] - ym * (j as i32 + 1) - xm * (i as i32 + 1);\n                if xm < 0 || ym < 0 || c < 0 {\n                    printer.println(im);\n                    return;\n                }\n                ans[i][j] = (xm, ym, c);\n            }\n        }\n        let i = a-1;\n        let ym = 0;\n        let xm = 0;\n        let c = d[i][0];\n        if xm < 0 || ym < 0 || c < 0 {\n            // debug!((i, j, xm, ym, c));\n            printer.println(im);\n            return;\n        }\n        ans[i][0] = (xm, ym, c);\n        \n        \n        ans\n    } else {\n        let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n        for i in 0..a-1 {\n            for j in 0..b-1 {\n                let ym = d[i][j+1]-d[i][j];\n                let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n                let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n                if xm < 0 || ym < 0 || c < 0 {\n                    // debug!((i, j, xm, ym, c));\n                    printer.println(im);\n                    return;\n                }\n                ans[i][j] = (xm, ym, c);\n            }\n        }\n        for j in 0..b-1 {\n            let i = a-1;\n            let ym = d[i][j+1]-d[i][j];\n            let xm = 0;\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                // debug!((i, j, xm, ym, c));\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n        ans\n    };\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    {\n        let calc = |x, y| {\n            ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n        };\n        for x in 1..a+1 {\n            for y in 1..b+1 {\n                // print!(\"{} \", calc(x as i32, y as i32));\n                if d[x-1][y-1] != calc(x as i32, y as i32) {\n                    printer.println(im);\n                    return;\n                }\n            }\n            // println!();\n        }\n    }\n\n    // debug!(ls);\n    let mut g = Graphmat::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    let mut cnt = 0;\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(_) = g.mat[i][j] {\n                cnt += 1;\n            }\n        }\n    }\n    printer.println(\"Possible\");\n    printer.println(format!(\"{} {}\", 300, cnt));\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(MAX_D + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..MAX_D {\n        char_edge.push((xs[i], xs[i + 1], 'X'));\n        char_edge.push((ys[i + 1], ys[i], 'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for from in 0..(MAX_D + 1) {\n        for to in 0..(MAX_D + 1) {\n            if from + to > MAX_D {\n                continue;\n            }\n            let mut edge_cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    if edge_cost + base_cost < dist[i][j] {\n                        edge_cost = dist[i][j] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edge.push((xs[from], ys[to], edge_cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    assert!(dist[i][j] <= base_cost + edge_cost);\n                    if base_cost + edge_cost == dist[i][j] { used[i][j] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n    let mut char_edges = Vec::new();\n    let xs: Vec<usize> = (0..(MAX_D + 1)).map(|i| i).collect();\n    let ys: Vec<usize> = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect();\n    for i in 0..MAX_D {\n        char_edges.push((xs[i], xs[i + 1], 'X'));\n        char_edges.push((ys[i + 1], ys[i], 'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edges = Vec::new();\n    for d1 in 0..(MAX_D + 1) {\n        for d2 in 0..(MAX_D + 1) {\n            if d1 + d2 > MAX_D { continue; }\n\n            let mut edge_cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = (i + 1);\n                    let cost_y = (j + 1);\n                    let base_cost = d1 * cost_x + d2 * cost_y;\n                    if edge_cost + base_cost < dist[i][j] {\n                        edge_cost = dist[i][j] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edges.push((xs[d1], ys[d2], edge_cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = (i + 1);\n                    let cost_y = (j + 1);\n                    let base_cost = d1 * cost_x + d2 * cost_y;\n                    assert!(dist[i][j] <= base_cost + edge_cost);\n                    if edge_cost + base_cost == dist[i][j] {\n                        used[i][j] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    for e in &char_edges {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n\n    for e in &int_edges {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[allow(dead_code)]\n#[derive(Clone, Debug, Eq, PartialEq)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\n#[allow(dead_code)]\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\nimpl std::cmp::Ord for Edge {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        (self.weight, self.src, self.dest).cmp(&(other.weight, other.src, other.dest))\n    }\n}\nimpl std::cmp::PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\n#[allow(dead_code)]\nfn graph_new(n: usize) -> Graph {\n    vec![vec![]; n]\n}\n#[allow(dead_code)]\nfn add_bi_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    graph[dest].push(Edge::new(*index, dest, src, weight));\n    *index += 1;\n}\n#[allow(dead_code)]\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn calc_min_c(y_cnt: usize, x_cnt: usize, ds: &Vec<Vec<i32>>, visit: &mut Vec<Vec<bool>>) -> i32 {\n    let mut ret = -1;\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            ret = std::cmp::max(ret, v);\n        }\n    }\n    if ret < 0 || 100 < ret { return ret; }\n    for i in 0..ds.len() {\n        for j in 0..ds[0].len() {\n            let v = ds[i][j] - (i as i32 + 1) * y_cnt as i32 - (j as i32 + 1) * x_cnt as i32;\n            if v == ret { visit[i][j] = true; }\n        }\n    }\n    ret\n}\n\nconst MAX_N: usize = 100;\nfn x_node(i: usize) -> usize { i }\nfn y_node(i: usize) -> usize { i + 110 }\n\nfn main() {\n    let a: usize = read();\n    let b: usize = read();\n    let mut ds = vec![vec![0 as i32; a]; b];\n    for x in 0..a {\n        for y in 0..b {\n            ds[y][x] = read();\n        }\n    }\n    let mut g = graph_new(300);\n    let mut e = 0;\n    for i in 0..MAX_N+1 {\n        add_uni_edge(&mut g, &mut e, x_node(i), x_node(i + 1), -1);\n        add_uni_edge(&mut g, &mut e, y_node(i + 1), y_node(i), -2);\n    }\n    let mut visit = vec![vec![false; a]; b];\n    for y_cnt in 0..MAX_N+1 {\n        for x_cnt in 0..MAX_N+1 {\n            let c = calc_min_c(y_cnt, x_cnt, &ds, &mut visit);\n            if 0 <= c && c <= 100 { add_uni_edge(&mut g, &mut e, x_node(x_cnt), y_node(y_cnt), c); }\n        }\n    }\n    for y in 0..b {\n        for x in 0..a {\n            if !visit[y][x] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n    println!(\"Possible\");\n    println!(\"{} {}\", g.len(), e);\n    for edges in g.iter() {\n        for edge in edges.iter() {\n            print!(\"{} {} \", edge.src + 1, edge.dest + 1);\n            match edge.weight {\n                -1 => print!(\"X\"),\n                -2 => print!(\"Y\"),\n                _ => print!(\"{}\", edge.weight),\n            }\n            println!(\"\");\n        }\n    }\n    println!(\"{} {}\", x_node(0) + 1, y_node(0) + 1);\n}"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let d: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = 300;\n    let max_d = 100;\n    let max_c = 100;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(max_d + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(max_d + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..max_d {\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for i in 0..(max_d + 1) {\n        for j in 0..(max_d + 1) {\n            if i + j > max_d {\n                continue;\n            }\n            let mut c = 0;\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    if c + f < d[x][y] {\n                        c = d[x][y] - f;\n                    }\n                }\n            }\n            if c > max_c { continue; }\n            int_edge.push((xs[i], ys[j], c));\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    assert!(d[x][y] <= f + c);\n                    if f + c == d[x][y] { used[x][y] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use itertools::iproduct;\nuse proconio::input;\n\n#[derive(Debug, Clone, Copy)]\nenum Label {\n    X,\n    Y,\n    Integer(usize),\n}\n\nfn err() -> ! {\n    println!(\"Impossible\");\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(a: usize, b: usize, d: [[usize; b]; a]);\n    let mut coeff = vec![vec![None; b]; a];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        'coeff: for (k, l) in (0..=100)\n            .map(|sum| (0..=sum).map(move |k| (k, sum - k)))\n            .flatten()\n        {\n            let base = |x, y| (x + 1) * k + (y + 1) * l;\n            if d[i][j] < base(i, j) {\n                continue;\n            }\n            let r = d[i][j] - base(i, j);\n            for (i1, j1) in iproduct!(0..a, 0..b) {\n                if base(i1, j1) + r < d[i1][j1] {\n                    continue 'coeff;\n                }\n            }\n            coeff[i][j] = Some((k, l, r));\n            break;\n        }\n    }\n    let coeff: Vec<Vec<(usize, usize, usize)>> = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.unwrap_or_else(|| err())).collect())\n        .collect();\n\n    let sum_max = coeff\n        .iter()\n        .map(|v| v.iter().map(|x| x.0 + x.1))\n        .flatten()\n        .max()\n        .unwrap();\n    let mut edges = vec![];\n    let coord =\n        |k, l| (sum_max + 1) * (sum_max + 2) / 2 - ((sum_max - k + 1) * (sum_max - k + 2)) / 2 + l;\n    let term = (sum_max + 1) * (sum_max + 2) / 2;\n    for (k, l) in (0..=sum_max)\n        .map(|sum| (0..=sum).map(move |k| (k, sum - k)))\n        .flatten()\n    {\n        if 0 < k {\n            edges.push((coord(k - 1, l), coord(k, l), Label::X));\n        }\n        if 0 < l {\n            edges.push((coord(k, l - 1), coord(k, l), Label::Y));\n        }\n    }\n    let mut ckd = vec![false; term + 1];\n    for (i, j) in iproduct!(0..a, 0..b) {\n        let (k, l, r) = coeff[i][j];\n        if ckd[coord(k, l)] {\n            continue;\n        }\n        ckd[coord(k, l)] = true;\n        edges.push((coord(k, l), term, Label::Integer(r)));\n    }\n    let vertex_count = term + 1;\n    let edge_count = edges.len();\n\n    assert!(vertex_count <= 300);\n    if 300 < vertex_count {\n        err();\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", vertex_count, edge_count);\n    for (u, v, w) in edges {\n        println!(\n            \"{} {} {}\",\n            u + 1,\n            v + 1,\n            match w {\n                Label::X => 'X'.to_string(),\n                Label::Y => 'Y'.to_string(),\n                Label::Integer(x) => x.to_string(),\n            }\n        );\n    }\n    println!(\"{} {}\", 1, vertex_count);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let d: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = 300;\n    let max_d = 100;\n    let max_c = 100;\n\n    let mut char_edge = Vec::new();\n    let mut xs = vec![0; max_d + 1];\n    let mut ys = vec![0; max_d + 1];\n    xs[0] = 0;\n    ys[0] = n - 1;\n    for i in 0..max_d {\n        xs[i + 1] = xs[i] + 1;\n        ys[i + 1] = ys[i] - 1;\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for i in 0..(max_d + 1) {\n        for j in 0..(max_d + 1) {\n            if i + j > max_d {\n                continue;\n            }\n            let mut c = 0;\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    if c + f < d[x][y] {\n                        c = d[x][y] - f;\n                    }\n                }\n            }\n            if c > max_c { continue; }\n            int_edge.push((xs[i], ys[j], c));\n            for x in 0..a {\n                for y in 0..b {\n                    let f = i * (x + 1) + j * (y + 1);\n                    assert!(d[x][y] <= f + c);\n                    if f + c == d[x][y] { used[x][y] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let dist: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(MAX_D + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..MAX_D {\n        char_edge.push((xs[i], xs[i + 1], 'X'));\n        char_edge.push((ys[i + 1], ys[i], 'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for from in 0..(MAX_D + 1) {\n        for to in 0..(MAX_D + 1) {\n            if from + to > MAX_D {\n                continue;\n            }\n            let mut edge_cost = 0;\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    if edge_cost + base_cost < dist[i][j] {\n                        edge_cost = dist[i][j] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edge.push((xs[from], ys[to], edge_cost));\n\n            for i in 0..a {\n                for j in 0..b {\n                    let cost_x = i + 1;\n                    let cost_y = j + 1;\n                    let base_cost = from * cost_x + to * cost_y;\n                    assert!(dist[i][j] <= base_cost + edge_cost);\n                    if base_cost + edge_cost == dist[i][j] { used[i][j] = true; }\n                }\n            }\n        }\n    }\n\n    if used.iter().flat_map(|&v| v.iter()).map(|&t| if t { 0 } else { 1 }).max() != 0 {\n        println!(\"Impossible\");\n        return;\n    }\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "const MAX_D: usize = 100;\nconst MAX_C: usize = 100;\nconst MAX_V: usize = 300;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let a: usize = sc.read();\n    let b: usize = sc.read();\n    let d: Vec<Vec<usize>> = (0..a).map(|_| (0..b).map(|_| sc.read()).collect()).collect();\n\n    let n = MAX_V;\n\n    let mut char_edge = Vec::new();\n    let xs = (0..(MAX_D + 1)).map(|i| i).collect::<Vec<_>>();\n    let ys = (0..(MAX_D + 1)).map(|i| n - 1 - i).collect::<Vec<_>>();\n    for i in 0..MAX_D {\n        char_edge.push((xs[i], xs[i + 1], b'X'));\n        char_edge.push((ys[i + 1], ys[i], b'Y'));\n    }\n\n    let mut used = vec![vec![false; b]; a];\n    let mut int_edge = Vec::new();\n    for i in 0..(MAX_D + 1) {\n        for j in 0..(MAX_D + 1) {\n            if i + j > MAX_D {\n                continue;\n            }\n            let mut edge_cost = 0;\n            for x in 0..a {\n                for y in 0..b {\n                    let base_cost = i * (x + 1) + j * (y + 1);\n                    if edge_cost + base_cost < d[x][y] {\n                        edge_cost = d[x][y] - base_cost;\n                    }\n                }\n            }\n            if edge_cost > MAX_C { continue; }\n            int_edge.push((xs[i], ys[j], edge_cost));\n\n            for x in 0..a {\n                for y in 0..b {\n                    let base_cost = i * (x + 1) + j * (y + 1);\n                    assert!(d[x][y] <= base_cost + edge_cost);\n                    if base_cost + edge_cost == d[x][y] { used[x][y] = true; }\n                }\n            }\n        }\n    }\n\n    for x in 0..a {\n        for y in 0..b {\n            if !used[x][y] {\n                println!(\"Impossible\");\n                return;\n            }\n        }\n    }\n\n    println!(\"Possible\");\n    println!(\"{} {}\", n, int_edge.len() + char_edge.len());\n    for e in &char_edge {\n        let (from, to, c) = *e;\n        let x = if c == b'X' { \"X\" } else { \"Y\" };\n        println!(\"{} {} {}\", from + 1, to + 1, x);\n    }\n    for e in &int_edge {\n        let (from, to, c) = *e;\n        println!(\"{} {} {}\", from + 1, to + 1, c);\n    }\n    println!(\"{} {}\", xs[0] + 1, ys[0] + 1);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) { b = self.byte(); }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// use std::ops::{Index, IndexMut};\n// use std::cmp::{Ordering, min, max};\n// use std::collections::{BinaryHeap, BTreeMap};\n// use std::collections::btree_map::Entry::{Occupied, Vacant};\n// use std::clone::Clone;\n\nfn getline() -> String{\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*) \n        }\n    };\n}\n\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator, \n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display {\n    for (i,e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\nstruct ContestPrinter {\n    s: String,\n}\n\nimpl ContestPrinter {\n    fn new() -> ContestPrinter {\n        ContestPrinter {\n            s: String::new(),\n        }\n    }\n\n    fn print<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\", x).as_str());\n    }\n\n    fn println<T>(&mut self, x: T)\n        where T: std::fmt::Display {\n        self.s.push_str(format!(\"{}\\n\", x).as_str());\n    }\n}\n\nimpl std::ops::Drop for ContestPrinter {\n    fn drop(&mut self) {\n        print!(\"{}\", self.s);\n    }\n}\n\nstruct Graph {\n    mat: Vec<Vec<Option<i32>>>,\n    s: usize, \n    t: usize,\n    ud: usize,\n}\n\nimpl Graph {\n    fn new() -> Self {\n        let n = 300;\n        let mut mat = vec![vec![None; n]; n];\n        for i in 0..100 {\n            mat[i][i+1] = Some(-1); // x\n        }\n        for i in 0..100 {\n            mat[101+i+1][101+i] = Some(-2); // y\n        }\n        Graph {\n            mat: mat,\n            s: 0,\n            t: 101,\n            ud: 202,\n        }\n    }\n    \n    fn add(&mut self, a: i32, b: i32, c: i32) {\n        let a = a as usize;\n        let b = b as usize;\n        if self.mat[a][101+b] == None {\n            self.mat[a][101+b] = Some(c);\n        } else {\n            self.mat[a][self.ud] = Some(0);\n            self.mat[self.ud][101+b] = Some(c);\n            // debug!(self.ud);\n            self.ud += 1;\n        }\n    }\n}\n\n\nfn main() {\n    let mut printer = ContestPrinter::new();\n    let (a, b) = readl!(usize, usize);\n    let mut d = Vec::with_capacity(b);\n    for _ in 0..a {\n        d.push(readlvec!(i32));\n    }\n    let im = \"Impossible\";\n    let n = 300;\n    let mut ans = vec![vec![(0, 0, 0); b-1]; a];\n    for i in 0..a-1 {\n        for j in 0..b-1 {\n            let ym = d[i][j+1]-d[i][j];\n            let xm = std::cmp::max(d[i+1][j]-d[i][j], d[i+1][j+1]-d[i][j+1]);\n            let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n            if xm < 0 || ym < 0 || c < 0 {\n                printer.println(im);\n                return;\n            }\n            ans[i][j] = (xm, ym, c);\n        }\n    }\n    for j in 0..b-1 {\n        let i = a-1;\n        let ym = d[i][j+1]-d[i][j];\n        let xm = 0;\n        let c = d[i][j] - ym * (j as i32 + 1) - xm*(i as i32 + 1);\n        if xm < 0 || ym < 0 || c < 0 {\n            printer.println(im);\n            return;\n        }\n        ans[i][j] = (xm, ym, c);\n    }\n    // debug!(ans);\n    \n    let mut ls = std::collections::HashSet::new();\n    for vec in ans {\n        for e in vec {\n            ls.insert(e);\n        }\n    }\n    let ls = ls;\n\n    // {\n    //     let calc = |x, y| {\n    //         ls.iter().map(|&(a, b, c)| a*x+b*y+c).min().unwrap()\n    //     };\n    //     for x in 1..a+1 {\n    //         for y in 1..b+1 {\n    //             print!(\"{} \", calc(x as i32, y as i32));\n    //         }\n    //         println!();\n    //     }\n    // }\n\n    // debug!(ls);\n    let mut g = Graph::new();\n    for (a, b, c) in ls {\n        g.add(a, b, c);\n    }\n    printer.println(\"Possible\");\n    for i in 0..g.mat.len() {\n        for j in 0..g.mat[i].len() {\n            if let Some(v) = g.mat[i][j] {\n                if v == -1 {\n                    printer.println(format!(\"{} {} X\", i+1, j+1));\n                } else if v == -2 {\n                    printer.println(format!(\"{} {} Y\", i+1, j+1));\n                } else {\n                    printer.println(format!(\"{} {} {}\", i+1, j+1, v));\n                }\n            }\n        }\n    }\n    printer.println(format!(\"{} {}\", g.s+1, g.t+1));\n}\n\n"
  }
]