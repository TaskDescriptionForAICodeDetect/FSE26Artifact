[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\nint grid[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint computeCapacity(int left, int right, int top, int bottom) {\n    if (left >= right || top >= bottom) return 0;\n\n    int perimeter = 0;\n    int minHeight = INT_MAX;\n    int minRow = -1, minCol = -1;\n\n    for (int i = top; i <= bottom; i++) {\n        if (grid[i][left] < minHeight) {\n            minHeight = grid[i][left];\n            minRow = i;\n            minCol = left;\n        }\n        if (grid[i][right] < minHeight) {\n            minHeight = grid[i][right];\n            minRow = i;\n            minCol = right;\n        }\n    }\n\n    for (int j = left; j <= right; j++) {\n        if (grid[top][j] < minHeight) {\n            minHeight = grid[top][j];\n            minRow = top;\n            minCol = j;\n        }\n        if (grid[bottom][j] < minHeight) {\n            minHeight = grid[bottom][j];\n            minRow = bottom;\n            minCol = j;\n        }\n    }\n\n    int capacity = 0;\n    for (int i = top + 1; i < bottom; i++) {\n        for (int j = left + 1; j < right; j++) {\n            if (grid[i][j] < minHeight) {\n                capacity += minHeight - grid[i][j];\n                grid[i][j] = minHeight;\n            }\n        }\n    }\n\n    capacity += computeCapacity(left, minCol - 1, top, bottom);\n    capacity += computeCapacity(minCol + 1, right, top, bottom);\n    capacity += computeCapacity(left, right, top, minRow - 1);\n    capacity += computeCapacity(left, right, minRow + 1, bottom);\n\n    return capacity;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &rows, &cols) == 2) {\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        printf(\"%d\\n\", computeCapacity(0, cols - 1, 0, rows - 1));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Cell {\n    int x, y, h;\n    Cell(int x, int y, int h) : x(x), y(y), h(h) {}\n    bool operator>(const Cell& other) const { return h > other.h; }\n};\n\nint maxPondCapacity(vector<vector<int>>& grid) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    int m = grid.size(), n = grid[0].size();\n    if (m < 3 || n < 3) return 0;\n    \n    priority_queue<Cell, vector<Cell>, greater<Cell>> pq;\n    vector<vector<bool>> visited(m, vector<bool>(n, false));\n    \n    for (int i = 0; i < m; ++i) {\n        pq.push(Cell(i, 0, grid[i][0]));\n        pq.push(Cell(i, n-1, grid[i][n-1]));\n        visited[i][0] = visited[i][n-1] = true;\n    }\n    for (int j = 1; j < n-1; ++j) {\n        pq.push(Cell(0, j, grid[0][j]));\n        pq.push(Cell(m-1, j, grid[m-1][j]));\n        visited[0][j] = visited[m-1][j] = true;\n    }\n    \n    int res = 0;\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    while (!pq.empty()) {\n        Cell cell = pq.top();\n        pq.pop();\n        \n        for (auto& dir : dirs) {\n            int x = cell.x + dir[0];\n            int y = cell.y + dir[1];\n            if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\n            \n            if (grid[x][y] < cell.h) {\n                res += cell.h - grid[x][y];\n                grid[x][y] = cell.h;\n            }\n            visited[x][y] = true;\n            pq.push(Cell(x, y, grid[x][y]));\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    int m, n;\n    while (cin >> m >> n) {\n        vector<vector<int>> grid(m, vector<int>(n));\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << maxPondCapacity(grid) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PondCapacity {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        int[][] grid = new int[rows][cols];\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int maxCapacity = 0;\n        \n        for (int i1 = 0; i1 < rows; i1++) {\n            for (int j1 = 0; j1 < cols; j1++) {\n                for (int i2 = i1 + 1; i2 < rows; i2++) {\n                    for (int j2 = j1 + 1; j2 < cols; j2++) {\n                        int minBorder = Integer.MAX_VALUE;\n                        for (int i = i1; i <= i2; i++) {\n                            minBorder = Math.min(minBorder, grid[i][j1]);\n                            minBorder = Math.min(minBorder, grid[i][j2]);\n                        }\n                        for (int j = j1; j <= j2; j++) {\n                            minBorder = Math.min(minBorder, grid[i1][j]);\n                            minBorder = Math.min(minBorder, grid[i2][j]);\n                        }\n                        \n                        int capacity = 0;\n                        boolean valid = true;\n                        for (int i = i1 + 1; i < i2; i++) {\n                            for (int j = j1 + 1; j < j2; j++) {\n                                if (grid[i][j] >= minBorder) {\n                                    valid = false;\n                                    break;\n                                }\n                                capacity += minBorder - grid[i][j];\n                            }\n                            if (!valid) break;\n                        }\n                        \n                        if (valid && capacity > maxCapacity) {\n                            maxCapacity = capacity;\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(maxCapacity);\n    }\n}",
    "timestamp": "2025-08-05 21:04:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PondCapacity {\n    public static int maxPondCapacity(int[][] grid) {\n        if (grid == null || grid.length < 3 || grid[0].length < 3) return 0;\n        \n        int rows = grid.length;\n        int cols = grid[0].length;\n        int maxCapacity = 0;\n        \n        for (int top = 0; top < rows - 2; top++) {\n            for (int bottom = top + 2; bottom < rows; bottom++) {\n                for (int left = 0; left < cols - 2; left++) {\n                    for (int right = left + 2; right < cols; right++) {\n                        int capacity = calculatePondCapacity(grid, top, bottom, left, right);\n                        maxCapacity = Math.max(maxCapacity, capacity);\n                    }\n                }\n            }\n        }\n        \n        return maxCapacity;\n    }\n    \n    private static int calculatePondCapacity(int[][] grid, int top, int bottom, int left, int right) {\n        // Check perimeter conditions\n        for (int i = left; i <= right; i++) {\n            if (grid[top][i] <= grid[top+1][i] || grid[bottom][i] <= grid[bottom-1][i]) \n                return 0;\n        }\n        \n        for (int i = top; i <= bottom; i++) {\n            if (grid[i][left] <= grid[i][left+1] || grid[i][right] <= grid[i][right-1]) \n                return 0;\n        }\n        \n        // Find minimum water height\n        int waterHeight = Integer.MAX_VALUE;\n        for (int i = top + 1; i < bottom; i++) {\n            for (int j = left + 1; j < right; j++) {\n                waterHeight = Math.min(waterHeight, grid[top][j]);\n                waterHeight = Math.min(waterHeight, grid[bottom][j]);\n                waterHeight = Math.min(waterHeight, grid[i][left]);\n                waterHeight = Math.min(waterHeight, grid[i][right]);\n            }\n        }\n        \n        // Calculate capacity\n        int capacity = 0;\n        for (int i = top + 1; i < bottom; i++) {\n            for (int j = left + 1; j < right; j++) {\n                capacity += Math.max(0, waterHeight - grid[i][j]);\n            }\n        }\n        \n        return capacity;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        \n        for (int t = 0; t < T; t++) {\n            int rows = scanner.nextInt();\n            int cols = scanner.nextInt();\n            \n            int[][] grid = new int[rows][cols];\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            \n            System.out.println(maxPondCapacity(grid));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:04:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculate_pond_capacity(int grid[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int max_capacity = 0;\n    \n    for (int top = 0; top < rows - 1; top++) {\n        for (int left = 0; left < cols - 1; left++) {\n            for (int bottom = top + 1; bottom < rows; bottom++) {\n                for (int right = left + 1; right < cols; right++) {\n                    int pond_height = INT_MAX;\n                    int is_valid_pond = 1;\n                    \n                    // Check top and bottom boundaries\n                    for (int j = left; j <= right; j++) {\n                        if (grid[top][j] <= grid[top][left] || grid[bottom][j] <= grid[bottom][left]) {\n                            is_valid_pond = 0;\n                            break;\n                        }\n                        pond_height = min(pond_height, grid[top][j]);\n                        pond_height = min(pond_height, grid[bottom][j]);\n                    }\n                    \n                    // Check left and right boundaries\n                    for (int i = top; i <= bottom; i++) {\n                        if (grid[i][left] <= grid[top][left] || grid[i][right] <= grid[top][left]) {\n                            is_valid_pond = 0;\n                            break;\n                        }\n                        pond_height = min(pond_height, grid[i][left]);\n                        pond_height = min(pond_height, grid[i][right]);\n                    }\n                    \n                    // Calculate water capacity\n                    if (is_valid_pond) {\n                        int water_capacity = 0;\n                        for (int i = top + 1; i < bottom; i++) {\n                            for (int j = left + 1; j < right; j++) {\n                                water_capacity += pond_height - grid[i][j];\n                            }\n                        }\n                        max_capacity = water_capacity > max_capacity ? water_capacity : max_capacity;\n                    }\n                }\n            }\n        }\n    }\n    \n    return max_capacity;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        int rows, cols;\n        scanf(\"%d %d\", &rows, &cols);\n        \n        int grid[MAX_SIZE][MAX_SIZE];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        int result = calculate_pond_capacity(grid, rows, cols);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint calculatePondCapacity(vector<vector<int>>& grid) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    if (cols == 0) return 0;\n\n    int maxCapacity = 0;\n\n    for (int r1 = 0; r1 < rows - 1; r1++) {\n        for (int r2 = r1 + 1; r2 < rows; r2++) {\n            for (int c1 = 0; c1 < cols - 1; c1++) {\n                for (int c2 = c1 + 1; c2 < cols; c2++) {\n                    int pondHeight = INT_MAX;\n\n                    // Check if boundary conditions are met\n                    bool validPond = true;\n                    for (int r = r1; r <= r2; r++) {\n                        if (grid[r][c1] <= grid[r1][c1] || grid[r][c2] <= grid[r1][c2]) {\n                            validPond = false;\n                            break;\n                        }\n                    }\n                    for (int c = c1; c <= c2; c++) {\n                        if (grid[r1][c] <= grid[r1][c1] || grid[r2][c] <= grid[r2][c1]) {\n                            validPond = false;\n                            break;\n                        }\n                    }\n\n                    if (!validPond) continue;\n\n                    // Find minimum height inside the pond\n                    for (int r = r1 + 1; r < r2; r++) {\n                        for (int c = c1 + 1; c < c2; c++) {\n                            pondHeight = min(pondHeight, grid[r][c]);\n                        }\n                    }\n\n                    // Calculate water capacity\n                    int capacity = 0;\n                    for (int r = r1 + 1; r < r2; r++) {\n                        for (int c = c1 + 1; c < c2; c++) {\n                            capacity += max(0, pondHeight - grid[r][c]);\n                        }\n                    }\n\n                    maxCapacity = max(maxCapacity, capacity);\n                }\n            }\n        }\n    }\n\n    return maxCapacity;\n}\n\nint main() {\n    int T;\n    cin >> T;\n\n    while (T--) {\n        int rows, cols;\n        cin >> rows >> cols;\n\n        vector<vector<int>> grid(rows, vector<int>(cols));\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                cin >> grid[i][j];\n            }\n        }\n\n        int result = calculatePondCapacity(grid);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_pond_capacity(elevations):\n    import heapq\n    \n    if not elevations or not elevations[0]:\n        return 0\n\n    n, m = len(elevations), len(elevations[0])\n    visited = [[False] * m for _ in range(n)]\n    min_heap = []\n    \n    # Push all border cells into the heap\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n-1 or j == 0 or j == m-1:\n                heapq.heappush(min_heap, (elevations[i][j], i, j))\n                visited[i][j] = True\n                \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    max_capacity = 0\n    max_elevation = float('-inf')\n    \n    while min_heap:\n        elevation, r, c = heapq.heappop(min_heap)\n        max_elevation = max(max_elevation, elevation)\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc]:\n                visited[nr][nc] = True\n                neutral_elevation = max_elevation if max_elevation > elevations[nr][nc] else elevations[nr][nc]\n                max_capacity += max(0, max_elevation - elevations[nr][nc])\n                heapq.heappush(min_heap, (neutral_elevation, nr, nc))\n    \n    return max_capacity\n\n# Example usage:\nelevation_map = [\n    [1, 3, 2, 4],\n    [3, 0, 1, 5],\n    [4, 2, 3, 3]\n]\nprint(max_pond_capacity(elevation_map))  # Output: 3",
    "timestamp": "2025-08-13 04:43:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PondCapacity {\n\n    private static class Cell {\n        int x, y, height;\n        public Cell(int x, int y, int height) {\n            this.x = x;\n            this.y = y;\n            this.height = height;\n        }\n    }\n\n    private static final int[] DX = {-1, 1, 0, 0};\n    private static final int[] DY = {0, 0, -1, 1};\n    \n    public int computeMaxCapacity(int[][] elevations) {\n        int rows = elevations.length;\n        int cols = elevations[0].length;\n        \n        if (rows < 3 || cols < 3) return 0;\n        \n        PriorityQueue<Cell> pq = new PriorityQueue<>(Comparator.comparingInt(c -> c.height));\n        boolean[][] visited = new boolean[rows][cols];\n        \n        for (int i = 0; i < rows; i++) {\n            visited[i][0] = true;\n            visited[i][cols - 1] = true;\n            pq.offer(new Cell(i, 0, elevations[i][0]));\n            pq.offer(new Cell(i, cols - 1, elevations[i][cols - 1]));\n        }\n        \n        for (int j = 0; j < cols; j++) {\n            visited[0][j] = true;\n            visited[rows - 1][j] = true;\n            pq.offer(new Cell(0, j, elevations[0][j]));\n            pq.offer(new Cell(rows - 1, j, elevations[rows - 1][j]));\n        }\n        \n        int maxCapacity = 0;\n        \n        while (!pq.isEmpty()) {\n            Cell current = pq.poll();\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + DX[d];\n                int ny = current.y + DY[d];\n                if (nx > 0 && nx < rows - 1 && ny > 0 && ny < cols - 1 && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    maxCapacity += Math.max(0, current.height - elevations[nx][ny]);\n                    pq.offer(new Cell(nx, ny, Math.max(elevations[nx][ny], current.height)));\n                }\n            }\n        }\n        \n        return maxCapacity;\n    }\n\n    public static void main(String[] args) {\n        PondCapacity pc = new PondCapacity();\n        \n        int[][] elevations = {\n            {1, 4, 3, 1, 3, 2},\n            {3, 2, 1, 3, 2, 4},\n            {2, 3, 3, 2, 3, 1}\n        };\n        \n        int maxCapacity = pc.computeMaxCapacity(elevations);\n        System.out.println(\"Maximum pond capacity: \" + maxCapacity);\n    }\n}",
    "timestamp": "2025-08-13 04:43:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint n, m;\nint** elevation;\nint** visited;\nint** water;\nint maxCapacity = 0;\n\nvoid dfs(int x, int y, int minHeight) {\n    if (x < 0 || y < 0 || x >= n || y >= m || visited[x][y] || elevation[x][y] >= minHeight) \n        return;\n    visited[x][y] = 1;\n    int capacity = MAX(0, minHeight - elevation[x][y]);\n    water[x][y] = capacity;\n    maxCapacity += capacity;\n\n    dfs(x + 1, y, minHeight);\n    dfs(x - 1, y, minHeight);\n    dfs(x, y + 1, minHeight);\n    dfs(x, y - 1, minHeight);\n}\n\nint main() {\n    printf(\"Enter dimensions of the garden (n m): \");\n    scanf(\"%d %d\", &n, &m);\n\n    elevation = (int**) malloc(n * sizeof(int*));\n    visited = (int**) malloc(n * sizeof(int*));\n    water = (int**) malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        elevation[i] = (int*) malloc(m * sizeof(int));\n        visited[i] = (int*) malloc(m * sizeof(int));\n        water[i] = (int*) malloc(m * sizeof(int));\n    }\n\n    printf(\"Enter elevation grid:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &elevation[i][j]);\n            visited[i][j] = 0;\n            water[i][j] = 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        dfs(i, 0, INT_MAX);\n        dfs(i, m - 1, INT_MAX);\n    }\n    for (int j = 0; j < m; j++) {\n        dfs(0, j, INT_MAX);\n        dfs(n - 1, j, INT_MAX);\n    }\n\n    printf(\"Maximum water capacity: %d\\n\", maxCapacity);\n\n    for (int i = 0; i < n; i++) {\n        free(elevation[i]);\n        free(visited[i]);\n        free(water[i]);\n    }\n    free(elevation);\n    free(visited);\n    free(water);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:43:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_max_pond_capacity(grid):\n    if not grid or not grid[0]:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    max_capacity = 0\n\n    for top in range(rows - 2):\n        for bottom in range(top + 1, rows):\n            for left in range(cols - 2):\n                for right in range(left + 1, cols):\n                    capacity = calculate_pond_capacity(grid, top, bottom, left, right)\n                    max_capacity = max(max_capacity, capacity)\n\n    return max_capacity\n\ndef calculate_pond_capacity(grid, top, bottom, left, right):\n    # Check if boundaries are higher than inner cells\n    if not is_valid_boundary(grid, top, bottom, left, right):\n        return 0\n\n    # Calculate water level as the minimum height of boundaries\n    water_level = min(\n        min(grid[top][left:right+1]),\n        min(grid[bottom][left:right+1]),\n        min(row[left] for row in grid[top:bottom+1]),\n        min(row[right] for row in grid[top:bottom+1])\n    )\n\n    # Calculate inner cell heights\n    inner_heights = [\n        grid[r][c] for r in range(top+1, bottom) for c in range(left+1, right)\n    ]\n\n    # Calculate water capacity\n    capacity = sum(max(water_level - height, 0) for height in inner_heights)\n    return capacity\n\ndef is_valid_boundary(grid, top, bottom, left, right):\n    # Check top and bottom rows\n    if any(grid[top][left:right+1][i] <= grid[top+1][left:right+1][i] or \n           grid[bottom][left:right+1][i] <= grid[bottom-1][left:right+1][i] \n           for i in range(right-left+1)):\n        return False\n\n    # Check left and right columns\n    if any(grid[r][left] <= grid[r][left+1] or \n           grid[r][right] <= grid[r][right-1] \n           for r in range(top+1, bottom)):\n        return False\n\n    return True\n\n# Example usage\ngrid = [\n    [1, 1, 1, 1, 1, 1],\n    [1, 2, 2, 2, 2, 1],\n    [1, 2, 3, 3, 2, 1],\n    [1, 2, 3, 3, 2, 1],\n    [1, 2, 2, 2, 2, 1],\n    [1, 1, 1, 1, 1, 1]\n]\n\nprint(calculate_max_pond_capacity(grid))",
    "timestamp": "2025-08-13 04:44:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef max_pond_capacity(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    if rows < 3 or cols < 3:\n        return 0\n    \n    heap = []\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    \n    # Push all boundary cells into the heap\n    for i in range(rows):\n        for j in [0, cols - 1]:\n            heapq.heappush(heap, (grid[i][j], i, j))\n            visited[i][j] = True\n    for j in range(1, cols - 1):\n        for i in [0, rows - 1]:\n            heapq.heappush(heap, (grid[i][j], i, j))\n            visited[i][j] = True\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    max_capacity = 0\n    \n    while heap:\n        current_height, x, y = heapq.heappop(heap)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]:\n                neighbor_height = grid[nx][ny]\n                if neighbor_height < current_height:\n                    max_capacity += current_height - neighbor_height\n                    grid[nx][ny] = current_height  # Fill the pond to current_height\n                visited[nx][ny] = True\n                heapq.heappush(heap, (max(current_height, neighbor_height), nx, ny))\n    \n    return max_capacity\n\n# Read input and process\nimport sys\ndef main():\n    input_lines = [line.strip() for line in sys.stdin if line.strip()]\n    idx = 0\n    while idx < len(input_lines):\n        rows, cols = map(int, input_lines[idx].split())\n        idx += 1\n        grid = []\n        for _ in range(rows):\n            grid.append(list(map(int, input_lines[idx].split())))\n            idx += 1\n        print(max_pond_capacity(grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 04:44:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// A structure to represent a cell in a grid\nstruct Cell {\n    int x, y, height;\n    Cell(int x, int y, int height): x(x), y(y), height(height) {}\n};\n\n// Custom comparator for priority queue\nstruct Compare {\n    bool operator()(const Cell& a, const Cell& b) {\n        return a.height > b.height;\n    }\n};\n\nint maxPondCapacity(vector<vector<int>>& heights) {\n    if (heights.empty() || heights[0].empty()) return 0;\n    int m = heights.size(), n = heights[0].size();\n    \n    // Priority queue to process cells in order of height\n    priority_queue<Cell, vector<Cell>, Compare> pq;\n    \n    // Visited array\n    vector<vector<bool>> visited(m, vector<bool>(n, false));\n    \n    // Add all border cells to the priority queue and mark them as visited\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == 0 || i == m-1 || j == 0 || j == n-1) {\n                pq.push(Cell(i, j, heights[i][j]));\n                visited[i][j] = true;\n            }\n        }\n    }\n    \n    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int maxCapacity = 0;\n\n    while (!pq.empty()) {\n        Cell cell = pq.top();\n        pq.pop();\n        \n        // Check all 4 directions\n        for (auto& dir : directions) {\n            int nx = cell.x + dir[0];\n            int ny = cell.y + dir[1];\n            \n            if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\n            \n            visited[nx][ny] = true;\n            \n            // Calculate the water capacity\n            if (heights[nx][ny] < cell.height) {\n                maxCapacity += cell.height - heights[nx][ny];\n            }\n            \n            // Push the maximum of current cell's height and neighbor's height\n            pq.push(Cell(nx, ny, max(heights[nx][ny], cell.height)));\n        }\n    }\n\n    return maxCapacity;\n}\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    vector<vector<int>> heights(m, vector<int>(n));\n    for (int i = 0; i < m; ++i) \n        for (int j = 0; j < n; ++j) \n            cin >> heights[i][j];\n    \n    cout << maxPondCapacity(heights) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:21:28"
  }
]