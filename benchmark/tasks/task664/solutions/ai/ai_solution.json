[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100005\n\n// Structure to store vertex information\ntypedef struct {\n    int value;\n    int weight;\n} Item;\n\nItem items[MAX_N];\nint dp[MAX_N][505];  // DP table for memoization\n\n// Function to solve the query\nint solve_query(int v, int L) {\n    // Base case: if vertex is invalid or weight limit is exhausted\n    if (v == 0 || L < 0) return 0;\n\n    // Check memoized result\n    if (dp[v][L] != -1) return dp[v][L];\n\n    // Option 1: Do not select current vertex's item\n    int without_current = solve_query(v / 2, L);\n\n    // Option 2: Select current vertex's item if possible\n    int with_current = 0;\n    if (items[v].weight <= L) {\n        with_current = items[v].value + solve_query(v / 2, L - items[v].weight);\n    }\n\n    // Store and return the maximum value\n    dp[v][L] = (without_current > with_current) ? without_current : with_current;\n    return dp[v][L];\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Read items' values and weights\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &items[i].value, &items[i].weight);\n    }\n\n    // Initialize DP table with -1\n    memset(dp, -1, sizeof(dp));\n\n    // Process queries\n    while (Q--) {\n        int v, L;\n        scanf(\"%d %d\", &v, &L);\n        printf(\"%d\\n\", solve_query(v, L));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int v;\n    int w;\n} Item;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nvoid solve() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    Item items[N+1];\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &items[i].v, &items[i].w);\n    }\n    \n    while (Q--) {\n        int v, L;\n        scanf(\"%d %d\", &v, &L);\n        \n        int path[60];\n        int k = 0;\n        while (v >= 1) {\n            path[k++] = v;\n            v /= 2;\n        }\n        \n        int dp[60][100001] = {0};\n        for (int i = 0; i < k; i++) {\n            int current = path[i];\n            for (int j = 0; j <= L; j++) {\n                if (i == 0) {\n                    if (items[current].w <= j) {\n                        dp[i][j] = items[current].v;\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                } else {\n                    if (items[current].w <= j) {\n                        dp[i][j] = max(dp[i-1][j], dp[i-1][j - items[current].w] + items[current].v);\n                    } else {\n                        dp[i][j] = dp[i-1][j];\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", dp[k-1][L]);\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    long long value;\n    long long weight;\n};\n\nvoid solve() {\n    int N;\n    cin >> N;\n    vector<Item> items(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> items[i].value >> items[i].weight;\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int v;\n        long long L;\n        cin >> v >> L;\n\n        vector<Item> ancestors;\n        while (v >= 1) {\n            ancestors.push_back(items[v]);\n            v /= 2;\n        }\n\n        int m = ancestors.size();\n        vector<vector<long long>> dp(m + 1, vector<long long>(L + 1, 0));\n\n        for (int i = 1; i <= m; ++i) {\n            for (long long w = 0; w <= L; ++w) {\n                dp[i][w] = dp[i - 1][w];\n                if (w >= ancestors[i - 1].weight) {\n                    dp[i][w] = max(dp[i][w], dp[i - 1][w - ancestors[i - 1].weight] + ancestors[i - 1].value);\n                }\n            }\n        }\n\n        cout << dp[m][L] << endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Item {\n        int v, w;\n        Item(int v, int w) {\n            this.v = v;\n            this.w = w;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Item[] items = new Item[N + 1];\n        for (int i = 1; i <= N; i++) {\n            int v = sc.nextInt();\n            int w = sc.nextInt();\n            items[i] = new Item(v, w);\n        }\n\n        int Q = sc.nextInt();\n        while (Q-- > 0) {\n            int v = sc.nextInt();\n            int L = sc.nextInt();\n            List<Item> ancestors = new ArrayList<>();\n            while (v >= 1) {\n                ancestors.add(items[v]);\n                v /= 2;\n            }\n            int n = ancestors.size();\n            int maxValue = 0;\n            for (int mask = 0; mask < (1 << n); mask++) {\n                int totalWeight = 0;\n                int totalValue = 0;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        totalWeight += ancestors.get(i).w;\n                        totalValue += ancestors.get(i).v;\n                    }\n                }\n                if (totalWeight <= L && totalValue > maxValue) {\n                    maxValue = totalValue;\n                }\n            }\n            System.out.println(maxValue);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:30:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxValueAncestors {\n    static class Item {\n        int value;\n        int weight;\n        \n        Item(int value, int weight) {\n            this.value = value;\n            this.weight = weight;\n        }\n    }\n    \n    public static int[] solve(int N, Item[] items, int[][] queries) {\n        int[] result = new int[queries.length];\n        \n        for (int q = 0; q < queries.length; q++) {\n            int v = queries[q][0];\n            int L = queries[q][1];\n            \n            List<Item> ancestors = new ArrayList<>();\n            while (v > 0) {\n                ancestors.add(items[v]);\n                v /= 2;\n            }\n            \n            int[][] dp = new int[ancestors.size() + 1][L + 1];\n            \n            for (int i = 1; i <= ancestors.size(); i++) {\n                Item curr = ancestors.get(i - 1);\n                for (int j = 0; j <= L; j++) {\n                    dp[i][j] = dp[i-1][j];\n                    if (j >= curr.weight) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i-1][j-curr.weight] + curr.value);\n                    }\n                }\n            }\n            \n            result[q] = dp[ancestors.size()][L];\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        Item[] items = new Item[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            int value = scanner.nextInt();\n            int weight = scanner.nextInt();\n            items[i] = new Item(value, weight);\n        }\n        \n        int Q = scanner.nextInt();\n        int[][] queries = new int[Q][2];\n        \n        for (int i = 0; i < Q; i++) {\n            queries[i][0] = scanner.nextInt();\n            queries[i][1] = scanner.nextInt();\n        }\n        \n        int[] results = solve(N, items, queries);\n        \n        for (int result : results) {\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:30:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N, Q;\nint value[MAXN], weight[MAXN];\nvector<int> adj[MAXN];\n\n// Dynamic programming memoization table\nint dp[MAXN][105];\n\n// Fill DP table using top-down dynamic programming\nint solve(int node, int remaining_weight) {\n    // Memoization check\n    if (dp[node][remaining_weight] != -1)\n        return dp[node][remaining_weight];\n    \n    // Base case\n    int parent = node / 2;\n    int max_value = 0;\n    \n    // Option 1: Do not select current node's item\n    int skip_value = (parent > 0) ? solve(parent, remaining_weight) : 0;\n    \n    // Option 2: Select current node's item if possible\n    int select_value = 0;\n    if (weight[node] <= remaining_weight) {\n        int next_weight = remaining_weight - weight[node];\n        int parent_value = (parent > 0) ? solve(parent, next_weight) : 0;\n        select_value = value[node] + parent_value;\n    }\n    \n    // Take maximum of the two options\n    max_value = max(skip_value, select_value);\n    \n    // Memoize and return\n    return dp[node][remaining_weight] = max_value;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    // Input tree details\n    cin >> N >> Q;\n    for (int i = 1; i <= N; i++) {\n        cin >> value[i] >> weight[i];\n    }\n    \n    // Process queries\n    while (Q--) {\n        int v, L;\n        cin >> v >> L;\n        \n        // Reset DP table\n        memset(dp, -1, sizeof(dp));\n        \n        // Output max possible value\n        cout << solve(v, L) << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:30:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_total_value(items, queries):\n    def knapsack(weights, values, capacity):\n        dp = [0] * (capacity + 1)\n        for i in range(len(weights)):\n            for j in range(capacity, weights[i] - 1, -1):\n                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])\n        return dp[capacity]\n\n    results = []\n    for v, L in queries:\n        selected_weights = []\n        selected_values = []\n        while v >= 1:\n            selected_weights.append(items[v][0])\n            selected_values.append(items[v][1])\n            v //= 2\n        results.append(knapsack(selected_weights, selected_values, L))\n    \n    return results\n\n# Example usage:\nN = 5\nitems = {\n    1: (2, 3),\n    2: (2, 4),\n    3: (3, 8),\n    4: (1, 1),\n    5: (5, 7)\n}\nqueries = [\n    (5, 7),\n    (3, 4)\n]\nprint(max_total_value(items, queries))  # Output: [11, 8]",
    "timestamp": "2025-08-13 11:02:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BinaryTreeKnapsack {\n\n    static class Vertex {\n        int value;\n        int weight;\n        Vertex parent;\n\n        Vertex(int value, int weight, Vertex parent) {\n            this.value = value;\n            this.weight = weight;\n            this.parent = parent;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        \n        Vertex[] vertices = new Vertex[N + 1];\n        vertices[1] = new Vertex(sc.nextInt(), sc.nextInt(), null);\n\n        for (int i = 2; i <= N; i++) {\n            int value = sc.nextInt();\n            int weight = sc.nextInt();\n            int parentIndex = i / 2;\n            vertices[i] = new Vertex(value, weight, vertices[parentIndex]);\n        }\n\n        int Q = sc.nextInt();\n        for (int q = 0; q < Q; q++) {\n            int v = sc.nextInt();\n            int L = sc.nextInt();\n            System.out.println(maxValue(vertices[v], L));\n        }\n        sc.close();\n    }\n\n    private static int maxValue(Vertex vertex, int L) {\n        List<Vertex> ancestry = new ArrayList<>();\n        while (vertex != null) {\n            ancestry.add(vertex);\n            vertex = vertex.parent;\n        }\n\n        int n = ancestry.size();\n        int[][] dp = new int[n + 1][L + 1];\n\n        for (int i = 1; i <= n; i++) {\n            Vertex curr = ancestry.get(i - 1);\n            int vi = curr.value;\n            int wi = curr.weight;\n\n            for (int w = 0; w <= L; w++) {\n                if (wi <= w) {\n                    dp[i][w] = Math.max(dp[i - 1][w], vi + dp[i - 1][w - wi]);\n                } else {\n                    dp[i][w] = dp[i - 1][w];\n                }\n            }\n        }\n\n        return dp[n][L];\n    }\n}",
    "timestamp": "2025-08-13 11:02:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 1001\n#define MAXL 1001\n\nint V[MAXN], W[MAXN];\nint dp[MAXN][MAXL];\n\nint solveQuery(int v, int L) {\n    memset(dp, 0, sizeof(dp));\n    int current = v;\n    int ancestorCount = 0;\n    \n    while (current > 0) {\n        ancestorCount++;\n        for (int weightLimit = 0; weightLimit <= L; ++weightLimit) {\n            if (weightLimit >= W[current]) {\n                dp[ancestorCount][weightLimit] = dp[ancestorCount - 1][weightLimit - W[current]] + V[current];\n            }\n            dp[ancestorCount][weightLimit] = dp[ancestorCount][weightLimit] > dp[ancestorCount - 1][weightLimit] ? dp[ancestorCount][weightLimit] : dp[ancestorCount - 1][weightLimit];\n        }\n        current /= 2;\n    }\n    \n    return dp[ancestorCount][L];\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%d %d\", &V[i], &W[i]);\n    }\n    \n    scanf(\"%d\", &Q);\n    while (Q--) {\n        int v, L;\n        scanf(\"%d %d\", &v, &L);\n        printf(\"%d\\n\", solveQuery(v, L));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:02:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Node {\n    constructor(value, weight) {\n        this.value = value;\n        this.weight = weight;\n    }\n}\n\nfunction knapsack(nodes, v, L) {\n    const ancestors = [];\n    while (v >= 1) {\n        ancestors.push(nodes[v - 1]);\n        v = Math.floor(v / 2);\n    }\n\n    const n = ancestors.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(L + 1).fill(0));\n\n    for (let i = 1; i <= n; i++) {\n        for (let w = 0; w <= L; w++) {\n            const currentNode = ancestors[i - 1];\n            if (currentNode.weight > w) {\n                dp[i][w] = dp[i - 1][w];\n            } else {\n                dp[i][w] = Math.max(\n                    dp[i - 1][w],\n                    dp[i - 1][w - currentNode.weight] + currentNode.value\n                );\n            }\n        }\n    }\n\n    return dp[n][L];\n}\n\nfunction processQueries(nodes, queries) {\n    const results = [];\n    for (const [v, L] of queries) {\n        results.push(knapsack(nodes, v, L));\n    }\n    return results;\n}\n\n// Usage:\n// const nodes = [\n//     new Node(V_1, W_1),\n//     new Node(V_2, W_2),\n//     ...,\n//     new Node(V_N, W_N)\n// ];\n\n// const queries = [\n//     [v1, L1],\n//     [v2, L2],\n//     ...,\n//     [vQ, LQ]\n// ];\n\n// const results = processQueries(nodes, queries);\n// console.log(results);",
    "timestamp": "2025-08-13 11:02:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def __init__(self, N, values, weights):\n        self.N = N\n        self.values = values\n        self.weights = weights\n        self.dp = [[0] * 2 for _ in range(N + 1)]\n\n    def compute_dp(self):\n        for i in range(self.N, 0, -1):\n            parent = i // 2\n            \n            # Not taking current vertex\n            self.dp[i][0] = self.dp[2*i][0] + self.dp[2*i+1][0] if 2*i <= self.N else 0\n            \n            # Taking current vertex\n            take_value = self.values[i-1]\n            take_weight = self.weights[i-1]\n            max_subtree_not_taken = self.dp[2*i][0] + self.dp[2*i+1][0] if 2*i <= self.N else 0\n            self.dp[i][1] = max_subtree_not_taken + take_value\n\n    def solve_query(self, v, L):\n        def dfs(vertex, remaining_weight):\n            if vertex > self.N:\n                return 0\n            \n            # Case 1: Do not take current vertex\n            skip_value = dfs(2*vertex, remaining_weight) + dfs(2*vertex+1, remaining_weight)\n            \n            # Case 2: Take current vertex if possible\n            take_value = 0\n            if self.weights[vertex-1] <= remaining_weight:\n                take_value = self.values[vertex-1] + \\\n                             dfs(2*vertex, remaining_weight - self.weights[vertex-1]) + \\\n                             dfs(2*vertex+1, remaining_weight - self.weights[vertex-1])\n            \n            return max(skip_value, take_value)\n\n        return dfs(v, L)\n\ndef main():\n    # Input parsing\n    N, Q = map(int, input().split())\n    values = list(map(int, input().split()))\n    weights = list(map(int, input().split()))\n    \n    solution = Solution(N, values, weights)\n    solution.compute_dp()\n    \n    # Process queries\n    for _ in range(Q):\n        v, L = map(int, input().split())\n        result = solution.solve_query(v, L)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 11:02:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Solution {\n    constructor(N, values, weights) {\n        this.N = N;\n        this.values = values;\n        this.weights = weights;\n        this.dp = new Array(N + 1).fill(null).map(() => new Array(10001).fill(-1));\n    }\n\n    solve(v, L) {\n        const memo = (node, remainingWeight) => {\n            if (node < 1) return 0;\n            \n            if (this.dp[node][remainingWeight] !== -1) {\n                return this.dp[node][remainingWeight];\n            }\n            \n            let parentNode = Math.floor(node / 2);\n            \n            // Case 1: Not taking current node\n            let notTaking = memo(parentNode, remainingWeight);\n            \n            // Case 2: Taking current node if weight allows\n            let taking = 0;\n            if (this.weights[node - 1] <= remainingWeight) {\n                taking = this.values[node - 1] + memo(parentNode, remainingWeight - this.weights[node - 1]);\n            }\n            \n            this.dp[node][remainingWeight] = Math.max(taking, notTaking);\n            return this.dp[node][remainingWeight];\n        };\n        \n        return memo(v, L);\n    }\n}\n\n// Example usage\nconst N = 7;\nconst values = [3, 2, 4, 5, 1, 6, 7];\nconst weights = [1, 2, 3, 4, 5, 6, 7];\nconst solution = new Solution(N, values, weights);\n\nconst Q = 3;\nconst queries = [\n    { v: 5, L: 10 },\n    { v: 3, L: 5 },\n    { v: 7, L: 15 }\n];\n\nqueries.forEach(query => {\n    console.log(solution.solve(query.v, query.L));\n});",
    "timestamp": "2025-08-13 11:02:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    \n    V = [0] * (N + 1)\n    W = [0] * (N + 1)\n    for i in range(1, N + 1):\n        V[i] = int(input[ptr])\n        W[i] = int(input[ptr + 1])\n        ptr += 2\n    \n    # Preprocess for each node, the list of ancestors (including itself)\n    ancestors = [[] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        v = i\n        while v >= 1:\n            ancestors[i].append(v)\n            v = v // 2\n    \n    Q = int(input[ptr])\n    ptr += 1\n    \n    for _ in range(Q):\n        v = int(input[ptr])\n        L = int(input[ptr + 1])\n        ptr += 2\n        \n        nodes = ancestors[v]\n        k = len(nodes)\n        max_value = 0\n        \n        # Generate all subsets of the nodes\n        for mask in range(1 << k):\n            total_weight = 0\n            total_value = 0\n            for i in range(k):\n                if mask & (1 << i):\n                    node = nodes[i]\n                    total_weight += W[node]\n                    total_value += V[node]\n                    if total_weight > L:\n                        break\n            if total_weight <= L and total_value > max_value:\n                max_value = total_value\n        print(max_value)\n\nsolve()",
    "timestamp": "2025-08-13 11:03:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nlet ptr = 0;\nconst [N, Q] = input[ptr++].split(' ').map(Number);\nconst V = new Array(N + 1).fill(0);\nconst W = new Array(N + 1).fill(0);\n\nfor (let i = 1; i <= N; i++) {\n    const [v, w] = input[ptr++].split(' ').map(Number);\n    V[i] = v;\n    W[i] = w;\n}\n\nconst ancestors = new Array(N + 1).fill(null).map(() => []);\n\nfor (let i = 1; i <= N; i++) {\n    let current = i;\n    while (current >= 1) {\n        ancestors[i].push(current);\n        current = Math.floor(current / 2);\n    }\n}\n\nconst solveQuery = (v, L) => {\n    const nodes = ancestors[v];\n    const n = nodes.length;\n    let maxValue = 0;\n    \n    for (let mask = 0; mask < (1 << n); mask++) {\n        let totalWeight = 0;\n        let totalValue = 0;\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                const node = nodes[i];\n                totalWeight += W[node];\n                totalValue += V[node];\n            }\n        }\n        if (totalWeight <= L && totalValue > maxValue) {\n            maxValue = totalValue;\n        }\n    }\n    return maxValue;\n};\n\nconst output = [];\nfor (let q = 0; q < Q; q++) {\n    const [v, L] = input[ptr++].split(' ').map(Number);\n    output.push(solveQuery(v, L));\n}\n\nconsole.log(output.join('\\n'));",
    "timestamp": "2025-08-13 11:03:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    int value;\n    int weight;\n};\n\nint knapsack(int L, vector<Item>& items) {\n    vector<int> dp(L + 1, 0);\n    for (const auto& item : items) {\n        for (int w = L; w >= item.weight; --w) {\n            dp[w] = max(dp[w], dp[w - item.weight] + item.value);\n        }\n    }\n    return dp[L];\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<int> V(N + 1);\n    vector<int> W(N + 1);\n    \n    for (int i = 1; i <= N; ++i) {\n        cin >> V[i] >> W[i];\n    }\n    \n    while (Q--) {\n        int v, L;\n        cin >> v >> L;\n        \n        vector<Item> items;\n        while (v > 0) {\n            items.push_back({V[v], W[v]});\n            v /= 2;\n        }\n        \n        cout << knapsack(L, items) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:11"
  }
]