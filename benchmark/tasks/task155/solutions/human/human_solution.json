[
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=1e5+10;\nlong long int a[N],n;\nbool check(long long int val){\n    long long int now=0,cnt=0;\n    for(int i=0;i<n;i++){\n        now+=a[i];\n        if(now>=val){\n            now=0;\n            cnt++;\n            if(cnt>=3)return true;\n        }\n    }\n    return false;\n}\nint main(){\n    long long int ans=0,l=0,r=0,mid;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n        r+=a[i];\n    }\n    while(r-l>1){\n        mid=(r+l)/2;\n        if(check(mid))r=mid;\n        else l=mid;\n    }\n    \n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint n;\n\n\nbool solve(ll mid,vector<ll> rsum){\n    rep(i,n+1){\n        ll start = rsum[i];\n        \n        int a=lower_bound(all(rsum),start  +mid)-rsum.begin();\n        if(a>=i+n+1)continue;\n        \n        int b=lower_bound(all(rsum),rsum[a]+mid)-rsum.begin();\n        if(b>=i+n+1)continue;\n        \n        int c=lower_bound(all(rsum),rsum[b]+mid)-rsum.begin();\n        if(c>=i+n+1)continue;\n        \n        return true;\n    }\n    return false;\n\n}\n\n\nint main(){\n    ll sum=0;\n    cin>>n;\n    vector<ll> vec(n);\n    rep(i,n){\n        cin>>vec[i];\n        sum += vec[i];\n    }\n\n    vector<ll> rsum(2*n+1,0);\n    rep(i,2*n)rsum[i+1] = rsum[i]+vec[i%n];\n\n    \n    ll left = 0;\n    ll right = sum;\n    ll mid;\n    while(1){\n        mid = (left+right)/2LL;\n        if(left+1>=right)break;\n\n        bool res = solve(mid,rsum);\n//        cout<<left<<\" \"<<right<<\" \"<<\" \"<<mid<<\" \"<<res<<endl;\n        \n        if(res){\n            left = mid;\n        }else{\n            right = mid;\n        }\n    }\n    cout<<mid<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nll _sum[300010], *sum = _sum+1;\nint main(void){\n\t_sum[0] = 0;\n\tint N;\n\tcin >> N;\n\tREP(i, N){\n\t\tcin >> sum[i];\n\t\tsum[i+N] = sum[i];\n\t\tsum[i+2*N] = sum[i];\n\t}\n\tFOR(i, 1, N*3){\n\t\tsum[i] += sum[i-1];\n\t}\n\tll res = 0;\n\tREP(i, N){\n\t\tll fs, sc, th;\n\t\tfs = *(lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+sum[i])-1);\n\t\tsc = *(lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+fs)-1);\n\t\tsc -= fs;\n\t\tfs -= sum[i-1];\n\t\tth = sum[N-1]-fs-sc;\n\t\tres = max(res, min(fs, min(sc, th)));\n\t\tsc = *lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+fs+sum[i-1]);\n\t\tsc -= fs + sum[i-1];\n\t\tth = sum[N-1]-fs-sc;\n\t\tres = max(res, min(fs, min(sc, th)));\n\t\tfs = *lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+sum[i]);\n\t\tsc = *(lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+fs)-1);\n\t\tsc -= fs;\n\t\tfs -= sum[i-1];\n\t\tth = sum[N-1]-fs-sc;\n\t\tres = max(res, min(fs, min(sc, th)));\n\t\tsc = *lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+fs+sum[i-1]);\n\t\tsc -= fs + sum[i-1];\n\t\tth = sum[N-1]-fs-sc;\n\t\tres = max(res, min(fs, min(sc, th)));\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tunsigned int a[125000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[n][0] = a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i + n][0] = a[i][0];\n\t\ta[i][1] = a[i - 1][1] + a[i - 1][0];\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\ta[i + n][1] = a[i + n - 1][1] + a[i + n - 1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n - 1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2, b1, b2_1, b2_2;\t//cut??????????????????????????????????????????????????¢??????\n\t\tfor (cut2 = cut1 + 1; cut2 < cut1 + n; cut2++){\n\t\t\tif ((b1 = a[cut2][1] - a[cut1][1]) > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < cut2 - 1 + n; cut3_1++){\n\t\t\tif ((b2_1 = a[cut3_1][1] - a[cut2 - 1][1]) > (baum - (b1 - a[cut2 - 1][0])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 <cut2 + n; cut3_2++){\n\t\t\tif ((b2_2 = a[cut3_2][1] - a[cut2][1]) > (baum - b1) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = b1 - a[cut2 - 1][0];\n\t\tb[0][1] = b2_1 - a[cut3_1 - 1][0];\n\t\tb[0][2] = baum - b1 - b2_1 + a[cut2 - 1][0] + a[cut3_1 - 1][0];\n\t\tb[1][0] = b1 - a[cut2 - 1][0];\n\t\tb[1][1] = b2_1;\n\t\tb[1][2] = baum - b1 - b2_1 + a[cut2 - 1][0];\n\t\tb[2][0] = b1;\n\t\tb[2][1] = b2_2 - a[cut3_2 - 1][0];\n\t\tb[2][2] = baum - b1 - b2_2 + a[cut3_2 - 1][0];\n\t\tb[3][0] = b1;\n\t\tb[3][1] = b2_2;\n\t\tb[3][2] = baum - b1 - b2_2;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=1;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\twhile (t<s+N && a<=ans){\n\t\t\tt++;\n\t\t\ta+=A[(t-1)%N];\n\t\t}\n\t\tif (t==s+N) break;\n\t\t//aがansを更新できるか\n\t\tauto p=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\tif (p!=sum+s+N){\n\t\t\t//見つかった\n\t\t\tb=*p-sum[t-1];\n\t\t\tc=sum[N-1]-b-a;\n\t\t\tif (c>=a){\n\t\t\t\t//aが最小値\n\t\t\t\tans=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans=max(ans,c);\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n, s;\n\n// ?????????????????????x??\\?????§3????????????????????¨?????§?????????\nbool solve(ll x) {\n\tREP(i, n) {\n\t\tbool flag = true;\n\t\tint pos = i;\n\t\tREP(j, 2) {\n\t\t\tpos = lower_bound(sum + i, sum + i + n, sum[pos] + x) - sum;\n\t\t\tif (pos == i + n) { flag = false; break; }\n\t\t}\n\t\tif (flag) {\n\t\t\tif (i == 0 && s - sum[pos] >= x) return true;\n\t\t\telse if (s - (sum[pos] - sum[i]) >= x) return true;;\n\t\t}\n\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t\ts += a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200001];\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tret = max(ret, min( { sum(i, j), sum(j, k), sum(k, n + i) } ));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N;\nlong long A[200010];\nlong long T[200010];\n\nbool f(int X) {\n  for (int i=0; i<N; i++) {\n    long long j = i;\n    long long d = 0;\n    bool ok = false;\n    for (; j<i+N; j++) {\n      d += A[j];\n      if (d >= X) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) continue;\n    j++;\n    long long g = j;\n\n    d = 0;\n    for (; j<i+N; j++) {\n      d += A[j];\n      if (d >= X) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) continue;\n    j++;\n\n    if (T[i+N-1] - T[j-1] >= X) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    int a;\n    cin >> a;\n    A[i] = A[i+N] = a;\n  }\n  long long t = 0;\n  for (int i=0; i<N+N; i++) {\n    t += A[i];\n    T[i] = t;\n  }\n\n  int lo = 0, hi = 1000000100L;\n  int m;\n  while (hi - lo > 1) {\n    m = (lo + hi) / 2;\n    if (f(m)) lo = m;\n    else      hi = m;\n  }\n  if (f(hi)) m = hi;\n  else       m = lo;\n\n  cout << m << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long;\nconst i64 INF = 1e16;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<i64> a(2 * n + 2, 0LL);\n    for(int i : in(n)) {\n        cin >> a[i + 1];\n        a[i + n + 1] = a[i + 1];\n    }\n    a.back() = INF;\n    for(int i : in(2 * n + 1)) a[i + 1] += a[i];\n    i64 ans = 0LL;\n    for(int i : in(n)) {\n        i64 lb = ans, ub = a[n] / 3LL + 1LL;\n        while(ub - lb > 1LL) {\n            i64 mid = (ub + lb) / 2LL;\n            bool ok = [&]() {\n                int cur = i;\n                for(int _ : in(2)) {\n                    int it = lower_bound(a.begin(), a.end(), a[cur] + mid) - a.begin();\n                    cur = it;\n                }\n                i64 rest = a[i + n] - a[cur];\n                return rest >= mid;\n            }();\n            if(ok) lb = mid;\n            else ub = mid;\n        }\n        ans = max(ans, lb);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\n#define MAX_N 100000\n\nusing namespace std;\n\nlong unsigned int A[MAX_N];\nunsigned int N;\n\nint main(void)\n{\n\tlong long int sum = 0;\n\tcin >> N;\n\tfor(unsigned int i = 0;i < N;i++)\n\t{\n\t\tcin >> A[i];\n\t\tsum += A[i];\n\t}\n\tlong long int sum3 = sum / 3;\n\tlong long int maxs = 0;\n\tfor(unsigned int i = 0;i < N;i++)\n\t{\n\t\tlong long int mindiff = sum3 - A[i % N],size1 = A[i % N];\n\t\tunsigned int mindiffi = 0;\n\t\tfor(unsigned int ii = i + 1;ii < N + i;ii++)\n\t\t{\n\t\t\tif(abs(mindiff - A[ii % N]) < abs(mindiff))\n\t\t\t{\n\t\t\t\tmindiff = mindiff - A[ii % N];\n\t\t\t\tsize1 += A[ii % N];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmindiffi = ii;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong long int mindiff2 = sum3 - A[mindiffi % N],size2 = A[mindiffi % N];\n\t\tunsigned int mindiff2i = 0;\n\t\tfor(unsigned int ii = mindiffi + 1;ii < N + mindiffi;ii++)\n\t\t{\n\t\t\tif(abs(mindiff2 - A[ii % N]) < abs(mindiff2))\n\t\t\t{\n\t\t\t\tmindiff2 = mindiff2 - A[ii % N];\n\t\t\t\tsize2 += A[ii % N];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmindiff2i = ii - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmaxs = max(maxs,min(sum - size1 - size2,min(size2,size1)));\n\t}\n\tcout << maxs << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[100010];\n\nvoid a(string s){}\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n    if (idx >= i + N) return false;\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n    if (idx2 >= i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 100010, 1e15);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e15+2;\n\n        rep(_, 50) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\n\n/**\n * バームクーヘンがそのサイズで切断できる\n */\nstatic bool iSCuttable(\n    const vector<SQWORD>& vecsqPos, \n    SQWORD sqN, \n    SQWORD sqTest) \n{\n    SQWORD sqSize = vecsqPos[sqN];\n\n    bool bIsCuttable = false;\n    for (SQWORD sqStartIdx = 0; sqStartIdx < sqN; sqStartIdx++) {\n        SQWORD sqStartPos = vecsqPos[sqStartIdx];\n        auto it0 = lower_bound(vecsqPos.begin(), vecsqPos.end(), sqStartPos + sqTest);\n        if (it0 == vecsqPos.end()) {\n            continue;\n        }\n        SQWORD sqCutPos0 = *it0;\n        auto it1 = lower_bound(vecsqPos.begin(), vecsqPos.end(), sqTest + sqCutPos0);\n        if (it1 == vecsqPos.end()) {\n            continue;\n        }\n        SQWORD sqCutPos1 = *it1;\n\n        if (sqSize + sqStartPos - sqCutPos1 < sqTest) {\n            continue;\n        }\n        bIsCuttable = true;\n        break;\n    }\n\n    return bIsCuttable;\n}\n\n\nstatic SQWORD binarySearch(\n    bool (*pfJudge)(const vector<SQWORD>&, SQWORD, SQWORD), \n    SQWORD sqInitLower, \n    SQWORD sqInitUpper, \n    const vector<SQWORD> &vecsqA,\n    SQWORD sqN)\n{\n    SQWORD sqNg = sqInitUpper;\n    SQWORD sqOk = sqInitLower;\n\n    while (1LL < sqNg - sqOk) {\n        SQWORD sqMid = (sqNg + sqOk) / 2LL;\n        if (pfJudge(vecsqA, sqN, sqMid)) {\n            sqOk = sqMid;\n        } else {\n            sqNg = sqMid;\n        }\n    }\n    return sqOk;\n}\n\n\n#define SQWORD_INF  (100100100100100100)\n\nint main(void)\n{\n    SQWORD sqInput_N = inputSQWORD();\n    vector<SQWORD> vecsqPos;\n\n    vecsqPos.emplace_back(0);\n\n    SQWORD sqPos = 0;\n    for (SQWORD sqIdx = 0; sqIdx < sqInput_N; sqIdx++) {\n        SQWORD sqInput_A = inputSQWORD();\n        sqPos += sqInput_A;\n        vecsqPos.emplace_back(sqPos);\n    }\n    SQWORD sqSize = sqPos;\n    for (SQWORD sqIdx = 1; sqIdx <= sqInput_N; sqIdx++) {\n        vecsqPos.emplace_back(vecsqPos[sqIdx] + sqSize);\n    }\n\n    SQWORD sqAns = binarySearch(iSCuttable, -1, SQWORD_INF, vecsqPos, sqInput_N);\n\n\n    printf(\"%lld\\n\", sqAns);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define ll long long\nusing namespace std;\n\nll round;\nint n;\nvector<ll> cumulative_sum;\n\nbool is_range_possible(ll required_range, int start) {\n    int cut = start;\n\n    for (int i = 0; i < 3; i++) {\n        auto x = lower_bound(cumulative_sum.begin(), cumulative_sum.end(), cumulative_sum[cut] + required_range);\n        cut = x - cumulative_sum.begin();\n        if (cut > start + n)return false;\n    }\n\n    return true;\n}\n\nll max_range(int start) {\n    ll ok = 0;\n    ll ng = round / 3 + 10;\n\n    while (abs(ok - ng) > 1) {\n        ll mid = ng + (ok - ng) / 2;\n\n        if (is_range_possible(mid, start)) ok = mid;\n        else ng = mid;\n    }\n\n    return ok;\n}\n\nint main() {\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)cin >> a[i];\n\n    cumulative_sum = vector<ll>(n * 2 + 1);\n    for (int i = 1; i <= n; i++) {\n        cumulative_sum[i] = cumulative_sum[i - 1] + a[i - 1];\n    }\n    for (int i = 1; i <= n; i++) {\n        cumulative_sum[n + i] = cumulative_sum[n + i - 1] + a[i - 1];\n    }\n\n    round = cumulative_sum[n];\n    ll ret = 0;\n    for (int i = 0; i < n; i++) {\n        ret = max(ret, max_range(i));\n    }\n\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  cin>>n;\n  int a[2n];\n  int z[n]\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a{i}\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d]\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n  }\n  sort(z,z+n);\n  cout<<z[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tvector<unsigned long long> a(200001);\n\tunsigned long long baum, b[4][3], minb, ans = 0;\n\tcin >> n;\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t\ta[i] += a[i - 1];\n\t\ta[i + n] = a[i];\n\t}\n\tbaum = a[n];\n\tfor (int i = 1; i <= n; i++){\n\t\ta[i + n] += baum;\n\t}\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < cut1 + n; cut2++){\n\t\t\tif (a[cut2] - a[cut1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < cut1 - 1 + n; cut3_1++){\n\t\t\tif (a[cut3_1] - a[cut2 - 1] >(baum - (a[cut2 - 1] - a[cut1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < cut1 + n; cut3_2++){\n\t\t\tif (a[cut3_2] - a[cut2] >(baum - a[cut2] - a[cut1]) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1] - a[cut1];\n\t\tb[0][1] = a[cut3_1 - 1] - a[cut2 - 1];\n\t\tb[0][2] = baum - b[0][0] - b[0][1];\n\t\tb[1][0] = a[cut2 - 1] - a[cut1];\n\t\tb[1][1] = a[cut3_1] - a[cut2 - 1];\n\t\tb[1][2] = baum - b[1][0] - b[1][1];\n\t\tb[2][0] = a[cut2] - a[cut1];\n\t\tb[2][1] = a[cut3_2 - 1] - a[cut2];\n\t\tb[2][2] = baum - b[2][0] - b[2][1];\n\t\tb[3][0] = a[cut2] - a[cut1];\n\t\tb[3][1] = a[cut3_2] - a[cut2];\n\t\tb[3][2] = baum - b[3][0] - b[3][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(ll l, ll r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, ll s) {\n    ll n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    return P((s+r)%n, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d; tie(pos, d) = search(m, i); sd += d;\n            P p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            if (sd <= L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\nvoid mmin(int &a, int b) {\n\ta = min(a, b);\n}\nvoid mmax(int &a, int b) {\n\ta = max(a, b);\n}\nvoid sor(vel &v) {\n\tsort(v.begin(), v.end());\n}\nint ser(vel &v, int tan) {\n\tint si = v.size() - 1;\n\tif (tan == v[si]) {\n\t\treturn si;\n\t}\n\tint lo = 0;\n\tint up = si;\n\twhile (up - lo > 1) {\n\t\tint mi = (lo + up) / 2;\n\t\tif (v[mi] <= tan) {\n\t\t\tlo = mi;\n\t\t}\n\t\telse {\n\t\t\tup = mi;\n\t\t}\n\t}\n\treturn lo;\n}\nint di(int st, int to, vel &sa) {\n\treturn sa[to] - sa[st];\n}\nint ni(int st, int to, vel &sa) {\n\tint se = sa[to] - sa[st];\n\tint lo = st;\n\tint up = to;\n\twhile (up - lo > 1) {\n\t\tint mi = (lo + up) / 2;\n\t\tif (di(st, mi, sa) * 2 < se) {\n\t\t\tlo = mi;\n\t\t}\n\t\telse {\n\t\t\tup = mi;\n\t\t}\n\t}\n\tint ans = 0;\n\tif (lo > st) {\n\t\tmmax(ans, (sa[lo] - sa[st]));\n\t}\n\tif (up < to) {\n\t\tmmax(ans,(sa[to] - sa[up]));\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n;\n\tcin >> n;\n\tvel a(n);\n\tvel sa(2*n);\n\tsa[0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i < 2 * n; i++) {\n\t\tsa[i] = sa[i - 1] + a[(i - 1)%n];\n\t}\n\tint sum = sa[n];\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint st = i + 2;\n\t\tint to = n + i;\n\t\tif (ni(i, st, sa) > di(st, to,sa)) {\n\t\t\tmmax(ans, di(st, to, sa));\n\t\t}\n\t\telse {\n\t\t\twhile (to - st > 1) {\n\t\t\t\tint mi = (to + st) / 2;\n\t\t\t\tif (ni(i, mi, sa) > di(mi, i + n, sa)) {\n\t\t\t\t\tto = mi;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tst = mi;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmmax(ans, ni(i, st, sa));\n\t\t\tif (to < n + i) {\n\t\t\t\tmmax(ans, di(to, n + i, sa));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[8][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i - 1][1] + a[i - 1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n - 1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2, b1, b2_1, b2_2;\n\t\tfor (cut2 = cut1 + 1; cut2 != n; ++cut2 %= n){\n\t\t\tif (cut2 > cut1){\n\t\t\t\tif ((b1 = a[cut2][1] - a[cut1][1]) > baum / 3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif ((b1 = a[cut2][1] + baum - a[cut1][1]) > baum / 3){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 !=  n; ++cut3_1 %= n){\n\t\t\tif (cut3_1 > cut2){\n\t\t\t\tif ((b2_1 = a[cut3_1][1] - a[cut2 - 1][1]) > (baum - (b1 - a[cut2 - 1][0])) / 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((b2_1 = a[cut3_1][1] + baum - a[cut2 - 1][1]) > (baum - (b1 - a[cut2 - 1][0])) / 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 != n; ++cut3_2 %= n){\n\t\t\tif (cut3_2 > cut2){\n\t\t\t\tif ((b2_2 = a[cut3_2][1] - a[cut2][1]) > (baum - b1) / 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((b2_2 = a[cut3_2][1] + baum - a[cut2][1]) > (baum - b1) / 2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb[0][0] = b1 - a[cut2 - 1][0];\n\t\tb[0][1] = b2_1 - a[cut3_1 - 1][0];\n\t\tb[0][2] = baum - b1 - b2_1 + a[cut2 - 1][0] + a[cut3_1 - 1][0];\n\t\tb[1][0] = b1 - a[cut2 - 1][0];\n\t\tb[1][1] = b2_1;\n\t\tb[1][2] = baum - b1 - b2_1 + a[cut2 - 1][0];\n\t\tb[2][0] = b1;\n\t\tb[2][1] = b2_2 - a[cut3_2 - 1][0];\n\t\tb[2][2] = baum - b1 - b2_2 + a[cut3_2 - 1][0];\n\t\tb[3][0] = b1;\n\t\tb[3][1] = b2_2;\n\t\tb[3][2] = baum - b1 - b2_2;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,c2=0,c3=0,s=0,s1=0,s2=0,m=0;\n\tint a[100000];\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> a[i];\n\t\ts+=a[i];\n\t}\n\tfor(int c1=0;c1<n;c1++){\n\t\twhile(s1<s/3){\n\t\t\ts1+=a[c2%n];\n\t\t\ts2-=a[c2%n];\n\t\t\tc2++;\n\t\t}\n\t\tif(c3<=c2){\n\t\t\tc3=c2+1;\n\t\t\ts2=a[c2%n];\n\t\t}\n\t\twhile(s2<(s-s1)/2){\n\t\t\ts2+=a[c3%n];\n\t\t\tc3++;\n\t\t}\n\t\tif(m<s-s1-s2){\n\t\t\tm=s-s1-s2;\n\t\t}\n\t\tc3--;\n\t\ts2-=a[c3%n];\n\t\tif(m<s2){\n\t\t\tm=s2;\n\t\t}\n\t\ts1-=a[c1%n];\n\t}\n\tcout << m;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l <= N){\n\t\tif(l!=0)sum = AA[r] - AA[l-1];\n\t\telse sum = AA[r];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif(AA[CC-1] - AA[r] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nint n,X[N];\n\nint ans;\nvoid update(int a,int i){\n  int len = X[n-1];  \n  int la = X[a]-X[i];\n  int b = lower_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n  int lb = X[b] - X[a];\n  int lc = len-la-lb;\n  ans = max(ans,min(la,min(lb,lc)));\n}\n\nsigned main(){\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n    \n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n\n  int len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int au = upper_bound(X+i,X+3*n,X[i]+len/3) - X;\n    update(au,i),update(au-1,i);\n }\n cout<< ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\nconst int INF = 2e9;\nconst LL LINF = 3e18;\n\nLL n;\nLL a[200010];\nLL ans = 0;\n\nLL solve(LL first)\n{\n  LL ret = 0;\n  LL *p1, *p2;\n  p1 = lower_bound(a + first, a + n + first, a[n] / 3 + a[first]);\n  p2 = lower_bound(p1, a + n + first, (a[n + first] - *p1) / 2 + *p1);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  p2 = lower_bound(p1, a + n + first, (a[n + first] - *p1) / 2 + *p1);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  /*\n  p2 = lower_bound(a + first, a + n + first, a[n] / 3 * 2 + a[first]);\n  p1 = lower_bound(a + first, p1, (*p2 - a[first]) / 2 + a[first]);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  p1 = lower_bound(a + first, p1, (*p2 - a[first]) / 2 + a[first]);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));*/\n  return ret;\n}\n\nint main()\n{\n  scanf(\"%lld\", &n);\n  for(LL i = 1; i <= n; i++)\n    scanf(\"%lld\", &a[i]);\n\n  for(LL i = n + 1; i <= 2 * n; i++)\n    a[i] = a[i - n];\n\n  for(LL i = 2; i <= 2 * n; i++)\n    a[i] += a[i - 1];\n\n  for(LL i = 0; i < n; i++)\n    ans = max(ans, solve(i));\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tint* A;\t//一つ一つのバウムクーヘンの大きさ\n\tint sum_baum;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tint tripartition();\t//\n\tint piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\n\tint full_search();\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\n\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n}\n\nint baumkuchen::tripartition(){\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tsum += A[N];\n\t}\n\treturn sum;\n}\n\nint baumkuchen::piece(int cut_1, int cut_2){\n\tint piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new int[N];\n\n\tset = true;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\tsum_baum += A[i];\n\t}\n}\n\nint baumkuchen::full_search(){\n\tint keep_value;\n\tint set_value=0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->full_search()<<endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint main(){\n\tint i,j,k;\n\t\n\tscanf(\"%d\",&N);\n\tif( N > 8000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\tfor( i = 0; i < N; i++ ){\n\t\tfor( j = i+1; j < N; j++ ){\n\t\t\t//できるだけ真ん中で切る\n\t\t\tk = seach1(j,i+N);\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0;\n\n\t\tint ans = 0;\n\t\trep(i, n + 1)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = double(sum - len) / 2.0;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\n\t\t\tif (idx >= i + n + 1 || remidx > i + n + 1) continue;\n\t\t\tint rrll = sum - len - remlen;\n\t\t\tif (sum != len + remlen + rrll) continue;\n\t\t\tans = max(ans, min({ len, remlen, rrll }));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r] - AA[l-1];\n\t\telse sum = AA[r];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif(AA[CC-1] - AA[r] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll in[200000];\nll ruisekiwa[200001];\nll over;\n\nll getmin(int l, int r) {\n\tll a, b, c, ans = 0;\n\ta = ruisekiwa[r] - ruisekiwa[l];\n\tb = *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tc = ruisekiwa[l + N] - *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tans = max(ans, min(a, min(b, c)));\n\t//b = *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\t//c = ruisekiwa[l + N] - *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\t//ans = max(ans, min(a, min(b, c)));\n\treturn ans;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t\tin[N + i] = in[i];\n\t}\n\tfor (int i = 1; i <= N * 2; i++) {\n\t\truisekiwa[i] = ruisekiwa[i - 1] + in[i - 1];\n\t}\n\n\tll ans = 0;\n\tover = (ruisekiwa[N] - ruisekiwa[0]) / 3;\n\tfor (int l = 0, r = 0;(l < N); l++) {\n\t\tfor (; ruisekiwa[r] - ruisekiwa[l] < over; r++)ans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r + 1));\n\t\tans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r - 1));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n//ちょっと気まぐれだが、O(N^2logN)の枝刈りで通してみたくなったからそれで通す。→無理でした。\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)573\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n//A[medi]-A[st] >= Xとなる最小のmediを返す。\nint seach2( int st, int ed, long long X ){\n\tint s=st,e=ed,medi;\n\twhile( s<=e ){\n\t\tmedi= (s+e)>>1;\n\t\tif( A[medi]-A[st] < X )\n\t\t\ts=medi+1;\n\t\tif( A[medi]-A[st] >= X ){\n\t\t\tif( A[medi-1]-A[st] < X )\n\t\t\t\tbreak;\n\t\t\te=medi-1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint solve( long long X ){\n\tint i,j,k;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tj = seach2(i,N+i,X);\n\t\t//できるだけ真ん中で切る\n\t\tk = seach1(j,N+i);\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\tint n;\n\tstatic int a[100010];\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n ;i ++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t\n\tint p = 1,q = 1,r = 1;\n\tint x = 0,y = 0,z = 0;\n\tfor(int i = 1; i <= n ;i ++)z += a[i];\n\t\n\tint ret = 0;\n\twhile(r != n){\n\t\tif(z >= max(x,y)){\n\t\t\ty += a[r];\n\t\t\tz -= a[r];\n\t\t\tr ++;\n\t\t}\n\t\telse if(y >= max(z,x)){\n\t\t\tx += a[q];\n\t\t\ty -= a[q];\n\t\t\tq ++;\n\t\t}\n\t\telse {\n\t\t\tz += a[p];\n\t\t\tx -= a[p];\n\t\t\tp ++;\n\t\t}\n\t\tret = max ( ret , min(min(x,y),z) );\n\t}\n\t\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll a[300000];\nint main() {\n\tll n; scanf(\"%lld\", &n);\n\trep(i, n) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1 + n] = a[i + 1];\n\t}\n\tfor (ll i = 1; i <= 2 * n; i++)\n\t\ta[i] += a[i - 1];\n\tll s = 0, g = 1000000000 * n;\n\twhile (s != g) {\n\t\tll t = (s + g) / 2 + s % 2;\n\t\tbool flag = false;\n\t\trep(i, n) {\n\t\t\tll j = lower_bound(a + i, a + i + n, a[i] + t) - a;\n\t\t\tif (j == n + i)continue;\n\t\t\tll k = lower_bound(a + j, a + i + n, a[j] + t) - a;\n\t\t\tif (a[j] - a[i] >= t&&a[k] - a[j] >= t&&a[i + n] - a[k] >= t) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)s = t;\n\t\telse g = t - 1;\n\t}\n\tprintf(\"%d\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tlong long check();\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcout << min_value << endl;\n\texit(0);\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tif (memo[cut_b] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_b] > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\n\tset_value = set_board();\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\tlong long min_value;\n\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\tif (memo[cut_b] - memo[cut_a] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (memo[cut_c] - memo[cut_b] > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n#include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)   (x).begin(),(x).end()\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define mp       make_pair\n#define eb       emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\n \nLL a[202020];\nint n;\n \nbool calc(LL m) {\n\tfor (int i = 0; i < n; i++) {\n\t\tint num = (i == 0 ? 0 : a[i - 1]);\n\t\tint pos1 = lower_bound(a + i, a + i + n, num + m) - a;\n\t\tint pos2 = lower_bound(a + i, a + i + n, a[pos1] + m) - a;\n\t\tif (a[n + i - 1] - a[pos2] >= m)return true;\n\t}\n\treturn false;\n}\n \n \nint main() {\n\tcin >> n;\n\tLL sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tsum +=a[i];\n\t}\n \n\tfor (int i = n + 1; i <= n * 2; i++) {\n\t\ta[i] += a[i - n];\n\t}\n\tfor (int i = 1; i <= n * 2; i++) {\n\t\ta[i] += a[i - 1];\n\t}\n \n\tLL left = 0, right = sum;\n\twhile (right - left > 1) {\n\t\tLL mid = (right + left) / 2;\n\t\tif (calc(mid)) {\n\t\t\tleft = mid;\n\t\t}\n\t\telse {\n\t\t\tright = mid;\n\t\t}\n\t}\n\tcout << left << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  cin>>n;\n  int a[200000];\n  int z[10000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n    for(int j;j<n;j++){\n    d=j-1;\n    while(b<=c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    while(e<c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n  }\n  sort(z,z+n);\n  cout<<z[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint n;\nll a[200001],sum[200001];\nbool test(ll d){\n    rep(i,n){\n        int cur=i;\n        bool flag=true;\n        rep(j,3){\n            cur=lower_bound(sum,sum+2*n,sum[cur]+d)-sum;\n            if(cur>i+n){\n                flag=false;break;\n            }\n        }\n        if(flag) return true;\n    }\n    return false;\n}\nint main(){\n    cin>>n;\n    rep(i,n){\n        cin>>a[i];\n        a[i+n]=a[i];\n    }\n    rep(i,2*n) sum[i+1]=sum[i]+a[i];\n    ll lb=0,ub=100010001000000;\n    while(ub-lb>1){\n        ll mid=(ub+lb)/2;\n        if(test(mid)) lb=mid;\n        else ub=mid;\n    }\n    cout<<lb<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\nusing namespace std;\n\n\nint main(){\n\tlong long  num_cut = 0;\n\tlong long  sum = 0L;\n\tlong long  oneThird = 0L;\n\tint cuts[100000];\n\n\tlong long min_piece=0L;\n\tint a=0;\n\tlong long restCake=0L;\n\n\tcin >> num_cut;\n\tfor(int i = 0; i < num_cut; i++){\n\t\tcin >> a;\n\t\tsum += a;\n\t\tcuts[i] = a;\n\t}\t\n\n\toneThird = (sum + 2) / 3;\n\tlong long firstSize = 0L;\n\tlong long secondSize = 0L;\n\tlong long thirdSize = 0L;\n\tlong long thirdSize_in1 = 0L;\n\t\n\tbool fi_se = false; // 1st >= 2nd\n\tbool se_th = false; // 2nd >= 3rd\n\tbool fi_th = false; // 1st >= 3rd\n\t// start\n\tfor(int start=0; restCake < oneThird; start++){\n\t\tfirstSize = 0L;\n\t\t// 1st\n\t\tfor(int first=start+1; firstSize < oneThird; first++){\n\t\t\tfirstSize += cuts[first];\n\t\t\tsecondSize = 0L;\n\t\t\tthirdSize_in1 = sum-firstSize;\n\t\t\t// 2nd\n\t\t\tfor(int second=first+1; secondSize < oneThird; second++){\n\t\t\t\tsecondSize += cuts[second];\n\t\t\t\t// 3rd  \n\t\t\t\tthirdSize = thirdSize_in1 - secondSize;\n\t\t\t\tfi_se = (firstSize >= secondSize);\n\t\t\t\tse_th = (secondSize >= thirdSize);\n\t\t\t\tfi_th = (firstSize >= thirdSize);\n\t\t\t\tif(!fi_se && !fi_th){\n\t\t\t\t\tif(firstSize > min_piece) min_piece = firstSize;\n\t\t\t\t}else if(fi_se && !se_th){\n\t\t\t\t\tif(secondSize > min_piece) min_piece =secondSize;\n\t\t\t\t}else{\n\t\t\t\t\tif(thirdSize > min_piece) min_piece =thirdSize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trestCake += cuts[start];\n\t}\n\n\tcout << min_piece << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VL a(n);\n    REP(i,n) scanf(\"%lld\", &a[i]);\n    REP(i,n){\n        a.push_back(a[i]);\n    }\n    VL s(2*n+1);\n    REP(i,2*n) s[i+1] = s[i] + a[i];\n    s.push_back(1e17);\n    s.push_back(2e17);\n    s.push_back(3e17);\n    ll l = 1, r = 1e16;\n    while (r - l > 1){\n        ll m = (l + r) / 2;\n        bool pos = 0;\n        REP(i,n){\n            int x = i;\n            REP(j,3){\n                x = lower_bound(s.begin(), s.end(), s[x] + m) - s.begin();\n            }\n            if (x <= i + n){\n                pos = 1;\n                break;\n            }\n        }\n        if (pos) l = m;\n        else r = m;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  for (l = 0; l < n; l ++) {\n    for (; _sum[r] - _sum[l] <= _max; r ++);\n    r --;\n\n    left = _sum[r] - _sum[l];\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n    if (mid_id < 0) cout << mid_id << endl;\n\n    ans = max(ans, min(left, rem));\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=0;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\twhile (t<s+N && a<=ans){\n\t\t\tt++;\n\t\t\ta+=A[(t-1)%N];\n\t\t}\n\t\tif (t==s+N) break;\n\t\t//aがansを更新できるか\n\t\tauto p=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\tif (p!=sum+s+N){\n\t\t\t//見つかった\n\t\t\tb=*p-sum[t-1];\n\t\t\tc=sum[N-1]-b-a;\n\t\t\tif (c>=a){\n\t\t\t\t//aが最小値\n\t\t\t\tans=a;\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else if (p < tar) l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n - 2, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2 + 1, n - 1, (A[n] - tmin) / 2);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n\n    for (int j = -1; j < 2; ++j) {\n      int tc2 = c2 + j, tc3 = c3 + j;\n      tmin = A[tc2 - 1] - A[i - 1];\n      tmin = min(tmin, A[tc3 - 1] - A[tc2 - 1]);\n      tmin = min(tmin, A[i + n - 1] - A[tc3 - 1]);\n      ans = max(ans, tmin);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define INF 1e17\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll a[100001];\nll sum[100001];\n\nbool cut(ll x,int f){\n\tint s=lower_bound(sum+f,sum+n,sum[f]+x)-sum;\n\tint t=lower_bound(sum+s,sum+n,sum[s]+x)-sum;\n\t//printf(\"%d %d %d %lld\\n\",f,s,t,x);\n\t//printf(\"%lld %lld %lld\\n\",sum[s]-sum[f],sum[t]-sum[s],sum[n]-sum[t]+sum[f]);\n\tif(sum[s]-sum[f]<x)return false;\n\tif(sum[t]-sum[s]<x)return false;\n\tif(sum[n]-sum[t]+sum[f]<x)return false;\n\treturn true;\n}\n\n\n\nbool check(ll x){\n\tint cut_f=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(cut(x,i))return true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i-1];\n\tll left=0,right=INF;\n\tfor(int i=0;i<100;i++){\n\t\tll mid=(left+right)/2;\n\t\tif(check(mid))left=mid;\n\t\telse right=mid;\n\t}\n\tprintf(\"%lld\\n\",left);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define real() X\n#define imag() Y\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll sumsum[2000010];\nll sums(int s,int e){\n\tif(s>e)\n\t\treturn 0;\n\treturn sumsum[e+1]-sumsum[s];\n}\nll divide(int ss,int ee){\n\tint s=ss;\n\tint e=ee;\n\tll maxim=0;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tmaxim=max(maxim,min(sums(ss,f),sums(f+1,ee)));\n\t\tif(sums(ss,f)<=sums(f+1,ee))\n\t\t\ts=f+1;\n\t\telse\n\t\t\te=f-1;\n\t}\n\treturn maxim;\n}\nint main() {\n\tll N,p,s,sum=0;\n\tvector<ll> baum;\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> p;\n\t\tbaum.push_back(p);\n\t\tsum+=p;\n\t\tsumsum[i+1]=sumsum[i]+p;\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N+i+1]=sumsum[N+i]+baum[i];\n\t}\n\tint head=0;\n\tll maxim=0;\n\tREP(snake,N){\n\t\twhile(sums(snake,head)*3<sum) head++;\n\t\tif(sums(snake+1,head)*3<sum){\n\t\t\tmaxim=max(maxim,divide((head+1)%N,(snake+N-1)%N+N*((head+1)%N>(snake+N-1)%N)));\n\t\t}\n\t}\n\tcout << maxim << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n, s;\n\n// ?????????????????????x??\\?????§3????????????????????¨?????§?????????\nbool solve(ll x) {\n\tREP(i, n) {\n\t\tbool flag = true;\n\t\tint pos = i;\n\t\tREP(j, 2) {\n\t\t\tpos = lower_bound(sum + i, sum + i + n + 1, sum[pos] + x) - sum;\n\t\t\tif (pos > i + n) { flag = false; break; }\n\t\t}\n\t\tif (flag && s - (sum[pos] - sum[i]) >= x) return true;\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t\ts += a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n#include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)   (x).begin(),(x).end()\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define mp       make_pair\n#define eb       emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\n\nLL a[2020200];\nLL b[2020200];\nLL n;\n\nbool calc(LL m) {\n\tfor (int i = 0; i < n; i++) {\n\t\tLL tmp = (i == 0 ? 0 : b[i - 1]);\n\t\tint pos1 = lower_bound(b + i, b + i + n, tmp + m) - b;\n\t\tint pos2 = lower_bound(b + i, b + i + n, b[pos1] + m) - b;\n\t\tif (b[n + i - 1] - b[pos2] >= m)return true;\n\t}\n\treturn false;\n}\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = n; i < n * 2; i++) {\n\t\ta[i] = a[i - n];\n\t}\n\tb[0] = a[0];\n\tfor (int i = 1; i < n * 2; i++) {\n\t\tb[i] = a[i] + b[i - 1];\n\t}\n\n\tLL left = 1, right = b[n - 1];\n\twhile (right - left > 1) {\n\t\tLL mid = (right + left) / 2;\n\t\tif (calc(mid)) {\n\t\t\tleft = mid;\n\t\t}\n\t\telse {\n\t\t\tright = mid;\n\t\t}\n\t}\n\tcout << left << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef long long int Num;\n\nconst int NMAX = 100010;\nint N;\nNum A[NMAX];\nNum acc[NMAX];\n\nvoid accumulate() {\n  for (int i = 1; i <= N; i++) {\n    acc[i] = acc[i - 1] + A[i];\n  }\n}\n\nint increment(int i) {\n  return (i + 1) % N + 1;\n}\n\nNum range(int l, int r) {\n  if (l <= r) {\n    return acc[r] - acc[l];\n  } else {\n    return range(0, r) + range(l, N);\n  }\n}\n\n\nNum solve() {\n  Num ans = 0;\n  const Num Whole = acc[N];\n  int left = 1, medium "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\n\ntypedef vector<pair<int, int> > vpii;\n\nint main() {\n  int n;\n  long a[200000];\n  \n  long sum;\n  long Max = 0;\n  cin >> n;\n  for(int i = 0; i< n; i++) {\n    cin >> a[i];\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  \n  int i,j,k;\n  long first, second, third, rest;\n  rep(j,n) {\n    first = 0;\n    for (i = 0;i < n - 2 && first <= Max;i++){\n      first += a[j + i];\n    }\n    rest = sum - first;\n    second = a[j + i];\n    k = j + i + 1;\n    third = rest - second;\n    while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n      second += a[k];\n      third = rest - second;\n      k++;\n    }\n    if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n      Max = max(first, Max);\n    }\n    for (;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      second -= a[j + i];\n      \n      while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n        second += a[k];\n        third = rest -second;\n        k++;\n      }\n\n      if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n        Max = max(first, Max);\n      } else {\n        break;\n      }\n    }\n  }\n  cout << Max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint a[111111*2];\nlong long sum[111111*2];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    assert(sum[m]-sum[l]+lim+sum[r]-sum[m]==sum[n]);\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] >= sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  //s = e;\n  assert(lim+sum[r]-sum[s]+sum[s]-sum[l]==sum[n]);\n  //printf(\":%lld %lld %lld %lld %d %d\\n\",lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  res = max(res,min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]));\n  return min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n  }\n  for( int j = 0; j < 2*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;s<=n&&e<=n;++e) {\n    while( e < n && C(s,e) >= sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }    \n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nint getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tint MaxMin = 0;\n\tint tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nint getLocalMin(int p1, int p2, int p3)\n{\n\tint LocalMin = sumArray(p1, p2);\n\tint tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong v_list[100001];\ndouble tripartition;\n\t\ninline llong searchOne(int n0, int n1_left, int n2_left);\ninline llong getMinV(int n0, int n1_left, int n2_left);\ninline int findIndexBinary(int from_n, int to_n, double target);\ninline int findIndexSequential(int from_n, double target);\n\nint main(){\n\tscanf(\"%lld\", &N);\n\tv_list[0] = 0;\n\tllong A;\n\tfor(int n=1; n<N+1; n++){\n\t\tscanf(\"%lld\", &A);\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\n\ttripartition = v_list[N] / 3.0;\n\tint n0_max = findIndexBinary(0, N, tripartition);\n\tint n1_left = n0_max;\n\tint\tn2_left = findIndexBinary(n1_left, N,  2*tripartition);\n\tllong maxV = searchOne(0, n1_left, n2_left);\n\tfor (int n0 = 1; n0 <= n0_max; n0++){\n\t\tn1_left = findIndexSequential(n1_left,   tripartition + v_list[n0]);\n\t\tn2_left = findIndexSequential(n2_left, 2*tripartition + v_list[n0]);\n\t\t\n\t\tllong tmp = searchOne(n0, n1_left, n2_left);\n\t\tif (tmp > maxV) maxV = tmp;\n\t}\n\n\tprintf(\"%lld\\n\", maxV);\n}\n\nllong searchOne(int n0, int n1_left, int n2_left){\n\tllong V_ll = getMinV(n0, n1_left  , n2_left  );\n\tllong V_lr = getMinV(n0, n1_left  , n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left  );\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tllong V0 = v_list[n1] - v_list[n0];\n\tllong V1 = v_list[n2] - v_list[n1];\n\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\treturn min(min(V0,V1),V2);\n}\n\nint findIndexBinary(int from_n, int to_n, double target){\n\twhile (to_n - from_n != 1) {\n\t\tint n_mid = (to_n + from_n) / 2;\n\t\tif (v_list[n_mid] > target) to_n = n_mid;\n\t\telse from_n = n_mid;\n\t}\n\treturn from_n;\n}\n\nint findIndexSequential(int from_n, double target){\n\tfor(int n=from_n; n<= N; n++)if(v_list[n] > target) return n-1;\n\treturn N-1;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n// IO library\n#include <cstdio>\n\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n\n#include <cmath>\n#include <numeric>\n#include <random>\n#include <cstring>\n#include <cassert>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <stack>\n\n// type\n#include <cstdint>\n\n/* ---------- Namespace ---------- */\nusing namespace std;\n\n/* ---------- Type ---------- */\nusing ll = long long;\n#define int ll\n#define P pair<ll, ll>\n\n/* ---------- Constants  */\nconst double PI = 3.141592653589793238462643383279;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1LL << 55;\n\nint N;\nint A[100005];\nint S[200010];\n\n// Is it possible to divide into 3 pieces with size of larger than or equal to x?\nbool f(int x) {\n    for (int start = 0; start < N; start++) {\n        int idx = start;\n        int lower = S[idx] + x;\n        for (int i = 0; i < 3; i++) {\n            idx = lower_bound(S, S + 2 * N, lower) - S;\n            lower = S[idx] + x;\n        }\n\n        if (idx <= start + N) return true;\n    }\n\n    return false;\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) cin >> A[i];\n    for (int i = 0; i < N; i++) S[i+1] = S[i] + A[i];\n    for (int i = N; i < 2*N; i++) S[i+1] = S[i] + A[i-N];\n\n    int lb = 0;\n    int ub = INF;\n    while (ub - lb > 1) {\n        int mid = (ub + lb) / 2;\n        if (f(mid)) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n\n    cout << lb << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(l, -1, 2)\n\t\t\t{\n\t\t\t\tint k = sep + l;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tans = max(ans, min({ a, b, c }));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n \nusing namespace std;\n \nconst int MAX_N=100000;\n \nint N;\nint A[MAX_N];\n \nlong long sum[MAX_N*2];\n \nint main(){\n    scanf(\"%d\",&N);\n    int i;\n    for (i=0;i<N;i++){\n        scanf(\"%d\",A+i);\n    }\n    sum[0]=A[0];\n    for (i=1;i<N;i++){\n        sum[i]=sum[i-1]+A[i];\n    }\n    for (i=N;i<2*N;i++){\n        sum[i]=sum[i-1]+A[i-N];\n    }\n    long long ans=0;\n    int s,t;\n    s=0;\n    t=0;\n    long long a=0,b,c;   //s-t間のバームクーヘン\n    while (s<N){\n        long long *p;\n        do{\n            while (a<=ans){\n                t++;\n                a+=A[(t-1)%N];\n            }\n            //aがansを更新できるか\n            p=lower_bound(sum+t,sum+s+N-1,a+sum[t-1]);\n            if (p!=sum+s+N-1){\n                //見つかった\n                b=*p-sum[t-1];\n                c=sum[N-1]-b-a;\n                if (c>=a){\n                    //aが最小値\n                    ans=a;\n                }\n                else{\n                    break;\n                }\n            }\n        }while (p!=sum+s+N-1);\n        s++;\n        a=sum[t-1]-sum[s-1];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200001];\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\t\tint posl2 = posr1 - 1;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)114\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[i]-A[st] >= A[ed]-A[i]となる最小のiを返す。\nint seach1( int st, int ed, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= A[ed]-A[i] )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n//A[i]-A[st] >= Xとなる最小のiを返す。\nint seach2( int st, int ed, long long X, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= X )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tfor( ; j < N+i; j++ ){\n\t\t\tif( A[j]-A[i] >= X )\n\t\t\t\tbreak;\n\t\t}\n\t\t//できるだけ真ん中で切る\n\t\tfor( ; k < N+i; k++ ){\n\t\t\tif( A[k]-A[j] >= A[N+i]-A[k] )\n\t\t\t\tbreak;\n\t\t}\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n - 2, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2, n - 1, (A[i + n - 1] - A[c2 - 1]) / 2);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n\n    for (int j = -1; j < 2; ++j) {\n      int tc2 = c2 + j, tc3 = c3 + j;\n      tmin = A[tc2 - 1] - A[i - 1];\n      tmin = min(tmin, A[tc3 - 1] - A[tc2 - 1]);\n      tmin = min(tmin, A[i + n - 1] - A[tc3 - 1]);\n      ans = max(ans, tmin);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<long long> ve;\nvector<long long>::iterator it,llit,lgit,rlit,rgit;\nlong long taml[4],tamm[4],tamr[4];\nlong long waru3(long long a){\n\tif(a%3==2) return a/3+1;\n\telse return a/3;\n}\nint main(){\n\tint N;\n\tlong long hog,mns,res,S,S1_3,S2_3;\n\tve.push_back(0);\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>hog;\n\t\tve.push_back(ve[i]+hog);\n\t}\n\tS=ve[N];\n\tve.pop_back();\n\tS1_3=waru3(S);\n\tS2_3=waru3(S*2);\n\tmns=res=0;\n\tfor(int i=0;i<N;i++){\n\t\thog=ve[0]+S;\n\t\tmns+=ve[1]-ve[0];\n\t\tve.erase(ve.begin());\n\t\tve.push_back(hog);\n\t\tlgit=lower_bound(ve.begin(),ve.end(),S1_3+mns);\n\t\tllit=lgit--;\n\t\trgit=lower_bound(ve.begin(),ve.end(),S2_3+mns);\n\t\trlit=rgit--;\n\t\ttaml[0]=(*lgit)-mns;\n\t\ttaml[1]=(*llit)-mns;\n\t\ttaml[2]=(*lgit)-mns;\n\t\ttaml[3]=(*llit)-mns;\n\t\ttamm[0]=(*rgit)-(*lgit);\n\t\ttamm[1]=(*rgit)-(*llit);\n\t\ttamm[2]=(*rlit)-(*lgit);\n\t\ttamm[3]=(*rlit)-(*llit);\n\t\ttamr[0]=S+mns-(*rgit);\n\t\ttamr[1]=S+mns-(*rgit);\n\t\ttamr[2]=S+mns-(*rlit);\n\t\ttamr[3]=S+mns-(*rlit);\n\t\tfor(int j=0;j<4;j++){\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<taml[j]<<\" \"<<tamm[j]<<\" \"<<tamr[j]<<endl;\n\t\t\tres=max(res,min(min(taml[j],tamr[j]),tamm[j]));\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0 + 0.5;\n\n\t\tint ans = 0;\n\t\trep(i, n + 1)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = (sum - len) / 2;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tans = max(ans, sum - len - remlen);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  for (l = 0; l < n; l ++) {\n    for (; _sum[r] - _sum[l] <= _max; r ++);\n    r --;\n\n    left = _sum[r] - _sum[l];\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n    if (mid_id < 0) cout << mid_id << endl;\n\n    ans = max(ans, min(left, rem));\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nvector<ll>V;\nint n;\nll MAX,sum;\nbool ok(ll x){\n  REP(i,n){\n    int res=V[i];\n    int fis=*lower_bound(ALL(V),res+x);\n    if(fis==MAX)continue;\n    int sec=*lower_bound(ALL(V),fis+x);\n    if(sec==MAX)continue;\n    int thi=*lower_bound(ALL(V),sec+x);\n    if(thi<=sum+res)return true;\n  }\n  return false;\n}\nint main(){\n  cin>>n;\n  sum=0;\n  ll lb=0,rb=0;\n  V.PB(0);\n  REP(i,n){\n    ll a;\n    cin>>a;\n    V.PB(V[V.size()-1]+a);\n    sum+=a;\n  }\n  MAX=sum*3;\n  rb=sum;\n  REP(i,n)V.PB(V[i+1]+sum);\n  V.PB(MAX);\n  while(rb-lb>1){\n    ll mid=(rb+lb)/2;\n    if(ok(mid)){\n      lb=mid;\n    }else{\n      rb=mid;\n    }\n  }\n  cout<<lb<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tll n;\n\tcin>>n;\n\n\tll *d = new ll [n*2];\n\tfor(ll i = 0;i < n;i++){\n\t\tcin>>d[i];\n\t\tif(i != 0){\n\t\t\td[i] += d[i-1];\n\t\t}\n\t\td[i+n] = d[i];\n\t}\n\tfor(ll i =0;i < n;i++){\n\t\td[i+n] += d[n-1];\n\t}\n\tll max_min = 0;\n\tll l = 0,c = 0,r = 0;\n\twhile(l < n-2){\n\t\twhile(d[c] - d[l] < d[n-1]/3) c++;\n\t\tfor(r = l + 1;r < n+l-1;r++){\n\t\t\tll m = min(d[r] - d[c],d[n+l-1] - d[r]);\n\t\t\tif(m > max_min){\n\t\t\t\tmax_min = m;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\tcout<<max_min<<endl;\n\n\tdelete [] d;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n\nint n, p, a[200005], pre[200005];\nll lo=1, mid, hi, c;\nbool check(ll L){\n    p=0; c=0;\n    drain(pre);\n    fox(l, n*2){\n        c+=a[l];\n        while(p<=l && c-a[p]>=L){\n            c-=a[p];\n            p++;\n        }\n        if (c<L) pre[l]=-(1 << 30);\n        else {\n            pre[l]=p;\n            //cout << pre[l] << ' ';\n            if (pre[l]>0 && pre[pre[l]-1]-1>=0 && l-pre[pre[pre[l]-1]-1]+1<=n) return 1;\n            continue;\n        }\n        //cout << pre[l] << ' ';\n    }\n    return 0;\n}\nint main(){\n    cin >> n;\n    fox(l, n){\n        cin >> a[l];\n        a[l+n]=a[l];\n    }\n    hi=1LL*n*MN;\n    //cout << check(6);\n    //return 0;\n    while(lo<hi){\n        mid=(lo+hi+1)/2;\n        //cout << mid << endl;\n        if (check(mid)) lo=mid;\n        else hi=mid-1;\n        //cout << endl;\n    }\n    cout << lo << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[100000];\nll S[200000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%lld\", &a[i]);\n\tS[0] = a[0];\n\tfor(int i = 1; i < 2*n; i++) S[i] = S[i-1]+a[i%n];\n\tll s = -1, e = 1000000000000001, mid;\n\twhile(true){\n\t\tmid = (s+e)/2;\n\t\tif(e-s == 1) break;\n\t\tbool ok = false;\n\t\trep(i,n){\n\t\t\tll st;\n\t\t\tif(i != 0) st = lower_bound(S+i,S+i+n,mid+S[i-1])-S;\n\t\t\telse st = lower_bound(S+i,S+i+n,mid)-S;\n\t\t//\tif(mid == 7) printf(\"%d\\n\", st);\n\t\t\tif(st == i+n) continue;\n\t\t\tst = lower_bound(S+st+1,S+i+n,mid+S[st])-S;\n\t\t\t//if(mid == 7) printf(\"%d\\n\\n\", st);\n\t\t\t\n\t\t\tif(S[i+n-1]-S[st] >= mid){\n\t\t\t\tok = true;\n\t\t\t\t//if(mid == 7) printf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) s = mid;\n\t\telse e = mid;\n\t}\n\tprintf(\"%d\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ll INF = LLONG_MAX / 3;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tll n; cin >> n;\n\tvi a(n); REP(i, n) cin >> a[i];\n\tll lb = 0, ub = INF;\n\twhile (ub - lb > 1)\n\t{\n\t\tll mid = (ub + lb) / 2;\n\t\tbool ok = false;\n\t\tREP(i, n)\n\t\t{\n\t\t\tbool f = true;\n\t\t\tint p = i;\n\t\t\tll tmp = 0;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (tmp >= mid) break;\n\t\t\t\tif (p == n)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttmp += a[p];\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\ttmp = 0;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tif (tmp >= mid) break;\n\t\t\t\t\tif (p == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttmp += a[p];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\ttmp = 0;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tif (p == n) p = 0;\n\t\t\t\t\tif (tmp >= mid) break;\n\t\t\t\t\tif (p == i)\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttmp += a[p];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) lb = mid;\n\t\telse ub = mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i;\n}\n\nvoid CalcPiece3(int _i3, ull *_piece3, const ull _two_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _two_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n}\n\nint main(){\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\t\ti1--;\n\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\tint i2 = i1;\n\t\tull piece2 = 0;\n\t\tCalcPiece(i2, &piece2, two_third_size, A, N);\n\n\t\tint i3 = i - 1 + N;\n\t\tull piece3 = 0;\n\t\tCalcPiece3(i3, &piece3, two_third_size, A, N);\n\n\t\tif (piece1 < piece2 && piece1 < piece3){\n\t\t\tif (piece1 > answer) answer = piece1;\n\t\t}\n\t\telse if (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\tpiece1 += A[i1 % N];\n\t\ttwo_third_size = (total_size - piece1) / 2;\n\t\ti2 = i1 + 1;\n\t\tCalcPiece(i2, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\ti3 = i - 1 + N;\n\t\tCalcPiece3(i3, &piece3, two_third_size, A, N);\n\t\tpiece2 = total_size - piece1 - piece3;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i;\n}\n\nint CalcPiece3(int _i3, ull *_piece3, const ull _two_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _two_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n\treturn _i3;\n}\n\nint main(){\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\t\ti1--;\n\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\tint i2 = i1;\n\t\tull piece2 = 0;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\n\t\tint i3 = i - 1;\n\t\tull piece3 = 0;\n\t\ti3 = CalcPiece3(i3, &piece3, two_third_size, A, N);\n\n\t\tif (piece1 < piece2 && piece1 < piece3){\n\t\t\tif (piece1 > answer) answer = piece1;\n\t\t}\n\t\telse if (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\tpiece1 += A[i1 % N];\n\t\ttwo_third_size = (total_size - piece1) / 2;\n\t\ti2 = i1 + 1;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\ti3 = i - 1;\n\t\ti3 = CalcPiece3(i3, &piece3, two_third_size, A, N);\n\t\tpiece2 = total_size - piece1 - piece3;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 9999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v;\nvector<int> pos(200010, 0);\n\nbool ch(int x){\n  int l, r=l=0, sum=0;\n  while(l<n){\n    while(sum<x && (r+1)%n!=l){\n      sum+=v[r];\n      r=(r+1)%n;\n    }\n\n    if((r+1)%n==l) return false;\n    pos[l]=r;\n    sum-=v[l];\n    l++;\n  }\n\n  REP(i, n){\n    int l1=pos[i]-i, l2=pos[pos[i]]-pos[i], l3=pos[pos[pos[i]]]-pos[pos[i]];\n\n    if(l1<0) l1+=n;\n    if(l2<0) l2+=n;\n    if(l3<0) l3+=n;\n    if(l1+l2+l3<=n) return true;\n  }\n  \n  return false;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  int sum=0;\n  REP(i, n){\n    int m;\n    scanf(\"%lld\", &m);\n    v.push_back(m);\n    sum+=m;\n  }\n\n  int l=0, r=INF;\n  int mid;\n  while(l+1<r){\n    mid=(l+r)/2;\n    if(ch(mid)) l=mid;\n    else r=mid;\n  }\n\n  printf(\"%lld\\n\", l);\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint main(){\n\tint i,j,k;\n\t\n\tscanf(\"%d\",&N);\n\tif( N > 8000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\tfor( i = 0; i < N; i++ ){\n\t\tfor( j = i+1; j < N; j++ ){\n\t\t\t//できるだけ真ん中で切る\n\t\t\tk = seach1(j,i+N);\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t\tk--;\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A; \n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[N];\n\tmemo = new long long[N*N];\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\tif (memo[cut_1*N + cut_2])return memo[cut_1*N + cut_2];\n\t\telse{\n\t\t\twhile (cut_1 != cut_2){\n\t\t\t\tpiece += A[cut_1 - 1];\n\t\t\t\tcut_1--;\n\t\t\t}\n\t\t\tpiece = sum_baum - piece;\n\t\t\tmemo[cut_1*N + cut_2] = sum_baum - piece;\n\t\t}\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n\tvector<int> ve(1,0);\n       \nint a[100020];\nint ch(int r,int val){\n\tint it=lower_bound(ve.begin(),ve.end(),ve[r]+val)-ve.begin();\n\tif(it==ve.size())return inf;\n\t it=lower_bound(ve.begin(),ve.end(),ve[it]+val)-ve.begin();\n\tif(it==ve.size())return inf;\n\t it=lower_bound(ve.begin(),ve.end(),ve[it]+val)-ve.begin();\n\tif(it==ve.size())return inf;\n\treturn it;\n}\n\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<n;i++)ve.pb(ve.back()+a[i]);\n\tfor(int i=0;i<n;i++)ve.pb(ve.back()+a[i]);\n\t\n\tint ans=-1;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint si=0,ue=inf*200000ll;\n\t\twhile(ue-si>1){\n\t\t\tint me=(ue+si)/2;\n\t\t\tint y=ch(i,me);\n\t\t//\tcout<<me<<\" \"<<y<<\" \"<<i+n<<endl;\n\t\t\tif(y>i+n)ue=me;\n\t\t\telse si=me;\n\t\t}\n\t//\tcout<<si<<endl;\n\t\tans=max(ans,si);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\t\nreturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif((a2_sum + InArray[a2+1]) < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n;\nvector < int > a;\nvector<long long int > pr;\nbool check2(int k,int now,long long int m)\n{\n    if (pr[now] - pr[k] >= m)return true;\n    return false;\n}\nbool check3(int k,int now,long long int m)\n{\n    if (pr[now] - pr[k] > m)return true;\n    return false;\n}\nbool check(int i,long long int m)\n{\n    int r = i+n-1, l = i;\n    while (r != l)\n    {\n        int now = (r + l) / 2;\n        if (check2(i,now,m))\n        {\n            r = now;\n        }\n        else\n        {\n            l = now+1;\n        }\n    }\n    r = i + n - 1;\n    int hoge = l;\n    while (r != l)\n    {\n        int now = (r + l) / 2;\n        if (check3(hoge, now, m))\n        {\n            r = now;\n        }\n        else\n        {\n            l = now+1;\n        }\n    }\n    if (pr[i + n - 1] - pr[r] > m)return false;\n    return true;\n}\n \nint main()\n{\n     \n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        a.push_back(x);\n        (i == 0) ? pr.push_back(x) : pr.push_back(x + pr[i - 1]);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        a.push_back(a[i]);\n        pr.push_back(pr.back() + a[i]);\n    }\n    long long int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        long long int r = 0, l = 50000000;\n        while (r != l)\n        {\n            long long int m = (r + l) / 2;\n            if (check(i,m))\n            {\n                l = m;\n            }\n            else\n            {\n                r = m+1;\n            }\n        }\n        ans = max(ans, l);\n    }\n    cout << ans << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n, a[200000],s[200000], minx, miny, sum;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tminy = min(s[j] - s[i], s[k] - s[j]);\n\t\t\t\tminy = min(miny, sum - (s[k] - s[i]));\n\t\t\t\tminx = max(minx, miny);\n\t\t\t}\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Baumkuchen\n//Level: 3\n//Category: 最小値の最大化,累積和,二分探索\n//Note: \n\n/**\n * 一切れの大きさの下限について二分探索する。\n *\n * 下限をひとつ決め、更に切断する切れ込みをひとつ決めると、この切れ込みを端にもつ2つの切れ端について、\n * もう一方の端をどこにするかは累積和上の二分探索で求められる。\n * もう一方の端をどちらも下限ギリギリになるように取ったとき、これらが交差しておらず、かつ3つ目の切れ端も下限を超えていれば、その下限は達成できる。\n *\n * 円周上の累積和をうまく扱うため、数列を3回繰り返したものの上で考えるとよい。\n * オーダーは O(N (log N)^2)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool solve(bool first) {\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    vector<long long> as(1+3*N);\n    as[0] = 0; // sentinel\n    for(int i = 1; i <= N; ++i) {\n        cin >> as[i];\n        as[N+i] = as[N*2+i] = as[i];\n    }\n    for(int i = 1; i < 1+3*N; ++i) {\n        as[i] += as[i-1];\n    }\n\n    long long sum = as[N];\n    long long left = 0, right = sum / 3 + 10;\n    while(left+1 < right) {\n        const long long c = (left + right) / 2;\n        // Separate between m-1 and m\n        bool ok = false;\n        for(int m = N+1; m <= 2*N; ++m) {\n            const auto it = begin(as) + m;\n            auto lit = lower_bound(it-N, it, as[m-1] - c);\n            auto rit = lower_bound(it, it+N, as[m-1] + c);\n            if(as[m-1] - *lit < c) {\n                --lit;\n            }\n            if(rit == it+N) goto next;\n            if(rit - lit >= N) goto next;\n            if(sum - (*rit - *lit) < c) goto next;\n            ok = true;\n            break;\nnext:\n            ;\n        }\n        if(ok) {\n            left = c;\n        } else {\n            right = c;\n        }\n    }\n    cout << left << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define st first\n#define nd second\n#define mp make_pair\n#define space << \" \" <<\n#define END << endl\n#define pb push_back\n#define int long long\n#define fo(i,n) for(int i = 0; i<n; ++i)\n#define ff(i,n) for(int i = 1; i<n; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pi;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> pl;\ntypedef vector<pil>vil;\n\nconst int N = 1e5 + 100;\nll a[N]; int n;\n\nll sum(int u, int v)\n{\n    if(u <= v) return  a[v] - (u==0 ? 0 : a[u-1]);\n    else return a[n-1] - ((u==0?0:a[u-1]) - a[v]);\n}\n\nbool check1(int num ,int t, int v)\n{\n    if(sum(t,(t+num-1)%n) >= v) return 1;\n    else return 0;\n}\n\nbool check(int u, int far)\n{\n    ll v = sum(u,(u+far-1)%n);\n    int t = (u + far) % n;\n    int l = 1;\n    int r = n - far - 1;\n    while( r - l > 1)\n    {\n        int mid = (l + r)/ 2;\n        if(check1(mid,t,v)) r = mid;\n        else l = mid;\n    }\n    if(check1(l,t,v) && a[n-1] - sum(t,(l+t-1)%n) - v >= v) return 1;\n    else if(check1(r,t,v) && a[n-1] - sum(t,(r+t-1)%n) - v >= v) return 1;\n    else return 0;\n}\n\nll work(int u)\n{\n    int l = 1;\n    int r = n-2;\n    //if(sum(u,(u+r-1)%n))\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(check(u,mid)) l = mid;\n        else r = mid;\n    }\n    //cout <<u space check(u,r) space r space check(u,l) space l << endl;\n    if(!check(u,r) && !check(u,l)) return 0;\n    if(check(u,r)) return sum(u,(u+r-1)%n);\n    else return sum(u,(u+l-1)%n);\n\n}\nmain()\n{\n    //freopen(\"test1.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n; fo(i,n) cin >> a[i]; fo(i,n) if(i) a[i] = a[i-1] + a[i];\n    ll ans = 0; fo(i,n) { ans = max(ans , work(i));  }\n    cout << ans << endl;\n    //cout << sum(4,2) << endl;\n    //ll ans = work(0); cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n;\nint A[100010];\nll sum[100010];\n\nbool check(int i, int x, bool f = false)\n{\n    int nowidx = i;\n    ll cur = i == 0 ? 0 : sum[i - 1];\n\n    rep(_, 2) {\n        nowidx = lower_bound(sum, sum + i + n, cur + x) - sum;\n        if (nowidx == i + n) return false;\n        cur = sum[nowidx];\n    }\n\n    return sum[i + n - 1] - sum[nowidx] >= x;\n}\n\nint main()\n{\n    n = in();\n\n    rep(i, n) {\n        A[i] = in();\n        sum[i] = A[i];\n        if (i) sum[i] += sum[i - 1];\n    }\n\n    rep(i, n - 1) {\n        sum[i + n] = A[i] + sum[i + n - 1];\n    }\n\n    ll ma = 0;\n\n    rep(i, n) {\n        ll l = 0, r = linf;\n\n        rep(_, 35) {\n            ll mid = (l + r) / 2;\n\n            (check(i, mid) ? l : r) = mid;\n        }\n\n        chmax(ma, l);\n    }\n\n    printf(\"%lld\\n\", ma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define MAX_N 100000\n#define MAX_A 1000000000\n#define INF 100000000000000\ntypedef __int64 Int;\nint N;\nInt A[MAX_N * 2 + 1];\n\nbool C(int p, Int x){\n\tint lb, ub, mid;\n\tint ed = p + N;\n\t\n\tlb = p; ub = ed;\n\twhile(ub - lb > 1){\n\t\tmid = (lb + ub) / 2;\n\t\tif(A[mid] - A[p] >= x) ub = mid;\n\t\telse lb = mid;\n\t}\n\tif(A[ub] - A[p] < x) return false;\n\t\n\tp = ub; lb = ub; ub = ed;\n\twhile(ub - lb > 1){\n\t\tmid = (lb + ub) / 2;\n\t\tif(A[mid] - A[p] >= x) ub = mid;\n\t\telse lb = mid;\n\t}\n\tif(A[ub] - A[p] < x) return false;\n\t\n\tif(A[ed] - A[ub] < x) return false;\n\t\n\treturn true;\n}\n\nInt Max(Int a, Int b){\n\treturn (a > b)? a : b;\n}\n\nint main(){\n\tInt n, res, lb, ub, mid;\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%I64d\", &n);\n\t\tA[i + 1] = A[i] + n;\n\t}\n\tfor(int i = N + 1; i <= N * 2; i++){\n\t\tA[i] = A[i - 1] + A[i - N] - A[i - N - 1];\n\t}\n\t\n\tres = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tlb = 0; ub = INF;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(C(i - 1, mid)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\t\n\t\tres = Max(res, lb);\n\t}\n\t\n\tprintf(\"%I64d\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tconst long long int one_third = whole / 3;\n\tlong long int ans = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tint j = i;\n\t\tlong long int piece1 = 0;\n\t\twhile (piece1 + (long long int)A[j] <= one_third){\n\t\t\tpiece1 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int piece2 = 0;\n\t\twhile (1){\n\t\t\tpiece2 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t\tif (piece2 >= one_third) break;\n\t\t}\n\n\t\t//long long int piece3 = whole - piece1 - piece2;\n\t\tlong long int tmpans = min(piece1, min(piece2, whole - piece1 - piece2));\n\t\tans = max(ans, tmpans);\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  cin>>n;\n  int a[200000];\n  int z[10000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n  }\n  sort(z,z+n);\n  cout<<z[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> s;\nint n;\n\nbool isOK(long long mid){\n    long long m = mid;\n    for (size_t i = 0; i <= n; i++)\n    {\n        std::vector<long long>::iterator it_j = lower_bound(s.begin() + i, s.end(), m + s[i]);\n        if (s.end() <= it_j){\n            continue;\n        }\n        std::vector<long long>::iterator it_k = lower_bound(it_j, s.end(), m + *it_j);\n        if (s.end() <= it_k){\n            continue;\n        }\n        if((s[n] - (*it_k - s[i]) ) < m){\n            continue;\n        }\n        return true;\n    }\n    return false;\n}\n\nint main(void)\n{\n    cin >> n;\n    s.resize(n);\n\n    s[0] = 0;\n\n    for (size_t i = 0; i < n; ++i)\n    {\n        int a;\n        cin >> a;\n        s[i+1] = s[i] + a;\n    }\n    \n    long long  MaxOfMin = 0;\n    long long  PossibleMaxM = s[n] / 3;\n\n    long long ng = PossibleMaxM; //「m = 0」が条件を満たすこともあるので、初期値は -1\n    long long ok = -1;\n\n    /* ok と ng のどちらが大きいかわからないことを考慮 */\n    while (abs(ok - ng) > 1) {\n        long long mid = (ok + ng) / 2;\n\n        if (isOK(mid)) ok = mid;\n        else ng = mid;\n    }\n\n    // for (long long m = 0; m <= PossibleMaxM; m++)\n    // {\n    //     for (size_t i = 0; i <= n; i++)\n    //     {\n    //         std::vector<long long>::iterator it_j = lower_bound(s.begin() + i, s.end(), m + s[i]);\n    //         if (s.end() <= it_j){\n    //             continue;\n    //         }\n    //         std::vector<long long>::iterator it_k = lower_bound(it_j, s.end(), m + *it_j);\n    //         if (s.end() <= it_k){\n    //             continue;\n    //         }\n    //         if((s[n] - (*it_k - s[i]) ) < m){\n    //             continue;\n    //         }\n    //         MaxOfMin = m;\n    //         break;\n    //     }\n    // }\n    \n    cout << ok << endl;\n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 100001\n#define MIN(a,b) ((a>b)?(b):(a))\n#define mAX(a,b) ((a>b)?(a):(b))\n\ntypedef long long int lli;\n\nint main(void){\n\tint N,a[MAX];\n\tlli i,j,k,l,sum,max,solve=0;\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) scanf(\"%d\",a+i);\n\n\tfor(i=0;i<N;i++){\n\t\tfor(j=i+1;j<N;j++){\n\t\t\tfor(k=j+1;k<N;k++){\n\t\t\t\tfor(l=i,max=0;l<j;l++) max+=a[l];\n\t\t\t\tfor(sum=0;l<k;l++) sum+=a[l];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tfor(sum=0;l<N+i;l++) sum+=a[l%N];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tsolve=mAX(max,solve);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",solve);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\nint main(void){\n\tint n;\n\tlong long a[210000];\n\tint l, r;\n\tint m;\n\tlong long s;\n\tlong long max;\n\tlong long s1, s2, s3;\n\tint z;\n\ts = 0;\n\tscanf(\"%d\", &n);\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ts = s + a[i];\n\t\ta[i] = a[i] + a[i - 1];\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\ta[n + i] = a[i] + s;\n\t}\n\tmax = 0;\n\tl = 0;\n\tr = 1;\n\ts1 = a[1];\n\tm = 2;\n\ts2 = a[2] - a[1];\n\ts3 = s - a[2];\n\tfor (; l < n;){\n\t\tz = 0;\n\t\t\tif (s1 <= s2&&s1 <= s3)z = 1;\n\t\tfor (; s2 < (s - s1) / 2;){\n\t\t\tm++;\n\t\t\ts2 = s2 + a[m] - a[m - 1];\n\t\t\ts3 = s3 - a[m] + a[m - 1];\n\t\t\tif (s1 <= s2&&s1 <= s3)z = 1;\n\t\t}\n\t\tif (z == 1){\n\t\t\tif (max < s1)max = s1;\n\t\t\tr++;\n\t\t\ts1 = s1 + a[r] - a[r - 1];\n\t\t\ts2 = s2 + a[r - 1] - a[r];\n\t\t}\n\t\telse{\n\t\t\tl++;\n\t\t\ts1 = s1 + a[l - 1] - a[l];\n\t\t\ts3 = s3 - a[l - 1] + a[l];\n\t\t}\n\t}\nprintf(\"%lld\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MP make_pair\n\nint main(){\n\tint n,a[100000];\n\tvector<int> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i-1] + x[i-1];\n\t\t}\n\t}\n\tx[n] = x[n-1] + a[n-1];\n\tint length = x[n] / 3;\n\tint mi = 0;\n\tint ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tint tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tint p1 = 0, p2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j;\n\t\t\t\t\ttmp = (x[n] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp = x[i] + length;\n\t\tint q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (q1 == 0) {\n\t\t\t\t\tq1 = j-1;\n\t\t\t\t\ttmp = (x[n] - x[q1] + x[i])/2 + x[q1];\t\n\t\t\t\t} else {\n\t\t\t\t\tq2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2-1] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2-1] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nint n,X[N];\n\nint ans;\nvoid update(int a,int i){\n  int len = X[n-1];  \n  int la = X[a]-X[i];\n  int b = lower_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n  int lb = X[b] - X[a];\n  int lc = len-la-lb;\n  ans = max(ans,min(la,min(lb,lc)));\n}\n\nsigned main(){\n\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n    \n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n\n  int len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int au = upper_bound(X+i,X+3*n,X[i]+len/3) - X;\n    update(au,i),update(au-1,i);\n }\n cout<< ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define NN 505\n#define N 100005\n#define oo 1000000007\n#define ln 1000000009\n\nusing namespace std;\n\nll S[N], ans;\nint n, a[N];\n\nll Get(int F, int i, int j)\n{\n    int L = i-1;\n    int R = j;\n    while(R - L > 1)\n    {\n        int X = (L + R) / 2;\n        if(S[X] * 2 <= S[i-1] + S[j])  L = X;\n        else R = X;\n    }\n    return min(S[i-1] - S[F-1], max(min(S[L] - S[i-1], S[j] - S[L]), min(S[R] - S[i-1], S[j] - S[R])));\n}\n\nll Solve(int i)\n{\n    int L = i;\n    int R = i + n - 1;\n    while(R != L)\n    {\n        int X = (L + R) / 2;\n        if(Get(i, X, i+n-1) > Get(i, X+1, i+n-1))   R = X;\n        else L = X+1;\n    }\n    return Get(i, L, i+n-1);\n}\n\nint main()\n{\n    //filein(\"inp.txt\");  fileout(\"out.txt\");\n    cin >> n;\n    for(int i=1; i<=n; i++)\n        cin >> a[i], a[i+n] = a[i];\n    for(int i=1; i<=2*n; i++)\n        S[i] = S[i-1] + a[i];\n    for(int i=1; i<=n; i++)\n        ans = max(ans, Solve(i));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[100010];\n\nvoid a(string s){}\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n    if (idx >= i + N) return false;\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n    if (idx2 >= i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 100010, 1e15);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e15+2;\n\n        rep(_, 60) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[200010];\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n\n    if (idx >= i + N) return false;\n\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n\n    if (idx2 >= i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 200010, 1e16);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e15+2;\n\n        rep(_, 50) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  cin>>n;\n  int a[200000];\n  int z[200000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n    for(int j;j<n;j++){\n    d=j-1;\n    while(b<=c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    while(e<c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n    }\n    b=0;\n    c=0;\n    j=0;\n    e=0;\n    f=0;\n    d=0;\n    for(int j;j<n;j++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    };\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    e=e-a[d];\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n  }\n  sort(z,z+2n);\n  cout<<z[2n-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nint n;\nint X[N]={};\nint ans=0;\nvoid update(int a,int i){\n  int len = X[n-1];\n  int la = X[a]-X[i];\n  int bu = upper_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n  int bl = bu - 1;\n  int lbu = X[bu] - X[a];\n  int lbl = X[bl] - X[a];\n  int lcu = len-la-lbu;\n  int lcl = len-la-lbl;\n  ans = max(ans,min(la,min(lbu,lcu)));\n  ans = max(ans,min(la,min(lbl,lcl)));\n}\n\nsigned main(){\n\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n   \n\n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n   \nint len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int au  = upper_bound(X+i,X+3*n,X[i]+len/3)-X-1;\n    int al = au - 1;\n    update(au,i);\n    update(al,i);\n  }\n  cout<< ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n, a[100000];\n\nlong long sum(int l, int r)\n{\n\tlong long ret = 0;\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tret += a[i % n];\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tret = max(ret, sum(i, j) + sum(j, k) + sum(k, n + i));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 100000\n#define D(x,y) (pos[(x)]-pos[(y)])\n\nlong long A[NMAX];\nlong long pos[NMAX*2];\nint N;\nlong long L;\n\nlong long solve() {\n    long long max = 1;\n    int p0 = 0, p1 = 1, p2 = 2;\n    while (p0 < N) {\n        while (p1 - p0 < N-1 && D(p1, p0) <= max) p1++;\n        if (D(p1, p0) <= max) goto L1;\n\n        while (p2 - p0 < N && D(p2,p1) < D(p1, p0)) p2++;\n        if (D(p2, p1) < D(p1, p0)) goto L1;\n\n        if (L - D(p2, p0) >= D(p1, p0)) {\n            max = D(p1, p0);\n            if (max >= L/3) return max;\n            continue;\n        }\nL1:\n        p0 += 1;\n        while (D(p2, p1) > D(p1, p0)) p2--;\n    }\n    return max;\n}\n\nint main(void) {\n    int i;\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n        L += A[i];\n    }\n    for (i = 0; i < 2*N; i++) {\n        pos[i] = pos[i-1] + A[(i-1)%N];\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tint Left,Right,Mid;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\n\t\tLeft=i;Right=n+2;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid - 2)%n + 1]>=B){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid - 1)%n + 1]<B){\n\t\t\t\tLeft=Mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tB2 = s[(Mid - 1) % n + 1]; d = (Mid - 1) % n + 1;\n\n\t\tLeft=i;Right=n+2;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid - 2)%n + 1]>=C){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid - 1)%n + 1]<C){\n\t\t\t\tLeft=Mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tC2 = s[(Mid - 1) % n + 1]; e = (Mid - 1) % n + 1;\n\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tFILE *inputFile = fopen(\"0600_in4.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t}\n\tfclose( inputFile);\n\t\n\t//cin >> N;\n\t//for(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 1000000001\n#define MIN(a,b) ((a>b)?(b):(a))\n#define mAX(a,b) ((a>b)?(a):(b))\n\ntypedef long long int lli;\n\nint main(void){\n\tint N,a[MAX];\n\tlli i,j,k,l,sum,max,solve=0;\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) scanf(\"%d\",a+i);\n\n\tfor(i=0;i<N;i++){\n\t\tfor(j=i+1;j<N;j++){\n\t\t\tfor(k=j+1;k<N;k++){\n\t\t\t\tfor(l=i,max=0;l<j;l++) max+=a[l];\n\t\t\t\tfor(sum=0;l<k;l++) sum+=a[l];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tfor(sum=0;l<N+i;l++) sum+=a[l%N];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tif(solve<max){\n\t\t\t\tsolve=mAX(max,solve);\n\t\t\t\tprintf(\"debug:%lld %lld %lld,%lld\\n\",i,j,k,solve);\n}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",solve);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\ts1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t/*while(a[l1]-a[r] < m){\n            if(a[l1] == INF)break;\n            l1++;\n        }\n        while(a[l2]-a[l1] < m){\n            if(a[l2] == INF)break;\n            l2++;\n        }\n        if(a[l1] == INF || a[l2] == INF)return 1;\n         \n        if(total-(a[l2]-a[r]) >= m){*/\n\t\t\n\t\tif(total-(s2-a[r]) >= m)return 0;\n\t\telse{\n\t\t\tr++;sum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<map>\n#include<queue>\n\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\ntypedef long long int64;\n\nconst int64 INF = 1LL << 55;\nbool calc( int64 value, vector< int64 >& A){ // value以上で全部切り出せる？\n  for(int i = 0; i < A.size() / 2; i++){\n    vector< int64 >::iterator beg = A.begin() + i, end = A.begin() + i + A.size() / 2 + 1;\n    int64 base = A[i];\n    vector< int64 >::iterator itr1 = lower_bound( beg, end, value + base);\n    if(itr1 == end) continue;\n    vector< int64 >::iterator itr2 = lower_bound( itr1, end, *itr1 + value);\n    if(itr2 == end) continue;\n    vector< int64 >::iterator itr3 = lower_bound( itr2, end, *itr2 + value);\n    if(itr3 == end) continue;\n    return true;\n  }\n  return false;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector< int64 > A(N * 2 + 1);\n  A[0] = 0;\n  for(int i = 1; i <= N; i++){\n    cin >> A[i];\n    A[N + i] = A[i];\n  }\n  for(int i = 1; i < A.size(); i++){\n    A[i] += A[i - 1];\n  }\n  \n  int64 row = 0, high = INF;\n   while(high - row > 0){\n     int64 mid = (row + high + 1) / 2;\n      if(calc(mid, A)) row = mid;\n     else high = mid - 1;\n  }\n\n  cout << row << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n;\nvector<long long> a;\nbool check(int i, long long  m)\n{\n\tvector<long long>::iterator hoge = lower_bound(a.begin() + i, a.begin() + i + n - 1, m + *(a.begin() + i - 1));\n\tvector<long long>::iterator hage = lower_bound(hoge, a.begin() + i + n - 1, m + *hoge);//\n\tif (*(a.begin() + i + n - 1) - (*hage) >= m)return true;\n\treturn false;\n}\n\n\nint main()\n{\n\ta.push_back(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++)a.push_back(a[i]);\n\tfor (int i = 1; i < a.size(); i++)a[i] += a[i - 1];\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long  l = 0,r = 500000000000000000;\n\t\twhile (r != l){\n\t\t\tlong long m = (r + l+1) / 2;\n\t\t\tif (check(i+1, m))\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, l);\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\n \nll const INF = 1LL<<60;\n \nll N;\nll sum[200001];\nll arr[100001];\n \nll midx;\n\nbool C(ll d, ll S[], ll base) {\n  ll p1 = lower_bound(S, S+N, d+base) - S;\n  ll p2 = lower_bound(S, S+N, d+S[p1]) - S;\n  if(N <= p2) return false;\n  if(S[N-1] - S[p2] >= d) {\n    return true;\n  }\n  return false;\n}\n \nint main() {\n   \n  cin >> N;\n  for(int i=0; i<N; i++) {\n    cin >> arr[i];\n  }\n   \n  for(int i=0; i<N; i++) {\n    sum[i] = arr[i];\n    if(i) sum[i] += sum[i-1];\n  }\n  for(int i=N; i<2*N; i++) {\n    sum[i] = arr[i-N]+sum[i-1];\n  }\n   \n  ll ans = 0;\n  for(midx=0; midx<N; midx++) {\n    ll lb = 0, ub = INF;\n    while(ub-lb>1) {\n      ll mid = (lb+ub)/2;\n      ll c;\n      if(midx>0) c = sum[midx-1];\n      else c = 0;\n \n      if(C(mid, sum+midx, c)) {\n        lb = mid;\n      } else {\n        ub = mid;\n      }\n    }\n    ans = max(ans, lb);\n  }\n   \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n\nint main(){\n\tll n,a[100000],maxx = 0,maxi = 0;\n\tvector<ll> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tmaxx = max(maxx,a[i]);\n\t\tif (maxx == a[i]) {\n\t\t\tmaxi = i;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i-1] + x[i-1];\n\t\t}\n\t}\n\tx[n] = x[n-1] + a[n-1];\n\tll length = x[n] / 3;\n\tif (maxx > length) {\n\t\tll i = maxi;\n\t\tll llll = x[n] - maxx;\n\t\tll mama = 0;\n\t\twhile (1) {\n\t\t\tif (i > maxi) {\n\t\t\t\tif((x[i] - x[maxi]) > length) {\n\t\t\t\t\tmama = max(x[i]-x[maxi],x[maxi-1]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif((x[i] - x[maxi]) > length) {\n\t\t\t\t\tmama = max(x[n]-x[maxi]+x[i],x[maxi-1]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = (i+1) % (n+1);\n\t\t}\n\t\tcout << mama << endl;\n\t\treturn 0;\n\t} \n\n\tll mi = 0;\n\tll ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tll tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tll p1 = 0, p2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j;\n\t\t\t\t\ttmp = (x[n] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp = x[i] + length;\n\t\tll q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (q1 == 0) {\n\t\t\t\t\tq1 = j-1;\n\t\t\t\t\ttmp = (x[n] - x[q1] + x[i])/2 + x[q1];\t\n\t\t\t\t} else {\n\t\t\t\t\tq2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2-1] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2-1] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N;\nlong long A[200010];\nlong long T[200010];\n\nbool f(long long X) {\n  for (int i=0; i<N; i++) {\n    int j = i;\n    long long d = 0;\n    bool ok = false;\n    for (; j<i+N; j++) {\n      d += A[j];\n      if (d >= X) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) continue;\n    j++;\n\n    d = 0;\n    for (; j<i+N; j++) {\n      d += A[j];\n      if (d >= X) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) continue;\n    j++;\n\n    if (T[i+N-1] - T[j-1] >= X) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    int a;\n    cin >> a;\n    A[i] = A[i+N] = a;\n  }\n  long long t = 0;\n  for (int i=0; i<N+N; i++) {\n    t += A[i];\n    T[i] = t;\n  }\n\n  long long lo = 0, hi = 1000000000000000000L;\n  long long m;\n  while (hi - lo > 1) {\n    m = (lo + hi) / 2;\n    if (f(m)) lo = m;\n    else      hi = m;\n  }\n  if (f(hi)) m = hi;\n  else       m = lo;\n\n  cout << m << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3*N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <3*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n\t\tprintf(\"c = %d\\n\", c);\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N)break;\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n// clang-format on\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<ll> a(2 * n);\n    REP(i, 0, n) {\n        cin >> a[i];\n        a[i + n] = a[i];\n    }\n    vector<ll> sum(2 * n + 1, 0);\n    REP(i, 0, 2 * n) {\n        sum[i + 1] += a[i % n] + sum[i];\n    }\n\n    auto check = [&](ll mid) -> bool {\n        REP(i, 0, n) {\n            auto it1 = lower_bound(sum.begin() + i, sum.end(), mid + sum[i]) - sum.begin();\n            auto it2 = lower_bound(sum.begin() + it1, sum.end(), mid + sum[it1]) - sum.begin();\n            auto it3 = lower_bound(sum.begin() + it2, sum.end(), mid + sum[it2]) - sum.begin();\n            if (it3 - i <= n) return true;\n        }\n        return false;\n    };\n\n    ll l = 0, r = 1LL << 60;\n    ll ans = 0;\n    while (l <= r) {\n        ll mid = (l + r) / 2;\n        if (check(mid)) {\n            l = mid + 1;\n            ans = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <stdlib.h>\nusing namespace std;\n\n#define debug 0\n\nint InArray[200000] = {0};\nint N = 0;\n\nlong long sumArray(int, int);\n\nint main()\n{\n\t// initialize input\n\tint temp;\n#if debug\n\tFILE *inputFile = fopen(\"0600_in1.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\t//cout << \"N: \" << N << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tfscanf(inputFile, \"%d\", &temp);\n\t\t//cout << temp << endl;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\tcout << endl;\n\t\n\t//for(int i = 0; i < 2 * N; i++){\n\t//\tcout << InArray[i] << endl;\n\t//}\n\t\n\tfclose( inputFile);\n#else\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n#endif\n\t\n\t// Calculate sum and average\n\tlong long sum = sumArray(0, N);\n\tlong long average;\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\n#if debug\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n#endif\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum;\n\tlong long average2;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(int a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(int a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n#if debug\n//cout << a1 << \" \" << a2 << \" \" << a3 << endl;\n//cout << a1_sum << \" \" << a2_sum << \" \" << sum - a1_sum - a2_sum << endl;\n#endif\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n#if debug\n//cout << MaxMin << endl;\n#endif\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n#if debug\n//cout << MaxMin << endl;\n#endif\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong long sumArray(int start, int end)\n{\n\tlong long sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n//\t\tcout << \"i:\" << i << \"sum:\" << sum << endl;\n\t}\n//\tcout << sum << endl;\n//\tsystem(\"pause\");\n\treturn sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\n \nll const INF = (ll)1e10;\n \nll N;\nll sum[200001];\nll arr[100001];\n \nll midx;\n\nbool C(ll d, ll S[], ll base) {\n  ll p1 = lower_bound(S, S+N, d+base) - S;\n  ll p2 = lower_bound(S, S+2*N, d+S[p1]) - S;\n  if(N <= p2) return false;\n  if(S[N-1] - S[p2] >= d) {\n    return true;\n  }\n  return false;\n}\n \nint main() {\n   \n  cin >> N;\n  for(int i=0; i<N; i++) {\n    cin >> arr[i];\n  }\n   \n  for(int i=0; i<N; i++) {\n    sum[i] = arr[i];\n    if(i) sum[i] += sum[i-1];\n  }\n  for(int i=N; i<2*N; i++) {\n    sum[i] = arr[i-N]+sum[i-1];\n  }\n   \n  ll ans = 0;\n  for(midx=0; midx<N; midx++) {\n    ll lb = 0, ub = INF;\n    while(ub-lb>1) {\n      ll mid = (lb+ub)/2;\n      ll c;\n      if(midx>0) c = sum[midx-1];\n      else c = 0;\n \n      if(C(mid, sum+midx, c)) {\n        lb = mid;\n      } else {\n        ub = mid;\n      }\n    }\n    ans = max(ans, lb);\n  }\n   \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100005];\nlong long int b[100005][2][2];\nint main(){\n\tint n;\n\tlong long int s=0,m=0;\n\tint i,j,k;\n\tlong long int c,d,e;\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ts+=a[i];\n\t}\n\tfor(i=0,j=0;i<n;i++){\n\t\twhile(m<(s/3)){\n\t\t\tm+=a[j];\n\t\t\tj++;j%=n;\n\t\t}\n\t\tb[i][0][0]=(j+n-1)%n;\n\t\tb[i][0][1]=m-a[b[i][0][0]];\n\t\tb[i][1][0]=j;\n\t\tb[i][1][1]=m;\n\t\tm-=a[i];\n\t}\n\tm=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<2;j++){\n\t\t\tfor(k=0;k<2;k++){\n\t\t\t\tc=b[i][j][1];\n\t\t\t\td=b[b[i][j][0]][k][1];\n\t\t\t\te=s-c-d;\n\t\t\t\tif(c>d)c=d;\n\t\t\t\tif(c>e)c=e;\n\t\t\t\tif(m<c)m=c;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<m<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m]-A[b-1])r=m;\n    else l=m+1;\n  }\n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    \n    cut2--;\n    \n    cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n;\nint A[100010];\nll sum[100010];\n\nbool check(int i, ll x, bool f = false)\n{\n    int nowidx = i;\n    ll cur = i == 0 ? 0 : sum[i - 1];\n\n    rep(_, 2) {\n        nowidx = lower_bound(sum, sum + i + n, cur + x) - sum;\n        if (nowidx == i + n) return false;\n        cur = sum[nowidx];\n    }\n\n    return sum[i + n - 1] - sum[nowidx] >= x;\n}\n\nint main()\n{\n    n = in();\n\n    rep(i, n) {\n        A[i] = in();\n        sum[i] = A[i];\n        if (i) sum[i] += sum[i - 1];\n    }\n\n    rep(i, n - 1) {\n        sum[i + n] = A[i] + sum[i + n - 1];\n    }\n\n    ll ma = 0;\n\n    rep(i, n) {\n        ll l = 0, r = linf;\n\n        rep(_, 65) {\n            ll mid = (l + r) / 2;\n\n            (check(i, mid) ? l : r) = mid;\n        }\n\n        chmax(ma, l);\n    }\n\n    printf(\"%lld\\n\", ma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tfor (; i2 < i1_ini + N - 2;){\n\t\tpiece1_s = piece1_l;\n\t\tpiece1_l += A[i2%N];\n\t\ti2++;\n\t\tif (piece1_l > one_third_size) break;\n\t}\n\tconst int i1_fin = i2;\n\n\tint i3 = i1_ini + N;\n\tull piece3_s = 0;\n\tull piece3_l = 0;\n\tfor (; i3 > i2 + 1;){\n\t\tpiece3_s = piece3_l;\n\t\ti3--;\n\t\tpiece3_l += A[i3%N];\n\t\tif (piece3_l > one_third_size) break;\n\t}\n\ti3++;\n\n\t/*ull tmp = 0;\n\ttmp = min(piece1_s, piece3_s);\n\t\n\tull piece2 = 0;\n\tpiece2 = total_size - piece1_s - piece3_l;\n\ttmp = max(tmp, min(piece1_s, piece2));\n\n\tpiece2 = total_size - piece1_l - piece3_s;\n\ttmp = max(tmp, min(piece3_s, piece2));\n\n\tpiece2 = total_size - piece1_l - piece3_l;\n\ttmp = max(tmp, piece2);\n\n\tanswer = tmp;*/\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse{\n\t\t\tfor (; i2 < i1 + N - 2;){\n\t\t\t\tpiece1_s = piece1_l;\n\t\t\t\tpiece1_l += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif (piece1_l > one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse{\n\t\t\tfor (; i3 < i1 + N - 1;){\n\t\t\t\tpiece3_l = piece3_s;\n\t\t\t\tpiece3_s -= A[i3%N];\n\t\t\t\ti3++;\n\t\t\t\tif (piece3_s <= one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\t/*tmp = min(piece1_s, piece3_s);\n\n\t\tpiece2 = total_size - piece1_s - piece3_l;\n\t\ttmp = max(tmp, min(piece1_s, piece2));\n\n\t\tpiece2 = total_size - piece1_l - piece3_s;\n\t\ttmp = max(tmp, min(piece3_s, piece2));\n\n\t\tpiece2 = total_size - piece1_l - piece3_l;\n\t\ttmp = max(tmp, piece2);\n\n\t\tanswer = max(answer, tmp);*/\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint rem = sum - size;\n\t\t\tint lb = right + 1, ub = left + n;\n\t\t\twhile (ub - lb > 1)\n\t\t\t{\n\t\t\t\tint mid = (lb + ub) / 2;\n\t\t\t\tint score = cuts[mid] - cuts[right];\n\t\t\t\tif (score <= rem / 2) lb = mid;\n\t\t\t\telse ub = mid;\n\t\t\t}\n\n\t\t\tREP(l, -1, 2)\n\t\t\t{\n\t\t\t\tint k = lb + l;\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t}\n\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n;\nint A[100010];\nint sum[100010];\n\nbool check(int i, int x, bool f = false)\n{\n    if(f)printf(\"check(%d, %d) called\\n\", i, x);\n    int nowidx = i;\n    int cur = i == 0 ? 0 : sum[i - 1];\n\n    rep(_, 2) {\n        nowidx = lower_bound(sum, sum + i + n, cur + x) - sum;\n        if (nowidx == i + n) return false;\n        if(f)printf(\"nowidx = %d\\n\", nowidx);\n        if(f)printf(\"sum[nowidx] - cur = %d\\n\", sum[nowidx] - cur);\n        cur = sum[nowidx];\n    }\n\n    return sum[i + n - 1] - sum[nowidx] >= x;\n}\n\nint main()\n{\n    n = in();\n\n    rep(i, n) {\n        A[i] = in();\n        sum[i] = A[i];\n        if (i) sum[i] += sum[i - 1];\n    }\n\n    rep(i, n - 1) {\n        sum[i + n] = A[i] + sum[i + n - 1];\n    }\n\n    int ma = 0;\n\n    rep(i, n) {\n        int l = 0, r = inf;\n\n        rep(_, 35) {\n            int mid = (l + r) / 2;\n\n            (check(i, mid) ? l : r) = mid;\n        }\n\n        chmax(ma, l);\n    }\n\n    printf(\"%d\\n\", ma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n    ll ans=0,sum=0;\n    int n,l=0,r=1;\n    \n    scanf(\"%d\",&n);\n    \n    vector<ll> a(2*n+1,0);\n    \n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        sum+=a[i];\n        a[i]=sum;\n    }\n    \n    for(int i=1;i<=n;i++){\n        a[i+n]=sum+a[i];\n    }\n    \n    while(1){\n        \n        if((a[r]-a[l])*3<sum){\n            r++;\n        }else{\n            l++;\n            if(l==n+1) break;\n        }\n        \n        if((a[r]-a[l])*3<sum)\n            continue;\n        \n        vector<ll>::iterator itl=lower_bound(a.begin(),a.end(),(sum-a[r]+a[l]+1)/2+a[r]);\n        \n        if(itl!=a.end()){\n            ans=max(ans,sum-(*itl)+a[l]);\n            ans=max(ans,*(itl-1)-a[r]);\n        }\n        \n       // cout << l << \"-\" << r << \":\" << a[r]-a[l] << \" \" << sum-(*itl)+a[l] << \":\" << *(itl-1)-a[r] << endl;\n        \n    }\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n\nint main(){\n\tll n,a[100000],maxx = 0,maxi = 0;\n\tvector<ll> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tmaxx = max(maxx,a[i]);\n\t\tif (maxx == a[i]) {\n\t\t\tmaxi = i;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i-1] + x[i-1];\n\t\t}\n\t}\n\tx[n] = x[n-1] + a[n-1];\n\tll length = x[n] / 3;\n\tif (maxx > length) {\n\t\tlength = (x[n] - maxx)/2;\n\t\tcout << length << endl;\n\t\treturn 0;\n\t\tll i = maxi+1;\n\t\tll llll = x[n] - maxx;\n\t\tll mama = 0;\n\t\twhile (1) {\n\t\t\tif (i > maxi) {\n\t\t\t\tif((x[i] - x[maxi+1]) > length) {\n\t\t\t\t\tmama = max(x[i]-x[maxi],x[maxi-1]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif((x[i] - x[maxi+1]) > length) {\n\t\t\t\t\tmama = max(x[n]-x[maxi]+x[i],x[maxi-1]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = (i+1) % (n+1);\n\t\t}\n\t\tcout << mama << endl;\n\t\treturn 0;\n\t} \n\n\tll mi = 0;\n\tll ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tll tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tll p1 = 0, p2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j;\n\t\t\t\t\ttmp = (x[n] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp = x[i] + length;\n\t\tll q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (q1 == 0) {\n\t\t\t\t\tq1 = j-1;\n\t\t\t\t\ttmp = (x[n] - x[q1] + x[i])/2 + x[q1];\t\n\t\t\t\t} else {\n\t\t\t\t\tq2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2-1] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2-1] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N + 2; i++ )\n\t{\n\t\tfor( size_t j = i; j < N + 2; j++ )\n\t\t{\n\t\t\tfor( size_t k = j; k < N + 2; k++ )\n\t\t\t{\n\t\t\t\tans = max ( ans , min ( { data[j] - data[i] , data[k] - data[j] , ( data[N + 1] - data[k] ) + ( data[i] - data[0] ) } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200001];\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\t\tint posl2 = posr1 - 1;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nvoid InitRand()\n{\n\tsrand((unsigned int)time(NULL));\n}\nint Dice()\n{\n\treturn rand() % N;\n}\nint main()\n{\n\tInitRand();\n\tint cou;\n\tint i, j, k;\n\tll ans = 0;\n\tll sum1, sum2, sum3;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < N; i++)AA[i] = AA[i - 1] + A[i];\n\tfor (cou = 0; cou < 40000000; cou++){\n\t\t//if (cou % 100000 == 99999)printf(\"%d\\n\", cou);\n\t\tsum1 = sum2 = sum3 = 0;\n\t\ti = Dice(); j = Dice(); k = Dice();\n\t\tif (i == j || j == k || i == k)continue;\n\t\tif (i>j)swap(i, j);\n\t\tif (i>k)swap(i, k);\n\t\tif (j>k)swap(j, k);\n\t\tif(i!=0)sum1 += AA[i - 1];\n\t\tsum2 += AA[j-1] - AA[i - 1];\n\t\tsum3 += AA[k-1] - AA[j - 1];\n\t\tsum1 += AA[N-1] - AA[k - 1];\n\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    ll sum=0;\n    vector<ll> a(2*n);\n    rep(i,n)\n    {\n        scanf(\" %lld\", &a[i]);\n        a[i+n]=a[i];\n        sum+=a[i];\n    }\n\n    vector<ll> presum(2*n+1,0);\n    for(int i=1; i<=2*n; ++i) presum[i] = presum[i-1]+a[i-1];\n\n    rep(i,presum.size()) printf(\" %d: %lld\\n\", i,presum[i]);\n\n    ll ans=0;\n    rep(i,n)\n    {\n        int x = lower_bound(all(presum),presum[i]+sum/3)-presum.begin();\n        int y = lower_bound(all(presum),presum[i]+sum*2/3)-presum.begin();\n        for(int j=x-2; j<=x+2; ++j)for(int k=y-2; k<=y+2; ++k)\n        {\n            if(i<j && j<k && j<i+n && k<i+n)\n            {\n                ll p = presum[j]-presum[i];\n                ll q = presum[k]-presum[j];\n                ll r = presum[i+n]-presum[k];\n\n                ans = max(ans, min({p,q,r}));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\tint k = max(j + 1, min(sep, n - 1));\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=1e5+10;\nlong long int a[N];\nint n;\nbool check(long long int val){\n    long long int now=0,cnt=0;\n    for(int i=0;i<n;i++){\n        now+=a[i];\n        if(now>=val){\n            now=0;\n            cnt++;\n            if(cnt>=3)return true;\n        }\n    }\n    return false;\n}\nint main(){\n    long long int l=0,r=0,mid;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n        r+=a[i];\n    }\n    while(r-l>1){\n        mid=(r+l)/2;\n        if(check(mid))l=mid;\n        else r=mid;\n    }\n    printf(\"%lld\\n\",l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n + n) if (cuts[k] - cuts[j] >= size)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nlong long int d[100000];\n\nlong long int wa[200000];\n\nbool func(long long int l)\n{\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint now = i;\n\t\tfor(int j = 0; j < 2; j++)\n\t\t{\n\t\t\tlong long int nl;\n\t\t\tif(now == 0)\n\t\t\t{\n\t\t\t\tnl = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnl = wa[now - 1];\n\t\t\t}\n\t\t\tif(wa[i + n - 1] - nl < l)\n\t\t\t{\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tint s = now - 1;\n\t\t\tint b = i + n - 1;\n\t\t\twhile(s < b - 1)\n\t\t\t{\n\t\t\t\tint m = (s + b) / 2;\n\t\t\t\tif(wa[m] - nl >= l)\n\t\t\t\t{\n\t\t\t\t\tb = m;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow = b + 1;\n\t\t\t//printf(\"%d %d\\n\",i,now);\n\t\t}\n\t\tif(wa[i + n - 1] - wa[now - 1] < l)\n\t\t{\n\t\t\tgoto aa;\n\t\t}\n\t\treturn true;\naa:\n\t\tint q = 0;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tlong long int now = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tlong long int w;\n\t\tscanf(\"%lld\",&w);\n\t\td[i] = w;\n\t\tnow += w;\n\t\twa[i] = now;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tnow += d[i];\n\t\twa[i + n] = now;\n\t}\n\tlong long int s = 1;\n\tlong long int b = 1000000000000000;\n\twhile(s < b - 1)\n\t{\n\t\tlong long int m = (s + b) / 2;\n\t\tif(func(m))\n\t\t{\n\t\t\ts = m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb = m;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(ll l, ll r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, ll s) {\n    ll n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    return P((s+r)%n, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d;\n            P p = search(m, i); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            sd += len(pos, i);\n            if (sd == L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500000\nusing namespace std;\n#define int long long\n\nint n;\nint A[N],X[N];\n\nbool check(int i,int x){\n  int len = X[n-1];\n  int a  = lower_bound(X+i,X+3*n,X[i]+x) - X;\n  int la = X[a]-X[i];\n  int b = lower_bound(X+a,X+3*n,X[a]+x)-X;\n  int lb = X[b]-X[a];\n  int lc = len - la-lb;\n  return lc>=x;\n}\n\nsigned main(){\n\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i];\n  \n\n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n\n  int ans = 0;\n  for(int i=0;i<=n;i++){\n    \n    int L = 0 , R = X[n-1];\n    while(L+1<R){\n      int M =(L+R)/2;\n      if(!check(i,M)) R = M;\n      else L = M;\n    }\n    ans = max(ans,L);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nint N;\nlint A[300005];\n\nbool able(lint x, int piv) {\n\tint add = 0;\n\tfor_(i,0,3) {\n\t\tint lb = 1, ub = N+10;\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (A[piv + add + med] - A[piv + add] >= x) ub = med;\n\t\t\telse lb = med;\n\t\t}\n\t\tadd += ub;\n\t\tif (add > N) return false;\n\t}\n\treturn true;\n}\n\nvoid solve() {\n\tfor_(i,1,N+1) A[i + N] = A[i + 2 * N] = A[i];\n\tfor_(i,1,3*N+5) A[i] += A[i - 1];\n\t\n\tlint ans = 0;\n\tfor_(piv,0,N) {\n\t\tlint lb = 0, ub = 1e16;\n\t\twhile (ub - lb > 1) {\n\t\t\tlint med = (ub + lb) / 2;\n\t\t\tif (able(med, piv)) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\tans = max(ans, lb);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> A[i + 1];\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n\nconst int INF=1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N;\nint A[200004];\nlong long int B[100002];\n\n\nint main(){\n\tFILE *fp;\n\tfp=fopen(\"F:\\\\1JOI本選\\\\2014\\\\joi2014-ho-data\\\\joi2014-ho-data\\\\2014-ho-t3\\\\in\\\\03-06.txt\",\"r\");\n\tfscanf(fp,\"%d\",&N);\n\tlong long int MAX = 0;\n\trep(i,N){\n\t\tfscanf(fp,\"%d\",&A[i]);\n\t\tMAX+=A[i];\n\t\tB[i]=MAX;\n\t}\n\t//memcpy(&A[N],A,sizeof(int)*N);\n\t\n\tlong long int M=MAX/3;//全てのピースがM以上になる切り方は存在するか?\n\tlong long int m=0;\n\tdo{\n\t\tbool cann=false;//全てのピースがn以上になる切り方は存在するか?\n\t\tlong long int n=(M+m)/2;\n\t\trep(i,N-2){//どこで最初に切るか\n\t\t\tint a=i;//よりあとで切る\n\t\t\tint b=N-2;//以前で切る\n\t\t\tdo{//次に切る場所を探す\n\t\t\t\tint c=(a+b)/2;\n\t\t\t\tlong long int piece1=B[c]-B[i];\n\t\t\t\tif(piece1>=n){b=c;}//c以前で切れる\n\t\t\t\telse a=c;//cよりあとで切るべき\n\t\t\t}while(b>a+1);\n\t\t\tlong long int p1=B[b]-B[i];\n\t\t\tif(p1<n)continue;//1個目がもうだめ\n\t\t\tint x=b;\n\t\t\tint y=N-1;\n\t\t\tdo{//最後に切る場所を探す\n\t\t\t\tint z=(x+y)/2;\n\t\t\t\tlong long int piece2=B[z]-B[b];\n\t\t\t\tif(piece2>=n){y=z;}\n\t\t\t\telse x=z;\n\t\t\t}while(y>x+1);\n\t\t\tlong long int p2=B[y]-B[b];\n\t\t\tif(p2<n)continue;//2個目がもうだめ\n\t\t\tif(MAX-p1-p2>=n){cann=true;}\n\t\t}\n\t\tif(cann){m=n;}//すべて(３つ)のピースがn以上になりえる\n\t\telse{M=n;}\n\t}while(M>m+1);\n\tprintf(\"%lld\\n\",m);\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\t\tfor (int j = i; j <= n + i; j++) {\n\t\t\tif (s[j%n] >= B) { B2 = s[j%n]; break; }\n\t\t}\n\t\tfor (int j = i; j <= n + i; j++) {\n\t\t\tif (s[j%n] >= C) { C2 = s[j%n]; break; }\n\t\t}\n\t\tif (A > B2) {\n\t\t\td = A;\n\t\t\te = B2;\n\t\t\tA = e;\n\t\t\tB2 = d;\n\t\t}\n\t\tif (B2 > C2) {\n\t\t\td = B2;\n\t\t\te = C2;\n\t\t\tB2 = e;\n\t\t\tC2 = d;\n\t\t}\n\t\tif (A > C2) {\n\t\t\td = A;\n\t\t\te = C2;\n\t\t\tA = e;\n\t\t\tC2 = d;\n\t\t}\n\t\tminy = min(B2 - A, C2 - B2);\n\t\tminy = min(miny, sum - (C2 - A));\n\t\tminx = max(minx, miny);\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nint n;\nint X[N]={};\nint ans=0;\nvoid update(int a,int i){\n  int len = X[n-1];\n  int la = X[a]-X[i];\n  int bu = upper_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n  int bl = bu - 1;\n  int lbu = X[bu] - X[a];\n  int lbl = X[bl] - X[a];\n  int lcu = len-la-lbu;\n  int lcl = len-la-lbl;\n  ans = max(ans,min(la,min(lbu,lcu)));\n  ans = max(ans,min(la,min(lbl,lcl)));\n}\n\nsigned main(){\n\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n   \n\n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n   \nint len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int a  = upper_bound(X+i,X+3*n,X[i]+len/3)-X-1;\n    int la = X[a]-X[i];\n    int b = lower_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n    int lb = X[b] - X[a];\n    int lc = len-la-lb;\n    ans = max(ans,min(la,min(lb,lc)));\n  }\n  cout<< ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cassert>\n#include<string>\n#include<vector>\n#include<queue>\n#define MAX_N 100010\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 100000005\n#define rep(i,n) for(int i = 0;i < n;i++)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> PI;\n\nint N;\nll allsum=0;\nll A[MAX_N],sum[MAX_N];\n\n\nbool check(ll shrt){\n    int c1,c2,c3;\n    for(c1=0;c1<N;c1++){\n        c2=(int)(lower_bound(sum,sum+2*N+1,sum[c1]+shrt)-sum);\n        if(c2>c1+N)\n            continue;\n        c3=(int)(lower_bound(sum,sum+2*N+1,sum[c2]+shrt)-sum);\n        if(c3>c1+N)\n            continue;\n        if(allsum-(sum[c3]-sum[c1])>=shrt){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cin>>N;\n    rep(i,N){\n        cin>>A[i];\n        allsum+=A[i];\n        A[i+N]=A[i];\n    }\n    sum[0]=0;\n    rep(i,2*N){\n        sum[i+1]=sum[i]+A[i];\n    }\n    ll left = 0,right = allsum+1;\n    while(right-left>1){\n        ll mid = (right+left)/2;\n        if(check(mid)){left=mid;}\n        else{right=mid;}\n    }\n    cout<<left<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define ULL int64_t\n\nULL sum(ULL *d,ULL s ,ULL e){\n\tULL r = 0;\n\tfor(int i = s;i <= e;i++){\n\t\tr+=d[i];\n\t}\n\treturn r;\n}\n\nint main(){\n\tULL n;\n\tcin >> n;\n\tULL *d = (ULL*)malloc(sizeof(ULL) * n);\n\tif(d == NULL){\n\t\treturn -1;\n\t}\n\tULL s = 0;\n\tULL m;\n\tfor(ULL i = 0;i < n;i++){\n\t\tcin>>m;\n\t\td[i] = m;\n\t\ts += m;\n\t}\n\tULL max_dis = s;\n\tULL max_snd,max_thd;\n\tfor(ULL u = 0;u < n - 2;u++){\n\t\tfor(ULL v = u+1;v < n - 1;v++){\n\t\t\tfor(ULL w = v + 1;w < n;w++){\n\t\t\t\tULL snd = sum(d,u,v-1);\n\t\t\t\tULL thd = sum(d,v,w-1);\n\t\t\t\tULL fst = s - snd - thd;\n\t\t\t\tif(max_dis > abs(snd - thd) + abs(thd-fst) + abs(fst - snd)){\n\t\t\t\t\tmax_dis = abs(snd - thd) + abs(thd-fst) + abs(fst - snd);\n\t\t\t\t\tmax_snd = snd;\n\t\t\t\t\tmax_thd = thd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tULL max_fst = s - max_snd - max_snd;\n\tULL res;\n\tif(max_fst <= max_snd && max_fst < max_thd){\n\t\tres = max_fst;\n\t}else if(max_snd <= max_thd && max_snd <= max_fst){\n\t\tres = max_snd;\n\t}else{\n\t\tres = max_thd;\n\t}\n\tcout<<res<<endl;\n\tfree( d );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>=1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC+1;\n\t\t\t\telse RR = CC-1;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r-1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<17;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2--;\n        p2--;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nbool Check(const vector<int> &a,int m){\n\tREP(i,0,a.size()){\n\t\tint cnt=0,last=i;\n\t\tdump(i);\n\t\tREP(i,0,3){\n\t\t\tint crt=last;\n\t\t\tint d=a[crt];\n\t\t\t++cnt;\n\t\t\twhile(cnt<=a.size()&&d<m){\n\t\t\t\tcrt=(crt+1)%a.size();\n\t\t\t\td+=a[crt];\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif(!(cnt<=a.size())) break;\n\t\t\tdump(last);\n\t\t\tdump(crt);\n\t\t\tdump(d);\n\t\t\tlast=(crt+1)%a.size(); \n\t\t}\n\t\tcout << endl;\n\t\tif(cnt<=a.size()) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tREP(i,0,N) cin >> A[i];\n\tint lb=0,ub=INF;\n\twhile(ub-lb>1){\n\t\tint mid=(lb+ub)/2;\n\t\tif(Check(A,mid)){\n\t\t\tlb=mid;\n\t\t\tdump(lb);\n\t\t\tcout << endl;\n\t\t}else ub=mid;\n\t}\n\tCheck(A,6);\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT binary_search(function<bool(T)> func, T include, T exclude)\n{\n  while (abs(exclude - include) > 1)\n  {\n    auto middle = (include + exclude) / 2;\n    (func(middle) ? include : exclude) = middle;\n  }\n  return include;\n}\n\nlong long N, A[200000], B[200000];\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> A[i];\n    A[i + N] = B[i] = B[i + N] = A[i];\n  }\n  for(int i = 1; i < N * 2; i++)\n    B[i] += B[i - 1];\n  auto f = [&](int v)\n  {\n    for(int i = 0; i < N; i++)\n    {\n      auto it = lower_bound(B + i, B + N * 2, v + B[i]);\n      if(it == B + N * 2)\n        continue;\n      auto it2 = lower_bound(it, B + N * 2, v + *it);\n      if(it2 == B + N * 2)\n        continue;\n      if(B[i + N] - *it2 >= v)\n        return true;\n    }\n    return false;\n  };\n  cout << binary_search<long long>(f, 0, B[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n;\nint table[200000];\n\nbool solve(ll x) {\n\tint l, r = 1; // [l,r)\n\tREP(i, 2 * n) table[i] = i;\n\tREP(i, 2 * n) {\n\t\tl = i;\n\t\tif (l >= r) r = l + 1;\n\t\twhile (r - l < n && r < 2 * n && sum[r - 1] - sum[l] + a[l] < x) r++;\n\t\tif (sum[r - 1] - sum[l] + a[l] >= x) table[l] = r;\n\t}\n\t\n\tREP(i, n) {\n\t\tint pos = i;\n\t\tREP(j, 3) {\n\t\t\tif (pos == table[pos]) break;\n\t\t\tpos = table[pos];\n\t\t\tif (pos >= i + n + 1) break;\n\t\t\tif (j == 2 && pos <= i + n + 1) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll n;\n  cin >> n;\n  vector<ll> a(n*2),sum(n*2+1,0);\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    a[n+i] = a[i];\n  }\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i];\n\n  ll ans = 0;\n\n  int l=0, r=0;\n  while(l<n){\n    while(r<l+n-1 && 3*(sum[r]-sum[l])<=sum[n])r++; r--;\n    if(r-l>1){\n      ll cur = sum[r]-sum[l], rem = sum[n]-cur;\n      if(cur>ans){\n\tint L=r, R=l+n;\n\twhile(R-L>1){\n\t  ll M = (L+R)/2;\n\t  if(2*(sum[M]-sum[r])<rem)L = M;\n\t  else R = M;\n\t}\n\t\n\tll minv = 0;\n\tif(R<l+n && r<R)minv = max(minv, min(sum[R]-sum[r], sum[l+n]-sum[R]));\n\tif(R-1<l+n && r<R-1)minv = max(minv, min(sum[R-1]-sum[r], sum[l+n]-sum[R-1]));\n\tminv = min(minv, cur);\n\tans = max(ans, minv);\n      }\n    }\n    l++; if(r<l)r++;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//図を書けばバグらない(バグったorz\n//ijがJOI君とすると残り2人は半分こするのがよさそう。\n#include<stdio.h>\n\nlong long N;\nlong long rui[200001];\n\nlong long max( long long a, long long b ){\n\tif( a > b )\n\t\treturn a;\n\treturn b;\n}\nlong long min( long long a, long long b ){\n\tif( a < b )\n\t\treturn a;\n\treturn b;\n}\nint lower( int start, long long num ){\n\tint last = start + N;\n\tint medi;\n\n\twhile( last - start + 1 > 0 )\n\t{\n\t\tmedi = (start + last)/2;\n\t\tlong long x = rui[medi] - rui[start];\n\n\t\tif( x == num )\n\t\t\tbreak;\n\t\tif( x > num ){\n\t\t\tif( rui[medi-1] - rui[start] < num )\n\t\t\t\tbreak;\n\t\t\tlast = medi-1;\n\t\t}\n\t\tif( x < num )\n\t\t\tstart = medi+1;\n\t}\n\tif( medi > last )\n\t\treturn -1;\n\treturn medi;\n}\n\nint main(){\n\tint i,j;\n\n\tscanf(\"%d\",&N);\n\tfor( i = 1;i <= N;i++ ){\n\t\tscanf(\"%d\",rui+i);\n\t\trui[i] += rui[i-1];\n\t}\n\tfor( i = N+1;i <= 2*N;i++ ){\n\t\trui[i] = rui[N] + rui[i-N];\n\t}\n\n\tlong long ij, jk, ki;\t\t\n\tlong long ans = 0;\n\n\tfor( i = 0;i < N;i++ ){\n\t\tfor( j = i+1;j < N;j++ ){\n\t\t\tij = rui[j] - rui[i];\n\n\t\t\tif( lower( j,ij ) == -1 )\n\t\t\t\tcontinue;\n\t\t\tjk = rui[ lower( j,ij ) ] - rui[j];\n\t\t\tki = rui[i+N] - rui[ lower( j,ij ) ];\n\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\n\t\t\tif( lower( j,ij ) <= j )\n\t\t\t\tcontinue;\n\t\t\tjk = rui[ lower( j,ij )-1 ] - rui[j];\n\t\t\tki = rui[i+N] - rui[ lower( j,ij )-1 ];\n\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nvoid CalcPiece1(int *_i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i2 < _i1 + _N - 2;){\n\t\t*_piece1_s = *_piece1_l;\n\t\t*_piece1_l += _A[(*_i2)%_N];\n\t\t(*_i2)++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\tconst int i1_fin = i2;\n\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tfor (; i3 < i1_ini + N - 1;){\n\t\tpiece3_l = piece3_s;\n\t\tpiece3_s -= A[i3%N];\n\t\ti3++;\n\t\tif (piece3_s <= one_third_size) break;\n\t}\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse{\n\t\t\t/*\n\t\t\tfor (; i2 < i1 + N - 2;){\n\t\t\t\tpiece1_s = piece1_l;\n\t\t\t\tpiece1_l += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif (piece1_l > one_third_size) break;\n\t\t\t}//*/\n\t\t\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\t\t}\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse{\n\t\t\tfor (; i3 < i1 + N - 1;){\n\t\t\t\tpiece3_l = piece3_s;\n\t\t\t\tpiece3_s -= A[i3%N];\n\t\t\t\ti3++;\n\t\t\t\tif (piece3_s <= one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[4 * N];\n\tmemo = new long long[5 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n\t\t//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < 4 * N; i++){\n\t\tint b;\n\n\t\tfor (int f = 0; f < 5 * N; f++){\n\t\t\tmemo[f] = 0;\n\t\t}\n\t\tfor (b = i + 1; b < 3 * N; b++){\n\t\t\tmemo[b] = memo[b - 1] + piece(b - 1, b);\n\t\t\tif (memo[b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[b - 1] < memo[b] - tripartition){\n\t\t\tif (i == b-1)keep_value = memo[b];\n\t\t\telse{\n\t\t\t\tkeep_value = memo[b - 1];\n\t\t\t\tb--;\n\t\t\t}\n\t\t}\n\t\telse keep_value = memo[b];\n\t\tdouble half = (sum_baum - memo[b]) / 2.0;\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[c] = memo[c - 1] + piece(c - 1, c);\n\t\t\tif (memo[c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[c - 1] < memo[c] - keep_value - half){\n\t\t\tkeep_value2 = memo[c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (i ==0 && c == N)i = b-1;\n\t\telse {\n\t\t\tif (c == N || c == 2 * N || c == 3 * N)break;\n\t\t}\n\n\t}\n\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT binary_search(function<bool(T)> func, T include, T exclude)\n{\n  while (abs(exclude - include) > 1)\n  {\n    auto middle = (include + exclude) / 2;\n    (func(middle) ? include : exclude) = middle;\n  }\n  return include;\n}\n\nlong long N, A[200000], B[200000];\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> A[i];\n    A[i + N] = B[i] = B[i + N] = A[i];\n  }\n  for(int i = 1; i < N * 2; i++)\n    B[i] += B[i - 1];\n  auto f = [&](long long v)\n  {\n    for(int i = 0; i < N; i++)\n    {\n      auto it = lower_bound(B + i, B + N * 2, v + B[i]);\n      if(it == B + N * 2)\n        continue;\n      auto it2 = lower_bound(it, B + N * 2, v + *it);\n      if(it2 == B + N * 2)\n        continue;\n      if(B[i + N] - *it2 >= v)\n        return true;\n    }\n    return false;\n  };\n  cout << binary_search<long long>(f, 0, B[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint N, A[200000];\nint64 sum[200000];\n\nbool Find(const int& pos, const int64& size){\n  int hoge = distance( sum, lower_bound( sum + pos + 1, sum + N + pos + 1, sum[pos] + size));\n  if(hoge == N + pos + 1) return false;\n  int fuga = distance( sum, lower_bound( sum + hoge + 1, sum + N + pos + 1, sum[hoge] + size));\n  if(fuga == N + pos + 1) return false;\n  int foo = distance( sum, lower_bound( sum + fuga + 1, sum + N + pos + 1, sum[fuga] + size));\n  return(foo != N + pos + 1);\n}\n\n\nbool calc(int64 size){ //size: 1個あたりの大きさ\n  for(int pos = 0; pos < N; pos++){\n    if(Find(pos, size)) return true;\n  }\n  return false;\n}\n\nint main(){\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", A + i);\n    A[N + i] = A[i];\n  }\n\n  sum[0] = A[0];\n  for(int i = 1; i < 2 * N; i++){\n    sum[i] = sum[i - 1] + A[i];\n  }\n\n  int64 low = 0, high = sum[2 * N - 1] / 3;\n  while(high != low){\n    int64 mid = (low + high + 1) >> 1;\n    if(calc(mid)) low = mid; else high = mid - 1;\n  }\n  printf(\"%lld\\n\", low);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>                                                                    \n#include <vector>                                                                      \n#include <cmath>                                                                       \n                                                                                       \n                                                                                       \nstd::vector<int> pieces;                                                               \nint limit; // THE MAX SIZE OF SMALLEST BAUMKUCHEN                                      \n                                                                                       \n                                                                                       \nint main()                                                                             \n{                                                                                      \n    // READ INPUTS                                                                     \n    {                                                                                  \n        int num, sum(0);                                                               \n        std::cin >> num;                                                               \n                                                                                       \n        pieces.assign(num, 0);                                                         \n        for (int i = 0; i < num; ++i)                                                  \n        {                                                                              \n            std::cin >> pieces[i];                                                     \n            sum += pieces.at(i);                                                       \n        }                                                                              \n        limit = std::ceil((double)sum / 3.0);                                          \n    }                                                                                  \n                                                                                       \n    int idx1(0), idx2(1);     // BEGIN & END INDEX OF SMALLEST BAUMKUCHEN              \n    int size(pieces.front()); // THE SIZE OF SMALLEST BAUMKUCHEN                       \n    int out(0);               // RETURN VALUE                                          \n                                                                                       \n    for (; idx1 < pieces.size(); size -= pieces.at(idx1++))                            \n    {                                                                                  \n        while (size + pieces.at(idx2) < limit)                                         \n        {                                                                              \n            size += pieces.at(idx2++);                                                 \n            idx2 %= pieces.size();                                                     \n        }                                                                              \n                                                                                       \n        if (size > out) out = size;                                                    \n    }                                                                                  \n                                                                                       \n    std::cout << out << std::endl;                                                     \n                                                                                       \n    return 0;                                                                          \n}                                                                                      \n                                                                                       \n                  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<20;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconst int IINF = (1 << 30) - 1;\nconst long long LLINF = 1LL << 61;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\ntemplate<typename T>\nbool chmax(T &a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T &a, T b){\n    if(b < a){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint n;\nvector<lint> sum;\n\ntemplate<typename T>\nbool check(T mid){\n    rep(i, n){\n        auto it1 = lower_bound(sum.begin() + i, sum.begin() + i + n, sum[i] + mid);\n        auto it2 = lower_bound(it1, sum.begin() + i + n, *it1 + mid);\n        if(sum[i + n] - *it2 >= mid){\n            return true;\n        }\n    }\n    return false;\n}\n\ntemplate<typename T>\nT meguru_search(T ok, T ng){\n    while(max(ok, ng) - min(ok, ng) > (T)1){\n        T mid = (ok + ng) / T(2);\n        if(check(mid)){\n            ok = mid;\n        }else{\n            ng = mid;\n        }\n    }\n    return ok;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n\n    sum.resize(n * 2 + 1);\n    reps(i, n){\n        cin >> sum[i];\n        sum[i + n] = sum[i];\n    }\n\n    reps(i, n * 2){\n        sum[i] += sum[i - 1];\n    }\n\n    lint ans = meguru_search(1LL, sum[n * 2]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i-1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n-1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[cut2][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < n; cut3_1++){\n\t\t\tif (baum - a[cut3_1][1] + a[cut1][1] >(baum - (a[cut2-1][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < n; cut3_2++){\n\t\t\tif (baum - a[cut3_2][1] + a[cut1][1] >(baum - (a[cut2][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3_1 - 1][1] - a[cut2 - 1][1];\n\t\tb[0][2] = baum - a[cut3_1 - 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3_1][1] - a[cut2 - 1][1];\n\t\tb[1][2] = baum - a[cut3_1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3_2 - 1][1] - a[cut2][1];\n\t\tb[2][2] = baum - a[cut3_2 - 1][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3_2][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3_2][1] + a[cut1][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[n-1-(n-1-(cut2))][1] - a[n-1-(cut1)][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < n; cut3_1++){\n\t\t\tif (baum - a[n-1-(cut3_1)][1] + a[n-1-(cut1)][1] >(baum - (a[n-1-(cut2-1)][1] - a[n-1-(cut1)][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < n; cut3_2++){\n\t\t\tif (baum - a[n-1-(cut3_2)][1] + a[n-1-(cut1)][1] >(baum - (a[n-1-(cut2)][1] - a[n-1-(cut1)][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[n-1-(cut2 - 1)][1] - a[n-1-(cut1)][1];\n\t\tb[0][1] = a[n-1-(cut3_1 - 1)][1] - a[n-1-(cut2 - 1)][1];\n\t\tb[0][2] = baum - a[n-1-(cut3_1 - 1)][1] + a[n-1-(cut1)][1];\n\t\tb[1][0] = a[n-1-(cut2 - 1)][1] - a[n-1-(cut1)][1];\n\t\tb[1][1] = a[n-1-(cut3_1)][1] - a[n-1-(cut2 - 1)][1];\n\t\tb[1][2] = baum - a[n-1-(cut3_1)][1] + a[n-1-(cut1)][1];\n\t\tb[2][0] = a[n-1-(cut2)][1] - a[n-1-(cut1)][1];\n\t\tb[2][1] = a[n-1-(cut3_2 - 1)][1] - a[n-1-(cut2)][1];\n\t\tb[2][2] = baum - a[n-1-(cut3_2 - 1)][1] + a[n-1-(cut1)][1];\n\t\tb[3][0] = a[n-1-(cut2)][1] - a[n-1-(cut1)][1];\n\t\tb[3][1] = a[n-1-(cut3_2)][1] - a[n-1-(cut2)][1];\n\t\tb[3][2] = baum - a[n-1-(cut3_2)][1] + a[n-1-(cut1)][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n\nconst int INF=1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N;\nint A[200004];\nlong long int B[100002];\n\n\nint main(){\n\t//FILE *fp;\n\t//fp=fopen(\"F:\\\\1JOI本選\\\\2014\\\\joi2014-ho-data\\\\joi2014-ho-data\\\\2014-ho-t3\\\\in\\\\03-06.txt\",\"r\");\n\tscanf(\"%d\",&N);\n\tlong long int MAX = 0;\n\trep(i,N){\n\t\tscanf(\"%d\",&A[i]);\n\t\tMAX+=A[i];\n\t\tB[i]=MAX;\n\t}\n\tmemcpy(&A[N],A,sizeof(int)*N);\n\t\n\tlong long int M=MAX/3;//全てのピースがM以上になる切り方は存在するか?\n\tlong long int m=0;\n\tdo{\n\t\tbool cann=false;//全てのピースがn以上になる切り方は存在するか?\n\t\tlong long int n=(M+m)/2;\n\t\trep(i,N-2){//どこで最初に切るか\n\t\t\tint a=i;//よりあとで切る\n\t\t\tint b=N-2;//以前で切る\n\t\t\tdo{//次に切る場所を探す\n\t\t\t\tint c=(a+b)/2;\n\t\t\t\tlong long int piece1=B[c]-B[i];\n\t\t\t\tif(piece1>=n){b=c;}//c以前で切れる\n\t\t\t\telse a=c;//cよりあとで切るべき\n\t\t\t}while(b>a+1);\n\t\t\tlong long int p1=B[b]-B[i];\n\t\t\tif(p1<n)continue;//1個目がもうだめ\n\t\t\tint x=b;\n\t\t\tint y=N-1;\n\t\t\tdo{//最後に切る場所を探す\n\t\t\t\tint z=(x+y)/2;\n\t\t\t\tlong long int piece2=B[z]-B[b];\n\t\t\t\tif(piece2>=n){y=z;}\n\t\t\t\telse x=z;\n\t\t\t}while(y>x+1);\n\t\t\tlong long int p2=B[y]-B[b];\n\t\t\tif(p2<n)continue;//2個目がもうだめ\n\t\t\tif(MAX-p1-p2>=n){cann=true;}\n\t\t}\n\t\tif(cann){m=n;}//すべて(３つ)のピースがn以上になりえる\n\t\telse{M=n;}\n\t}while(M>m+1);\n\tprintf(\"%lld\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) a.begin(),a.end()\n#define fst first\n#define scd second\n\nint n;\nint A[100010];\nint sum[200010];\n\nbool check(int i, int x)\n{\n\tint idx = lower_bound(sum+i, sum+i+n, sum[i]+x) - sum;\n\n\tif (idx == i + n) return false;\n\tint idx2 = lower_bound(sum+i, sum+i+n, sum[idx]+x) - sum;\n\n\tif (idx2 == i + n) return false;\n\t\n\treturn sum[i+n] - sum[idx2] >= x;\n}\n\nsigned main()\n{\n\tcin >> n;\n\t\n\trep(i, n)cin>>A[i];\n\t\n\trep(i,n) sum[i+1] = A[i] + sum[i];\n\trep(i,n) sum[i+n+1] = A[i] + sum[i+n];\n\t\n\t//rep(i,2*n+1)printf(\"sum[%lld]=%lld\\n\",i,sum[i]);\n\t\n\tint ans = 0;\n\t\n\trep(i, n) {\n\t\tint l = -1, r = 1e9*1e5;\n\t\trep(_, 50) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif (check(i, mid)) l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\t\n\t\tans = max(ans, l);\n\t\t//if (l==17){cout<<\"i=\"<<i<<endl;}\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cassert>\n#include<string>\n#include<vector>\n#include<queue>\n#define MAX_N 100010\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF 100000005\n#define rep(i,n) for(int i = 0;i < n;i++)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> PI;\n\nint N;\nll allsum=0;\nll A[MAX_N*2],sum[MAX_N*2];\n\n\nbool check(ll shrt){\n    int c1,c2,c3;\n    for(c1=0;c1<N;c1++){\n        c2=(int)(lower_bound(sum,sum+2*N+1,sum[c1]+shrt)-sum);\n        if(c2>c1+N)\n            continue;\n        c3=(int)(lower_bound(sum,sum+2*N+1,sum[c2]+shrt)-sum);\n        if(c3>c1+N)\n            continue;\n        if(allsum-(sum[c3]-sum[c1])>=shrt){\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cin>>N;\n    rep(i,N){\n        cin>>A[i];\n        allsum+=A[i];\n        A[i+N]=A[i];\n    }\n    sum[0]=0;\n    rep(i,2*N){\n        sum[i+1]=sum[i]+A[i];\n    }\n    ll left = 0,right = allsum+1;\n    while(right-left>1){\n        ll mid = (right+left)/2;\n        if(check(mid)){left=mid;}\n        else{right=mid;}\n    }\n    cout<<left<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint N;\nbool check(const int from, const vector<long long int>&sums, const long long int norma) {\n\tlong long int base = *(sums.begin() + from);\n\tauto it = lower_bound(sums.begin() + from, sums.begin() + from + N + 1, base + norma);\n\tif (it == sums.begin() + from + N + 1)return false;\n\tbase = *it;\n\tauto jt = lower_bound(it, sums.begin() + from + N + 1, base + norma);\n\tif (jt == sums.begin() + from + N + 1)return false;\n\tbase = *jt;\n\tif (*(sums.begin() + from + N) - base >= norma)return true;\n\telse return false;\n\n}\nint main() {\n\tcin >> N;\n\tvector<long long int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int a; cin >> a;\n\t\tnums.push_back(a);\n\t}\n\tlong long int sum = 0;\n\tvector<long long int>sums;\n\tsums.push_back(sum);\n\tfor (int t = 0; t < 2; ++t) {\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tsum += nums[i];\n\t\t\tsums.push_back(sum);\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 0;\n\t\tlong long int amax = 1e18;\n\t\twhile (amin + 1 != amax) {\n\t\t\tlong long int amid = (amin + amax) / 2;\n\t\t\tif (check(i,sums, amid)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, amin);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[100000];\nint main()\n{\n\tint i,j,k,l;\n\tll sum1 = 0;\n\tll sum2 = 0;\n\tll sum3 = 0;\n\tll ans = 0;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++)scanf(\"%lld\", &A[i]);\n\tfor (i = 0; i < N; i++){\n\t\tfor (j = i + 1; j < N; j++){\n\t\t\tfor (k = j+1; k < N; k++){\n\t\t\t\tsum1 = 0;\n\t\t\t\tsum2 = 0;\n\t\t\t\tsum3 = 0;\n\t\t\t\tfor (l = 0; l < i; l++)sum3 += A[l];\n\t\t\t\tfor (l = i; l < j; l++)sum1 += A[l];\n\t\t\t\tfor (l = j; l < k; l++)sum2 += A[l];\n\t\t\t\tfor (l = k; l < N; l++)sum3 += A[l];\n\t\t\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 100005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n// #define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(int)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = (_begin + _end) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\n\n\nll N,M,K,A[NMAX],B,D,E;\nll S[NMAX] = {};\n\nll ans = {};\n\nbool C(int x){\n  for (int i = 0, j = 0; i < N; ++i)\n  {\n    while(j < N && S[j] - S[i] < x) ++j;\n    if(j == N) return false;\n    int k = j;\n    while(k < N && S[k] - S[j] < x) ++k;\n    if(k == N) return false;\n\n    if(S[i + N] - S[k] >= x) return true;\n  }\n  return false;\n}\n\nvoid solve(){\n  // main algorithm\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    S[i+1] = S[i] + A[i % N];\n  }\n  int low = 1, hi = S[N] / 3 + 10;\n  while(hi - low > 1) {\n    int mid = (hi + low) / 2;\n    if(C(mid)) {\n      low = mid;\n      debug(\"C(%d) = true\\n\", mid);\n    }\n    else {\n      hi = mid;\n      debug(\"C(%d) = false\\n\", mid);\n    }\n  }\n  ans = low;\n}\nvoid debug(){\n  // output debug information\n\n  printf(\"i\\t| A[i]\\tS[i]\\n--------------------------\\n\");\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    printf(\"%d\\t| %lld\\t%lld\\n\", i, A[i%N], S[i]);\n  }\n  printf(\"%d\\t| ***\\t%lld\\n\", 2*N, S[2 * N]);\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // Fill(dp, -1);\n  cin >> N;\n  for (int i = 0; i < N; ++i)\n  {\n    scanf(\"%lld\", &A[i]);\n  }\n  solve();\n  #ifdef DEBUG\n  debug();\n  #endif\n  answer();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\n#define Input(x) scanf(\"%lld\",&x);\n\nll n;\nll a[234567];\nll sum[234567];\n\nbool cond(int index,ll limit)\n{\n\tint nowind = index;\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tInput(n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tInput(a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\tsum[0] = 0;\n\tfor (int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tsum[i] = sum[i - 1] + a[i - 1];\n\t}\n\tll answer = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tll cmin = 0, cmax = sum[n];\n\t\tfor (int j = 0; j < 100; ++j)\n\t\t{\n\t\t\tll find = (cmin + cmax) / 2;\n\t\t\tif (cond(i, find))\n\t\t\t{\n\t\t\t\tcmin = find;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmax = find;\n\t\t\t}\n\t\t}\n\t\tanswer = max(answer, cmin);\n\t}\n\tprintf(\"%lld\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG_IS_VALID\n#define DEB 1\n#define _LIBCPP_DEBUG 0\n#else\n#define DEB 0\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(long long i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(long long i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#define fi first\n#define se second\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid solve();\nint main(void) {\n  std::cout << std::fixed << std::setprecision(15);\n  solve();\n\treturn 0;\n}\n\nusing Int = long long;\nusing ll = long long;\nusing P = pair<Int,Int>;\nusing vi = vector<Int>;\nusing vvi = vector<vi>;\nusing vp = vector<P>;\nusing vvp = vector<vp>;\n\nconst Int INF = (1<<30)-10;\n\nvoid solve(){\n  Int N; cin >> N;\n  vi a(N), s(2*N+1); rep(i, N) cin >> a[i];\n  Int ok = 0, ng = accumulate(ALL(a), 0LL);\n  // copy(a.begin(), a.end(), back_inserter(a));\n  rep(i, N) a.pb(a[i]);\n  rep(i, 2*N) s[i+1] = s[i] + a[i]; \n  while(abs(ok - ng) > 1){\n    Int mid = (ok + ng) / 2;\n    bool chk = false;\n    rep(x, N){\n      Int y, z;\n      Int temp = s[x] + mid;\n      // [x, y), [y, z), [z, x)\n      y = Int(lower_bound(ALL(s), temp) - s.begin());\n      if(y == 2*N + 1) continue;\n      temp = s[y] + mid;\n      z = Int(lower_bound(ALL(s), temp) - s.begin());\n      if(z == 2*N + 1) continue;\n      temp = s[x + N] - s[z];\n      if(temp < mid) continue;\n      chk = true;\n      break;\n    }\n    if(chk) ok = mid;\n    else ng = mid;\n  }\n  cout << ok << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\ntypedef size_t baumkuchen_size_t;\ntypedef int index_t;\n\nstd::vector<baumkuchen_size_t> pieces;\nbaumkuchen_size_t whole_size; // SUM OF SIZE OF PIECES\nbaumkuchen_size_t max_size;   // MAX SIZE OF THE SMALLEST PIECE\n\n\ninline void reguralize(index_t *x)\n{\n    if ((*x) < 0)\n        (*x) += pieces.size();\n    (*x) %= pieces.size();\n}\n\n\ninline void progress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev += pieces.at(idx);\n    size_curr -= pieces.at(idx);\n    ++idx;\n    reguralize(&idx);\n}\n\n\ninline void regress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    --idx;\n    reguralize(&idx);\n    size_prev -= pieces.at(idx);\n    size_curr += pieces.at(idx);\n}\n\n\ninline void update(baumkuchen_size_t input, baumkuchen_size_t *target)\n{\n    if (input > (*target))\n        (*target) = input;\n}\n\n\nint main()\n{\n    // READ INPUTS\n    {\n        int num;\n        std::cin >> num;\n        pieces.assign(num, 0);\n\n        for (int i = 0; i < num; ++i)\n        {\n            std::cin >> pieces[i];\n            whole_size += pieces.at(i);\n        }\n        max_size = whole_size / 3;\n    }\n    \n    index_t idx1(0), idx2(1), idx3(2); // BEGIN INDEX OF EACH BAUMKUCHEN PIECE\n    baumkuchen_size_t\n        size1(pieces.at(idx1)),            // SIZE OF 1ST BAUMKUCHEN PIECE\n        size2(pieces.at(idx2)),            // SIZE OF 2ND BAUMKUCHEN PIECE\n        size3(whole_size - size1 - size2); // SIZE OF 3RD BAUMKUCHEN PIECE\n    baumkuchen_size_t out(0); // RETURN VALUE\n\n    /* PRESUME THAT THE FIRST PIECE IS SMALLEST. */\n\n    std::cerr << \"num = \" << pieces.size() << std::endl;\n    std::cerr << \"sum = \" << whole_size << std::endl;\n    std::cerr << \"max = \" << max_size << std::endl;\n    \n    for (int i = 0; i < pieces.size(); ++i)\n    {        \n        while (size1 <= max_size)\n        {\n            // CHECK WHETHER size1 CAN BE SMALLEST\n            \n            if (size1 <= size2 and size1 <= size3)\n                update(size1, &out);\n\n            while (size1 > size2 or size1 > size3)\n            {\n                // NOTE: size2 & size3 CANNOT BE EQUAL HERE.\n                \n                bool was_larger(size2 > size3);\n                assert(size2 != size3);\n\n                (size2 > size3) ?\n                    regress_idx(idx3, size2, size3) :\n                    progress_idx(idx3, size2, size3);\n\n                if (size1 <= size2 and size1 <= size3)\n                    update(size1, &out);\n\n                if ((size2 > size3) != was_larger)\n                    break;\n            }\n            \n            progress_idx(idx2, size1, size2);\n        }\n\n        progress_idx(idx1, size3, size1);\n        while (size1 > max_size)\n            regress_idx(idx2, size1, size2);\n    }\n    \n    std::cerr << \"out = \" << out << std::endl;\n    std::cout << out << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RND(x,y) for(int x=-2;x<=2;x++)for(int y=-2;y<=2;y++)\nint n;\nint a[114514];\nint s[114514];\n\nint b(int x){\n  return distance(s,lower_bound(s,s+n,x));\n}\n\nint mod(int x,int y){\n  return (x%y+y)%y;\n}\n\nsigned main(){\n  cin>>n;\n  REP(i,n){\n    cin>>a[i];\n    s[i+1]=a[i]+s[i];\n  }\n  int ans=0;\n  int S=s[n];\n  REP(i,n){\n    int p=b((S/3+s[i])%S);\n    int q=b((S*2/3+s[i])%S);\n    RND(x,y){\n      int px=(p+x)%n;\n      int qy=(q+y)%n;\n      int w1=mod(s[px]-s[i],S);\n      int w2=mod(s[qy]-s[px],S);\n      int w3=mod(s[i]-s[qy],S);\n      if(w1+w2+w3!=S)continue;\n      #ifdef DEBUG\n      cout<<(i)<<\" \"<<(px)<<\" \"<<(qy)<<\":\";\n      cout<<w1<<\" \"<<w2<<\" \"<<w3<<endl;\n      #endif\n      int wm=min({w1,w2,w3});\n      ans=max(ans,wm);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> a(2 * n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    a[i] = a[i + n] = x;\n  }\n  for (int i = 1; i <= 2 * n; i++) {\n    a[i] += a[i - 1];\n  }\n  auto ck = [&] (int k) -> bool {\n    for (int l = 0; l <= n; l++) {\n      auto it = lower_bound(a.begin(), a.end(), a[l] + k); if (it == a.end()) continue;\n      auto jt = lower_bound(a.begin(), a.end(), *it + k); if (jt == a.end()) continue;\n      auto kt = lower_bound(a.begin(), a.end(), *jt + k); if (kt == a.end()) continue;\n      int r = kt - a.begin();\n      if (r - l <= n) return true;\n    }\n    return false;\n  };\n  constexpr int inf = 1 << 30;\n  int ok = 0, ng = inf, md;\n  while (ng - ok > 1) {\n    md = (ok + ng) >> 1;\n    if (ck(md)) ok = md;\n    else ng = md;\n  }\n  cout << ok << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long > rui;\nint n;\nlong long int ans=0;\n\nint check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(rui.begin()+i,rui.begin()+i+n-1,m+rui[i]);\n\tif(*(rui.begin()+i+n)-*hoge<=m)return 1;\n\tvector<long long>::iterator hage=lower_bound(hoge,rui.begin()+i+n-1,*hoge+m);\n\tif(*(rui.begin()+i+n)-*hage>=m)return 0;\n\treturn 1;\n}\n\n\nint main ()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\trui.push_back(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[i]);\n\t}\n\tfor(int i=1;i<rui.size();i++)\n\t{\n\t\trui[i]+=rui[i-1];\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long l=0,r=5000000000000;\n\t\twhile(r!=l)\n\t\t{\n\t\t\tlong long m=(r+l)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=m+1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans-1<<endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n \n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n \nbool ok(int first, long long len, const vector<long long> &a) {\n\tconst int second = lower_bound(a.begin() + first, a.end(), a[first] + len) - a.begin();\n\tconst int third  = lower_bound(a.begin() + second, a.end(), a[second] + len) - a.begin();\n\treturn third < a.size() && len <= a[first] + a.back() - a[third];\n}\n \nbool check(long long len, const vector<long long> &a) {\n\trep(i, a.size()) {\n\t\tif(ok(i, len, a)) return true;\n\t}\n\treturn false;\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tconstexpr long long MAX_A = 1000000000;\n \n\tint n;\n\tcin >> n;\n \n\tvector<long long> a(n + 1, 0);\n\tREP(i, 1, n + 1) {\n\t\tcin >> a[i];\n\t}\n \n\tpartial_sum(ALL(a), a.begin());\n \n\tlong long L = 0, R = n * MAX_A;\n\twhile(L + 1 < R) {\n\t\tconst long long M = (L + R) / 2;\n\t\tif(check(M, a)) {\n\t\t\tL = M;\n\t\t}\n\t\telse {\n\t\t\tR = M;\n\t\t}\n\t}\n\n\tcout << L << endl;\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll sum[200001];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<ll> baumkuchen;\n\n    memset(sum,0x01,sizeof(sum));\n    sum[0] = 0;\n    for(int i=0;i<N;i++){\n      ll width;\n      scanf(\"%lld\",&width);\n      baumkuchen.push_back(width);\n      sum[i+1] = sum[i] + width;\n    }\n    \n    for(int i=0;i<N;i++){\n      sum[N + i + 1] = sum[N] + sum[i + 1];\n    }\n\n    ll lhs = 0;\n    ll rhs = 100000000000000LL;\n    for(int round = 0; round < 50; round++){\n      ll mid = lhs + (rhs - lhs) / 2LL;\n\n      bool isok = false;\n\n      for(int i=0;i<N;i++){\n        ll offset = sum[i];\n        int div_idx = lower_bound(sum,sum + 200001,offset + mid) - sum;\n        div_idx = lower_bound(sum,sum + 200001,sum[div_idx] + mid) - sum;\n        div_idx = lower_bound(sum,sum + 200001,sum[div_idx] + mid) - sum;\n        if(div_idx <= i + N){\n          isok = true;\n          break;\n        }\n      }\n      if(isok){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n    printf(\"%lld\\n\",lhs);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long > rui;\nint n;\nlong long int ans=0;\n\nint check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(rui.begin()+i,rui.begin()+i+n-1,m+rui[i]);\n\tif(*(rui.begin()+i+n)-*hoge<=m)return 1;\n\tvector<long long>::iterator hage=lower_bound(hoge,rui.begin()+i+n-1,*hoge+m+1);\n\tif(*(rui.begin()+i+n)-*hage>m)return 0;\n\treturn 1;\n}\n\n\nint main ()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\trui.push_back(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[i]);\n\t}\n\tfor(int i=1;i<rui.size();i++)\n\t{\n\t\trui[i]+=rui[i-1];\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long l=0,r=5000000000000;\n\t\twhile(l!=r)\n\t\t{\n\t\t\tlong long m=(r+l)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=m+1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans<<endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef complex<double> dcomplex;\ninline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}\n\n//ラジアンを度に変換-----------------------------------------------------\ndouble rad_deg(double rad){\n\tif(rad >= 0)return rad*180.0/acos(-1);\n\telse return (2*acos(-1)+rad)*180/acos(-1);\n}\n\nint main(void){\n\tdouble pi = acos(-1);\n\t//入力--------------------------------------------------------------\n\tint N;\n\tcin >> N;\n\tint data[N];\n\tlong int sum = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\t//極座標の保持\n\tdcomplex pol[N];\n\tdouble sum_t = 0;\n\tfor(int i=0; i<N; i++){\n\t\tpol[i] = polar(1.0,2.0*pi*sum_t/sum);\n\t\tsum_t += data[i];\n\t}\n\t//適当なmin_argを与える----------------------------------------------\n\tdouble min_arg = 0;\n\tdcomplex p = pol[0];\n\tdcomplex q,r;\n\tdouble theta1 = 0,theta2,theta3;\n\tdouble a,b,d;\n\tint tmp;\n\tfor(int i=1;i<N;i++){\n\t\tq = pol[i];\n\t\tif (rad_deg(arg(q)) >= 120){\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\ttmp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int k=tmp; k<N; k++){\n\t\tr = pol[k];\n\t\ttheta3 = rad_deg(arg(r));\n\t\tb = theta3 - theta2;\n\t\td = 360-a-b;\n\t\t//高速化?\n\t\t//3つ目の条件いらないかも\n\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\tif(d < b) break;\n\t}\n\tcout << min_arg << endl;\n\t\n\t//初期位置の保存-----------------------------------------------------\n\tint judge1 = 0;\n\tint judge2 = 0;\n\tint tmp1,tmp2;\n\tp = pol[1];\n\ttheta1 = 0;\n\tfor (int j=1; j<N-1; j++){\n\t\tif(judge1 == 0){\n\t\t\tq = pol[j];\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\tif(a >= min_arg){\n\t\t\t\ttmp1 = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k = tmp+1; k<N; k++){\n\t\tif(judge2 == 0){\n\t\t\tr = pol[k];\n\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\tb = theta3 - theta2;\n\t\t\tif(b >= min_arg){\n\t\t\t\ttmp2 = k;\n\t\t\t\td = 360-a-b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << a << \",\" << b << \",\" << d << endl;\n\tcout << tmp1 << \",\" << tmp2 << endl;\n\t\n\t//ループ処理--------------------------------------------------------\n\tint judge = 0;\n\t//pをiに固定\n\tfor(int i=0; i<N-2; i++){ \n\t\tp = pol[i];\n\t\ttheta1 = rad_deg(arg(p));\n\t\t//tmp1の更新\n\t\tif(i > 1){\n\t\t\twhile(theta2 - theta1 < min_arg && tmp1 <= N-2){\n\t\t\t\ttmp1 += 1;\n\t\t\t\tq = pol[tmp1];\n\t\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\t\tjudge = 1;\n\t\t\t}\n\t\t}\n\t\t//高速化?\n\t\tif(360-theta1 < min_arg){\n\t\t\tbreak;\n\t\t}\n\t\tcout << i << endl;\n\t\tfor (int j = tmp1; j<N-1; j++){\n\t\t\tq = pol[j];\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\t//tmp1の更新\n\t\t\tif(judge == 1){\n\t\t\t\twhile(theta3 - theta2 < min_arg && tmp2 <= N-1){\n\t\t\t\t\ttmp2 += 1;\n\t\t\t\t\tr = pol[tmp2];\n\t\t\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//高速化?\n\t\t\tif(360-theta2 < min_arg){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int k=tmp2; k<N; k++){\n\t\t\t\tr = pol[k];\n\t\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\t\tb = theta3 - theta2;\n\t\t\t\td = 360-a-b;\n\t\t\t\t//高速化?\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t\t//cout << a << \",\" << b << \",\" << d << endl;\n\t\t\t\tif(d < b || (a < theta1 && a < b)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//------------------------------------------------------------------\n\t\t\t\n\tcout << min_arg << endl;\n\tcout << (long int)(round((min_arg/360.0)*sum)) << endl;;\n\t\n\t\nreturn 0;\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<int>a,b,c;\n  int x,y,z;\n  while(1){\n    cin >> x >> y >> z;\n    if(x==0&&y==0&&z==0)break;\n    a.push_back(x-1);\n    b.push_back(y-1);\n    c.push_back(z);\n  }\n  int l;\n  cin >> l;\n  vector<int>d(m);\n  for(int i=0;i<l;i++){\n    vector<int>co(n,0);\n    for(int j=0;j<m;j++){\n      int bu;\n      cin >> bu;\n      d[j]=bu;\n    }\n    for(int j=0;j<a.size();j++){\n      co[a[j]]+=d[b[j]]*c[j];\n    }\n    for(int j=0;j<n;j++){\n      cout << co[j] ;\n      if(j+1!=n){\n\tcout << ' ';\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[100010];\n\nvoid a(string s){}\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n    if (idx >= i + N) return false;\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n    if (idx2 >= i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 100010, 1e16);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e15;\n\n        rep(_, 60) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  \n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m]-A[b-1])r=m;\n    else l=m+1;\n  }\n  \n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    cut3--;\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n    cut2--;\n    \n    cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n    cut3--;\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000];\n\nlong long sum(int l, int r)\n{\n\tlong long ret = 0;\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tret += a[i % n];\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tret = max(ret, min( { sum(i, j), sum(j, k), sum(k, n + i) } ));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n\nint main(){\n\tll n,a[100000],maxx = 0,maxi = 0;\n\tvector<ll> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tmaxx = max(maxx,a[i]);\n\t\tif (maxx == a[i]) {\n\t\t\tmaxi = i;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i-1] + x[i-1];\n\t\t}\n\t}\n\tx[n] = x[n-1] + a[n-1];\n\tll length = x[n] / 3;\n\tif (maxx > length) {\n\t\tlength = (x[n] - maxx)/2;\n\t\tll i = maxi+1;\n\t\tll llll = x[n] - maxx;\n\t\tll mama = 0;\n\t\twhile (1) {\n\t\t\tif (i > maxi) {\n\t\t\t\tif((x[i] - x[maxi+1]) >= length) {\n\t\t\t\t\tmama = min(x[i]-x[maxi+1],x[maxi]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(x[n]-x[maxi+1]+x[i] >= length) {\n\t\t\t\t\tmama = min(x[n]-x[maxi+1]+x[i],x[maxi]-x[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = (i+1) % (n+1);\n\t\t}\n\t\tcout << mama << endl;\n\t\treturn 0;\n\t} \n\n\tll mi = 0;\n\tll ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tll tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tll p1 = 0, p2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j;\n\t\t\t\t\ttmp = (x[n] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp = x[i] + length;\n\t\tll q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (q1 == 0) {\n\t\t\t\t\tq1 = j-1;\n\t\t\t\t\ttmp = (x[n] - x[q1] + x[i])/2 + x[q1];\t\n\t\t\t\t} else {\n\t\t\t\t\tq2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2-1] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2-1] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    int N;\n    cin >> N;\n    vector<LL> place;\n    for(int i=0; i<N; i++){\n        int tmp;\n        cin >> tmp;\n        if(i!= 0) place.push_back(place[i-1] + tmp);\n        else place.push_back(tmp);\n    }\n    for(int i=0; i<N; i++){\n        place.push_back(place[N-1] + place[i]);\n    }\n\n    LL ans = 0;\n    for(int i=0; i<N; i++){\n        LL riso = place[i] + place[N-1]/3;\n        auto itr1b = lower_bound(place.begin(), place.end(), riso);\n        auto itr1a = itr1b; itr1a--;\n\n        riso = place[i] + place[N-1]*2/3;\n        auto itr2b = lower_bound(place.begin(), place.end(), riso);\n        auto itr2a = itr2b; itr2a--;\n\n        ans = max(ans, min(min(*itr2a-*itr1a,*itr1a-place[i]),place[i]-*itr2a+place[N-1]));\n        ans = max(ans, min(min(*itr2a-*itr1b,*itr1b-place[i]),place[i]-*itr2a+place[N-1]));\n        ans = max(ans, min(min(*itr2b-*itr1a,*itr1a-place[i]),place[i]-*itr2b+place[N-1]));\n        ans = max(ans, min(min(*itr2b-*itr1b,*itr1b-place[i]),place[i]-*itr2b+place[N-1]));\n    }\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint i = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[i] <= one_third){\n\t\tpiece1 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t}\n\t\n\tint piece2_begin = i;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_begin = i;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_begin];\n\t\t\tpiece2_begin++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_begin] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_begin];\n\t\t\tpiece2 -= (long long int)A[piece2_begin];\n\t\t\tpiece2_begin++;\n\t\t\tif (piece2_begin == N) piece2_begin -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_begin];\n\t\t\tpiece3_begin++;\n\t\t\tif (piece3_begin == N) piece3_begin -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VL a(n);\n    REP(i,n) scanf(\"%lld\", &a[i]);\n    REP(i,n){\n        a.push_back(a[i]);\n    }\n    ll l = 1, r = 1e16;\n    while (r - l > 1){\n        ll m = (l + r) / 2;\n        bool pos = 0;\n        REP(i,n){\n            int x = i, p = 0;\n            ll t = 0;\n            while (x < i + n){\n                t += a[x];\n                x++;\n                if (t >= m){\n                    t = 0;\n                    p++;\n                }\n                if (p == 3){\n                    pos = 1;\n                    break;\n                }\n            }\n        }\n        if (pos) l = m;\n        else r = m;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nvoid CalcPiece1(int *_i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i2 < _i1 + _N - 2;){\n\t\t*_piece1_s = *_piece1_l;\n\t\t*_piece1_l += _A[*_i2%_N];\n\t\t(*_i2)++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n}\n\nvoid CalcPiece3(int *_i3, ull *_piece3_s, ull *_piece3_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i3 < _i1 + _N - 1;){\n\t\t*_piece3_l = *_piece3_s;\n\t\t*_piece3_s -= _A[*_i3%_N];\n\t\t(*_i3)++;\n\t\tif (*_piece3_s <= _one_third_size) break;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tint *A = new int[N];\n\tull total_size = 0;\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tint i3 = i1_ini + 1;\n\t\t/*CalcPiece1(&i3, &piece2, &tmp, i1_ini + 1, N, half_size, A);\n\t\tull piece3 = total_size - A_max - tmp;*/\n\t\tull piece3 = total_size - A_max;\n\t\tCalcPiece3(&i3, &piece3, &tmp, i1_ini, N, half_size, A);\n\t\tpiece2 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\tconst int i1_fin = i2;\n\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tCalcPiece3(&i3, &piece3_s, &piece3_l, i1_ini, N, one_third_size, A);\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse CalcPiece1(&i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse CalcPiece3(&i3, &piece3_s, &piece3_l, i1, N, one_third_size, A);\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tint total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\n\tint minimum_piece = 0;\n\tfor(int i1=0; i1<N-2; i1++){\n\t\tfor(int i2=i1+1; i2<N-1; i2++){\n\t\t\tfor(int i3=i2+1; i3<N; i3++){\n\t\t\t\tint piece1 = 0, piece2 = 0, piece3 = 0;\n\t\t\t\tfor(int i=i1; i<i2; i++) piece1 += A[i];\n\t\t\t\tfor(int i=i2; i<i3; i++) piece2 += A[i];\n\t\t\t\tpiece3 = total_size - piece1 - piece2;\n\t\t\t\t\n\t\t\t\tint tmp = piece1;\n\t\t\t\tif(tmp > piece2) tmp = piece2;\n\t\t\t\tif(tmp > piece3) tmp = piece3;\n\n\t\t\t\tif(minimum_piece < tmp) minimum_piece = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << minimum_piece << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>num(N * 2 + 1);\n\tvector<long long int>sum(N * 2 + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> num[i];\n\t\tM += num[i];\n\t\tnum[i + N] = num[i];\n\t}\n\tsum[0] = num[0];\n\tfor (int i = 0; i < N * 2; i++) {\n\t\tsum[i] = sum[i - 1] + num[i];\n\t}\n\tsum[N * 2] = sum[N * 2 - 1] + num[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tL = i;\n\t\tR = i + N - 2;\n\t\tlong long int mid;\n\t\twhile (R - L > 1) {\n\t\t\tmid = (R + L + 1) / 2;\n\t\t\tif (sum[mid] - sum[i - 1] <= M / 3) {\n\t\t\t\tL = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = mid;\n\t\t\t}\n\t\t}\n\t\tmid = L;\n\t\tL = mid + 1;\n\t\tR = i + N - 1;\n\t\tlong long int med;\n\t\twhile (R - L > 1) {\n\t\t\tmed = (R + L + 1) / 2;\n\t\t\tif (sum[med] - sum[mid] <= (M - (sum[mid] - sum[i - 1])) / 2) {\n\t\t\t\tL = med;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = med;\n\t\t\t}\n\t\t}\n\t\t//cout << sum[mid] - sum[i - 1] << \" \" << sum[L] - sum[mid] << \" \" << sum[i + N - 1] - sum[L + 1] << endl;\n\t\tK = max({ K,min(sum[mid] - sum[i - 1],sum[L] - sum[mid]),min(sum[i + N - 1] - sum[L + 1],sum[mid] - sum[i - 1]) });\n\t\t//cout << K << \" \" << mid << \" \" << L << endl;\n\t}\n\tcout << K << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[200005];\n\nbool check(int x,ll key){\n  ll* p=&a[x];\n  ll* ed=&a[x+n+1];\n  \n  for(int i=0;i<3;i++){\n    ll target=*p;\n    p=lower_bound(p,ed,target+key);\n    if(p==ed)return false;\n  }  \n  return true;\n}\n\nll solve(int x){\n  ll L=1,R=1e9,M;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(x,M))L=M+1;\n    else R=M;\n  }\n  return L-1;\n}\n\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++)cin>>a[i];\n  for(int i=n+1;i<=n+n;i++)a[i]=a[i-n];\n\n  for(int i=1;i<=n+n;i++)a[i]+=a[i-1];\n  \n  ll ans=0;\n  for(int i=0;i<n;i++)ans=max(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n   int a,b,c,d,e,f,g;\n   scanf(\"%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g);\n   printf(\"6\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint a[200000];\nsigned main() {\n\tint b;\n\tcin >> b;\n\tint c = 0;\n\tfor (int d = 0; d < b ; d++) {\n\t\tint e; scanf(\"%lld\", &e);\n\t\tc += e;\n\t\ta[d + 1] = c;\n\t}\n\tfor (int d = 1; d < b; d++) {\n\t\ta[b + d] = a[d] + c;\n\t}\n\tint MIN = LLONG_MAX / 3;\n\tint k = 0;\n\tfor (int d = 0; d < b; d++) {\n\t\tint e = d + 1, f = d + b - 1;\n\t\twhile (f - e >= 1) {\n\t\t\tint g = (e + f) / 2;\n\t\t\tauto h = lower_bound(a + d, a + d + b, a[d]+2*(a[g] - a[d]));\n\t\t\tif (h == a + d + b || a[d + b] - *h < a[g] - a[d]) {\n\t\t\t\tf = g;\n\t\t\t}\n\t\t\telse { e = g + 1; k = max(k, a[g] - a[d]);  }\n\t\t}\n\t}\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 100000\n\n#define D(x,y) (pos[(x)]-pos[(y)])\n\nlong long A[NMAX];\nlong long pos[NMAX*2];\nint N;\nlong long L;\n\nlong long solve() {\n    long long ret = 1;\n    int p0 = 0, p1 = 0, p2 = 0;\n    long d0 = 0, d1 = 0;\n    while (p0 < N) {\n        if (p1 <= p0) p1 = p0 + 1;\n        while (p1 - p0 < N && D(p1, p0) <= ret) p1++;\n        if (D(p1, p0) <= ret) goto L1;\n\n        if (p2 <= p1) p2 = p1 + 1;\n        while (p2 - p0 < N && D(p2,p1) < D(p1, p0)) p2++;\n        if (D(p2, p1) < D(p1, p0)) goto L1;\n\n        if (L - D(p2, p0) >= D(p1, p0)) {\n            ret = D(p1, p0);\n            if (ret >= L/3) return ret;\n            continue;\n        }\nL1:\n        p0 += 1;\n        while (p2 > p1 && D(p2, p1) > D(p1, p0)) p2--;\n    }\n    return ret;\n}\n\nint main(void) {\n    int i;\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n        L += A[i];\n    }\n    for (i = 0; i < 2*N; i++) {\n        pos[i] = pos[i-1] + A[(i-1)%N];\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef complex<double> dcomplex;\ninline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}\n\n//ラジアンを度に変換-----------------------------------------------------\ndouble rad_deg(double rad){\n\tif(rad >= 0)return rad*180.0/acos(-1);\n\telse return (2*acos(-1)+rad)*180/acos(-1);\n}\n\nint main(void){\n\tdouble pi = acos(-1);\n\t//入力--------------------------------------------------------------\n\tint N;\n\tcin >> N;\n\tint data[N];\n\tlong int sum = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\t//極座標の保持\n\tdcomplex pol[N];\n\tdouble sum_t = 0;\n\tdouble sumlist[N+1];\n\tfor(int i=0; i<N; i++){\n\t\tpol[i] = polar(1.0,2.0*pi*sum_t/sum);\n\t\tsumlist[i] = rad_deg(arg(pol[i]));\n\t\tsum_t += data[i];\n\t}\n\tsumlist[N] = 360.0;\n\t//適当なmin_argを与える----------------------------------------------\n\tdouble min_arg = 0;\n\tdcomplex p = pol[0];\n\tdcomplex q,r;\n\tdouble theta1 = 0,theta2,theta3;\n\tdouble a,b,d;\n\tint tmp;\n\tfor(int i=1;i<N;i++){\n\t\tq = pol[i];\n\t\tif (rad_deg(arg(q)) >= 120){\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\ttmp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int k=tmp; k<N; k++){\n\t\tr = pol[k];\n\t\ttheta3 = rad_deg(arg(r));\n\t\tb = theta3 - theta2;\n\t\td = 360-a-b;\n\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\tif(d < b) break;\n\t}\n\t\n\t//ループ処理--------------------------------------------------------------\n\tint tmp0 = 0;\n\tint tmp1 = 1;\n\tint tmp2 = 2;\n\ta = sumlist[tmp1] -sumlist[tmp0];\n\tb = sumlist[tmp2] - sumlist[tmp1];\n\td = 360.0 - sumlist[tmp2] +sumlist[tmp0];\n\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\n\twhile(tmp0 < round(N/2.0) && tmp2 < N && tmp1 < tmp2){\n\t\ttmp1 = tmp0 + 1;\n\t\ttmp2 = tmp1 + 1;\n\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\twhile(d >= min_arg && tmp2 < N-1){\n\t\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg){\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse if(sumlist[tmp1] - sumlist[tmp0] < min_arg){\n\t\t\t\ttmp1 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t}\n\t\ttmp0 += 1;\n\t}\n\n\tcout << (long int)(round((min_arg/360.0)*sum)) << endl;;\n\t\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nstruct BIT {\n\tvector<int> v;\n\tint n;\n\tBIT(int N) { n = N + 1; v.resize(n); }\n\tint sum(int idx) {\n\t\tint ret = 0;\n\t\tfor (int i = idx + 1; i > 0; i -= i & -i) ret += v[i];\n\t\treturn ret;\n\t}\n\tint sum(int from, int to) {\n\t\treturn sum(to) - sum(from - 1);\n\t}\n\tvoid add(int idx, int num) {\n\t\tfor (int i = idx + 1; i < n; i += i & -i) v[i] += num;\n\t}\n};\n\nsigned main() {\n\tint n; cin >> n;\n\tvector<int> as(n);\n\tBIT bit(n + n);\n\trep (i, n) {\n\t\tint x;  scanf(\"%d\", &x);\n\t\tbit.add(i, x);\n\t\tbit.add(i + n, x);\n\t}\n\tint len = bit.sum(n - 1);\n\tint left = 0, right = 0;\n\tint ans = 0;\n\twhile (left < n) {\n\t\tif (right < left) right = left;\n\t\tint s = bit.sum(left, right);\n\t\tint end = left + n;\n\t\tint rem = len - s;\n\t\tint b = right + 1, e = end;\n\t\twhile (b + 1 < e) {\n\t\t\tint mid = (b + e) / 2;\n\t\t\tint x = bit.sum(right + 1, mid);\n\t\t\tif (x < s) b = mid;\n\t\t\telse e = mid;\n\t\t}\n\t\tif (bit.sum(right + 1, right + 1) > s) b = right;\n\t\tint r1 = bit.sum(right + 1, b + 1);\n\t\tint r2 = rem - r1;\n\t\tif (s <= r1 && s <= r2) {\n\t\t\tmaxup(ans, s);\n\t\t\tright++;\n\t\t}\n\t\telse {\n\t\t\tleft++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\nusing namespace std;\n\n#define debug 0\n\nint InArray[200000] = {0};\nint N = 0;\n\nlong long sumArray(int, int);\nlong long getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tint temp;\n#if debug\n\tFILE *inputFile = fopen(\"0600_in8.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\t//cout << \"N: \" << N << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tfscanf(inputFile, \"%d\", &temp);\n\t\tcout << temp << endl;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\tcout << endl;\n\tfclose( inputFile);\n#else\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n#endif\n\t\n\t// Calculate sum and average\n\tlong long sum = sumArray(0, N);\n\tlong long average = sum / 3;\n\n#if debug\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n#endif\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum, a3_sum;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1 + 1; a2 < N + 1; a2++){\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tlong average2 = (sum - (a1_sum - InArray[a2])) / 2;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2 + 1; a3 < a1 + N; a3++){\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3 - 1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong long sumArray(int start, int end)\n{\n\tlong long sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n//\t\tcout << \"i:\" << i << \"sum:\" << sum << endl;\n\t}\n//\tcout << sum << endl;\n//\tsystem(\"pause\");\n\treturn sum;\n}\n\nlong long getLocalMin(int p1, int p2, int p3)\n{\n\tlong long LocalMin = sumArray(p1, p2);\n\tlong long tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(p3, p1 + N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n#if debug\n//cout << \"getLocalMin(\" << p1 << \", \" << p2 << \", \" << p3 << \") = \" << LocalMin << endl;\n#endif\n\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint ini = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[ini] <= one_third){\n\t\tpiece1 += (long long int)A[ini];\n\t\tini++;\n\t}\n\t\n\tint piece2_i = ini;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[ini];\n\t\tini++;\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = ini;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst ll MAX_N = ll(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i,n) for (int i = n; i >=0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll n, a[MAX_N], cum[MAX_N]{}, ans = 0, ma, L;\n\nint main() {\n    \n    cin >> n;\n    REP(i,n) cin >> a[i];\n    REP(i,n*2){\n        cum[i+1] = cum[i] + a[i%n];\n    }\n    L = cum[n];\n    ma = cum[n]/3;\n    ll l = 0, r = 0;\n    while(l <= n){\n        while(n-r+l > 2 && cum[r] - cum[l] < ma){\n            r++;\n        }\n        ll s = cum[r] - cum[l];\n        ll k = lower_bound(cum+r,cum+n+l,(L-s)/2+cum[r]) - cum;\n        for(int i = 0; i < 1; i++){\n            ll tmp = LLINF;\n            tmp = min(tmp, s);\n            tmp = min(tmp, cum[k+i]-cum[r]);\n            tmp = min(tmp, cum[n+l]-cum[k+i]);\n            ans = max(ans, tmp);\n        }\n        l++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,c2=0,c3=0,s=0,s1=0,s2=0,m=0;\n\tint a[100000];\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> a[i];\n\t\ts+=a[i];\n\t}\n\tfor(int c1=0;c1<n;c1++){\n\t\twhile(s1<s/3){\n\t\t\ts1+=a[c2%n];\n\t\t\ts2-=a[c2%n];\n\t\t\tc2++;\n\t\t}\n\t\tif(c3<=c2){\n\t\t\tc3=c2+1;\n\t\t\ts2=a[c2%n];\n\t\t}\n\t\twhile(s2<(s-s1)/2){\n\t\t\ts2+=a[c3%n];\n\t\t\tc3++;\n\t\t}\n\t\tif(m<s-s1-s2){\n\t\t\tm=s-s1-s2;\n\t\t}\n\t\tc3--;\n\t\ts2-=a[c3%n];\n\t\tif(m<s2){\n\t\t\tm=s2;\n\t\t}\n\t\ts1-=a[c1%n];\n\t}\n\tcout << m;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 60u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\nclass Circle {\npublic:\n    unsigned int n;\n    vector<long long> circle;\n    vector<long long> dp;\n    long long total = 0;\n\npublic:\n    Circle(vector<long long> circle) : n(circle.size()), circle(circle) {\n        this->dp.resize(n * 2 + 1, 0);\n        for (int i = 0; i < n * 2; ++i) {\n            this->dp[i + 1] = this->dp[i] + circle[i % n];\n            this->total += circle[i % n];\n        }\n        this->total /= 2;\n    }\n\n    long long get(int i) const {\n        return circle[i % this->n];\n    }\n\n    // [i, j)の和\n    long long distance(int i, int j) const {\n        if (i > j) {\n            j += this->n;\n        }\n\n        i %= 2 * this->n;\n        j %= 2 * this->n;\n\n        return this->dp[j] - this->dp[i];\n    }\n};\n\nbool can_make(int l, int r, const int N, const LL total, const LL x, const Circle &circle) {\n    assert(l <= r);\n\n    // x以上の最小の数\n    int low = r, high = N + l;\n    LL ans = -1;\n    while (high - low > 1) {\n        int middle = (low + high) / 2;\n        LL sum = circle.distance(r + 1, middle);\n        if (sum >= x) {\n            high = middle;\n            ans = sum;\n        }\n        else {\n            low = middle;\n        }\n    }\n\n    return (ans >= x and (total - ans) >= x);\n}\n\nbool ok(const LL x, int N, const Circle &circle) {\n\n    // しゃくとり[l, r]\n    LL len = 0;\n    int l = 0;\n    for (int r = 0; l < N and abs(l - r) < N; ++r) {\n//        cout << l << \":\" << r << \"(\" << len << \")\" << endl;\n        // rの分をいれる\n        len += circle.get(r);\n\n        while (l < N and len - circle.get(l) >= x) {\n            // lの分を消す\n            len -= circle.get(l);\n            ++l;\n        }\n\n        if (len >= x) {\n            if (can_make(l, r, N, circle.total - len, x, circle)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL N;\n    cin >> N;\n\n    auto A = make_v<LL>(N);\n    FOR(i, 0, N) {\n        cin >> A[i];\n    }\n    Circle circle(A);\n\n    long long low = -1, high = circle.total + 1;\n    // (low, high)\n    while (high - low > 1) {\n        long long middle = (low + high) / 2;\n        if (ok(middle, N, circle)) {\n            low = middle;\n        }\n        else {\n            high = middle;\n        }\n    }\n\n    print(low);\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=1e5+10;\nlong long int a[N],n;\nbool check(long long int val){\n    long long int now=0,cnt=0;\n    for(int i=0;i<n;i++){\n        now+=a[i];\n        if(now>=val){\n            now=0;\n            cnt++;\n            if(cnt>=3)return true;\n        }\n    }\n    return false;\n}\nint main(){\n    long long int ans=0,l=0,r=0,mid;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n        r+=a[i];\n    }\n    while(r-l>1){\n        mid=(r+l)/2;\n        if(check(mid))r=mid;\n        else l=mid;\n    }\n    \n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tauto eval = [&](int k)\n\t\t{\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\treturn min({ a, b, c });\n\t\t};\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint x0 = right, x3 = n;\n\t\t\twhile (x3 != x0)\n\t\t\t{\n\t\t\t\tint x1 = x0 + (x3 - x0) / 3;\n\t\t\t\tint e1 = eval(x1);\n\t\t\t\tint x2 = x1 + (x3 - x0) / 3;\n\t\t\t\tint e2 = eval(x2);\n\t\t\t\tif (x1 < x2) x0 = x1;\n\t\t\t\telse x3 = x2;\n\t\t\t}\n\t\t\ttmin = eval(x0);\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1 << 30;\nvector<int> baum;\nint n, ans, minma = INF;\nint Baum = 0, Baum3 = 0;\n\nvoid cut(int f) {\n\tint s = f + Baum3, t = s + Baum3;\n\tint p;\n\tint sp[3] = {}, tp[3] = {};\n\tp = lower_bound(baum.begin(), baum.end(), s) - baum.begin();\n\tif (s == baum[p]) {\n\t\tsp[0] = baum[p + 1];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = baum[p];\n\t}\n\telse {\n\t\tsp[0] = baum[p];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = INF;\n\t}\n\tp = lower_bound(baum.begin(), baum.end(), t) - baum.begin();\n\tif (t == baum[p]) {\n\t\ttp[0] = baum[p + 1];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = baum[p];\n\t}\n\telse {\n\t\ttp[0] = baum[p];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = INF;\n\t}\n\tfor (int i = 0; i <= 2; i++) {\n\t\tif (sp[i] == INF) break;\n\t\tminma = sp[i] - f;\n\t\tfor (int j = 0; j <= 2;j ++){\n\t\t\tif (tp[j] == INF) break;\n\t\t\tminma = min( minma, min( tp[j] - sp[i], Baum - tp[j] + f ));\n\t\t\tans = max(ans, minma);\n\t\t\tminma = sp[i]-f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tbaum.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint in;\n\t\tcin >> in;\n\t\tBaum += in;\n\t\tbaum.push_back(in);\n\t}\n\tbaum.push_back(baum[1]);\n\tBaum3 = Baum / 3;\n\n\tfor (int i = 2; i <= n+1; i++) {\n\t\tbaum[i] += baum[i - 1];\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tif (baum[i] > Baum3) break;\n\t\tcut(baum[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\ntypedef int baumkuchen_size_t;\ntypedef int index_t;\n\nstd::vector<baumkuchen_size_t> pieces;\nbaumkuchen_size_t whole_size; // SUM OF SIZE OF PIECES\nbaumkuchen_size_t max_size;   // MAX SIZE OF THE SMALLEST PIECE\n\n\ninline void reguralize(index_t *x)\n{\n    if ((*x) < 0)\n        (*x) += pieces.size();\n    (*x) %= pieces.size();\n}\n\n\ninline void progress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev += pieces.at(idx);\n    size_curr -= pieces.at(idx);\n    ++idx;\n    reguralize(&idx);\n}\n\n\ninline void regress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    --idx;\n    reguralize(&idx);\n    size_prev -= pieces.at(idx);\n    size_curr += pieces.at(idx);\n}\n\n\ninline void update(int input, int *target)\n{\n    if (input > (*target))\n        (*target) = input;\n}\n\n\nint main()\n{\n    // READ INPUTS\n    {\n        int num;\n        std::cin >> num;\n        pieces.assign(num, 0);\n\n        for (int i = 0; i < num; ++i)\n        {\n            std::cin >> pieces[i];\n            whole_size += pieces.at(i);\n        }\n        max_size = whole_size / 3;\n    }\n    \n    index_t idx1(0), idx2(1), idx3(2); // BEGIN INDEX OF EACH BAUMKUCHEN PIECE\n    baumkuchen_size_t\n        size1(pieces.at(idx1)),            // SIZE OF 1ST BAUMKUCHEN PIECE\n        size2(pieces.at(idx2)),            // SIZE OF 2ND BAUMKUCHEN PIECE\n        size3(whole_size - size1 - size2); // SIZE OF 3RD BAUMKUCHEN PIECE\n    int out(0); // RETURN VALUE\n\n    /* PRESUME THAT THE FIRST PIECE IS SMALLEST. */\n    \n    for (int i = 0; i < pieces.size(); ++i)\n    {        \n        while (size1 <= max_size)\n        {\n            // CHECK WHETHER size1 CAN BE SMALLEST\n            \n            if (size1 <= size2 and size1 <= size3)\n                update(size1, &out);\n\n            while (size1 > size2 or size1 > size3)\n            {\n                // NOTE: size2 & size3 CANNOT BE EQUAL HERE.\n                \n                bool was_larger(size2 > size3);\n                assert(size2 != size3);\n\n                (size2 > size3) ?\n                    regress_idx(idx3, size2, size3) :\n                    progress_idx(idx3, size2, size3);\n\n                if (size1 <= size2 and size1 <= size3)\n                    update(size1, &out);\n\n                if ((size2 > size3) != was_larger)\n                    break;\n            }\n            \n            progress_idx(idx2, size1, size2);\n        }\n\n        progress_idx(idx1, size3, size1);\n        while (size1 > max_size)\n            regress_idx(idx2, size1, size2);\n    }\n    \n    std::cout << out << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i;\n}\n\nint CalcPiece3(int _i3, ull *_piece3, const ull _two_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _two_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3++;\n\t}\n\treturn _i3;\n}\n\nint main(){\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\t\ti1--;\n\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\tint i2 = i1;\n\t\tull piece2 = 0;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\n\t\tint i3 = i - 1;\n\t\tull piece3 = 0;\n\t\ti3 = CalcPiece3(i3, &piece3, two_third_size, A, N);\n\n\t\tif (piece1 < piece2 && piece1 < piece3){\n\t\t\tif (piece1 > answer) answer = piece1;\n\t\t}\n\t\telse if (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\tpiece1 += A[i1 % N];\n\t\ttwo_third_size = (total_size - piece1) / 2;\n\t\ti2 = i1 + 1;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\n\t\ti3 = i - 1;\n\t\ti3 = CalcPiece3(i3, &piece3, two_third_size, A, N);\n\t\tpiece2 = total_size - piece1 - piece3;\n\t\tif (piece2 < piece3){\n\t\t\tif (piece2 > answer) answer = piece2;\n\t\t}\n\t\telse{\n\t\t\tif (piece3 > answer) answer = piece3;\n\t\t}\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100000);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  REP(i, n) scanf(\"%lld\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  REP(i, 100){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nint n;\nint a[200001];\nint sum[200001];\n\nbool bin_check(int x) {\n\n    int p1 = 0, p2 = 0;\n    int sum1 = 0, sum2 = 0;\n\n    // Shakutori\n    for(int i = 0; i < n; ++i) {\n\n        // 1\n        while(sum1 < x) {\n            sum1 += a[p1];\n            if(p1 < p2) sum2 -= a[p1];\n            ++p1;\n        }\n\n        // 2\n        if(!i) p2 = p1;\n        while(sum2 < x) {\n            sum2 += a[p2];\n            ++p2;\n        }\n\n        // 3\n        if(sum[n + i] - sum[p2] >= x) {\n            return true;\n        }\n\n        sum1 -= a[i];\n    }\n\n    return false;\n\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        a[n + i] = a[i];\n    }\n\n    sum[0] = 0;\n    for(int i = 1; i <= 2 * n; ++i) {\n        sum[i] = sum[i - 1] + a[i - 1];\n    }\n\n    int l = 0, m, r = sum[n] / 3;\n    while(l + 1 < r) {\n        m = (l + r) / 2;\n        if(bin_check(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n\n    cout << l << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nint N;\nll A[200001];\nll sum[200005];\nint nibun(int st,int ed,ll H,ll hiku){\nint ret=-1;\nwhile ( st <= ed ){\nint h = (st+ed)/2;\nll y = sum[h] - hiku;\nif( y > H ){\ned=h-1;\nret = h;\n} else if( y < H ){\nst=h+1;\n} else {\nret = h;\nbreak;\n}\n}\nreturn ret;\n}\n \nll check(int id){\nll ret=-1;\nll st = 0,ed = sum[N];\n// ll st = 213,ed = 213;\nwhile( st <= ed ){\nll h = (st+ed)/2;\nbool f=false;\nint r = nibun(id,id+N-3,h,sum[id-1]);\nif( r > -1 ){\nr = nibun(r+1,id+N-2,h,sum[r]);\nif( r > -1 ){\nif( sum[id+N-1] - sum[r] >= h ){\nf=true;\n}\n}\n}\nif( f ){\n// printf(\"ok %lld\\n\",h);\nst=h+1;\nret = h;\n} else {\n// printf(\"ng %lld\\n\",h);\ned=h-1;\n}\n}\nreturn ret;\n}\n \nint main(){\nscanf(\"%d\",&N);\nfor(int i=1;i<=N;i++){\nscanf(\"%lld\",&A[i]);\n}\nfor(int i=1;i<=N;i++){\nA[i+N] = A[i];\n}\nfor(int i=1;i<=2*N;i++){\nsum[i]=sum[i-1]+A[i];\n// printf(\"%lld\\n\",sum[i]);\n}\n \nll res = 0;\nfor(int i=1;i<=N;i++){\nll ret = check(i);\n// printf(\"%lld\\n\",ret);\nres = max(res,ret);\n}\nprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\nll n,a[200000],x[200000];\n\nll binsearch(ll start,ll d){\n    ll lb = -1,ub = n + 1;//[lb,ub)?????¢?´¢??????\n\n    while(ub - lb > 1){\n        ll mid = (lb + ub) / 2;\n        if((x[(mid + start) % (n + 1)] - x[start] + 3 * x[n]) % x[n] >= d)ub = mid;\n        else lb = mid;\n    }\n\n    return ub;\n}\n\n\n\nbool C(ll mid){\n    REP(i,n){\n        ll p = binsearch(i,mid);\n        if(p == n + 1)\n            continue;\n        ll q = binsearch((p + i) % (n + 1),(x[(p + i) % (n + 1)] - x[i] + 3 * x[n]) % x[n]);\n        if(p + q > n + 1)\n            continue;\n        ll r = binsearch((q + p + i) % (n + 1),(x[(p + i) % (n + 1)] - x[i] + 3 * x[n]) % x[n]);\n        if(p + q + r > n + 1)\n            continue;\n        return true;\n    }\n    return false;\n}\n\nll binsearch_i_max(){\n    ll lb = 0,ub = x[n] / 3 + 1;//[lb,ub)?????¢?´¢??????\n\n    while(ub - lb > 1){\n        ll mid = (lb + ub) / 2;\n        if(C(mid))lb = mid;\n        else ub = mid;\n    }\n\n    return lb;\n}\n\nint main(){\n    scanf(\"%lld\",&n);\n    REP(i,n)\n        scanf(\"%lld\",a + i);\n    x[0] = 0;\n    REP(i,n)\n        x[i + 1] = x[i] + a[i];\n\n    printf(\"%lld\\n\",binsearch_i_max());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint n;\nll a[200010], b[200010];\n\nbool check(int m) {\n  REP(i, n) {\n    int tmp = i==0 ? 0 : b[i-1];\n    int itr1 = lower_bound(b+i, b+i+n, tmp+m) - b;\n    // cout << b[itr1]+m << \" \" << *lower_bound(b+i, b+i+n, b[itr1]+m) << endl;\n    int itr2 = lower_bound(b+i, b+i+n, b[itr1]+m) - b;\n    // cout << \"i:\" << i << \" \" << itr1 << \" \" << itr2 << \" \" << a[itr1] << \" \" << a[itr2] << endl;\n    if(b[n+i-1] - b[itr2] >= m) return true;\n  }\n  return false;\n}\n\nsigned main(void)\n{\n  cin >> n;\n  REP(i, n) cin >> a[i];\n  FOR(i, n, 2*n) a[i] = a[i-n];\n  b[0] = a[0];\n  FOR(i, 1, 2*n) b[i] = a[i] + b[i-1];\n\n  // [low, high)\n  ll low=1, high=b[n-1];\n  while(high-low>1) {\n    ll mid = (low+high)/2;\n    // cout << low << \" \" << mid << \" \" << high << endl;\n    if(check(mid)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  cout << low << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tlong long check();\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcout << min_value << endl;\n\texit(0);\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tif (memo[cut_b] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_b] > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\n\tset_value = set_board();\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\tlong long min_value;\n\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\tif (memo[cut_b] - memo[cut_a] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (memo[cut_c] - memo[cut_b] > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n,a[100100],sum[200100];\nint main(){\n  scanf(\"%lld\",&n);\n  for(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i%n];\n\n  int l = 0, r = 1;\n  ll ans = 0, third = sum[n]/3;\n  while(l<n){\n    while(sum[r]-sum[l] <= third)r++;\n    r--;\n    ll fs = sum[r]-sum[l], half = (sum[n] - fs)/2;\n    int pos = lower_bound(sum+r, sum+2*n, half + sum[r]) - sum;\n\n    ll rem = min(sum[pos]-sum[r], sum[l+n]-sum[pos]);\n    if(pos>0)rem = max(rem, min(sum[pos-1]-sum[r], sum[l+n]-sum[pos-1]));\n\n    ans = max(ans, min(fs,rem));\n    l++;\n  }\n\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint n;\nll a[200010], b[200010];\n\nbool check(int m) {\n  REP(i, n) {\n    int tmp = i==0 ? 0 : b[i-1];\n    int itr1 = lower_bound(b+i, b+i+n, tmp+m) - b;\n    int itr2 = lower_bound(b+i, b+i+n, b[itr1]+m) - b;\n    if(b[n+i-1] - b[itr2] >= m) return true;\n  }\n  return false;\n}\n\nsigned main(void)\n{\n  cin >> n;\n  REP(i, n) cin >> a[i];\n  FOR(i, n, 2*n) a[i] = a[i-n];\n  b[0] = a[0];\n  FOR(i, 1, 2*n) b[i] = a[i] + b[i-1];\n\n  // [low, high)\n  ll low=1, high=b[n-1];\n  while(high-low>1) {\n    ll mid = (low+high)/2;\n    if(check(mid)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  cout << low << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> vector<T> make_v(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto make_v(size_t N,T... t){return vector<decltype(make_v(t...))>(N,make_v(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\nint main() {\n    int N; cin >> N;\n    V<ll> A(2*N+2,HIGHINF);\n    A[0] = 0;\n    for(int i = 1; i < N+1; ++i){\n        cin >> A[i];\n        A[i+N] = A[i];\n    }\n    for(int i = 1; i < 2*N+1; ++i) A[i] += A[i-1];\n\n    ll ok = 0, ng = HIGHINF/10, md;\n    while(ng - ok > 1){\n        md = (ok+ng)/2;\n        V<int> B(2*N+2);\n        B[2*N+1] = 2*N+1;\n        for(int i = 0; i < 2*N+1; ++i){\n            B[i] = lower_bound(ALL(A),A[i]+md) - A.begin();\n        }\n        int flg = 0;\n        for(int i = 0; i < N; ++i){\n            int idx = B[B[B[i]]];\n            if(idx-i<=N) flg = 1;\n        }\n        (flg?ok:ng) = md;\n    }\n    cout << ok << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\t/*s1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\tt = *lower_bound(a, a+MAX, s2+m);\n\t\tif(m == 216)printf(\"%lld %lld %lld %lld\\n\", s1, s2, t, total+sum-s2);*/\n\t\twhile(a[l1]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t\tl1++;\n\t\t}\n\t\twhile(a[l2]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t\tl2++;\n\t\t}\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tr++;\n\t\t\tsum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n;\nint table[200000];\n\nbool solve(ll x) {\n\tint l, r = 1; // [l,r)\n\tREP(i, 2 * n) table[i] = i;\n\tREP(i, 2 * n) {\n\t\tl = i;\n\t\tif (l >= r) r = l + 1;\n\t\twhile (r - l < n && r < 2 * n && sum[r - 1] - sum[l] + a[l] < x) r++;\n\t\tif (sum[r - 1] - sum[l] + a[l] >= x) table[l] = r;\n\t}\n\t\n\tREP(i, n) {\n\t\tint pos = i;\n\t\tREP(j, 3) {\n\t\t\tpos = table[pos];\n\t\t\tif (pos > i + n) break;\n\t\t\tif (j == 2 && pos <= i + n) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<cstring>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<complex>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define INF (1<<28)\n#define pb(i) push_back(i)\n#define fs first\n#define sc second\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<ll> v(n);\n\tll ub = 0,lb = 0,sum = 0;\n\trep(i,n){\n\t\tcin >> v[i];\n\t\tsum += v[i];\n\t}\n\tub = sum;\n\twhile(lb < ub){\n\t\tll med = (ub - lb)/2 + lb;\n\t\tint bg = 0, ed = 1;//[bg,ed)\n\t\tll sub = v[0];\n\t\tbool f = false;\n\t\twhile(bg != n && !f){\n\t\t\tif(sub >= med){\n\t\t\t\tll lsum = 0;\n\t\t\t\tfor(int i=ed;i!=bg && lsum < med;i=(i+1)%n){\n\t\t\t\t\tlsum += v[i];\n\t\t\t\t}\n\t\t\t\tif(lsum >= med && sum - lsum - sub >= med)f = true;\n\t\t\t\tsub -= v[bg++];\n\t\t\t}else{\n\t\t\t\tsub += v[ed];\n\t\t\t\ted = (ed+1)%n;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tlb = med+1;\n\t\t}else{\n\t\t\tub = med;\n\t\t}\n\t}\n\tcout << lb-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tconst long long int one_third = whole / 3;\n\tlong long int ans = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tint j = i;\n\t\tlong long int piece1 = 0;\n\t\twhile (piece1 + (long long int)A[j] <= one_third){\n\t\t\tpiece1 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int piece2 = 0;\n\t\twhile (1){\n\t\t\tpiece2 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t\tif (piece2 >= one_third) break;\n\t\t}\n\n\t\tlong long int piece3 = whole - piece1 - piece3;\n\t\tlong long int tmpans = min(piece1, min(piece2, piece3));\n\t\tans = max(ans, tmpans);\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ncin.tie(0);\nios::sync_with_stdio(false);\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\n\tvoid set_value();\t//値のセットをする関数\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long* memo;\t//バウムクーヘンの面積をメモ\n\tvoid memo_all_piece();\t//バウムクーヘンの面積をメモ\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\t//全てのバウムクーヘンの大きさの三分の一\n\n\tlong long extended_full_search();\t//計算\n\n\tlong long set_board();\t\t//最初の盤面の作成\n\tint cut_b;\t\t//2つ目の切れ込み\n\tint cut_c;\t\t//3つ目の切れ込み\n\n\tlong long check();\t//例外パターンのときの計算\n\tbool check_bool;\t//例外パターンがおきたかどうか\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n\tcheck_bool = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set)delete[] A;\n\tif (set)delete[] memo;\n}\n\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\t//バウムクーヘンの大きさの入力\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\t//バウムクーヘンの面積をメモ\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcheck_bool = true;\n\treturn min_value;\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tmin_value = memo[cut_b];\n\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (min_value > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\tlong long min_value;\n\n\tset_value = set_board();\t//一番最初の盤面の作成\n\tif (check_bool)return set_value;\t//例外パターンのときはcheck()の値を返す\n\n\t//一つずつずらしていく\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\t//3つのバウムクーヘンの大きさ比較\n\t\tmin_value = memo[cut_b] - memo[cut_a];\n\t\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (min_value > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\t//最大値の更新\n\n\t\tif (cut_c == N || cut_c == 2 * N || cut_c == 3 * N)break;\t//切れ込みが重なったらループ終了\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200001];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\t\tint posl2 = posr1 - 1;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tauto eval = [&](int k)\n\t\t{\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tint ttmin = min({ a, b, c });\n\t\t\tans = max(ans, ttmin);\n\t\t\treturn ttmin;\n\t\t};\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint x0 = right, x3 = n;\n\t\t\twhile (x3 != x0)\n\t\t\t{\n\t\t\t\tint x1 = x0 + (x3 - x0) / 3;\n\t\t\t\tint e1 = eval(x1);\n\t\t\t\tint x2 = x1 + (x3 - x0) / 3;\n\t\t\t\tint e2 = eval(x2);\n\t\t\t\tif (x1 < x2) x0 = x1;\n\t\t\t\telse x3 = x2;\n\t\t\t}\n\t\t\ttmin = eval(x0);\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double eps = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n;\nll a[100001], sum[200001];\n\nint main() {\n\tstd::cin >> n;\n\trep(i, n)std::cin >> a[i];\n\n\tREP(i, 1, 2 * n + 1)sum[i] = sum[i - 1] + a[(i - 1 >= n ? i - n - 1 : i - 1)];\n\n\tll l = 0, r = infll;\n\twhile (l <= r) {\n\t\tll m = (l + r) / 2;\n\n\t\tbool flg = false;\n\t\trep(i, n) {\n\t\t\tint be = i;\n\t\t\trep(j, 3) {\n\t\t\t\tbe = std::lower_bound(sum + i, sum + i + n + 1, m + sum[be]) - sum;\n\t\t\t\tif (be == i + n + 1)break;\n\t\t\t}\n\t\t\tif (be <= i + n) flg = true;\n\t\t}\n\t\tif (flg) l = m + 1;\n\t\telse r = m - 1;\n\t}\n\n\tstd::cout << l - 1 << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=1e14;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n  ll fir=*lower_bound(ALL(sum),x);\n  ll sec=*lower_bound(ALL(sum),fir+x);\n  ll thi=*lower_bound(ALL(sum),sec+x);\n  if(fir<=cnt&&sec<=cnt&&thi<=cnt){\n\t\treturn true;\n\t}\n  REP(i,n){\n      fir=*lower_bound(ALL(sum),sum[i]+x);\n\t\t\tif(fir>sum[i+n])continue;\n      sec=*lower_bound(ALL(sum),fir+x);\n\t\t\tif(sec>sum[i+n])continue;\n      thi=*lower_bound(ALL(sum),sec+x);\n\t\t\tif(thi>sum[i+n])continue;\n\t\t\treturn true;\n  }\n  return false;\n}\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n){\n        scanf(\"%lld\",&a[i]);\n        cnt+=a[i];\n    }\n    sum.resize(n*2);\n    REP(i,n*2){\n        if(i==0){\n            sum[i]=a[i];\n        }else{\n            sum[i]=sum[i-1]+a[i%n];\n        }\n    }\n    sum.PB(MAX+1);\n    ll lb=0,rb=cnt;\n    while(rb-lb>1){\n        ll mid=(rb+lb)/2;\n        if(ok(mid)){\n            lb=mid;\n        }else{\n            rb=mid;\n        }\n    }\n    printf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long > rui;\nint n;\nlong long int ans=0;\n\nint check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(rui.begin()+i,rui.begin()+i+n-1,m+rui[i]);\n\tif(*(rui.begin()+i+n)-*hoge<=m)return 1;\n\tvector<long long>::iterator hage=lower_bound(hoge,rui.begin()+i+n-1,*hoge+m);\n\tif(*(rui.begin()+i+n)-*hage>=m)return 0;\n\treturn 1;\n}\n\n\nint main ()\n{\n\tcin>>n;\n\tint mm=999999999;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tmm=min(mm,x);\n\t\trui.push_back(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[i]);\n\t}\n\tfor(int i=1;i<rui.size();i++)\n\t{\n\t\trui[i]+=rui[i-1];\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long l=0,r=5000000000000;\n\t\twhile(r!=l)\n\t\t{\n\t\t\tlong long m=(r+l)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=m+1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans-mm<<endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tcin >> inputBuffer;\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF (1e+15)\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\n  int n, a[100001];\n  ll ssum[100001*2] = {0};\n  \n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  \n  ssum[0] = a[0];\n  for(int i = 1; i < n*2; i++) ssum[i] = ssum[i - 1] + a[i % n];\n  \n  ll al = 0, ar = INF, amid;\n  int c2;\n  while(al < ar){\n    amid = (al + ar) / 2;          //解を二分探索\n    bool judge = false;\n    for(int i = 0; i < n; i++){\n      int l = i, r = n + i;              //添字を二分探索\n      while(l < r){\n        int mid = (l + r) / 2;\n        ll sub = ssum[mid] - ssum[i];\n        if(sub < amid) l = mid + 1;\n        else r = mid;\n      }\n      c2 = l++;\n      r = n + i;\n      while(l < r){\n        int mid = (l + r) / 2;\n        ll sub = ssum[mid] - ssum[c2];\n        if(sub < amid) l = mid + 1;\n        else r = mid;\n      }\n\n      if(ssum[i + n] - ssum[r] >= amid){\n        judge = true;\n        break;\n      }\n    }\n    if(judge) al = amid;\n    else ar = amid - 1;\n  }\n  cout << al << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)114\nint N;\nlong long input;\nlong long A[200010];\nlong long ans;\n\n//A[i]-A[st] >= A[ed]-A[i]となる最小のiを返す。\nint seach1( int st, int ed, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= A[ed]-A[i] )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n//A[i]-A[st] >= Xとなる最小のiを返す。\nint seach2( int st, int ed, long long X, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= X )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tfor( ; j < N+i; j++ ){\n\t\t\tif( A[j]-A[i] >= X )\n\t\t\t\tbreak;\n\t\t}\n\t\t//できるだけ真ん中で切る\n\t\tfor( ; k < N+i; k++ ){\n\t\t\tif( A[k]-A[j] >= A[N+i]-A[k] )\n\t\t\t\tbreak;\n\t\t}\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\ntypedef size_t baumkuchen_size_t;\ntypedef int index_t;\n\nstd::vector<baumkuchen_size_t> pieces;\nbaumkuchen_size_t whole_size; // SUM OF SIZE OF PIECES\nbaumkuchen_size_t max_size;   // MAX SIZE OF THE SMALLEST PIECE\n\n\ninline void reguralize(index_t *x)\n{\n    if ((*x) < 0)\n        (*x) += pieces.size();\n    (*x) %= pieces.size();\n}\n\n\ninline void progress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev += pieces.at(idx);\n    size_curr -= pieces.at(idx);\n    ++idx;\n    reguralize(&idx);\n}\n\n\ninline void regress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    --idx;\n    reguralize(&idx);\n    size_prev -= pieces.at(idx);\n    size_curr += pieces.at(idx);\n}\n\n\ninline void update(baumkuchen_size_t input, baumkuchen_size_t *target)\n{\n    if (input > (*target))\n        (*target) = input;\n}\n\n\nint main()\n{\n    // READ INPUTS\n    {\n        int num;\n        std::cin >> num;\n        pieces.assign(num, 0);\n\n        for (int i = 0; i < num; ++i)\n        {\n            std::cin >> pieces[i];\n            whole_size += pieces.at(i);\n        }\n        max_size = whole_size / 3;\n    }\n    \n    index_t idx1(0), idx2(1), idx3(2); // BEGIN INDEX OF EACH BAUMKUCHEN PIECE\n    baumkuchen_size_t\n        size1(pieces.at(idx1)),            // SIZE OF 1ST BAUMKUCHEN PIECE\n        size2(pieces.at(idx2)),            // SIZE OF 2ND BAUMKUCHEN PIECE\n        size3(whole_size - size1 - size2); // SIZE OF 3RD BAUMKUCHEN PIECE\n    baumkuchen_size_t out(0); // RETURN VALUE\n\n    /* PRESUME THAT THE FIRST PIECE IS SMALLEST. */\n\n    //std::cerr << \"num = \" << pieces.size() << std::endl;\n    //std::cerr << \"sum = \" << whole_size << std::endl;\n    //std::cerr << \"max = \" << max_size << std::endl;\n    \n    for (int i = 0; i < pieces.size(); ++i)\n    {        \n        while (size1 <= max_size)\n        {\n            // CHECK WHETHER size1 CAN BE SMALLEST\n            \n            if (size1 <= size2 and size1 <= size3)\n                update(size1, &out);\n\n            while (size1 > size2 or size1 > size3)\n            {\n                // NOTE: size2 & size3 CANNOT BE EQUAL HERE.\n                \n                bool was_larger(size2 > size3);\n                assert(size2 != size3);\n\n                (size2 > size3) ?\n                    regress_idx(idx3, size2, size3) :\n                    progress_idx(idx3, size2, size3);\n\n                if (size1 <= size2 and size1 <= size3)\n                    update(size1, &out);\n\n                if ((size2 > size3) != was_larger)\n                    break;\n            }\n            \n            progress_idx(idx2, size1, size2);\n        }\n\n        progress_idx(idx1, size3, size1);\n        while (size1 > max_size)\n            regress_idx(idx2, size1, size2);\n    }\n    \n    //std::cerr << \"out = \" << out << std::endl;\n    std::cout << out << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\ntypedef long long int ll;\ntypedef pair<int, int> pii;\n\nint N, A[100010], S[200010];\n\n// start-point (1-indexed), length\nbool d(int init, int len) {\n    // [lb, ub)\n    // printf(\"length = %lld\\n\", len);\n    int lb = init, ub = N+init, idx = init;\n    rep(i,0,3) {\n        int target = S[idx] + len;\n        idx = lower_bound(S, S+2*N+1, target) - S;\n        // printf(\"target = %lld, idx = %lld\\n\", target, idx);\n        if(idx > ub) return false;\n    }\n    return true;\n}\n\nint main() {\n    cin >> N;\n    rep(i,0,N) cin >> A[i];\n\n    // 1 ... N\n    rep(i,0,N) S[i+1] = S[i] + A[i];\n    // N+1 ... 2N\n    rep(i,0,N) S[i+1+N] = S[i+N] + A[i];\n\n    int ans = 0;\n    repq(i,1,N) {\n        int ub = (int)1e15, lb = 0;\n        while(ub - lb > 1) {\n            int mid = (ub + lb) / 2;\n            if(d(i, mid)) lb = mid;\n            else ub = mid;\n        }\n        ans = max(ans, lb);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[4 * N];\n\tmemo = new long long[5 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n\t\t//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n/*\nlong long baumkuchen::extended_full_search(){\nlong long keep_value;\nlong long keep_value2;\nlong long set_value = 0;\n\nfor (int i = 0; i <4*N; i++){\nint b;\nfor (b = i+1; b < 3 * N; b++){\nmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\nif (memo[i * N + b] >= tripartition)break;\n}\nif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\nkeep_value = memo[i * N + b - 1];\nb--;\n}\nelse keep_value = memo[i * N + b];\ndouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\nint c;\nfor (c = b; c < 3 * N; c++){\nmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\nif (memo[i * N + c] >= keep_value + half)break;\n}\nif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\nkeep_value2 = memo[i * N + c - 1];\nc--;\n}\nelse keep_value2 = memo[i * N + c];\n\nif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\nif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"i = %d\\t\", i);\n//\t\tprintf(\"c = %d\\n\\n\", c);\n\nif (set_value < keep_value)set_value = keep_value;\nif (c == N || c == 2*N || c== 3*N)break;\n\n}\n\nreturn set_value;\n}\n*/\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < 4 * N; i++){\n\t\tint b;\n\n\t\tfor (int f = 0; f < 5 * N; f++){\n\t\t\tmemo[f] = 0;\n\t\t}\n\t\tfor (b = i + 1; b < 3 * N; b++){\n\t\t\tmemo[b] = memo[b - 1] + piece(b - 1, b);\n\t\t\tif (memo[b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[b - 1] < memo[b] - tripartition){\n\t\t\tkeep_value = memo[b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[b];\n\t\tdouble half = (sum_baum - memo[b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[c] = memo[c - 1] + piece(c - 1, c);\n\t\t\tif (memo[c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[c - 1] < memo[c] - keep_value - half){\n\t\t\tkeep_value2 = memo[c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n\t\t//\t\tprintf(\"i = %d\\t\", i);\n\t\t//\t\tprintf(\"c = %d\\n\\n\", c);\n\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N || c == 2 * N || c == 3 * N)break;\n\n\t}\n\n\treturn set_value;\n}\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define LL long long\n#define pb push_back\nvector<LL>V;\nint main(){\n\tV.pb(0);\n\tint n;cin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint t;cin>>t;;\n\t\tV.pb(t);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tV.pb(V[i]);\n\t}\n\tfor(int i=1;i<V.size();i++){\n\t\tV[i]+=V[i-1];\n\t}\n\tLL MX=V[n]/3,MN=1;\n\tvector<LL>::iterator IT=V.begin();\n\tIT++;\n\tfor(int i=1;i<=n;i++,IT++){\n\t\tLL mn=MN,mx=MX;\n\t\tLL p=(mn+mx)/2;\n\t\twhile(mx-mn>1){\n\t\t\tp=(mn+mx)/2;\n\t\t\tvector<LL>::iterator it1=lower_bound(IT,IT+n-1,(*(IT-1))+p);\n\t\t\tvector<LL>::iterator it2=lower_bound(it1+1,IT+n-1,(*it1)+p);\n\t\t\tvector<LL>::iterator it3=lower_bound(it2+1,IT+n-1,(*it2)+p);\n\t\t\tif(*it3<=*(IT+n-1) && p<=(*it3)-(*it2))mn=p;\n\t\t\telse mx=p;\n\t\t}\n\t\tMN=max(MN,mn);\n\t}\n\tcout<<MN<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n) if (cuts[k] - cuts[j] >= size)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ll INF = LLONG_MAX / 3;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tll n; cin >> n;\n\tvi a(n); REP(i, n) cin >> a[i];\n\tll lb = 0, ub = INF;\n\twhile (ub - lb > 1)\n\t{\n\t\tll mid = (ub + lb) / 2;\n\t\tbool ok = false;\n\t\tint div0, div1, div2;\n\t\tdiv0 = 0;\n\t\tint p = 0;\n\t\tll tmpa = 0;\n\t\twhile (tmpa < mid)\n\t\t{\n\t\t\ttmpa += a[p];\n\t\t\tp++;\n\t\t\tif (p == n) goto end;\n\t\t}\n\t\tdiv1 = p;\n\t\tll tmpb = 0;\n\t\twhile (tmpb < mid)\n\t\t{\n\t\t\ttmpb += a[p];\n\t\t\tp++;\n\t\t\tif (p == n) goto end;\n\t\t}\n\t\tdiv2 = p;\n\t\tll tmpc = 0;\n\t\tFOR(i, p, n) tmpc += a[i];\n\t\twhile (1)\n\t\t{\n\t\t\tif (tmpa >= mid && tmpb >= mid && tmpc >= mid)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (div2 == n) break;\n\t\t\ttmpa -= a[div0];\n\t\t\ttmpc += a[div0];\n\t\t\tdiv0++;\n\t\t\twhile (tmpa < mid)\n\t\t\t{\n\t\t\t\ttmpa += a[div1];\n\t\t\t\ttmpb -= a[div1];\n\t\t\t\tdiv1++;\n\t\t\t\tif (div1 == div2) goto end;\n\t\t\t}\n\t\t\twhile (tmpb < mid)\n\t\t\t{\n\t\t\t\tif (div2 == n) break;\n\t\t\t\ttmpb += a[div2];\n\t\t\t\ttmpc -= a[div2];\n\t\t\t\tdiv2++;\n\t\t\t\tif (div2 == div0) goto end;\n\t\t\t}\n\t\t}\n\tend:;\n\t\tif (ok) lb = mid;\n\t\telse ub = mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \nint N;\nlong long A[200002];\n \nbool Check(long long val)\n{\n  for(int i = 1; i <= N; i++) {\n    long long *Begin = &A[i], *End = &A[i + N + 1]; // ???????????????\n    bool Flag = true;\n    for(int j = 0; j < 3; j++) {\n      long long Need = *Begin + val;\n      long long *It = lower_bound(Begin, End, Need);\n      if(It == End) {\n        Flag = false;\n        break;\n      }\n      Begin = It;\n    }\n    if(Flag) return(true);\n  }\n  return(false);\n}\n \nint main()\n{\n  cin >> N;\n  for(int i = 1; i <= N + N; i++) {\n    if(1 <= i && i <= N) {\n      cin >> A[i];\n      A[i + N] = A[i];\n    }\n    A[i] += A[i - 1];\n  }\n  long long low = 0, high = 1LL << 60;\n  while(high - low > 0) {\n    long long mid = (low + high + 1) >> 1;\n    if(Check(mid)) low = mid;\n    else high = mid - 1;\n  }\n  cout << low << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tint* A;\t//一つ一つのバウムクーヘンの大きさ\n\tint sum_baum;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tint tripartition();\t//\n\tint piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\n\tint full_search();\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\n\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n}\n\nint baumkuchen::tripartition(){\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tsum += A[N];\n\t}\n\treturn sum;\n}\n\nint baumkuchen::piece(int cut_1, int cut_2){\n\tint piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new int[N];\n\n\tset = true;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\tsum_baum += A[i];\n\t}\n\tN -= 1;\n}\n\nint baumkuchen::full_search(){\n\tint keep_value;\n\tint set_value=0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->full_search()<<endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<long long int> v;\nlong long int ans;\nlong long int s;\n\nint third(int x){\n\tint l = x;\n\tint r = 2*n;\n\tint m = n;\n\twhile(r - l > 1){\n//\t\tif(x == 0) printf(\"%d %d %d\\n\", l, m, r);\n\t\tm = (l + r) / 2;\n\t\tif(v[m] > v[x] + v[n] / 3) r = m;\n\t\telse l = m + 1;\n\t}\n\treturn l;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tv.push_back(0);\n\tfor(int i=0; i<n; i++){\n\t\tlong long int t;\n\t\tscanf(\"%lld\", &t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<n+1; i++) v.push_back(v[i]);\n\tfor(int i=1; i<v.size(); i++) v[i] += v[i-1];\n\n\tfor(int i=0; i<n; i++){\n\t\tint j = third(i);\n\t\tint k = third(j);\n\t\tans = max(ans, min(v[j] - v[i], min(v[k] - v[j], v[n] +v[i] - v[k])));\n//\t\tif(ans == 5) printf(\"%d %d %d\\n\", i, j, k);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nvoid CalcPiece1(int *_i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i2 < _i1 + _N - 2;){\n\t\t*_piece1_s = *_piece1_l;\n\t\t*_piece1_l += _A[*_i2%_N];\n\t\t(*_i2)++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n}\n\nvoid CalcPiece3(int *_i3, ull *_piece3_s, ull *_piece3_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i3 < _i1 + _N - 1;){\n\t\t*_piece3_l = *_piece3_s;\n\t\t*_piece3_s -= _A[*_i3%_N];\n\t\t(*_i3)++;\n\t\tif (*_piece3_s <= _one_third_size) break;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tint *A = new int[N];\n\tull total_size = 0;\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\t/*for (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}*/\n\t\tint i3 = i1_ini + 1;\n\t\tCalcPiece1(&i3, &piece2, &tmp, i1_ini + 1, N, half_size, A);\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\tconst int i1_fin = i2;\n\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tCalcPiece3(&i3, &piece3_s, &piece3_l, i1_ini, N, one_third_size, A);\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse CalcPiece1(&i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse CalcPiece3(&i3, &piece3_s, &piece3_l, i1, N, one_third_size, A);\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst long long LINF = 1e18;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<ll,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll A[300000] = {};\nPii sum[300000] = {};\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\n\trep(i,N){\n\t\tscanf(\"%lld\",&A[i]);\n\t\tA[N+i] = A[i];\n\t\tA[2*N+i] = A[i];\n\t}\n\n\tsum[0].fr = 0;\n\tsum[3*N].sc = 3*N;\n\trep(i,3*N){\n\t\tsum[i+1].fr += sum[i].fr + A[i];\n\t\tsum[i].sc = i;\n\t}\n\n\t/*rep(i,3*N+1){\n\t\tprintf(\"%lld \",sum[i].fr);\n\t}\n\tputs(\"\");\n\n\trep(i,3*N+1){\n\t\tprintf(\"%lld \",sum[i].sc);\n\t}\n\tputs(\"\");*/\n\t\n\n\tll ans = -LINF;\n\n\trep(i,N){\n\t\tint l = 0;\n\t\tint r = sum[N].fr-sum[0].fr;\n\t\tint p,q,w;\n\t\twhile(l + 1 != r){\n\t\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\t//printf(\"[%d , %d] => %d\\n\",l,r,m);\n\t\t\tPii tmp;\n\t\t\ttmp.fr = m + sum[i].fr; tmp.sc = 0;\n\t\t\tPii res1 = *lower_bound(sum+i,sum+i+N-1,tmp);\n\t\t\ttmp.fr = m + res1.fr;\n\t\t\tPii res2 = *lower_bound(sum+res1.sc,sum+res1.sc+N-1,tmp);\n\t\t\ttmp.fr = m + res2.fr;\n\t\t\tPii res3 = *lower_bound(sum+res2.sc,sum+res2.sc+N-1,tmp);\n\t\t\t//printf(\"res1(%lld , %d)\\n\",res1.fr,res1.sc);\n\t\t\t//printf(\"res2(%lld , %d)\\n\",res2.fr,res2.sc);\n\t\t\t//printf(\"res3(%lld , %d)\\n\",res3.fr,res3.sc);\n\t\t\t\n\t\t\tif(res3.sc <= i+N){\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tPii _tmp;\n\t\t_tmp.fr = l + sum[i].fr; _tmp.sc = 0;\n\t\tPii _res1 = *lower_bound(sum+i,sum+i+N-1,_tmp);\n\t\t_tmp.fr = l + _res1.fr;\n\t\tPii _res2 = *lower_bound(sum+_res1.sc,sum+_res1.sc+N-1,_tmp);\n\t\t_tmp.fr = l + _res2.fr;\n\t\tPii _res3 = *lower_bound(sum+_res2.sc,sum+_res2.sc+N-1,_tmp);\n\t\tp = _res1.sc; q = _res2.sc; w = _res3.sc;\n\t\t//printf(\"[%d , %d] => %lld %lld %lld\\n\",l,r,sum[p].fr-sum[i].fr,sum[q].fr-sum[p].fr,sum[w].fr-sum[q].fr);\n\t\t\n\t\tans = max(ans,min(sum[p].fr-sum[i].fr,min(sum[q].fr-sum[p].fr,sum[w].fr-sum[q].fr)));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left <= n + 1)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = (sum - size) / 2.0;\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tif (N < DevideNum){\n\t\tcout << \"0\" << endl;\n\t\texit(1);\n\t}\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / DevideNum;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_max)) ? ans_max : ans_min;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nconst int MAX = 210000;\nint N;\nlong long A[MAX];\nlong long sum[MAX];\n\nint dp[MAX];\nlong long val[MAX];\n\nint main() {\n    while (cin >> N) {\n        long long all = 0;\n        for (int i = 0; i < N; ++i) {\n            cin >> A[i];\n            sum[i+1] = A[i];\n            sum[i+N+1] = A[i];\n            all += A[i];\n        }\n        for (int i = 0; i < N*2; ++i) sum[i+1] += sum[i];\n        \n        long long lo = 0, hi = sum[N]/3 + 1, med;\n        while (hi - lo > 1) {\n            med = (hi + lo) / 2;\n            \n            //cout << endl; COUT(med);\n            \n            for (int i = 0, j = 0; i <= N && j <= N*2; ) {\n                if (sum[j] - sum[i] < med) {\n                    ++j;\n                }\n                else {\n                    dp[i] = j;\n                    val[i] = sum[j] - sum[i];\n                    ++i;\n                }\n            }\n            \n            bool ok = false;\n            for (int i = 0; i < N; ++i) {\n                int i2 = dp[i]; \n                if (i2 >= N) continue;\n                long long a = val[i];\n                long long b = val[i2];\n                \n                //cout << i << \" : \" << i2 << \"; \" << pll(a, b) << \", \" << (all - a - b >= med) << endl;\n                \n                if (all - a - b >= med) ok = true;\n            }\n            \n            if (!ok) hi = med;\n            else lo = med;\n        }\n        \n        cout << lo << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\n\tvoid set_value();\t//値のセットをする関数\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long* memo;\t//バウムクーヘンの面積をメモ\n\tvoid memo_all_piece();\t//バウムクーヘンの面積をメモ\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\t//全てのバウムクーヘンの大きさの三分の一\n\n\tlong long extended_full_search();\t//計算\n\n\tlong long set_board();\t\t//最初の盤面の作成\n\tint cut_b;\t\t//2つ目の切れ込み\n\tint cut_c;\t\t//3つ目の切れ込み\n\n\tlong long check();\t//例外パターンのときの計算\n\tbool check_bool;\t//例外パターンがおきたかどうか\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n\tcheck_bool = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set)delete[] A;\n\tif (set)delete[] memo;\n}\n\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\t//バウムクーヘンの大きさの入力\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\t//バウムクーヘンの面積をメモ\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcheck_bool = true;\n\treturn min_value;\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tmin_value = memo[cut_b];\n\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (min_value > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\tlong long min_value;\n\n\tset_value = set_board();\t//一番最初の盤面の作成\n\tif (check_bool)return set_value;\t//例外パターンのときはcheck()の値を返す\n\n\t//一つずつずらしていく\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\t//3つのバウムクーヘンの大きさ比較\n\t\tmin_value = memo[cut_b] - memo[cut_a];\n\t\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (min_value > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\t//最大値の更新\n\n\t\tif (cut_c == N || cut_c == 2 * N || cut_c == 3 * N)break;\t//切れ込みが重なったらループ終了\n\t}\n\treturn set_value;\n}\n\nint main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0 + 0.5;\n\n\t\tint ans = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = (sum - len) / 2;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tans = max(ans, sum - len - remlen);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long > rui;\nint n;\nlong long int ans=0;\n\nint check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(rui.begin()+i,rui.begin()+i+n-1,m+((i==0)?0:rui[i-1]));\n\tif(*(rui.begin()+i+n)-*hoge<=m)return 1;\n\tvector<long long>::iterator hage=lower_bound(hoge,rui.begin()+i+n-1,*hoge+m);\n\tif(*(rui.begin()+i+n-1)-*hage>=m)return 0;\n\treturn 1;\n}\n\n\nint main ()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\trui.push_back(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[i]);\n\t}\n\tfor(int i=1;i<rui.size();i++)\n\t{\n\t\trui[i]+=rui[i-1];\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long l=0,r=5000000000000;\n\t\twhile(l!=r)\n\t\t{\n\t\t\tlong long m=(r+l)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=m+1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans-1<<endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\t//FILE *inputFile = fopen(\"0600_in4.txt\", \"r\");\n\t//fscanf(inputFile, \"%d\", &N);\n\t//for(int i = 0; i < N; i++){\n\t//\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t//}\n\t//fclose( inputFile);\n\t\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nbool Check(const vector<int> &a,lli m){\n\tREP(i,0,a.size()){\n\t\tint cnt=0,last=i;\n\t\tREP(i,0,3){\n\t\t\tint crt=last;\n\t\t\tlli d=a[crt];\n\t\t\t++cnt;\n\t\t\twhile(cnt<=a.size()&&d<m){\n\t\t\t\tcrt=(crt+1)%a.size();\n\t\t\t\td+=a[crt];\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif(!(cnt<=a.size())) break;\n\t\t\tlast=(crt+1)%a.size(); \n\t\t}\n\t\tif(cnt<=a.size()) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tREP(i,0,N) cin >> A[i];\n\tlli lb=0,ub=INF_;\n\twhile(ub-lb>1){\n\t\tlli mid=(lb+ub)/2;\n\t\tif(Check(A,mid)){\n\t\t\tlb=mid;\n\t\t}else ub=mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=LLONG_MAX;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n  ll fir=*lower_bound(ALL(sum),x);\n  ll sec=*lower_bound(ALL(sum),fir+x);\n  ll thi=*lower_bound(ALL(sum),sec+x);\n  if(fir<=cnt&&sec<=cnt&&thi<=cnt){\n\t\treturn true;\n\t}\n  REP(i,n){\n      fir=*lower_bound(ALL(sum),sum[i]+x);\n\t\t\tif(fir>sum[i+n])continue;\n      sec=*lower_bound(ALL(sum),fir+x);\n\t\t\tif(sec>sum[i+n])continue;\n      thi=*lower_bound(ALL(sum),sec+x);\n\t\t\tif(thi>sum[i+n])continue;\n\t\t\treturn true;\n  }\n  return false;\n}\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n){\n        scanf(\"%lld\",&a[i]);\n        cnt+=a[i];\n    }\n    sum.resize(n*2);\n    REP(i,n*2){\n        if(i==0){\n            sum[i]=a[i];\n        }else{\n            sum[i]=sum[i-1]+a[i%n];\n        }\n    }\n    sum.PB(MAX);\n    ll lb=0,rb=cnt;\n    while(rb-lb>1){\n        ll mid=(rb+lb)/2;\n        if(ok(mid)){\n            lb=mid;\n        }else{\n            rb=mid;\n        }\n    }\n    printf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / DevideNum;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_min)) ? ans_min : ans_max;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vll a(n); REP(i, n) cin >> a[i];\n    ll total = accumulate(ALL(a), 0ll);\n\n    a.resize(2 * n);\n    REP(i, n) a[i + n] = a[i];\n\n    auto check = [&](ll x) {\n        // 大きさx以上を3つ切り出せるか?\n        int m = 0, r = 0;\n        ll suml = 0, sumr = 0;\n        REP(l, n) {\n            while (m < 2 * n and suml < x) suml += a[m], sumr -= a[m], ++m;\n            while (r < 2 * n and sumr < x) sumr += a[r], ++r;\n            if (suml < x or sumr < x) break;\n            if (total - suml - sumr >= x) return true;\n            suml -= a[l];\n        }\n        return false;\n    };\n\n    ll left = 0, right = total / 3 + 1;\n    while (right - left > 1) {\n        ll mid = (left + right) / 2;\n        (check(mid) ? left : right) = mid;\n    }\n    cout << left << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tconst long long int one_third = whole / 3;\n\tlong long int ans = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tint j = i;\n\t\tlong long int piece1 = 0;\n\t\twhile (piece1 + (long long int)A[j] <= one_third){\n\t\t\tpiece1 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int piece2 = 0;\n\t\twhile (1){\n\t\t\tpiece2 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t\tif (piece2 >= one_third) break;\n\t\t}\n\n\t\tlong long int piece3 = whole - piece1 - piece2;\n\t\tlong long int tmpans = min(piece1, min(piece2, piece3));\n\t\tans = max(ans, tmpans);\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 100005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n// #define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(int)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = (_begin + _end) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\n\n\nll N,M,K,A[NMAX],B,D,E;\nll S[NMAX] = {};\n\nll ans = {};\n\nbool C(int x){\n  for (int i = 0, j = 0; i < N; ++i)\n  {\n    while(j < N && S[j] - S[i] < x) ++j;\n    if(j == N) return false;\n    int k = j;\n    while(k < N && S[k] - S[j] < x) ++k;\n    if(k == N) return false;\n\n    if(S[i + N] - S[k] >= x) return true;\n  }\n  return false;\n}\n\nvoid solve(){\n  // main algorithm\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    S[i+1] = S[i] + A[i % N];\n  }\n  int low = 1, hi = S[N] / 3 + 1;\n  while(hi - low > 1) {\n    int mid = (hi + low) / 2;\n    if(C(mid)) {\n      low = mid;\n      debug(\"C(%d) = true\\n\", mid);\n    }\n    else {\n      hi = mid;\n      debug(\"C(%d) = false\\n\", mid);\n    }\n  }\n  ans = low;\n}\nvoid debug(){\n  // output debug information\n\n  printf(\"i\\t| A[i]\\tS[i]\\n--------------------------\\n\");\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    printf(\"%d\\t| %lld\\t%lld\\n\", i, A[i%N], S[i]);\n  }\n  printf(\"%d\\t| ***\\t%lld\\n\", 2*N, S[2 * N]);\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // Fill(dp, -1);\n  cin >> N;\n  for (int i = 0; i < N; ++i)\n  {\n    scanf(\"%lld\", &A[i]);\n  }\n  solve();\n  #ifdef DEBUG\n  debug();\n  #endif\n  answer();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n//ちょっと気まぐれだが、O(N^2logN)の枝刈りで通してみたくなったからそれで通す。\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n//A[medi]-A[st] > ansとなる最小のmediを返す。\nint seach2( int st, int ed ){\n\tint s=st,e=ed,medi;\n\twhile( s<=e ){\n\t\tmedi= (s+e)>>1;\n\t\tif( A[medi]-A[st] <= ans )\n\t\t\ts=medi+1;\n\t\tif( A[medi]-A[st] > ans ){\n\t\t\tif( A[medi-1]-A[st] <= ans )\n\t\t\t\tbreak;\n\t\t\te=medi-1;\n\t\t}\n\t}\n\treturn medi;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\t\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\tfor( i = 0; i < N; i++ ){\n\t\tfor( j = seach2(i,N); j < N; j++ ){\n\t\t\t//できるだけ真ん中で切る\n\t\t\tk = seach1(j,i+N);\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t\tk--;\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200000];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i < 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n, s[i] + sums / 3) - s;\n\t\tint posr2 = lower_bound(s, s + 2 * n, s[i] + sums * 2 / 3) - s;\n\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1--, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\n\tull minimum_piece = 0;\n\tfor(int i1=0; i1<N-2; i1++){\n\t\tfor(int i2=i1+1; i2<N-1; i2++){\n\t\t\tfor(int i3=i2+1; i3<N; i3++){\n\t\t\t\tull piece1 = 0, piece2 = 0, piece3 = 0;\n\t\t\t\tfor(int i=i1; i<i2; i++) piece1 += A[i];\n\t\t\t\tfor(int i=i2; i<i3; i++) piece2 += A[i];\n\t\t\t\tpiece3 = total_size - piece1 - piece2;\n\t\t\t\t\n\t\t\t\tull tmp = piece1;\n\t\t\t\tif(tmp > piece2) tmp = piece2;\n\t\t\t\tif(tmp > piece3) tmp = piece3;\n\n\t\t\t\tif(minimum_piece < tmp) minimum_piece = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << minimum_piece << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define ULL int64_t\n\nULL sum(ULL *d,ULL s ,ULL e){\n\tULL r = 0;\n\tfor(int i = s;i <= e;i++){\n\t\tr+=d[i];\n\t}\n\treturn r;\n}\n\nint main(){\n\tULL n;\n\tcin >> n;\n\tULL *d = (ULL*)malloc(sizeof(ULL) * n);\n\tif(d == NULL){\n\t\treturn -1;\n\t}\n\tULL s = 0;\n\tULL m;\n\tfor(ULL i = 0;i < n;i++){\n\t\tcin>>m;\n\t\td[i] = m;\n\t\ts += m;\n\t}\n\tULL max_dis = s;\n\tULL max_snd,max_thd;\n\tfor(ULL u = 0;u < n - 2;u++){\n\t\tfor(ULL v = u+1;v < n - 1;v++){\n\t\t\tfor(ULL w = v + 1;w < n;w++){\n\t\t\t\tULL snd = sum(d,u,v-1);\n\t\t\t\tULL thd = sum(d,v,w-1);\n\t\t\t\tULL fst = s - snd - thd;\n\t\t\t\tif(max_dis > abs(snd - thd) + abs(thd-fst) + abs(fst - snd)){\n\t\t\t\t\tmax_dis = abs(snd - thd) + abs(thd-fst) + abs(fst - snd);\n\t\t\t\t\tmax_snd = snd;\n\t\t\t\t\tmax_thd = thd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tULL max_fst = s - max_snd - max_thd;\n\tULL res;\n\tif(max_fst <= max_snd && max_fst < max_thd){\n\t\tres = max_fst;\n\t}else if(max_snd <= max_thd && max_snd <= max_fst){\n\t\tres = max_snd;\n\t}else{\n\t\tres = max_thd;\n\t}\n\tcout<<res<<endl;\n\tfree( d );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3*N];\n\tmemo = new long long[N * N+5]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <3*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"c = %d\\n\", c);\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N || c == 2*N || c== 3*N)break;\n\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nusing ll = long long int;\n\nll a[100000];\nll sum[200001];\nint n;\n\ninline ll modloop(int a_, int b_)\n{\n\treturn (a_ >= 0) ? (a_ % b_) : ((a_ % b_) + b_);\n}\n\ninline ll piece(int a_)\n{\n\treturn a[modloop(a_, n)];\n}\n\ninline ll width(int a_,int b_)\n{\n\ta_ = modloop(a_, n);\n\tb_ = modloop(b_, n);\n\tif (a_ < b_ + 1)\n\t{\n\t\treturn sum[b_ + 1] - sum[a_];\n\t}\n\telse\n\t{\n\t\treturn sum[n] - sum[b_ + 1] + sum[a_];\n\t}\n}\n\nbool cir(int cut,ll x)\n{\n\tint seccut = lower_bound(sum + cut, sum + n + n, sum[cut] + x) - sum;\n\tint thrcut = lower_bound(sum + seccut, sum + n + n, sum[seccut] + x) - sum;\n\tif (sum[cut + n] - sum[thrcut] >= x)return true;\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)scanf(\"%lld\", a + i);\n\tsum[0] = 0;\n\tfor (int i = 0; i < n; ++i)sum[i + 1] = sum[i] + a[i];\n\tfor (int i = n; i < 2 * n;++i)sum[i + 1] = sum[i] + a[i - n];\n\tll ans = 0;\n\tfor (int cut = 0; cut < n; ++cut)\n\t{\n\t\tll min = 1;\n\t\tll max = sum[n] / 3 + 1;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t{\n\t\t\tll mid = (min + max) / 2;\n\t\t\tif (cir(cut,mid))\n\t\t\t{\n\t\t\t\tmin = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\tans = (ans > min) ? ans : min;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint n;\nvector<long long > rui;\nbool check(int i,long long m)\n{\n\tvector<long long >::iterator hoge=rui.end();\n\thoge = lower_bound(rui.begin() + i, rui.begin() +n-1+ i, m+rui[i]);\n\tif (hoge == rui.end())return false;\n\tvector<long long >::iterator hage = rui.end();\n\thage = lower_bound(hoge, rui.begin() + n - 1 + i, m + *hoge);\n\tif (hage == rui.end())return false;\n\tif (*(rui.begin() + n - 1 + i) - (*hage) >= m)return true;\n\treturn false;\n}\nint main()\n{\n\tcin >> n;\n\trep(i, n)\n\t{\n\t\tlong long int x;\n\t\tcin >> x;\n\t\t(i == 0) ? rui.push_back(x) : rui.push_back(rui[i - 1] + x);\n\t}\n\trep(i, n)(i == 0) ? rui.push_back(rui[0] + rui[n - 1]) : rui.push_back(rui[n - 1 + i] + rui[i] - rui[i - 1]);\n\tlong long int ans = 0;\n\trep(i, n)\n\t{\n\t\tlong long l = 0;\n\t\tlong long r = 500000000000000000;\n\t\twhile (r != l)\n\t\t{\n\t\t\tlong long int m = (l + r) / 2;\n\t\t\tif (check(i, m))\n\t\t\t{\n\t\t\t\tl = m+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, l);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<map>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef pair< int , int  > Pi;\ntypedef pair< double , Pi > Pii;\n\nconst int INF = 1 << 30;\ntypedef long long int64;\n\nint N;\nint64 A[200001];\n\nbool foo(int64* begin, int64* end, int hage, int64 value){\n  int64* pos = lower_bound( begin, end, hage + value);\n  if(pos == end) return false;\n  hage = *pos;\n  pos = lower_bound( begin, end, hage + value);\n  if(pos == end) return false;\n  hage = *pos;\n  pos = lower_bound( begin, end, hage + value);\n  return pos != end;\n}\n\nbool calc(int64 value){\n  for(int i = 0; i < N; i++){ // 切り始めるところ\n    int64 *begin = A + i, *end = A + i + N + 1;\n    int64 base = A[i];\n    if(foo( begin, end, base, value)) return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", &A[i]);\n    A[i + N] = A[i];\n  }\n\n  for(int i = 1; i < 2 * N; i++){\n    A[i] += A[i - 1];\n  }\n  A[2 * N] = (1LL << 61);\n\n  int64 row = 0, high = (1LL << 61);\n  \n  while(high - row > 0){\n    int64 mid = (high + row + 1) / 2;\n    if(calc(mid)) row = mid;\n    else high = mid - 1;\n  }\n  cout << row << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = (a) ; i <= (b) ; i++)\n#define Rep(i , n) for (int i = 0 ; i < (n) ; i++)\n#define Ford(i , a , b) for (int i = (a) ; i >= (b) ; i--)\n\nconst int maxn = 100000 + 1912;\nint n , a[maxn];\nlong long totalSum = 0;\nlong long sum[maxn];\n\nvoid ReadData() {\n\tscanf(\"%d\" , &n);\n\tFor(i , 1 , n) scanf(\"%d\" , &a[i]);\n\tFor(i , 1 , n) a[i + n] = a[i];\n\tFor(i , 1 , n << 1) sum[i] = sum[i - 1] + a[i];\n}\n\nlong long GetSum(const int l , const int r) {\n\treturn sum[r] - sum[l - 1];\n}\n\nbool check(long long limit) {\n\tint ptr1 = 1 , ptr2 = 2;\n\tFor(i , 1 , n - 1) {\n\t\tint last = i + n - 1;\n\t\twhile (ptr1 < last - 1 && GetSum(i , ptr1) < limit) ptr1++;\n\t\tptr2 = max(ptr2 , ptr1 + 1);\n\t\twhile (ptr2 < last && GetSum(ptr1 + 1, ptr2) < limit) ptr2++;\n\t\t\n\t\tif ((ptr2 <= last) &&\n\t\t (GetSum(i , ptr1) >= limit && GetSum(ptr1 + 1 , ptr2) >= limit && GetSum(ptr2 + 1 , last) >= limit) ) return true;\n\t}\n\treturn false;\n}\n\nvoid Process() {\n\tlong long res = 0;\n\tlong long l = 1 , r = 1000LL * 1000 * 1000 * 1000 * 1000 + 1912;\n\twhile (l <= r) {\n\t\tlong long mid = (l + r) >> 1;\n\t\tif (check(mid)) {\n\t\t\tres = mid;\n\t\t\tl = mid + 1;\n\t\t} else r = mid - 1;\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n   // freopen(\"./baumkuchen.inp\" , \"r\" , stdin);\t\n   \tReadData();\n   \tProcess();\n\n    return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst vi emp;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint n;\nvl a;\n\nint main(){\n\tcin>>n;\n\ta=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=1;i<n;i++) a[i]+=a[i-1];\n\tll ans=0,sum=a[n-1];\n\tfor(int i=0;i<n;i++){\n\t\tint Im=lower_bound(a.begin(),a.end(),(a[i]+sum/3)%sum)-a.begin();\n\t\tint IM=lower_bound(a.begin(),a.end(),(a[i]+sum/3*2)%sum)-a.begin();\n\t\tfor(int j=Im-1;j<Im+1;j++) for(int k=IM-1;k<IM+1;k++){\n\t\t\tll A=(a[(j+n)%n]-a[i]+sum)%sum;\n\t\t\tll B=(a[(k+n)%n]-a[(j+n)%n]+sum)%sum;\n\t\t\tans=max(ans,min(A,min(B,sum-A-B)));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\t\tfor (int j = i; j <= n + i + 1; j++) {\n\t\t\tif (s[(j - 1) % n + 1] >= B) { B2 = s[(j - 1) % n + 1]; d = (j - 1) % n + 1; break; }\n\t\t}\n\t\tfor (int j = i; j <= n + i + 1; j++) {\n\t\t\tif (s[(j - 1) % n + 1] >= C) { C2 = s[(j - 1) % n + 1]; e = (j - 1) % n + 1; break; }\n\t\t}\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = lower_bound(all(cuts), cuts[j] + rem) - cuts.begin();\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int N=20010;\nint a[N];\nint n, d, e, i, m, s, j, k;\n\nint main(){\n\tcin >>n;\n\td=0;\n\tfor (i=0; i<n; i++){\n\t\tcin >>a[i];\n\t\ta[i+n]=a[i];\n\t\td+=a[i];\n\t}\n\tm=0;\n\tfor (i=0; i<n; i++){\n\t\ts=a[i];\n\t\tif (3*s>d) break;\n\t\te=0;\n\t\tfor (k=1; k<n; k++){\n\t\t\te+=a[i+k];\n\t\t\tif (e>=s && d-e-s>=s){\n\t\t\t\tm=max(m, s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (j=1; j<n; j++){\n\t\t\ts+=a[i+j];\n\t\t\tif (3*s>d) break;\n\t\t\te=0;\n\t\t\tfor (k=1; k<n-j; k++){\n\t\t\t\te+=a[i+j+k];\n\t\t\t\tif (e>=s && d-e-s>=s){\n\t\t\t\t\tm=max(m, s);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout <<m<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n + n) if (cuts[k] - cuts[j] >= (sum + 2) / 3)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n + 1)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = ceil(double(sum - size) / 2.0);\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[200001];\n\nbool check(long long x)\n{\n\tint l = 0, r = 1;\n\tfor (; r <= n; r++){\n\t\tif (a[r] - a[l] < x) continue;\n\t\twhile (a[r] - a[l + 1] >= x) l++;\n\t\t\n\t\tint tail = l + n;\n\t\tint mid = lower_bound(a + l + 1, a + tail + 1, (a[r] - a[l]) * 2 + a[l]) - a;\n\t\t\n\t\tif (mid == tail + 1) continue;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\", l, r, mid, tail);\n\t\t\n\t\tif (\n\t\t\tr != mid &&\n\t\t\tmid != tail &&\n\t\t\ta[mid] - a[r] >= a[r] - a[l] &&\n\t\t\ta[tail] - a[mid] >= a[r] - a[l]\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\t\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\t\n\tlong long l = 0, r = 1000000000LL * 100000LL;\n\twhile (l <= r){\n\t\tlong long mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\t\n\tprintf(\"%d\\n\", r);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(ll l, ll r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, ll s) {\n    ll n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    if (r == n) return P(s, L);\n    return P((s+r)%n, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d;\n            P p = search(m, i); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            sd += len(pos, i);\n            if (sd == L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n#define INF 1000000000000000ll\n#define pb push_back\nll A[100100];\nvector<ll> a;\nint N;\nll sum;\nbool C(ll x)\n{\n\tvector<ll>::iterator it;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tll f = a[i];\n\t\tit = lower_bound(a.begin(),a.end(),f+x);\n\t\tif(it==a.end())continue;\n\t\tll s = *it;\n\t\tit = lower_bound(a.begin(),a.end(),s+x);\n\t\tif(it==a.end())continue;\n\t\tll t = *it;\n\t\tit = lower_bound(a.begin(),a.end(),t+x);\n\t\tif(it==a.end())continue;\n\t\tll ff = *it;\n\t\tif(ff-f<=sum)return true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%lld\",&A[i]);\n\tfor(int i=1;i<N;i++)A[i]+=A[i-1];\n\tsum=A[N-1];\n\ta.pb(0);\n\tfor(int i=0;i<N;i++)a.pb(A[i]);\n\tfor(int i=0;i<N;i++)a.pb(A[i]+sum);\n\tfor(int i=0;i<a.size();i++)cout << i << \" \" << a[i] << endl;\n\tll l=0,r=INF;\n\twhile(r-l>1)\n\t{\n\t\tll mid = (l+r)/2ll;\n\t\tif(C(mid))l = mid;\n\t\telse r = mid;\n\t}\n\tprintf(\"%lld\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n\nint n, p, a[200005], pre[200005];\nll lo=1, mid, hi, c;\nbool check(ll L){\n    p=0; c=0;\n    drain(pre);\n    fox(l, n*2){\n        c+=a[l];\n        while(p<=l && c-a[p]>=L){\n            c-=a[p];\n            p++;\n        }\n        if (c<L) pre[l]=-(1 << 30);\n        else {\n            pre[l]=p;\n            //cout << pre[l] << ' ';\n            if (pre[l]>0 && pre[pre[l]-1]-1>=0 && l-pre[pre[pre[l]-1]-1]+1<=n) return 1;\n            continue;\n        }\n        //cout << pre[l] << ' ';\n    }\n    return 0;\n}\nint main(){\n    cin >> n;\n    fox(l, n){\n        cin >> a[l];\n        a[l+n]=a[l];\n    }\n    hi=1LL*n*MN;\n    //cout << check(6);\n    //return 0;\n    while(lo<hi){\n        mid=(lo+hi+1)/2;\n        //cout << mid << endl;\n        if (check(mid)) lo=mid;\n        else hi=mid-1;\n        //cout << endl;\n    }\n    cout << lo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<ll> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tvector<ll> pos = { 0 };\n\tfor (int i = 0; i < N * 3; i++) {\n\t\tpos.push_back(pos.back() + A[i % N]);\n\t}\n\tll lb = 1, ub = 1e17;\n\twhile (ub - lb > 1) {\n\t\tll m = (lb + ub) / 2;\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tbool f = true;\n\t\t\tint p = i;\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tp = lower_bound(pos.begin(), pos.end(), pos[p] + m) - pos.begin();\n\t\t\t\tif (p == (int)pos.size()) {\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f && p - i <= N) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tlb = m;\n\t\t}\n\t\telse {\n\t\t\tub = m;\n\t\t}\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\n\nsigned main() {\n\tint n;\n\n\tscanf(\"%d\", &n);\n\n\tvector<ll> bam(n+1);\n\tll sum = 0;\n\tREP(i, n) {\n\t\tscnaf(\"%lld\", &bam[i+1]);\n\t\tsum += bam[i+1];\n\t}\n\tREP(i, n) {\n\t\tbam[i+1] += bam[i];\n\t}\n\n\tll l = 0, r = sum/3+3;\n\n\twhile (1) {\n\t\tll mid = (l + r) / 2;\n\t\tbool f = 0;\n\t\tREP(i, n) {\n\t\t\tauto itr = lower_bound(bam.begin()+i,bam.end(), mid + bam[i]);\n\t\t\tif (itr == bam.end())\n\t\t\t\tbreak;\n\t\t\tauto bufi = itr;\n\t\t\tbufi++;\n\t\t\tauto itr2 = lower_bound(bufi, bam.end(), mid + *itr);\n\t\t\tif (itr2 != bam.end()) {\n\t\t\t\tif ((bam[i] + sum - *itr2) >= mid) {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t\tif (r-l <= 1) {\n\t\t\tprintf(\"%d\\n\", l);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define st first\n#define nd second\n#define mp make_pair\n#define space << \" \" <<\n#define END << endl\n#define pb push_back\n#define fo(i,n) for(int i = 0; i<n; ++i)\n#define ff(i,n) for(int i = 1; i<n; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pi;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> pl;\ntypedef vector<pil>vil;\n\nconst int N = 1e5 + 100;\nll a[N]; int n;\n\nll sum(int u, int v)\n{\n    if(u <= v) return  a[v] - (u==0 ? 0 : a[u-1]);\n    else return a[n-1] - ((u==0?0:a[u-1]) - a[v]);\n}\n\nbool check1(int num ,int t, int v)\n{\n    if(sum(t,(t+num-1)%n) >= v) return 1;\n    else return 0;\n}\n\nbool check(int u, int far)\n{\n    ll v = sum(u,(u+far-1)%n);\n    int t = (u + far) % n;\n    int l = 1;\n    int r = n - far - 1;\n    while( r - l > 1)\n    {\n        int mid = (l + r)/ 2;\n        if(check1(mid,t,v)) r = mid;\n        else l = mid;\n    }\n    if(check1(l,t,v) && a[n-1] - sum(t,(l+t-1)%n) - v >= v) return 1;\n    else if(check1(r,t,v) && a[n-1] - sum(t,(r+t-1)%n) - v >= v) return 1;\n    else return 0;\n}\n\nll work(int u)\n{\n    int l = 1;\n    int r = n-2;\n    //if(sum(u,(u+r-1)%n))\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(check(u,mid)) l = mid;\n        else r = mid;\n    }\n    //cout <<u space check(u,r) space r space check(u,l) space l << endl;\n    if(check(u,r)) return sum(u,(u+r-1)%n);\n    else return sum(u,(u+l-1)%n);\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n; fo(i,n) cin >> a[i]; fo(i,n) if(i) a[i] = a[i-1] + a[i];\n    ll ans = 0; fo(i,n) { ans = max(ans , work(i));  }\n    cout << ans << endl;\n    //cout << sum(4,2) << endl;\n    //ll ans = work(0); cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  \n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m]-A[b-1])r=m;\n    else l=m+1;\n  }\n  \n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    \n    cut2--;\n    \n    cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  for(int i=0;i<2*n;i++)cout<<A[i]<<' ';\n  cout<<endl;\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n//ちょっと気まぐれだが、O(N^2logN)の枝刈りで通してみたくなったからそれで通す。→無理でした。\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE 50000\n#define EPS 4000\n#define TO_OUTSIDE 1500\n#define IS_NOT_EVEN_HOBBY 76573\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n//A[medi]-A[st] >= Xとなる最小のmediを返す。\nint seach2( int st, int ed, long long X ){\n\tint s=st,e=ed,medi;\n\twhile( s<=e ){\n\t\tmedi= (s+e)>>1;\n\t\tif( A[medi]-A[st] < X )\n\t\t\ts=medi+1;\n\t\tif( A[medi]-A[st] >= X ){\n\t\t\tif( A[medi-1]-A[st] < X )\n\t\t\t\tbreak;\n\t\t\te=medi-1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint solve( long long X ){\n\tint i,j,k;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tj = seach2(i,N+i,X);\n\t\t//できるだけ真ん中で切る\n\t\tk = seach1(j,N+i);\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll sum[200001];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<ll> baumkuchen;\n\n    memset(sum,0x3f,sizeof(sum));\n    sum[0] = 0;\n    for(int i=0;i<N;i++){\n      ll width;\n      scanf(\"%lld\",&width);\n      baumkuchen.push_back(width);\n      sum[i+1] = sum[i] + width;\n    }\n    \n    for(int i=0;i<N;i++){\n      sum[N + i + 1] = sum[N] + sum[i + 1];\n    }\n\n    ll lhs = 0;\n    ll rhs = 100000000000000LL;\n    for(int round = 0; round < 50; round++){\n      ll mid = lhs + (rhs - lhs) / 2LL;\n\n      bool isok = false;\n      for(int i=0;i<N;i++){\n        ll offset = sum[i];\n        int div_idx = lower_bound(sum,sum + 200001,offset + mid) - sum;\n        div_idx = lower_bound(sum,sum + 200001,sum[div_idx] + mid) - sum;\n        div_idx = lower_bound(sum,sum + 200001,sum[div_idx] + mid) - sum;\n        if(div_idx <= i + N){\n          isok = true;\n          break;\n        }\n      }\n      if(isok){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n\n    printf(\"%lld\\n\",lhs);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 100000000000000\ntypedef long long Int;\nint N;\nInt A[MAX_N * 2 + 1];\n\nbool CC(int a, int b, Int x){\n\treturn A[b] - A[a] >= x;\n}\n\nbool C(Int x){\n\tint lb, ub, left;\n\tbool cut;\n\tfor(int i = 0; i <= N; i++){\n\t\tleft = i; lb = i; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tleft = ub; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tleft = ub; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tif(ub - i < N + 1) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tA[0] = 0;\n\tscanf(\"%lld\", &A[1]);\n\tA[N + 1] = A[1];\n\tfor(int i = 2; i <= N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i] += A[i - 1];\n\t\tA[i + N] = A[i];\n\t}\n\tfor(int i = N + 1; i <= N * 2; i++){\n\t\tA[i] += A[N];\n\t}\n\t\n\tInt lb = 0, ub = INF;\n\twhile(ub - lb > 1){\n\t\tInt mid = (lb + ub) / 2;\n\t\tif(C(mid)) lb = mid;\n\t\telse ub = mid;\n\t}\n\t\n\tprintf(\"%lld\\n\", lb);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\t/*s1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\tt = *lower_bound(a, a+MAX, s2+m);\n\t\tif(m == 216)printf(\"%lld %lld %lld %lld\\n\", s1, s2, t, total+sum-s2);*/\n\t\twhile(a[l1]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t\tl1++;\n\t\t}\n\t\twhile(a[l2]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t\tl2++;\n\t\t}\n\t\t//printf(\"%lld %lld\\n\", total-(a[l2]-a[r]), m);\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tr++;\n\t\t\tsum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t\t//printf(\"%d \", a[i]);\n\t}\n\ttotal = a[n];\n\t//printf(\"\\n\");\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\t//printf(\"%lld\", total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tREP(k, right + 1, n)\n\t\t\t{\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\tif (tmin > ttmin) break;\n\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nstruct BIT {\n\tvector<int> v;\n\tint n;\n\tBIT(int N) { n = N + 1; v.resize(n); }\n\tint sum(int idx) {\n\t\tint ret = 0;\n\t\tfor (int i = idx + 1; i > 0; i -= i & -i) ret += v[i];\n\t\treturn ret;\n\t}\n\tint sum(int from, int to) {\n\t\treturn sum(to) - sum(from - 1);\n\t}\n\tvoid add(int idx, int num) {\n\t\tfor (int i = idx + 1; i < n; i += i & -i) v[i] += num;\n\t}\n};\n\nsigned main() {\n\tint n; cin >> n;\n\tvector<int> as(n);\n\tBIT bit(n + n);\n\trep (i, n) {\n\t\tint x;  scanf(\"%d\", &x);\n\t\tbit.add(i, x);\n\t\tbit.add(i + n, x);\n\t}\n\tint len = bit.sum(n - 1);\n\tint left = 0, right = 0;\n\tint ans = 0;\n\twhile (left < n) {\n\t\tif (right < left) right = left;\n\t\tint s = bit.sum(left, right);\n\t\tint end = left + n;\n\t\tint rem = len - s;\n\t\tint b = right + 1, e = end;\n\t\twhile (b + 1 < e) {\n\t\t\tint mid = (b + e) / 2;\n\t\t\tint x = bit.sum(right + 1, mid);\n\t\t\tif (x < s) b = mid;\n\t\t\telse e = mid;\n\t\t}\n\t\tif (bit.sum(right + 1, right + 1) > s) b = right;\n\t\tint r1 = bit.sum(right + 1, b + 1);\n\t\tint r2 = rem - r1;\n\t\tif (s <= r1 && s <= r2) {\n\t\t\tmaxup(ans, s);\n\t\t\tright++;\n\t\t}\n\t\telse {\n\t\t\tleft++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint ini = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[ini] <= one_third){\n\t\tpiece1 += (long long int)A[ini];\n\t\tini++;\n\t}\n\t\n\tint piece2_i = ini;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[ini];\n\t\tini++;\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = ini;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef complex<double> dcomplex;\ninline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}\n\n//ラジアンを度に変換-----------------------------------------------------\ndouble rad_deg(double rad){\n\tif(rad >= 0)return rad*180.0/acos(-1);\n\telse return (2*acos(-1)+rad)*180/acos(-1);\n}\n\nint main(void){\n\tdouble pi = acos(-1);\n\t//入力--------------------------------------------------------------\n\tint N;\n\tcin >> N;\n\tint data[N];\n\tlong int sum = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\t//極座標の保持\n\tdcomplex pol[N];\n\tdouble sum_t = 0;\n\tfor(int i=0; i<N; i++){\n\t\tpol[i] = polar(1.0,2.0*pi*sum_t/sum);\n\t\tsum_t += data[i];\n\t}\n\t//適当なmin_argを与える----------------------------------------------\n\tdouble min_arg = 0;\n\tdcomplex p = pol[0];\n\tdcomplex q,r;\n\tdouble theta1 = 0,theta2,theta3;\n\tdouble a,b,d;\n\tint tmp;\n\tfor(int i=1;i<N;i++){\n\t\tq = pol[i];\n\t\tif (rad_deg(arg(q)) >= 120){\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\ttmp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int k=tmp; k<N; k++){\n\t\tr = pol[k];\n\t\ttheta3 = rad_deg(arg(r));\n\t\tb = theta3 - theta2;\n\t\td = 360-a-b;\n\t\t//高速化?\n\t\t//3つ目の条件いらないかも\n\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\tif(d < b) break;\n\t}\n\t\n\t//初期位置の保存-----------------------------------------------------\n\tint judge1 = 0;\n\tint judge2 = 0;\n\tint tmp1,tmp2;\n\tp = pol[1];\n\ttheta1 = 0;\n\tfor (int j=1; j<N-1; j++){\n\t\tif(judge1 == 0){\n\t\t\tq = pol[j];\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\tif(a >= min_arg){\n\t\t\t\ttmp1 = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k = tmp+1; k<N; k++){\n\t\tif(judge2 == 0){\n\t\t\tr = pol[k];\n\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\tb = theta3 - theta2;\n\t\t\tif(b >= min_arg){\n\t\t\t\ttmp2 = k;\n\t\t\t\td = 360-a-b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//ループ処理--------------------------------------------------------\n\tint judge = 0;\n\t//pをiに固定\n\tfor(int i=0; i<N-2; i++){ \n\t\tp = pol[i];\n\t\ttheta1 = rad_deg(arg(p));\n\t\t//tmp1の更新\n\t\tif(i > 1){\n\t\t\twhile(theta2 - theta1 < min_arg && tmp1 <= N-2){\n\t\t\t\ttmp1 += 1;\n\t\t\t\tq = pol[tmp1];\n\t\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\t\tjudge = 1;\n\t\t\t}\n\t\t}\n\t\t//高速化?\n\t\tif(360-theta1 < min_arg){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int j = tmp1; j<N-1; j++){\n\t\t\tq = pol[j];\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\t//tmp1の更新\n\t\t\tif(judge == 1){\n\t\t\t\twhile(theta3 - theta2 < min_arg && tmp2 <= N-1){\n\t\t\t\t\ttmp2 += 1;\n\t\t\t\t\tr = pol[tmp2];\n\t\t\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//高速化?\n\t\t\tif(360-theta2 < min_arg){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int k=tmp2; k<N; k++){\n\t\t\t\tr = pol[k];\n\t\t\t\ttheta3 = rad_deg(arg(r));\n\t\t\t\tb = theta3 - theta2;\n\t\t\t\td = 360-a-b;\n\t\t\t\t//高速化?\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t\t//cout << a << \",\" << b << \",\" << d << endl;\n\t\t\t\tif(d < b || (a < theta1 && a < b)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//------------------------------------------------------------------\n\n\tcout << (long int)(round((min_arg/360.0)*sum)) << endl;;\n\t\n\t\nreturn 0;\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nll N;\nll A[200001];\nll sum[200001];\nll ans;\n\nbool ok(ll x){//\n\tll d1,d2,mid,lb,ub;\n\trep(st,N){// [st,st+N)??§?????????\n\t\tub=st+N;\n\t\tlb=st;\n\t\twhile(ub-lb>1){\n\t\t\tmid=(ub+lb)/2;\n\t\t\tif( sum[mid]-(st-1<0?0:sum[st-1]) >=x ) ub=mid;\n\t\t\telse lb=mid;\n\t\t}\n\t\tif(ub>=st+N-2) continue;\n\t\td1=ub+1;\n\t\tub=st+N;\n\t\tlb=d1;\n\t\twhile(ub-lb>1){\n\t\t\tmid=(ub+lb)/2;\n\t\t\tif( sum[mid]-sum[d1-1] >=x ) ub=mid;\n\t\t\telse lb=mid;\n\t\t}\n\t\tif(ub>=st+N-1) continue;\n\t\td2=ub+1;\n\t\tif(sum[st+N-1]-sum[d2-1]>=x) return 1;\n\t}\n\treturn 0;\n}\n\n\nint main()\n{\n\tcin>>N;\n\trep(i,N) cin>>A[i];\n\trep(i,N) A[i+N]=A[i];\n\tA[2*N]=0;\n\tsum[0]=A[0];\n\trep1(i,2*N) sum[i]=A[i]+sum[i-1];\n\tll ub=1e17,lb=0;\n\twhile(ub-lb>1){\n\t\tll mid=(ub+lb)/2;\n\t\tif(ok(mid)) lb=mid;\n\t\telse ub=mid;\n\t}\n\tcout<<lb<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N;\nlong long A[200010];\nlong long T[200010];\n\nbool f(long long X) {\n  for (int i=0; i<N; i++) {\n    int j = i;\n    j = lower_bound(T+j, T+i+N, X + (j > 0 ? T[j-1] : 0)) - T;\n    if (j == i+N) continue;\n    j++;\n\n    j = lower_bound(T+j, T+i+N, X + (j > 0 ? T[j-1] : 0)) - T;\n    if (j == i+N) continue;\n    j++;\n\n    if (T[i+N-1] - T[j-1] >= X) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    long long a;\n    cin >> a;\n    A[i] = A[i+N] = a;\n  }\n  T[0] = A[0];\n  for (int i=1; i<N+N; i++) {\n    T[i] = T[i-1] + A[i];\n  }\n\n  long long lo = 0, hi = T[N+N-1];\n  while (hi - lo > 1) {\n    long long m = (lo + hi) / 2;\n    if (f(m)) lo = m;\n    else      hi = m - 1;\n  }\n  if (f(hi)) lo = hi;\n\n  cout << lo << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tlong long check();\n\tbool check_bool;\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n\tcheck_bool = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set)delete[] A;\n\tif (set)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcheck_bool = true;\n\treturn min_value;\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tmin_value = memo[cut_b];\n\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (min_value > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\tlong long min_value;\n\n\tset_value = set_board();\n\tif (check_bool)return set_value;\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\tmin_value = memo[cut_b] - memo[cut_a];\n\t\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (min_value > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n\t\tif (cut_c == N || cut_c == 2 * N || cut_c == 3 * N)break;\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll in[200000];\nll ruisekiwa[200001];\nll over;\n\nll getmin(int l, int r) {\n\tll a, b, c, ans = 0;\n\ta = ruisekiwa[r] - ruisekiwa[l];\n\tb = *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tc = ruisekiwa[l + N] - *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tans = max(ans, min(a, min(b, c)));\n\treturn ans;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t\tin[N + i] = in[i];\n\t}\n\tfor (int i = 1; i <= N * 2; i++) {\n\t\truisekiwa[i] = ruisekiwa[i - 1] + in[i - 1];\n\t}\n\n\tll ans = 0;\n\tover = (ruisekiwa[N] - ruisekiwa[0]) / 3;\n\tfor (int l = 0, r = 0;(l < N); l++) {\n\t\tfor (; ruisekiwa[r] - ruisekiwa[l] < over; r++)ans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r + 1));\n\t\tans = max(ans, getmin(l, r));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nll sum[300000];\nint N;\nll A[100010];\n\ninline bool check2(int sp,int cur,ll mini){ return sum[cur] - sum[sp-1] >= mini; }\n\nbool check(ll mini){\n  if( sum[N] < mini * 3LL ) return false;\n  REP(sp,1,N+1) {\n    int cur = sp;\n    int end = sp + N; // )\n    bool success = true;\n    rep(i,3){\n      ll remain = sum[end-1] - sum[cur-1];\n      if( remain < mini ) { success = false; break; }\n      int L = cur, R = cur+N-1;\n      while( L + 1 < R ){\n\tint M = ( L + R ) / 2;\n\tif( check2(cur,M,mini) ) R = M;\n\telse                     L = M;\n      }\n      assert( sum[R] - sum[cur-1] >= mini );\n      cur = R+1;\n    }\n    if( success ) return true;\n  }\n  return false;\n}\n\nint main(){\n  cin >> N;\n  rep(i,N) cin >> A[i];\n  sum[0] = 0;\n  REP(i,1,N+1) sum[i] = sum[i-1] + A[i-1];\n  REP(i,N+1,2*N+1) sum[i] = sum[i-1] + A[i-N-1];\n  ll L = 0, R = 1000000000000000000LL;\n  while( R - L ) {\n    ll M = ( L + R ) / 2LL;\n    if( check(M) ) L = M + 1LL;\n    else           R = M;\n  }\n  cout << L-1LL << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece1(int _i2, ull *_piece1, const int _N, const int _i1, const ull _one_third_size, const int *_A){\n\tfor( ; _i2<_i1+_N-2; ){\n\t\t*_piece1 += _A[_i2%_N];\n\t\t_i2++;\n\t\tif(*_piece1 >= _one_third_size) break;\n\t}\n\treturn _i2;\n}\n\null CalcMinimunPiece(const int _i1, const int _i2, const int _N, const int *_A, const ull _half_size, const ull _two_third_size){\n\tull piece2 = 0;\n\tull tmp = 0;\n\tfor(int i3=_i2; i3<_i1+_N-1; i3++){\n\t\tpiece2 = tmp;\n\t\ttmp += _A[i3%_N];\n\t\tif(tmp > _half_size) break;\n\t}\n\tif(tmp <= _half_size) return tmp;\n\tull piece3 = _two_third_size - tmp;\n\n\tif(piece2 > piece3) tmp = piece2;\n\telse tmp = piece3;\n\n\treturn tmp;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\t\n\t/*\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size;\n\tif(total_size % 3 == 0) one_third_size = total_size / 3;\n\telse one_third_size = total_size / 3 + 1;\n\n\tull answer = 0;\n\t\n\tfor(int i1=0; i1<N; i1++){\n\t\tull piece1 = 0;\n\t\tint i2;\n\t\tfor(i2=i1; i2<i1-2+N; i2++){\n\t\t\tpiece1 += A[i2%N];\n\t\t\tif(piece1 >= one_third_size) break;\n\t\t}\n\t\tif(piece1 < one_third_size) continue;\n\t\ti2++;\n\n\t\tull two_third_size = total_size - piece1;\n\t\tull half_size;\n\t\tif(two_third_size % 2 == 0) half_size = two_third_size / 2;\n\t\telse half_size = two_third_size / 2 + 1;\n\n\t\tull tmp = 0;\n\t\tfor(int i3=i1-1+N; i3>i2; i3--){\n\t\t\ttmp += A[i3%N];\n\t\t\tif(tmp >= half_size) break;\n\t\t}\n\t\tif(tmp < half_size){\n\t\t\tif(tmp > answer) answer = tmp;\n\t\t\tcontinue;\n\t\t}\n\t\tull piece2 = two_third_size - tmp;\n\n\t\ttmp = 0;\n\t\tfor(int i3=i2; i3<i1-1+N; i3++){\n\t\t\ttmp += A[i3%N];\n\t\t\tif(tmp >= half_size) break;\n\t\t}\n\t\tif(tmp < half_size){\n\t\t\tif(tmp > answer) answer = tmp;\n\t\t\tcontinue;\n\t\t}\n\t\tull piece3 = two_third_size - tmp;\n\n\t\tif(piece2 > piece3) tmp = piece2;\n\t\telse tmp = piece3;\n\t\t\n\t\tif(tmp > answer) answer = tmp;\n\t}\n\t\n\tdelete[] A;\n\n\tcout << answer << endl;\n\t/*/\n\tint *A = new int[N];\n\tull total_size = 0;\n\tint A_max = 0;\n\tint i1 = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif(A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1 = i;\n\t\t}\n\t}\n\n\tull one_third_size;\n\tif(total_size % 3 == 0) one_third_size = total_size / 3;\n\telse one_third_size = total_size / 3 + 1;\n\n\tull piece1 = 0;\n\tint i2 = i1;\n\ti2 = CalcPiece1(i2, &piece1, N, i1, one_third_size, A);\n\t/*for( ; i2<i1+N-2; ){\n\t\tpiece1 += A[i2%N];\n\t\ti2++;\n\t\tif(piece1 >= one_third_size) break;\n\t}*/\n\n\tull two_third_size = total_size - piece1;\n\tull half_size = two_third_size / 2;\n\n\tull answer = 0;\n\tif(A[i2%N] > half_size) answer = two_third_size - A[i2%N];\n\telse{\n\t\t/*ull piece2 = 0;\n\t\tull tmp = 0;\n\t\tfor(int i3=i2+1; i3<i1+N; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[(i3-1)%N];\n\t\t\tif(tmp > half_size) break;\n\t\t}\n\t\tull piece3 = two_third_size - tmp;\n\t\t\n\t\tif(piece2 > piece3) tmp = piece2;\n\t\telse tmp = piece3;\n\t\tanswer = tmp;*/\n\t\tanswer = CalcMinimunPiece(i1, i2, N, A, half_size, two_third_size);\n\t}\n\n\tfor(int i=i1+1; i<i1+N; i++){\n\t\tpiece1 -= A[(i-1)%N];\n\t\tif(piece1 < one_third_size){\n\t\t\ti2 = CalcPiece1(i2, &piece1, N, i, one_third_size, A);\n\t\t\t/*for( ; i2<i+N-2; ){\n\t\t\t\tpiece1 += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif(piece1 >= one_third_size) break;\n\t\t\t}*/\n\t\t}\n\n\t\ttwo_third_size = total_size - piece1;\n\t\thalf_size = two_third_size / 2;\n\n\t\tif(A[i2%N] > half_size){\n\t\t\tull piece3 = two_third_size - A[i2%N];\n\t\t\tif(piece3 > answer) answer = piece3;\n\t\t}\n\t\telse{\n\t\t\t/*ull piece2 = 0;\n\t\t\tull tmp = 0;\n\t\t\tfor(int i3=i2+1; i3<i+N; i3++){\n\t\t\t\tpiece2 = tmp;\n\t\t\t\ttmp += A[(i3-1)%N];\n\t\t\t\tif(tmp > half_size) break;\n\t\t\t}\n\t\t\tull piece3 = two_third_size - tmp;\n\n\t\t\tif(piece2 > piece3) tmp = piece2;\n\t\t\telse tmp = piece3;*/\n\t\t\tull tmp = CalcMinimunPiece(i, i2, N, A, half_size, two_third_size);\n\t\t\tif(tmp > answer) answer = tmp;\n\t\t}\n\t}\n\tdelete[] A;\n\n\tcout << answer << endl;\n\t//*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    int A[100000];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    int mi=0;\n    for (int i=0; i<num; i++) {\n        for (int j=i; j<num; j++) {\n            for (int k=j; k<num; k++) {\n                \n                int aa=0,bb=0,cc=0;\n                for (int i2=i; i2< j; i2++) {\n                    aa+=A[i2];\n                }\n                \n                for (int i3=j; i3< k; i3++) {\n                    bb+=A[i3];\n                }\n                \n                for (int i4=k; i4< num; i4++) {\n                    cc+=A[i4];\n                }\n                for (int i4=0; i4< i; i4++) {\n                    cc+=A[i4];\n                }\n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT binary_search(function<bool(T)> func, T include, T exclude)\n{\n  while (abs(exclude - include) > 1)\n  {\n    auto middle = (include + exclude) / 2;\n    (func(middle) ? include : exclude) = middle;\n  }\n  return include;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nbool check(vector<ll> const& a, ll m) {\n    const int N = a.size() / 2;\n    bool ok = false;\n    for(int i=0; i<N; ++i) {\n        int j = lower_bound(a.begin()+i, a.begin()+i+N+1, a[i]+m) - a.begin();\n        int k = lower_bound(a.begin()+j, a.begin()+i+N+1, a[j]+m) - a.begin();\n        if(a[j] - a[i] >= m && a[k] - a[j] >= m && a[i+N] - a[k] >= m) {\n            ok = true;\n            break;\n        }\n    }\n    return ok;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ll> a(2*N+1);\n    for(int i=1; i<=N; ++i) {\n        cin >> a[i];\n        a[i+N] = a[i];\n    }\n    for(int i=1; i<2*N+1; ++i) {\n        a[i] += a[i-1];\n    }\n\n    ll lb = 0, ub = (a[N] + 2) / 3;\n    while(ub - lb > 1) {\n        ll m = (ub + lb) / 2;\n        if(check(a, m)) {\n            lb = m;\n        } else {\n            ub = m;\n        }\n    }\n    cout << lb << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=0;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\twhile (t<s+N && a<=ans){\n\t\t\tt++;\n\t\t\ta+=A[(t-1)%N];\n\t\t}\n\t\tif (t==s+N) break;\n\t\t//aがansを更新できるか\n\t\tauto p=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\tif (p!=sum+s+N){\n\t\t\t//見つかった\n\t\t\tb=*p-sum[t-1];\n\t\t\tc=sum[N-1]-b-a;\n\t\t\tif (c>=a){\n\t\t\t\t//aが最小値\n\t\t\t\tans=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans=max(ans,c);\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\n#ifndef  LLONG_MAX\n#define LLONG_MAX 9223372036854775807\n#endif\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left != 1) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>                                                        \n                                                                                \n#define int long long                                                           \n                                                                                \nusing namespace std;                                                            \n                                                                                \nint n;                                                                          \nint a[200001];                                                                  \nint sum[200001];                                                                \n                                                                                \nbool bin_check(int x) {                                                         \n                                                                                \n    int p1 = 0, p2 = 0;                                                         \n    int sum1 = 0, sum2 = 0;                                                     \n                                                                                \n    // Shakutori                                                                \n    for(int i = 0; i < n; ++i) {                                                \n                                                                                \n        // 1                                                                    \n        while(sum1 < x) {                                                       \n            sum1 += a[p1];                                                      \n            if(i) sum2 -= a[p1];                                                \n            ++p1;                                                               \n        }                                                                       \n                                                                                \n        // 2                                                                    \n        if(!i) p2 = p1;                                                         \n        while(sum2 < x) {                                                       \n            sum2 += a[p2];                                                      \n            ++p2;                                                               \n        }                                                                       \n                                                                                \n        // 3                                                                    \n        if(sum[n + i] - sum[p2] >= x) {                                         \n            return true;                                                        \n        }                                                                       \n                                                                                \n        sum1 -= a[i];                                                           \n    }                                                                           \n                                                                                \n    return false;                                                               \n                                                                                \n}                                                                               \n                                                                                \nmain() {                                                                        \n                                                                                \n    cin >> n;                                                                   \n                                                                                \n    for(int i = 0; i < n; ++i) {                                                \n        cin >> a[i];                                                            \n        a[n + i] = a[i];                                                        \n    }                                                                           \n                                                                                \n    sum[0] = 0;                                                                 \n    for(int i = 1; i <= 2 * n; ++i) {                                           \n        sum[i] = sum[i - 1] + a[i - 1];                                         \n    }                                                                           \n                                                                                \n    int l = 0, m, r = sum[n] / 3;                                               \n    while(l < r - 1) {                                                          \n        m = (l + r) / 2;                                                        \n        if(bin_check(m)) {                                                      \n            l = m;                                                              \n        } else {                                                                \n            r = m - 1;                                                          \n        }                                                                       \n    }                                                                           \n                                                                                \n    cout << l << endl;                                                          \n}                                                                                "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\nbool ok(int first, long long len, const vector<long long> &a) {\n  const int second = lower_bound(a.begin() + first, a.end(), a[first] + len) - a.begin();\n  const int third  = lower_bound(a.begin() + second, a.end(), a[second] + len) - a.begin();\n  return third < a.size() && len <= a[first] + a.back() - a[third];\n}\n\nbool check(long long len, const vector<long long> &a) {\n  rep(i, a.size()) {\n\tif(ok(i, len, a)) return true;\n  }\n  return false;\n}\n\nint main(){\n  constexpr long long MAX_A = 1000000000;\n\n  int n;\n  cin >> n;\n\n  vector<long long> a(n + 1, 0);\n  REP(i, 1, n + 1) {\n\tcin >> a[i];\n  }\n\n  partial_sum(ALL(a), a.begin());\n\n  long long L = 0, R = n * MAX_A;\n  while(L + 1 < R) {\n\tconst long long M = (L + R) / 2;\n\tif(check(M, a)) {\n\t  L = M;\n\t}\n\telse {\n\t  R = M;\n\t}\n  }\n\n  cout << L << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0 + 1, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left+1, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left != 1) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tauto eval = [&](int k)\n\t\t{\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tint ttmin = min({ a, b, c });\n\t\t\tans = max(ans, ttmin);\n\t\t\treturn ttmin;\n\t\t};\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint x0 = right + 1, x3 = n;\n\t\t\twhile (x3 - x0 > 1)\n\t\t\t{\n\t\t\t\tint x1 = x0 + (x3 - x0) / 3;\n\t\t\t\tint e1 = eval(x1);\n\t\t\t\tint x2 = x1 + (x3 - x0) / 3;\n\t\t\t\tint e2 = eval(x2);\n\t\t\t\tif (x1 < x2) x0 = x1;\n\t\t\t\telse x3 = x2;\n\t\t\t\ttmin = max({ tmin, e1, e2 });\n\t\t\t}\n\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint main(){\n\tint i,j,k;\n\t\n\tscanf(\"%d\",&N);\n\tif( N > 8000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\tfor( i = 0; i < N; i++ ){\n\t\tfor( j = i+1; j < N; j++ ){\n\t\t\t//できるだけ真ん中で切る\n\t\t\tk = seach1(j,i+N);\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t\tk--;\n\t\t\tans = max( ans, min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) );\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long int mi=0;\n    \n    for (int i2=1; i2< num; i2++) {\n        A[i2]=A[i2]+A[i2-1];\n    }\n    \n    long int aa,bb,cc;\n    for (int i=0; i<num; i++) {\n        for (int j=i+1; j<num; j++) {\n            for (int k=j+1; k<num; k++) {\n                aa=A[k]-A[j];\n                bb=A[j]-A[i];\n                cc=A[num-1]-A[k]+A[i];\n                \n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nbool Check(const vector<int> &a,int m){\n\tREP(i,0,a.size()){\n\t\tint cnt=0,last=i;\n\t\tREP(i,0,3){\n\t\t\tint crt=last;\n\t\t\tint d=a[crt];\n\t\t\t++cnt;\n\t\t\twhile(cnt<=a.size()&&d<m){\n\t\t\t\tcrt=(crt+1)%a.size();\n\t\t\t\td+=a[crt];\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif(!(cnt<=a.size())) break;\n\t\t\tlast=(crt+1)%a.size(); \n\t\t}\n\t\tif(cnt<=a.size()) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tREP(i,0,N) cin >> A[i];\n\tint lb=0,ub=INF;\n\twhile(ub-lb>1){\n\t\tint mid=(lb+ub)/2;\n\t\tif(Check(A,mid)){\n\t\t\tlb=mid;\n\t\t}else ub=mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 2e5L + 11;\nll a[N];\n\nbool solve(ll lim, int n) {\n\tint j = 0, k = 0;\n\tfor(int i = 0; i < n; i ++) {\n\t\twhile(j < i + n && a[j] - a[i] < lim) j ++;\n\t\twhile(k < i + n && a[k] - a[j] < lim) k ++;\n\t\tif(a[i + n] - a[k] >= lim) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n;\n\tfor(int i = 1; i <= n; i ++) {\n\t\tcin >> a[i];\n\t\ta[i + n] = a[i];\n\t}\n\tpartial_sum(a , a + n + n + 1, a);\n\tll l = 0, r = 1e18L;\n\twhile(l + 1 < r) {\n\t\tll m = (l + r) / 2;\n\t\tif(solve(m, n))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << l << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[111111*2];\nlong long sum[111111*2];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] >= sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  s = e;\n  //printf(\":%lld %lld %lld %lld %d %d\\n\",lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  res = max(res,min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]));\n  return min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n  }\n  for( int j = 0; j < 2*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;s<n&&e<n;++e) {\n    while( e < n && C(s,e) >= sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }    \n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <stdlib.h>\nusing namespace std;\n\n#define debug 0\n\nint InArray[200000] = {0};\nint N = 0;\n\nlong long sumArray(int, int);\nlong long getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tint temp;\n#if debug\n\tFILE *inputFile = fopen(\"0600_in33.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\tcout << \"N: \" << N << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tfscanf(inputFile, \"%d\", &temp);\n\t\t//cout << temp << endl;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\tcout << endl;\n\tfclose( inputFile);\n#else\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n#endif\n\t\n\t// Calculate sum and average\n\tlong long sum = sumArray(0, N);\n\tlong long average = sum / 3;\n\n#if debug\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n#endif\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum, a3_sum;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1 + 1; a2 < N + 1; a2++){\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tlong average2 = (sum - (a1_sum - InArray[a2])) / 2;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2 + 1; a3 < a1 + N; a3++){\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3 - 1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong long sumArray(int start, int end)\n{\n\tlong long sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n//\t\tcout << \"i:\" << i << \"sum:\" << sum << endl;\n\t}\n//\tcout << sum << endl;\n//\tsystem(\"pause\");\n\treturn sum;\n}\n\nlong long getLocalMin(int p1, int p2, int p3)\n{\n\tlong long LocalMin = sumArray(p1, p2);\n\tlong long tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(p3, p1 + N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n#if debug\n//cout << \"getLocalMin(\" << p1 << \", \" << p2 << \", \" << p3 << \") = \" << LocalMin << endl;\n#endif\n\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define real() X\n#define imag() Y\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll sumsum[200002];\nll sums(int s,int e){\n\tif(s>e)\n\t\treturn 0;\n\treturn sumsum[e+1]-sumsum[s];\n}\nll divide(int ss,int ee){\n\tint s=ss;\n\tint e=ee;\n\tll maxim=0;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tmaxim=max(maxim,min(sums(ss,f),sums(f+1,ee)));\n\t\tif(sums(ss,f)<=sums(f+1,ee))\n\t\t\ts=f+1;\n\t\telse\n\t\t\te=f-1;\n\t}\n\treturn maxim;\n}\nint main() {\n\tll N,p,s,sum=0;\n\tvector<ll> baum;\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> p;\n\t\tbaum.push_back(p);\n\t\tsum+=p;\n\t\tsumsum[i+1]=sumsum[i]+p;\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N+i+1]=sumsum[N+i]+baum[i];\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N*2+i+1]=sumsum[N*2+i]+baum[i];\n\t}\n\tint head=0;\n\tll maxim=0;\n\tREP(snake,N){\n\t\twhile(sums(snake,head)*3<sum) head++;\n\t\tif(sums(snake+1,head)*3<sum){\n\t\t\tmaxim=max(maxim,divide((head+1)%N,(snake+N-1)%N+N*((head+1)%N>(snake-1))));\n\t\t}\n\t}\n\tcout << maxim << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<17;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        p2++;\n        int minb=V[p2]-V[p1];\n        int minc=V[N-1]-(mina+minb);\n        if(minb<mina||minc<mina)continue;\n        ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint ini = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[ini] <= one_third){\n\t\tpiece1 += (long long int)A[ini];\n\t\tini++;\n\t}\n\t\n\tint piece2_i = ini;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[ini];\n\t\tini++;\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = ini;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tauto eval = [&](int k)\n\t\t{\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\treturn min({ a, b, c });\n\t\t};\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint x0 = right, x3 = n;\n\t\t\twhile (x3 != x0)\n\t\t\t{\n\t\t\t\tint x1 = x0 + (x3 - x0) / 3;\n\t\t\t\tint e1 = eval(x1);\n\t\t\t\tint x2 = x1 + (x3 - x0) / 3;\n\t\t\t\tint e2 = eval(x2);\n\t\t\t\tif (x1 < x2) x0 = x1;\n\t\t\t\telse x3 = x2;\n\t\t\t}\n\t\t\ttmin = eval(x0);\n\t\t\tans = max(ans, tmin);\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,c2=0,c3=0;\n\tlong long int m=0,s=0,s1=0,s2;\n\tlong long int a[100000];\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> a[i];\n\t\ts+=a[i];\n\t}\n\tfor(int c1=0;c1<n;c1++){\n\t\twhile(s1<s/3){\n\t\t\ts1+=a[c2%n];\n\t\t\ts2-=a[c2%n];\n\t\t\tc2++;\n\t\t}\n\t\tif(c3<=c2){\n\t\t\tc3=c2+1;\n\t\t\ts2=a[c2%n];\n\t\t}\n\t\twhile(s2<(s-s1)/2){\n\t\t\ts2+=a[c3%n];\n\t\t\tc3++;\n\t\t}\n\t\tif(m<s-s1-s2){\n\t\t\tm=s-s1-s2;\n\t\t}\n\t\tc3--;\n\t\ts2-=a[c3%n];\n\t\tif(m<s2){\n\t\t\tm=s2;\n\t\t}\n\t\ts1-=a[c1%n];\n\t}\n\tcout << m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint n;\nlong long int a[200010];\n\nbool cansolve(long long int k)\n{\n\tfor(int i = 0; i < n; i++){\n\t\tint tmp1;\n\t\tif(i == 0) tmp1 = lower_bound(a + i, a + i + n, k) - a;\n\t\telse tmp1 = lower_bound(a + i, a + i + n, k + a[i - 1]) - a;\n\t\tint tmp2 = lower_bound(a + tmp1 + 1, a + i + n, k + a[tmp1]) - a;\n\t\t// cout << mid << \" \" << tmp1 << \" \" << tmp2 << endl;\n\t\tif(a[i + n - 1] - a[tmp2] >= k) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i + n] = a[i];\n\t}\n\tfor(int i = 1; i < 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\tlong long int l = 0, r = a[n - 1];\n\twhile(r - l > 1){\n\t\tlong long int mid = (l + r) / 2;\n\t\tif(cansolve(mid)) l = mid;\n\t\telse r = mid;\n\t}\n\tcout << l << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2回2分探索をしても良いことを、証明したいね。意味としてはなんとなく分かるけど。\n//2回2分探索できそうでできない例：AOJ542\n//ちょっと気まぐれだが、O(N^2logN)の枝刈りで通してみたくなったからそれで通す。→無理でした。\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define ごまえ 50000\n#define EPS 4000\n#define 向こう側 1500\n#define 趣味ですらない 76573\n\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[medi]-A[st] >= A[ed]-A[medi]となる最小のmediを返す。\nint seach1( int st, int ed ){\n\tint medi,s = st,e = ed;\n\t\n\twhile( s <= e ){\n\t\tmedi = (s+e)>>1;\n\t\tif( A[medi]-A[st] == A[ed]-A[medi] )\n\t\t\tbreak;\n\t\tif( A[medi]-A[st] > A[ed]-A[medi] ){\n\t\t\tif( A[medi-1]-A[st] < A[ed]-A[medi-1] )\n\t\t\t\tbreak;\n\t\t\te = medi-1;\n\t\t}\n\t\telse{\n\t\t\ts = medi+1;\n\t\t}\n\t}\n\treturn medi;\n}\n//A[medi]-A[st] >= Xとなる最小のmediを返す。\nint seach2( int st, int ed, long long X ){\n\tint s=st,e=ed,medi;\n\twhile( s<=e ){\n\t\tmedi= (s+e)>>1;\n\t\tif( A[medi]-A[st] < X )\n\t\t\ts=medi+1;\n\t\tif( A[medi]-A[st] >= X ){\n\t\t\tif( A[medi-1]-A[st] < X )\n\t\t\t\tbreak;\n\t\t\te=medi-1;\n\t\t}\n\t}\n\treturn medi;\n}\n\nint solve( long long X ){\n\tint i,j,k;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tj = seach2(i,N+i,X);\n\t\t//できるだけ真ん中で切る\n\t\tk = seach1(j,N+i);\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = ごまえ * 向こう側 * 趣味ですらない * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100010);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    \n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  REP(i, n) scanf(\"%lld\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  while(l+1<r){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b1 = 0, b2 = 0, b3 = 0, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = a[0][0];\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i][0];\n\t}\n\tbaum = a[n - 1][1];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tfor (int cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tfor (int cut3 = cut2 + 1; cut3 < n; cut3++){\n\t\t\t\tb1 = a[cut2][1] - a[cut1][1];\n\t\t\t\tb2 = a[cut3][1] - a[cut2][1];\n\t\t\t\tb3 = baum - a[cut3][1] + a[cut1][1];\n\t\t\t\tminb = MIN(MIN(b1, b2), b3);\n\t\t\t\tif (ans < minb){\n\t\t\t\t\tans = minb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<ll> a(n+1, 0);\n    for(int i = 1; i <= n; i++)  cin >> a[i];\n    for(int i = 1; i <= n; i++)  a[i] += a[i-1];\n    \n    ll l = 0, r = a[n];\n    // 1e5*log(1e5)*2*log2(1e15) ~~ 1.6e8\n    while(r-l > 1){\n        ll mid = (l+r)/2;\n        bool ok = false;\n        for(int i = 0; i < n; i++){\n            int j = lower_bound(a.begin(), a.end(), a[i]+mid)-a.begin();\n            if(j >= n)    continue;\n            int k = lower_bound(a.begin(), a.end(), a[j]+mid)-a.begin();\n            if(k == n+1)    continue;\n            ll last = a[n]-a[k]+a[i];\n            if(last >= mid){\n                ok = true;\n                break;\n            }\n        }\n        if(!ok)  r = mid;\n        else     l = mid;\n    }\n    cout << l << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=1e14;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n\tint fir=*lower_bound(ALL(sum),x);\n\tint sec=*lower_bound(ALL(sum),fir+x);\n\tint thi=*lower_bound(ALL(sum),sec+x);\n\tif(thi<=cnt)return true;\n\tREP(i,n){\n\t\tfir=*lower_bound(ALL(sum),sum[i]+x);\n\t\tsec=*lower_bound(ALL(sum),fir+x);\n\t\tthi=*lower_bound(ALL(sum),sec+x);\n\t\tif(thi<=sum[i]+cnt)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tcnt+=a[i];\n\t}\n\tsum.resize(n*2);\n\tREP(i,n*2){\n\t\tif(i==0){\n\t\t\tsum[i]=a[i];\n\t\t}else{\n\t\t\tsum[i]=sum[i-1]+a[i%n];\n\t\t}\n\t}\n\tsum.PB(MAX+1);\n\tll lb=0,rb=cnt;\n\twhile(rb-lb>1){\n\t\tll mid=(rb+lb)/2;\n\t\tif(ok(mid)){\n\t\t\tlb=mid;\n\t\t}else{\n\t\t\trb=mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n   int a,b,c,d,e,f,g;\n   scanf(\"%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g);\n   printf(\"6\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint p[10001][10001],a,b,c,n,m,q;\nint main(){\n  cin>>n>>m;\n  while(scanf(\"%d%d%d\",&a,&b,&c),a){\n    p[a][b]=c;\n  }\n  cin>>q;\n  while(q--){\n    int d[10001]={};\n    for(int i=1;i<=m;i++){\n      scanf(\"%d\",&a);\n      for(int j=1;j<=n;j++)\n\td[j]+=p[j][i]*a;\n    }\n    for(int i=1;i<=n;i++){\n      if(i>1)cout<<' ';\n      printf(\"%d\",d[i]);\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int sum = data[N + 1];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N+2; i++ )\n\t{\n\t\tfor( size_t j = i; j < N+2; j++ )\n\t\t{\n\t\t\tlong long int A = data[j] - data[i];\n\t\t\tif( A < ans )continue;\n\t\t\tif( sum - A < ans * 2 )break;\n\t\t\tfor( size_t k = j; k < N+2; k++ )\n\t\t\t{\n\t\t\t\tlong long int B = data[k] - data[j];\n\t\t\t\tans = max ( ans , min ( { A , B , sum - A - B } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    ifstream ifs(\"in.txt\");\n    int n;\n    cin >> n;\n    VL a(n);\n    REP(i,n) cin >> a[i];\n    REP(i,n){\n        a.push_back(a[i]);\n    }\n    VL s(2*n+1);\n    REP(i,2*n) s[i+1] = s[i] + a[i];\n    s.push_back(1e17);\n    s.push_back(2e17);\n    s.push_back(3e17);\n    ll l = 1, r = 1e16;\n    while (r - l > 1){\n        ll m = (l + r) / 2;\n        bool pos = 0;\n        REP(i,n){\n            int x = i;\n            REP(j,3){\n                x = lower_bound(s.begin(), s.end(), s[x] + m) - s.begin();\n            }\n            if (x <= i + n){\n                pos = 1;\n                break;\n            }\n        }\n        if (pos) l = m;\n        else r = m;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define real() X\n#define imag() Y\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll sumsum[200002];\nll sums(int s,int e){\n\tif(s>e)\n\t\treturn 0;\n\treturn sumsum[e+1]-sumsum[s];\n}\nll divide(int ss,int ee){\n\tint s=ss;\n\tint e=ee;\n\tll maxim=0;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tmaxim=max(maxim,min(sums(ss,f),sums(f+1,ee)));\n\t\tif(sums(ss,f)<=sums(f+1,ee))\n\t\t\ts=f+1;\n\t\telse\n\t\t\te=f-1;\n\t}\n\treturn maxim;\n}\nint main() {\n\tll N,p,s,sum=0;\n\tvector<ll> baum;\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> p;\n\t\tbaum.push_back(p);\n\t\tsum+=p;\n\t\tsumsum[i+1]=sumsum[i]+p;\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N+i+1]=sumsum[N+i]+baum[i];\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N*2+i+1]=sumsum[N*2+i]+baum[i];\n\t}\n\tint head=0;\n\tll maxim=0;\n\tREP(snake,N){\n\t\twhile(sums(snake,head)*3<sum) head++;\n\t\tif(sums(snake+1,head)*3<sum){\n\t\t\tmaxim=max(maxim,divide((head+1)%N,(snake+N-1)%N+N*((head+1)%N>(snake+N-1)%N)));\n\t\t}\n\t}\n\tcout << maxim << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i-1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n-1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[cut2][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < n; cut3_1++){\n\t\t\tif (baum - a[cut3_1][1] + a[cut1][1] >(baum - (a[cut2-1][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < n; cut3_2++){\n\t\t\tif (baum - a[cut3_2][1] + a[cut1][1] >(baum - (a[cut2][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3_1 - 1][1] - a[cut2 - 1][1];\n\t\tb[0][2] = baum - a[cut3_1 - 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3_1][1] - a[cut2 - 1][1];\n\t\tb[1][2] = baum - a[cut3_1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3_2 - 1][1] - a[cut2][1];\n\t\tb[2][2] = baum - a[cut3_2 - 1][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3_2][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3_2][1] + a[cut1][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define pb push_back\n#define LL long long\nusing namespace std ;\n\nint n ;\nvector<LL> a ;\n\nint main(){\n\t\n\tcin >> n ;\n\ta.pb(0) ;\n\t\n\tfor( int i=0 ; i<n ; i++ ){\n\t\tint b ;\n\t\tcin >> b ;\n\t\ta.pb(b) ;\n\t}\n\tfor( int i=1 ; i<=n ; i++ ) a.pb( a[i] ) ;\n\tfor( int i=1 ; i<a.size() ; i++ ) a[i] += a[i-1] ;\n\t\n\tLL X = a[n]/3 ;\n\tLL Y = 1 ;\n\t\n\tvector<LL>::iterator IT = a.begin()+1 ;\n\t\n\tfor( int i=1; i<=n ; i++ , IT++ ){\n\t\tLL x = X , y = Y ;\n\t\tLL p ;\n\t\twhile( x-y > 1 ){\n\t\t\tp = (x+y)/2;\n\t\t\tvector<LL>::iterator it1 = lower_bound( IT , IT+n-1 , *(IT-1) + p ) ;\n\t\t\tvector<LL>::iterator it2 = lower_bound( it1+1 , IT+n-1 , *it1 + p ) ;\n\t\t\tvector<LL>::iterator it3 = lower_bound( it2+1 , IT+n-1 , *it2 + p ) ;\n\t\t\t\n\t\t\tif( *it3 <= *(IT+n-1) && p <= *it3 - *it2 ) y = p ;\n\t\t\telse x = p ;\n\t\t}\n\t\tY = max( Y , y ) ;\n\t}\n\t\n\tcout << Y << endl ;\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,N) for(int i = 0; i < N; i++)\n#define int long long\n#define pb push_back\n#define LLINF 1LL << 60\ntypedef pair<int,int> Pi;\n#define F first\n#define S second\n \nsigned main()\n{\n  int N;\n  int A[200005];\n  int wsum = 0;\n  cin >> N;\n  Rep(i,N) {\n    cin >> A[i]; wsum += A[i];\n  }\n  Rep(i,N) A[i + N] = A[i];\n   \n  int l = 0, r = 1e14;\n  while (l + 1 < r) {\n    int m = (l + r + 1) / 2;\n     \n    bool flag = false;\n    int j = 0, k = 0, jsum = 0, ksum = 0;\n    Rep (i,N) {\n      for (; j < i + N && jsum < m; j++) jsum += A[j], ksum -= A[j];\n      for (; k < i + N && ksum < m; k++) ksum += A[k];\n      if (jsum >= m && ksum >= m && wsum - jsum - ksum >= m) flag = true;\n      jsum -= A[i];\n    }\n    \n    if (flag)  l = m;\n    else r = m;\n  }\n  cout << l << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing ll = long long;\n\nint n;\nvector<ll> a;\nvector<ll> imos;\n\nll sum(ll l, ll r){\n    return imos[r] - imos[l];\n}\n\nll get(int l, int r, ll lb){\n    ll x = l;\n    while(l+1 < r){\n        int m = (l+r)/2;\n        if(sum(x,m) < lb) l = m;\n        else r = m;\n    }\n    return r;\n}\n\nbool check(ll lb){\n    ll S = sum(0,n);\n    rep(i,n){\n        ll x = get(i,i+n,lb);\n        if(S - sum(i,x) < lb) return false;\n        ll y = get(x,i+n,lb);\n        if(sum(i,x) >= lb && sum(x,y) >= lb && sum(y,i+n) >= lb){\n            return true;\n        }\n    }\n    return false;\n}\n\nll solve(){\n    a.insert(a.end(), a.begin(), a.end());\n    imos.assign(a.size()+1,0);\n    rep(i,a.size()) imos[i+1] = imos[i] + a[i];\n    ll l = 1, r = imos[n];\n    while(l+1 < r){\n        ll m = (l+r)/2;\n        if(check(m)) l = m; else r = m;\n    }\n    return l;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(cin >> n){\n        a.resize(n);\n        rep(i,n) cin >> a[i];\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long t,n,a[200001];\n\nbool check(int b,long long x){\n  int l=b,r=b+n,m;\n  while(l<r){\n    m=(l+r)/2;\n    if(a[m]-a[b]>=x)r=m;\n    else l=m+1;\n  }\n  int d=l;\n  r=min(n+d,2*n);\n  while(l<r){\n    m=(l+r)/2;\n    if(a[m]-a[d]>=x)r=m;\n    else l=m+1;\n  } \n  if(l<b+n&&a[b+n]-a[l]>=x)return 1;  \n  return 0;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    cin>>a[i],t+=a[i],a[i]=t;\n  for(int i=0;i<n;i++)a[i+n]=a[i]+t;\n  long long ans=-1;\n  for(int i=0;i<n;i++){\n    long long l=0,r=1e18,m;\n    while(l<r){\n      m=(l+r)/2;\n      if(check(i,m))l=m+1;\n      else r=m;\n    }\n    ans=max(ans,l-1);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n + 1] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n + 1)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = ceil(double(sum - size) / 2.0);\n\t\t\tint sep = upper_bound(all(cuts), ideal + cuts[right]) - cuts.begin() - 1;\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//図を書けばバグらない(はず!??\n#include<stdio.h>\n\nlong long N;\nlong long rui[200001];\n\nlong long max( long long a,long long b ){\n\tif( a > b )\n\t\treturn a;\n\treturn b;\n}\nlong long min( long long a,long long b ){\n\tif( a < b )\n\t\treturn a;\n\treturn b;\n}\n\nint main(){\n\tint i,j,k;\n\n\tscanf(\"%d\",&N);\n\tfor( i = 1;i <= N;i++ ){\n\t\tscanf(\"%d\",rui+i);\n\t\trui[i] += rui[i-1];\n\t}\n\tfor( i = N+1;i <= 2*N;i++ ){\n\t\trui[i] = rui[N] + rui[i-N];\n\t}\n\n\tlong long ij, jk, ki;\t\t\n\tlong long ans = 0;\n\n\tfor( i = 0;i < N;i++ ){\n\t\tfor( j = i+1;j < N;j++ ){\n\t\t\tfor( k = j+1;k < N;k++ ){\n\t\t\t\tij = rui[j] - rui[i];\n\t\t\t\tjk = rui[k] - rui[j];\n\t\t\t\tki = rui[i+N] - rui[k];\n\n\t\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\n\nsigned main() {\n\tint n;\n\n\tscanf(\"%d\", &n);\n\n\tvector<ll> bam(n+1);\n\tll sum = 0;\n\tREP(i, n) {\n\t\tscnaf(\"%lld\", &bam[i+1]);\n\t\tsum += bam[i+1];\n\t}\n\tREP(i, n) {\n\t\tbam[i+1] += bam[i];\n\t}\n\n\tll l = 0, r = sum/3+3;\n\n\twhile (1) {\n\t\tll mid = (l + r) / 2;\n\t\tbool f = 0;\n\t\tREP(i, n) {\n\t\t\tauto itr = lower_bound(bam.begin()+i,bam.end(), mid + bam[i]);\n\t\t\tif (itr == bam.end())\n\t\t\t\tbreak;\n\t\t\tauto bufi = itr;\n\t\t\tbufi++;\n\t\t\tauto itr2 = lower_bound(bufi, bam.end(), mid + *itr);\n\t\t\tif (itr2 != bam.end()) {\n\t\t\t\tif ((bam[i] + sum - *itr2) >= mid) {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tl = mid;\n\t\t}\n\t\telse {\n\t\t\tr = mid;\n\t\t}\n\t\tif (r-l <= 1) {\n\t\t\tprintf(\"%lld\\n\", l);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL-=3;\n\t\t\tif (LL <= -1)LL = 0;\n\t\t\twhile (AA[LL] - AA[r - 1] < sum)LL++;\n\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define LL long long\nint N;\nLL A[200010];\n\nbool judge(LL x){\n    for(int s = 0; s < N; s++){//始点\n        int lb = s, ub = s + N;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid] >= A[s] + x){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        int t = ub;\n        lb = ub;\n        ub = s + N;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid]  - A[t] >= A[s] + x){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        if(A[s + N] - A[ub] >= x) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> N;\n    for(int i = 1; i <= N; i++){\n        cin >> A[i];\n        A[i + N] = A[i];\n    }\n    for(int i = 1; i <= N * 2; i++){\n        A[i] += A[i - 1];\n    }\n    LL lb = 0;\n    LL ub = A[N];\n    while(ub - lb > 1){\n        LL mid = (ub + lb) / 2;\n        if(judge(mid)){\n            lb = mid;\n        }else{\n            ub = mid;\n        }\n    }\n    cout << lb << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N 100000\n\nusing namespace std;\n\ntypedef unsigned long long int uint64;\n\nvector<uint64> S;\nint N;\n\nbool ctb(int x)\n{\n\tint able = false;\n\tfor(int ofs = 0;ofs < N;ofs++)\n\t{\n\t\tauto itr = lower_bound(S.begin(),S.end(),S[ofs]+x);\n\t\titr = lower_bound(itr,S.end(),*(itr)+x);\n\t\titr = lower_bound(itr,S.end(),*(itr)+x);\n\t\tif(itr < S.begin()+ofs+N+1)\n\t\t{\n\t\t\table = true;\n\t\t}\n\t}\n\treturn able;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tuint64 s = 0;\n\tuint64 t;\n\tS.push_back(0);\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> t;\n\t\ts += t;\n\t\tS.push_back(s);\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tS.push_back(S[i+1] + S[N]);\n\t}\n\tS.push_back(S[2*N]+1);\n\tuint64 L = S[N-1];\n\tuint64 S = 1;\n\tuint64 m;\n\twhile(S != L)\n\t{\n\t\tm = (((L-S)+1)/2)+S;\n\t\tif(ctb(m))\n\t\t{\n\t\t\tS = m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL = m-1;\n\t\t}\n\t}\n\tcout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define real() X\n#define imag() Y\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll sumsum[200002];\nll sums(int s,int e){\n\tif(s>e)\n\t\treturn 0;\n\treturn sumsum[e+1]-sumsum[s];\n}\nll divide(int ss,int ee){\n\tint s=ss;\n\tint e=ee;\n\tll maxim=0;\n\twhile(s<=e){\n\t\tint f=(s+e)/2;\n\t\tmaxim=max(maxim,min(sums(ss,f),sums(f+1,ee)));\n\t\tif(sums(ss,f)<=sums(f+1,ee))\n\t\t\ts=f+1;\n\t\telse\n\t\t\te=f-1;\n\t}\n\treturn maxim;\n}\nint main() {\n\tll N,p,s,sum=0;\n\tvector<ll> baum;\n\tcin >> N;\n\tREP(i,N){\n\t\tcin >> p;\n\t\tbaum.push_back(p);\n\t\tsum+=p;\n\t\tsumsum[i+1]=sumsum[i]+p;\n\t}\n\tREP(i,N){\n\t\tbaum.push_back(baum[i]);\n\t\tsumsum[N+i+1]=sumsum[N+i]+baum[i];\n\t}\n\tint head=0;\n\tll maxim=0;\n\tREP(snake,N){\n\t\twhile(sums(snake,head)*3<sum) head++;\n\t\tif(sums(snake+1,head)*3<sum){\n\t\t\tmaxim=max(maxim,divide((head+1)%N,(snake+N-1)%N+N*((head+1)%N>(snake-1))));\n\t\t\t//cout << snake <<\" \" <<head <<\" \" <<sums(0,N-1)<<\" \" <<sums(snake,head)<<\" \" << sums((head+1)%N,(snake+N-1)%N+N-((head+1)/N)*N)<<\" \" <<(head+1)%N<<\" \" <<(snake+N-1)%N+N-((head+1)/N)*N <<  endl;\n\t\t}\n\t}\n\tcout << maxim << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[300001];\nll l = 0;\n\nbool C(ll x){\n  for(int i=0;i<n;i++){\n    int left = upper_bound(a+i,a+i+n,a[i+n]-x) - a - 1;\n    int right = lower_bound(a+i+n,a+i+2*n,a[i+n]+x) - a;\n    if(a[right]-a[left]<=l-x) return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  a[0] = 0;\n  for(int i=0;i<n;i++){\n    scanf(\"%lld\",a+i+1);\n    l += a[i+1];\n    a[i] = l;\n  }\n  for(int i=0;i<n;i++){\n    a[i+n] = a[i] + l;\n    a[i+2*n] = a[i] + 2 * l;\n  }\n  ll lb = 1, ub = l;\n  while(ub-lb>1){\n    ll mid = (ub + lb) / 2;\n    if(C(mid)) lb = mid;\n    else ub = mid;\n  }\n  printf(\"%lld\\n\",lb);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RND(x,y) for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\nint n;\nint a[114514];\nint s[114514];\n\nint b(int x){\n  return distance(s,lower_bound(s,s+n,x));\n}\n\nint mod(int x,int y){\n  return (x%y+y)%y;\n}\n\nsigned main(){\n  cin>>n;\n  REP(i,n){\n    cin>>a[i];\n    s[i+1]=a[i]+s[i];\n  }\n  int ans=0;\n  int S=s[n];\n  REP(i,n){\n    int p=b((S/3+s[i])%S);\n    int q=b((S*2/3+s[i])%S);\n    RND(x,y){\n      int px=(p+x)%n;\n      int qy=(q+y)%n;\n      if(i>=px||px>=qy||qy>=i+n)continue;\n      int w1=mod(s[px]-s[i],S);\n      int w2=mod(s[qy]-s[px],S);\n      int w3=mod(s[i]-s[qy],S);\n      #ifdef DEBUG\n      cout<<(i)<<\" \"<<(px)<<\" \"<<(qy)<<\":\";\n      cout<<w1<<\" \"<<w2<<\" \"<<w3<<endl;\n      #endif\n      int wm=min({w1,w2,w3});\n      ans=max(ans,wm);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#define REP(i,n) for(ll i = 0; i < (ll)n; i++)\n#define INF 1000000000000000\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef string str;\n\nint main(){\n  ll n; cin >> n;\n  ll sum_round = 0;\n  ll a[n];\n  REP(i,n){\n    cin >> a[i];\n    sum_round += a[i];\n  }\n  ll b[2*n];\n  REP(i,2*n){\n    if(i==0) b[i] = 0;\n    else b[i] = a[i%n] + b[i-1];\n  }\n  ll lb = 0, ub = sum_round;\n  ll mid;\n  while(ub-lb>1){\n    mid = (ub+lb)/2;\n    ll upper[n];\n    ll r = 0;\n    for(ll l = 0; l < n; l++){\n      while(b[r]-b[l]<mid&&r<2*n) r++;\n      upper[l] = r;\n      if(l==r) r++;\n    }\n    bool ok = false;\n    REP(i,n){\n      ll first_cut = b[upper[i]]-b[i];\n      ll j = upper[i]%n;\n      ll next_cut = b[upper[j]]-b[j];\n      if(sum_round-first_cut-next_cut>=mid){\n        ok = true;\n        break;\n      }\n    }\n    if(ok){\n      lb = mid;\n    }else{\n      ub = mid;\n    }\n  }\n  cout << lb << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)573\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[i]-A[st] >= A[ed]-A[i]となる最小のiを返す。\nint seach1( int st, int ed, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= A[ed]-A[i] )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n//A[i]-A[st] >= Xとなる最小のiを返す。\nint seach2( int st, int ed, long long X, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= X )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tfor( ; j < N+i; j++ ){\n\t\t\tif( A[j]-A[i] >= X )\n\t\t\t\tbreak;\n\t\t}\n\t\t//できるだけ真ん中で切る\n\t\tfor( ; k < N+i; k++ ){\n\t\t\tif( A[k]-A[j] >= A[N+i]-A[k] )\n\t\t\t\tbreak;\n\t\t}\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100000);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  REP(i, 100){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%d\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N=100000;\n\nusing ll=long long int;\n\nint n;\nll A[MAX_N*2+1];\n\nbool C(ll x) {\n\tfor(int i=1;i<=n;++i) {\n\t\tint l=std::lower_bound(A+i,A+n+i,A[i-1]+x)-A;\n\t\tif(l==n+i)\n\t\t\tcontinue;\n\t\tint r=std::lower_bound(A+l+1,A+n+i,A[l]+x)-A;\n\t\tif(r==n+i)\n\t\t\tcontinue;\n\t\tif(A[n+i-1]-A[r]>=x)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tstd::cin>>n;\n\tfor(int i=1;i<=n;++i) {\n\t\tstd::cin>>A[i];\n\t\tA[i+n]=A[i];\n\t}\n\tfor(int i=1;i<=n*2;++i)\n\t\tA[i]+=A[i-1];\n\n\tll lb=1,rb=(ll)n*1e9+1,mid=(lb+rb)/2;\n\n\twhile(lb<rb-1) {\n\t\tif(C(mid)){\n\t\t\tlb=mid;\n\t\t}\n\t\telse{\n\t\t\trb=mid;\n\t\t}\n\t\tmid=(lb+rb)/2;\n\t}\n\n\tstd::cout<<lb<<std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tconst long long int one_third = whole / 3;\n\tlong long int ans = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tint j = i;\n\t\tlong long int piece1 = 0;\n\t\twhile (piece1 + (long long int)A[j] <= one_third){\n\t\t\tpiece1 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int piece2 = 0;\n\t\twhile (1){\n\t\t\tpiece2 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t\tif (piece2 >= one_third) break;\n\t\t}\n\n\t\tlong long int piece3 = 0;\n\t\twhile(j != i){\n\t\t\tpiece3 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int tmpans = min(piece1, min(piece2, piece3));\n\t\tans = max(ans, tmpans);\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define ll long long\n#define INF 10000000000000000\nint n;\nll a[300005] = { 0 };\nll lb = 0;\nll ub = INF;\nll bsum = 0;\n\n\nbool solve(ll len){\n\tll b1 = 0;\n\tll b2 = 0;\n\tint now1 = n;\n\twhile (b1 < len&&now1<3 * n){\n\t\tb1 += a[now1];\n\t\tnow1++;\n\t}\n\tif (b1 < len) return false;\n\tint now2 = n - 1;\n\twhile (b2 < b1&&now2>0){\n\t\tb2 += a[now2];\n\t\tnow2--;\n\t}\n\tnow2++;\n\tif (b2 < b1) return false;\n\tfor (int i = n+1; i < 2*n; i++){\n\t\tb1 -= a[i - 1];\n\t\tb2 += a[i - 1];\n\t\twhile (b1 < len&&now1 < 3 * n){\n\t\t\tb1 += a[now1];\n\t\t\tnow1++;\n\t\t}\n\t\tif (b1<len) continue;\n\t\twhile (b2>=b1&&now2<3*n&&now2>0){\n\t\t\tb2 -= a[now2];\n\t\t\tnow2++;\n\t\t}\n\t\tnow2--;\n\t\tb2 += a[now2];\n\t\tif (b2 < b1) continue;\n\t\tif (bsum - (b1 + b2) >= b1){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tbsum += a[i];\n\t\ta[i + n] = a[i];\n\t\ta[i + 2 * n] = a[i];\n\t}\n\tfor (int i = 0; i < 100; i++){\n\t\tll mb = (ub + lb) / 2;\n\t\tif (solve(mb)){\n\t\t\tlb = mb;\n\t\t}\n\t\telse{\n\t\t\tub = mb;\n\t\t}\n\t}\n\tcout << (ll)lb << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long b[210000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tlong long at=0;\n\tfor(int i=0;i<a;i++){\n\t\tint tmp;scanf(\"%d\",&tmp);\n\t\tat+=tmp;\n\t\tb[i+1]=at;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tb[a+i+1]=b[a]+b[i+1];\n\t}\n\tlong long L=0;\n\tlong long R=1000000000000000LL;\n\twhile(L+1<R){\n\t\tlong long M=(L+R)/2;\n\t\tbool ok=false;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tlong long now=b[i];\n\t\t\tint nat=lower_bound(b,b+2*a,b[i]+M)-b;\n\t\t\tnat=lower_bound(b,b+2*a,b[nat]+M)-b;\n\t\t\tnat=lower_bound(b,b+2*a,b[nat]+M)-b;\n\t\t\tif(nat<=i+a){ok=true;break;}\n\t\t}\n\t\tif(ok)L=M;else R=M;\n\t}\n\tprintf(\"%lld\\n\",L);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    long int num;\n    cin>>num;\n    long long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long long int mi=0;\n    \n    for (int i=1; i< num; i++) {\n        A[i]=A[i]+A[i-1];\n    }\n    \n    for (int i=0; i<num-2; i++) {\n        for (int j=i+1; j<num-1; j++) {\n            for (int k=j+1; k<num; k++) {\n                mi=max(mi,min(A[k]-A[j],min(A[j]-A[i],A[num-1]-A[k]+A[i])));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<17;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        //cout<<i<<\" \"<<p1<<\" \"<<p2<<endl;\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        //cout<<i<<\" \"<<p1<<\" \"<<p2<<endl;\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 200005;\n\nll a[MAX_N];\nint n;\n\nbool possible(ll cri)\n{\n\tll asum[3];\n\tasum[0] = asum[1] = asum[2] = 0;\n\tint r=0;\n\tint rr[2];\n\tint i=0;\n\trep(i,2){\n\t\twhile(asum[i] < cri && r<n){\n\t\t\tasum[i] += a[r];\n\t\t\tr++;\n\t\t}\n\t\tif(r>=n){\n\t\t\tbreak;\n\t\t}\n\t\trr[i] = r;\n\t}\n\tif(r>=n&&i==0){\n\t\treturn false;\n\t}\n\tfor(;r<n;r++){\n\t\tasum[2] += a[r];\n\t}\n\tif(asum[2] >= cri){\n\t\treturn true;\n\t}\n\trep(i,n){\n\t\tasum[0] -= a[i];\n\t\trep(j,2){\n\t\t\tr = rr[j];\n\t\t\twhile(asum[j] < cri && r<n+i+1){\n\t\t\t\tasum[j] += a[r];\n\t\t\t\tasum[j+1] -= a[r];\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif(r>n+i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trr[j] = r;\n\t\t}\n\t\tif(r<n+i+1){\n\t\t\tasum[2] += a[n+i];\n\t\t}\n\t\tif(asum[2] >= cri){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\ta[i+n] = a[i];\n\t}\n\tll asum = accumulate(a,a+n,0LL);\n\tll amin = *(min_element(a,a+n));\n\tll h=asum/3+1;\n\tll l=amin-1;\n\tll ans;\n\twhile(1){\n\t\tll mid = (l+h)/2;\n\t\tif(l==mid){\n\t\t\tans = mid;\n\t\t\tbreak;\n\t\t}\n\t\tif(possible(mid)){\n\t\t\tl = mid;\n\t\t}else{\n\t\t\th = mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long int mi=0;\n    \n    for (int i2=1; i2< num; i2++) {\n        A[i2]=A[i2]+A[i2-1];\n    }\n    \n    long int aa,bb,cc;\n    for (int i=0; i<num; i++) {\n        for (int j=i; j<num; j++) {\n            for (int k=j; k<num; k++) {\n                aa=A[k]-A[j];\n                bb=A[j]-A[i];\n                cc=A[num-1]-A[k]+A[i];\n                \n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v)) os<<*i<<(i==end(v)-1?\"\":\"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n    is>>p.first>>p.second; return is; }\ntemplate<class T> bool chmax(T &a,const T &b) {if(a<b) {a=b;return 1;} return 0;}\ntemplate<class T> bool chmin(T &a,const T &b) {if(b<a) {a=b;return 1;} return 0;}\ntemplate <class T> using heap = priority_queue<T,vector<T>,greater<T>>;\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int n;\n    cin>>n;\n    vector<int> a(n*2),sum(n*2);\n    REP(i,n) {\n        cin>>a[i];\n        a[i+n]=sum[i]=sum[i+n]=a[i];\n    }\n    REP(i,n*2-1) sum[i+1]+=sum[i];\n\n    int L=sum[n-1];\n\n    int ans=0;\n    REP(i,n) {\n        int l=0,r=L;\n        while(r-l>1) {\n            int k=(l+r)/2;\n            auto itr1=lower_bound(begin(sum)+i,begin(sum)+i+n,k+(i==0?0:sum[i-1]));\n            int p1=*itr1;\n            auto itr2=lower_bound(itr1,begin(sum)+i+n,k+p1);\n            int p2=*itr2;\n            int p3=sum[i+n-1]-p2;\n            if(p3>=k) {\n                l=k;\n                chmax(ans,k);\n            } else {\n                r=k;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0;\n\n\t\tint ans = 0;\n\t\trep(i, n + 1)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = double(sum - len) / 2.0;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tif (idx >= i + n + 1 || remidx > i + n + 1) continue;\n\t\t\tans = max(ans, min({ len, remlen, sum - len - remlen }));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[200005];\n\nbool check(int x,ll key){\n  ll* p=&a[x];\n  ll* ed=&a[x+n+1];\n  \n  for(int i=0;i<3;i++){\n    ll target=*p;\n    p=lower_bound(p,ed,target+key);\n    if(p==ed)return false;\n  }  \n  return true;\n}\n\nll solve(int x,ll sum){\n  ll L=2,R=sum/3,M;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(x,M))L=M+1;\n    else R=M;\n  }\n  return L-1;\n}\n\nint main(){\n  cin>>n;\n  ll sum=0;\n  for(int i=1;i<=n;i++){cin>>a[i];sum+=a[i];}\n  for(int i=n+1;i<=n+n;i++)a[i]=a[i-n];\n\n  for(int i=1;i<=n+n;i++)a[i]+=a[i-1];\n  \n  ll ans=0;\n  for(int i=0;i<n;i++)ans=max(ans,solve(i,sum));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left <= n + 1)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = (sum - size) / 2.0 + 0.5;\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<long long> A(N+1);\n    long long total=0;\n    A[0]=0LL;\n    for(int i=1; i<=N; ++i) {\n        cin >> A[i];\n        total+=A[i];\n        A[i]+=A[i-1];\n    }\n\n    long long P,Q,R;\n    long long ans=0;\n    int i=1,j=i+1,k=j+1;\n    while(true) {\n        P=A[j-1]-A[i-1];\n        Q=A[k-1]-A[j-1];\n        R=total-P-Q;\n        ans=max(ans,min({P,Q,R}));\n        if(i==N-2) break;\n        else if(R==min({P,Q,R})) {\n            ++i;\n            if(i==j) ++j;\n            if(j==k) ++k;\n        } else if(P<Q && k-j>1) {\n            ++j;\n        } else {\n            ++k;\n            if(k>N) break;\n        }\n    }    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\nusing namespace std;\n#define INF 1<<30\n#define LL long long\n\nLL N;\nvector<LL> A, sum;\n\nint main() {\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;  cin >> a;\n\t\tA.push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) A.push_back(A[i]);\n\t//get sum\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tsum.push_back(A[i]);\n\t\tif (i) sum[i] += sum[i - 1];\n\t}\n\t//binary search:ans\n\tLL mn = 0, mx = sum[N];\n\twhile (mx - mn > 1) {\n\t\tLL md = (mx + mn) / 2;\n\t\tbool jud = false;\n\t\t//1st cut\n\t\tfor (int fir = 0; fir < N; fir++) {\n\t\t\t//binary search:2nd cut(at least md)\n\t\t\t//range:fir to fir + N - 1\n\t\t\tauto beg = sum.begin();  beg += fir;\n\t\t\tauto lef = sum.begin();  lef += fir;\n\t\t\tauto rig = sum.begin();  rig += fir + N - 1;\n\t\t\tauto sec = lower_bound(lef, rig, md + (lef == sum.begin() ? 0 : *(lef - 1)));\n\t\t\tif (sec == sum.end()) continue;//NG\n\t\t\tlef = sec;  lef++;\n\t\t\t//binary search:3rd cut(at least md)\n\t\t\t//range:sec + 1 to fir + N - 1\n\t\t\tauto thr = lower_bound(lef, rig, md + *(lef - 1));\n\t\t\tif (thr == sum.end()) continue;//NG\n\t\t\t//left part is at least md?\n\t\t\tif (sum[N - 1] - *thr + (beg == sum.begin() ? 0 : *(beg - 1)) >= md) { jud = true; break; }\n\t\t}\n\t\t(jud ? mn : mx) = md;\n\t}\n\tcout << mn << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nvector<ll>V;\nint n;\nll MAX,sum;\nbool ok(ll x){\n  REP(i,n){\n    int res=V[i];\n    ll fis=*lower_bound(ALL(V),res+x);\n    if(fis==MAX)continue;\n    ll sec=*lower_bound(ALL(V),fis+x);\n    if(sec==MAX)continue;\n    ll thi=*lower_bound(ALL(V),sec+x);\n    if(thi<=sum+res)return true;\n  }\n  return false;\n}\nint main(){\n  cin>>n;\n  sum=0;\n  ll lb=0,rb=0;\n  V.PB(0);\n  REP(i,n){\n    ll a;\n    cin>>a;\n    V.PB(V[V.size()-1]+a);\n    sum+=a;\n  }\n  MAX=sum*2+1;\n  rb=sum;\n  REP(i,n)V.PB(V[i+1]+sum);\n  V.PB(MAX);\n  while(rb-lb>1){\n    ll mid=(rb+lb)/2;\n    if(ok(mid)){\n      lb=mid;\n    }else{\n      rb=mid;\n    }\n  }\n  cout<<lb<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b1 = 0, b2 = 0, b3 = 0, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = a[0][0];\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i][0];\n\t}\n\tbaum = a[n - 1][1];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tfor (int cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tfor (int cut3 = cut2 + 1; cut3 < n; cut3++){\n\t\t\t\tb1 = a[cut2][1] - a[cut1][1];\n\t\t\t\tb2 = a[cut3][1] - a[cut2][1];\n\t\t\t\tb3 = baum - a[cut3][1] + a[cut1][1];\n\t\t\t\tminb = MIN(MIN(b1, b2), b3);\n\t\t\t\tif (ans < minb){\n\t\t\t\t\tans = minb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define st first\n#define nd second\n#define mp make_pair\n#define space << \" \" <<\n#define END << endl\n#define pb push_back\n#define int long long\n#define fo(i,n) for(int i = 0; i<n; ++i)\n#define ff(i,n) for(int i = 1; i<n; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pi;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> pl;\ntypedef vector<pil>vil;\n\nconst int N = 1e5 + 100;\nll a[N]; int n;\n\nll sum(int u, int v)\n{\n    if(u <= v) return  a[v] - (u==0 ? 0 : a[u-1]);\n    else return a[n-1] - ((u==0?0:a[u-1]) - a[v]);\n}\n\nbool check1(int num ,int t, int v)\n{\n    if(sum(t,(t+num-1)%n) >= v) return 1;\n    else return 0;\n}\n\nbool check(int u, int far)\n{\n    ll v = sum(u,(u+far-1)%n);\n    int t = (u + far) % n;\n    int l = 1;\n    int r = n - far - 1;\n    while( r - l > 1)\n    {\n        int mid = (l + r)/ 2;\n        if(check1(mid,t,v)) r = mid;\n        else l = mid;\n    }\n    if(check1(l,t,v) && a[n-1] - sum(t,(l+t-1)%n) - v >= v) return 1;\n    else if(check1(r,t,v) && a[n-1] - sum(t,(r+t-1)%n) - v >= v) return 1;\n    else return 0;\n}\n\nll work(int u)\n{\n    int l = 1;\n    int r = n-2;\n    //if(sum(u,(u+r-1)%n))\n    while(r - l > 1)\n    {\n        int mid = (l + r) / 2;\n        if(check(u,mid)) l = mid;\n        else r = mid;\n    }\n    //cout <<u space check(u,r) space r space check(u,l) space l << endl;\n    if(check(u,r)) return sum(u,(u+r-1)%n);\n    else return sum(u,(u+l-1)%n);\n\n}\nmain()\n{\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> n; fo(i,n) cin >> a[i]; fo(i,n) if(i) a[i] = a[i-1] + a[i];\n    ll ans = 0; fo(i,n) { ans = max(ans , work(i));  }\n    cout << ans << endl;\n    //cout << sum(4,2) << endl;\n    //ll ans = work(0); cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nlong long int a[100001],sa[200001],sum,mx,sum3;\nint bina(int low,int high,long long int key)\n{\n\tint mid;\n\twhile(low<=high)\t{\n\t\tmid=(low+high)/2;\n\t\tif(sa[mid]<key)\tlow=mid+1;\n\t\telse if(sa[mid]>key)\thigh=mid-1;\n\t\telse return mid;\n\t}\n\treturn low;\n}\nint main(void)\n{\n\tlong long int wk,wk2,wk3,min1,min2,wkh;\n\tint i,j,lp,hp,flg,b;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tsa[0]=0;\n\tfor(i=1;i<=n;i++)\t{\n\t\tsa[i]=sa[i-1]+a[i];\n\t}\n\tsum=sa[n];\n\tfor(i=n+1;i<=2*n;i++)\t{\n\t\tsa[i]=sa[i-n]+sum;\n\t}\n\tsum3=sum/3;\n//\tprintf(\"sum=%lld\\n\",sum);\n//\tfor(i=1;i<=n;i++)\tprintf(\"sa=%lld\\n\",sa[i]);\n\t\n\tmx=0;\n\tfor(lp=0;lp<n;lp++)\t{\n\t\tb=bina(lp,n+lp,sum3+sa[lp]);\n\t\twk=sa[b-1]-sa[lp];\n\t\thp=b-1;\n\t\twkh=(sum-wk)/2;\n\t\tb=bina(hp,n+lp,wkh+sa[hp]);\n\t\twk2=sa[b-1]-sa[hp];\twk3=sa[n+lp]-sa[b-1];\n\t\tmin1=min(wk2,wk3);\tmin1=min(min1,wk);\n//\t\tprintf(\"a:wk=%lld wk2=%lld wk3=%lld\\n\",wk,wk2,wk3);\n\t\twk2=sa[b]-sa[hp];\twk3=sa[n+lp]-sa[b];\n\t\tmin2=min(wk2,wk3);\t\tmin2=min(min2,wk);\n//\t\tprintf(\"b:wk=%lld wk2=%lld wk3=%lld\\n\",wk,wk2,wk3);\n\t\tmx=max(mx,min1);\tmx=max(mx,min2);\t\n\t}\n\tprintf(\"%lld\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nint sumArray(int, int);\nint getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tint sum = sumArray(0, N);\n\tint average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tint MaxMin = 0;\n\tint tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nint sumArray(int start, int end)\n{\n\tint sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nint getLocalMin(int p1, int p2, int p3)\n{\n\tint LocalMin = sumArray(p1, p2);\n\tint tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n;\nvector < int > a;\nvector<long long int > pr;\nbool check2(int k,int now,long long int m)\n{\n    if (pr[now] - pr[k] >= m)return true;\n    return false;\n}\nbool check(int i,long long int m)\n{\n    int r = i+n-1, l = i;\n    while (r != l)\n    {\n        int now = (r + l) / 2;\n        if (check2(i,now,m))\n        {\n            r = now;\n        }\n        else\n        {\n            l = now+1;\n        }\n    }\n    r = i + n - 1;\n    int hoge = l;\n    while (r != l)\n    {\n        int now = (r + l) / 2;\n        if (check2(hoge, now, m))\n        {\n            r = now;\n        }\n        else\n        {\n            l = now+1;\n        }\n    }\n    if (pr[i + n - 1] - pr[r] >= m)return true;\n    return false;\n}\n \nint main()\n{\n     \n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        a.push_back(x);\n        (i == 0) ? pr.push_back(x) : pr.push_back(x + pr[i - 1]);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        a.push_back(a[i]);\n        pr.push_back(pr.back() + a[i]);\n    }\n    long long int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        long long int r = 0, l = 50000000;\n        while (r != l)\n        {\n            long long int m = (r + l) / 2;\n            if (check(i,m))\n            {\n                l = m;\n            }\n            else\n            {\n                r = m+1;\n            }\n        }\n        ans = max(ans, l);\n    }\n    cout << ans << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst vi emp;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nint n;\nvl a;\n\nint main(){\n\tcin>>n;\n\ta=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=1;i<n;i++) a[i]+=a[i-1];\n\tll ans=0,sum=a[n-1];\n\tfor(int i=0;i<n;i++){\n\t\tint Im=lower_bound(a.begin(),a.end(),(a[i]+sum/3)%sum)-a.begin();\n\t\tint IM=lower_bound(a.begin(),a.end(),(a[i]+sum/3*2)%sum)-a.begin();\n\t\tfor(int j=Im-5;j<Im+5;j++) for(int k=IM-5;k<IM+5;k++){\n\t\t\tll A=(a[(j+n)%n]-a[i]+sum)%sum;\n\t\t\tll B=(a[(k+n)%n]-a[(j+n)%n]+sum)%sum;\n\t\t\tans=max(ans,min(A,min(B,sum-A-B)));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n + 1] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = ceil(double(sum - size) / 2.0);\n\t\t\tint sep = upper_bound(all(cuts), ideal + cuts[right]) - cuts.begin() - 1;\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nvoid InitRand()\n{\n\tsrand((unsigned int)time(NULL));\n}\nint Dice()\n{\n\treturn rand() % N;\n}\nint main()\n{\n\tInitRand();\n\tint cou;\n\tint i, j, k;\n\tll ans = 0;\n\tll sum1, sum2, sum3;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < N; i++)AA[i] = AA[i - 1] + A[i];\n\tfor (cou = 0; cou < 45000000; cou++){\n\t\t//if (cou % 100000 == 99999)printf(\"%d\\n\", cou);\n\t\tsum1 = sum2 = sum3 = 0;\n\t\ti = Dice(); j = Dice(); k = Dice();\n\t\tif (i == j || j == k || i == k)continue;\n\t\tif (i>j)swap(i, j);\n\t\tif (i>k)swap(i, k);\n\t\tif (j>k)swap(j, k);\n\t\tif(i!=0)sum1 += AA[i - 1];\n\t\tsum2 += AA[j-1] - AA[i - 1];\n\t\tsum3 += AA[k-1] - AA[j - 1];\n\t\tsum1 += AA[N-1] - AA[k - 1];\n\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong v_list[100001];\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\ninline llong searchOne(int n0, int n1_left, int n2_left);\ninline llong getMinV(int n0, int n1_left, int n2_left);\ninline int findIndexBinary(int from_n, int to_n, double target);\ninline int findIndexSequential(int from_n, double target);\n\n\nint main(){\n\t/*\n\tFILE* fp = fopen(\"input.txt\", \"r\");\n\tfscanf(fp, \"%lld\", &N);\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfscanf(fp, \"%lld\", &A);\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfclose(fp);\n\n\t/*/\n\tscanf(\"%lld\", &N);\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tscanf(\"%lld\", &A);\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tprintf(\"%lld\\n\", BaumukuchenGetAnswer());\n}\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tint n0_max = findIndexBinary(0, N, tripartition);\n\n\tint n1_left = n0_max;\n\tint\tn2_left = findIndexBinary(n1_left, N,  2*tripartition);\n\tllong interm_maxV = searchOne(0, n1_left, n2_left);\n\tfor (int n0 = 1; n0 <= n0_max; n0++){\n\t\tn1_left = findIndexSequential(n1_left,   tripartition + v_list[n0]);\n\t\tn2_left = findIndexSequential(n2_left, 2*tripartition + v_list[n0]);\n\t\t\n\t\tllong tmp = searchOne(n0, n1_left, n2_left);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0, int n1_left, int n2_left){\n\tllong V_ll = getMinV(n0, n1_left  , n2_left  );\n\tllong V_lr = getMinV(n0, n1_left  , n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left  );\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tllong V0 = v_list[n1] - v_list[n0];\n\tllong V1 = v_list[n2] - v_list[n1];\n\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\treturn min(min(V0,V1),V2);\n}\n\nint findIndexBinary(int from_n, int to_n, double target){\n\twhile (to_n - from_n != 1) {\n\t\tint n_mid = (to_n + from_n) / 2;\n\t\tif (v_list[n_mid] > target) to_n = n_mid;\n\t\telse from_n = n_mid;\n\t}\n\treturn from_n;\n}\n\nint findIndexSequential(int from_n, double target){\n\tfor(int n=from_n; n<= N; n++)if(v_list[n] > target) return n-1;\n\treturn N-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n;\nlong long sum[110000];\n\nbool Func(long long key){\n\n\tfor(int i=1;i<n;i++){\n\n\t\tint f=lower_bound(sum+i,sum+n+1,key+sum[i-1]);\n\t\tint g=lower_bound(f,sum+n+1,key+*f);\n\n\t\tif(*g&&*g+key-sum[i-1]<=sum[n]){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tcin>>n;\n\tsum[0]=0;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin>>sum[i+1];\n\t\tsum[i+1]+=sum[i];\n\t}\n\n\tlong long left=0,right=sum[n]/3+1,mid;\n\tlong long ans=0;\n\n\twhile(left<right){\n\n\t\tmid=(left+right)/2;\n\n\t\tif(Func(mid)){\n\t\t\tleft=mid+1;\n\t\t\tans=max(ans,mid);\n\t\t}\n\t\telse right=mid;\n\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[300001];\n\nbool check(long long x)\n{\n\tint l = 0, r = 1;\n\tfor (; r < 2 * n; r++){\n\t\tif (a[r] - a[l] < x) continue;\n\t\twhile (a[r] - a[l + 1] >= x) l++;\n\t\t\n\t\tint tail = l + n;\n\t\tint mid = lower_bound(a + l + 1, a + tail + 1, (a[r] - a[l]) * 2 + a[l]) - a;\n\t\t\n\t\tif (mid == tail + 1) continue;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\", l, r, mid, tail);\n\t\t\n\t\tif (\n\t\t\tr != mid &&\n\t\t\tmid != tail &&\n\t\t\ttail - n != l + 1 &&\n\t\t\ta[mid] - a[r] >= a[r] - a[l] &&\n\t\t\ta[tail] - a[mid] >= a[r] - a[l]\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[i + n] = a[i + 2 * n] = a[i];\n\t}\n\t\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\t\n\tlong long l = 0, r = 1000000000LL * 100000LL;\n\twhile (l <= r){\n\t\tlong long mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\t\n\tprintf(\"%lld\\n\", r);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint CalcMid(int lb,int ub,int size){\n\tint mid;\n\tif(lb<ub) mid=(ub+lb)/2;\n\telse mid=(lb+ub+size)/2;\n\tmid%=size;\n\treturn mid;\n}\n\nbool Sub_Check(int last,int mid,lli m,const vector<lli> &a){\n\tlli d;\n\tif(last<mid){\n\t\tif(last>0) d=a[mid]-a[last-1];\n\t\telse d=a[mid];\n\t}else if(last>mid){\n\t\tif(last>0) d=a[a.size()-1]-a[last-1]+a[mid];\n\t\telse d=a[last];\n\t}else{\n\t\tif(last>0) d=a[last]-a[last-1];\n\t\telse d=a[last];\n\t}\n\treturn d>=m;\n}\n\nbool Check(const vector<lli> &a,lli m){\n\tREP(i,0,a.size()){\n\t\tint cnt=0,last=i;\n\t\tREP(i,0,3){\n\t\t\tint lb=last,ub=last-1;\n\t\t\tif(ub<0) ub=a.size()-1;\n\t\t\tdo{\n\t\t\t\tint mid=CalcMid(lb,ub,a.size());\n\t\t\t\tif(Sub_Check(last,mid,m,a)) ub=mid;\n\t\t\t\telse lb=mid;\n\t\t\t}while(abs(ub-lb)>1&&!(lb==a.size()-1&&ub==0));\n\t\t\tif(Sub_Check(last,lb,m,a)) ub=lb;\n\t\t\tif(last<=ub) cnt+=ub-last+1;\n\t\t\telse cnt+=ub+a.size()-last+1;\n\t\t\tif(!(cnt<=a.size())) break;\n\t\t\tlast=(ub+1)%a.size();\n\t\t}\n\t\tif(cnt<=a.size()) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<lli> A(N);\n\tREP(i,0,N){\n\t\tint a;\n\t\tcin >> a;\n\t\tif(i==0) A[i]=a;\n\t\telse A[i]=A[i-1]+a;\n\t}\n\tlli lb=0,ub=INF_;\n\twhile(ub-lb>1){\n\t\tlli mid=(lb+ub)/2;\n\t\tif(Check(A,mid)) lb=mid;\n\t\telse ub=mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2017/09/17\ndata will be seperated to 3 groups, a b c\nthe bigest(a) should >= sum / 3\nthen the second should >= (sum - a) / 3\nloop to find the just data that comply with the previous conditions\n*/\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\t// end link to head\n\tint InArray[200000] = {0};\n\tint N = 0;\n\t\n\t// initialize input\n\tint temp;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t\n\t// Calculate sum and average\n\tlong long sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tlong long average;\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum;\n\tlong long average2;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(int a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(int a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//図を書けばバグらない(はず!??\n#include<stdio.h>\n\nlong long N;\nlong long rui[200001];\n\nlong long max( long long a,long long b ){\n\tif( a > b )\n\t\treturn a;\n\treturn b;\n}\nlong long min( long long a,long long b ){\n\tif( a < b )\n\t\treturn a;\n\treturn b;\n}\n\nint main(){\n\tint i,j,k;\n\n\tscanf(\"%d\",&N);\n\tfor( i = 1;i <= N;i++ ){\n\t\tscanf(\"%d\",rui+i);\n\t\trui[i] += rui[i-1];\n\t}\n\tfor( i = N+1;i <= 2*N;i++ ){\n\t\trui[i] += rui[N] + rui[i-N];\n\t}\n\n\tlong long ij, jk, ki;\t\t\n\tlong long ans = 0;\n\n\tfor( i = 0;i < N;i++ ){\n\t\tfor( j = i+1;j < N;j++ ){\n\t\t\tfor( k = j+1;k < N;k++ ){\n\t\t\t\tij = rui[j] - rui[i];\n\t\t\t\tjk = rui[k] - rui[j];\n\t\t\t\tki = rui[i+N] - rui[k];\n\n\t\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else if (p < tar) l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n - 2, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2, n - 1, (A[i + n - 1] - A[c2 - 1]) / 2);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n;\nVI manysize;\n\nvoid solve() {\n\tint num = n / 3;\n\tint size1 = 0, size2 = 0, size3 = 0;\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize1 += manysize[ i ];\n\t}\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize2 += manysize[ i + num ];\n\t}\n\tfor ( int j = num * 2; j < n; j++ ) {\n\t\tsize3 += manysize[ j ];\n\t}\n\tint ans = min( size1, max( size2, size3 ) );\n\tint now1 = num, now2 = num * 2, now3 = 0;\n\tset < pair<int, PII> > s;\n\twhile ( !s.count( MP( now1, MP( now2, now3 ) ) ) && !s.count( MP( now2, MP( now3, now1 ) ) ) && !s.count( MP( now3, MP( now1, now2 ) ) ) ) {\n\t\ts.insert( MP( now1, MP( now2, now3 ) ) );\n\t\tif ( size3 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size3 );\n\t\t\tsize3 += manysize[ now3 ];\n\t\t\tsize1 -= manysize[ now3 ];\n\t\t\tnow3++;\n\t\t\tnow3 %= n;\n\t\t}\n\t\telse if ( size2 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size2 );\n\t\t\tsize2 += manysize[ now2 ];\n\t\t\tsize3 -= manysize[ now2 ];\n\t\t\tnow2++;\n\t\t\tnow2 %= n;\n\t\t}\n\t\telse {\n\t\t\tans = max( ans, size1 );\n\t\t\tsize1 += manysize[ now1 ];\n\t\t\tsize2 -= manysize[ now1 ];\n\t\t\tnow1++;\n\t\t\tnow1 %= n;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\t\n#endif\n\tcin >> n;\n\tmanysize.resize( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> manysize[ i ];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = LLONG_MAX/4;\n\nint n;\n\nbool c(ll x, int idx, vector<ll> &B)\n{\n    int p = lower_bound(B.begin(), B.end(), x + B[idx]) - B.begin();\n    if (p - idx > n) return 0;\n    p = lower_bound(B.begin(), B.end(), x + B[p]) - B.begin();\n    if (p - idx > n) return 0;\n    p = lower_bound(B.begin(), B.end(), x + B[p]) - B.begin();    \n    return (p - idx <= n);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<ll> A(N), B(2*N, 0);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[i] = A[i] + (i > 0 ? B[i-1] : 0);\n    }\n    for (int i = 0; i < N; i++) {\n        B[N+i] = B[N+i-1] + A[i];\n    }\n    n = N;\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        ll lb = i, ub = INF;\n        while (ub - lb > 1) {\n            ll mid = (lb + ub) / 2;\n            if (c(mid, i, B)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        res = max(res, lb);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tvector<ll> v(n);\n\trep(i, n) cin >> v[i];\n\n\tvector<ll> sum(2*n + 1);\n\trep(i, n) {\n\t\tsum[i+1] += sum[i] + v[i];\n\t}\n\n\trep(i, n) {\n\t\tsum[n+i+1] += sum[n + i] + v[i];\n\t}\n\n\tll ans = 0;\n\tint s = 0, t = 0,cnt = 0;\n\tbool flag = true, first = true;\n\n\twhile(true) {\n\t\tif(flag) t++;\n\t\telse s++;\n\n\t\tif(s + n >= sum.size()) break;\n\n\t\tll d = sum[t] - sum[s];\n\t\tint id = lower_bound(sum.begin(), sum.end(), sum[t]  + (sum[t] - sum[s])) - sum.begin();\n\n\t\tif(s + n > id && d < sum[s+n] - sum[id]) {\n\t\t\tans = max(ans, d);\n\t\t\tflag = true;\n\t\t} else {\n\t\t\tflag = false;\n\t\t}\n\n\t\t// cout << s << \" \" << t << \" v:\" << sum[s] << \",\" << sum[t] << \" diff:\" << sum[t] - sum[s] << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL, RR, CC;\nint main()\n{\n\tint i, j, k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1;\n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2 * N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif (l != 0)sum = AA[r-1] - AA[l - 1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N - 1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif (AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL--;\n\t\t\tif (LL < 0)LL = 0;\n\t\t\twhile (sum > AA[LL] - AA[r-1])LL++;\n\t\t\tsum1 = AA[LL] - AA[r-1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2){\n\t\t\t\tans = max(ans, sum); r++;\n\t\t\t}\n\t\t\telse l++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int N=1e5+10;\nlong long int a[N];\nint n;\nbool check(long long int val){\n    long long int now=0,cnt=0;\n    for(int i=0;i<n;i++){\n        now+=a[i];\n        if(now>=val){\n            now=0;\n            cnt++;\n            if(cnt>=3)return true;\n        }\n    }\n    return false;\n}\nint main(){\n    long long int ans=0,l=0,r=0,mid;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&a[i]);\n        r+=a[i];\n    }\n    while(r-l>1){\n        mid=(r+l)/2;\n        if(check(mid))r=mid;\n        else l=mid;\n    }\n    \n    printf(\"%lld\\n\",r);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL-=2;\n\t\t\tif (LL <= -1)LL = 0;\n\t\t\twhile (AA[LL] - AA[r - 1] < sum)LL++;\n\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nvector<ll>V;\nint n;\nll MAX,sum;\nbool ok(ll x){\n  REP(i,n){\n    int res=V[i];\n    ll fis=*lower_bound(ALL(V),res+x);\n    if(fis==MAX)continue;\n    ll sec=*lower_bound(ALL(V),fis+x);\n    if(sec==MAX)continue;\n    ll thi=*lower_bound(ALL(V),sec+x);\n    if(thi<=sum+res)return true;\n  }\n  return false;\n}\nint main(){\n  cin>>n;\n  sum=0;\n  ll lb=0,rb=0;\n  V.PB(0);\n  REP(i,n){\n    ll a;\n    cin>>a;\n    V.PB(V[V.size()-1]+a);\n    sum+=a;\n  }\n  MAX=sum*3;\n  rb=sum;\n  REP(i,n)V.PB(V[i+1]+sum);\n  V.PB(MAX);\n  while(rb-lb>1){\n    ll mid=(rb+lb)/2;\n    if(ok(mid)){\n      lb=mid;\n    }else{\n      rb=mid;\n    }\n  }\n  cout<<lb<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nint sumArray(int, int);\nint getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tint sum = sumArray(0, N);\n\tint average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tint MaxMin = 0;\n\tint tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nint sumArray(int start, int end)\n{\n\tint sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nint getLocalMin(int p1, int p2, int p3)\n{\n\tint LocalMin = sumArray(p1, p2);\n\tint tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[100000];\nll S[200000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%lld\", &a[i]);\n\tS[0] = a[0];\n\tfor(int i = 1; i < 2*n; i++) S[i] = S[i-1]+a[i%n];\n\tll s = 1, e = 1000000000000001, mid;\n\t//printf(\"\\n\");\n\twhile(true){\n\t\tmid = (s+e)/2;\n\t\tif(e-s == 1) break;\n\t\tbool ok = false;\n\t\trep(i,n){\n\t\t\tint st;\n\t\t\tif(i != 0) st = lower_bound(S+i,S+i+n,mid+S[i-1])-S;\n\t\t\telse st = lower_bound(S+i,S+i+n,mid)-S;\n\t\t\tif(st == i+n) continue;\n\t\t\tst = lower_bound(S+st+1,S+i+n,mid+S[st])-S;\n\t\t\tif(st == i+n) continue;\n\t\t\tif(S[i+n-1]-S[st] >= mid){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) s = mid;\n\t\telse e = mid;\n\t\t//printf(\"%d\\n\", mid);\n\t}\n\tprintf(\"%d\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tif(0){\n\t\tFILE *inputFile = fopen(\"0600_in33.txt\", \"r\");\n\t\tfscanf(inputFile, \"%d\", &N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t\t}\n\t\tfclose( inputFile);\n\t} else {\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t}\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a3_sum, a1_sum, a2_sum;\n\t\n\ta3_sum = InArray[0];\n\tfor(int a1 = 0; a1 < N-2; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1+1; a2 < N-2;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta3_sum += InArray[a1];\n\t\tif(a3_sum > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL-=3;\n\t\t\tif (LL <= -1)LL = 0;\n\t\t\twhile (AA[LL] - AA[r - 1] < sum)LL++;\n\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\tsum2 = AA[N-1]-sum-sum1;\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define LL long long\nint N;\nLL A[200010];\n\nbool judge(LL x){\n    for(int s = 0; s < N; s++){//始点\n        int lb = s, ub = s + N + 1;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid] >= x + A[s]){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        int t = ub;\n        lb = ub;\n        ub = s + N + 1;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid] >= x + A[t]){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        if(A[s + N] - A[ub] > x) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> N;\n    for(int i = 1; i <= N; i++){\n        cin >> A[i];\n        A[i + N] = A[i];\n    }\n    for(int i = 1; i <= N * 2; i++){\n        A[i] += A[i - 1];\n    }\n    LL lb = 0;\n    LL ub = A[N];\n    while(ub - lb > 1){\n        LL mid = (ub + lb) / 2;\n        if(judge(mid)){\n            lb = mid;\n        }else{\n            ub = mid;\n        }\n    }\n    cout << lb << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntypedef int baumkuchen_size_t;\ntypedef int index_t;\n\nstd::vector<baumkuchen_size_t> pieces;\nbaumkuchen_size_t whole_size; // SUM OF SIZE OF PIECES\nbaumkuchen_size_t max_size;   // MAX SIZE OF THE SMALLEST PIECE\n\n\ninline void reguralize(index_t *x)\n{\n    if ((*x) < 0)\n        (*x) += pieces.size();\n    (*x) %= pieces.size();\n}\n\n\ninline void progress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev += pieces.at(idx);\n    size_curr -= pieces.at(idx);\n    ++idx;\n}\n\n\ninline void regress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev -= pieces.at(idx);\n    size_curr += pieces.at(idx);\n    --idx;\n}\n\n\nint main()\n{\n    // READ INPUTS\n    {\n        int num;\n        std::cin >> num;\n        pieces.assign(num, 0);\n\n        for (int i = 0; i < num; ++i)\n        {\n            std::cin >> pieces[i];\n            whole_size += pieces.at(i);\n        }\n        max_size = whole_size / 3;\n    }\n    \n    index_t idx1(0), idx2(1), idx3(2); // BEGIN INDEX OF EACH BAUMKUCHEN PIECE\n    baumkuchen_size_t\n        size1(pieces.at(idx1)),            // SIZE OF 1ST BAUMKUCHEN PIECE\n        size2(pieces.at(idx2)),            // SIZE OF 2ND BAUMKUCHEN PIECE\n        size3(whole_size - size1 - size2); // SIZE OF 3RD BAUMKUCHEN PIECE\n    int out(0); // RETURN VALUE\n\n    /* PRESUME THAT THE FIRST PIECE IS SMALLEST. */\n#define update { if (size1 > out) out = size1; }\n    \n    while (idx1 < pieces.size())\n    {\n        while (size1 <= max_size)\n        {\n            // CHECK WHETHER size1 CAN BE SMALLEST\n            while (true)\n            {\n                if (size1 <= size2 and size1 <= size3)\n                {\n                    update;\n                    break;\n                }\n\n                // NOTE: size2 & size3 CANNOT BE EQUAL HERE.\n                \n                bool was_larger(size2 > size3);\n                (size2 > size3) ?\n                    regress_idx(idx3, size2, size3) :\n                    progress_idx(idx3, size2, size3);\n                reguralize(&idx3);\n\n                if (size1 <= size2 and size1 <= size3)\n                {\n                    update;\n                    break;\n                }\n                else if ((size2 > size3) != was_larger)\n                    break;\n            }\n            \n            progress_idx(idx2, size1, size2);\n            reguralize(&idx2);\n        }\n\n        progress_idx(idx1, size3, size1);\n    }\n    \n    std::cout << out << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n   int a,b,c,d,e,f,g;\n   scanf(\"%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tint n;\n\tstatic ll a[100010];\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n ;i ++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\t\n\tint p = 1,q = 1,r = 1;\n\tll x = 0,y = 0,z = 0;\n\tfor(int i = 1; i <= n ;i ++)z += a[i];\n\t\n\tll ret = 0;\n\twhile(r != n){\n\t\tif(z >= max(x,y)){\n\t\t\ty += a[r];\n\t\t\tz -= a[r];\n\t\t\tr ++;\n\t\t}\n\t\telse if(y >= max(z,x)){\n\t\t\tx += a[q];\n\t\t\ty -= a[q];\n\t\t\tq ++;\n\t\t}\n\t\telse {\n\t\t\tz += a[p];\n\t\t\tx -= a[p];\n\t\t\tp ++;\n\t\t}\n\t\tret = max ( ret , min(min(x,y),z) );\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint a[111111*2];\nlong long sum[111111*2];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    assert(sum[m]-sum[l]+lim+sum[r]-sum[m]==sum[n]);\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] >= sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  //s = e;\n  assert(lim+sum[r]-sum[s]+sum[s]-sum[l]==sum[n]);\n  //printf(\":%lld %lld %lld %lld %d %d\\n\",lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  res = max(res,min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]));\n  return min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n  }\n  for( int j = 0; j < 2*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;s<n&&e<n;++e) {\n    while( e < n && C(s,e) >= sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }    \n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT binary_search(function<bool(T)> func, T include, T exclude)\n{\n  while (abs(exclude - include) > 1)\n  {\n    auto middle = (include + exclude) / 2;\n    (func(middle) ? include : exclude) = middle;\n  }\n  return include;\n}\n\nint N, A[200000], B[200000];\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N; i++)\n  {\n    cin >> A[i];\n    A[i + N] = B[i] = B[i + N] = A[i];\n  }\n  for(int i = 1; i < N * 2; i++)\n    B[i] += B[i - 1];\n  auto f = [&](int v)\n  {\n    for(int i = 0; i < N; i++)\n    {\n      auto it = lower_bound(B + i, B + N * 2, v + B[i]);\n      if(it == B + N * 2)\n        continue;\n      auto it2 = lower_bound(it, B + N * 2, v + *it);\n      if(it2 == B + N * 2)\n        continue;\n      if(B[i + N] - *it2 >= v)\n        return true;\n    }\n    return false;\n  };\n  cout << binary_search<long long>(f, 0, B[N]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n;\nint A[100010];\nll sum[200010];\n\nbool check(int i, ll x, bool f = false)\n{\n    int nowidx = i;\n    ll cur = i == 0 ? 0 : sum[i - 1];\n\n    rep(_, 2) {\n        nowidx = lower_bound(sum, sum + i + n, cur + x) - sum;\n        if (nowidx == i + n) return false;\n        cur = sum[nowidx];\n    }\n\n    return sum[i + n - 1] - sum[nowidx] >= x;\n}\n\nint main()\n{\n    n = in();\n\n    rep(i, n) {\n        A[i] = in();\n        sum[i] = A[i];\n        if (i) sum[i] += sum[i - 1];\n    }\n\n    rep(i, n - 1) {\n        sum[i + n] = A[i] + sum[i + n - 1];\n    }\n\n    ll ma = 0;\n\n    rep(i, n) {\n        ll l = 0, r = linf;\n\n        rep(_, 65) {\n            ll mid = (l + r) / 2;\n\n            (check(i, mid) ? l : r) = mid;\n        }\n\n        chmax(ma, l);\n    }\n\n    printf(\"%lld\\n\", ma);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n int main(){\n\n\t int N,point2,point3,tmp,sum;\n\t ll ans = -1;\n\t scanf(\"%d\",&N);\n\n\t ll* table = new ll[N+1];\n\t table[0] = 0;\n\n\t for(int i = 1; i <= N; i++){\n\t\t scanf(\"%lld\",&table[i]);\n\t\t table[i] += table[i-1];\n\t }\n\n\t ll left,right,m,inner_left,inner_right,inner_m;\n\t bool FLG;\n\n\t left = 1;\n\t right = table[N]/3;\n\t m = (left+right)/2;\n\n\t while(left <= right){\n\t\t FLG = false;\n\n\t\t for(int start = 1; start <= N; start++){\n\n\t\t\t inner_left = 1;\n\t\t\t inner_right = N-1;\n\t\t\t inner_m = (inner_left+inner_right)/2;\n\n\t\t\t point2 = -1;\n\n\t\t\t while(inner_left <= inner_right){\n\n\t\t\t\t if(start+inner_m > N){\n\t\t\t\t\t tmp = start+inner_m-N;\n\t\t\t\t }else{\n\t\t\t\t\t tmp = start+inner_m;\n\t\t\t\t }\n\n\t\t\t\t if(tmp > start){\n\t\t\t\t\t sum = table[tmp-1] - table[start-1];\n\t\t\t\t }else{\n\t\t\t\t\t sum = (table[N]-table[start-1]) + (table[tmp-1] - table[0]);\n\t\t\t\t }\n\n\t\t\t\t if(sum >= m){\n\t\t\t\t\tpoint2 = tmp;\n\t\t\t\t\tinner_right = inner_m-1;\n\t\t\t\t }else{\n\t\t\t\t\t inner_left = inner_m+1;\n\t\t\t\t }\n\t\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t }\n\n\t\t\t inner_left = 1;\n\n\t\t\t if(point2 > start){\n\t\t\t\t inner_right = N+start-point2-1;\n\t\t\t }else{\n\t\t\t\t inner_right = start-point2-1;\n\t\t\t }\n\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t point3 = -1;\n\n\t\t\t while(inner_left <= inner_right){\n\n\t\t\t\t if(point2+inner_m > N){\n\t\t\t\t\t tmp = point2+inner_m-N;\n\t\t\t\t }else{\n\t\t\t\t\t tmp = point2+inner_m;\n\t\t\t\t }\n\n\t\t\t\t if(tmp > point2){\n\t\t\t\t\t sum = table[tmp-1] - table[point2-1];\n\t\t\t\t }else{\n\t\t\t\t\t sum = (table[N]-table[point2-1]) + (table[tmp-1] - table[0]);\n\t\t\t\t }\n\n\t\t\t\t if(sum >= m){\n\t\t\t\t\t if(start > tmp){\n\t\t\t\t\t\t sum = table[start-1] - table[tmp-1];\n\t\t\t\t\t }else{\n\t\t\t\t\t\t sum = (table[N]-table[tmp-1]) + (table[start-1] - table[0]);\n\t\t\t\t\t }\n\t\t\t\t\t if(sum >= m){\n\t\t\t\t\t\t point3 = tmp;\n\t\t\t\t\t\t inner_right = inner_m-1;\n\t\t\t\t\t }else{\n\t\t\t\t\t\t inner_right = inner_m-1;\n\t\t\t\t\t }\n\t\t\t\t }else{\n\t\t\t\t\t inner_left = inner_m+1;\n\t\t\t\t }\n\t\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t }\n\n\t\t\t if(point3 == -1){\n\t\t\t\t continue;\n\t\t\t }else{\n\t\t\t\t FLG = true;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\t\t if(FLG){\n\t\t\t ans = m;\n\t\t\t left = m+1;\n\t\t }else{\n\t\t\t right = m-1;\n\t\t }\n\t\t m = (left+right)/2;\n\t }\n\n\t printf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong A[100000];\n\nint main(int argc, char const* argv[])\n{\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    int sep[3];\n    sep[0] = sep[1] = sep[2] = 0;\n\n    long size[3];\n    size[0] = size[1] = size[2] = 0;\n    for (int i = 0; i < N; i++) {\n        size[2] += A[i];\n    }\n\n    long max = size[0];\n\n    while (sep[2] < N) {\n        long min = size[0];\n        int argmin = 0;\n        for (int i = 0; i < 3; i++) {\n            if (size[i] <= min) {\n                min = size[i];\n                argmin = i;\n            }\n        }\n\n        size[(argmin+1)%3] -= A[sep[(argmin+1)%3]];\n        size[argmin] += A[sep[(argmin+1)%3]];\n        sep[(argmin+1)%3]++;\n\n        if (max < min) {\n            max = min;\n        }\n    }\n\n    cout << max << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n;\nint table[200000];\n\nbool solve(ll x) {\n\tint l, r = 1; // [l,r)\n\tREP(i, 2 * n) table[i] = i;\n\tREP(i, 2 * n) {\n\t\tl = i;\n\t\tif (l >= r) r = l + 1;\n\t\twhile (r - l < n && r < 2 * n && sum[r - 1] - sum[l] + a[l] < x) r++;\n\t\tif (sum[r - 1] - sum[l] + a[l] >= x) table[l] = r;\n\t}\n\t\n\tREP(i, n) {\n\t\tint pos = i;\n\t\tREP(j, 3) {\n\t\t\tif (pos == table[pos]) break;\n\t\t\tpos = table[pos];\n\t\t\tif (j == 2 && pos <= i + n) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[8][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i - 1][1] + a[i - 1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n - 1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[cut2][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < n; cut3_1++){\n\t\t\tif (baum - a[cut3_1][1] + a[cut1][1] < (baum - (a[cut2 - 1][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < n; cut3_2++){\n\t\t\tif (baum - a[cut3_2][1] + a[cut1][1] < (baum - (a[cut2][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3_1 - 1][1] - a[cut2 - 1][1];\n\t\tb[0][2] = baum - a[cut3_1 - 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3_1][1] - a[cut2 - 1][1];\n\t\tb[1][2] = baum - a[cut3_1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3_2 - 1][1] - a[cut2][1];\n\t\tb[2][2] = baum - a[cut3_2 - 1][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3_2][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3_2][1] + a[cut1][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst long long LINF = 1e18;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<ll,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll A[300010] = {};\nPii sum[300010] = {};\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\n\trep(i,N){\n\t\tscanf(\"%lld\",&A[i]);\n\t\tA[N+i] = A[i];\n\t\tA[2*N+i] = A[i];\n\t}\n\n\tsum[0].fr = 0;\n\tsum[3*N].sc = 3*N;\n\trep(i,3*N){\n\t\tsum[i+1].fr += sum[i].fr + A[i];\n\t\tsum[i].sc = i;\n\t}\n\n\t/*rep(i,3*N+1){\n\t\tprintf(\"%lld \",sum[i].fr);\n\t}\n\tputs(\"\");\n\n\trep(i,3*N+1){\n\t\tprintf(\"%lld \",sum[i].sc);\n\t}\n\tputs(\"\");*/\n\t\n\n\tll ans = -LINF;\n\n\trep(i,N){\n\t\tll l = 0;\n\t\tll r = sum[N].fr-sum[0].fr;\n\t\tint p,q,w;\n\t\twhile(l+1 != r){\n\t\t\t\n\t\t\tll m = (l + r) / 2;\n\t\t\t//printf(\"[%d , %d] => %d\\n\",l,r,m);\n\t\t\tPii tmp;\n\t\t\ttmp.fr = m + sum[i].fr; tmp.sc = 0;\n\t\t\tPii res1 = *lower_bound(sum+i,sum+i+N,tmp);\n\t\t\ttmp.fr = m + res1.fr;\n\t\t\tPii res2 = *lower_bound(sum+res1.sc,sum+res1.sc+N,tmp);\n\t\t\ttmp.fr = m + res2.fr;\n\t\t\tPii res3 = *lower_bound(sum+res2.sc,sum+res2.sc+N,tmp);\n\t\t\t//printf(\"res1(%lld , %d)\\n\",res1.fr,res1.sc);\n\t\t\t//printf(\"res2(%lld , %d)\\n\",res2.fr,res2.sc);\n\t\t\t//printf(\"res3(%lld , %d)\\n\",res3.fr,res3.sc);\n\t\t\t\n\t\t\tif(res3.sc <= i+N){\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tPii _tmp;\n\t\t_tmp.fr = l + sum[i].fr; _tmp.sc = 0;\n\t\tPii _res1 = *lower_bound(sum+i,sum+i+N,_tmp);\n\t\t_tmp.fr = l + _res1.fr;\n\t\tPii _res2 = *lower_bound(sum+_res1.sc,sum+_res1.sc+N,_tmp);\n\t\t_tmp.fr = l + _res2.fr;\n\t\tPii _res3 = *lower_bound(sum+_res2.sc,sum+_res2.sc+N,_tmp);\n\t\tp = _res1.sc; q = _res2.sc; w = _res3.sc;\n\t\t//printf(\"[%d , %d] => %lld %lld %lld\\n\",l,r,sum[p].fr-sum[i].fr,sum[q].fr-sum[p].fr,sum[w].fr-sum[q].fr);\n\t\t\n\t\tans = max(ans,min(sum[p].fr-sum[i].fr,min(sum[q].fr-sum[p].fr,sum[w].fr-sum[q].fr)));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll n;\nll sum;\nvector<ll> a;\nll MAX;\nll ans;\n\nbool can_cut(ll len){\n\tfor (int i = 0;i < n;i++){\n\t\tint idx1 = lower_bound(a.begin(), a.end(), a[i]+len) - a.begin();\n\t\tif(idx1-i > n) continue;\n\t\tint idx2 = lower_bound(a.begin(), a.end(), a[idx1]+len) - a.begin();\n\t\tif(idx2-i > n) continue;\n\t\tif(a[i+n] - a[idx2] < len) continue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n;\n\tsum = 0;\n\tMAX = LLONG_MAX;\n\n\tfor (int i = 0;i < n;i++){\n\t\tll tmp; cin >> tmp;\n\t\tsum += tmp;\n\t\ta.push_back(sum);\n\t}\n\n\tfor (int i = 0;i < n;i++){\n\t\ta.push_back(a[i]+sum);\n\t}\n\n\tll low = 1;\n\tll high = 1000000000*n;\n\n\twhile(high-low > 1){\n\t\tll mid = (low+high)/2;\n\t\tif(can_cut(mid)) low = mid;\n\t\telse high = mid;\n\t}\n\n\tcout << low << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tint Left,Right,Mid;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\n\t\tLeft=i;Right=n+i+1;\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid-1)%n+1]>B && s[(Mid-2)%n+1]>B){\n\t\t\t\tLeft=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid-1)%n+1]<B){\n\t\t\t\tRight=Mid+1;\n\t\t\t}\n\t\t}\n\t\tB2=Mid;\n\t\tLeft=i;Right=n+i+1;\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid-1)%n+1]>C && s[(Mid-2)%n+1]>C){\n\t\t\t\tLeft=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid-1)%n+1]<C){\n\t\t\t\tRight=Mid+1;\n\t\t\t}\n\t\t}\n\t\tC2=Mid;\n\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll n;\n  scanf(\"%lld\",&n);\n  vector<ll> a(n*2),sum(n*2+1,0);\n  for(int i=0;i<n;i++)scanf(\"%lld\",&a[i]), a[n+i] = a[i];\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i];\n\n  ll ans=0, l=0, r=0;\n  while(l<n){\n    while(r<l+n-1 && 3*(sum[r]-sum[l])<=sum[n])r++; r--;\n    if(r-l>1){\n      ll cur = sum[r]-sum[l], rem = sum[n]-cur, L=r, R=l+n;\n      while(R-L>1){\n\tll M = (L+R)/2;\n\tif(2*(sum[M]-sum[r])<rem)L = M;\n\telse R = M;\n      }\n\t\n      ll minv = 0;\n      for(int i=0;i<2;i++){\n\tif(R-i<l+n && r<R-i)minv = max(minv, min(sum[R-i]-sum[r], sum[l+n]-sum[R-i]));\n      }\n      minv = min(minv, cur);\n      ans = max(ans, minv);\n    }\n    l++; if(r<l)r++;\n  }\n\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,c2=0,c3=0;\n\tlong long int m=0,s=0,s1=0,s2;\n\tlong long int a[100000];\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> a[i];\n\t\ts+=a[i];\n\t}\n\tfor(int c1=0;c1<n;c1++){\n\t\twhile(s1*3<s){\n\t\t\ts1+=a[c2%n];\n\t\t\ts2-=a[c2%n];\n\t\t\tc2++;\n\t\t}\n\t\tif(c3<=c2){\n\t\t\tc3=c2+1;\n\t\t\ts2=a[c2%n];\n\t\t}\n\t\twhile(s2*2<(s-s1)){\n\t\t\ts2+=a[c3%n];\n\t\t\tc3++;\n\t\t}\n\t\tif(m<s-s1-s2){\n\t\t\tm=s-s1-s2;\n\t\t}\n\t\tc3--;\n\t\ts2-=a[c3%n];\n\t\tif(m<s2){\n\t\t\tm=s2;\n\t\t}\n\t\ts1-=a[c1%n];\n\t}\n\tcout << m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = lower_bound(all(cuts), cuts[j] + rem) - cuts.begin();\n\t\t\tint k = min(sep, n - 1);\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n#define SUPpl 100002\n\ntypedef long long ll;\n\nint i,j,k,l;\nint pl;\nll ps[SUPpl*2];\nll sps[SUPpl*2+1];\nll re;\nint rei=0,rej=0,rek=0;\n\nvoid decideK(){\n\tint ak=j;\n\tint bk=l;\n\twhile(bk-ak>1){\n\t\tk = (ak+bk)/2;\n\t\tif( sps[k]-sps[j] ==sps[l]-sps[k] ) {ak=k;bk=k;break;}\n\t\tif( sps[k]-sps[j] < sps[l]-sps[k] ) ak=k;\n\t\tif( sps[k]-sps[j] > sps[l]-sps[k] ) bk=k;\n\t}\n\tif(min(sps[ak]-sps[j],sps[l]-sps[ak]) >= min(sps[bk]-sps[j],sps[l]-sps[bk])) k=ak;\n\telse k=bk;\n}\n\nvoid decideJK(){\n\tint aj=i;\n\tint bj=l;\n\twhile(bj-aj>1){\n\t\tj = (aj+bj)/2;\n\t\tdecideK();\n\t\tif( sps[j]-sps[i] ==min(sps[k]-sps[j],sps[l]-sps[k]) ) {aj=j;bj=j;break;}\n\t\tif( sps[j]-sps[i] < min(sps[k]-sps[j],sps[l]-sps[k]) ) aj=j;\n\t\tif( sps[j]-sps[i] > min(sps[k]-sps[j],sps[l]-sps[k]) ) bj=j;\n\t}\n\tj=aj;\n}\n\nvoid decideIJK(){\n\tre=0;\n\tfor(i=0;i<pl;i++){\n\t\tl=i+pl;\n\t\tdecideJK();\n\t\tif(re<sps[j]-sps[i]){\n\t\t\tre=sps[j]-sps[i];\n\t\t\trei=i;rej=j;rek=k;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> pl;\n\tREP(pi,pl) cin>>ps[pi];\n\tREP(pi,pl) ps[pi+pl]=ps[pi];\n\tREP(pi,pl*2) sps[pi+1]=sps[pi]+ps[pi];\n\n\tdecideIJK();\n\tcout<<re<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N 100000\n\nusing namespace std;\n\ntypedef unsigned long long int uint64;\n\nvector<uint64> S;\nint N;\n\nbool ctb(uint64 x)\n{\n\tint able = false;\n\tfor(int ofs = 0;ofs < N;ofs++)\n\t{\n\t\tauto itr = lower_bound(S.begin(),S.end(),S[ofs]+x);\n\t\titr = lower_bound(itr,S.end(),*(itr)+x);\n\t\titr = lower_bound(itr,S.end(),*(itr)+x);\n\t\tif(itr < S.begin()+ofs+N+1)\n\t\t{\n\t\t\table = true;\n\t\t}\n\t}\n\treturn able;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tuint64 s = 0;\n\tuint64 t;\n\tS.push_back(0);\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> t;\n\t\ts += t;\n\t\tS.push_back(s);\n\t}\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tS.push_back(S[i+1] + S[N]);\n\t}\n\tS.push_back(S[2*N]+1);\n\tuint64 L = S[N-1];\n\tuint64 S = 1;\n\tuint64 m;\n\twhile(S != L)\n\t{\n\t\tm = (((L-S)+1)/2)+S;\n\t\tif(ctb(m))\n\t\t{\n\t\t\tS = m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL = m-1;\n\t\t}\n\t}\n\tcout << S << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll a[300000];\nint main() {\n\tll n; scanf(\"%lld\", &n);\n\trep(i, n) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1 + n] = a[i + 1];\n\t}\n\tfor (ll i = 1; i <= 2 * n; i++)\n\t\ta[i] += a[i - 1];\n\tll s = 0, g = 1000000000 * n;\n\twhile (s != g) {\n\t\tll t = (s + g) / 2;\n\t\tif (g - s == 1)t = g;\n\t\tbool flag = false;\n\t\trep(i, n) {\n\t\t\tll j = lower_bound(a + i, a + i + n + 1, a[i] + t) - a;\n\t\t\tif (j == n + i + 1)continue;\n\t\t\tll k = lower_bound(a + j, a + i + n + 1, a[j] + t) - a;\n\t\t\tif (a[j] - a[i] >= t&&a[k] - a[j] >= t&&a[i + n] - a[k] >= t) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)s = t;\n\t\telse g = t - 1;\n\t}\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nsigned main(){\n  int n;\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n   \n  int X[N]={};\n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n   \n  int ans = 0,len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int a  = lower_bound(X+i,X+3*n,X[i]+len/3)-X;\n    int la = X[a]-X[i];\n    int b = lower_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n    int lb = X[b] - X[a];\n    int lc = len-la-lb;\n    ans = max(ans,min(la,min(lb,lc)));\n  }\n  cout<< ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nvoid CalcPiece1(int *_i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i2 < _i1 + _N - 2;){\n\t\t*_piece1_s = *_piece1_l;\n\t\t*_piece1_l += _A[*_i2%_N];\n\t\t(*_i2)++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n}\n\nvoid CalcPiece3(int *_i3, ull *_piece3_s, ull *_piece3_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i3 < _i1 + _N - 1;){\n\t\t*_piece3_l = *_piece3_s;\n\t\t*_piece3_s -= _A[*_i3%_N];\n\t\t(*_i3)++;\n\t\tif (*_piece3_s <= _one_third_size) break;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tint *A = new int[N];\n\tull total_size = 0;\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\tconst int i1_fin = i2;\n\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tCalcPiece3(&i3, &piece3_s, &piece3_l, i1_ini, N, one_third_size, A);\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse CalcPiece1(&i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse CalcPiece3(&i3, &piece3_s, &piece3_l, i1, N, one_third_size, A);\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint ushi;\nint uma;\nint shika;\nint ka;\nint j;\n\nint main(){\n  cin>>n;\n  int a[300000];\n  int z[300000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<=c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    d=d-1;\n    while(e<c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    z[j]=min(b,f);\n    shika=max(z[j-1],z[j]);\n  }\n  b=0;\n  c=0;\n  e=0;\n  f=0;\n  d=0;\n  for(int m;m<n;m++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    };\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    e=e-a[d];\n    f=c-b-e;\n    z[m]=min(b,f);\n    ka=max(z[m-1],z[m]);\n  }\n  \n  cout<<max(ka,shika)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll sum[200001];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<ll> baumkuchen;\n\n    memset(sum,0,sizeof(sum));\n    for(int i=0;i<N;i++){\n      ll width;\n      scanf(\"%lld\",&width);\n      baumkuchen.push_back(width);\n      sum[i+1] = sum[i] + width;\n    }\n    \n    for(int i=0;i<N;i++){\n      sum[N + i + 1] = sum[N] + sum[i + 1];\n    }\n\n    ll lhs = 0;\n    ll rhs = 10000000000LL;\n    for(int round = 0; round < 50; round++){\n      ll mid = lhs + (rhs - lhs) / 2LL;\n\n      bool isok = false;\n      for(int i=0;i<N;i++){\n        ll offset = sum[i];\n        int div_idx = lower_bound(sum,sum + 2 * N,offset + mid) - sum;\n        div_idx = lower_bound(sum,sum + 2 * N,sum[div_idx] + mid) - sum;\n        div_idx = lower_bound(sum,sum + 2 * N,sum[div_idx] + mid) - sum;\n        if(div_idx <= i + N){\n          isok = true;\n          break;\n        }\n      }\n      if(isok){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n\n    printf(\"%lld\\n\",lhs);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n);\n\t\trep(i, n) cin >> cuts[i];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = (sum - size) / 2.0;\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100010);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    \n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  REP(i, n) scanf(\"%lld\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  REP(i, 100){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size + 1) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(l, -1, 2)\n\t\t\t{\n\t\t\t\tint k = sep + l;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tans = max(ans, min({ a, b, c }));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = LLONG_MAX/4;\n\nbool c(ll x, int idx, vector<ll> &B)\n{    \n    int N = B.size() / 2;\n    int p1 = lower_bound(B.begin(), B.end(), x + B[idx]) - B.begin();\n    if (p1 - idx > N) return 0;\n    int p2 = lower_bound(B.begin(), B.end(), x + B[p1]) - B.begin();\n    if (p2 - idx > N) return 0;\n    int p3 = lower_bound(B.begin(), B.end(), x + B[p2]) - B.begin();    \n    return (p3 - idx <= N) && (B[p3] - B[p2] >= x);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<ll> A(N), B(2*N, 0);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        B[i] = A[i] + (i > 0 ? B[i-1] : 0);\n    }\n    for (int i = 0; i < N; i++) {\n        B[N+i] = B[N+i-1] + A[i];\n    }\n    ll res = 0;\n    for (int i = 0; i < N; i++) {\n        ll lb = 0, ub = INF;\n        while (ub - lb > 1) {\n            ll mid = (lb + ub) / 2;\n            if (c(mid, i, B)) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        res = max(res, lb);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 100000000000000\ntypedef __int64 Int;\nint N;\nInt A[MAX_N * 2 + 1];\n\nbool CC(int a, int b, Int x){\n\treturn A[b] - A[a] >= x;\n}\n\nbool C(Int x){\n\tint lb, ub, left;\n\tbool cut;\n\tfor(int i = 0; i <= N; i++){\n\t\tleft = i; lb = i; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tleft = ub; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tleft = ub; ub = 2 * N + 1;\n\t\tcut = false;\n\t\twhile(ub - lb > 1){\n\t\t\tint mid = (lb + ub) / 2;\n\t\t\tif(CC(left, mid, x)){\n\t\t\t\tub = mid;\n\t\t\t\tcut = true;\n\t\t\t}\n\t\t\telse lb = mid;\n\t\t}\n\t\tif(!cut) continue;\n\t\tif(ub - i < N + 1) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tA[0] = 0;\n\tscanf(\"%I64d\", &A[1]);\n\tA[N + 1] = A[1];\n\tfor(int i = 2; i <= N; i++){\n\t\tscanf(\"%I64d\", &A[i]);\n\t\tA[i] += A[i - 1];\n\t\tA[i + N] = A[i];\n\t}\n\tfor(int i = N + 1; i <= N * 2; i++){\n\t\tA[i] += A[N];\n\t}\n\t\n\tInt lb = 0, ub = INF;\n\twhile(ub - lb > 1){\n\t\tInt mid = (lb + ub) / 2;\n\t\tif(C(mid)) lb = mid;\n\t\telse ub = mid;\n\t}\n\t\n\tprintf(\"%I64d\\n\", lb);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\n\nint n;\nInt a[200010];\nInt s[200010];\n\nbool cond(Int x)\n{\n\tint p0 = 0, p1 = 0, p2 = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tp2 = i + n;\n\t\twhile (p0 < p2 && s[p0] - s[i] < x) p0++;\n\t\twhile (p1 < p2 && s[p1] - s[p0] < x) p1++;\n\t\tcout << i << \" \" << p0 << \" \" << p1 << \" \" << p2 << endl;\n\t\tif (s[p0] - s[i] > s[p1] - s[p0]) continue;\n\t\tif (s[p0] - s[i] > s[p2] - s[p1]) continue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i + n] = a[i];\n\t}\n\n\tfor (int i = 0; i < 2 * n; i++){\n\t\ts[i + 1] = s[i] + a[i];\n\t}\n\n\tInt lb = 0, ub = 1e15;\n\twhile (ub - lb > 1){\n\t\tInt md = (lb + ub) / 2;\n\t\t(cond(md) ? lb : ub) = md;\n\t}\n\n\tcout << lb << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tint* A;\t//一つ一つのバウムクーヘンの大きさ\n\tint sum_baum=0;\n\n\tvoid set_value();\t//値のセット\n\tbool set = false;\t//値のセットを行ったかどうかを判別する変数\n\n\tint tripartition();\t//\n\tint piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\n\tint full_search();\n\n};\n\nbaumkuchen::baumkuchen(){\n}\n\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n}\n\nint baumkuchen::tripartition(){\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tsum += A[N];\n\t}\n\treturn sum;\n}\n\nint baumkuchen::piece(int cut_1, int cut_2){\n\tint piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::set_value(){\n\tcin >> N;\n\tA = new int[N];\n\n\tset = true;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\tsum_baum += A[i];\n\t}\n\tN -= 1;\n}\n\nint baumkuchen::full_search(){\n\tint keep_value;\n\tint set_value=0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->full_search()<<endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200000];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i < 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1--, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL, RR, CC;\nint main()\n{\n\tint i, j, k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1;\n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2 * N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif (l != 0)sum = AA[r] - AA[l - 1];\n\t\telse sum = AA[r];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N - 1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r + 1; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif (AA[CC - 1] - AA[r] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2){\n\t\t\t\tans = max(ans, sum); l++;\n\t\t\t}\n\t\t\telse r++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n;\nvector<long long> a;\nbool check(int i, long long  m)\n{\n\tvector<long long>::iterator hoge = lower_bound(a.begin() + i, a.begin() + i + n - 1, m + *(a.begin() + i - 1));\n\tvector<long long>::iterator hage = lower_bound(hoge, a.begin() + i + n - 1, m + *hoge);//\n\tif (*(a.begin() + i + n - 1) - (*hage) >= m)return true;\n\treturn false;\n}\n\n\nint main()\n{\n\ta.push_back(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++)a.push_back(a[i]);\n\tfor (int i = 1; i < a.size(); i++)a[i] += a[i - 1];\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long  l = 0,r = 50000000000;\n\t\twhile (r != l){\n\t\t\tlong long m = (r + l+1) / 2;\n\t\t\tif (check(i+1, m))\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, l);\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=1e14;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n\tint fir=*lower_bound(ALL(sum),x);\n\tint sec=*lower_bound(ALL(sum),fir+x);\n\tint thi=*lower_bound(ALL(sum),sec+x);\n\tif(thi<=cnt)return true;\n\tREP(i,n){\n\t\tfir=*lower_bound(ALL(sum),a[i]+x);\n\t\tsec=*lower_bound(ALL(sum),fir+x);\n\t\tthi=*lower_bound(ALL(sum),sec+x);\n\t\tif(thi<=a[i]+cnt)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tcnt+=a[i];\n\t}\n\tsum.resize(n*2);\n\tREP(i,n*2){\n\t\tif(i==0){\n\t\t\tsum[i]=a[i];\n\t\t}else{\n\t\t\tsum[i]=sum[i-1]+a[i%n];\n\t\t}\n\t}\n\tsum.PB(MAX+1);\n\tll lb=0,rb=MAX+1;\n\twhile(rb-lb>1){\n\t\tll mid=(rb+lb)/2;\n\t\tif(ok(mid)){\n\t\t\tlb=mid;\n\t\t}else{\n\t\t\trb=mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "//図を書けばバグらない(バグったorz\n#include<stdio.h>\n\nlong long N;\nlong long rui[200001];\n\nlong long max( long long a,long long b ){\n\tif( a > b )\n\t\treturn a;\n\treturn b;\n}\nlong long min( long long a,long long b ){\n\tif( a < b )\n\t\treturn a;\n\treturn b;\n}\n\nint main(){\n\tint i,j,k;\n\n\tscanf(\"%d\",&N);\n\tfor( i = 1;i <= N;i++ ){\n\t\tscanf(\"%d\",rui+i);\n\t\trui[i] += rui[i-1];\n\t}\n\tfor( i = N+1;i <= 2*N;i++ ){\n\t\trui[i] = rui[N] + rui[i-N];\n\t}\n\n\tlong long ij, jk, ki;\t\t\n\tlong long ans = 0;\n\n\tfor( i = 0;i < N;i++ ){\n\t\tfor( j = i+1;j < N;j++ ){\n\t\t\tfor( k = j+1;k < N;k++ ){\n\t\t\t\tij = rui[j] - rui[i];\n\t\t\t\tjk = rui[k] - rui[j];\n\t\t\t\tki = rui[i+N] - rui[k];\n\n\t\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nint main()\n{\n\tint n;\n\tint a[100000];\n\tint t[300000];\n\t\n\tlint sum = 0;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", a + i);\n\t\tsum += a[i];\n\t}\n\t\n\tlint left = 0, right = sum / 3;\n\t\n\twhile (left != right){\n\t\tlint mid = (left + right + 1) >> 1;\n\t\tlint sum2 = 0;\n\t\t\n\t\tint head = 0, tail = 0;\n\t\tfor (; head < n; head++){\n\t\t\twhile (sum2 < mid){\n\t\t\t\tsum2 += a[tail % n];\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\tt[head] = tail - 1;\n\t\t\tt[head + n] = tail - 1 + n;\n\t\t\tt[head + n + n] = tail - 1 + n + n;\n\t\t\tsum2 -= a[head];\n\t\t}\n\t\t\n\t\tbool ok = false;\n\t\tfor (head = 0; head < n; head++){\n\t\t\tif (t[t[t[head] + 1] + 1] - head + 1 <= n){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ok) left = mid;\n\t\telse right = mid - 1;\n\t}\n\t\n\tprintf(\"%lld\\n\", left);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  for (l = 0; l < n; l ++) {\n    for (; _sum[r] - _sum[l] <= _max; r ++);\n    r --;\n\n    left = _sum[r] - _sum[l];\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n    if (mid_id < 0) cout << mid_id << endl;\n\n    ans = max(ans, min(left, rem));\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll solve();\nbool possible(ll,int);\nint N;\nll S[200010];\nint main()\n{\n    ll ANS;\n    scanf(\"%d\",&N);\n    for(int i = 1; i <= N; i++)\n    {\n        scanf(\"%d\",&S[i]);\n        if(i > 0)S[i] += S[i - 1];\n    }\n    for(int i = N + 1; i <= 2 * N; i++)\n    {\n        S[i] = S[N] + S[i - N];\n    }\n    ANS = solve();\n    printf(\"%lld\\n\",ANS);\n    return 0;\n}\nll solve()\n{\n    ll l = 1,r = S[N] + 1;\n    while(r - l > 0)\n    {\n        ll m = (r + l) / 2;\n        bool up1 = 0,up2 = 0;\n        for(int i = 0; i < N; i++)\n        {\n            up1 = up1 | possible(m,i);\n            up2 = up2 | possible(m + 1,i);\n        }\n        if(up1 && !up2)return m;\n        if(up1)l = m + 1;\n        else r = m;\n    }\n    return l;\n}\nbool possible(ll O,int C)\n{\n    ll M = O;\n    for(int i = 0; i < 3; i++)\n    {\n        if(M > S[C + N] - S[C])return false;\n        ll l = C + 1,r = C + N + 1;\n        while(r - l > 0)\n        {\n            ll m = (r + l) / 2;\n            if((S[m] - S[C] > M && S[m - 1] - S[C] < M) || S[m] - S[C] == M)\n            {\n                M = S[m] - S[C] + O;\n                break;\n            }\n            if(S[m] - S[C] > M)r = m;\n            else l = m + 1;\n        }\n    }\n    return true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\nusing namespace std;\nconst int N=1e5+10;\nconst long long int INF=1<<30;\nlong long int a[N],tot=0,s[N];\nmap<long long int ,int>m;\nbool check(long long int val,int pos){\n    int temp=m.lower_bound(s[pos-1]+val)->second;\n    long long int ans;\n    if(temp==N)return false;\n    ans=m.lower_bound(s[temp]+val)->first-s[pos-1];\n    temp=m.lower_bound(s[temp]+val)->second;\n    if(temp==N)return false;\n    if(tot-ans<val)return false;\n    return true;\n}\nint main(){\n    long long int l=0,r,mid;\n    int n;\n    scanf(\"%d\",&n);\n    s[0]=0;\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        tot+=a[i];\n        s[i]=s[i-1]+a[i];\n        m.insert({s[i],i});\n    }\n    m.insert({INF,N});\n    for(int i=1;i<=n;i++){\n        r=tot;\n        while(r-l>1){\n            mid=(r+l)>>1;\n            if(check(mid,i))l=mid;\n            else r=mid;\n        }\n    }\n    printf(\"%lld\\n\",l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    int A[100000];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    int mi=0;\n    for (int i=0; i<num-2; i++) {\n        for (int j=i+1; j<num-1; j++) {\n            for (int k=j+1; k<num; k++) {\n                \n                int aa=0,bb=0,cc=0;\n                for (int i2=i; i2< j; i2++) {\n                    aa+=A[i2];\n                }\n                \n                for (int i3=j; i3< k; i3++) {\n                    bb+=A[i3];\n                }\n                \n                for (int i4=k; i4< num; i4++) {\n                    cc+=A[i4];\n                }\n                for (int i4=0; i4< i; i4++) {\n                    cc+=A[i4];\n                }\n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\t\tfor (int j = i; j <= n + i; j++) {\n\t\t\tif (s[j%n] >= B) { B2 = s[j%n]; d = j % n; break; }\n\t\t}\n\t\tfor (int j = i; j <= n + i; j++) {\n\t\t\tif (s[j%n] >= C) { C2 = s[j%n]; e = j % n; break; }\n\t\t}\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0 + 0.5;\n\n\t\tint ans = 0;\n\t\trep(i, n + 1)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = double(sum - len) / 2.0 + 0.5;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tans = max(ans, sum - len - remlen);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n#include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)   (x).begin(),(x).end()\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define mp       make_pair\n#define eb       emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\n\nLL a[2020200];\nLL b[2020200];\nLL n;\n\nbool calc(LL m) {\n\tfor (int i = 0; i < n; i++) {\n\t\tLL tmp = (i == 0 ? 0 : b[i - 1]);\n\t\tint pos1 = lower_bound(b + i, b + i + n, tmp + m) - b;\n\t\tint pos2 = lower_bound(b + i, b + i + n, b[pos1] + m) - b;\n\t\tif (b[n + i - 1] - b[pos2] >= m)return true;\n\t}\n\treturn false;\n}\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = n; i < n * 2; i++) {\n\t\ta[i] = a[i - n];\n\t}\n\tb[0] = a[0];\n\tfor (int i = 1; i < n * 2; i++) {\n\t\tb[i] = a[i] + b[i - 1];\n\t}\n\n\tLL left = 1, right = b[n - 1];\n\twhile (right - left > 1) {\n\t\tLL mid = (right + left) / 2;\n\t\tif (calc(mid)) {\n\t\t\tleft = mid;\n\t\t}\n\t\telse {\n\t\t\tright = mid;\n\t\t}\n\t}\n\tcout << left << endl;\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200000];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i < 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\t\tint posl2 = posr2 - 1;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[100000];\nll AA[100000];\nint main()\n{\n\tint i,j,k;\n\tll sum1 = 0;\n\tll sum2 = 0;\n\tll sum3 = 0;\n\tll ans = 0;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++)scanf(\"%lld\", &A[i]);\n\tAA[0] = A[0];\n\tfor (i = 1; i < N; i++)AA[i] = AA[i - 1] + A[i];\n\tfor (i = 0; i < N; i++){\n\t\tfor (j = i + 1; j < N; j++){\n\t\t\tfor (k = j+1; k < N; k++){\n\t\t\t\tsum1 = 0;\n\t\t\t\tsum2 = 0;\n\t\t\t\tsum3 = 0;\n\t\t\t\tif(i!=0)sum3 += AA[i-1];\n\t\t\t\tif(i!=0)sum1 += AA[j-1]-AA[i-1];\n\t\t\t\telse sum1 += AA[j - 1];\n\t\t\t\tsum2 += AA[k-1]-AA[j-1];\n\t\t\t\tsum3 += AA[N-1]-AA[k-1];\n\t\t\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s[50001],t[50001],e[50001];\n  cin>>n>>m;\n  int i=0;\n  while(cin>>s[i]>>t[i]>>e[i],s[i])s[i]--,t[i]--,i++;\n  int l;\n  cin>>l;\n  for(int j=0;j<l;j++){\n    int b[10000];\n    for(int k=0;k<m;k++){\n      cin>>b[k];\n    }\n    int ans[10000]={};\n    for(int k=0;k<i;k++)\n      ans[s[k]]+=e[k]*b[t[k]];\n    for(int k=0;k<n;k++){\n      if(k)cout<<\" \";\n      cout<<ans[k];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n\nconst int INF=1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N;\nint A[200004];\nlong long int B[100002];\n\n\nint main(){\n\tFILE *fp;\n\tfp=fopen(\"F:\\\\1JOI本選\\\\2014\\\\joi2014-ho-data\\\\joi2014-ho-data\\\\2014-ho-t3\\\\in\\\\03-06.txt\",\"r\");\n\tfscanf(fp,\"%d\",&N);\n\tlong long int MAX = 0;\n\trep(i,N){\n\t\tfscanf(fp,\"%d\",&A[i]);\n\t\tMAX+=A[i];\n\t\tB[i]=MAX;\n\t}\n\tmemcpy(&A[N],A,sizeof(int)*N);\n\t\n\tlong long int M=MAX/3;//全てのピースがM以上になる切り方は存在するか?\n\tlong long int m=0;\n\tdo{\n\t\tbool cann=false;//全てのピースがn以上になる切り方は存在するか?\n\t\tlong long int n=(M+m)/2;\n\t\trep(i,N-2){//どこで最初に切るか\n\t\t\tint a=i;//よりあとで切る\n\t\t\tint b=N-2;//以前で切る\n\t\t\tdo{//次に切る場所を探す\n\t\t\t\tint c=(a+b)/2;\n\t\t\t\tlong long int piece1=B[c]-B[i];\n\t\t\t\tif(piece1>=n){b=c;}//c以前で切れる\n\t\t\t\telse a=c;//cよりあとで切るべき\n\t\t\t}while(b>a+1);\n\t\t\tlong long int p1=B[b]-B[i];\n\t\t\tif(p1<n)continue;//1個目がもうだめ\n\t\t\tint x=b;\n\t\t\tint y=N-1;\n\t\t\tdo{//最後に切る場所を探す\n\t\t\t\tint z=(x+y)/2;\n\t\t\t\tlong long int piece2=B[z]-B[b];\n\t\t\t\tif(piece2>=n){y=z;}\n\t\t\t\telse x=z;\n\t\t\t}while(y>x+1);\n\t\t\tlong long int p2=B[y]-B[b];\n\t\t\tif(p2<n)continue;//2個目がもうだめ\n\t\t\tif(MAX-p1-p2>=n){cann=true;}\n\t\t}\n\t\tif(cann){m=n;}//すべて(３つ)のピースがn以上になりえる\n\t\telse{M=n;}\n\t}while(M>m+1);\n\tprintf(\"%lld\\n\",m);\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    ll sum=0;\n    vector<ll> a(2*n);\n    rep(i,n)\n    {\n        scanf(\" %lld\", &a[i]);\n        a[i+n]=a[i];\n        sum+=a[i];\n    }\n\n    vector<ll> presum(2*n+1,0);\n    for(int i=1; i<=2*n; ++i) presum[i] = presum[i-1]+a[i-1];\n\n    ll ans=0;\n    rep(i,n)\n    {\n        int x = lower_bound(all(presum),presum[i]+sum/3)-presum.begin();\n        int y = lower_bound(all(presum),presum[i]+sum*2/3)-presum.begin();\n        for(int j=x-2; j<=x+2; ++j)for(int k=y-2; k<=y+2; ++k)\n        {\n            if(i<j && j<k && j<i+n && k<i+n)\n            {\n                ll p = presum[j]-presum[i];\n                ll q = presum[k]-presum[j];\n                ll r = presum[i+n]-presum[k];\n\n                ans = max(ans, min({p,q,r}));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i-1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n-1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3;\n\t\tfor (cut2 = cut1 + 1; ; cut2++){\n\t\t\tif (a[cut2+1][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3 = cut2 + 1; cut3 < n; cut3++){\n\t\t\tif (baum - a[cut3][1] + a[cut1][1] >(baum - (a[cut2+1][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 + 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3 + 1][1] - a[cut2 + 1][1];\n\t\tb[0][2] = baum - a[cut3 + 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3 + 1][1] - a[cut2][1];\n\t\tb[1][2] = baum - a[cut3 + 1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2 + 1][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3][1] - a[cut2 + 1][1];\n\t\tb[2][2] = baum - a[cut3][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3][1] + a[cut1][1];\n\t\tminb = baum;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N) {\n        vector<int> A(2 * N);\n        REP(i, N) cin >> A[i];\n        REP(i, N) A[N + i] = A[i];\n        vector<int> cum(A.size() + 1);\n        REP(i, A.size()) cum[i + 1] = cum[i] + A[i];\n        \n        int S = cum[N];\n\n        int ans = 0;\n        for(int i = 0, j = 0; i < N; i++) {\n            while(cum[j + 1] - cum[i] < S / 3) {\n                j++;\n            }\n            // A[i] + ... + A[j - 1] < S / 3, \n            // A[i] + ... + A[j] >= S / 3\n            for(int l = j - i - 3; l <= j - i + 3; l++) if(l >= 1 && N - l >= 2) {\n                int k = i + l;\n                // A[i, k) + A[k, i + N)\n                int lb = 0, ub = N - l; // \n                while(ub - lb > 1) {\n                    int mid = (lb + ub) / 2;\n                    if(cum[k + mid] - cum[k] < S / 3) {\n                        lb = mid;\n                    } else {\n                        ub = mid;\n                    }\n                }\n                for(int m = lb - 3; m <= lb + 3; m++) if(m >= 1 && N - l - m >= 1) {\n                    int S1 = cum[i + l] - cum[i];\n                    int S2 = cum[i + l + m] - cum[i + l];\n                    int S3 = cum[i + N] - cum[i + l + m];\n                    ans = max(ans, min({S1, S2, S3}));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nll _sum[300010], *sum = _sum+1;\nint main(void){\n\t_sum[0] = 0;\n\tint N;\n\tcin >> N;\n\tREP(i, N){\n\t\tcin >> sum[i];\n\t\tsum[i+N] = sum[i];\n\t\tsum[i+2*N] = sum[i];\n\t}\n\tFOR(i, 1, N*3){\n\t\tsum[i] += sum[i-1];\n\t}\n\tll res = 0;\n\tREP(i, N){\n\t\tll fs, sc, th;\n\t\tfs = *(lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+sum[i])-1);\n\t\tsc = *(lower_bound(sum+i, sum+i+N, (sum[N-1]/3)+fs)-1);\n\t\tsc -= fs;\n\t\tfs -= sum[i-1];\n\t\tth = sum[N-1]-fs-sc;\n\t\tres = max(res, min(fs, min(sc, th)));\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint n;\nvector<long long> pl;\n\n\nbool check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(pl.begin()+i,pl.begin()+i+n,m+(*(pl.begin()+i)));\n\tvector<long long>::iterator hage=lower_bound(hoge,pl.begin()+i+n,2*m+(*(pl.begin()+i)));\n\tif(*(pl.begin()+i+n-1)-(*(hage))>=m)return true;\n\treturn false;\n}\nint main ()\n{\n\tpl.push_back(0);\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tint x;cin>>x;\n\t\tpl.push_back(x);\n\t}\n\trep(i,n)pl.push_back(pl[i+1]);\n\trep(i,pl.size())if(i!=0)pl[i]+=pl[i-1];\n\tlong long ans=0;\n\trep(i,n)\n\t{\n\t\tlong long r=0;\n\t\tlong long l=5000000000000;\n\t\twhile(r!=l)\n\t\t{\n\t\t\tlong long m=(r+l+1)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}else l=m-1;\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\t\tcout<<ans<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VL a(n);\n    REP(i,n) scanf(\"%lld\", &a[i]);\n    ll s = 0;\n    REP(i,n){\n        s += a[i];\n        a.push_back(a[i]);\n    }\n    ll l = 1, r = s/3;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        bool pos = 0;\n        REP(i,n){\n            int x = i, p = 0, t = 0;\n            while (x < i + n){\n                t += a[x];\n                x++;\n                if (t >= m){\n                    t = 0;\n                    p++;\n                }\n                if (p == 3){\n                    pos = 1;\n                    break;\n                }\n            }\n        }\n        if (pos) l = m;\n        else r = m;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint ini = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[ini] <= one_third){\n\t\tpiece1 += (long long int)A[ini];\n\t\tini++;\n\t}\n\t\n\tint piece2_i = ini;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[ini];\n\t\tini++;\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = ini;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else if (p < tar) l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2 + 1, n - 1, tar);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\n#include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n#define ALL(x)   (x).begin(),(x).end()\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define mp       make_pair\n#define eb       emplace_back\ntypedef pair<LL, LL> P;\ntypedef pair<LL, P> PP;\n \nLL a[2020200];\nLL b[2020200];\nint n;\n \nbool calc(LL m) {\n\tfor (int i = 0; i < n; i++) {\n\t\tint num = (i == 0 ? 0 : b[i - 1]);\n\t\tint pos1 = lower_bound(b + i, b + i + n, num + m) - b;\n\t\tint pos2 = lower_bound(b + i, b + i + n, b[pos1] + m) - b;\n\t\tif (b[n + i - 1] - b[pos2] >= m)return true;\n\t}\n\treturn false;\n}\n \n \nint main() {\n\tcin >> n;\n\tLL sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n \n\tfor (int i = n; i <= n * 2; i++) {\n\t\ta[i] = a[i - n];\n\t}\n\tb[0] = a[0];\n\tfor (int i = 1; i <= n * 2; i++) {\n\t\tb[i] = a[i] + b[i - 1];\n\t}\n \n\tLL left = 0, right = b[n - 1];\n\twhile (right - left > 1) {\n\t\tLL mid = (right + left) / 2;\n\t\tif (calc(mid)) {\n\t\t\tleft = mid;\n\t\t}\n\t\telse {\n\t\t\tright = mid;\n\t\t}\n\t}\n\tcout << left << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b1 = 0, b2 = 0, b3 = 0, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = a[0][0];\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i][0];\n\t}\n\tbaum = a[n - 1][1];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tfor (int cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tfor (int cut3 = cut2 + 1; cut3 < n; cut3++){\n\t\t\t\tb1 = a[cut2][1] - a[cut1][1];\n\t\t\t\tb2 = a[cut3][1] - a[cut2][1];\n\t\t\t\tb3 = baum - a[cut3][1] + a[cut1][1];\n\t\t\t\tminb = MIN(MIN(b1, b2), b3);\n\t\t\t\tif (ans < minb){\n\t\t\t\t\tans = minb;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector< long long int > rui;\nvector<long long int > kasu;\nint n;\n\nbool check2(int i,long long int now,long long int m)\n{\n\tif(rui[now]-rui[i]>=m){return true;}\n\treturn false;\n}\n\nbool check(int i,long long int m)\n{\n\tlong long int r=i;\n\tlong long int l=i+n-1;\n\twhile(r!=l)\n\t{\n\t\tlong long int now=(r+l)/2;\n\t\t\n\t\tif(check2(i,now,m))\n\t\t{\n\t\t\tl=now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr=now+1;\n\t\t}\n\t}\n\tint hoge=l;\n\tl=i+n-1;\n\twhile(r!=l)\n\t{\n\t\tlong long int now=(r+l)/2;\n\t\tif(check2(hoge,now,m))\n\t\t{\n\t\t\tl=now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr=now+1;\n\t\t}\n\t}\n\tif(rui[n+i-1]-rui[r]>=m)return true;\n\treturn false;\n\t\n\t\n}\n\n\n\nint main ()\n{\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tkasu.push_back(x);\n\t\t(i==0)?rui.push_back(x):rui.push_back(rui[i-1]+x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[n+i-1]+kasu[i]);\n\t}\n\tfor(int i=0;i<2*n;i++)cout<<rui[i]<<endl;\n\tlong long int ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long int r=0;\n\t\tlong long int l=5000000;\n\t\twhile(r!=l)\n\t\t{\n\t\t\tlong long int m=(r+l)/2;\n\t\t\t\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tl=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr=m+1;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,r);\n\t}\n\tcout<<ans<<endl;\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = (double)sum / 3.0 + 0.5;\n\n\t\tint ans = 0;\n\t\trep(i, n + 1)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = double(sum - len) / 2.0 + 0.5;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tif (idx >= i + n + 1 || remidx > i + n + 1) continue;\n\t\t\tans = max(ans, sum - len - remlen);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(int l, int r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, int s) {\n    int n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    return P(r, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d; tie(pos, d) = search(m, i); sd += d;\n            P p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            if (sd <= L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    // cout << search(6, 0).second << endl;\n    // cout << search(6, 2).second << endl;\n    // cout << search(9, 4).first << endl;\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[4*N];\n\tmemo = new long long[4* N * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <4*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"i = %d\\t\", i);\n//\t\tprintf(\"c = %d\\n\\n\", c);\n\t\t\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N || c == 2*N || c== 3*N)break;\n\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\trep(k, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\nusing namespace std;\nconst int N=1e5+10;\nconst long long int INF=1LL<<60;\nlong long int a[N],tot=0,s[N];\nmap<long long int ,int>m;\nbool check(long long int val,int pos){\n    int temp=m.lower_bound(s[pos-1]+val)->second;\n    long long int ans;\n    if(temp==N)return false;\n    ans=m.lower_bound(s[temp]+val)->first-s[pos-1];\n    temp=m.lower_bound(s[temp]+val)->second;\n    if(temp==N)return false;\n    if(tot-ans<val)return false;\n    return true;\n}\nint main(){\n    long long int l=0,r,mid;\n    int n;\n    scanf(\"%d\",&n);\n    s[0]=0;\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        tot+=a[i];\n        s[i]=s[i-1]+a[i];\n        m.insert({s[i],i});\n    }\n    m.insert({INF,N});\n    for(int i=1;i<=n;i++){\n        r=tot;\n        while(r-l>1){\n            mid=(r+l)>>1;\n            if(check(mid,i))l=mid;\n            else r=mid;\n        }\n    }\n    printf(\"%lld\\n\",l);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;int n;long long s[110000];bool F(long long key){for(int i=1;i<n;i++){long long* f=lower_bound(s+i,s+n+1,key+s[i-1]);long long* g=lower_bound(f,s+n+1,key+*f);if(*g&&*g+key-s[i-1]<=s[n])return 1;}return 0;}int main(){cin>>n;s[0]=0;for(int i=0;i<n;i++){cin>>s[i+1];s[i+1]+=s[i];}long long l=0,r=s[n]/3+1,m,a=0;while(l<r){m=(l+r)/2;if(F(m))l=m+1,a=max(a,m);else r=m;}cout<<a<<endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nusing ll = long long int;\n\nll a[100000];\nll sum[200001];\nint n;\n\ninline ll modloop(int a_, int b_)\n{\n\treturn (a_ >= 0) ? (a_ % b_) : ((a_ % b_) + b_);\n}\n\ninline ll piece(int a_)\n{\n\treturn a[modloop(a_, n)];\n}\n\ninline ll width(int a_,int b_)\n{\n\ta_ = modloop(a_, n);\n\tb_ = modloop(b_, n);\n\tif (a_ < b_ + 1)\n\t{\n\t\treturn sum[b_ + 1] - sum[a_];\n\t}\n\telse\n\t{\n\t\treturn sum[n] - sum[b_ + 1] + sum[a_];\n\t}\n}\n\nbool cir(int cut,ll x)\n{\n\tint seccut = lower_bound(sum + cut, sum + n + n, sum[cut] + x) - sum;\n\tint thrcut = lower_bound(sum + seccut, sum + n + n, sum[seccut] + x) - sum;\n\tif (sum[cut + n] - sum[thrcut] >= x)return true;\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)scanf(\"%lld\", a + i);\n\tsum[0] = 0;\n\tfor (int i = 0; i < n; ++i)sum[i + 1] = sum[i] + a[i];\n\tfor (int i = n; i < 2 * n;++i)sum[i + 1] = sum[i] + a[i - n];\n\tll ans = 0;\n\tfor (int cut = 0; cut < n; ++cut)\n\t{\n\t\tll min = 1;\n\t\tll max = sum[n] / 3 + 1;\n\t\tfor (int i = 0; i < 100; ++i)\n\t\t{\n\t\t\tll mid = (min + max) / 2;\n\t\t\tif (cir(cut,mid))\n\t\t\t{\n\t\t\t\tmin = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\t\tans = (ans > min) ? ans : min;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "??£??£??£???"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v;\nvector<int> pos(200010, 0);\n\nbool ch(int x){\n  int l, r=l=0, sum=0;\n  while(l<n){\n    while(sum<x && (r+1)%n!=l){\n      sum+=v[r];\n      r=(r+1)%n;\n    }\n\n    if((r+1)%n==l) return false;\n    pos[l]=r;\n    sum-=v[l];\n    l++;\n  }\n\n  REP(i, n){\n    int l1=pos[i]-i, l2=pos[pos[i]]-pos[i], l3=pos[pos[pos[i]]]-pos[pos[i]];\n\n    if(l1<0) l1+=n;\n    if(l2<0) l2+=n;\n    if(l3<0) l3+=n;\n    if(l1+l2+l3<=n) return true;\n  }\n  \n  return false;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  int sum=0;\n  REP(i, n){\n    int m;\n    scanf(\"%lld\", &m);\n    v.push_back(m);\n    sum+=m;\n  }\n\n  int l=0, r=INF;\n  int mid;\n  while(l+1<r){\n    mid=(l+r)/2;\n    if(ch(mid)) l=mid;\n    else r=mid;\n  }\n\n  printf(\"%lld\\n\", l);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i-1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n-1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[cut2][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3 = cut2 + 1; cut3 < n; cut3++){\n\t\t\tif (baum - a[cut3][1] + a[cut1][1] >(baum - (a[cut2][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3 - 1][1] - a[cut2 - 1][1];\n\t\tb[0][2] = baum - a[cut3 - 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3 - 1][1] - a[cut2][1];\n\t\tb[1][2] = baum - a[cut3 - 1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3][1] - a[cut2 - 1][1];\n\t\tb[2][2] = baum - a[cut3][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3][1] + a[cut1][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n + 1] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = static_cast<LL>((double(sum - size) / 2.0) + 0.5);\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tlong long check();\n\tbool check_bool;\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n\tcheck_bool = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcheck_bool = true;\n\treturn min_value;\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tmin_value = memo[cut_b];\n\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (min_value > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\tlong long min_value;\n\n\tset_value = set_board();\n\tif (check_bool)return set_value;\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n//\t\tprintf(\"i = %d\\n\", cut_a);\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n//\t\tprintf(\"b = %d\\n\", cut_b);\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n//\t\tprintf(\"half = %f\\n\", half - memo[cut_b]);\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n//\t\tprintf(\"c = %d\\n\", cut_c);\n\n\t\tmin_value = memo[cut_b] - memo[cut_a];\n\t\tif (min_value > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (min_value > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n//\t\tprintf(\"set_value = %d\\n\\n\", set_value);\n\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tlong a[100000][2] = { 0 }, baum, b[8][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i][1] = a[i-1][1]+a[i-1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n-1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < n; cut2++){\n\t\t\tif (a[cut2][1] - a[cut1][1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < n; cut3_1++){\n\t\t\tif (baum - a[cut3_1][1] + a[cut1][1] < (baum - (a[cut2-1][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < n; cut3_2++){\n\t\t\tif (baum - a[cut3_2][1] + a[cut1][1] < (baum - (a[cut2][1] - a[cut1][1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[0][1] = a[cut3_1 - 1][1] - a[cut2 - 1][1];\n\t\tb[0][2] = baum - a[cut3_1 - 1][1] + a[cut1][1];\n\t\tb[1][0] = a[cut2 - 1][1] - a[cut1][1];\n\t\tb[1][1] = a[cut3_1][1] - a[cut2 - 1][1];\n\t\tb[1][2] = baum - a[cut3_1][1] + a[cut1][1];\n\t\tb[2][0] = a[cut2][1] - a[cut1][1];\n\t\tb[2][1] = a[cut3_2 - 1][1] - a[cut2][1];\n\t\tb[2][2] = baum - a[cut3_2 - 1][1] + a[cut1][1];\n\t\tb[3][0] = a[cut2][1] - a[cut1][1];\n\t\tb[3][1] = a[cut3_2][1] - a[cut2][1];\n\t\tb[3][2] = baum - a[cut3_2][1] + a[cut1][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1 << 30;\nvector<int> baum;\nint n, ans, minma = INF;\nint Baum = 0, Baum3 = 0;\n\nvoid cut(int f, int pt) {\n\tint s = f + Baum3, t = s + Baum3;\n\tint p;\n\tint sp[2], tp[2];\n\tp = upper_bound(baum.begin(), baum.end(), s) - baum.begin();\n\tsp[0] = baum[p];\n\tsp[1] = baum[p - 1];\n\tp = upper_bound(baum.begin(), baum.end(), t) - baum.begin();\n\ttp[0] = baum[p];\n\ttp[1] = baum[p - 1];\n\tfor (int i = 0; i <= 1; i++) {\n\t\tminma = INF;\n\t\tminma = min( minma, sp[i] - f );\n\t\tfor (int j = 0; j <= 1;j ++){\n\t\t\tminma = min( minma, min( tp[j] - sp[i], Baum - tp[j] + f ));\n\t\t\tans = max(ans, minma);\n\t\t}\n\t}\n\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint in;\n\t\tcin >> in;\n\t\tBaum += in;\n\t\tbaum.push_back(in);\n\t}\n\tBaum3 = Baum / 3;\n\n\tfor (int i = 1; i < n; i++) {\n\t\tbaum[i] += baum[i - 1];\n\t}\n\n\tcut(0, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (baum[i] > Baum3) break;\n\t\tcut(baum[i], i);\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n\nconst int INF=1001001001;\n#define rep(i,n) for(int i=0;i<n;i++)\nint N;\nint A[200004];\nlong long int B[100002];\n\n\nint main(){\n\t//FILE *fp;\n\t//fp=fopen(\"F:\\\\1JOI本選\\\\2014\\\\joi2014-ho-data\\\\joi2014-ho-data\\\\2014-ho-t3\\\\in\\\\03-06.txt\",\"r\");\n\tscanf(\"%d\",&N);\n\tlong long int MAX = 0;\n\trep(i,N){\n\t\tscanf(\"%d\",&A[i]);\n\t\tMAX+=A[i];\n\t\tB[i]=MAX;\n\t}\n\tmemcpy(&A[N],A,sizeof(int)*N);\n\t\n\tlong long int M=MAX/3;//全てのピースがM以上になる切り方は存在するか?\n\tlong long int m=0;\n\tdo{\n\t\tbool cann=false;//全てのピースがn以上になる切り方は存在するか?\n\t\tlong long int n=(M+m)/2;\n\t\trep(i,N-2){//どこで最初に切るか\n\t\t\tint a=i;//よりあとで切る\n\t\t\tint b=N-2;//以前で切る\n\t\t\tdo{//次に切る場所を探す\n\t\t\t\tint c=(a+b)/2;\n\t\t\t\tlong long int piece1=B[c]-B[i];\n\t\t\t\tif(piece1>=n){b=c;}//c以前で切れる\n\t\t\t\telse a=c;//cよりあとで切るべき\n\t\t\t}while(b>a+1);\n\t\t\tlong long int p1=B[b]-B[i];\n\t\t\tif(p1<n)continue;//1個目がもうだめ\n\t\t\tint x=b;\n\t\t\tint y=N-1;\n\t\t\tdo{//最後に切る場所を探す\n\t\t\t\tint z=(x+y)/2;\n\t\t\t\tlong long int piece2=B[z]-B[b];\n\t\t\t\tif(piece2>=n){y=z;}\n\t\t\t\telse x=z;\n\t\t\t}while(y>x+1);\n\t\t\tlong long int p2=B[y]-B[b];\n\t\t\tif(p2<n)continue;//2個目がもうだめ\n\t\t\tif(MAX-p1-p2>=n){cann=true;}\n\t\t}\n\t\tif(cann){m=n;}//すべて(３つ)のピースがn以上になりえる\n\t\telse{M=n;}\n\t}while(M>m+1);\n\tprintf(\"%lld\\n\",m);\n\treturn 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\n\nint n;\nInt a[200010];\nInt s[200010];\n\nbool cond(Int x)\n{\n\tint p0 = 0, p1 = 0, p2 = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tp2 = i + n;\n\t\twhile (p0 < p2 && s[p0] - s[i] < x) p0++;\n\t\twhile (p1 < p2 && s[p1] - s[p0] < x) p1++;\n\t\tif (min({s[p0] - s[i], s[p1] - s[p0], s[p2] - s[p1]}) >= x) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i + n] = a[i];\n\t}\n\n\tfor (int i = 0; i < 2 * n; i++){\n\t\ts[i + 1] = s[i] + a[i];\n\t}\n\n\tInt lb = 0, ub = 1e15;\n\twhile (ub - lb > 1){\n\t\tInt md = (lb + ub) / 2;\n\t\t(cond(md) ? lb : ub) = md;\n\t}\n\n\tcout << lb << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(){\n  \n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=;\n  }\n  \n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    long long int num;\n    cin>>num;\n    long long int A[200100];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long long int mi=0;\n    \n    for (int i=1; i< num; i++) {\n        A[i]=A[i]+A[i-1];\n    }\n    double sanbun=A[num-1]/3.0;\n    int ni=0,san;\n    while (A[ni+1]<sanbun) {\n        ni++;\n    }\n    san=ni;\n    while (A[san+1]<2*A[ni]) {\n        san++;\n    }\n    \n    for (int i=0; i<num-2; i++) {\n        for (int j=ni; j<num-1; j++) {\n            for (int k=san; k<num; k++) {\n                mi=max(mi,\n                       min(A[k]-A[j],\n                           min(A[j]-A[i],\n                               A[num-1]-A[k]+A[i])));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint main() {\n\tint n;\n\tint a = 0, b = 0, c = 0;\n\tstd::cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint s;\n\t\tstd::cin >> s;\n\t\tif (i < n / 3) {\n\t\t\ta += s;\n\t\t}\n\t\telse if (i < n / 3*2) {\n\t\t\tb += s;\n\t\t}\n\t\telse if (i < n / 3*3) {\n\t\t\tc += s;\n\t\t}\n\t}\n\tstd::cout << c<<std::endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long int mi=0;\n    \n    for (int i=1; i< num; i++) {\n        A[i]=A[i]+A[i-1];\n    }\n    \n    for (int i=0; i<num-2; i++) {\n        for (int j=i+1; j<num-1; j++) {\n            for (int k=j+1; k<num; k++) {\n                \n                mi=max(mi,min(A[k]-A[j],min(A[j]-A[i],A[num-1]-A[k]+A[i])));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    int mi=0;\n    for (int i=0; i<num-2; i++) {\n        for (int j=i+1; j<num-1; j++) {\n            for (int k=j+1; k<num; k++) {\n                \n                long int aa=0,bb=0,cc=0;\n                for (int i2=i; i2< j; i2++) {\n                    aa+=A[i2];\n                }\n                \n                for (int i3=j; i3< k; i3++) {\n                    bb+=A[i3];\n                }\n                \n                for (int i4=k; i4< num; i4++) {\n                    cc+=A[i4];\n                }\n                for (int i4=0; i4< i; i4++) {\n                    cc+=A[i4];\n                }\n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n,a[100100],sum[200100];\n\nint main(){\n  scanf(\"%lld\",&n);\n  for(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i%n];\n\n  int l = 0, r = 1;\n  ll ans = 0, third = sum[n]/3;\n  while(l<n){\n    while(sum[r]-sum[l] <= third)r++;\n    r--;\n    ll minv = sum[r]-sum[l];\n    ll half = (sum[n] - minv)/2;\n    int pos = lower_bound(sum+r, sum+2*n, half + sum[r]) - sum;\n\n    //cout << minv << \" \" << sum[pos]-sum[r] << \" \" << sum[l+n]-sum[pos] << endl;\n    ll tmp = min(sum[pos]-sum[r], sum[l+n]-sum[pos]);\n    if(pos>0)tmp = max(tmp, min(sum[pos-1]-sum[r], sum[l+n]-sum[pos-1]));\n    minv = min(minv,tmp);\n\n    ans = max(ans,minv);\n    l++;\n  }\n\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100005];\nlong long int b[100005][2][2];\nint main(){\n\tint n;\n\tlong long int s=0,m=0;\n\tint i,j,k;\n\tlong long int c,d,e;\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ts+=a[i];\n\t}\n\tcout<<s<<endl;\n\tfor(i=0,j=0;i<n;i++){\n\t\twhile(m<(s/3)){\n\t\t\tm+=a[j];\n\t\t\tj++;j%=n;\n\t\t}\n\t\tb[i][0][0]=(j+n-1)%n;\n\t\tb[i][0][1]=m-a[b[i][0][0]];\n\t\tb[i][1][0]=j;\n\t\tb[i][1][1]=m;\n\t\tm-=a[i];\n\t}\n\tcout<<s<<endl;\n\tm=0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<2;j++){\n\t\t\tfor(k=0;k<2;k++){\n\t\t\t\tc=b[i][j][1];\n\t\t\t\td=b[b[i][j][0]][k][1];\n\t\t\t\te=s-c-d;\n\t\t\t\tif(c>d)c=d;\n\t\t\t\tif(c>e)c=e;\n\t\t\t\tif(m<c)m=c;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<m<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>num(N * 2 + 1);\n\tvector<long long int>sum(N * 2 + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> num[i];\n\t\tM += num[i];\n\t\tnum[i + N] = num[i];\n\t}\n\tsum[0] = num[0];\n\tfor (int i = 0; i < N * 2; i++) {\n\t\tsum[i] = sum[i - 1] + num[i];\n\t}\n\tsum[N * 2] = sum[N * 2 - 1] + num[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tL = i;\n\t\tR = i + N - 2;\n\t\tlong long int mid;\n\t\twhile (R - L > 1) {\n\t\t\tmid = (R + L + 1) / 2;\n\t\t\tif (sum[mid] - sum[i - 1] <= M / 3) {\n\t\t\t\tL = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = mid;\n\t\t\t}\n\t\t}\n\t\tmid = L;\n\t\tL = mid + 1;\n\t\tR = i + N - 1;\n\t\tlong long int med;\n\t\twhile (R - L > 1) {\n\t\t\tmed = (R + L + 1) / 2;\n\t\t\tif (sum[med] - sum[mid] <= (M - (sum[mid] - sum[i - 1])) / 2) {\n\t\t\t\tL = med;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = med;\n\t\t\t}\n\t\t}\n\t\t//cout << sum[mid] - sum[i - 1] << \" \" << sum[L] - sum[mid] << \" \" << sum[i + N - 1] - sum[L + 1] << endl;\n\t\tK = max({ K,min({sum[mid] - sum[i - 1],sum[L] - sum[mid],sum[i + N - 1] - sum[L]}),min({sum[i + N - 1] - sum[L + 1],sum[mid] - sum[i - 1],sum[L + 1] - sum[mid]}) });\n\t\t//cout << K << \" \" << mid << \" \" << L << endl;\n\t}\n\tcout << K << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 2000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nint n;\nvector<long long> a;\nlong long memo[1000000] = {};\nlong long calc_wa(long long l, long long r) {\n\treturn memo[r] - memo[l - 1];\n}\nlong long solve(long long border) {\n\tfor (int i = 0;i < n;++i) {\n\t\tint now_itr = i;\n\t\tfor (int q = 0;q < 3 && memo[now_itr] != LONG_INF;++q) {\n\t\t\tint bot = now_itr;\n\t\t\tint top = a.size();\n\t\t\twhile (top - bot > 1) {\n\t\t\t\tint mid = (top + bot) / 2;\n\t\t\t\tif (calc_wa(now_itr, mid) >= border) {\n\t\t\t\t\ttop = mid;\n\t\t\t\t}\n\t\t\t\telse bot = mid;\n\t\t\t}\n\t\t\tif (calc_wa(now_itr, bot) >= border) {\n\t\t\t\tnow_itr = bot + 1;\n\t\t\t}\n\t\t\telse if (calc_wa(now_itr, top) >= border) {\n\t\t\t\tnow_itr = top + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow_itr = a.size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (now_itr - i <= n) return true;\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tlong long tmp;\n\t\tcin >> tmp;\n\t\ta.push_back(tmp);\n\t}\n\tREP(i, n) {\n\t\tlong long tmp = a[i];\n\t\ta.push_back(tmp);\n\t}\n\tREP(i, n) {\n\t\tlong long tmp = a[i];\n\t\ta.push_back(tmp);\n\t}\n\tREP(i, n) {\n\t\tlong long tmp = a[i];\n\t\ta.push_back(tmp);\n\t}\n\tmemo[0] = a[0];\n\tfor (int i = 1;i < a.size();++i) {\n\t\tmemo[i] = memo[i - 1] + a[i];\n\t}\n\tmemo[a.size()] = LONG_INF;\n\tmemo[a.size() + 1] = LONG_INF;\n\tmemo[a.size() + 2] = LONG_INF;\n\tlong long bot = 0;\n\tlong long top = LONG_INF;\n\twhile (top - bot > 1) {\n\t\tlong long mid = (top + bot) / 2;\n\t\tif (solve(mid) == true) {\n\t\t\tbot = mid;\n\t\t}\n\t\telse top = mid;\n\t}\n\tif (solve(top)) {\n\t\tcout << top << endl;\n\t}\n\telse cout << bot << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconst int N=20010;\nint a[N];\nint n, d, e, i, m, s, j, k;\n\nint main(){\n\tcin >>n;\n\td=0;\n\tfor (i=0; i<n; i++){\n\t\tcin >>a[i];\n\t\ta[i+n]=a[i];\n\t\td+=a[i];\n\t}\n\tm=0;\n\tfor (i=0; i<n; i++){\n\t\ts=a[i];\n\t\te=0;\n\t\tfor (k=1; k<n; k++){\n\t\t\te+=a[i+k];\n\t\t\tif (e>=s && d>=s+s+e){\n\t\t\t\tm=max(m, s);\n\t\t\t}\n\t\t}\n\t\tfor (j=1; j<n; j++){\n\t\t\ts+=a[i+j];\n\t\t\te=0;\n\t\t\tfor (k=1; k<n-j; k++){\n\t\t\t\te+=a[i+j+k];\n\t\t\t\tif (e>=s && d>=s+s+e){\n\t\t\t\t\tm=max(m, s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout <<m<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r-1];\n\t\t\tif (sum > sum1){\n\t\t\t\tLL++;\n\t\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\t}\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=0;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\twhile (t<s+N && a<=ans){\n\t\t\tt++;\n\t\t\ta+=A[(t-1)%N];\n\t\t}\n\t\tif (t==s+N) break;\n\t\t//aがansを更新できるか\n\t\tauto p=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\tif (p!=sum+s+N){\n\t\t\t//見つかった\n\t\t\tb=*p-sum[t-1];\n\t\t\tc=sum[N-1]-b-a;\n\t\t\tif (c>=a && b>=a){\n\t\t\t\t//aが最小値\n\t\t\t\tans=a;\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 200005;\n\nll a[MAX_N];\nint n;\n\nbool possible(ll cri)\n{\n\tll asum[3];\n\tasum[0] = asum[1] = asum[2] = 0;\n\tint r=0;\n\tint rr[2];\n\trep(i,2){\n\t\twhile(asum[i] < cri && r<n){\n\t\t\tasum[i] += a[r];\n\t\t\tr++;\n\t\t}\n\t\tif(r>=n){\n\t\t\tbreak;\n\t\t}\n\t\trr[i] = r;\n\t}\n\tfor(;r<n;r++){\n\t\tasum[2] += a[r];\n\t}\n\tif(asum[2] >= cri){\n\t\treturn true;\n\t}\n\trep(i,n){\n\t\tasum[0] -= a[i];\n\t\trep(j,2){\n\t\t\tr = rr[j];\n\t\t\twhile(asum[j] < cri && r<n+i+1){\n\t\t\t\tasum[j] += a[r];\n\t\t\t\tasum[j+1] -= a[r];\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif(r>n+i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trr[j] = r;\n\t\t}\n\t\tif(r<n+i+1){\n\t\t\tasum[2] += a[n+i];\n\t\t}\n\t\tif(asum[2] >= cri){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\ta[i+n] = a[i];\n\t}\n\tll asum = accumulate(a,a+n,0LL);\n\tll amin = *(min_element(a,a+n));\n\tll h=asum/3+1;\n\tll l=amin-1;\n\tll ans;\n\twhile(1){\n\t\tll mid = (l+h)/2;\n\t\tif(l==mid){\n\t\t\tans = mid;\n\t\t\tbreak;\n\t\t}\n\t\tif(possible(mid)){\n\t\t\tl = mid;\n\t\t}else{\n\t\t\th = mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<string>\n#include<set>\n#include<map>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\n#define FOR(i,m,n) for(int i=(m);(i)<(n);(i)++)\ntypedef long long ll;\n\nbool check(ll m,int N,vector<ll> &sum){\n    for(int s=0;s<=N;s++){\n        ll f = sum[s];\n        ll itr1 = lower_bound(sum.begin()+s,sum.begin()+s+N,f+m)-sum.begin();\n        ll itr2 = lower_bound(sum.begin()+s,sum.begin()+s+N,sum[itr1]+m)-sum.begin();\n        if(sum[N+s]-sum[itr2]>=m)return true;\n    }\n    return false;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> A(2*N);\n    rep(i,N)cin >> A[i];\n    for(int i=N;i<2*N;i++)A[i]=A[i-N];\n    vector<ll> sum(2*N+1);\n    rep(i,2*N){\n        sum[i+1]=sum[i]+A[i];\n    }\n\n    //check(m):=mid以上の最小になるよう２か所切ったとき、最小がmよりも大きいかどうか\n\n    ll low = 1,high=sum[N];\n    while(high-low>1){\n        ll mid = (low+high)/2;\n        if(check(mid,N,sum)){\n            low=mid;\n        }else{\n            high=mid;\n        }\n    }\n    cout << low << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<(int)(n);i++)\ntypedef long long ll;\n\nll a[200004],b[200004];\nint n;\nbool check(ll m){\n    rep(i,n){\n        ll tmp;\n        if(i==0)tmp=0;\n        else tmp=b[i-1];\n        int ss=lower_bound(b+i,b+n+i,tmp+m)-b;\n        int tt=lower_bound(b+i,b+n+i,b[ss]+m)-b;\n        if(b[n+i-1]-b[tt]>=m) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin>>n;\n    rep(i,n)cin>>a[i];\n    for(int i=n;i<2*n;i++)a[i]=a[i-n];\n    b[0]=a[0];\n    for(int i=1;i<2*n;i++)b[i]=a[i]+b[i-1];\n    ll l=1,r=b[n-1];\n    while(r-l>1){\n        ll mid=(l+r)/2;\n        if(check(mid))l=mid;\n        else r=mid;\n    }\n    cout<<l<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[200000];\nint main(){\n  int n;\n  long long sum=0;\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%lld\",&a[i]);\n    a[n+i] = a[i];\n    sum += a[i];\n  }\n  long long l=0,r=(long long)10e14,mid;\n  long long cnt1,cnt2,num1,num2,ma,ans=0;\n  while(l <= r){\n    mid = (l+r)/2;\n    ma = 0;\n    cnt1 = 0;\n    cnt2 = 0;\n    num1 = 0;\n    for(int i=0;i<n;i++){\n      while(cnt1 < mid && num1 < i+n){\n\tcnt1 += a[num1];\n\tif(i != 0) cnt2 -= a[num1];\n\tnum1++;\n      }\n      if(i == 0) num2 = num1;\n      while(cnt2 < mid && num2 < i+n){\n\tcnt2 += a[num2];\n\tnum2++;\n      }\n      ma = max(ma, min(min(cnt1,cnt2),sum-(cnt1+cnt2)));\n      cnt1 -= a[i];\n    }\n\n    if(ma >= mid){\n      ans = max(ans,ma);\n      l = mid+1;\n    }else{\n      r = mid-1;\n    }\n\n  }\n  printf(\"%lld\\n\",ans);\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1) REP(k, j + 1, n)\n\t\t{\n\t\t\t//int size = cuts[j] - cuts[i];\n\t\t\t//int rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\t//int sep = j + 1;\n\t\t\t//rep(k, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t//{\n\t\t\t//\tsep = k;\n\t\t\t//\tbreak;\n\t\t\t//}\n\n\t\t\t//int k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m]-A[b-1])r=m;\n    else l=m+1;\n  }\n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut2--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    \n    cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define MAX_N 100000\n#define MAX_A 1000000000\n#define INF 100000000000000\ntypedef long long Int;\nint N;\nInt A[MAX_N * 2 + 1];\n\nbool C(int p, Int x){\n\tint lb, ub, mid;\n\tint ed = p + N;\n\t\n\tlb = p; ub = ed;\n\twhile(ub - lb > 1){\n\t\tmid = (lb + ub) / 2;\n\t\tif(A[mid] - A[p] >= x) ub = mid;\n\t\telse lb = mid;\n\t}\n\tif(A[ub] - A[p] < x) return false;\n\t\n\tp = ub; lb = ub; ub = ed;\n\twhile(ub - lb > 1){\n\t\tmid = (lb + ub) / 2;\n\t\tif(A[mid] - A[p] >= x) ub = mid;\n\t\telse lb = mid;\n\t}\n\tif(A[ub] - A[p] < x) return false;\n\t\n\tif(A[ed] - A[ub] < x) return false;\n\t\n\treturn true;\n}\n\nInt Max(Int a, Int b){\n\treturn (a > b)? a : b;\n}\n\nint main(){\n\tInt n, res, lb, ub, mid;\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &n);\n\t\tA[i + 1] = A[i] + n;\n\t}\n\tfor(int i = N + 1; i <= N * 2; i++){\n\t\tA[i] = A[i - 1] + A[i - N] - A[i - N - 1];\n\t}\n\t\n\tres = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tlb = 0; ub = INF;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(C(i - 1, mid)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\t\n\t\tres = Max(res, lb);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = -1;\n\tll s1, s2;\n\t\n\twhile(r+1 < n){\n\t\tr++;\n\t\ts1 = *lower_bound(a, a+MAX, a[r]+m);\n\t\tif(s1 == INF)continue;\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF)continue;\n\t\tif(total-(s2-a[r]) >= m)return 0;\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ta[0] = 0;\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\nusing namespace std;\n\nint n;\nint a[100000];\nint pos[100000];\nlong long int low;\nlong long int high;\nlong long int sum;\n\nbool check(long long int x) {\n    int s = 0;\n    int t = 0;\n    long long int now = 0;\n\n    while (s < n) {\n        while ((t+1)%n != s && now < x) {\n            now += a[t];\n            t = (t+1)%n;\n        }\n        assert((t+1)%n != s);\n        pos[s] = t;\n        now -= a[s++];\n    }\n\n    for (int i=0; i<n; i++) {\n        int len1 = pos[i] - i;\n        int len2 = pos[pos[i]] - pos[i];\n        int len3 = pos[pos[pos[i]]] - pos[pos[i]];\n\n        if (len1 < 0) len1 += n;\n        if (len2 < 0) len2 += n;\n        if (len3 < 0) len3 += n;\n        if (len1 + len2 +len3 <= n) return true;\n    }\n\n    return false;\n}\n    \n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i=0; i<n; i++) {\n        scanf(\"%d\", &a[i]);\n        sum += a[i];\n    }\n\n    low = -1;\n    high = (sum/3) + 1;\n    while (high - low > 1) {\n        long long int mid = (high+low)/2;\n        if (check(mid)) low = mid;\n        else high = mid;\n    }\n\n    printf(\"%lld\\n\", low);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll sum[200001];\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<ll> baumkuchen;\n\n    memset(sum,0,sizeof(sum));\n    for(int i=0;i<N;i++){\n      ll width;\n      scanf(\"%lld\",&width);\n      baumkuchen.push_back(width);\n      sum[i+1] = sum[i] + width;\n    }\n    \n    for(int i=0;i<N;i++){\n      sum[N + i + 1] = sum[N] + sum[i + 1];\n    }\n\n    ll lhs = 0;\n    ll rhs = 100000000000000LL;\n    for(int round = 0; round < 50; round++){\n      ll mid = lhs + (rhs - lhs) / 2LL;\n\n      bool isok = false;\n      for(int i=0;i<N;i++){\n        ll offset = sum[i];\n        int div_idx = lower_bound(sum,sum + 2 * N,offset + mid) - sum;\n        div_idx = lower_bound(sum,sum + 2 * N,sum[div_idx] + mid) - sum;\n        div_idx = lower_bound(sum,sum + 2 * N,sum[div_idx] + mid) - sum;\n        if(div_idx <= i + N){\n          isok = true;\n          break;\n        }\n      }\n      if(isok){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n\n    printf(\"%lld\\n\",lhs);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=LLONG_MAX;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n  REP(i,n+1){\n      ll fir=*lower_bound(ALL(sum),sum[i]+x);\n      ll sec=*lower_bound(ALL(sum),fir+x);\n      ll thi=*lower_bound(ALL(sum),sec+x);\n      if(thi<=sum[i]+cnt)return true;\n  }\n  return false;\n}\nint main(){\n    scanf(\"%d\",&n);\n    REP(i,n){\n        scanf(\"%lld\",&a[i]);\n        cnt+=a[i];\n    }\n    sum.resize(n*2+1);\n\t\tsum[0]=0;\n    REP(i,n*2){\n        if(i==0){\n            sum[i+1]=a[i];\n        }else{\n            sum[i+1]=sum[i]+a[i%n];\n        }\n    }\n    sum.PB(MAX);\n    ll lb=0,rb=cnt;\n    while(rb-lb>1){\n        ll mid=(rb+lb)/2;\n        if(ok(mid)){\n            lb=mid;\n        }else{\n            rb=mid;\n        }\n    }\n    printf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tfor (; i2 < i1_ini + N - 2;){\n\t\tpiece1_s = piece1_l;\n\t\tpiece1_l += A[i2%N];\n\t\ti2++;\n\t\tif (piece1_l > one_third_size) break;\n\t}\n\tconst int i1_fin = i2;\n\n\t/*int i3 = i1_ini + N;\n\tull piece3_s = 0;\n\tull piece3_l = 0;\n\tfor (; i3 > i2 + 1;){\n\t\tpiece3_s = piece3_l;\n\t\ti3--;\n\t\tpiece3_l += A[i3%N];\n\t\tif (piece3_l > one_third_size) break;\n\t}\n\ti3++;*/\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tfor (; i3 < i1_ini + N - 1;){\n\t\tpiece3_l = piece3_s;\n\t\tpiece3_s -= A[i3%N];\n\t\ti3++;\n\t\tif (piece3_s <= one_third_size) break;\n\t}\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse{\n\t\t\tfor (; i2 < i1 + N - 2;){\n\t\t\t\tpiece1_s = piece1_l;\n\t\t\t\tpiece1_l += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif (piece1_l > one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse{\n\t\t\tfor (; i3 < i1 + N - 1;){\n\t\t\t\tpiece3_l = piece3_s;\n\t\t\t\tpiece3_s -= A[i3%N];\n\t\t\t\ti3++;\n\t\t\t\tif (piece3_s <= one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nstruct H {\n\tint x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\nint ari(int a, int b, int c) {\n\treturn (a + b)*c / 2;\n}//????????°?????????\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\n//---------------------------------------------------\n//+++++++++++++++++++++++++++++++++++++++++++++++++++\nint n, a[100000], b[200001], ans;\nint solve(int s, int e) {\n\tint s2 = s, e2 = e, t;\n\twhile (e - s > 1) {\n\t\tt = (s + e) / 2;\n\t\tif (b[t] - b[s2 - 1] > b[e2 - 1] - b[t])\n\t\t\te = t;\n\t\telse\n\t\t\ts = t;\n\t}\n\tint sum = min(b[s] - b[s2 - 1], b[e2 - 1] - b[s]);\n\tif (s + 2 != e2)\n\t\tsum = max(sum, min(b[s + 1] - b[s2 - 1], b[e2 - 1] - b[s + 1]));\n\treturn sum;\n}\nsigned main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tb[0] = a[0];\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = b[i - 1] + a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tb[i + n] = b[i + n - 1] + a[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint s = i, e = i + n, t;\n\t\twhile (e - s > 1) {\n\t\t\tt = (s + e) / 2;\n\t\t\tif (solve(t + 1, i + n) < (i != 0 ? b[t] - b[i - 1] : b[t]))\n\t\t\t\te = t;\n\t\t\telse\n\t\t\t\ts = t;\n\t\t}\n\t\tint sum = min(solve(s + 1, i + n), (i != 0 ? b[s] - b[i - 1] : b[s]));\n\t\tif (s + 3 != i + n)\n\t\t\tsum = max(sum, min(solve(s + 2, i + n), (i != 0 ? b[s + 1] - b[i - 1] : b[s + 1])));\n\t\tans = max(ans, sum);\n\t}\n\tcout << ans << endl;\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef complex<double> dcomplex;\ninline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}\n\n//ラジアンを度に変換-----------------------------------------------------\ndouble rad_deg(double rad){\n\tif(rad >= 0)return rad*180.0/acos(-1);\n\telse return (2*acos(-1)+rad)*180/acos(-1);\n}\n\nint main(void){\n\tdouble pi = acos(-1);\n\t//入力--------------------------------------------------------------\n\tint N;\n\tcin >> N;\n\tint data[N];\n\tlong int sum = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\t//極座標の保持\n\tdcomplex pol[N];\n\tdouble sum_t = 0;\n\tdouble sumlist[N+1];\n\tfor(int i=0; i<N; i++){\n\t\tpol[i] = polar(1.0,2.0*pi*sum_t/sum);\n\t\tsumlist[i] = rad_deg(arg(pol[i]));\n\t\tsum_t += data[i];\n\t}\n\tsumlist[N] = 360.0;\n\t//適当なmin_argを与える----------------------------------------------\n\tdouble min_arg = 0;\n\tdcomplex p = pol[0];\n\tdcomplex q,r;\n\tdouble theta1 = 0,theta2,theta3;\n\tdouble a,b,d;\n\tint tmp;\n\tfor(int i=1;i<N;i++){\n\t\tq = pol[i];\n\t\tif (rad_deg(arg(q)) >= 120){\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\ttmp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int k=tmp; k<N; k++){\n\t\tr = pol[k];\n\t\ttheta3 = rad_deg(arg(r));\n\t\tb = theta3 - theta2;\n\t\td = 360-a-b;\n\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\tif(d < b) break;\n\t}\n\t/*\n\tcout << \"[\";\n\tfor(int i = 0; i<N+1; i++){\n\tcout << sumlist[i] << \",\"; \n\t}\n\t*/\n\t//ループ処理--------------------------------------------------------------\n\tint tmp0 = 0;\n\tint tmp1 = 1;\n\tint tmp2 = 2;\n\ta = sumlist[tmp1] -sumlist[tmp0];\n\tb = sumlist[tmp2] - sumlist[tmp1];\n\td = 360.0 - sumlist[tmp2] +sumlist[tmp0];\n\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\n\twhile(tmp0 < round(N/2.0) && tmp2 < N && tmp1 < tmp2){\n\t\ttmp1 = tmp0 + 1;\n\t\ttmp2 = tmp1 + 1;\n\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\twhile(d >= min_arg){\n\t\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg && tmp2 < N-1){\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse if(sumlist[tmp1] - sumlist[tmp0] < min_arg and tmp1 < N-2){\n\t\t\t\ttmp1 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(tmp2 == N)break;\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t}\n\t\ttmp0 += 1;\n\t}\n\n\tcout << (long int)(round((min_arg/360.0)*sum)) << endl;;\n\t\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N + 2; i++ )\n\t{\n\t\tlong long int A = data[i] - data[0];\n\t\tfor( size_t j = i; j < N + 2; j++ )\n\t\t{\n\t\t\tlong long int B = data[j] - data[i];\n\t\t\tif( ans > B )continue;\n\t\t\tfor( size_t k = j; k < N + 2; k++ )\n\t\t\t{\n\t\t\t\tlong long int C = data[k] - data[j];\n\t\t\t\tif( ans > C )continue;\n\t\t\t\tans = max ( ans , min ( { B , C , ( data[N + 1] - data[k] ) + A } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n#define INF 1000000000000000ll\n#define pb push_back\nll A[100100];\nvector<ll> a;\nint N;\nll sum;\nbool C(ll x)\n{\n\tvector<ll>::iterator it;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tll f = a[i];\n\t\tit = lower_bound(a.begin(),a.end(),f+x);\n\t\tif(it==a.end())continue;\n\t\tll s = *it;\n\t\tit = lower_bound(a.begin(),a.end(),s+x);\n\t\tif(it==a.end())continue;\n\t\tll t = *it;\n\t\tit = lower_bound(a.begin(),a.end(),t+x);\n\t\tif(it==a.end())continue;\n\t\tll ff = *it;\n\t\tif(ff-f<=sum)return true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%lld\",&A[i]);\n\tfor(int i=1;i<N;i++)A[i]+=A[i-1];\n\tsum=A[N-1];\n\ta.pb(0);\n\tfor(int i=0;i<N;i++)a.pb(A[i]);\n\tfor(int i=0;i<N;i++)a.pb(A[i]+sum);\n\tll l=0,r=INF;\n\twhile(r-l>1)\n\t{\n\t\tll mid = (l+r)/2ll;\n\t\tif(C(mid))l = mid;\n\t\telse r = mid;\n\t}\n\tprintf(\"%lld\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main(){\n  int n;\n  cin >> n;\n  vector<ll> a(n * 2);\n  ll total = 0; \n  for(int i = 0; i < n; ++i){\n    cin >> a[i];\n    a[i + n] = a[i];\n    total += a[i];\n  }\n\n  ll ng = -1;\n  ll ok = LINF;\n  while(abs(ok - ng) > 1){ // O(nlogn)\n    ll mid = (ok + ng) / 2;\n\n    vector<int> nxt(n, -1);\n    vector<ll> nxt_size(n, -1);\n    ll tmp_sum = 0;\n    int r = 0;\n    for(int l = 0; l < n; ++l){\n      while(r < n * 2 && tmp_sum < mid){\n        tmp_sum += a[r];\n        ++r;\n      }\n\n      if(tmp_sum >= mid){\n        nxt[l] = r;\n        nxt_size[l] = tmp_sum;\n      }\n\n      if(l == r)++r;\n      else tmp_sum -= a[l];\n    }\n\n    bool is_ok = false;\n    for(int i = 0; i < n; ++i){\n      int ni = nxt[i];\n      if(ni == -1)continue;\n      if(nxt_size[i] >= total)continue;\n\n      ni %= n;\n      int nni = nxt[ni];\n      if(nni == -1)continue;\n\n      if(total - nxt_size[i] - nxt_size[ni] >= mid)is_ok = true;\n    }\n\n    if(!is_ok)ok = mid;\n    else ng = mid;\n  }\n\n  cout << ng << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<long> as(N*2), acc(2*N+1);\n\tlong total = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> as[i];\n\t\tas[i+N] = as[i];\n\t\ttotal += as[i];\n\t}\n\t//sum[i..j) = acc[j] - acc[i]\n\tfor (int i = 0; i < 2*N; i++) acc[i+1] = acc[i] + as[i];\n\tlong ok = 0, ng = total;\n\twhile(ok+1<ng)\n\t{\n\t\tlong x = (ok+ng)/2, sum = 0;\n\t\tint t = 0;\n\t\tvector<int> nxt(2*N+1, -1);\n\t\tfor (int s = 0; s < N; s++)\n\t\t{\n\t\t\twhile(t < 2*N && sum < x)\n\t\t\t{\n\t\t\t\tsum += as[t++];\n\t\t\t}\n\t\t\tif (sum >= x) nxt[s] = t;\n\t\t\tif (s != t)\n\t\t\t{\n\t\t\t\tsum -= as[s];\n\t\t\t}\n\t\t\telse t++;\n\t\t}\n\t\tbool f = 0;\n\t\tfor (int s = 0; s < N; s++)\n\t\t{\n\t\t\tint t = nxt[s];\n\t\t\tif (t == -1) continue;\n\t\t\tint u = nxt[t];\n\t\t\tif (u == -1) continue;\n\t\t\t//cout << x << ' ' << t << ' ' << u << ' ' << total - acc[u] + acc[s] << endl;\n\t\t\tf |= (total - acc[u] + acc[s] >= x);\n\t\t}\n\t\t(f ? ok : ng) = x;\n\t}\n\tcout << ok << endl;\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\nll n,a[200000],x[200000];\n\nll binsearch(ll start,ll d){\n    ll lb = -1,ub = n + 1;//[lb,ub)?????¢?´¢??????\n\n    while(ub - lb > 1){\n        ll mid = (lb + ub) / 2;\n        if((x[(mid + start) % (n + 1)] - x[start] + 3 * x[n]) % x[n] >= d)ub = mid;\n        else lb = mid;\n    }\n\n    return ub;\n}\n\n\n\nbool C(ll mid){\n    REP(i,n){\n        ll p = binsearch(i,mid);\n        if(p > n + 1)\n            continue;\n        ll q = binsearch((p + i) % (n + 1),(x[(p + i) % (n + 1)] - x[i] + 3 * x[n]) % x[n]);\n        if(p + q > n + 1)\n            continue;\n        ll r = binsearch((q + p + i) % (n + 1),(x[(p + i) % (n + 1)] - x[i] + 3 * x[n]) % x[n]);\n        if(p + q + r > n + 1)\n            continue;\n        return true;\n    }\n    return false;\n}\n\nll binsearch_i_max(){\n    ll lb = 0,ub = x[n] / 3 + 1;//[lb,ub)?????¢?´¢??????\n\n    while(ub - lb > 1){\n        ll mid = (lb + ub) / 2;\n        if(C(mid))lb = mid;\n        else ub = mid;\n    }\n\n    return lb;\n}\n\nint main(){\n    scanf(\"%lld\",&n);\n    REP(i,n)\n        scanf(\"%lld\",a + i);\n    x[0] = 0;\n    REP(i,n)\n        x[i + 1] = x[i] + a[i];\n\n    printf(\"%lld\\n\",binsearch_i_max());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\n#ifndef  LLONG_MAX\n#define LLONG_MAX 9223372036854775807\n#endif\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0 + 1, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left+1, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left != 1) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll a[300000];\nint main() {\n\tll n; scanf(\"%lld\", &n);\n\trep(i, n) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1 + n] = a[i + 1];\n\t}\n\tfor (ll i = 1; i <= 2 * n; i++)\n\t\ta[i] += a[i - 1];\n\tll s = 0, g = a[n];\n\twhile (s != g) {\n\t\tll t = (s + g) / 2;\n\t\tif (g - s == 1)t = g;\n\t\tbool flag = false;\n\t\trep(i, n) {\n\t\t\tll j = lower_bound(a + i, a + i + n + 1, a[i] + t) - a;\n\t\t\tif (j == n + i + 1)continue;\n\t\t\tll k = lower_bound(a + j, a + i + n + 1, a[j] + t) - a;\n\t\t\tif (a[j] - a[i] >= t&&a[k] - a[j] >= t&&a[i + n] - a[k] >= t) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)s = t;\n\t\telse g = t - 1;\n\t}\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll n;\n  cin >> n;\n  vector<ll> a(n*2);\n  ll total = 0;\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    a[n+i] = a[i];\n    total += a[i];\n  }\n\n  vector<ll> sum(n*2+1,0);\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i];\n\n  ll ans = 0;\n\n  int l=0, r=0;\n  while(l<n){\n    while(r<l+n-1 && 3*(sum[r]-sum[l])<=total)r++; r--;\n    //cout << l << \" \" << r << endl;\n    if(r-l>1){\n      ll cur = sum[r]-sum[l], rem = total-cur;\n      int L=r, R=l+n;\n      while(R-L>1){\n\tll M = (L+R)/2;\n\tif(2*(sum[M]-sum[r])<rem)L = M;\n\telse R = M;\n      }\n\n      ll minv = 0;\n      if(R<l+n && r<R)minv = max(minv, min(sum[R]-sum[r], sum[l+n]-sum[R]));\n      if(R-1<l+n && r<R-1)minv = max(minv, min(sum[R-1]-sum[r], sum[l+n]-sum[R-1]));\n      //cout << cur << \" \" << minv << \" \" << R << \" \" << endl;\n      minv = min(minv, cur);\n      ans = max(ans, minv);\n    }\n    l++; if(r<l)r++;\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    int n; cin >> n;\n    vector<ll> a(2 * n, 0);\n    ll total = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i], a[i + n] = a[i], total += a[i];\n    }\n    for (int i = 1; i < 2 * n; i++) {\n        a[i] += a[i - 1];\n    }\n    // [i, j), [j, k), [k, i+n) の３ピースに分ける\n    ll ans = 0;\n    for (int i = 0, j = i + 1; i < n; i++) {\n        while (true) {\n            ll d = a[j] - a[i];\n            auto tail = a.begin() + i + n + 1;\n            int k = lower_bound(a.begin(), tail, a[j] + d) - a.begin();\n            if (a[i + n] - a[k] > d) {\n                ans = max(ans, d);\n                j++;\n            } else {\n                break;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\trep(k, n)\n\t\t\t{\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\tif (tmin > ttmin) break;\n\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    long int num;\n    cin>>num;\n    long long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long long int mi=0;\n    \n    for (int i=1; i< num; i++) {\n        A[i]=A[i]+A[i-1];\n    }\n    double sanbun=A[num-1]/3.0;\n    int ni=0,san;\n    while (A[ni]<sanbun) {\n        ni++;\n    }\n    san=ni;\n    while (A[san]<2*A[ni]) {\n        san++;\n    }\n    \n    for (int i=0; i<num-2; i++) {\n        for (int j=ni; j<num-1; j++) {\n            for (int k=san; k<num; k++) {\n                mi=max(mi,min(A[k]-A[j],min(A[j]-A[i],A[num-1]-A[k]+A[i])));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  for (l = 0; l < n; l ++) {\n    for (; _sum[r] - _sum[l] <= _max; r ++);\n    r --;\n\n    left = _sum[r] - _sum[l];\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n    if (mid_id < 0) cout << mid_id << endl;\n\n    ans = max(ans, min(left, rem));\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000],s[200000], minx, miny, sum;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tminy = min(s[j] - s[i], s[k] - s[j]);\n\t\t\t\tminy = min(miny, sum - (s[k] - s[i]));\n\t\t\t\tminx = max(minx, miny);\n\t\t\t}\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst long long INF = 1000000000LL * 100000 + 10;\nint N;\nlong long sum[100001];\n\nint get_position(long long x){\n\treturn upper_bound(sum, sum + N, x) - sum;\n}\n\nint main() {\n\tlong long a[100001];\n\tcin >> N;\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum[i + 1] = sum[i] + a[i];\n\t}\n\t\n\tlong long res = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tint p1, p2;\n\t\twhile(1){\n\t\t\tp1 = get_position(res + sum[i]);\n\t\t\tp2 = get_position(res + sum[p1]);\n\t\t\tif(sum[p1] - sum[i] > res && sum[p2] - sum[p1] > res && sum[N] - sum[p2] + sum[i] > res){\n\t\t\t\tres = min(sum[p1] - sum[i], min(sum[p2] - sum[p1], sum[N] - sum[p2] + sum[i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int sum = data[N + 1];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N+2; i++ )\n\t{\n\t\tfor( size_t j = i; j < N+2; j++ )\n\t\t{\n\t\t\tlong long int A = data[j] - data[i];\n\t\t\tif( A < ans )continue;\n\t\t\tif( sum - A < ans * 2 )continue;\n\t\t\tfor( size_t k = j; k < N+2; k++ )\n\t\t\t{\n\t\t\t\tlong long int B = data[k] - data[j];\n\t\t\t\tans = max ( ans , min ( { A , B , sum - A - B } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tlong long  num_cut = 0;\n\tlong long  sum = 0L;\n\tlong long  oneThird = 0L;\n\tint cuts[100000];\n\n\tlong long min_piece=0L;\n\tint a=0;\n\tlong long restCake=0L;\n\n\tcin >> num_cut;\n\tfor(int i = 0; i < num_cut; i++){\n\t\tcin >> a;\n\t\tsum += a;\n\t\tcuts[i] = a;\n\t}\t\n\n\toneThird = (sum + 2) / 3;\n\tlong long firstSize = 0L;\n\tlong long secondSize = 0L;\n\tlong long thirdSize = 0L;\n\tlong long thirdSize_in1 = 0L;\n\t\n\tbool fi_se = false; // 1st >= 2nd\n\tbool se_th = false; // 2nd >= 3rd\n\tbool fi_th = false; // 1st >= 3rd\n\t// start\n\tfor(int start=0; restCake < oneThird; start++){\n\t\tfirstSize = 0L;\n\t\t// 1st\n\t\tfor(int first=start+1; firstSize < oneThird; first++){\n\t\t\tfirstSize += cuts[first];\n\t\t\tsecondSize = 0L;\n\t\t\tthirdSize_in1 = sum-firstSize;\n\t\t\t// 2nd\n\t\t\tfor(int second=first+1; secondSize < oneThird; second++){\n\t\t\t\tsecondSize += cuts[second];\n\t\t\t\t// 3rd  \n\t\t\t\tthirdSize = thirdSize_in1 - secondSize;\n\t\t\t\tfi_se = (firstSize >= secondSize);\n\t\t\t\tse_th = (secondSize >= thirdSize);\n\t\t\t\tfi_th = (firstSize >= thirdSize);\n\t\t\t\tif(!fi_se && !fi_th){\n\t\t\t\t\tif(firstSize > min_piece) min_piece = firstSize;\n\t\t\t\t}else if(fi_se && !se_th){\n\t\t\t\t\tif(secondSize > min_piece) min_piece =secondSize;\n\t\t\t\t}else{\n\t\t\t\t\tif(thirdSize > min_piece) min_piece =thirdSize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trestCake += cuts[start];\n\t}\n\n\tcout << min_piece << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \nlong long t,n,a[200001];\n \nbool check(int b,long long x){\n  int l=b,r=b+n,m;\n  while(l<r){\n    m=(l+r)/2;\n    if(a[m]-a[b]>=x)r=m;\n    else l=m+1;\n  }\n  int d=l;\n  r=min(n+d,2*n);\n  while(l<r){\n    m=(l+r)/2;\n    if(a[m]-a[d]>=x)r=m;\n    else l=m+1;\n  } \n  if(l<b+n&&a[b+n]-a[l]>=x)return 1;  \n  return 0;\n}\n \nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    cin>>a[i],t+=a[i],a[i]=t;\n  for(int i=0;i<n;i++)a[i+n]=a[i]+t;\n  long long ans=-1;\n  for(int i=0;i<n;i++){\n    long long l=0,r=1e18,m;\n    while(l<r){\n      m=(l+r)/2;\n      if(check(i,m))l=m+1;\n      else r=m;\n    }\n    ans=max(ans,l-1);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n\n#define max(a,b) ((a>b)?a:b)\n\nusing namespace std;\n\nint main(void){\n    int n,i,s=0,e,m,flag;\n    long long int* pos;\n    long long int a[200001],sum,mid,lim,ans=-1,tmp,x,y,p,q,v,w;\n    scanf(\"%d\",&n);\n    a[0] = 0LL;\n    for(i=1; i<=n; i++){\n        scanf(\"%lld\",&a[i]);\n        a[i] += a[i-1];\n    }\n    sum = a[n];\n    for(i=1; i<=n; i++){\n        a[n+i] = sum + a[i];\n    }\n    lim = (sum+3)/3;\n    e=0;\n    while(s<=n){\n        tmp = a[e] - a[s];\n        if(tmp>lim){\n            s++;\n        }else if(s==e){\n            e++;\n        }else{\n            flag = 0;\n            mid = ((sum-tmp)/2)+a[e];\n            pos=lower_bound(a,a+2*n+1,mid);\n            m=(int)(pos-a);\n            x = a[m]-a[e];\n            y = sum-tmp-x;\n            m--;\n            p = a[m]-a[e];\n            q = sum-tmp-p;\n            if(x>=tmp && y>=tmp){\n                ans = max(ans,tmp);\n                flag = 1;\n            }else if(p>=tmp && q>=tmp){\n                ans = max(ans,tmp);\n                flag = 1;\n            }\n            if(flag==1){\n                e++;\n            }else{\n                s++;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m])r=m;\n    else l=m+1;\n  }\n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut2--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n    cut3--;\n    ans=max(max(ans,A[cut2]-A[cut1]),max(A[cut3]-A[cut2],A[cut1+n]-A[cut3]));\n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint i = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[i] <= one_third){\n\t\tpiece1 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t}\n\t\n\tint piece2_i = i;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = i;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint n;vector<long long > rui;\nbool check(int i,long long m)\n{    vector<long long >::iterator hoge=rui.end();    hoge = lower_bound(rui.begin() + i, rui.begin() +n-1+ i, m+rui[i]-1);    if (hoge == rui.end())return false;    vector<long long >::iterator hage = rui.end();    hage = lower_bound(hoge, rui.begin() + n - 1 + i, m + *hoge);    if (hage == rui.end())return false;    if (*(rui.begin() + n - 1 + i) - (*hage) >= m)return true;    return false;}int main(){    cin >> n;    rep(i, n)    {        long long int x;        cin >> x;        (i == 0) ? rui.push_back(x) : rui.push_back(rui[i - 1] + x);    }    rep(i, n)(i == 0) ? rui.push_back(rui[0] + rui[n - 1]) : rui.push_back(rui[n - 1 + i] + rui[i] - rui[i - 1]);    long long int ans = 0;    rep(i, n)    {        long long l = 0;        long long r = 500000000000000000;        while (r != l)        {            long long int m = (l + r) / 2;            if (check(i, m))            {                l = m+1;            }            else            {                r = m;            }        }        ans = max(ans, l);    }    cout << ans << endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[100010];\n\nvoid a(string s){}\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n    if (idx > i + N) return false;\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n    if (idx2 > i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 100010, 1e16);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e15;\n\n        rep(_, 60) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nint n;\nvector<ll> a;\nll sum = 0;\n\nbool f(ll x){\n    for(int i = 1; i <= n; i++){\n        auto first = lower_bound(a.begin(), a.end(), a[i-1]+x);\n        if(first == a.end())    continue;\n        ll s = *first-a[i-1];\n        auto second = lower_bound(a.begin(), a.end(), *first+x);\n        if(second == a.end())   continue;\n        ll t = *second-*first;\n        if(sum-s-t >= x)    return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> n;\n\n    a.resize(n+1);\n    a[0] = 0;\n    for(int i = 0; i < n; i++)  cin >> a[i+1];\n\n    sum = accumulate(a.begin(), a.end(), 0ll);\n    ll l = 1, r = sum;\n\n    for(int i = 0; i < n; i++)  a[i+1] += a[i];\n\n    while(r-l > 1){\n        ll mid = (l+r)/2;\n        if(f(mid))  l = mid;\n        else        r = mid;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 200000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 200000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)114\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tfor( ; j < N+i; j++ ){\n\t\t\tif( A[j]-A[i] >= X )\n\t\t\t\tbreak;\n\t\t}\n\t\t//できるだけ真ん中で切る\n\t\tfor( ; k < N+i; k++ ){\n\t\t\tif( A[k]-A[j] >= A[N+i]-A[k] )\n\t\t\t\tbreak;\n\t\t}\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tint a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif((a2_sum + InArray[a2+1]) < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\nconst int INF = 2e9;\nconst LL LINF = 3e18;\n\nLL n;\nLL a[200010];\nLL ans = 0;\n\nLL solve(LL first)\n{\n  LL ret = 0;\n  LL *p1, *p2;\n  p1 = lower_bound(a + first, a + n + first, a[n] / 3 + a[first]);\n  p2 = lower_bound(p1, a + n + first, (a[n + first] - *p1) / 2 + *p1);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  p2 = lower_bound(p1, a + n + first, (a[n + first] - *p1) / 2 + *p1);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n\n  p2 = lower_bound(a + first, a + n + first, a[n] / 3 * 2 + a[first]);\n  p1 = lower_bound(a + first, p1, (*p2 - a[first]) / 2 + a[first]);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p2--;\n  p1 = lower_bound(a + first, p1, (*p2 - a[first]) / 2 + a[first]);\n  \n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n\n  p1--;\n  ret = max(ret, min(*p1 - a[first], min(*p2 - *p1, a[n + first] - *p2)));\n  return ret;\n}\n\nint main()\n{\n  scanf(\"%lld\", &n);\n  for(LL i = 1; i <= n; i++)\n    scanf(\"%lld\", &a[i]);\n\n  for(LL i = n + 1; i <= 2 * n; i++)\n    a[i] = a[i - n];\n\n  for(LL i = 2; i <= 2 * n; i++)\n    a[i] += a[i - 1];\n\n  for(LL i = 0; i < n; i++)\n    ans = max(ans, solve(i));\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL, RR, CC;\nint main()\n{\n\tint i, j, k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1;\n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2 * N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif (l != 0)sum = AA[r-1] - AA[l - 1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N - 1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif (AA[CC - 1] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r-1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2){\n\t\t\t\tans = max(ans, sum); l++;\n\t\t\t}\n\t\t\telse r++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint ini = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[ini] <= one_third){\n\t\tpiece1 += (long long int)A[ini];\n\t\tini++;\n\t}\n\t\n\tint piece2_i = ini;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[ini];\n\t\tini++;\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = ini;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << \"\\n\";\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\nint main() {\n    /* 入力 */\n    int N;\n    cin >> N;\n    vector<long long> a(N*2); // 環状の数列を扱うときは二週確保はよくやる\n    long long total = 0; // バームクーヘン全体のサイズ\n    for (int i = 0; i < N; ++i) cin >> a[i], a[i+N] = a[i], total += a[i];\n    \n    \n    /* 二分探索 */\n    long long low = 0, high = 1LL<<60;\n    while (high - low > 1) {\n        /* 三ピースとも mid 以上にできるかを判定する */\n        long long mid = low + (high - low) / 2;\n        \n        //COUT(\"------\");\n        //COUT(mid);\n    \n        /* 各切れ目から mid 以上になる最小区間がどこまでかを求める */\n        vector<int> Next(N, -1);\n        vector<long long> Size(N, -1);\n        int right = 0;\n        long long sum = 0;\n        for (int left = 0; left < N; ++left) {\n            while (right < N*2 && sum < mid) {\n                sum += a[right];\n                ++right;\n            }\n            if (sum >= mid) { // mid 以上なら記録\n                Next[left] = right;\n                Size[left] = sum;\n                \n                //cout << left << \": \" << Next[left] << \", \" << Size[left] << endl;\n            }\n            if (right == left) ++right;\n            else sum -= a[left];\n        }\n        \n        /* check */\n        bool ok = false;\n        for (int i = 0; i < N; ++i) {\n            int ni = Next[i];\n            if (ni == -1) continue;\n            if (Size[i] >= total) continue;\n            \n            ni %= N;\n            int nni = Next[ni];\n            if (nni == -1) continue;\n            \n            // 残りが mid 以上なら OK\n            if (total - Size[i] - Size[ni] >= mid) ok = true;\n        }\n        \n        if (!ok) high = mid;\n        else low = mid;\n    }\n    \n    cout << low << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define all(a) begin(a),end(a)\n\nint N;\nint A[100010];\nint Sum[100010];\n\nbool check(int i, int x)\n{\n    int idx = lower_bound(all(Sum), Sum[i] + x) - begin(Sum);\n    if (idx > i + N) return false;\n    int idx2 = lower_bound(all(Sum), Sum[idx] + x) - begin(Sum);\n    if (idx2 > i + N) return false;\n\n    return Sum[i + N] - Sum[idx2] >= x;\n}\n\nsigned main()\n{\n    cin >> N;\n\n    rep(i, N) cin >> A[i];\n\n    fill_n(Sum, 100010, 1e16);\n    Sum[0] = 0;\n    for (int i = 0; i < N; ++i) Sum[i + 1] = A[i] + Sum[i];\n    for (int i = 0; i < N; ++i) Sum[N + i + 1] = A[i] + Sum[N + i];\n\n    int ans = 0;\n\n    rep(i, N) {\n        int l = 0, r = 1e17;\n\n        rep(_, 60) {\n            int mid = (l+r)/2;\n            if (check(i, mid)) l = mid;\n            else r = mid;\n        }\n\n        ans = max(ans, l);\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MP make_pair\n\nint main(){\n\tint n,a[100000];\n\tvector<int> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i] + x[i-1];\n\t\t}\n\t}\n\tint length = x[n-1] / 3;\n\tint mi = 0;\n\tint ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tint tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tint p1 = 0, p2 = 0;\n\t\tint q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j-1;\n\t\t\t\t\ttmp = (x[n-1] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n-1] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long int lis[200005]={0},rui[200005]={0};\nint main(){\n    long long int N;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>lis[i];\n    for(int i=0;i<N;i++){\n        lis[N+i]=lis[i];\n    }\n    for(int i=0;i<N*2+1;i++){\n        if(i==0)rui[i]=lis[i];\n        else rui[i]=rui[i-1]+lis[i];\n    }\n    long long int maxans=0;\n    rui[2*N]=1000000000000000000;rui[2*N+1]=1000000000000000000;rui[2*N+2]=1000000000000000000;rui[2*N+3]=1000000000000000000;\n    for(int i=0;i<N;i++){\n        long long int l=0,r=10000000000000000,mid=(l+r)/2;\n        for(int j=0;j<55;j++){\n            mid=(l+r)/2;\n            long long int ll=i,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(i!=0){\n                    if(rui[midmid]-rui[i-1]>=mid)rr=midmid;\n                    else ll=midmid;\n                }\n                else if(rui[midmid]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            int memo=rr+1;\n            ll=rr,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(rui[midmid]-rui[memo-1]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            memo=rr+1;\n            ll=rr,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(rui[midmid]-rui[memo-1]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            if(rr<2*N&&rr-i<N)l=mid;\n            else r=mid;\n        }\n        maxans=max(maxans,mid);\n    }\n    cout<<maxans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint num_cut = 0;\nvector<int> cuts;\nint sum = 0;\nint oneThird = 0;\n\n\nint searchMinCut(int start, int num, int rest){\n\tint thisCutSize = 0;\n\tif(num == 3){\n\t\tfor(int i=start; i<num_cut; i++){\n\t\t\tthisCutSize += cuts[i];\n\t\t}\n\t\tthisCutSize += rest;\n\t\treturn thisCutSize;\n\t}\n\t// set max size\n\tint thisMaxMin = 0;\n\tint nextCutMinMaxSize = 0;\n\tfor(int i=start; i<num_cut; i++){\n\t\tif(thisCutSize > oneThird) return thisMaxMin;\n\t\tthisCutSize += cuts[i];\n\t\tint nextMinSize = searchMinCut(i+1, num+1, rest);\n\t\tif(nextMinSize > thisCutSize){\n\t\t\tif(thisCutSize > thisMaxMin) thisMaxMin = thisCutSize;\n\t\t}else{\n\t\t\tif(nextMinSize > thisMaxMin) thisMaxMin = nextMinSize;\n\t\t}\n\t}\n\treturn thisMaxMin;\n}\n\nint main(){\n\tint min_piece=0;\n\tint a=0;\n\tint restCake=0;\n\tcin >> num_cut;\n\tfor(int i = 0; i < num_cut; i++){\n\t\tcin >> a;\n\t\tsum += a;\n\t\tcuts.push_back(a);\n\t}\t\n\toneThird = (sum + 2) / 3; \n\n\tfor(int first=0; restCake<=oneThird; first++){\n\t\tint nextMin = searchMinCut(first, 1, restCake);\n\t\tif(min_piece < nextMin) min_piece = nextMin;\n\t\trestCake += cuts[first];\n\t}\n\n\tcout << min_piece << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define NN 505\n#define N 10005\n#define oo 1000000007\n#define ln 1000000009\n\nusing namespace std;\n\nll S[N], ans;\nint n, a[N];\n\nll Get(int F, int i, int j)\n{\n    int L = i-1;\n    int R = j;\n    while(R - L > 1)\n    {\n        int X = (L + R) / 2;\n        if(S[X] * 2 <= S[i-1] + S[j])  L = X;\n        else R = X;\n    }\n    return min(S[i-1] - S[F-1], max(min(S[L] - S[i-1], S[j] - S[L]), min(S[R] - S[i-1], S[j] - S[R])));\n}\n\nll Solve(int i)\n{\n    int L = i;\n    int R = i + n - 1;\n    for(int j=1; j<=20; j++)\n    {\n        int X = (L + R) / 2;\n        if(Get(i, X, i+n-1) > Get(i, X+1, i+n-1))   R = X;\n        else L = X+1;\n    }\n    return Get(i, L, i+n-1);\n}\n\nint main()\n{\n    //filein(\"inp.txt\");  fileout(\"out.txt\");\n    cin >> n;\n    for(int i=1; i<=n; i++)\n        cin >> a[i], a[i+n] = a[i];\n    for(int i=1; i<=2*n; i++)\n        S[i] = S[i-1] + a[i];\n    for(int i=1; i<=n; i++)\n        ans = max(ans, Solve(i));\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint N, A[200000];\nint64 sum[200000];\n\nbool Find(const int& pos, const int64& size){\n  int hoge = distance( sum, lower_bound( sum + pos + 1, sum + N + pos + 1, sum[pos] + size));\n  if(hoge == N + pos + 1) return false;\n  int fuga = distance( sum, lower_bound( sum + hoge + 1, sum + N + pos + 1, sum[hoge] + size));\n  if(fuga == N + pos + 1) return false;\n  int foo = distance( sum, lower_bound( sum + fuga + 1, sum + N + pos + 1, sum[fuga] + size));\n  return(foo != N + pos + 1);\n}\n\n\nbool calc(int64 size){ //size: 1個あたりの大きさ\n  for(int pos = 0; pos < N; pos++){\n    if(Find(pos, size)) return true;\n  }\n  return false;\n}\n\nint main(){\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", A + i);\n    A[N + i] = A[i];\n  }\n\n  sum[0] = A[0];\n  for(int i = 1; i < 2 * N; i++){\n    sum[i] = sum[i - 1] + A[i];\n  }\n\n  int64 low = 0, high = INF;\n  while(high - low > 1){\n    int64 mid = (low + high + 1) >> 1;\n    if(calc(mid)) low = mid; else high = mid;\n  }\n  printf(\"%d\\n\", low + calc(high));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n;\nvector < int > a;\nvector<long long int > pr;\nbool check2(int k,int now,long long int m)\n{\n\tif (pr[now] - pr[k] >= m)return true;\n\treturn false;\n}\nbool check(int i,long long int m)\n{\n\tint r = i+n-1, l = i;\n\twhile (r != l)\n\t{\n\t\tint now = (r + l) / 2;\n\t\tif (check2(i,now,m))\n\t\t{\n\t\t\tr = now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = now+1;\n\t\t}\n\t}\n\tr = i + n - 1;\n\tint hoge = l;\n\twhile (r != l)\n\t{\n\t\tint now = (r + l) / 2;\n\t\tif (check2(hoge, now, m))\n\t\t{\n\t\t\tr = now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = now+1;\n\t\t}\n\t}\n\tif (pr[i + n - 1] - pr[r] >= m)return false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x);\n\t\t(i == 0) ? pr.push_back(x) : pr.push_back(x + pr[i - 1]);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ta.push_back(a[i]);\n\t\tpr.push_back(pr.back() + a[i]);\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long int r = 0, l = 50000000;\n\t\twhile (r != l)\n\t\t{\n\t\t\tlong long int m = (r + l) / 2;\n\t\t\tif (check(i,m))\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m+1;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, l);\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n + 1] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = (sum - size) / 2.0;\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nint main()\n{\n\tint n;\n\tstatic int a[100000];\n\tstatic int s[200000], t[200000], next[2][200000];\n\tstatic pair<int, int> p[400000];\n\tstatic vector<int> bucket[300000];\n\t\n\tlint sum = 0;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", a + i);\n\t\tsum += a[i];\n\t}\n\t\n\tlint left = 0, right = sum / 3;\n\t\n\twhile (left != right){\n\t\tlint mid = (left + right + 1) >> 1;\n\t\tlint sum2 = 0;\n\t\tint head = 0, tail = 0;\n\t\tbool ng = false;\n\t\t\n\t\tfor (; head < n; head++){\n\t\t\twhile (sum2 < mid){\n\t\t\t\tsum2 += a[tail++];\n\t\t\t\tif (tail >= n) tail -= n;\n\t\t\t}\n\t\t\tint i = head;\n\t\t\ts[i] = head, t[i] = tail;\n\t\t\tif (s[i] == t[i]) ng = true;\n\t\t\tif (t[i] < s[i]) t[i] += n;\n\t\t\ts[n + i] = s[i] + n, t[n + i] = t[i] + n;\n\t\t\tsum2 -= a[head];\n\t\t}\n\t\tif (ng){\n\t\t\tright = mid - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 0; i < n * 3; i++) bucket[i].clear();\n\t\t\n\t\tfor (int i = 0; i < n * 2; i++){\n\t\t\tbucket[t[i]].push_back(i);\n\t\t\tbucket[s[i]].push_back(n * 2 + i);\n\t\t}\n\t\tint ctr = 0;\n\t\tfor (int i = 0; i < n * 3; i++){\n\t\t\tfor (int j = 0; j < bucket[i].size(); j++){\n\t\t\t\tp[ctr++] = make_pair(i, bucket[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint last = -1;\n\t\tfor (int i = n * 4 - 1; i >= 0; i--){\n\t\t\tint id = p[i].second;\n\t\t\tif (id < n * 2) next[0][id] = last;\n\t\t\telse {\n\t\t\t\tid -= n * 2;\n\t\t\t\tif (last < 0 || t[last] > t[id]) last = id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k = 0; k + 1 < 2; k++){\n\t\t\tfor (int i = 0; i < n * 2; i++){\n\t\t\t\tif (next[k][i] < 0) next[k + 1][i] = -1;\n\t\t\t\telse next[k + 1][i] = next[k][next[k][i]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint tmp = 0, j = i;\n\t\t\tfor (int k = 1; k >= 0; k--){\n\t\t\t\tint j2 = next[k][j];\n\t\t\t\tif (j2 >= 0 && t[j2] <= s[i] + n){\n\t\t\t\t\tj = j2;\n\t\t\t\t\ttmp |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res >= 3) break;\n\t\t\tres = max(res, tmp + 1);\n\t\t}\n\t\tif (res >= 3) left = mid;\n\t\telse right = mid - 1;\n\t}\n\t\n\tprintf(\"%lld\\n\", left);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tunsigned int a[200001], baum, b[4][3], minb, ans = 0;\n\tcin >> n;\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t\ta[i] += a[i - 1];\n\t\ta[i + n] = a[i];\n\t}\n\tbaum = a[n];\n\tfor (int i = 1; i <= n; i++){\n\t\ta[i + n] += baum;\n\t}\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2;\n\t\tfor (cut2 = cut1 + 1; cut2 < cut1 + n; cut2++){\n\t\t\tif (a[cut2] - a[cut1] > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < cut1 - 1 + n; cut3_1++){\n\t\t\tif (a[cut3_1] - a[cut2 - 1] >(baum - (a[cut2 - 1] - a[cut1])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 < cut1 + n; cut3_2++){\n\t\t\tif (a[cut3_2] - a[cut2] >(baum - a[cut2] - a[cut1]) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = a[cut2 - 1] - a[cut1];\n\t\tb[0][1] = a[cut3_1 - 1] - a[cut2 - 1];\n\t\tb[0][2] = baum - b[0][0] - b[0][1];\n\t\tb[1][0] = a[cut2 - 1] - a[cut1];\n\t\tb[1][1] = a[cut3_1] - a[cut2 - 1];\n\t\tb[1][2] = baum - b[1][0] - b[1][1];\n\t\tb[2][0] = a[cut2] - a[cut1];\n\t\tb[2][1] = a[cut3_2 - 1] - a[cut2];\n\t\tb[2][2] = baum - b[2][0] - b[2][1];\n\t\tb[3][0] = a[cut2] - a[cut1];\n\t\tb[3][1] = a[cut3_2] - a[cut2];\n\t\tb[3][2] = baum - b[3][0] - b[3][1];\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\n\nint N, A[200000];\nint64 sum[200000];\n\nbool Find(const int& pos, const int64& size){\n  int hoge = distance( sum, lower_bound( sum + pos + 1, sum + N + pos + 1, sum[pos] + size));\n  if(hoge == N + pos + 1) return false;\n  int fuga = distance( sum, lower_bound( sum + hoge + 1, sum + N + pos + 1, sum[hoge] + size));\n  if(fuga == N + pos + 1) return false;\n  int foo = distance( sum, lower_bound( sum + fuga + 1, sum + N + pos + 1, sum[fuga] + size));\n  return(foo != N + pos + 1);\n}\n\n\nbool calc(int64 size){ //size: 1個あたりの大きさ\n  for(int pos = 0; pos < N; pos++){\n    if(Find(pos, size)) return true;\n  }\n  return false;\n}\n\nint main(){\n\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++){\n    scanf(\"%d\", A + i);\n    A[N + i] = A[i];\n  }\n\n  sum[0] = A[0];\n  for(int i = 1; i < 2 * N; i++){\n    sum[i] = sum[i - 1] + A[i];\n  }\n\n  int64 low = 0, high = INF;\n  while(high != low){\n    int64 mid = (low + high + 1) >> 1;\n    if(calc(mid)) low = mid; else high = mid - 1;\n  }\n  printf(\"%lld\\n\", low);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint a[111111*3];\nlong long sum[111111*3];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    assert(sum[m]-sum[l]+lim+sum[r]-sum[m]==sum[n]);\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] >= sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  //s = e;\n  assert(lim+sum[r]-sum[s]+sum[s]-sum[l]==sum[n]);\n  //printf(\":%d %d %lld %lld %lld %lld %d %d\\n\",l,r,lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  long long ret = min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n  res = max(res,ret);\n  return ret;\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n    a[i+2*n] = a[i];\n  }\n  for( int j = 0; j < 3*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;e<2*n;++e) {\n    while( e < 2*n && C(s,e) > sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[200007],sum=0,pref[200007],ans=0;\nint check(int start,int fs,long long val){\n    int l=start;\n    int r=fs;\n    int mid=(l+r)/2;\n    if(val>sum/3) return 0;\n    while(l!=mid && r!=mid){\n        if(pref[mid]-pref[start-1]>=val) r=mid;\n        else l=mid+1;\n        mid=(l+r)/2;\n    }\n    for(int i=l;i<=r;i++){\n        if(pref[i]-pref[start-1]>=val){\n            if(sum-val-(pref[i]-pref[start-1])>=val) return 1;\n        }\n    }\n    return 0;\n}\nlong long sol(int pos,int stat){\n    int l=pos;\n    int r=stat-2;\n    int mid=(l+r)/2;\n    while(l!=mid && r!=mid){\n        if(check(mid+1,stat,pref[mid]-pref[pos-1])==1) l=mid;\n        else r=mid-1;\n        mid=(l+r)/2;\n    }\n    for(int i=r;i>=l;i--){\n        if(check(i+1,stat,pref[i]-pref[pos-1])==1) return pref[i]-pref[pos-1];\n    }\n    return -1;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n        sum+=a[i];\n        pref[i]=pref[i-1]+a[i];\n    }\n    for(int i=1;i<=n;i++){\n        a[i+n]=a[i];\n        pref[i+n]=pref[i+n-1]+a[i+n];\n    }\n    for(int i=n;i<=n+n-1;i++){\n        long long ps=sol(i-n+1,i);\n        ans=max(ans,ps);\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 100005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n// #define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(int)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = (_begin + _end) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\n\n\nll N,M,K,A[NMAX],B,D,E;\nll S[NMAX] = {};\n\nll ans = {};\n\nbool C(int x){\n  for (int i = 0, j = 0; i < N; ++i)\n  {\n    while(j < N && S[j] - S[i] < x) ++j;\n    if(j == N) return false;\n    int k = j;\n    while(k < N && S[k] - S[j] < x) ++k;\n    if(k == N) return false;\n\n    if(S[i + N] - S[k] >= x) return true;\n  }\n  return false;\n}\n\nvoid solve(){\n  // main algorithm\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    S[i+1] = S[i] + A[i % N];\n  }\n  int low = 1, hi = S[N];\n  while(hi - low > 1) {\n    int mid = (hi + low) / 2;\n    if(C(mid)) {\n      low = mid;\n      debug(\"C(%d) = true\\n\", mid);\n    }\n    else {\n      hi = mid;\n      debug(\"C(%d) = false\\n\", mid);\n    }\n  }\n  ans = low;\n}\nvoid debug(){\n  // output debug information\n\n  printf(\"i\\t| A[i]\\tS[i]\\n--------------------------\\n\");\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    printf(\"%d\\t| %lld\\t%lld\\n\", i, A[i%N], S[i]);\n  }\n  printf(\"%d\\t| ***\\t%lld\\n\", 2*N, S[2 * N]);\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // Fill(dp, -1);\n  cin >> N;\n  for (int i = 0; i < N; ++i)\n  {\n    scanf(\"%lld\", &A[i]);\n  }\n  solve();\n  #ifdef DEBUG\n  debug();\n  #endif\n  answer();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst int64 INF = 1LL << 33;\n  \nint64 N, P[200014];\nint64 Sum[200014];\n  \nbool Check(int64 value)\n{\n  int End1 = 0, End2 = 0;\n  int64 Sum1 = 0, Sum2 = 0;\n  \n  for(int i = 0; i < N; i++) {\n    while(Sum1 < value) {\n      Sum1 += P[End1];\n      if(End1 < End2) Sum2 -= P[End1];\n      ++End1;     \n    }\n    if(i == 0) {\n      Sum2 = 0, End2 = End1;\n    }\n    while(Sum2 < value) {\n      Sum2 += P[End2];\n      ++End2;\n    }\n    if(Sum[i + N] - Sum[End2] >= value) {\n      return(true);\n    }\n    Sum1 -= P[i];\n  }\n  return(false);\n}\n  \nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%lld\", &P[i]);\n    P[i + N] = P[i];\n  }\n  for(int i = 1; i <= 2 * N; i++) {\n    Sum[i] = Sum[i - 1] + P[i - 1];\n  }\n  int64 low = 0, high = Sum[N + N] / 3;\n  while(high - low > 0) {\n    int64 mid = (low + high + 1) / 2;\n    if(Check(mid)) low = mid;\n    else high = mid - 1;\n  }\n  printf(\"%lld\\n\", low);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 100000\n\n#define D(x,y) (pos[(x)]-pos[(y)])\n\nlong long A[NMAX];\nlong long pos[NMAX*2];\nint N;\nlong long L;\n\nlong long solve() {\n    long long ret = 1;\n    int p0 = 0, p1 = 0, p2 = 0;\n    long d0 = 0, d1 = 0;\n    while (p0 < N) {\n        if (p1 <= p0) p1 = p0 + 1;\n        while (p1 - p0 < N && D(p1, p0) <= ret) p1++;\n        if (D(p1, p0) <= ret) goto L1;\n\n        if (p2 <= p1) p2 = p1 + 1;\n        while (p2 - p0 < N && D(p2,p1) < D(p1, p0)) p2++;\n        if (D(p2, p1) < D(p1, p0)) goto L1;\n\n        if (L - D(p2, p0) >= D(p1, p0)) {\n            ret = D(p1, p0);\n            if (ret >= L/3) return ret;\n            continue;\n        }\nL1:\n        p0 += 1;\n        while (p2 > p1 && D(p2, p1) > D(p1, p0)) p2--;\n    }\n    return ret;\n}\n\nint main(void) {\n    int i;\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n        L += A[i];\n    }\n    for (i = 0; i < 2*N; i++) {\n        pos[i] = pos[i-1] + A[(i-1)%N];\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint searchMinimumSum(ll sum[]) {\n\tif (sum[0] <= sum[1] && sum[0] <= sum[2]) {\n\t\treturn 0;\n\t} else if (sum[1] <= sum[0] && sum[1] <= sum[2]) {\n\t\treturn 1;\n\t}\n\treturn 2;\n}\n\nint main(int argc, char const* argv[])\n{\n\tll N, ans = -1, counter = 0;\n\tcin >> N;\n\tll A[N], sum[3] = {0}, knife[3] = {0, 1, 2};\n\tfor (int i=0; i<N; i++) {\n\t\tcin >> A[i];\n\t\tif (i==0) {\n\t\t\tsum[0] = A[0];\n\t\t} else if (i==1) {\n\t\t\tsum[1] = A[1];\n\t\t} else {\n\t\t\tsum[2] += A[i];\n\t\t}\n\t}\n\twhile (counter < N + 3) {\n\t\tint minID = searchMinimumSum(sum);\n\t\tif (ans < sum[minID]) {\n\t\t\tans = sum[minID];\n\t\t}\n\t\tsum[minID] += A[knife[(minID+1)%3]];\n\t\tsum[(minID+1)%3] -= A[knife[(minID+1)%3]];\n\t\tknife[(minID+1)%3]++;\n\t\tif (knife[(minID+1)%3] == N) {\n\t\t\tknife[(minID+1)%3] = 0;\n\t \t}\n\t\tif (minID == 2) {\n\t\t\tcounter++;\n\t\t}\n\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  for (l = 0; l < n; l ++) {\n    for (; _sum[r] - _sum[l] <= _max; r ++);\n    r --;\n\n    left = _sum[r] - _sum[l];\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n    if (mid_id < 0) cout << mid_id << endl;\n\n    ans = max(ans, min(left, rem));\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n, a[200000],s[200000], minx, miny, sum;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tminy = min(a[j] - a[i], a[k] - a[j]);\n\t\t\t\tminy = min(miny, sum - (a[k] - a[i]));\n\t\t\t\tminx = max(minx, miny);\n\t\t\t}\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<long long> A(N+1);\n    long long total=0;\n    A[0]=0LL;\n    for(int i=1; i<=N; ++i) {\n        cin >> A[i];\n        total+=A[i];\n        A[i]+=A[i-1];\n    }\n\n    long long P,Q,R;\n    long long ans=0;\n    int i=1,j=i+1,k=j+1;\n    while(true) {\n        P=A[j-1]-A[i-1];\n        Q=A[k-1]-A[j-1];\n        R=total-P-Q;\n        ans=max(ans,min({P,Q,R}));\n        if(i==N-2) break;\n        else if(R==min({P,Q,R})) {\n            ++i;\n            if(i==j) ++j;\n            if(j==k) ++k;\n        } else if(P<Q && k-j>1) {\n            ++j;\n        } else {\n            ++k;\n            if(k>N) break;\n        }\n    }    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i - 1;\n}\n\nvoid CalcPiece1(int _i1, ull *_piece1_s, ull *_piece1_l, const ull _one_third_size, const int *_A, const int _N){\n\tif (_A[_i1 % _N] >= _one_third_size){\n\t\t*_piece1_s = _A[_i1 % _N];\n\t\t*_piece1_l = _A[_i1 % _N];\n\t\treturn;\n\t}\n\t\n\tull tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece1_s = tmp;\n\t\ttmp += _A[_i1 % _N];\n\t\t_i1++;\n\t}\n\t*_piece1_l = tmp;\n}\n\nvoid CalcPiece3(int _i3, ull *_piece3_s, ull *_piece3_l, const ull _one_third_size, const int *_A, const int _N){\n\tif (_A[_i3 % _N] >= _one_third_size){\n\t\t*_piece3_s = _A[_i3 % _N];\n\t\t*_piece3_l = _A[_i3 % _N];\n\t\treturn;\n\t}\n\t\n\tull tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece3_s = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n\t*_piece3_l = tmp;\n}\n\nint CalcPiece3(int _i3, ull *_piece3, const ull _one_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n\treturn _i3++;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t/*\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\tint i2 = i1;\n\t\tull piece2 = 0;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\n\t\tint i3 = i2;\n\t\tull piece3 = total_size - piece1 - piece2;\n\t\twhile (piece3 > two_third_size){\n\t\t\tpiece3 -= A[i3 % N];\n\t\t\ti3++;\n\t\t}\n\n\t\tull tmp = 0;\n\t\tif (piece1 < piece2 && piece1 < piece3){\n\t\t\ttmp = piece1;\n\t\t}\n\t\telse if (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\n\t\tpiece1 += A[i1 % N];\n\t\ttwo_third_size = (total_size - piece1) / 2;\n\t\ti2 = i1 + 1;\n\t\tCalcPiece(i2, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2;\n\t\tif (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\n\t\ti3 = i - 1 + N;\n\t\tCalcPiece3(i3, &piece3, two_third_size, A, N);\n\t\tpiece2 = total_size - piece1 - piece3;\n\t\tif (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\t/*/\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size;\n\tif(total_size % 3 == 0) one_third_size = total_size / 3;\n\telse one_third_size = total_size / 3 + 1;\n\n\tull answer = 0;\n\tfor(int i1=0; i1<N; i1++){\n\t\tull piece1 = 0;\n\t\tint i2;\n\t\tfor(i2=i1; i2<i1-2+N; i2++){\n\t\t\tpiece1 += A[i2%N];\n\t\t\tif(piece1 >= one_third_size) break;\n\t\t}\n\t\tif(piece1 < one_third_size) continue;\n\t\ti2++;\n\n\t\tull two_third_size = total_size - piece1;\n\t\tull half_size;\n\t\tif(two_third_size % 2 == 0) half_size = two_third_size / 2;\n\t\telse half_size = two_third_size / 2 + 1;\n\n\t\tull tmp = 0;\n\t\tfor(int i3=i1-1+N; i3>i2; i3--){\n\t\t\ttmp += A[i3%N];\n\t\t\tif(tmp >= half_size) break;\n\t\t}\n\t\tull piece2 = two_third_size - tmp;\n\n\t\ttmp = 0;\n\t\tfor(int i3=i2; i3<i1-1+N; i3++){\n\t\t\ttmp += A[i3%N];\n\t\t\tif(tmp >= half_size) break;\n\t\t}\n\t\tull piece3 = two_third_size - tmp;\n\n\t\tif(piece2 > piece3) tmp = piece2;\n\t\telse tmp = piece3;\n\t\t\n\t\tif(tmp > answer) answer = tmp;\n\t}\n\n\tdelete[] A;\n\n\tcout << answer << endl;\n\t//*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = 0;\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif((a2_sum + InArray[a2+1]) < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif((a3_sum + InArray[a3+1]) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100000;\n\nint N;\nll sum[2 * MAX_N + 1];\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i < N + 1; i++){\n\t\tscanf(\"%lld\", &sum[i]);\n\t\tsum[N + i] = sum[i];\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor(int i = N + 1; i < 2 * N + 1; i++) sum[i] += sum[i - 1];\n\tll res = 0LL;\n\tll avg = sum[N] / 3;\n\tint j = 0, k = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(; k < i + N && sum[N + i] - sum[k] > avg; k++);\n\t\tfor(; j < k && sum[j] - sum[i] < avg; j++);\n\t\tfor(int l = 0; l < 9; l++){\n\t\t\tint sep1 = k + (l / 3) - 1;\n\t\t\tint sep2 = j + (l % 3) - 1;\n\t\t\tres = max(res, min(sum[N + i] - sum[sep1], min(sum[sep1] - sum[sep2], sum[sep2] - sum[i])));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\ntypedef long long int ll;\ntypedef pair<int, int> pii;\n\nll N, A[100010], S[200010];\n\n// start-point (1-indexed), length\nbool d(ll init, ll len) {\n    // [lb, ub)\n    ll lb = init, ub = N+init, idx = init;\n    rep(i,0,3) {\n        ll target = S[idx] + len;\n        idx = lower_bound(S, S+2*N+2, target) - S;\n        if(idx > ub) return false;\n    }\n    return true;\n}\n\nint main() {\n    cin >> N;\n    rep(i,0,N) cin >> A[i];\n\n    // 1 ... N\n    rep(i,0,N) S[i+1] = S[i] + A[i];\n    // N+1 ... 2N\n    rep(i,0,N) S[i+1+N] = S[i+N] + A[i];\n    S[2*N+1] = 1LL << 62;\n\n    ll ans = 0;\n    repq(i,1,N) {\n        ll ub = (ll)1e15, lb = 0;\n        while(ub - lb > 1) {\n            ll mid = (ub + lb) / 2;\n            if(d(i, mid)) lb = mid;\n            else ub = mid;\n        }\n        ans = max(ans, lb);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<20;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RND(x,y) for(int x=-2;x<=2;x++)for(int y=-2;y<=2;y++)\nint n;\nint a[114514];\nint s[114514];\n\nint b(int x){\n  return distance(s,lower_bound(s,s+n,x));\n}\n\nint mod(int x,int y){\n  return (x%y+y)%y;\n}\n\nsigned main(){\n  cin>>n;\n  REP(i,n){\n    cin>>a[i];\n    s[i+1]=a[i]+s[i];\n  }\n  int ans=0;\n  int S=s[n];\n  REP(i,n){\n    int p=b((S/3+s[i])%S);\n    int q=b((S*2/3+s[i])%S);\n    RND(x,y){\n      int px=(p+x)%n;\n      int qy=(q+y)%n;\n      if(i>=px||px>=qy||qy>=i+n)continue;\n      int w1=mod(s[px]-s[i],S);\n      int w2=mod(s[qy]-s[px],S);\n      int w3=mod(s[i]-s[qy],S);\n      #ifdef DEBUG\n      cout<<(i)<<\" \"<<(px)<<\" \"<<(qy)<<\":\";\n      cout<<w1<<\" \"<<w2<<\" \"<<w3<<endl;\n      #endif\n      int wm=min({w1,w2,w3});\n      ans=max(ans,wm);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "s"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tconst long long int one_third = whole / 3;\n\tlong long int ans = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tint j = i;\n\t\tlong long int piece1 = 0;\n\t\twhile (piece1 + (long long int)A[j] <= one_third){\n\t\t\tpiece1 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t}\n\n\t\tlong long int piece2 = 0;\n\t\twhile (1){\n\t\t\tpiece2 += (long long int)A[j];\n\t\t\tj++;\n\t\t\tif (j == N) j-= N; //周期的境界条件\n\t\t\tif (piece2 >= piece1) break;\n\t\t}\n\n\t\tlong long int piece3 = whole - piece1 - piece2;\n\t\tlong long int tmpans = min(piece1, piece3);\n\t\tans = max(ans, tmpans);\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\twhile(a[l1++]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t}\n\t\twhile(a[l2++]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t}\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tr++;\n\t\t\tsum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tvoid check();\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcout << min_value << endl;\n\texit(0);\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tif (memo[cut_b] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_b] > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\n\tset_value = set_board();\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\tlong long min_value;\n\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\tif (memo[cut_b] - memo[cut_a] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (memo[cut_c] - memo[cut_b] > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n\ntypedef long long lolo;\nint N, *A;\nlolo sum= 0, *sumA, allsum= 0, ans= 0, mini;\n\nint main(){\n\t\n\tcin>> N;\n\n\tA= new int[N];\n\tsumA= new lolo[N];\n\n\tfor(int i= 0; i< N; i++){\n\t\tcin>> A[i];\n\t\tallsum+= A[i];\n\t\tsumA[i]= allsum;\n\t}\n\tlolo div= allsum/ 3, fp1= 0, fp1num, fp2, fp2num, fp3, shiftsum= 0, com;\n\tfor(int c= 0; c< N; c++){\n\t\tif(c!= 0) shiftsum= sumA[c- 1];\n\t\tcom= 0;\n\t\tfor(int i= c; i< N+ c; i++){\n\t\t\tif(i< N) com= sumA[i]- shiftsum;\n\t\t\telse com+= A[i- N];\n\t\t\tif(com<= div){\n\t\t\t\tfp1= com;\n\t\t\t\tfp1num= i;\n\t\t\t}\n\t\t\telse if(com- fp1>= div){\n\t\t\t\tfp2= com- fp1;\n\t\t\t\tfp2num= i;\n\t\t\t\tfp3= allsum- (fp1+ fp2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmini= min(fp1, fp3);\n\t\tans= max(ans, mini);\n\t}\n\t\n\tcout<< ans<< endl;\n\n\tdelete[] A;\n\tdelete[] sumA;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstatic const int CUTNUMMAX = 100000;\n\n#define LOOP(x,n) ((x)==-1) ? ((n)-1) : ((x)%(n))\n\nint Shortestin3(int* l){\n\tif (l[0] <= l[1] && l[0] <= l[2])return 0;\n\tif (l[1] <= l[0] && l[1] <= l[2])return 1;\n\treturn 2;\n}\n\nint main(){\n\tint N;//バームクーヘンの切れ込みの数\n\tcin >> N;\n\tint A[CUTNUMMAX];//バームクーヘンの各片の長さ\n\tfor (int i = 0; i < N; ++i){\n\t\tcin >> A[i];\n\t}\n\n\tint Length[3] = {};//各分けられたバームクーヘンの長さ\n\tint Begin[3];//各分けられたバームクーヘンの起点のAの数値\n\tBegin[0] = 0; Begin[1] = int(N / 3); Begin[2] = int(N * 2 / 3);\n\tfor (int i = 0; i < Begin[1]; ++i){\n\t\tLength[0] += A[i];\n\t}\n\tfor (int i = Begin[1]; i < Begin[2]; ++i){\n\t\tLength[1] += A[i];\n\t}\n\tfor (int i = Begin[2]; i < N; ++i){\n\t\tLength[2] += A[i];\n\t}\n\n\tint SN = -1;//最小幅番号\n\tbool IsDoing = false;//追加却下判定\n\twhile (1){\n\t\tSN = Shortestin3(Length);\n\t\tIsDoing = false;\n\t\t//最小幅に次の一部を追加\n\t\tif (Length[SN] - (Length[LOOP(SN + 1, 3)] - A[Begin[LOOP(SN + 1, 3)]]) < 0){\n\t\t\tLength[SN] += A[Begin[LOOP(SN + 1, 3)]];\n\t\t\tLength[LOOP(SN + 1, 3)] -= A[Begin[LOOP(SN + 1, 3)]];\n\t\t\tBegin[LOOP(SN + 1, 3)] = LOOP(Begin[LOOP(SN + 1, 3)] + 1, N);\n\t\t\tIsDoing = true;\n\t\t}\n\t\t//最小幅に前の一部を追加\n\t\tif (Length[SN] - (Length[LOOP(SN - 1, 3)] - A[Begin[LOOP(SN - 1, 3)]]) < 0){\n\t\t\tLength[SN] += A[Begin[LOOP(SN - 1, 3)]];\n\t\t\tLength[LOOP(SN - 1, 3)] -= A[Begin[LOOP(SN - 1, 3)]];\n\t\t\tBegin[LOOP(SN - 1, 3)] = LOOP(Begin[LOOP(SN - 1, 3)] + 1, N);\n\t\t\tIsDoing = true;\n\t\t}\n\t\tif (!IsDoing)break;\n\t}\n\n\tcout << Length[SN] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint num_cut;\nvector<int> cuts;\nint sum;\nint oneThird;\n\nint searchMinCut(int start, int num, int rest){\n\tint thisCutSize = 0;\n\tif(num == 3){\n\t\tfor(int i=start; i<num_cut; i++){\n\t\t\tthisCutSize += cuts[i];\n\t\t}\n\t\tthisCutSize += rest;\n\t\treturn thisCutSize;\n\t}\n\t// set max size\n\tint thisMaxMin = 0;\n\tint nextCutMinMaxSize = 0;\n\tfor(int i=start; i<num_cut; i++){\n\t\tif(thisCutSize > oneThird) return thisMaxMin;\n\t\tthisCutSize += cuts[i];\n\t\tint nextMinSize = searchMinCut(i+1, num+1, rest);\n\t\tif(nextMinSize > thisCutSize){\n\t\t\tif(thisCutSize > thisMaxMin) thisMaxMin = thisCutSize;\n\t\t}else{\n\t\t\tif(nextMinSize > thisMaxMin) thisMaxMin = nextMinSize;\n\t\t}\n\t}\n\treturn thisMaxMin;\n}\n\nint main(){\n\tint min_piece=0;\n\tint a=0;\n\tint restCake=0;\n\tcin >> num_cut;\n\tfor(int i = 0; i < num_cut; i++){\n\t\tcin >> a;\n\t\tsum += a;\n\t\tcuts.push_back(a);\n\t}\t\n\toneThird = (sum + 2) / 3; \n\n\tfor(int first=0; restCake<=oneThird; first++){\n\t\tint nextMin = searchMinCut(first, 1, restCake);\n\t\tif(min_piece < nextMin) min_piece = nextMin;\n\t\trestCake += cuts[first];\n\t}\n\n\tcout << min_piece << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[200000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = InArray[0];\n\t\tfor(int a2 = a1 + 1; a2 < N + 1; a2++){\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tint average2 = (sum - a1_sum) / 2;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2 + 1; a3 < a1 + N; a3++){\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[200000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1 + 1; a2 < N + 1; a2++){\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tint average2 = (sum - a1_sum) / 2;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2 + 1; a3 < a1 + N; a3++){\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint get_sum(vector<int> array, int i, int j) {\n  int _sum = 0;\n  if (i < j) {\n    for (int l = i; l < j; l ++)\n      _sum += array[l];\n  } else {\n    for (int l = i; l < array.size(); l ++)\n      _sum += array[l];\n    for (int l = 0; l < j; l ++)\n      _sum += array[l];\n  }\n  return _sum;\n}\n\n\nint get_max_min(vector<int> array, int size) {\n  int i, j, k, _max, _min, left, center, right;\n  _min = 1000;\n  _max = -1;\n\n  // first point \n  for (i = 0; i < size - 2; i ++) {\n    // second point \n    for (j = i + 1; j < size - 1; j ++) {\n      // third point\n      for (k = j + 1; k < size; k ++) {\n        // calculate each size and get min\n        _min = get_sum(array, i, j);\n        _min = min(get_sum(array, j, k), _min);\n        _min = min(get_sum(array, k, i), _min);\n\n        // choose max\n        _max = max(_max, _min);\n      }\n    }\n  }\n  return _max;\n}\n\n\nint main() {\n  int i, n, t, _min, size;\n  vector<int> array;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> t;\n    array.push_back(t);\n  }\n\n  // calculate max\n  _min = get_max_min(array, n);\n\n  // output answer\n  cout << _min << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\t\n\tfor (p.end = p.top; p.end <= _end; p.end ++){\n\t\tif ((p.size = calcPieceSize(p)) >= min_piece_size) return p;\n\t}\n\n\tp.end --;\n\tp.size = -1;\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans = sum[N - 1] / 3;\n\n\twhile (!cutOK(ans)) ans--;\n\n\treturn ans;\n}\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\n\n\t\t\t//int ideal = ceil(double(sum - size) / 2.0);\n\t\t\t//int sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\t//int next = cuts[sep] - cuts[right];\n\t\t\t//int rem = sum - next - size;\n\n\t\t\t//int tmin = min({ next, rem, size });\n\t\t\t//ans = max(ans, tmin);\n\t\t\tint tmin = 0;\n\t\t\trep(k, n)\n\t\t\t{\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[200005];\n\nbool check(int x,ll key){\n  ll* p=&a[x];\n  ll* ed=&a[x+n+1];\n  \n  for(int i=0;i<3;i++){\n    ll target=*p;\n    p=lower_bound(p,ed,target+key);\n    if(p==ed)return false;\n  }  \n  return true;\n}\n\nll solve(int x){\n  ll L=1,R=1e9+1,M;\n  while(L<R){\n    M=(L+R)/2;\n    if(check(x,M))L=M+1;\n    else R=M;\n  }\n  return L-1;\n}\n\nint main(){\n  cin>>n;\n  for(int i=1;i<=n;i++)cin>>a[i];\n  for(int i=n+1;i<=n+n;i++)a[i]=a[i-n];\n\n  for(int i=1;i<=n+n;i++)a[i]+=a[i-1];\n  \n  ll ans=0;\n  for(int i=0;i<n;i++)ans=max(ans,solve(i));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\ts1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\tt = *lower_bound(a, a+MAX, s2+m);\n\t\t\n\t\tif(total-(s2-sum) >= m)return 0;\n\t\telse{\n\t\t\tr++;sum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll in[200000];\nll ruisekiwa[200001];\nll over;\n\nll getmin(int l, int r) {\n\tll a, b, c, ans = 0;\n\ta = ruisekiwa[r] - ruisekiwa[l];\n\tb = *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tc = ruisekiwa[l + N] - *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tans = max(ans, min(a, min(b, c)));\n\tb = *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\tc = ruisekiwa[l + N] - *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\tans = max(ans, min(a, min(b, c)));\n\treturn ans;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t\tin[N + i] = in[i];\n\t}\n\tfor (int i = 1; i <= N * 2; i++) {\n\t\truisekiwa[i] = ruisekiwa[i - 1] + in[i - 1];\n\t}\n\n\tll ans = 0;\n\tover = (ruisekiwa[N] - ruisekiwa[0]) / 3;\n\tfor (int l = 0, r = 0;(l < N); l++) {\n\t\tfor (; ruisekiwa[r] - ruisekiwa[l] < over; r++)ans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r + 1));\n\t\tans = max(ans, getmin(l, r));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[200001];\n\nbool check(long long x)\n{\n\tint l = 0, r = 1;\n\tfor (; r <= n; r++){\n\t\tif (a[r] - a[l] < x) continue;\n\t\twhile (a[r] - a[l + 1] >= x) l++;\n\t\t\n\t\tint tail = l + n;\n\t\tint mid = lower_bound(a + l + 1, a + tail + 1, (a[r] - a[l]) * 2 + a[l]) - a;\n\t\t\n\t\tif (mid == tail + 1) continue;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\", l, r, mid, tail);\n\t\t\n\t\tif (\n\t\t\tr != mid &&\n\t\t\tmid != tail &&\n\t\t\ttail - n != l + 1 &&\n\t\t\ta[mid] - a[r] >= a[r] - a[l] &&\n\t\t\ta[tail] - a[mid] >= a[r] - a[l]\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\t\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\t\n\tlong long l = 0, r = 1000000000LL * 100000LL;\n\twhile (l <= r){\n\t\tlong long mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\t\n\tprintf(\"%lld\\n\", r);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\n#ifndef  LLONG_MAX\n#define LLONG_MAX 9223372036854775807\n#endif\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left > 2) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n + n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint num_cut = 0;\nlong long  sum = 0L;\nlong long  oneThird = 0L;\nint cuts[100000];\n\nlong long  searchMinCut(int start, int num, long long rest){\n\tlong long thisCutSize = 0L;\n\tlong long  thisMaxMin = 0L;\n  long long  nextCutMinMaxSize = 0L;\n\tlong long nextMinSize = 0L;\n\n\tif(num == 3){\n\t\tfor(int i=start; i<num_cut; i++){\n\t\t\tthisCutSize += cuts[i];\n\t\t}\n\t\tthisCutSize += rest;\n\t\treturn thisCutSize;\n\t}\n\n\tfor(int i=start; i<num_cut; i++){\n\t\tif(thisCutSize > oneThird) return thisMaxMin;\n\t\tthisCutSize += cuts[i];\n\t\tnextMinSize = searchMinCut(i+1, num+1, rest);\n\t\tif(nextMinSize > thisCutSize){\n\t\t\tif(thisCutSize > thisMaxMin) thisMaxMin = thisCutSize;\n\t\t}else{\n\t\t\tif(nextMinSize > thisMaxMin) thisMaxMin = nextMinSize;\n\t\t}\n\t}\n\treturn thisMaxMin;\n}\n\nint main(){\n\tlong long min_piece=0L;\n\tint a=0;\n\tlong long restCake=0L;\n\n\tcin >> num_cut;\n\tfor(int i = 0; i < num_cut; i++){\n\t\tcin >> a;\n\t\tsum += a;\n\t\tcuts[i] = a;\n\t}\t\n\toneThird = (sum + 2) / 3;\n\tfor(int first=0;restCake < oneThird; first++){\n\t\tlong long nextMin = searchMinCut(first, 1, restCake);\n\t\tif(min_piece < nextMin) min_piece = nextMin;\n\t\trestCake += cuts[first];\n\t}\n\n\tcout << min_piece << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine()\n\t\t\tA[i] = Integer.perseInt(str)//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=1;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\twhile (a<=ans){\n\t\t\tt++;\n\t\t\ta+=A[(t-1)%N];\n\t\t}\n\t\t//aがansを更新できるか\n\t\tauto p=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\tif (p!=sum+s+N){\n\t\t\t//見つかった\n\t\t\tb=*p-sum[t-1];\n\t\t\tc=sum[N-1]-b-a;\n\t\t\tif (c>=a){\n\t\t\t\t//aが最小値\n\t\t\t\tans=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans=max(ans,c);\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<long long int> v;\nlong long int ans;\nlong long int s;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tv.push_back(0);\n\tfor(int i=0; i<n; i++){\n\t\tlong long int t;\n\t\tscanf(\"%lld\", &t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<n+1; i++) v.push_back(v[i]);\n\tfor(int i=1; i<v.size(); i++) v[i] += v[i-1];\n\n//\tfor(int i=0; i<v.size(); i++) printf(\"%lld\\n\", v[i]);\n\tfor(int i=0; i<n; i++){\n\t\t\n\t\tint j = upper_bound(v.begin(), v.end(), v[i] + v[n]/3)-v.begin();\n\t\tint k = upper_bound(v.begin(), v.end(), (v[j] + v[i+n])/2)-v.begin();\n\t\tint l = lower_bound(v.begin(), v.end(), (v[j] + v[i+n])/2)-v.begin();\n/*\t\tprintf(\"%d %d %d %d\\n\", i, j, k, l);\n\t\tprintf(\"%lld %lld %lld %lld\\n\", v[i], v[j], v[k], v[l]);\n*/\t\tans = max(ans, min(v[j] - v[i], min(v[k] - v[j], v[n] + v[i] - v[k])));\n\t\tans = max(ans, min(v[j] - v[i], min(v[l] - v[j], v[n] + v[i] - v[l])));\n//\t\tif(ans == 5) printf(\"%d %d %d\\n\", i, j, k);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tif (N < DevideNum){\n\t\tcout << \"0\" << endl;\n\t\texit(1);\n\t}\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, (piece[0].top) % N + N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / DevideNum;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_max)) ? ans_max : ans_min;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N;\nbool func(long long mid, vector<long long>&line) {\n\tint lp = 0, hp = 1;\n\twhile (true) {\n\t\tif (line[hp] - line[lp] >= mid) {/*\n\t\t\tint fp = hp + 1;\n\t\t\tint bp = lp + N;\n\t\t\twhile (fp < bp) {\n\t\t\t\tint mp = (fp + bp) >> 1;\n\t\t\t\tif (line[mp] - line[hp+1] >= mid) {\n\t\t\t\t\tif (line[lp + N] - line[mp] >= mid) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbp = mp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfp = mp + 1;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tint it = lower_bound(line.begin() + hp + 1, line.begin() + lp + N, mid + line[hp])-line.begin();\n\t\t\tif (line[lp + N] - line[it] >= mid) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t++lp;\n\t\t}\n\t\telse {\n\t\t\t++hp;\n\t\t\tif (hp == N - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> N;\n\tvector<long long> line(N+1);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcin >> line[i];\n\t\tline.push_back(line[i]);\n\t}\n\tline[0] = 0;\n\tfor (int i = 1; i < line.size(); ++i) {\n\t\tline[i] = line[i] + line[i - 1];\n\t}\n\tlong long lp = 0, hp = INT64_MAX;\n\twhile (lp < hp) {\n\t\tlong long mid = (lp + hp) >> 1;\n\t\tif (func(mid, line)) {\n\t\t\tlp = mid+1;\n\t\t}\n\t\telse {\n\t\t\thp = mid;\n\t\t}\n\t}\n\tcout << lp - 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(x,y) for(int x=0;x<(y);x++)\n\ntypedef long long ll;\n\nint N;\nll A[100005];\n\nint main(){\n  scanf(\"%d\", &N);\n  rep(i,N) scanf(\"%lld\", &A[i+1]);\n  rep(i,N) A[i+1] += A[i]; A[N+1] = A[N];\n  ll res = 0;\n\n  rep(i,N){\n    while(1){\n      ll *j = upper_bound(A, A+N+1, A[i]+res);\n      ll x = *j-A[i];\n      ll *k = upper_bound(A, A+N+1, A[i]+x+res);\n      ll y = *k-*j;\n      ll z = A[N]-*k+A[i];\n      if(x > res && y > res && z > res){\n\tres = min(x,min(y,z));\n      }else{\n\tbreak;\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200000];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i < 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100010);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    \n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  REP(i, n) scanf(\"%lld\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  while(l+1<r){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 20000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 20000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nint n;\nint a[200001];\nint sum[200001];\n\nbool bin_check(int x) {\n\n    int p1 = 0, p2 = 0;\n    int sum1 = 0, sum2 = 0;\n\n    // Shakutori\n    for(int i = 0; i < n; ++i) {\n\n        // 1\n        while(sum1 < x) {\n            sum1 += a[p1];\n            if(p1 < p2) sum2 -= a[p1];\n            ++p1;\n        }\n\n        // 2\n        if(!i) p2 = p1;\n        while(sum2 < x) {\n            sum2 += a[p2];\n            ++p2;\n        }\n\n        // 3\n        if(sum[n + i] - sum[p2] >= x) {\n            return true;\n        }\n\n        sum1 -= a[i];\n    }\n\n    return false;\n\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        a[n + i] = a[i];\n    }\n\n    sum[0] = 0;\n    for(int i = 1; i <= 2 * n; ++i) {\n        sum[i] = sum[i - 1] + a[i - 1];\n    }\n\n    int l = 0, m, r = sum[n + n] / 3;\n    while(l < r - 1) {\n        m = (l + r) / 2;\n        if(bin_check(m)) {\n            l = m;\n        } else {\n            r = m - 1;\n        }\n    }\n\n    cout << l << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define filein(t) freopen(t, \"r\", stdin)\n#define fileout(t) freopen(t, \"w\", stdout)\n#define f first\n#define s second\n#define cs 137\n#define ll long long\n#define mp make_pair\n#define NN 505\n#define N 10005\n#define oo 1000000007\n#define ln 1000000009\n\nusing namespace std;\n\nll S[N], ans;\nint n, a[N];\n\nll Get(int F, int i, int j)\n{\n    int L = i-1;\n    int R = j;\n    while(R - L > 1)\n    {\n        int X = (L + R) / 2;\n        if(S[X] * 2 <= S[i-1] + S[j])  L = X;\n        else R = X;\n    }\n    return min(S[i-1] - S[F-1], max(min(S[L] - S[i-1], S[j] - S[L]), min(S[R] - S[i-1], S[j] - S[R])));\n}\n\nll Solve(int i)\n{\n    int L = i;\n    int R = i + n - 1;\n    for(int j=1; j<=20; j++)\n    {\n        int X = (L + R) / 2;\n        if(Get(i, X, i+n-1) > Get(i, X+1, i+n-1))   R = X;\n        else L = X+1;\n    }\n    return Get(i, L, i+n-1);\n}\n\nint main()\n{\n    //filein(\"inp.txt\");  fileout(\"out.txt\");\n    cin >> n;\n    for(int i=1; i<=n; i++)\n        cin >> a[i], a[i+n] = a[i];\n    for(int i=1; i<=2*n; i++)\n        S[i] = S[i-1] + a[i];\n    for(int i=1; i<=n; i++)\n        ans = max(ans, Solve(i));\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VL a(n);\n    REP(i,n) scanf(\"%lld\", &a[i]);\n    ll s = 0;\n    REP(i,n){\n        s += a[i];\n        a.push_back(a[i]);\n    }\n    ll l = 1, r = s/3;\n    while (r - l > 1){\n        ll m = (l + r) / 2;\n        bool pos = 0;\n        REP(i,n){\n            int x = i, p = 0;\n            ll t = 0;\n            while (x < i + n){\n                t += a[x];\n                x++;\n                if (t >= m){\n                    t = 0;\n                    p++;\n                }\n                if (p == 3){\n                    pos = 1;\n                    break;\n                }\n            }\n        }\n        if (pos) l = m;\n        else r = m;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\null PickLargestMinimumPiece(const ull _total_size, const ull _piece1_s, const ull _piece1_l, const ull _piece3_s, const ull _piece3_l){\n\tull tmp = min(_piece1_s, _piece3_s);\n\t\n\tull piece2 = _total_size - _piece1_s - _piece3_l;\n\ttmp = max(tmp, min(_piece1_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_s;\n\ttmp = max(tmp, min(_piece3_s, piece2));\n\n\tpiece2 = _total_size - _piece1_l - _piece3_l;\n\ttmp = max(tmp, piece2);\n\n\treturn tmp;\n}\n\nvoid CalcPiece1(int *_i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; *_i2 < _i1 + _N - 2;){\n\t\t_piece1_s = _piece1_l;\n\t\t*_piece1_l += _A[(*_i2)%_N];\n\t\t(*_i2)++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n}\n\nint CalcPiece1(int _i2, ull *_piece1_s, ull *_piece1_l, const int _i1, const int _N, const ull _one_third_size, const int *_A){\n\tfor (; _i2 < _i1 + _N - 2;){\n\t\t_piece1_s = _piece1_l;\n\t\t*_piece1_l += _A[_i2%_N];\n\t\t_i2++;\n\t\tif (*_piece1_l > _one_third_size) break;\n\t}\n\treturn _i2;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\tdelete[] A;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tCalcPiece1(&i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\t//i2 = CalcPiece1(i2, &piece1_s, &piece1_l, i1_ini, N, one_third_size, A);\n\tconst int i1_fin = i2;\n\n\tint i3 = i2;\n\tull piece3_s = total_size - piece1_l;\n\tull piece3_l = 0;\n\tfor (; i3 < i1_ini + N - 1;){\n\t\tpiece3_l = piece3_s;\n\t\tpiece3_s -= A[i3%N];\n\t\ti3++;\n\t\tif (piece3_s <= one_third_size) break;\n\t}\n\n\tanswer = PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l);\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse{\n\t\t\tfor (; i2 < i1 + N - 2;){\n\t\t\t\tpiece1_s = piece1_l;\n\t\t\t\tpiece1_l += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif (piece1_l > one_third_size) break;\n\t\t\t}\n\t\t\t//CalcPiece1(&i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\t\t\t//i2 = CalcPiece1(i2, &piece1_s, &piece1_l, i1, N, one_third_size, A);\n\t\t}\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse{\n\t\t\tfor (; i3 < i1 + N - 1;){\n\t\t\t\tpiece3_l = piece3_s;\n\t\t\t\tpiece3_s -= A[i3%N];\n\t\t\t\ti3++;\n\t\t\t\tif (piece3_s <= one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tanswer = max(answer, PickLargestMinimumPiece(total_size, piece1_s, piece1_l, piece3_s, piece3_l));\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3*N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <3*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n\t\tprintf(\"c = %d\\n\", c);\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N)break;\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\n\tlong long int whole = 0; //バームクーヘンの大きさ\n\tint* A = new int[N];\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\twhole += (long long int)A[i];\n\t}\n\n\tlong long int one_third = whole / 3;\n\n\tint i = 0;\n\tlong long int piece1 = 0;\n\twhile (piece1 + (long long int)A[i] <= one_third){\n\t\tpiece1 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t}\n\t\n\tint piece2_i = i;\n\tlong long int piece2 = 0;\n\twhile (1){\n\t\tpiece2 += (long long int)A[i];\n\t\ti++;\n\t\tif (i == N) i -= N; //周期的境界条件\n\t\tif (piece2 >= piece1) break;\n\t}\n\t\n\tint piece3_i = i;\n\tlong long int piece3 = whole - piece1 - piece2;\n\tlong long int ans = min(piece1, piece3);\n\n\tfor (int i = 1; i < N; i++){\n\t\tif (piece1 == 0){\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t}\n\t\telse piece1 -= (long long int)A[i-1];\n\n\t\twhile (piece1 + (long long int)A[piece2_i] <= one_third){\n\t\t\tpiece1 += (long long int)A[piece2_i];\n\t\t\tpiece2 -= (long long int)A[piece2_i];\n\t\t\tpiece2_i++;\n\t\t\tif (piece2_i == N) piece2_i -= N; //周期的境界条件\n\t\t}\n\n\t\twhile (piece2 < piece1){\n\t\t\tpiece2 += (long long int)A[piece3_i];\n\t\t\tpiece3_i++;\n\t\t\tif (piece3_i == N) piece3_i -= N; //周期的境界条件\n\t\t}\n\n\t\tpiece3 = whole - piece1 - piece2;\n\t\tans = max(ans, min(piece1, piece3));\n\t}\n\n\tcout << ans << endl;\n\n\tdelete[] A;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n#define debug 0\n\nlong InArray[200000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n#if debug\n\tFILE *inputFile = fopen(\"0600_in33.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tint temp;\n\t\tfscanf(inputFile, \"%d\", &temp);\n\t\tcout << temp << \"\\t\";\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\tcout << endl;\n\tfclose( inputFile);\n#else\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n#endif\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\n#if debug\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n#endif\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1 + 1; a2 < N + 1; a2++){\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tint average2 = (sum - (a1_sum - InArray[a2])) / 2;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2 + 1; a3 < a1 + N; a3++){\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3 - 1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(p3, p1 + N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n#if debug\n//cout << \"getLocalMin(\" << p1 << \", \" << p2 << \", \" << p3 << \") = \" << LocalMin << endl;\n#endif\n\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n;\nlong long sum[110000];\n\nbool Func(long long key){\n\n\tfor(int i=1;i<n;i++){\n\n\t\tlong long* f=lower_bound(sum+i,sum+n+1,key+sum[i-1]);\n\t\tlong long* g=lower_bound(f,sum+n+1,key+*f);\n\n\t\tif(*g&&*g+key-sum[i-1]<=sum[n]){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tcin>>n;\n\tsum[0]=0;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin>>sum[i+1];\n\t\tsum[i+1]+=sum[i];\n\t}\n\n\tlong long left=0,right=sum[n]/3+1,mid;\n\tlong long ans=0;\n\n\twhile(left<right){\n\n\t\tmid=(left+right)/2;\n\n\t\tif(Func(mid)){\n\t\t\tleft=mid+1;\n\t\t\tans=max(ans,mid);\n\t\t}\n\t\telse right=mid;\n\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long sum_baum;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tint tripartition();\t//\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\n\tlong long full_search();\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\n\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n}\n\nint baumkuchen::tripartition(){\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tsum += A[N];\n\t}\n\treturn sum;\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[N];\n\n\tset = true;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\tsum_baum += A[i];\n\t}\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value=0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->full_search()<<endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main(){\n    int N;\n    while(cin >> N) {\n        vector<LL> A(2 * N);\n        REP(i, N) cin >> A[i];\n        REP(i, N) A[N + i] = A[i];\n        vector<LL> cum(A.size() + 1);\n        REP(i, A.size()) cum[i + 1] = cum[i] + A[i];\n        \n        LL S = cum[N];\n\n        LL ans = 0;\n        for(int i = 0, j = 0; i < N; i++) {\n            while(cum[j + 1] - cum[i] < S / 3) {\n                j++;\n            }\n            // A[i] + ... + A[j - 1] < S / 3, \n            // A[i] + ... + A[j] >= S / 3\n            for(int l = j - i - 3; l <= j - i + 3; l++) if(l >= 1 && N - l >= 2) {\n                int k = i + l;\n                // A[i, k) + A[k, i + N)\n                int lb = 0, ub = N - l; // \n                while(ub - lb > 1) {\n                    int mid = (lb + ub) / 2;\n                    if(cum[k + mid] - cum[k] < S / 3) {\n                        lb = mid;\n                    } else {\n                        ub = mid;\n                    }\n                }\n                for(int m = lb - 3; m <= lb + 3; m++) if(m >= 1 && N - l - m >= 1) {\n                    LL S1 = cum[i + l] - cum[i];\n                    LL S2 = cum[i + l + m] - cum[i + l];\n                    LL S3 = cum[i + N] - cum[i + l + m];\n                    ans = max(ans, min({S1, S2, S3}));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\tlong long check();\n\tbool check_bool;\n\n\tvoid memo_all_piece();\n\tlong long set_board();\n\tint cut_b;\n\tint cut_c;\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n\tcheck_bool = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3 * N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t}\n\n\tmemo_all_piece();\n\n\tset = true;\t//セットの判定\n}\n\nvoid baumkuchen::memo_all_piece(){\n\tfor (int i = 1; i < 3 * N; i++){\n\t\tmemo[i] = memo[i - 1] + A[i - 1];\n\t}\n\tsum_baum = memo[N];\t//バウムクーヘンの和\n\ttripartition = sum_baum / 3.0;\t//バウムクーヘンの和の三分の一\n}\n\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1 > cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nlong long baumkuchen::check(){\n\tlong long min_value;\n\tdouble half = 0.0 + sum_baum;\n\thalf += memo[cut_b] / 2.0;\n\t\n\tcut_b = N;\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\n\tif (memo[cut_b] - memo[cut_b - 1] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_c] - memo[cut_b] > (sum_baum + memo[cut_b - 1]) - memo[cut_c]) min_value = (sum_baum + memo[cut_b - 1]) - memo[cut_c];\n\n\tcheck_bool = true;\n\treturn min_value;\n}\n\n\nlong long baumkuchen::set_board(){\n\tlong long min_value;\n\n\tcut_b = 0;\n\twhile (tripartition > memo[cut_b])cut_b++;\n\tif (tripartition - memo[cut_b - 1] < memo[cut_b] - tripartition)cut_b--;\n\n\n\tdouble half = 0.0 + memo[cut_b];\n\thalf += (sum_baum - memo[cut_b]) / 2.0;\n\n\tcut_c = cut_b;\n\twhile (half > memo[cut_c])cut_c++;\n\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\tif (memo[cut_b] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\tif (memo[cut_b] > sum_baum - memo[cut_c]) min_value = sum_baum - memo[cut_c];\n\t\n\tif (cut_b == N - 1) return check();\n\n\treturn min_value;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long set_value = 0;\n\n\tset_value = set_board();\n\tif (check_bool)return set_value;\n\tfor (int cut_a = 1; cut_a < N; cut_a++){\n\t\tlong long min_value;\n\n\t\twhile (memo[cut_a] + tripartition > memo[cut_b])cut_b++;\n\t\tif (memo[cut_a] + tripartition - memo[cut_b - 1] < memo[cut_b] - (memo[cut_a]+ tripartition))cut_b--;\n\n\t\tdouble half = 0.0 + memo[cut_b];\n\t\thalf += (memo[N + cut_a] - memo[cut_b]) / 2.0;\n\n\t\twhile (half > memo[cut_c])cut_c++;\n\t\tif (half - memo[cut_c - 1] < memo[cut_c] - half)cut_c--;\n\n\t\tif (memo[cut_b] - memo[cut_a] > memo[cut_c] - memo[cut_b]) min_value = memo[cut_c] - memo[cut_b];\n\t\tif (memo[cut_c] - memo[cut_b] > memo[N + cut_a] - memo[cut_c]) min_value = memo[N + cut_a] - memo[cut_c];\n\t\t\n\t\tif (set_value < min_value)set_value = min_value;\n\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tif(0){\n\t\tFILE *inputFile = fopen(\"0600_in3.txt\", \"r\");\n\t\tfscanf(inputFile, \"%d\", &N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t\t}\n\t\tfclose( inputFile);\n\t} else {\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t}\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a3_sum, a1_sum, a2_sum;\n\t\n\ta3_sum = InArray[0];\n\tfor(int a1 = 0;;a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta3_sum += InArray[a1];\n\t\tif(a3_sum > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\t/*s1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\tt = *lower_bound(a, a+MAX, s2+m);\n\t\tif(m == 216)printf(\"%lld %lld %lld %lld\\n\", s1, s2, t, total+sum-s2);*/\n\t\twhile(a[l1++]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t\t//l1++;\n\t\t}\n\t\twhile(a[l2++]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t\t//l2++;\n\t\t}\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tr++;\n\t\t\tsum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>#include<vector>#include<algorithm>#include<string>#define rep(i,n) for(int i=0;i<(int)(n);i++)using namespace std;int n;vector<long long > rui;bool check(int i,long long m){    vector<long long >::iterator hoge=rui.end();    hoge = lower_bound(rui.begin() + i, rui.begin() +n-1+ i, m+rui[i]-1);    if (hoge == rui.end())return false;    vector<long long >::iterator hage = rui.end();    hage = lower_bound(hoge, rui.begin() + n - 1 + i, m + *hoge);    if (hage == rui.end())return false;    if (*(rui.begin() + n - 1 + i) - (*hage) >= m)return true;    return false;}int main(){    cin >> n;    rep(i, n)    {        long long int x;        cin >> x;        (i == 0) ? rui.push_back(x) : rui.push_back(rui[i - 1] + x);    }    rep(i, n)(i == 0) ? rui.push_back(rui[0] + rui[n - 1]) : rui.push_back(rui[n - 1 + i] + rui[i] - rui[i - 1]);    long long int ans = 0;    rep(i, n)    {        long long l = 0;        long long r = 500000000000000000;        while (r != l)        {            long long int m = (l + r) / 2;            if (check(i, m))            {                l = m+1;            }            else            {                r = m;            }        }        ans = max(ans, l);    }    cout << ans << endl;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector< long long int > rui;\nvector<long long int > kasu;\nint n;\n\nbool check2(int i,long long int now,long long int m)\n{\n\tif(rui[now]-rui[i]>=m)return true;\n\treturn false;\n}\n\nbool check(int i,long long int m)\n{\n\tlong long int r=i;\n\tlong long int l=i+n-1;\n\twhile(r!=l)\n\t{\n\t\tlong long int now=(r+l)/2;\n\t\t\n\t\tif(check2(i,now,m))\n\t\t{\n\t\t\tl=now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr=now+1;\n\t\t}\n\t}\n\tint hoge=l;\n\tl=i+n-1;\n\twhile(r!=l)\n\t{\n\t\tlong long int now=(r+l)/2;\n\t\tif(check2(hoge,now,m))\n\t\t{\n\t\t\tl=now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr=now+1;\n\t\t}\n\t}\n\tif(rui[n+i-1]-rui[r]>=m)return true;\n\treturn false;\n\t\n\t\n}\n\n\n\nint main ()\n{\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tkasu.push_back(x);\n\t\t(i==0)?rui.push_back(x):rui.push_back(rui[i-1]+x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[n+i-1]+kasu[i]);\n\t}\n\tlong long int ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long int r=0;\n\t\tlong long int l=5000000;\n\t\twhile(r!=l)\n\t\t{\n\t\t\tlong long int m=(r+l)/2;\n\t\t\t\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tl=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr=m+1;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,r);\n\t}\n\tcout<<ans<<endl;\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n;\nvector<int>a(200003);\nvector<int>::iterator it,it2;\nbool ch(int mid){\n  r(i,n){\n    int p=(i==0?0:a[i-1]);\n    it=lower_bound(a.begin(),a.begin()+i+n,mid+p);\n    it2=lower_bound(a.begin(),a.begin()+i+n,mid+(*(it)));\n    if((*(a.begin()+i+n-1))-(*(it2))>=mid)return 1;\n  }\n  return 0;\n}\nmain(){\n  cin>>n;\n  r(i,n){\n    cin>>a[i];\n    a[i+n]=a[i];\n  }\n  r(i,n*2)a[i+1]+=a[i];\n  int l=0,r=1e17;\n  while(l<r){\n    int mid=(l+r)/2;\n    if(!ch(mid))r=mid;\n    else l=mid+1;\n  }\n  cout<<l-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint n;\n\n\nbool solve(ll mid,vector<ll> rsum){\n    rep(i,n+1){\n        ll start = rsum[i];\n        \n        int a=lower_bound(all(rsum),start  +mid)-rsum.begin();\n        if(a>=i+n+1)continue;\n        \n        int b=lower_bound(all(rsum),rsum[a]+mid)-rsum.begin();\n        if(b>=i+n+1)continue;\n        \n        int c=lower_bound(all(rsum),rsum[b]+mid)-rsum.begin();\n        if(c>=i+n+1)continue;\n        \n        return true;\n    }\n    return false;\n\n}\n\n\nint main(){\n    ll sum=0;\n    cin>>n;\n    vector<ll> vec(n);\n    rep(i,n){\n        cin>>vec[i];\n        sum += vec[i];\n    }\n\n    vector<ll> rsum(2*n+1,0);\n    rep(i,2*n)rsum[i+1] = rsum[i]+vec[i%n];\n\n    \n    ll left=0, right=rsum[n+1], mid=(left+right)/2LL;\n    while(left+1<right){\n        bool res = solve(mid,rsum);\n        \n        if(res) left = mid;\n        else    right= mid;\n        \n        mid = (left+right)/2LL;\n    }\n    cout<<mid<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint n;\nll a[200010];\nll s[200010];\n\nbool cond(ll x)\n{\n\tint p0 = 0, p1 = 0, p2 = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tp2 = i + n;\n\t\twhile (p0 < p2 && s[p0] - s[i] < x) p0++;\n\t\twhile (p1 < p2 && s[p1] - s[p0] < x) p1++;\n\t\tll s0 = s[p0] - s[i];\n\t\tll s1 = s[p1] - s[p0];\n\t\tll s2 = s[p2] - s[p1];\n\t\tif (min({s0, s1, s2}) >= x) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld\", a + i);\n\t\ta[i + n] = a[i];\n\t}\n\n\tfor (int i = 0; i < 2 * n; i++){\n\t\ts[i + 1] = s[i] + a[i];\n\t}\n\n\tll lb = 0, ub = 1e15;\n\twhile (ub - lb > 1){\n\t\tll md = (lb + ub) / 2;\n\t\t(cond(md) ? lb : ub) = md;\n\t}\n\n\tprintf(\"%lld\\n\", lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tcin >> inputBuffer;\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1 << 30;\nvector<long long int> baum;\nlong long int n, ans, minma = INF;\nlong long int Baum = 0, Baum3 = 0;\n\nvoid cut(long long int f) {\n\tlong long int s = f + Baum3, t = s + Baum3;\n\tlong long int p;\n\tlong long int sp[3] = {}, tp[3] = {};\n\tp = lower_bound(baum.begin(), baum.end(), s) - baum.begin();\n\tif (s == baum[p]) {\n\t\tsp[0] = baum[p + 1];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = baum[p];\n\t}\n\telse {\n\t\tsp[0] = baum[p];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = INF;\n\t}\n\tp = lower_bound(baum.begin(), baum.end(), t) - baum.begin();\n\tif (t == baum[p]) {\n\t\ttp[0] = baum[p + 1];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = baum[p];\n\t}\n\telse {\n\t\ttp[0] = baum[p];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = INF;\n\t}\n\tfor (int i = 0; i <= 2; i++) {\n\t\tif (sp[i] == INF) break;\n\t\tminma = sp[i] - f;\n\t\tfor (int j = 0; j <= 2;j ++){\n\t\t\tif (tp[j] == INF) break;\n\t\t\tminma = min( minma, min( tp[j] - sp[i], Baum - tp[j] + f ));\n\t\t\tans = max(ans, minma);\n\t\t\tminma = sp[i]-f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tbaum.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint in;\n\t\tscanf(\"%d\", &in);\n\t\tBaum += in;\n\t\tbaum.push_back(in);\n\t}\n\tbaum.push_back(baum[1]);\n\tBaum3 = Baum / 3;\n\n\tfor (int i = 2; i <= n+1; i++) {\n\t\tbaum[i] += baum[i - 1];\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tif (baum[i] > Baum3) break;\n\t\tcut(baum[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tif(1){\n\t\tFILE *inputFile = fopen(\"0600_in33.txt\", \"r\");\n\t\tfscanf(inputFile, \"%d\", &N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t\t}\n\t\tfclose( inputFile);\n\t} else {\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t}\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a3_sum, a1_sum, a2_sum;\n\t\n\ta3_sum = InArray[0];\n\tfor(int a1 = 0; a3 < N-1; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta3_sum += InArray[a1];\n\t\tif(a3_sum > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nint n;\nint a[200001];\nint sum[200001];\n\nbool bin_check(int x) {\n\n    int p1 = 0, p2 = 0;\n    int sum1 = 0, sum2 = 0;\n\n    // Shakutori\n    for(int i = 0; i < n; ++i) {\n\n        // 1\n        while(p1 < n + i && sum1 < x) {\n            sum1 += a[p1];\n            if(p1 < p2) sum2 -= a[p1];\n            ++p1;\n        }\n\n        // 2\n        if(!i) p2 = p1;\n        while(p2 < n + i && sum2 < x) {\n            sum2 += a[p2];\n            ++p2;\n        }\n\n        // 3\n        if(sum[n + i] - sum[p2] >= x) {\n            return true;\n        }\n\n        sum1 -= a[i];\n    }\n\n    return false;\n\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        a[n + i] = a[i];\n    }\n\n    sum[0] = 0;\n    for(int i = 1; i <= 2 * n; ++i) {\n        sum[i] = sum[i - 1] + a[i - 1];\n    }\n\n    int l = 0, m, r = sum[n] / 3;\n    while(l + 1 < r) {\n        m = (l + r) / 2;\n        if(bin_check(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n        //cout << l << \" \" << r << endl;\n    }\n\n    cout << l << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll MAX=1e14;\nint n;\nll a[100100],cnt;\nvector<ll> sum;\nbool ok(ll x){\n\tint fir=*lower_bound(ALL(sum),x);\n\tint sec=*lower_bound(ALL(sum),fir+x);\n\tint thi=*lower_bound(ALL(sum),sec+x);\n\tif(thi<=cnt)return true;\n\tREP(i,n){\n\t\tfir=*lower_bound(ALL(sum),sum[i]+x);\n\t\tsec=*lower_bound(ALL(sum),fir+x);\n\t\tthi=*lower_bound(ALL(sum),sec+x);\n\t\tif(thi<=a[i]+cnt)return true;\n\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tcnt+=a[i];\n\t}\n\tsum.resize(n*2);\n\tREP(i,n*2){\n\t\tif(i==0){\n\t\t\tsum[i]=a[i];\n\t\t}else{\n\t\t\tsum[i]=sum[i-1]+a[i%n];\n\t\t}\n\t}\n\tsum.PB(MAX+1);\n\tll lb=0,rb=cnt;\n\twhile(rb-lb>1){\n\t\tll mid=(rb+lb)/2;\n\t\tif(ok(mid)){\n\t\t\tlb=mid;\n\t\t}else{\n\t\t\trb=mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",lb);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[4*N];\n\tmemo = new long long[4* N * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <4*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"i = %d\\t\", i);\n//\t\tprintf(\"c = %d\\n\\n\", c);\n\t\t\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N || c == 2*N || c== 3*N)break;\n\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a ;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nint n;\nint a[200001];\nint sum[200001];\n\nbool bin_check(int x) {\n\n    int p1 = 0, p2 = 0;\n    int sum1 = 0, sum2 = 0;\n\n    // Shakutori\n    for(int i = 0; i < n; ++i) {\n\n        // 1\n        while(sum1 < x) {\n            sum1 += a[p1];\n            if(i) sum2 -= a[p1];\n            ++p1;\n        }\n\n        // 2\n        if(!i) p2 = p1;\n        while(sum2 < x) {\n            sum2 += a[p2];\n            ++p2;\n        }\n\n        // 3\n        if(sum[n + i] - sum[p2] >= x) {\n            return true;\n        }\n\n        sum1 -= a[i];\n    }\n\n    return false;\n\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        a[n + i] = a[i];\n    }\n\n    sum[0] = 0;\n    for(int i = 1; i <= 2 * n; ++i) {\n        sum[i] = sum[i - 1] + a[i - 1];\n    }\n\n    int l = 0, m, r = sum[n + n] / 3;\n    while(l < r - 1) {\n        m = (l + r) / 2;\n        if(bin_check(m)) {\n            l = m;\n        } else {\n            r = m - 1;\n        }\n    }\n\n    cout << l << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\tSystem.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();\n\t\t\t\n\t\t\t//*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input33.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tsw.Start();\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\n\t\t\tsw.Stop();\n\t\t\tConsole.WriteLine(sw.ElapsedMilliseconds);\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tlong interm_maxV = -1;\n\t\t\tint n0_max = findIndex(0, N, tripartition)[0];\n\t\t\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = findIndex(n0, N, tripartition + v_list[n0]);\n\t\t\tint[] n2 = findIndex(n1[0], N, 2 * tripartition + v_list[n0]);\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { \n\t\t\t\t\tv_list[n1] - v_list[n0], \n\t\t\t\t\tv_list[n2] - v_list[n1], \n\t\t\t\t\tv_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\n\t\tprivate int[] findIndex(int from_n, int to_n, double target) {\n\t\t\tint n_left = from_n;\n\t\t\tint n_right = to_n;\n\t\t\twhile (n_right - n_left >1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn new int[] { n_left, n_right };\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long > rui;\nint n;\nlong long int ans=0;\n\nint check(int i,long long m)\n{\n\tvector<long long>::iterator hoge=lower_bound(rui.begin()+i,rui.begin()+i+n-1,m+rui[i]);\n\tif(*(rui.begin()+i+n)-*hoge<=m)return 1;\n\tvector<long long>::iterator hage=lower_bound(hoge,rui.begin()+i+n-1,*hoge+m);\n\tif(*(rui.begin()+i+n)-*hage>m)return 0;\n\treturn 1;\n}\n\n\nint main ()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\trui.push_back(x);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trui.push_back(rui[i]);\n\t}\n\tfor(int i=1;i<rui.size();i++)\n\t{\n\t\trui[i]+=rui[i-1];\n\t}\n\t\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long l=0,r=5000000000000;\n\t\twhile(l!=r)\n\t\t{\n\t\t\tlong long m=(r+l)/2;\n\t\t\tif(check(i,m))\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=m+1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans-1<<endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N;\nbool func(long long mid, vector<long long>&line) {\n\tint lp = 0, hp = 1;\n\twhile (true) {\n\t\tif (line[hp] - line[lp] >= mid) {/*\n\t\t\tint fp = hp + 1;\n\t\t\tint bp = lp + N;\n\t\t\twhile (fp < bp) {\n\t\t\t\tint mp = (fp + bp) >> 1;\n\t\t\t\tif (line[mp] - line[hp+1] >= mid) {\n\t\t\t\t\tif (line[lp + N] - line[mp] >= mid) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbp = mp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfp = mp + 1;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tint it = lower_bound(line.begin() + hp + 1, line.begin() + lp + N, mid + line[hp])-line.begin();\n\t\t\tif (line[lp + N] - line[it] >= mid) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t++lp;\n\t\t}\n\t\telse {\n\t\t\t++hp;\n\t\t\tif (hp == N - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tcin >> N;\n\tvector<long long> line(N+1);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcin >> line[i];\n\t\tline.push_back(line[i]);\n\t}\n\tline[0] = 0;\n\tfor (int i = 1; i < line.size(); ++i) {\n\t\tline[i] = line[i] + line[i - 1];\n\t}\n\tlong long lp = 0, hp = INT64_MAX;\n\twhile (lp < hp) {\n\t\tlong long mid = (lp + hp) >> 1;\n\t\tif (func(mid, line)) {\n\t\t\tlp = mid+1;\n\t\t}\n\t\telse {\n\t\t\thp = mid;\n\t\t}\n\t}\n\tcout << lp - 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500001\nusing namespace std;\n#define int long long\nsigned main(){\n  int n;\n  cin>>n;\n  int A[N];\n  for(int i=0;i<n;i++)cin>>A[i];\n  \n  int X[N]={};\n  X[0] = A[0];\n  for(int i=1;i<3*n;i++) X[i] += A[i%n] + X[i-1];\n  \n  int ans = 0,len = X[n-1];\n  for(int i=0;i<=n;i++){\n    int a  = lower_bound(X+i,X+3*n,X[i]+len/3)-X;\n    int la = X[a]-X[i];\n    int b = lower_bound(X+a,X+3*n,X[a]+(len-la)/2)-X;\n    int lb = X[b] - X[a];\n    int lc = len-la-lb;\n    ans = max(ans,min(la,min(lb,lc)));\n  }\n  cout<< ans << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = (a) ; i <= (b) ; i++)\n#define Rep(i , n) for (int i = 0 ; i < (n) ; i++)\n#define Ford(i , a , b) for (int i = (a) ; i >= (b) ; i--)\n\nconst int maxn = 200000 + 1912;\nint n , a[maxn];\nlong long totalSum = 0;\nlong long sum[maxn];\n\nvoid ReadData() {\n\tscanf(\"%d\" , &n);\n\tFor(i , 1 , n) scanf(\"%d\" , &a[i]);\n\tFor(i , 1 , n) a[i + n] = a[i];\n\tFor(i , 1 , n << 1) sum[i] = sum[i - 1] + a[i];\n}\n\nlong long GetSum(const int l , const int r) {\n\treturn sum[r] - sum[l - 1];\n}\n\nbool check(long long limit) {\n\tint ptr1 = 1 , ptr2 = 2;\n\tFor(i , 1 , n - 1) {\n\t\tint last = i + n - 1;\n\t\twhile (ptr1 < last - 1 && GetSum(i , ptr1) < limit) ptr1++;\n\t\tptr2 = max(ptr2 , ptr1 + 1);\n\t\twhile (ptr2 < last && GetSum(ptr1 + 1, ptr2) < limit) ptr2++;\n\t\t\n\t\tif ((ptr2 <= last) &&\n\t\t (GetSum(i , ptr1) >= limit && GetSum(ptr1 + 1 , ptr2) >= limit && GetSum(ptr2 + 1 , last) >= limit) ) return true;\n\t}\n\treturn false;\n}\n\nvoid Process() {\n\tlong long res = 0;\n\tlong long l = 1 , r = 1000LL * 1000 * 1000 * 1000 * 1000 + 1912;\n\twhile (l <= r) {\n\t\tlong long mid = (l + r) >> 1;\n\t\tif (check(mid)) {\n\t\t\tres = mid;\n\t\t\tl = mid + 1;\n\t\t} else r = mid - 1;\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n   // freopen(\"./baumkuchen.inp\" , \"r\" , stdin);\t\n   \tReadData();\n   \tProcess();\n\n    return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n + 1) cuts[i + n + 1] = cuts[i];\n\t\trep(i, n + n + 1) cuts[i + 1] += cuts[i];\n\t\tint ideal = int(((double)sum / 3.0) + 0.5);\n\n\t\tint ans = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tint idx = lower_bound(all(cuts), ideal + cuts[i]) - cuts.begin();\n\t\t\tint len = cuts[idx] - cuts[i];\n\t\t\tint rem = (sum - len) / 2;\n\t\t\tint remidx = lower_bound(all(cuts), rem + cuts[idx]) - cuts.begin();\n\t\t\tint remlen = cuts[remidx] - cuts[idx];\n\t\t\tans = max(ans, sum - len - remlen);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL-=3;\n\t\t\tif (LL <= -1)LL = 0;\n\t\t\twhile (AA[LL] - AA[r - 1] < sum)LL++;\n\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\tsum2 = AA[N-1]-sum-sum1;\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2){\n\t\t\t\tans = max(ans, sum);\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse l++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[3*N];\n\tmemo = new long long[3 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <3*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[i * N + b] = memo[i * N + b - 1] + piece(b - 1, b);\n\t\t\tif (memo[i * N + b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[i * N + b - 1] < memo[i * N + b] - tripartition){\n\t\t\tkeep_value = memo[i * N + b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[i * N + b];\n\t\tdouble half = (sum_baum - memo[i * N + b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[i * N + c] = memo[i * N + c - 1] + piece(c - 1, c);\n\t\t\tif (memo[i * N + c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[i * N + c - 1] < memo[i * N + c] - keep_value - half){\n\t\t\tkeep_value2 = memo[i * N + c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[i * N + c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"c = %d\\n\", c);\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N)break;\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->extended_full_search() << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n    ll ans=0,sum=0;\n    int n,l=0,r=1;\n    \n    scanf(\"%d\",&n);\n    \n    vector<ll> a(n+1,0);\n    \n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        sum+=a[i];\n        a[i]=sum;\n    }\n    \n    while(1){\n        \n        if((a[r]-a[l])*3<sum){\n            r++;\n            if(r==n+1) break;\n        }else{\n            l++;\n        }\n        \n        if((a[r]-a[l])*3<sum)\n            continue;\n        \n        vector<ll>::iterator itl=lower_bound(a.begin(),a.end(),(sum-a[r]+a[l]+1)/2+a[r]);\n        \n        if(itl!=a.end())\n            ans=max(ans,sum-(*itl)+a[l]);\n        \n            ans=max(ans,*(itl-1)-a[r]);\n        \n        cout << l << \"-\" << r << \":\" << a[r]-a[l] << \" \" << sum-(*itl)+a[l] << \":\" << *(itl-1)-a[r] << endl;\n        \n    }\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\nusing namespace std;\n\nint main(){\n    \n    double a,b,c,d,e;\n    int num;\n    cin>>num;\n    long int A[100001];\n    for (int i=0; i<num; i++) {\n        cin>>A[i];\n    }\n    long int mi=0;\n    for (int i=0; i<num-2; i++) {\n        for (int j=i+1; j<num-1; j++) {\n            for (int k=j+1; k<num; k++) {\n                \n                long int aa=0,bb=0,cc=0;\n                for (int i2=i; i2< j; i2++) {\n                    aa+=A[i2];\n                }\n                \n                for (int i3=j; i3< k; i3++) {\n                    bb+=A[i3];\n                }\n                \n                for (int i4=k; i4< num; i4++) {\n                    cc+=A[i4];\n                }\n                for (int i4=0; i4< i; i4++) {\n                    cc+=A[i4];\n                }\n                mi=max(mi,min(aa,min(bb,cc)));\n            }\n        }\n    }\n    cout<<mi<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n   int a,b,c,d,e,f,g;\n   scanf(\"%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g);\n   printf(\"6\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(2*n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &v[i]);\n        v[n+i] = v[i];\n    }\n    vector<ll> S(2*n+1);\n    for (int i = 0; i < 2*n; ++i) {\n        S[i+1] = S[i] + v[i];\n    }\n    auto f = [&](int i, ll X){\n        auto next = lower_bound(S.begin()+i+1, S.begin()+i+1+n, S[i]+X);\n        if(next == S.begin()+i+1+n) return false;\n        auto nextnext = lower_bound(S.begin()+i+1, S.begin()+i+1+n, *next+X);\n        if(nextnext == S.begin()+i+1+n) return false;\n        return S[i+n] - *nextnext >= X;\n    };\n    ll ok = 0, ng = S[n]/3+2;\n    while(ng-ok > 1){\n        ll mid = (ok+ng)/2;\n        int okk = 0;\n        for (int i = 0; i < n; ++i) {\n            if(f(i, mid)) {\n                okk = 1;\n                break;\n            }\n        }\n        if(okk) ok = mid;\n        else ng = mid;\n    }\n    cout << ok << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n + i, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2, n + i, (A[i + n - 1] - A[c2 - 1]) / 2);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n\n    for (int j = -1; j < 2; ++j) {\n      int tc2 = c2 + j, tc3 = c3 + j;\n      tmin = A[tc2 - 1] - A[i - 1];\n      tmin = min(tmin, A[tc3 - 1] - A[tc2 - 1]);\n      tmin = min(tmin, A[i + n - 1] - A[tc3 - 1]);\n      ans = max(ans, tmin);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint rem = sum - size;\n\t\t\tint lb = right + 1, ub = left + n;\n\t\t\twhile (ub - lb > 1)\n\t\t\t{\n\t\t\t\tint mid = (lb + ub) / 2;\n\t\t\t\tint score = cuts[mid] - cuts[right];\n\t\t\t\tif (score <= rem / 2) lb = mid;\n\t\t\t\telse ub = mid;\n\t\t\t}\n\n\t\t\tint k = lb;\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tint ttmin = min({ a, b, c });\n\t\t\tans = max(ans, ttmin);\n\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= ttmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[111111*2];\nlong long sum[111111*2];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] > sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  s = e;\n  //printf(\":%lld %lld %lld %lld %d %d\\n\",lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  res = max(res,min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]));\n  return min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n  }\n  for( int j = 0; j < 2*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;s<n&&e<n;++e) {\n    while( e < n && C(s,e) > sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }    \n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <stdlib.h>\nusing namespace std;\n\n#define debug 0\n\nint InArray[200000] = {0};\nint N = 0;\n\nlong long sumArray(int, int);\n\nint main()\n{\n\t// initialize input\n\tint temp;\n#if debug\n\tFILE *inputFile = fopen(\"0600_in12.txt\", \"r\");\n\tfscanf(inputFile, \"%d\", &N);\n\t//cout << \"N: \" << N << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tfscanf(inputFile, \"%d\", &temp);\n\t\t//cout << temp << endl;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\tcout << endl;\n\tfclose( inputFile);\n#else\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n#endif\n\t\n\t// Calculate sum and average\n\tlong long sum = sumArray(0, N);\n\tlong long average;\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\n#if debug\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n#endif\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum;\n\tlong long average2;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(int a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(int a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] < sum - a1_sum - a2_sum){\n\t\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n#if debug\n\t\t\t\t\t\tcout << MaxMin << endl;\n#endif\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n#if debug\n\t\t\t\t\t\tcout << MaxMin << endl;\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong long sumArray(int start, int end)\n{\n\tlong long sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n//\t\tcout << \"i:\" << i << \"sum:\" << sum << endl;\n\t}\n//\tcout << sum << endl;\n//\tsystem(\"pause\");\n\treturn sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long sum_baum;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tint tripartition();\t//\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\n\tlong long full_search();\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\n\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n}\n\nint baumkuchen::tripartition(){\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tsum += A[N];\n\t}\n\treturn sum;\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[N];\n\n\tset = true;\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t\tsum_baum += A[i];\n\t}\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value=0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value<keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tcout << solve->full_search()<<endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n    ll ans=0,sum=0;\n    int n,l=0,r=1;\n    \n    scanf(\"%d\",&n);\n    \n    vector<ll> a(n+1,0);\n    \n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i]);\n        sum+=a[i];\n        a[i]=sum;\n    }\n    \n    while(1){\n        \n        if((a[r]-a[l])*3<sum){\n            r++;\n            if(r==n+1) break;\n        }else{\n            l++;\n        }\n        \n        if((a[r]-a[l])*3<sum)\n            continue;\n        \n        vector<ll>::iterator itl=lower_bound(a.begin(),a.end(),(sum-a[r]+a[l]+1)/2+a[r]);\n        \n        if(itl!=a.end())\n            ans=max(ans,sum-(*itl)+a[l]);\n        \n            ans=max(ans,*(itl-1)-a[r]);\n        \n       // cout << l << \"-\" << r << \":\" << a[r]-a[l] << \" \" << sum-(*itl)+a[l] << \":\" << *(itl-1)-a[r] << endl;\n        \n    }\n    \n    printf(\"%lld\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N + 2; i++ )\n\t{\n\t\tlong long int A = data[i]-data[0];\n\t\tfor( size_t j = i; j < N + 2; j++ )\n\t\t{\n\t\t\tlong long int B = data[j] - data[i];\n\t\t\tfor( size_t k = j; k < N + 2; k++ )\n\t\t\t{\n\t\t\t\tans = max ( ans , min ( { B , data[k] - data[j] , ( data[N + 1] - data[k] ) + A } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tlong long Left,Right,Mid;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\n\t\tLeft=i;Right=n+1;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid - 2)%n + 1]>=B){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid - 1)%n + 1]<B){\n\t\t\t\tLeft=Mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tB2 = s[(Mid - 1) % n + 1]; d = (Mid - 1) % n + 1;\n\n\t\tLeft=i;Right=n+1;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[(Mid - 2)%n + 1]>=C){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[(Mid - 1)%n + 1]<C){\n\t\t\t\tLeft=Mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tC2 = s[(Mid - 1) % n + 1]; e = (Mid - 1) % n + 1;\n\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<long long> a(2 * n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    long long x;\n    cin >> x;\n    a[i] = a[i + n] = x;\n  }\n  for (int i = 1; i <= 2 * n; i++) {\n    a[i] += a[i - 1];\n  }\n  auto ck = [&] (long long k) -> bool {\n    for (int l = 0; l <= n; l++) {\n      auto it = lower_bound(a.begin(), a.end(), a[l] + k); if (it == a.end()) continue;\n      auto jt = lower_bound(a.begin(), a.end(), *it + k); if (jt == a.end()) continue;\n      auto kt = lower_bound(a.begin(), a.end(), *jt + k); if (kt == a.end()) continue;\n      int r = kt - a.begin();\n      if (r - l <= n) return true;\n    }\n    return false;\n  };\n  constexpr long long inf = 1LL << 60;\n  long long ok = 0, ng = inf, md;\n  while (ng - ok > 1) {\n    md = (ok + ng) >> 1;\n    if (ck(md)) ok = md;\n    else ng = md;\n  }\n  cout << ok << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1 << 30;\nvector<long long int> baum;\nlong long int n, ans, minma = INF;\nlong long int Baum = 0, Baum3 = 0;\n\nvoid cut(long long int f) {\n\tlong long int s = f + Baum3, t = s + Baum3;\n\tlong long int p;\n\tlong long int sp[3] = {}, tp[3] = {};\n\tp = lower_bound(baum.begin(), baum.end(), s) - baum.begin();\n\tif (s == baum[p]) {\n\t\tsp[0] = baum[p + 1];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = baum[p];\n\t}\n\telse {\n\t\tsp[0] = baum[p];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = INF;\n\t}\n\tp = lower_bound(baum.begin(), baum.end(), t) - baum.begin();\n\tif (t == baum[p]) {\n\t\ttp[0] = baum[p + 1];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = baum[p];\n\t}\n\telse {\n\t\ttp[0] = baum[p];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = INF;\n\t}\n\tfor (int i = 0; i <= 2; i++) {\n\t\tif (sp[i] == INF) break;\n\t\tminma = sp[i] - f;\n\t\tfor (int j = 0; j <= 2;j ++){\n\t\t\tif (tp[j] == INF) break;\n\t\t\tminma = min( minma, min( tp[j] - sp[i], Baum - tp[j] + f ));\n\t\t\tans = max(ans, minma);\n\t\t\tminma = sp[i]-f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tbaum.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint in;\n\t\tscanf(\"%d\", &in);\n\t\tBaum += in;\n\t\tbaum.push_back(in);\n\t}\n\tBaum3 = Baum / 3;\n\n\tfor (int i = 2; i <= n+1; i++) {\n\t\tbaum[i] += baum[i - 1];\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tif (baum[i] >= Baum3) break;\n\t\tcut(baum[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\trep(k, n + n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntypedef int baumkuchen_size_t;\ntypedef int index_t;\n\nstd::vector<baumkuchen_size_t> pieces;\nbaumkuchen_size_t whole_size; // SUM OF SIZE OF PIECES\nbaumkuchen_size_t max_size;   // MAX SIZE OF THE SMALLEST PIECE\n\n\ninline void reguralize(index_t *x)\n{\n    if ((*x) < 0)\n        (*x) += pieces.size();\n    (*x) %= pieces.size();\n}\n\n\ninline void progress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev += pieces.at(idx);\n    size_curr -= pieces.at(idx);\n    ++idx;\n}\n\n\ninline void regress_idx(\n    index_t &idx,\n    baumkuchen_size_t &size_prev,\n    baumkuchen_size_t &size_curr)\n{\n    size_prev -= pieces.at(idx);\n    size_curr += pieces.at(idx);\n    --idx;\n}\n\n\nint main()\n{\n    // READ INPUTS\n    {\n        int num;\n        std::cin >> num;\n        pieces.assign(num, 0);\n\n        for (int i = 0; i < num; ++i)\n        {\n            std::cin >> pieces[i];\n            whole_size += pieces.at(i);\n        }\n        max_size = whole_size / 3;\n    }\n    \n    index_t idx1(0), idx2(1), idx3(2); // BEGIN INDEX OF EACH BAUMKUCHEN PIECE\n    baumkuchen_size_t\n        size1(pieces.at(idx1)),            // SIZE OF 1ST BAUMKUCHEN PIECE\n        size2(pieces.at(idx2)),            // SIZE OF 2ND BAUMKUCHEN PIECE\n        size3(whole_size - size1 - size2); // SIZE OF 3RD BAUMKUCHEN PIECE\n    int out(0); // RETURN VALUE\n\n    /* ASSUME THAT THE FIRST PIECE IS SMALLEST. */\n    \n    while (idx1 < pieces.size())\n    {\n        while (size1 <= max_size)\n        {\n            // CHECK WHETHER size1 CAN BE SMALLEST\n            while (true)\n            {\n                bool was_larger(size2 > size3);\n                \n                if (size2 == size3)\n                {\n                    if (size1 > out) out = size1;\n                    break;\n                }\n                else if (size2 > size3)\n                {\n                    if (size3 > size1)\n                    {\n                        if (size1 > out) out = size1;\n                        break;\n                    }\n                    else\n                        regress_idx(idx3, size2, size3);\n                }\n                else\n                {\n                    if (size2 > size1)\n                    {\n                        if (size1 > out) out = size1;\n                        break;\n                    }\n                    else\n                        progress_idx(idx3, size2, size3);\n                }\n                \n                reguralize(&idx3);\n                if ((size2 > size3) != was_larger)\n                    break;\n            }\n            \n            progress_idx(idx2, size1, size2);\n            reguralize(&idx2);\n        }\n\n        progress_idx(idx1, size3, size1);\n    }\n    \n    std::cout << out << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.perseInt(str);//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[100000];\nll S[200000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%lld\", &a[i]);\n\tS[0] = a[0];\n\tfor(int i = 1; i < 2*n; i++) S[i] = S[i-1]+a[i%n];\n\tll s = -1, e = 1000000000000001, mid;\n\twhile(true){\n\t\tmid = (s+e)/2;\n\t\tif(e-s == 1) break;\n\t\tbool ok = false;\n\t\trep(i,n){\n\t\t\tll st;\n\t\t\tif(i != 0) st = lower_bound(S+i,S+i+n-1,mid+S[i-1])-S;\n\t\t\telse st = lower_bound(S+i,S+i+n,mid)-S;\n\t\t\tif(st == i+n-1) continue;\n\t\t\tst = lower_bound(S+st+1,S+i+n-1,mid+S[st])-S;\n\t\t\tif(S[i+n-1]-S[st] >= mid){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) s = mid;\n\t\telse e = mid;\n\t}\n\tprintf(\"%d\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / 3;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_min)) ? ans_min : ans_max;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\n \nll const INF = 1LL<<60;\n \nll N;\nll sum[200001];\nll arr[100001];\n \nll midx;\n\nbool C(ll d, ll S[], ll base) {\n  ll p1 = lower_bound(S, S+N, d+base) - S;\n  ll p2 = lower_bound(S, S+N, d+S[p1]) - S;\n  if(N <= p2) return false;\n  if(S[N-1] - S[p2] >= d) {\n    return true;\n  }\n  return false;\n}\n \nint main() {\n   \n  cin >> N;\n  for(int i=0; i<N; i++) {\n    cin >> arr[i];\n  }\n   \n  for(int i=0; i<N; i++) {\n    sum[i] = arr[i];\n    if(i) sum[i] += sum[i-1];\n  }\n  for(int i=N; i<2*N; i++) {\n    sum[i] = arr[i-N]+sum[i-1];\n  }\n   \n  ll ans = 0;\n  for(midx=0; midx<N; midx++) {\n    ll lb = 0, ub = INF;\n    while(ub-lb>1) {\n      ll mid = (lb+ub)/2;\n      ll c;\n      if(midx>0) c = sum[midx-1];\n      else c = 0;\n \n      if(C(mid, sum+midx, c)) {\n        lb = mid;\n      } else {\n        ub = mid;\n      }\n    }\n    ans = max(ans, lb);\n  }\n   \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n);\n\t\trep(i, n) cin >> cuts[i];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left <= n + 1)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = (sum - size) / 2.0;\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<functional>\n#include<map>\n#define int long long\nusing namespace std;\n\nint a[200000];\nsigned main() {\n\tint b;\n\tcin >> b;\n\tint c = 0;\n\tfor (int d = 0; d < b ; d++) {\n\t\tint e; scanf(\"%lld\", &e);\n\t\tc += e;\n\t\ta[d + 1] = c;\n\t}\n\tfor (int d = 1; d < b; d++) {\n\t\ta[b + d] = a[d] + c;\n\t}\n\tint MIN = LLONG_MAX / 3;\n\tint k = 0;\n\tfor (int d = 0; d < b; d++) {\n\t\tint e = d + 1, f = d + b - 1;\n\t\twhile (f - e >= 1) {\n\t\t\tint g = (e + f) / 2;\n\t\t\tauto h = lower_bound(a + d, a + d + b, a[d]+2*(a[g] - a[d]));\n\t\t\tif (h == a + d + b || a[d + b] - *h < a[g] - a[d]) {\n\t\t\t\tf = g;\n\t\t\t}\n\t\t\telse { e = g + 1; k = max(k, a[g] - a[d]);  }\n\t\t}\n\t}\n\tcout << k << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  vector<Int> b(n*3);\n  for(Int i=0;i<n;i++) b[i]=b[n+i]=b[n*2+i]=a[i];\n  b.emplace(b.begin(),0);\n  partial_sum(b.begin(),b.end(),b.begin());\n  \n  auto calc=[&](Int x){\n    for(Int i=0;i<n;i++){\n      Int p=i;\n      p=lower_bound(b.begin()+p,b.end(),b[p]+x)-b.begin();\n      p=lower_bound(b.begin()+p,b.end(),b[p]+x)-b.begin();\n      p=lower_bound(b.begin()+p,b.end(),b[p]+x)-b.begin();\n      if(p-i<=n) return 1;\n    }\n    return 0;\n  };\n  \n  Int l=0,r=accumulate(a.begin(),a.end(),(Int)0);\n  while(l+1<r){\n    Int m=(l+r)>>1;\n    if(calc(m)) l=m;\n    else r=m;\n  }\n  cout<<l<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint n;\nll a[200010], b[200010];\n\nbool check(int m) {\n  REP(i, n) {\n    int tmp = i==0 ? 0 : b[i-1];\n    int itr1 = lower_bound(b+i, b+i+n, tmp+m) - b;\n    // cout << b[itr1]+m << \" \" << *lower_bound(b+i, b+i+n, b[itr1]+m) << endl;\n    int itr2 = lower_bound(b+i, b+i+n, b[itr1]+m) - b;\n    // cout << \"i:\" << i << \" \" << itr1 << \" \" << itr2 << \" \" << a[itr1] << \" \" << a[itr2] << endl;\n    if(b[n+i-1] - b[itr2] >= m) return true;\n  }\n  return false;\n}\n\nsigned main(void)\n{\n  cin >> n;\n  REP(i, n) cin >> a[i];\n  FOR(i, n, 2*n) a[i] = a[i-n];\n  b[0] = a[0];\n  FOR(i, 1, 2*n) b[i] = a[i] + b[i-1];\n\n  // [low, high)\n  ll low=1, high=b[n-1];\n  while(high-low>1) {\n    ll mid = (low+high)/2;\n    // cout << low << \" \" << mid << \" \" << high << endl;\n    if(check(mid)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  cout << low << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0600\n#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int number;\n\nconst number NMAX = 100020;\nnumber N;\nnumber A[NMAX], acc[NMAX];\n\nnumber length(number l, number r) {\n  if (l > r) {\n    return acc[N] - length(r, l);\n  } else {\n    return acc[r - 1] - acc[l - 1];\n  }\n}\n\nint main() {\n  cin >> N;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i];\n    acc[i] = acc[i - 1] + A[i];\n  }\n\n  number a = 1, b = 2, c = 3;\n  number ans = -1, counter = 0;\n\n  while (counter < N + 4) {\n//    cout << \"(\" << a << \" \" << b << \" \" << c << \")\" << endl;\n    number asize = length(a, b), bsize = length(b, c),\n           csize = length(c, a);\n    number minimum = min(asize, min(bsize, csize));\n    ans = max(ans, minimum);\n\n    if (asize == minimum) {\n      b = b % N + 1;\n    } else if (bsize == minimum) {\n      c = c % N + 1;\n    } else if (csize == minimum) {\n      a = a % N + 1;\n      counter++;\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n\nint main(){\n\tll n,a[100000];\n\tvector<ll> x(100000);\n\tcin >> n;\n\n\tfor(int i=0;i<n;i++){\n\t\tx[i] = 0;\n\t\tcin >> a[i];\n\t\tif (i != 0) {\n\t\t\tx[i] = a[i-1] + x[i-1];\n\t\t}\n\t}\n\tx[n] = x[n-1] + a[n-1];\n\tll length = x[n] / 3;\n\tll mi = 0;\n\tll ma = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tll tmp = x[i] + length;\n\t\tmi = x[n-1] + 1;\n\t\tll p1 = 0, p2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (p1 == 0) {\n\t\t\t\t\tp1 = j;\n\t\t\t\t\ttmp = (x[n] - x[p1] + x[i])/2 + x[p1];\t\n\t\t\t\t} else {\n\t\t\t\t\tp2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp = x[i] + length;\n\t\tll q1 = 0, q2 = 0;\n\t\tfor (int j=i;j<n;j++) {\n\t\t\tif (x[j] >= tmp) {\n\t\t\t\tif (q1 == 0) {\n\t\t\t\t\tq1 = j-1;\n\t\t\t\t\ttmp = (x[n] - x[q1] + x[i])/2 + x[q1];\t\n\t\t\t\t} else {\n\t\t\t\t\tq2 = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[p1] - x[i]);\n\t\tmi = min(mi, x[p2-1] - x[p1]);\n\t\tmi = min(mi, x[n] - x[p2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2] + x[i]);\n\t\tma = max(ma,mi);\n\t\tmi = x[n] + 1;\n\t\tmi = min(mi, x[q1] - x[i]);\n\t\tmi = min(mi, x[q2-1] - x[q1]);\n\t\tmi = min(mi, x[n] - x[q2-1] + x[i]);\n\t\tma = max(ma,mi);\n\t}\n\tcout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lg;\n\nbool able(vector<lg>& ps, lg n) {\n\tlg const N = ps.size()/2l;\n\tfor (lg i = 1; i <= N; i++) {\n\t\tauto beg = begin(ps)+i,\n\t\t     ed = beg+N;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tbeg = lower_bound(beg, end(ps), *(beg-1)+n)+1;\n\t\t\tif (beg >= end(ps)) break;\n\t\t}\n\t\tif (beg <= ed) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tlg N;\n\tcin >> N;\n\tvector<lg> A(2*N), ps(2*N+1, 0);\n\tfor (auto i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tA[i+N] = A[i];\n\t}\n\tpartial_sum(begin(A), end(A), begin(ps)+1);\n\tlg l = 0, r = 1000000000l*N;\n\twhile (r-l > 1l) {\n\t\tauto m = (l+r)/2l;\n\t\t(able(ps, m) ? l : r) = m;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main() {\n\tint N;\n\tlong long int *baum;\n\tcin >> N;\n\tlong long int all = 0;\n\tbaum = new long long int[N];\n\tlong long int *memo;\n\tmemo = new long long int[N + 1];\n\tmemo[N] = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> baum[i];\n\t\tall += baum[i];\n\t}\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tmemo[i] = memo[i + 1] + baum[i];\n\t}\n\tlong long int first = 0;\n\tlong long int answer=0;\n\tfor (int i = 0; i < N-2; ++i) {\n\t\tfirst += baum[i];\n\t\tfor (int j = i + 2;; ++j) {\n\t\t\tanswer = max(answer, min(memo[j], min(all - first - memo[j], first)));\n\t\t\tif (memo[j] < all - first - memo[j])break;\n\t\t}\n\t}\n\tcout << answer << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tauto eval = [&](int k)\n\t\t{\n\t\t\tint i = left, j = right;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tint ttmin = min({ a, b, c });\n\t\t\tans = max(ans, ttmin);\n\t\t\treturn ttmin;\n\t\t};\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tint x0 = right, x3 = n;\n\t\t\twhile (x3 - x0 > 1)\n\t\t\t{\n\t\t\t\tint x1 = x0 + (x3 - x0) / 3;\n\t\t\t\tint e1 = eval(x1);\n\t\t\t\tint x2 = x1 + (x3 - x0) / 3;\n\t\t\t\tint e2 = eval(x2);\n\t\t\t\tif (x1 < x2) x0 = x1;\n\t\t\t\telse x3 = x2;\n\t\t\t\ttmin = max({ tmin, e1, e2 });\n\t\t\t}\n\n\t\t\t//REP(k, right + 1, n)\n\t\t\t//{\n\t\t\t//\tint i = left, j = right;\n\t\t\t//\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t//\tint ttmin = min({ a, b, c });\n\t\t\t//\tans = max(ans, ttmin);\n\t\t\t//\tif (tmin > ttmin) break;\n\t\t\t//\ttmin = max(tmin, ttmin);\n\t\t\t//}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200001];\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posl1 = posr1 - 1;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\t\tint posl2 = posr1 - 1;\n\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posl2), sum(posl2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posl1), sum(posl1, posr2), sum(posr2, i + n) }));\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0600\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\ntypedef long long ll;\n\nconst int MAX_N = 100000;\n\nint N;\nll A[MAX_N], S[MAX_N*3+1];\n\nint nxt( int p, ll x )\n{ return std::lower_bound( S, S+N*3, S[p]+x )-S; }\n\nbool C( ll x )\n{\n\trep( i, N )\n\t{\n\t\tint p = i;\n\t\tp = nxt( p, x ); if( p > i+N ) continue;\n\t\tp = nxt( p, x ); if( p > i+N ) continue;\n\t\tp = nxt( p, x ); if( p > i+N ) continue;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tscanf( \"%d\", &N );\n\trep( i, N )\n\t\tscanf( \"%lld\", A+i );\n\n\tS[0] = 0;\n\trep( i, N )\n\t\tS[i+1] = S[i+N+1] = S[i+N*2+1] = A[i];\n\trep( i, 3*N )\n\t\tS[i+1] += S[i];\n\n\tll lb = 1, ub = S[N]/3;\n\n\twhile( lb != ub )\n\t{\n\t\tll mid = lb+ub+1>>1;\n\n\t\tif( C( mid ) )\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid-1;\n\t}\n\n\tprintf( \"%lld\\n\", ub );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\t\n\tfor (p.end = p.top; p.end <= _end; p.end ++){\n\t\tif ((p.size = calcPieceSize(p)) >= min_piece_size) return p;\n\t}\n\n\tp.end --;\n\tp.size = -1;\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / 3;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_min)) ? ans_min : ans_max;\n\n\treturn ans;\n}\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nconst double EPS = 1e-10;\nconst ll MOD = 7+(1e+9);\n\nll n;\n\nll ch(ll a){\n  return (a+n)%n;\n}\n\nint main (){\n  cin>>n;\n  vector<ll>v(n,0);\n  ll sum=0;\n  for(ll i=0;i<n;i++){\n    cin>>v[i];\n    sum+=v[i];\n  }\n  ll f=0;\n  ll i=0;\n  ll j=1;\n  ll l=2;\n  ll ans=0;\n  ll asum,bsum,csum;\n  asum=v[0];\n  bsum=v[1];\n  csum=sum-v[0]-v[1];\n  ans=min({asum,bsum,csum});\n  if(n==3){\n    cout<<ans<<endl;\n    return 0;\n  }\n  while(!(f!=0&&i==0)){\n    ll m=min({asum,bsum,csum});\n    ll mm=max({asum,bsum,csum});\n    if(csum==m&&ch(j-i)!=1){\n      asum-=v[i];\n      csum+=v[i];\n      i++;\n      i=ch(i);\n    }\n    else if(asum==m&&ch(l-j)!=1){\n      bsum-=v[j];\n      asum+=v[j];\n      j++;\n      j=ch(j);\n    }\n    else if(bsum==m&&ch(i-l)!=1){\n      csum-=v[l];\n      bsum+=v[l];\n      l++;\n      l=ch(l);\n    }\n    else if(asum==mm&&ch(j-i)!=1){\n      asum-=v[i];\n      csum+=v[i];\n      i++;\n      i=ch(i);\n    }\n    else if(bsum==mm&&ch(l-j)!=1){\n      bsum-=v[j];\n      asum+=v[j];\n      j++;\n      j=ch(j);\n    }\n    else if(csum==mm&&ch(i-l)!=1){\n      csum-=v[l];\n      bsum+=v[l];\n      l++;\n      l=ch(l);\n    }\n    else{\n      ans=max(ans,min({asum,bsum,csum}));\n      break;\n    }\n    ans=max(ans,min({asum,bsum,csum}));\n    if(i>1)f=1;\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tif (N > DevideNum){\n\t\tcout << \"0\" << endl;\n\t\texit(1);\n\t}\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / DevideNum;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_max)) ? ans_max : ans_min;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\n int main(){\n\n\t int N,point2,point3,tmp;\n\t ll ans = -1;\n\t scanf(\"%d\",&N);\n\n\t ll* table = new ll[N+1];\n\t table[0] = 0;\n\n\t for(int i = 1; i <= N; i++){\n\t\t scanf(\"%lld\",&table[i]);\n\t\t table[i] += table[i-1];\n\t }\n\n\t ll left,right,m,inner_left,inner_right,inner_m,sum;\n\t bool FLG;\n\n\t left = 1;\n\t right = table[N]/3;\n\t m = (left+right)/2;\n\n\t while(left <= right){\n\t\t FLG = false;\n\n\t\t for(int start = 1; start <= N; start++){\n\n\t\t\t inner_left = 1;\n\t\t\t inner_right = N-1;\n\t\t\t inner_m = (inner_left+inner_right)/2;\n\n\t\t\t point2 = -1;\n\n\t\t\t while(inner_left <= inner_right){\n\n\t\t\t\t if(start+inner_m > N){\n\t\t\t\t\t tmp = start+inner_m-N;\n\t\t\t\t }else{\n\t\t\t\t\t tmp = start+inner_m;\n\t\t\t\t }\n\n\t\t\t\t if(tmp > start){\n\t\t\t\t\t sum = table[tmp-1] - table[start-1];\n\t\t\t\t }else{\n\t\t\t\t\t sum = (table[N]-table[start-1]) + (table[tmp-1] - table[0]);\n\t\t\t\t }\n\n\t\t\t\t if(sum >= m){\n\t\t\t\t\tpoint2 = tmp;\n\t\t\t\t\tinner_right = inner_m-1;\n\t\t\t\t }else{\n\t\t\t\t\t inner_left = inner_m+1;\n\t\t\t\t }\n\t\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t }\n\n\t\t\t inner_left = 1;\n\t\t\t if(point2 > start){\n\t\t\t\t inner_right = N+start-point2-1;\n\t\t\t }else{\n\t\t\t\t inner_right = start-point2-1;\n\t\t\t }\n\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t point3 = -1;\n\n\t\t\t while(inner_left <= inner_right){\n\n\t\t\t\t if(point2+inner_m > N){\n\t\t\t\t\t tmp = point2+inner_m-N;\n\t\t\t\t }else{\n\t\t\t\t\t tmp = point2+inner_m;\n\t\t\t\t }\n\n\t\t\t\t if(tmp > point2){\n\t\t\t\t\t sum = table[tmp-1] - table[point2-1];\n\t\t\t\t }else{\n\t\t\t\t\t sum = (table[N]-table[point2-1]) + (table[tmp-1] - table[0]);\n\t\t\t\t }\n\n\t\t\t\t if(sum >= m){\n\t\t\t\t\t if(start > tmp){\n\t\t\t\t\t\t sum = table[start-1] - table[tmp-1];\n\t\t\t\t\t }else{\n\t\t\t\t\t\t sum = (table[N]-table[tmp-1]) + (table[start-1] - table[0]);\n\t\t\t\t\t }\n\t\t\t\t\t if(sum >= m){\n\t\t\t\t\t\t point3 = tmp;\n\t\t\t\t\t\t inner_right = inner_m-1;\n\t\t\t\t\t }else{\n\t\t\t\t\t\t inner_right = inner_m-1;\n\t\t\t\t\t }\n\t\t\t\t }else{\n\t\t\t\t\t inner_left = inner_m+1;\n\t\t\t\t }\n\t\t\t\t inner_m = (inner_left+inner_right)/2;\n\t\t\t }\n\n\t\t\t if(point3 == -1){\n\t\t\t\t continue;\n\t\t\t }else{\n\t\t\t\t FLG = true;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\t\t if(FLG){\n\t\t\t ans = m;\n\t\t\t left = m+1;\n\t\t }else{\n\t\t\t right = m-1;\n\t\t }\n\t\t m = (left+right)/2;\n\t }\n\n\t printf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vi a(n);\n    rep(i, n) cin >> a[i];\n    ll sum = accumulate(all(a), 0LL);\n\n    ll aa = 0, b, c = LINF;\n    while(c-aa != 1) {\n        b = (c+aa)>>1;\n\n        int j = 0;\n        int k = 0;\n        ll suma = 0, sumb = 0;\n        bool ok = false;\n        rep(i, n) {\n            while(j <= 2*n and suma < b) {\n                suma += a[j%n];\n                j++;\n            }\n            while(k <= 2*n and sumb < b+suma) {\n                sumb += a[k%n];\n                k++;\n            }\n            if(sum-sumb >= b) {\n                ok = true;\n                break;\n            }\n            suma -= a[i];\n            sumb -= a[i];\n        }\n        if(ok) {\n            aa = b;\n        } else {\n            c = b;\n        }\n    }\n    cout << aa << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\n\nLL get_sum(vector<LL> array, LL i, LL j) {\n  LL _sum = 0;\n  if (i < j) {\n    for (LL l = i; l < j; l ++)\n      _sum += array[l];\n  } else {\n    for (LL l = i; l < array.size(); l ++)\n      _sum += array[l];\n    for (LL l = 0; l < j; l ++)\n      _sum += array[l];\n  }\n  return _sum;\n}\n\n\nLL get_max_min(vector<LL> array, LL size) {\n  LL i, j, k, _max, _min, left, center, right;\n  _max = -1;\n\n  // first point\n  for (i = 0; i < size - 2; i ++) {\n    // second poLL \n    for (j = i + 1; j < size - 1; j ++) {\n      // third poLL\n      for (k = j + 1; k < size; k ++) {\n        // calculate each size and get min\n        _min = get_sum(array, i, j);\n        _min = min(get_sum(array, j, k), _min);\n        _min = min(get_sum(array, k, i), _min);\n\n        // choose max\n        _max = max(_max, _min);\n      }\n    }\n  }\n  return _max;\n}\n\n\nint main() {\n   LL i, n, t, _min, size;\n  vector<LL> array;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> t;\n    array.push_back(t);\n  }\n\n  // calculate max\n  _min = get_max_min(array, n);\n\n  // output answer\n  cout << _min << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tll n;\n\tcin>>n;\n\n\tll *d = new ll [n*2];\n\tfor(ll i = 0;i < n;i++){\n\t\tcin>>d[i];\n\t\tif(i != 0){\n\t\t\td[i] += d[i-1];\n\t\t}\n\t\td[i+n] = d[i];\n\t}\n\tfor(ll i =0;i < n;i++){\n\t\td[i+n] += d[n-1];\n\t}\n\tfor(ll i =0;i < n*2;i++){\n\t\t//cout<<i<<\"-\"<<d[i]<<endl;\n\t}\n\tll max_min = 0;\n\tll l = 0,c = 0,r = 0;\n\twhile(l < n){\n\t\twhile(d[c] - d[l] < d[n-1]/3) c++;\n\t\tc--;\n\t\tfor(r = c+1 ;r < n+l;r++){\n\t\t\tll cr = d[r] - d[c];\n\t\t\tll rl = d[n+l] - d[r];\n\t\t\tll m = d[c]-d[l];\n\t\t\tif(m >= cr) m = cr;\n\t\t\tif(m >= rl) m = rl;\n\t\t//\tcout<<l<<\",\"<<c<<\",\"<<r<<\",\"<<n+l<<\"-\"<<d[c]-d[l]<<\",\"<<cr<<\",\"<<rl<<endl;\n\t\t\tif(m > max_min){\n\t\t\t\tmax_min = m;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\tcout<<max_min<<endl;\n\n\tdelete [] d;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>num(N * 2 + 1);\n\tvector<long long int>sum(N * 2 + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> num[i];\n\t\tM += num[i];\n\t\tnum[i + N] = num[i];\n\t}\n\tsum[0] = num[0];\n\tfor (int i = 0; i < N * 2; i++) {\n\t\tsum[i] = sum[i - 1] + num[i];\n\t}\n\tsum[N * 2] = sum[N * 2 - 1] + num[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tL = i;\n\t\tR = i + N - 2;\n\t\tlong long int mid;\n\t\twhile (R - L > 1) {\n\t\t\tmid = (R + L + 1) / 2;\n\t\t\tif (sum[mid] - sum[i - 1] < M / 3) {\n\t\t\t\tL = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = mid;\n\t\t\t}\n\t\t}\n\t\tmid = R;\n\t\tif (mid == i + N - 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tL = mid + 1;\n\t\tR = i + N - 1;\n\t\tlong long int med;\n\t\twhile (R - L > 1) {\n\t\t\tmed = (R + L + 1) / 2;\n\t\t\tif (sum[med] - sum[mid] < (M - (sum[mid] - sum[i - 1])) / 2) {\n\t\t\t\tL = med;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = med;\n\t\t\t}\n\t\t}\n\t\tK = max(K, sum[L] - sum[mid]);\n\t\tif (R == i + N - 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tK = max(K, sum[i + N - 1] - sum[R]);\n\t}\n\tcout << K << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)114\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tfor( ; j < N+i; j++ ){\n\t\t\tif( A[j]-A[i] >= X )\n\t\t\t\tbreak;\n\t\t}\n\t\t//できるだけ真ん中で切る\n\t\tfor( ; k < N+i; k++ ){\n\t\t\tif( A[k]-A[j] >= A[N+i]-A[k] )\n\t\t\t\tbreak;\n\t\t}\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N;\n    cin >> N;\n    vector<long long> A(N);\n    for (int i=0; i<N; ++i) {\n        cin >> A[i];\n    }\n\n    vector<long long> acum(N+1);\n    acum[0] = 0;\n    for (int i=1; i<=N; ++i) {\n        acum[i] = acum[i-1] + A[i-1];\n    }\n\n    long long hi = acum[N];\n    long long lo = 0;\n    while (hi - lo > 1) {\n        long long mi = (hi + lo) / 2;\n\n        int j = 0, k = 0;\n        bool ok = false;\n        for (int i=0; i<N; ++i) {\n            j = max(j, i);\n            while (j <= i+N && (acum[j%(N+1)]-acum[i%(N+1)]+acum[N]) % acum[N] < mi) {\n                j++;\n            }\n            k = max(k, j);\n            while (k <= i+N && (acum[k%(N+1)]-acum[j%(N+1)]+acum[N]) % acum[N] < mi) {\n                k++;\n            }\n            long long p1, p2, p3;\n            p1 = (acum[j%(N+1)]-acum[i%(N+1)]+acum[N]) % acum[N];\n            p2 = (acum[k%(N+1)]-acum[j%(N+1)]+acum[N]) % acum[N];\n            p3 = (acum[i%(N+1)]-acum[k%(N+1)]+acum[N]) % acum[N];\n            if (min(min(p1, p2), p3) >= mi) {\n                ok = true;\n                break;\n            }\n        }\n\n        if (ok) {\n            lo = mi;\n        } else {\n            hi = mi;\n        }\n    }\n    cout << lo << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nvoid InitRand()\n{\n\tsrand((unsigned int)time(NULL));\n}\nint Dice()\n{\n\treturn rand() % N;\n}\nint main()\n{\n\tInitRand();\n\tint cou;\n\tint i, j, k;\n\tll ans = 0;\n\tll sum1, sum2, sum3;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < N; i++)AA[i] = AA[i - 1] + A[i];\n\tfor (cou = 0; cou < 20000000; cou++){\n\t\t//if (cou % 100000 == 99999)printf(\"%d\\n\", cou);\n\t\tsum1 = sum2 = sum3 = 0;\n\t\ti = Dice(); j = Dice(); k = Dice();\n\t\tif (i == j || j == k || i == k)continue;\n\t\tif (i>j)swap(i, j);\n\t\tif (i>k)swap(i, k);\n\t\tif (j>k)swap(j, k);\n\t\tif(i!=0)sum1 += AA[i - 1];\n\t\tsum2 += AA[j-1] - AA[i - 1];\n\t\tsum3 += AA[k-1] - AA[j - 1];\n\t\tsum1 += AA[N-1] - AA[k - 1];\n\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = lower_bound(all(cuts), cuts[j] + size) - cuts.begin();\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000]; long long s[200000];\n\ninline int reader()\n{\n\tint ret = 0;\n\n\twhile (true)\n\t{\n\t\tchar c = getchar();\n\n\t\tif (c == '\\n') break;\n\n\t\tret = (ret << 1) + (ret << 3) + c - 48;\n\t}\n\n\treturn ret;\n}\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tn = reader();\n\n\tfor (int i = 0; i < n; i++) a[i] = reader();\n\n\ts[0] = 0; for (int i = 1; i < 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0, sums = s[n];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint posr1 = lower_bound(s, s + 2 * n + 1, s[i] + sums / 3) - s;\n\t\tint posr2 = lower_bound(s, s + 2 * n + 1, s[i] + sums * 2 / 3) - s;\n\n\t\tret = max(ret, min({ sum(i, posr1), sum(posr1, posr2), sum(posr2, i + n) }));\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0, s1, s2, s3, t;\n\ta[0] = 0;\n\t\n\twhile(r < n){\n\t\twhile(a[l1]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t\tl1++;\n\t\t}\n\t\twhile(a[l2]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t\tl2++;\n\t\t}\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m)return 0;\n\t\telse{\n\t\t\tr++;sum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nll n,sum,a[N],A[2*N];\n\nll bynary_search(ll b,ll e){\n  ll l=b,r=e;\n  \n  while(l<r){\n    ll m=(l+r)/2;\n    if(sum/3.0<=A[m]-A[b-1])r=m;\n    else l=m+1;\n  }\n  \n  return l;\n}\n\nvoid solve(){\n  ll ans=0;\n  \n  for(int cut1=0;cut1<n;cut1++){\n    ll cut2=bynary_search(cut1+1,cut1+n);\n    ll cut3=bynary_search(cut2+1,cut1+n);\n    \n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    cut3--;\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n    cut2--;\n    \n    cut3=bynary_search(cut2+1,cut1+n);\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n    cut3--;\n    ans=max(ans,min(A[cut2]-A[cut1],min(A[cut3]-A[cut2],A[cut1+n]-A[cut3])));\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>a[i],sum+=a[i];\n  A[0]=a[0];\n  for(int i=1;i<2*n;i++)A[i]=a[i%n]+A[i-1];\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint n,c2=0,c3=0,s=0,s1=0,s2=0,m=0;\n\tint a[100000];\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> a[i];\n\t\ts+=a[i];\n\t}\n\tfor(int c1=0;c1<n;c1++){\n\t\twhile(s1<s/3){\n\t\t\ts1+=a[c2%n];\n\t\t\ts2-=a[c2%n];\n\t\t\tc2++;\n\t\t}\n\t\tif(c3<=c2){\n\t\t\tc3=c2+1;\n\t\t\ts2=a[c2%n];\n\t\t}\n\t\twhile(s2<(s-s1)/2){\n\t\t\ts2+=a[c3%n];\n\t\t\tc3++;\n\t\t}\n\t\tif(m<s-s1-s2){\n\t\t\tm=s-s1-s2;\n\t\t}\n\t\tc3--;\n\t\ts2-=a[c3%n];\n\t\tif(m<s2){\n\t\t\tm=s2;\n\t\t}\n\t\ts1-=a[c1%n];\n\t}\n\tcout << m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  cin>>n;\n  int a[200000];\n  int z[200000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<=c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    d=d-1;\n    while(e<c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}\n  }\n  b=0;\n  c=0;\n  e=0;\n  f=0;\n  d=0;\n  for(int m;m<n;m++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    };\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    e=e-a[d];\n    f=c-b-e;\n    if(f>b){\n      z[m]=b;\n    }else{\n      z[m]=f;}     \n  }\n  sort(z,z+2n);\n  cout<<z[2n-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nint n;\nint a[200001];\nint sum[200001];\n\nbool bin_check(int x) {\n\n    int p1 = 0, p2 = 0;\n    int sum1 = 0, sum2 = 0;\n\n    // Shakutori\n    for(int i = 0; i < n; ++i) {\n\n        // 1\n        while(sum1 < x) {\n            sum1 += a[p1];\n            if(p1 < p2) sum2 -= a[p1];\n            ++p1;\n        }\n\n        // 2\n        if(!i) p2 = p1;\n        while(sum2 < x) {\n            sum2 += a[p2];\n            ++p2;\n        }\n\n        // 3\n        if(sum[n + i] - sum[p2] >= x) {\n            return true;\n        }\n\n        sum1 -= a[i];\n    }\n\n    return false;\n\n}\n\nmain() {\n\n    cin >> n;\n\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        a[n + i] = a[i];\n    }\n\n    sum[0] = 0;\n    for(int i = 1; i <= 2 * n; ++i) {\n        sum[i] = sum[i - 1] + a[i - 1];\n    }\n\n    int l = 0, m, r = sum[n + n] / 3;\n    while(l + 1 < r) {\n        m = (l + r) / 2;\n        if(bin_check(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n        //cout << l << \" \" << r << endl;\n    }\n\n    cout << l << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n + n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  VL xs(N*2);\n  REP(i,N){\n\tcin >> xs[i];\n\txs[i+N] = xs[i];\n  }\n  VL acc(2*N+1);\n  REP(i,N*2) acc[i+1] = acc[i] + xs[i];\n\n  LL lb = 0, ub = 1e18;\n  while(ub-lb > 1){\n\tLL m = (lb + ub) / 2;\n\tbool ok = false;\n\tREP(i,N){\n\t  int b1 = lower_bound(begin(acc)+i, end(acc), acc[i]+m) - begin(acc);\n\t  if(b1 == 2*N+1) continue;\n\t  int b2 = lower_bound(begin(acc)+b1, end(acc), acc[b1]+m) - begin(acc);\n\t  if(b2 == 2*N+1) continue;\n\t  int b3 = lower_bound(begin(acc)+b2, end(acc), acc[b2]+m) - begin(acc);\n\t  if(b3 == 2*N+1) continue;\n\t  if(b3-i <= N){\n\t\tok = true;\n\t\tbreak;\n\t  }\n\t}\n\tif(ok) lb = m;\n\telse ub = m;\n  }\n  cout << lb << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <complex>\nusing namespace std;\ntypedef complex<double> dcomplex;\ninline int toInt(std::string s) {int v; std::istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline std::string toString(T x) {std::ostringstream sout;sout<<x;return sout.str();}\n\n//ラジアンを度に変換-----------------------------------------------------\ndouble rad_deg(double rad){\n\tif(rad >= 0)return rad*180.0/acos(-1);\n\telse return (2*acos(-1)+rad)*180/acos(-1);\n}\n\nint main(void){\n\tdouble pi = acos(-1);\n\t//入力--------------------------------------------------------------\n\tint N;\n\tcin >> N;\n\tint data[N];\n\tlong int sum = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\t//極座標の保持\n\tdcomplex pol[N];\n\tdouble sum_t = 0;\n\tdouble sumlist[N+1];\n\tfor(int i=0; i<N; i++){\n\t\tpol[i] = polar(1.0,2.0*pi*sum_t/sum);\n\t\tsumlist[i] = rad_deg(arg(pol[i]));\n\t\tsum_t += data[i];\n\t}\n\tsumlist[N] = 360.0;\n\t//適当なmin_argを与える----------------------------------------------\n\tdouble min_arg = 0;\n\tdcomplex p = pol[0];\n\tdcomplex q,r;\n\tdouble theta1 = 0,theta2,theta3;\n\tdouble a,b,d;\n\tint tmp;\n\tfor(int i=1;i<N;i++){\n\t\tq = pol[i];\n\t\tif (rad_deg(arg(q)) >= 120){\n\t\t\ttheta2 = rad_deg(arg(q));\n\t\t\ta = theta2 - theta1;\n\t\t\ttmp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int k=tmp; k<N; k++){\n\t\tr = pol[k];\n\t\ttheta3 = rad_deg(arg(r));\n\t\tb = theta3 - theta2;\n\t\td = 360-a-b;\n\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\tif(d < b) break;\n\t}\n\tcout << min_arg << endl;\n\t\n\t//ループ処理--------------------------------------------------------------\n\tint tmp0 = 0;\n\tint tmp1 = 1;\n\tint tmp2 = 2;\n\ta = sumlist[tmp1] -sumlist[tmp0];\n\tb = sumlist[tmp2] - sumlist[tmp1];\n\td = 360.0 - sumlist[tmp2] +sumlist[tmp0];\n\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\n\twhile(tmp0 < round(N/2.0) && tmp2 < N && tmp1 < tmp2){\n\t\ttmp1 = tmp0 + 1;\n\t\ttmp2 = tmp1 + 1;\n\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\twhile(d >= min_arg && tmp2 < N-1){\n\t\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg){\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse if(sumlist[tmp1] - sumlist[tmp0] < min_arg){\n\t\t\t\ttmp1 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp2 += 1;\n\t\t\t\ta = sumlist[tmp1] - sumlist[tmp0];\n\t\t\t\tb = sumlist[tmp2]-sumlist[tmp1];\n\t\t\t\td = 360.0 - sumlist[tmp2] + sumlist[tmp0];\n\t\t\t\tmin_arg = max(min_arg, min(d,min(a,b)));\n\t\t\t}\n\t\t}\n\t\ttmp0 += 1;\n\t}\n\n\tcout << (long int)(round((min_arg/360.0)*sum)) << endl;;\n\t\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(ll l, ll r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, ll s) {\n    ll n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    return P((s+r)%n, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d; tie(pos, d) = search(m, i); sd += d;\n            P p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            if (sd <= L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\nint n;\nvector<int> v(100000);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint main(){\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  REP(i, 100){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%d\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a[200007],sum=0,pref[200007],ans=0;\nint check(int start,int fs,long long val){\n    int l=start;\n    int r=fs;\n    int mid=(l+r)/2;\n    if(val>sum/3) return 0;\n    while(l!=mid && r!=mid){\n        if(pref[mid]-pref[start-1]>=val) r=mid;\n        else l=mid+1;\n        mid=(l+r)/2;\n    }\n    for(int i=l;i<=r;i++){\n        if(pref[i]-pref[start-1]>=val){\n            if(sum-val-(pref[i]-pref[start-1])>=val) return 1;\n        }\n    }\n    return 0;\n}\nlong long sol(int pos,int stat){\n    int l=pos;\n    int r=stat-2;\n    int mid=(l+r)/2;\n    while(l!=mid && r!=mid){\n        if(check(mid+1,stat,pref[mid]-pref[pos-1])==1) l=mid;\n        else r=mid-1;\n        mid=(l+r)/2;\n    }\n    for(int i=r;i>=l;i--){\n        if(check(i+1,stat,pref[i]-pref[pos-1])==1) return pref[i]-pref[pos-1];\n    }\n    return -1;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n        sum+=a[i];\n        pref[i]=pref[i-1]+a[i];\n    }\n    for(int i=1;i<=n;i++){\n        a[i+n]=a[i];\n        pref[i+n]=pref[i+n-1]+a[i+n];\n    }\n    for(int i=n;i<=n+n-1;i++){\n        long long ps=sol(i-n+1,i);\n        ans=max(ans,ps);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r] - AA[l-1];\n\t\telse sum = AA[r];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r+1; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif(AA[CC-1] - AA[r] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    やるだけでバグって辛い\n */\n\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\nint n;\nint a[100000];\nint pos[100000];\nlong long int low;\nlong long int high;\nlong long int sum;\n\nbool check(long long int x) {\n    int s = 0;\n    int t = 0;\n    long long int now = 0;\n\n    while (s < n) {\n        while ((t+1)%n != s && now < x) {\n            now += a[t];\n            t = (t+1)%n;\n        }\n        if ((t+1)%n == s) return false;\n        pos[s] = t;\n        now -= a[s++];\n    }\n\n    for (int i=0; i<n; i++) {\n        int len1 = pos[i] - i;\n        int len2 = pos[pos[i]] - pos[i];\n        int len3 = pos[pos[pos[i]]] - pos[pos[i]];\n\n        if (len1 < 0) len1 += n;\n        if (len2 < 0) len2 += n;\n        if (len3 < 0) len3 += n;\n        if (len1 + len2 +len3 <= n) return true;\n    }\n\n    return false;\n}\n    \n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i=0; i<n; i++) {\n        scanf(\"%d\", &a[i]);\n        sum += a[i];\n    }\n\n    low = -1;\n    high = (sum/3) + 1;\n    while (high - low > 1) {\n        long long int mid = (high+low)/2;\n        if (check(mid)) low = mid;\n        else high = mid;\n    }\n\n    printf(\"%lld\\n\", low);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  ll n;\n  scanf(\"%lld\",&n);\n  vector<ll> a(n*2),sum(n*2+1,0);\n  for(int i=0;i<n;i++){\n    scanf(\"%lld\",&a[i]);\n    a[n+i] = a[i];\n  }\n  for(int i=0;i<2*n;i++)sum[i+1] = sum[i] + a[i];\n\n  ll ans = 0;\n\n  int l=0, r=0;\n  while(l<n){\n    while(r<l+n-1 && 3*(sum[r]-sum[l])<=sum[n])r++; r--;\n    if(r-l>1){\n      ll cur = sum[r]-sum[l], rem = sum[n]-cur;\n      int L=r, R=l+n;\n      while(R-L>1){\n\tll M = (L+R)/2;\n\tif(2*(sum[M]-sum[r])<rem)L = M;\n\telse R = M;\n      }\n\t\n      ll minv = 0;\n      if(R<l+n && r<R)minv = max(minv, min(sum[R]-sum[r], sum[l+n]-sum[R]));\n      if(R-1<l+n && r<R-1)minv = max(minv, min(sum[R-1]-sum[r], sum[l+n]-sum[R-1]));\n      minv = min(minv, cur);\n      ans = max(ans, minv);\n    }\n    l++; if(r<l)r++;\n  }\n\n  printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1 << 30;\nvector<long long int> baum;\nlong long int n, ans, minma = INF;\nlong long int Baum = 0, Baum3 = 0;\n\nvoid cut(long long int f) {\n\tlong long int s = f + Baum3, t = s + Baum3;\n\tlong long int p;\n\tlong long int sp[3] = {}, tp[3] = {};\n\tp = lower_bound(baum.begin(), baum.end(), s) - baum.begin();\n\tif (s == baum[p]) {\n\t\tsp[0] = baum[p + 1];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = baum[p];\n\t}\n\telse {\n\t\tsp[0] = baum[p];\n\t\tsp[1] = baum[p - 1];\n\t\tsp[2] = INF;\n\t}\n\tp = lower_bound(baum.begin(), baum.end(), t) - baum.begin();\n\tif (t == baum[p]) {\n\t\ttp[0] = baum[p + 1];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = baum[p];\n\t}\n\telse {\n\t\ttp[0] = baum[p];\n\t\ttp[1] = baum[p - 1];\n\t\ttp[2] = INF;\n\t}\n\tfor (int i = 0; i <= 2; i++) {\n\t\tif (sp[i] == INF) break;\n\t\tminma = sp[i] - f;\n\t\tfor (int j = 0; j <= 2;j ++){\n\t\t\tif (tp[j] == INF) break;\n\t\t\tminma = min( minma, min( tp[j] - sp[i], Baum - tp[j] + f ));\n\t\t\tans = max(ans, minma);\n\t\t\tminma = sp[i]-f;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tbaum.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint in;\n\t\tcin >> in;\n\t\tBaum += in;\n\t\tbaum.push_back(in);\n\t}\n\tbaum.push_back(baum[1]);\n\tBaum3 = Baum / 3;\n\n\tfor (int i = 2; i <= n+1; i++) {\n\t\tbaum[i] += baum[i - 1];\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tif (baum[i] > Baum3) break;\n\t\tcut(baum[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//初めての尺取り\n\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\n#define GOMAE (long long)50000\n#define EPS (long long)4000\n#define TO_OUTSIDE (long long)1500\n#define IS_NOT_EVEN_HOBBY (long long)573\nint N;\nlong long input;\nlong long A[300010];\nlong long ans;\n\n//A[i]-A[st] >= A[ed]-A[i]となる最小のiを返す。\nint seach1( int st, int ed, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= A[ed]-A[i] )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n//A[i]-A[st] >= Xとなる最小のiを返す。\nint seach2( int st, int ed, long long X, int i ){\n\t\n\tfor( ; i < ed; i++ ){\n\t\tif( A[i]-A[st] >= X )\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nint solve( long long X ){\n\tint i,j=0,k=0;\n\t\n\tif( X >= (A[N]>>1) )\n\t\treturn 0;\n\tfor( i = 0; i < N; i++ ){\n\t\t//大きさがX以上になるように切る\n\t\tj = seach2(i,N+i,X,j);\n\t\t//できるだけ真ん中で切る\n\t\tk = seach1(j,N+i,k);\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t\tk--;\n\t\tif( min( A[j]-A[i], min( A[k]-A[j], A[i+N]-A[k] ) ) >= X )\n\t\t\tbreak;\n\t}\n\tif( i < N )\n\t\treturn 1;\n\treturn 0;\n}\n\t\t\t\t\nint main(){\n\tint i,j,k;\n\tlong long s = 0, e = GOMAE * EPS * TO_OUTSIDE * IS_NOT_EVEN_HOBBY * EPS;\n\tscanf(\"%d\",&N);\n\tif( N > 100000 )\n\t\treturn 0;\n\t\t\n\tfor( i = 1; i < N+1; i++ ){\n\t\tscanf(\"%d\",&input);\n\t\tA[i] = A[i-1]+input;\n\t}\n\tfor( i = N+1; i < 3*N+1; i++ ){\n\t\tA[i] = A[i-N] + A[N];\n\t}\n\t\n\t//printf(\"%lld %lld\\n\",s,e);\n\twhile( s <= e ){\n\t\tans = (s+e)>>1;\n\t\tif( solve(ans) ){\n\t\t\tif( solve(ans+1) )\n\t\t\t\ts = ans+1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\te = ans-1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\tint k = max(j + 1, min(sep, n - 1));\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\t\tfor (int j = i + 1; j <= n + i + 1; j++) {\n\t\t\tif (s[(j - 1) % n - 1] >= B) { B2 = s[(j - 1) % n - 1]; d = (j - 1) % n - 1; break; }\n\t\t}\n\t\tfor (int j = i + 1; j <= n + i + 1; j++) {\n\t\t\tif (s[(j - 1) % n - 1] >= C) { C2 = s[(j - 1) % n - 1]; e = (j - 1) % n - 1; break; }\n\t\t}\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long int lis[200005]={0},rui[200005]={0};\nint main(){\n    long long int N;\n    cin>>N;\n    for(int i=0;i<N;i++)cin>>lis[i];\n    for(int i=0;i<N;i++){\n        lis[N+i]=lis[i];\n    }\n    for(int i=0;i<N*2+1;i++){\n        if(i==0)rui[i]=lis[i];\n        else rui[i]=rui[i-1]+lis[i];\n    }\n    long long int maxans=0;\n    rui[2*N]=1000000000000000000;rui[2*N+1]=1000000000000000000;rui[2*N+2]=1000000000000000000;rui[2*N+3]=1000000000000000000;\n    for(int i=0;i<N;i++){\n        long long int l=0,r=10000000000000000,mid=(l+r)/2;\n        for(int j=0;j<55;j++){\n            mid=(l+r)/2;\n            long long int ll=i,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(i!=0){\n                    if(rui[midmid]-rui[i-1]>=mid)rr=midmid;\n                    else ll=midmid;\n                }\n                else if(rui[midmid]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            int memo=rr+1;\n            ll=rr,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(rui[midmid]-rui[memo-1]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            memo=rr+1;\n            ll=rr,rr=2*N+1,midmid=(ll+rr)/2;\n            for(int k=0;k<18;k++){\n                midmid=(ll+rr)/2;\n                if(rui[midmid]-rui[memo-1]>=mid)rr=midmid;\n                else ll=midmid;\n            }\n            if(rr<2*N&&rr-i<N)l=mid;\n            else r=mid;\n        }\n        maxans=max(maxans,mid);\n    }\n    cout<<maxans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n;\nVI manysize;\n\nvoid solve() {\n\tint num = n / 3;\n\tLL size1 = 0, size2 = 0, size3 = 0;\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize1 += manysize[ i ];\n\t}\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize2 += manysize[ i + num ];\n\t}\n\tfor ( int j = num * 2; j < n; j++ ) {\n\t\tsize3 += manysize[ j ];\n\t}\n\tLL ans = min( size1, min( size2, size3 ) );\n\tint now1 = num, now2 = num * 2, now3 = 0;\n\tset < pair<int, PII> > s;\n\twhile ( !s.count( MP( now1, MP( now2, now3 ) ) ) ) {\n\t\ts.insert( MP( now1, MP( now2, now3 ) ) );\n\t\tif ( size3 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size3 );\n\t\t\tsize3 += manysize[ now3 ];\n\t\t\tsize1 -= manysize[ now3 ];\n\t\t\tnow3++;\n\t\t\tnow3 %= n;\n\t\t}\n\t\telse if ( size2 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size2 );\n\t\t\tsize2 += manysize[ now2 ];\n\t\t\tsize3 -= manysize[ now2 ];\n\t\t\tnow2++;\n\t\t\tnow2 %= n;\n\t\t}\n\t\telse {\n\t\t\tans = max( ans, size1 );\n\t\t\tsize1 += manysize[ now1 ];\n\t\t\tsize2 -= manysize[ now1 ];\n\t\t\tnow1++;\n\t\t\tnow1 %= n;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\t\n#endif\n\tcin >> n;\n\tmanysize.resize( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> manysize[ i ];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n;\nvector < int > a;\nvector<long long int > pr;\nbool check2(int k,int now,long long int m)\n{\n\tif (pr[now] - pr[k] >= m)return true;\n\treturn false;\n}\nbool check(int i,long long int m)\n{\n\tint r = i+n-1, l = i;\n\twhile (r != l)\n\t{\n\t\tint now = (r + l) / 2;\n\t\tif (check2(i,now,m))\n\t\t{\n\t\t\tr = now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = now+1;\n\t\t}\n\t}\n\tr = i + n - 1;\n\tint hoge = l;\n\twhile (r != l)\n\t{\n\t\tint now = (r + l) / 2;\n\t\tif (check2(hoge, now, m))\n\t\t{\n\t\t\tr = now;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl = now+1;\n\t\t}\n\t}\n\tif (pr[i + n - 1] - pr[r] >= m)return false;\n\treturn true;\n}\n\nint main()\n{\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\ta.push_back(x);\n\t\t(i == 0) ? pr.push_back(x) : pr.push_back(x + pr[i - 1]);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ta.push_back(a[i]);\n\t\tpr.push_back(pr.back() + a[i]);\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong long int r = 0, l = 50000000;\n\t\twhile (r != l)\n\t\t{\n\t\t\tlong long int m = (r + l) / 2;\n\t\t\tif (check(i,m))\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m+1;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, l);\n\t}\n\tcout << ans+1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint b;\nint c;\nint d;\nint e;\nint f;\nint ushi;\nint uma;\nint j;\n\nint main(){\n  cin>>n;\n  int a[300000];\n  int z[300000];\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a[i];\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<=c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d];\n    d=d-1;\n    while(e<c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}\n  }\n  b=0;\n  c=0;\n  e=0;\n  f=0;\n  d=0;\n  for(int m;m<n;m++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    };\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    e=e-a[d];\n    f=c-b-e;\n    if(f>b){\n      z[m]=b;\n    }else{\n      z[m]=f;}     \n  }\n  ushi=2*n-1;\n  uma=z+2*n;\n  sort(z,uma);\n  cout<<z[ushi]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1L << (x))\nusing ll = long long;\nusing namespace std;\n\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\n \ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n    return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> a(2 * n), s(2 * n + 1, 0);\n\n    REP(i, n) {\n        cin >> a[i];\n        a[i + n] = a[i];\n    }\n\n    REP(i, 2 * n) {\n        s[i + 1] = s[i] + a[i];\n    }\n    \n    auto check = [&](ll x) {\n        REP(i, n) {\n            int j = lower_bound(s.begin() + i, s.end(), s[i] + x) - s.begin();\n            int k = lower_bound(s.begin() + j, s.end(), s[j] + x) - s.begin();\n\n            if (j < n + i && k < n + i && s[n + i] - s[k] >= x) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    ll l = 0, r = 1e15;\n    while (r - l > 1) {\n        ll m = (r + l) / 2;\n\n        if (check(m)) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n\n    cout << l << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\tint sep = lower_bound(all(cuts), cuts[j] + rem) - cuts.begin();\n\t\t\tint k = min(sep, n);\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\nstatic const int MAX_N = 100000;\ntypedef pair<int,int> pii;\n\nint N;\nint A[MAX_N];\nint V[MAX_N];\nint ans=0;\n\nint binary(int l,int r,int res){\n    int mid=(l+r)/2;\n    for(int i=0;i<20;++i){\n        mid=(l+r)/2;\n        if(V[mid]>res)r=mid;\n        else l=mid;\n    }\n    return l;\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        cin>>A[i];\n    }\n    for(int i=0;i<N;++i){\n        if(i==0)V[i]=A[i];\n        else V[i]=V[i-1]+A[i];\n    }\n    for(int i=N;i<2*N;++i)V[i]=V[i-1]+A[i-N];\n    int mid = V[N-1]/3;\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    for(int i=0;i<N;++i){\n        int r = i+N;\n        int p1;\n        if(i==0)p1=binary(i,r,mid);\n        else p1=binary(i,r,mid+V[i-1]);\n        p1--;\n        int mina;\n        if(i==0)mina=V[p1];\n        else mina=V[p1]-V[i-1];\n        int p2=binary(p1+1,r,mid+V[p1]);\n        int minb,minc;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n        p2++;\n        minb=V[p2]-V[p1];\n        minc=V[N-1]-(mina+minb);\n        if(minb>=mina&&minc>=mina)ans=max(mina,ans);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF (1e+15)\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\n  int n, a[100001];\n  ll ssum[100001*2] = {0};\n  \n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  \n  ssum[0] = a[0];\n  for(int i = 1; i < n*2; i++) ssum[i] = ssum[i - 1] + a[i % n];\n  \n  ll al = 0, ar = INF, amid;\n  int c2;\n  while(al < ar){\n    amid = ((al + 1) + ar) / 2;          //解を二分探索\n    bool judge = false;\n    for(int i = 0; i < n; i++){\n      int l = i, r = n + i;              //添字を二分探索\n      while(l < r){\n        int mid = (l + r) / 2;\n        ll sub = ssum[mid] - ssum[i];\n        if(sub < amid) l = mid + 1;\n        else r = mid;\n      }\n      c2 = l++;\n      r = n + i;\n      while(l < r){\n        int mid = (l + r) / 2;\n        ll sub = ssum[mid] - ssum[c2];\n        if(sub < amid) l = mid + 1;\n        else r = mid;\n      }\n\n      if(ssum[i + n] - ssum[r] >= amid){\n        judge = true;\n        break;\n      }\n    }\n    if(judge) al = amid;\n    else ar = amid - 1;\n  }\n  cout << al << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long int n;\nvector<long long int> v;\nlong long int ans;\n\nbool cut(long long int x){\n\tbool f = false;\n\tfor(int i=0; i<n; i++){\n\t\tint j, k;\n\t\tj = lower_bound(v.begin(), v.end(), v[i]+x)-v.begin();\n\t\tk = lower_bound(v.begin(), v.end(), v[j]+x)-v.begin();\n//\t\tif(x == 6) printf(\"%lld %lld %d %d %d\\n\", v[i]+x, v[j]+x, i, j, k);\n\t\tif(v[i+n] - v[k] >= x){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn f;\n}\n\nlong long int solve(){\n\tlong long int l = 0;\n\tlong long int r = 1000000000 * n + 1;\n\twhile(r - l > 1){\n//\t\tprintf(\"%lld %lld\\n\", l, r);\n\t\tlong long int m = (l + r) / 2;\n\t\tif(cut(m)) l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n\nint main(){\n\tscanf(\"%lld\", &n);\n\tv.push_back(0);\n\tfor(int i=0; i<n; i++){\n\t\tlong long int t;\n\t\tscanf(\"%lld\", &t);\n\t\tv.push_back(t);\n\t}\n\tfor(int i=1; i<n+1; i++) v.push_back(v[i]);\n\tfor(int i=1; i<2*n+2; i++) v[i] += v[i-1];\n\n//\tfor(int i=0; i<v.size(); i++) printf(\"%lld\\n\", v[i]);\n\tprintf(\"%lld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint D;\nint N;\nlong long val[200010];\n\nlong long cal(int s,int t){ // [s,t]\n\tif( s > t ){ t += N; }\n\treturn val[t] - (s?val[s-1]:0);\n}\nint cut(int x,long long lim){\n\tint D = x+N;\n\tlong long subval = x ? val[x-1] : 0;\n\tint idx1 = lower_bound(val+x,val+D,lim+subval) - val;\n\tif( idx1 >= D ) return 0;\n\tint idx2 = lower_bound(val+x,val+D,val[idx1]+lim) - val;\n\tif( idx2 >= D ) return 0;\n\t\n\treturn val[D-1] - val[idx2] >= lim;\n}\nint main(){\n\tcin >> N;\n\n\tfor(int i = 0 ; i < N ; i++) cin >> val[i], val[i+N] = val[i];\n\tfor(int i = 1 ; i < 2*N ; i++) val[i] += val[i-1];\n\tlong long answer = 0;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tlong long le = 1;\n\t\tlong long ri = 1e15;\n\t\twhile( le != ri ){\n\t\t\tlong long mi = (le+ri+1) / 2;\n\t\t\tif( cut(i,mi) ){\n\t\t\t\tle = mi;\n\t\t\t}else{\n\t\t\t\tri = mi-1;\n\t\t\t}\n\t\t}\n\t\tanswer = max(answer,le);\n\t}\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e16;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX], total;\n\nint solve(ll m, int n){\n\tint r = 0, l1 = 1, l2 = 1;\n\tll sum = 0;\n\t\n\twhile(r < n){\n\t\twhile(a[l1]-a[r] < m){\n\t\t\tif(a[l1] == INF)break;\n\t\t\tl1++;\n\t\t}\n\t\twhile(a[l2]-a[l1] < m){\n\t\t\tif(a[l2] == INF)break;\n\t\t\tl2++;\n\t\t}\n\t\tif(a[l1] == INF || a[l2] == INF)return 1;\n\t\t\n\t\tif(total-(a[l2]-a[r]) >= m)return 0;\n\t\telse{\n\t\t\tr++;sum += a[r];\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t}\n\ta[0] = 0;\n\ttotal = a[n];\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tint Left,Right,Mid;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\n\t\tLeft=i;Right=n+2;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[Mid + 1]>B){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[Mid]<B){\n\t\t\t\tLeft=Mid;\n\t\t\t}\n\t\t}\n\n\t\tB2 = s[(Mid - 1) % n + 1]; d = (Mid - 1) % n + 1;\n\n\t\tLeft=i;Right=n+2;\n\n\t\tfor(int j=0;j<100;j++){\n\t\t\tMid=(Left+Right)/2;\n\t\t\tif(s[Mid + 1]>C){\n\t\t\t\tRight=Mid;\n\t\t\t}\n\t\t\tif(s[Mid]<C){\n\t\t\t\tLeft=Mid;\n\t\t\t}\n\t\t}\n\n\t\tC2 = s[(Mid - 1) % n + 1]; d = (Mid - 1) % n + 1;\n\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nusing namespace std;\n\nint main(){\n\tint n;\n\tunsigned int a[125000][2] = { 0 }, baum, b[4][3] = { 0 }, minb, ans = 0;\n\tcin >> n;\n\tcin >> a[0][0];\n\ta[0][1] = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tcin >> a[i][0];\n\t\ta[i + n][0] = a[i][0];\n\t\ta[i][1] = a[i - 1][1] + a[i - 1][0];\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\ta[i + n][1] = a[i + n - 1][1] + a[i + n - 1][0];\n\t}\n\tbaum = a[n - 1][1] + a[n - 1][0];\n\tfor (int cut1 = 0; cut1 < n; cut1++){\n\t\tint cut2, cut3_1, cut3_2, b1, b2_1, b2_2;\t//cut??????????????????????????????????????????????????¢??????\n\t\tfor (cut2 = cut1 + 1; cut2 < cut1 + n; cut2++){\n\t\t\tif ((b1 = a[cut2][1] - a[cut1][1]) > baum / 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_1 = cut2; cut3_1 < cut2 - 1 + n; cut3_1++){\n\t\t\tif ((b2_1 = a[cut3_1][1] - a[cut2 - 1][1]) > (baum - (b1 - a[cut2 - 1][0])) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (cut3_2 = cut2 + 1; cut3_2 <cut2 + n; cut3_2++){\n\t\t\tif ((b2_2 = a[cut3_2][1] - a[cut2][1]) > (baum - b1) / 2){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tb[0][0] = b1 - a[cut2 - 1][0];\n\t\tb[0][1] = b2_1 - a[cut3_1 - 1][0];\n\t\tb[0][2] = baum - b1 - b2_1 + a[cut2 - 1][0] + a[cut3_1 - 1][0];\n\t\tb[1][0] = b1 - a[cut2 - 1][0];\n\t\tb[1][1] = b2_1;\n\t\tb[1][2] = baum - b1 - b2_1 + a[cut2 - 1][0];\n\t\tb[2][0] = b1;\n\t\tb[2][1] = b2_2 - a[cut3_2 - 1][0];\n\t\tb[2][2] = baum - b1 - b2_2 + a[cut3_2 - 1][0];\n\t\tb[3][0] = b1;\n\t\tb[3][1] = b2_2;\n\t\tb[3][2] = baum - b1 - b2_2;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tminb = MIN(MIN(b[i][0], b[i][1]), b[i][2]);\n\t\t\tif (ans < minb){\n\t\t\t\tans = minb;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n) REP(k, j + 1, n)\n\t\t{\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 200004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e14;\n//__gcd(a,b), __builtin_popcount(a);\n\nll a[MAX];\n\nint solve(ll m, int n){\n\tint l, r = 0, flag = 1;\n\tl = lower_bound(a, a+MAX, m)-a;\n\tll sum = 0, s1, s2, s3;\n\t\n\twhile(r < n){\n\t\ts1 = *lower_bound(a, a+MAX, sum+m);\n\t\tif(s1 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts2 = *lower_bound(a, a+MAX, s1+m);\n\t\tif(s2 == INF){\n\t\t\tr++;sum += a[r];\n\t\t\tcontinue;\n\t\t}\n\t\ts3 = lower_bound(a, a+MAX, s2+m)-a;\n\t\tif(s3 <= r+n){\n\t\t\t//printf(\"%lld %d\\n\", m, s3);\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tr++;\n\t\t\tsum += a[r];\n\t\t}\n\t}\n\t\n\treturn flag;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfill(a, a+MAX, INF);\n\trrep(i,n){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n+i] = a[i];\n\t}\n\tfor(int i = 2;i <= 2*n;i++){\n\t\ta[i] += a[i-1];\n\t\t//printf(\"%d \", a[i]);\n\t}\n\t/*int ans = lower_bound(a, a+MAX, 50)-a;\n\tprintf(\"%d \", ans);*/\n\t\n\tll vl = 0, vr = INF;\n\twhile(vr-vl > 1){\n\t\tll mid = (vr+vl)/2;\n\t\tint f = solve(mid, n);\n\t\tif(f)vr = mid;\n\t\telse vl = mid;\n\t\t/*if(mid == 6){\n\t\t\tprintf(\"*%d %d*\\n\", vl, vr);\n\t\t}*/\n\t}\n\tprintf(\"%lld\\n\", vl);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 200005;\n\nll a[MAX_N];\nint n;\n\nbool possible(ll cri)\n{\n\tll asum[3];\n\tasum[0] = asum[1] = asum[2] = 0;\n\tint r=0;\n\tint rr[2];\n\trep(i,2){\n\t\twhile(asum[i] < cri && r<n){\n\t\t\tasum[i] += a[r];\n\t\t\tr++;\n\t\t}\n\t\tif(r>=n){\n\t\t\tbreak;\n\t\t}\n\t\trr[i] = r;\n\t}\n\tfor(;r<n;r++){\n\t\tasum[2] += a[r];\n\t}\n\tif(asum[2] >= cri){\n\t\treturn true;\n\t}\n\trep(i,n){\n\t\tasum[0] -= a[i];\n\t\trep(j,2){\n\t\t\tr = rr[j];\n\t\t\twhile(asum[j] < cri && r<n+i+1){\n\t\t\t\tasum[j] += a[r];\n\t\t\t\tasum[j+1] -= a[r];\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif(r>n+i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trr[j] = r;\n\t\t}\n\t\tif(r<n+i+1){\n\t\t\tasum[2] += a[n+i];\n\t\t}\n\t\tif(asum[2] >= cri){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\ta[i+n] = a[i];\n\t}\n\tll asum = accumulate(a,a+n,0);\n\tll amin = *(min_element(a,a+n));\n\tll h=asum/3+1;\n\tll l=amin-1;\n\tll ans;\n\twhile(1){\n\t\tll mid = (l+h)/2;\n\t\tif(l==mid){\n\t\t\tans = mid;\n\t\t\tbreak;\n\t\t}\n\t\tif(possible(mid)){\n\t\t\tl = mid;\n\t\t}else{\n\t\t\th = mid;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\n#define Input(x) scanf(\"%lld\",&x);\n\nll n;\nll a[234567];\nll sum[234567];\n\nbool cond(int index,ll limit)\n{\n\tint nowind = index;\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\tnowind = lower_bound(sum + nowind, sum + n + n + 1, sum[nowind] + limit) - sum;\n\tif (nowind > index + n)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tInput(n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tInput(a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\tsum[0] = 0;\n\tfor (int i = 1; i <= 2 * n; ++i)\n\t{\n\t\tsum[i] = sum[i - 1] + a[i - 1];\n\t}\n\tll answer = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tll cmin = 0, cmax = sum[n];\n\t\tfor (int j = 0; j < 100; ++j)\n\t\t{\n\t\t\tll find = (cmin + cmax) / 2;\n\t\t\tif (cond(i, find))\n\t\t\t{\n\t\t\t\tcmin = find;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmax = find;\n\t\t\t}\n\t\t\tif (cmax - cmin <= 1)break;\n\t\t}\n\t\tanswer = max(answer, cmin);\n\t}\n\tprintf(\"%lld\\n\", answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tcin >> inputBuffer;\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nvoid InitRand()\n{\n\tsrand((unsigned int)time(NULL));\n}\nint Dice()\n{\n\treturn rand() % N;\n}\nint main()\n{\n\tInitRand();\n\tint cou;\n\tint i, j, k;\n\tll ans = 0;\n\tll sum1, sum2, sum3;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < N; i++)AA[i] = AA[i - 1] + A[i];\n\tfor (cou = 0; cou < 3000000; cou++){\n\t\t//if (cou % 100000 == 99999)printf(\"%d\\n\", cou);\n\t\tsum1 = sum2 = sum3 = 0;\n\t\ti = Dice(); j = Dice(); k = Dice();\n\t\tif (i == j || j == k || i == k)continue;\n\t\tif (i>j)swap(i, j);\n\t\tif (i>k)swap(i, k);\n\t\tif (j>k)swap(j, k);\n\t\tif(i!=0)sum1 += AA[i - 1];\n\t\tsum2 += AA[j-1] - AA[i - 1];\n\t\tsum3 += AA[k-1] - AA[j - 1];\n\t\tsum1 += AA[N-1] - AA[k - 1];\n\t\tans = max(ans, min(sum1, min(sum2, sum3)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\n#ifndef  LLONG_MAX\n#define LLONG_MAX 9223372036854775807\n#endif\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left > 2) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll L;\nvector<ll> a, x;\nll len(ll l, ll r) {\n    ll s = x[l], t = x[r];\n    if (r < l) return L - abs(s - t);\n    return abs(s - t);\n}\nP search(ll th, ll s) {\n    ll n = a.size();\n    ll l = 0, r = n;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        if ( len(s, (s+m)%n) >= th ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    return P((s+r)%n, len(s, (s+r)%n));\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    a.assign(n, 0); cin >> a;\n    x.assign(n, 0); REP(i, n-1) x[i+1] = x[i] + a[i];\n    L = 0; REP(i, n) L += a[i];\n    ll l = 0, r = L;\n    while (r - l > 1) {\n        ll m = (l + r)/2;\n        bool f = false;\n        REP(i, n) {\n            ll sd = 0;\n            ll pos, d; tie(pos, d) = search(m, i); sd += d;\n            P p = search(m, pos); tie(pos, d) = p; sd += d;\n            p = search(m, pos); tie(pos, d) = p; sd += d;\n            sd += len(pos, i);\n            if (sd == L) {\n                f = true;\n                break;\n            }\n        }\n        if (f) {\n            l = m;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lld;\nlld N;\nlld A[200010];\nlld sum[200010];\n\nbool solve(lld mid){\n  for(int i=0;i<N;i++){\n    int a = distance(sum,lower_bound(sum+i+1,sum+N+i+1,sum[i] + mid));\n    if(a == N + i + 1) continue;\n    int b = distance(sum,lower_bound(sum+a+1,sum+N+i+1,sum[a] + mid));\n    if(b == N + i + 1) continue;\n    int c = distance(sum,lower_bound(sum+b+1,sum+N+i+1,sum[b] + mid));\n    if(c == N + i + 1) continue;\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    cin >> A[i];\n    A[N+i] = A[i];\n  }\n  sum[0] = A[0];\n  for(int i=1;i<2*N;i++){\n    sum[i] = sum[i-1] + A[i];\n  }\n  lld left = 0, right = sum[2*N-1] / 3;\n  while(left != right){\n    lld mid = (left + right + 1) / 2;\n    if(solve(mid) == true) left = mid;\n    else right = mid - 1;\n  }\n  cout << left << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<numeric>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nint n;\nvector<ll> a;\nll sum = 0;\n\nbool f(ll x){\n    for(int i = 1; i <= n; i++){\n        auto first = lower_bound(a.begin(), a.end(), a[i-1]+x);\n        if(first == a.end())    continue;\n        ll s = *first-a[i-1];\n        auto second = lower_bound(a.begin(), a.end(), *first+x);\n        if(second == a.end())   continue;\n        ll t = *second-*first;\n        if(sum-s-t >= x)    return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> n;\n\n    a.resize(n+1);\n    a[0] = 0;\n    for(int i = 0; i < n; i++)  cin >> a[i+1];\n\n    sum = accumulate(a.begin(), a.end(), 0ll);\n    ll l = 1, r = sum/3;\n\n    for(int i = 0; i < n; i++)  a[i+1] += a[i];\n\n    while(r-l > 1){\n        ll mid = (l+r)/2;\n        if(f(mid))  l = mid;\n        else        r = mid;\n    }\n\n    cout << l << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n;\nVI manysize;\n\nvoid solve() {\n\tint num = n / 3;\n\tint size1 = 0, size2 = 0, size3 = 0;\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize1 += manysize[ i ];\n\t}\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize2 += manysize[ i + num ];\n\t}\n\tfor ( int j = num * 2; j < n; j++ ) {\n\t\tsize3 += manysize[ j ];\n\t}\n\tint ans = min( size1, min( size2, size3 ) );\n\tint now1 = num, now2 = num * 2, now3 = 0;\n\tset < pair<int, PII> > s;\n\twhile ( !s.count( MP( now1, MP( now2, now3 ) ) ) ) {\n\t\ts.insert( MP( now1, MP( now2, now3 ) ) );\n\t\tif ( size3 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size3 );\n\t\t\tsize3 += manysize[ now3 ];\n\t\t\tsize1 -= manysize[ now3 ];\n\t\t\tnow3++;\n\t\t\tnow3 %= n;\n\t\t}\n\t\telse if ( size2 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size2 );\n\t\t\tsize2 += manysize[ now2 ];\n\t\t\tsize3 -= manysize[ now2 ];\n\t\t\tnow2++;\n\t\t\tnow2 %= n;\n\t\t}\n\t\telse {\n\t\t\tans = max( ans, size1 );\n\t\t\tsize1 += manysize[ now1 ];\n\t\t\tsize2 -= manysize[ now1 ];\n\t\t\tnow1++;\n\t\t\tnow1 %= n;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\t\n#endif\n\tcin >> n;\n\tmanysize.resize( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> manysize[ i ];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\n\nint N;\nll A[200000];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    ll sum = 0;\n    for(int i=0;i<N;i++){\n        scanf(\"%lld\", A+i);\n        A[i+N] = A[i];\n        sum += A[i];\n    }\n\n    for(int i=1;i<2*N;i++){\n        A[i] += A[i-1];\n    }\n\n    ll res = 0ll;\n    for(int i=0;i<N;i++){\n        ll lb = 0, ub = sum;\n        while(ub-lb > 1){\n            ll mid = (lb+ub) / 2;\n            // A[i] + ... + A[j] >= mid\n            // A[0] + ... + A[j] >= A[0] + ... + A[i-1] + mid\n            int index = std::lower_bound(A+i, A+i+N, (i>0?A[i-1]:0) + mid) - A;\n            if(index == i+N){\n                ub = mid;\n                continue;\n            }\n            \n            int index2 = std::lower_bound(A+index+1, A+i+N, A[index] + mid) - A;\n            if(index2 >= i+N-1){\n                ub = mid;\n                continue;\n            }\n\n            if(A[i+N-1] - A[index2] >= mid){\n                lb = mid;\n            }else{\n                ub = mid;\n            }\n        }\n\n        res = std::max(res, lb);\n    }\n\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nint a[111111*2];\nlong long sum[111111*2];\nlong long res = 0;\nint n;\n\nlong long C(int s,int e)\n{\n  long long lim = sum[e]-sum[s];\n  //printf(\"[%d,%d) [%d,%d)\\n\",s,e,e,s+n);\n  s += n;\n  int l = e, r = s;\n  while( e < s ) {\n    int m = (s+e)/2;\n    assert(sum[m]-sum[l]+lim+sum[r]-sum[m]==sum[n]);\n    //printf(\"%d %d %d %lld %lld %lld %lld\\n\",e,m,s,sum[m]-sum[l],lim,sum[r]-sum[m],sum[m]-sum[l]+lim+sum[r]-sum[m]);\n    if( sum[m]-sum[l] >= sum[r]-sum[m] ) {\n      s = m;\n    } else {\n      e = m+1;\n    }\n  }\n  //s = e;\n  assert(lim+sum[r]-sum[s]+sum[s]-sum[l]==sum[n]);\n  //printf(\":%d %d %lld %lld %lld %lld %d %d\\n\",l,r,lim,sum[r]-sum[s],sum[s]-sum[l],lim+sum[r]-sum[s]+sum[s]-sum[l],sum[n],l,r);\n  long long ret = min(min(lim,sum[r]-sum[s]),sum[s]-sum[l]);\n  res = max(res,ret);\n  return ret;\n}\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    scanf(\"%d\",a+i);\n    a[i+n] = a[i];\n    a[i+2*n] = a[i];\n  }\n  for( int j = 0; j < 3*n; j++ ) {\n    sum[j+1] = sum[j]+a[j];\n  }\n  int s,e;\n  s = 0;\n  e = 1;\n  for(;e<2*n;++e) {\n    while( e < 2*n && C(s,e) > sum[e]-sum[s] ) {\n      ++e;\n    }\n    while( s < e && C(s,e) < sum[e]-sum[s] ) {\n      ++s;\n    }\n  }\n  printf(\"%lld\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nint N;\nlint A[300005];\n\nbool able(lint x, int piv) {\n\tint add = 0;\n\tfor_(i,0,3) {\n\t\tint lb = 0, ub = N+10;\n\t\twhile (ub - lb > 1) {\n\t\t\tint med = (ub + lb) / 2;\n\t\t\tif (A[piv + add + med] - A[piv + add] >= x) ub = med;\n\t\t\telse lb = med;\n\t\t}\n\t\tadd += ub;\n\t\tif (add > N) return false;\n\t}\n\treturn true;\n}\n\nvoid solve() {\n\tfor_(i,1,N+1) A[i + N] = A[i + 2 * N] = A[i];\n\tfor_(i,1,3*N+5) A[i] += A[i - 1];\n\t\n\tlint ans = 0;\n\tfor_(piv,0,N) {\n\t\tlint lb = 0, ub = 1e16;\n\t\twhile (ub - lb > 1) {\n\t\t\tlint med = (ub + lb) / 2;\n\t\t\tif (able(med, piv)) lb = med;\n\t\t\telse ub = med;\n\t\t}\n\t\tans = max(ans, lb);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> A[i + 1];\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nint getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\t\n\tfor(int a1 = 0;;a1++){\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\tif(sumArray(a1, a2+1) < average) continue;\n\t\t\tfor(int a3 = a2+1;;a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\tif(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sumArray(0, a1+1) > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nint getLocalMin(int p1, int p2, int p3)\n{\n\tint LocalMin = sumArray(p1, p2);\n\tint tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n// cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nint n;\nll a[100000];\nvector<int> vec[100000];\n\nbool C(ll x){\n\tfor(int i = 0;i < n;i++) vec[i].clear();\n\tint l = 0,r = 0;\n\tll sum = 0;\n\twhile(1){\n\t\twhile(sum < x && r < 2 * n){\n\t\t\tsum += a[r++ % n];\n\t\t}\n\t\tif(sum < x) break;\n\t\tvec[l % n].push_back(r);\n\t\tsum -= a[l++ % n];\n\t}\n\tint pos = 0;\n\tbool flag = false;\n\tfor(int i = 0;i < n;i++){\n\t\tpos = i;\n\t\tint j = 0;\n\t\tfor(;j < 3;j++) {\n\t\t\tif(vec[pos % n].empty()) break;\n\t\t\tif(pos >= vec[pos % n][0]) break;\n\t\t\tpos = vec[pos % n][0];\n\t\t\t//if(x >= 213) cout << pos << endl;\n\t\t}\n\t\t//if(x >= 213) cout << i << \" \" << j << \" \" << pos << endl;\n\t\tif(j == 3 && pos <= i + n) {\n\t\t\tflag = true;\n\t\t\t//if(x >= 213) cout << \" \" << i << endl;\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(){\n\tll sum = 0;\n\tcin >> n;\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tll low = 0,up = sum / 3;\n\twhile(up - low > 1){\n\t\tll mid = (low + up) / 2;\n\t\t//cout << mid << endl;\n\t\tif(C(mid)) low = mid;\n\t\telse up = mid;\n\t}\n\tcout << low << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\t//FILE *inputFile = fopen(\"0600_in4.txt\", \"r\");\n\t//fscanf(inputFile, \"%d\", &N);\n\t//for(int i = 0; i < N; i++){\n\t//\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t//}\n\t//fclose( inputFile);\n\t\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\n//cout << \"sum:\\t\" << sum << endl;\n//cout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a1_sum, a2_sum, a3_sum;\n\t\n\ta1_sum = 0;\n\tfor(int a1 = 0;;a1++){\n\t\ta2_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta2_sum += InArray[a2];\n\t\t\tif(a2_sum + InArray[a2+1] < average) continue;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta3_sum = 0;\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta3_sum += InArray[a3];\n\t\t\t\tif(a3_sum + InArray[a3+1] < average) continue;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta1_sum += InArray[a1];\n\t\tif(a1_sum + InArray[a1+1] > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\n\nLL arr[100000];\nLL _sum[200000];\n\n\nint main() {\n  LL i, l, r, n;\n  LL _max, ans, left, res, rem, mid_id;\n  _sum[0] = 0;\n\n  // get num\n  cin >> n;\n\n  // get each size\n  for (i = 0; i < n; i ++) {\n    cin >> l;\n    arr[i] = l;\n  }\n\n  // calculate sum\n  for (i = 0; i < 2 * n; i ++) \n    _sum[i + 1] = _sum[i] + arr[i % n];\n\n  _max = _sum[n] / 3;\n\n  while (l < n) {\n    while (_sum[r] - _sum[l] <= _max)  r ++;\n    r --;\n\n    // get left size\n    left = _sum[r] - _sum[l];\n    // get rest size / 2\n    res = (_sum[n] - left) / 2;\n\n    // get second point\n    mid_id = lower_bound(_sum + r, _sum + 2*n, res + _sum[r]) - _sum;\n\n    // comp middle and right size\n    rem = min(_sum[mid_id] - _sum[r], _sum[l + n] - _sum[mid_id]);\n    if (mid_id > 0) rem = max(rem, min(_sum[mid_id - 1] - _sum[r], _sum[l + n] - _sum[mid_id - 1]));\n\n    ans = max(ans, min(left, rem));\n\n    l ++;\n  }\n\n  // output answer\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing lg = long long;\n\nbool able(vector<lg>& ps, lg n) {\n\tlg const N = ps.size()/2l;\n\tfor (lg i = 1; i <= N; i++) {\n\t\tauto beg = begin(ps)+i,\n\t\t     ed = beg+N;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tbeg = lower_bound(beg, end(ps), *(beg-1)+n)+1;\n\t\t\tif (beg >= end(ps)) break;\n\t\t}\n\t\tif (beg <= ed) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tlg N;\n\tcin >> N;\n\tvector<lg> A(2*N), ps(2*N+1, 0);\n\tfor (auto i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tA[i+N] = A[i];\n\t}\n\tpartial_sum(begin(A), end(A), begin(ps)+1);\n\tlg l = 0, r = 1000000000l*N;\n\twhile (r-l > 1l) {\n\t\tauto m = (l+r)/2l;\n\t\t(able(ps, m) ? l : r) = m;\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000;\n\nint N;\nint A[MAX_N];\n\nlong long sum[MAX_N*2];\n\nint main(){\n\tscanf(\"%d\",&N);\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tscanf(\"%d\",A+i);\n\t}\n\tsum[0]=A[0];\n\tfor (i=1;i<N;i++){\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor (i=N;i<2*N;i++){\n\t\tsum[i]=sum[i-1]+A[i-N];\n\t}\n\tlong long ans=1;\n\tint s,t;\n\ts=0;\n\tt=1;\n\tlong long a=A[0],b,c;\t//s-t間のバームクーヘン\n\twhile (s<N){\n\t\tlong long *p;\n\t\tdo{\n\t\t\twhile (a<=ans){\n\t\t\t\tt++;\n\t\t\t\ta+=A[(t-1)%N];\n\t\t\t}\n\t\t\t//aがansを更新できるか\n\t\t\tp=lower_bound(sum+t,sum+s+N,a+sum[t-1]);\n\t\t\tif (p!=sum+s+N){\n\t\t\t\t//見つかった\n\t\t\t\tb=*p-sum[t-1];\n\t\t\t\tc=sum[N-1]-b-a;\n\t\t\t\tif (c>=a){\n\t\t\t\t\t//aが最小値\n\t\t\t\t\tans=a;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}while (p!=sum+s+N);\n\t\ts++;\n\t\ta=sum[t-1]-sum[s-1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define ULL int64_t\n\nULL sum(ULL *d,ULL s ,ULL e){\n\tULL r = 0;\n\tfor(int i = s;i <= e;i++){\n\t\tr+=d[i];\n\t}\n\treturn r;\n}\n\nint main(){\n\tULL n;\n\tcin >> n;\n\tULL *d = (ULL*)malloc(sizeof(ULL) * n);\n\tif(d == NULL){\n\t\treturn -1;\n\t}\n\tULL s = 0;\n\tULL m;\n\tfor(ULL i = 0;i < n;i++){\n\t\tcin>>m;\n\t\td[i] = m;\n\t\ts += m;\n\t}\n\tULL res = 0;\n\tfor(ULL u = 0;u < n - 2;u++){\n\t\tfor(ULL v = u+1;v < n - 1;v++){\n\t\t\tfor(ULL w = v + 1;w < n;w++){\n\t\t\t\tULL snd = sum(d,u,v-1);\n\t\t\t\tULL thd = sum(d,v,w-1);\n\t\t\t\tULL fst = s - snd - thd;\n\t\t\t\tULL min;\n\t\t\t\tif(fst <= snd && fst <= thd){\n\t\t\t\t\tmin = fst;\n\t\t\t\t}else if( snd <= fst && snd <= thd ){\n\t\t\t\t\tmin = snd;\n\t\t\t\t}else{\n\t\t\t\t\tmin = thd;\n\t\t\t\t}\n\t\t\t\tif(res < min){\n\t\t\t\t\tres = min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\tfree( d );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tint i1_ini = 0;\n\tint A_max = 0;\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t\tif (A[i] > A_max){\n\t\t\tA_max = A[i];\n\t\t\ti1_ini = i;\n\t\t}\n\t}\n\tull one_third_size = total_size / 3;\n\tull answer = 0;\n\tif (A_max > one_third_size){\n\t\tull half_size = (total_size - A_max) / 2;\n\t\tull tmp = 0;\n\t\tull piece2 = 0;\n\t\tfor (int i3 = i1_ini + 1; i3 < i1_ini + N - 1; i3++){\n\t\t\tpiece2 = tmp;\n\t\t\ttmp += A[i3%N];\n\t\t\tif (tmp > half_size) break;\n\t\t}\n\t\tull piece3 = total_size - A_max - tmp;\n\t\tanswer = max(piece2, piece3);\n\t\tcout << answer << endl;\n\t\treturn 0;\n\t}\n\n\tint i2 = i1_ini;\n\tull piece1_s = 0;\n\tull piece1_l = 0;\n\tfor (; i2 < i1_ini + N - 2;){\n\t\tpiece1_s = piece1_l;\n\t\tpiece1_l += A[i2%N];\n\t\ti2++;\n\t\tif (piece1_l > one_third_size) break;\n\t}\n\tconst int i1_fin = i2;\n\n\tint i3 = i1_ini + N;\n\tull piece3_s = 0;\n\tull piece3_l = 0;\n\tfor (; i3 > i2 + 1;){\n\t\tpiece3_s = piece3_l;\n\t\ti3--;\n\t\tpiece3_l += A[i3%N];\n\t\tif (piece3_l > one_third_size) break;\n\t}\n\ti3++;\n\n\tull tmp = 0;\n\ttmp = min(piece1_s, piece3_s);\n\t\n\tull piece2 = 0;\n\tpiece2 = total_size - piece1_s - piece3_l;\n\ttmp = max(tmp, min(piece1_s, piece2));\n\n\tpiece2 = total_size - piece1_l - piece3_s;\n\ttmp = max(tmp, min(piece3_s, piece2));\n\n\tpiece2 = total_size - piece1_l - piece3_l;\n\ttmp = max(tmp, piece2);\n\n\tanswer = tmp;\n\n\tfor (int i1 = i1_ini + 1; i1 < i1_fin; i1++){\n\t\tint A_tmp = A[(i1 - 1) % N];\n\t\tpiece1_l -= A_tmp;\n\t\tif (piece1_l > one_third_size) piece1_s -= A_tmp;\n\t\telse{\n\t\t\tfor (; i2 < i1 + N - 2;){\n\t\t\t\tpiece1_s = piece1_l;\n\t\t\t\tpiece1_l += A[i2%N];\n\t\t\t\ti2++;\n\t\t\t\tif (piece1_l > one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\tpiece3_s += A_tmp;\n\t\tif (piece3_s <= one_third_size) piece3_l += A_tmp;\n\t\telse{\n\t\t\tfor (; i3 < i1 + N - 1;){\n\t\t\t\tpiece3_l = piece3_s;\n\t\t\t\tpiece3_s -= A[i3%N];\n\t\t\t\ti3++;\n\t\t\t\tif (piece3_s <= one_third_size) break;\n\t\t\t}\n\t\t}\n\n\t\ttmp = min(piece1_s, piece3_s);\n\n\t\tpiece2 = total_size - piece1_s - piece3_l;\n\t\ttmp = max(tmp, min(piece1_s, piece2));\n\n\t\tpiece2 = total_size - piece1_l - piece3_s;\n\t\ttmp = max(tmp, min(piece3_s, piece2));\n\n\t\tpiece2 = total_size - piece1_l - piece3_l;\n\t\ttmp = max(tmp, piece2);\n\n\t\tanswer = max(answer, tmp);\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\n\nusing namespace std;\n\nint main ()\n{\n\tint N;\n\tcin >> N;\n\tvector<long long int>data ( N + 2 );\n\tfor( size_t i = 1; i <= N; i++ )\n\t{\n\t\tcin >> data[i];\n\t\tdata[i] += data[i - 1];\n\t}\n\tdata[N + 1] = data[N];\n\tlong long int sum = data[N + 1];\n\tlong long int ans = INT_MIN;\n\tfor( size_t i = 0; i < N+2; i++ )\n\t{\n\t\tfor( size_t j = i; j < N+2; j++ )\n\t\t{\n\t\t\tlong long int A = data[j] - data[i];\n\t\t\tif( A < ans )continue;\n\t\t\tif( sum - A < ans * 2 )break;\n\t\t\tfor( size_t k = j; k < N+2; k++ )\n\t\t\t{\n\t\t\t\tlong long int B = data[k] - data[j];\n\t\t\t\tif( B < ans )continue;\n\t\t\t\tif( sum - B < ans * 2 )break;\n\t\t\t\tans = max ( ans , min ( { A , B , sum - A - B } ) );\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint N;\nll A[200010];\n\nbool ok(ll m,vector<ll>& S){\n    for(int i=1;i<=N;i++){//iと+1の間で切る\n        int s = lower_bound(S.begin(),S.end(),S[i]+m)-S.begin();\n        if(s>=i+N) continue;\n        int r = lower_bound(S.begin(),S.end(),S[s]+m)-S.begin();\n        if(r<i+N && S[i+N]-S[r]>=m) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> N;\n    vector<ll> S(2*N+2,0);\n    for(int i=1;i<=N;i++){\n        cin >> A[i];\n        A[i+N] = A[i];\n    }\n    for(int i=1;i<=2*N;i++) S[i] = S[i-1]+A[i];\n    S[2*N+1] = (ll) 1e18;\n    ll l = 0,r = 1e15;\n    while(l+1<r){\n        ll m = (l+r)/2;\n        if(ok(m,S)) l = m;\n        else r = m;\n    }\n    cout << l << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n\tint n;\n\tstatic ll a[100010];\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n ;i ++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\t\n\tint p = 1,q = 2,r = 3;\n\tll x = a[1],y = a[2],z = 0;\n\tfor(int i = 3; i <= n ;i ++)z += a[i];\n\t\n\tll ret = 0;\n\twhile(r <= n){\n\t\tif(y <= min(z,x)){\n\t\t\ty += a[r];\n\t\t\tz -= a[r];\n\t\t\tr ++;\n\t\t}\n\t\telse if(x <= min(y,z)){\n\t\t\tx += a[q];\n\t\t\ty -= a[q];\n\t\t\tq ++;\n\t\t}\n\t\telse {\n\t\t\tz += a[p];\n\t\t\tx -= a[p];\n\t\t\tp ++;\n\t\t}\n\t\tret = max ( ret , min(min(x,y),z) );\n\t}\n\t\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\ntemplate <typename T>\nint getFormer(const vector<T> &vec, T x) {\n    return upper_bound(vec.begin(), vec.end(), x) - vec.begin() - 1;\n}\n\ntemplate <typename T>\nint getLatter(const vector<T> &vec, T x) {\n    return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nlong long check(long long mid, const vector<long long>& acc) {\n    int N = acc.size() / 2;\n    for (int i = 0; i < N; i++) {\n        int j = lower_bound(acc.begin() + i, acc.begin() + i + N + 1, acc[i] + mid) - acc.begin();\n        int k = lower_bound(acc.begin() + j, acc.begin() + i + N + 1, acc[j] + mid) - acc.begin();\n        if (acc[j] - acc[i] < mid || acc[k] - acc[j] < mid || acc[i + N] - acc[k]< mid) continue;\n\n        return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<long long> acc(2 * N + 1, 0);\n    REP(i, N) {\n        cin >> acc[i + 1];\n        acc[i + N + 1] += acc[i + 1];\n    }\n    REP(i, 2 * N) {\n        acc[i + 1] += acc[i];\n    }\n\n    long long lb = -1, ub = (acc[N]) / 3 + 1;\n    while (ub - lb > 1) {\n        long long mid = (ub + lb) / 2;\n        if (check(mid, acc)) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n\n    cout << lb << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n - 2) REP(j, i + 1, n - 1)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = (sum - size) / 2;\n\t\t\t//int sep = upper_bound(all(cuts), cuts[j] + rem) - cuts.begin() - 1;\n\t\t\t//int k = max(j + 1, min(sep, n - 1));\n\n\t\t\tint sep = j + 1;\n\t\t\tREP(k, j + 1, n + n) if (cuts[k] - cuts[j] >= rem)\n\t\t\t{\n\t\t\t\tsep = k;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double eps = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n;\nll a[100001], sum[200001];\n\nint main() {\n\tstd::cin >> n;\n\trep(i, n)std::cin >> a[i];\n\n\tREP(i, 1, 2 * n + 1)sum[i] = sum[i - 1] + a[(i - 1 >= n ? i - n - 1 : i - 1)];\n\n\tint l = 0, r = 1000000000;\n\twhile (l <= r) {\n\t\tint m = (l + r) / 2;\n\n\t\tbool flg = false;\n\t\trep(i, n) {\n\t\t\tint be = i;\n\t\t\trep(j, 3) {\n\t\t\t\tbe = std::lower_bound(sum + i, sum + i + n + 1, m + sum[be]) - sum;\n\t\t\t\tif (be == i + n + 1)break;\n\t\t\t}\n\t\t\tif (be <= i + n) flg = true;\n\t\t}\n\t\tif (flg) l = m + 1;\n\t\telse r = m - 1;\n\t}\n\n\tstd::cout << l - 1 << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tint sep = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tif (sep <= right) sep = right + 1;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tREP(k, sep, n)\n\t\t\t{\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\tif (tmin > ttmin) break;\n\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t\tsep = k;\n\t\t\t}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 100001\n#define MIN(a,b) ((a>b)?(b):(a))\n#define mAX(a,b) ((a>b)?(a):(b))\n\ntypedef long long int lli;\n\nint main(void){\n\tint N,a[MAX];\n\tlli i,j,k,l,sum,max,solve=0;\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++) scanf(\"%d\",a+i);\n\n\tfor(i=0;i<N;i++){\n\t\tfor(j=i+1;j<N;j++){\n\t\t\tfor(k=j+1;k<N;k++){\n\t\t\t\tfor(l=i,max=0;l<j;l++) max+=a[l];\n\t\t\t\tfor(sum=0;l<k;l++) sum+=a[l];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tfor(sum=0;l<N+i;l++) sum+=a[l%N];\n\t\t\t\tmax=MIN(max,sum);\n\t\t\t\tif(solve<max){\n\t\t\t\tsolve=mAX(max,solve);\n\t\t\t\tprintf(\"debug:%lld %lld %lld,%lld\\n\",i,j,k,solve);\n}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",solve);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\t\n\tfor (p.end = p.top; p.end != _end + 1; p.end ++){\n\t\tif ((p.size = calcPieceSize(p)) >= min_piece_size) return p;\n\t}\n\n\tp.size = -1;\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen((piece[pieceNum - 1].end + 1) % N, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n\t\treturn true;\n\n\tMISS:\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans = sum[N - 1] / 3;\n\n\twhile (!cutOK(ans)) ans--;\n\n\treturn ans;\n}\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0\n#define int ll\n\n#define MAX 200005\nint piece[MAX];\n\nsigned main(){\n  int n;\n  cin>>n;\n  for(int i=1; i<=n; i++){\n    int a;\n    cin>>a;\n    piece[i]=piece[i-1]+a;\n  }\n  \n  for(int i=1; i<=n; i++){\n    piece[i+n]=piece[n]+piece[i];\n  }\n  \n  int l=0;\n  int r=100000000000000;\n  while(l+1<r){\n    int m=(r+l)/2;\n    bool ok=false;\n    for(int i=1; i<=n-2; i++){\n      int bet=lower_bound(piece, piece+2*n, piece[i-1]+m)-piece;\n      bet=lower_bound(piece, piece+2*n, piece[bet]+m)-piece;\n      bet=lower_bound(piece, piece+2*n, piece[bet]+m)-piece;\n      if(bet<=i+n-1) {\n        ok=true;\n        break;\n      }\n    }\n    if(ok) l=m;\n    else r=m;\n  }\n  \n  cout<<l<<en;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong v_list[100001];\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\ninline llong searchOne(int n0, int n1_left, int n2_left);\ninline llong getMinV(int n0, int n1_left, int n2_left);\ninline int findIndexBinary(int from_n, int to_n, double target);\ninline int findIndexSequential(int from_n, double target);\n\n\nint main(){\n\t/*\n\tFILE* fp = fopen(\"input.txt\", \"r\");\n\tfscanf(fp, \"%lld\", &N);\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfscanf(fp, \"%lld\", &A);\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfclose(fp);\n\n\t/*/\n\tscanf(\"%lld\", &N);\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tscanf(\"%lld\", &A);\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tprintf(\"%lld\\n\", BaumukuchenGetAnswer());\n}\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tint n0_max = findIndexBinary(0, N, tripartition);\n\n\tint n1_left = n0_max;\n\tint\tn2_left = findIndexBinary(n1_left, N,  2*tripartition);\n\tllong interm_maxV = searchOne(0, n1_left, n2_left);\n\tfor (int n0 = 1; n0 <= n0_max; n0++){\n\t\tn1_left = findIndexSequential(n1_left,   tripartition + v_list[n0]);\n\t\tn2_left = findIndexSequential(n2_left, 2*tripartition + v_list[n0]);\n\t\t\n\t\tllong tmp = searchOne(n0, n1_left, n2_left);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0, int n1_left, int n2_left){\n\tllong V_ll = getMinV(n0, n1_left  , n2_left  );\n\tllong V_lr = getMinV(n0, n1_left  , n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left  );\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tllong V0 = v_list[n1] - v_list[n0];\n\tllong V1 = v_list[n2] - v_list[n1];\n\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\treturn min(min(V0,V1),V2);\n}\n\nint findIndexBinary(int from_n, int to_n, double target){\n\twhile (to_n - from_n != 1) {\n\t\tint n_mid = (to_n + from_n) / 2;\n\t\tif (v_list[n_mid] > target) to_n = n_mid;\n\t\telse from_n = n_mid;\n\t}\n\treturn from_n;\n}\n\nint findIndexSequential(int from_n, double target){\n\tfor(int n=from_n; n<= N; n++)if(v_list[n] > target) return n-1;\n\treturn N-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long ll;\n \nll const INF = (ll)1e10;\n \nll N;\nll sum[200002];\nll arr[100001];\n \nll midx;\n\nbool C(ll d, ll S[], ll base) {\n  ll p1 = lower_bound(S, S+N, d+base) - S;\n  ll p2 = lower_bound(S, S+N+p1, d+S[p1]) - S;\n  if(N <= p2) return false;\n  if(S[N-1] - S[p2] >= d) {\n    return true;\n  }\n  return false;\n}\n \nint main() {\n   \n  cin >> N;\n  for(int i=0; i<N; i++) {\n    cin >> arr[i];\n  }\n   \n  for(int i=0; i<N; i++) {\n    sum[i] = arr[i];\n    if(i) sum[i] += sum[i-1];\n  }\n  for(int i=N; i<2*N; i++) {\n    sum[i] = arr[i-N]+sum[i-1];\n  }\n  sum[2*N] = INF/2;\n   \n  ll ans = 0;\n  for(midx=0; midx<N; midx++) {\n    ll lb = 0, ub = INF;\n    while(ub-lb>1) {\n      ll mid = (lb+ub)/2;\n      ll c;\n      if(midx>0) c = sum[midx-1];\n      else c = 0;\n \n      if(C(mid, sum+midx, c)) {\n        lb = mid;\n      } else {\n        ub = mid;\n      }\n    }\n    ans = max(ans, lb);\n  }\n   \n  cout << ans << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n;\nint table[200000];\n\nbool solve(ll x) {\n\tint l, r = 1; // [l,r)\n\tREP(i, 2 * n) table[i] = i;\n\tREP(i, 2 * n) {\n\t\tl = i;\n\t\tif (l >= r) r = l + 1;\n\t\twhile (r - l < n && r < 2 * n && sum[r - 1] - sum[l] + a[l] < x) r++;\n\t\tif (sum[r - 1] - sum[l] + a[l] >= x) table[l] = r;\n\t}\n\t\n\tREP(i, n) {\n\t\tint pos = i;\n\t\tREP(j, 3) {\n\t\t\tif (pos == table[pos]) break;\n\t\t\tpos = table[pos];\n\t\t\tif (pos > i + n) break;\n\t\t\tif (j == 2 && pos <= i + n) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\nint n;\nll a[100000];\nll S[200000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i,n) scanf(\"%lld\", &a[i]);\n\tS[0] = a[0];\n\tfor(int i = 1; i < 2*n; i++) S[i] = S[i-1]+a[i%n];\n\tll s = 1, e = 1000000000000001, mid;\n\t//printf(\"\\n\");\n\twhile(true){\n\t\tmid = (s+e)/2;\n\t\t//printf(\"%lld %lld %lld\\n\", s,mid,e);\n\t\tif(e-s == 1) break;\n\t\tbool ok = false;\n\t\trep(i,n){\n\t\t\tll st;\n\t\t\tif(i != 0) st = lower_bound(S+i,S+i+n,mid+S[i-1])-S;\n\t\t\telse st = lower_bound(S+i,S+i+n,mid)-S;\n\t\t\tif(st == i+n) continue;\n\t\t\tst = lower_bound(S+st+1,S+i+n,mid+S[st])-S;\n\t\t\tif(st == i+n) continue;\n\t\t\tif(S[i+n-1]-S[st] >= mid){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) s = mid;\n\t\telse e = mid;\n\t\t//printf(\"%lld %lld %lld\\n\", s,mid,e);\n\t}\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int lint;\nint N;\nbool check(int i,lint m,vector<lint> &S)\n{\n\tauto begin=S.begin()+i,end=S.begin()+i+N-1;\n\t\n\tauto bmk1=lower_bound(begin,end,m+(i?S[i-1]:0));\n\tauto bmk2=lower_bound(bmk1,end,m+*bmk1);\n\treturn *end-*bmk2>=m;\n}\n\n\nint main()\n{\n\tcin>>N;\n\tvector<lint> A(N),S(3*N);\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>A[i];\n\t\tS[2*N+i]=S[N+i]=S[i]=A[i];\n\t}\n\t\n\tfor(int i=0;i<3*N-1;i++)\n\t{\n\t\tS[i+1]+=S[i];\n\t}\n\t\n\tlint ans=-1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlint l=0,r=1e16,m;//left,right,middle\n\t\twhile(l!=r)\n\t\t{\n\t\t\tm=(l+r+1)/2;\n\t\t\tif(check(i,m,S))\n\t\t\t{\n\t\t\t\tl=m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr=m-1;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,l);\n\t}\n\tcout<<ans<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst ll MAX_N = ll(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i,n) for (int i = n; i >=0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll n, a[MAX_N], cum[MAX_N]{}, ans = 0, ma, L;\n\nint main() {\n    \n    cin >> n;\n    REP(i,n) cin >> a[i];\n    REP(i,n*2){\n        cum[i+1] = cum[i] + a[i%n];\n    }\n    L = cum[n];\n    ma = cum[n]/3;\n    ll l = 0, r = 0;\n    while(l <= n){\n        while(n-r+l > 2 && cum[r] - cum[l] < ma){\n            r++;\n        }\n        ll s = cum[r] - cum[l];\n        ll k = lower_bound(cum+r,cum+n+l,(L-s)/2+cum[r]) - cum;\n        for(int i = -1; i < 1; i++){\n            ll tmp = LLINF;\n            tmp = min(tmp, s);\n            tmp = min(tmp, cum[k+i]-cum[r]);\n            tmp = min(tmp, cum[n+l]-cum[k+i]);\n            ans = max(ans, tmp);\n        }\n        l++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nint main() {\n  for(int N; cin >> N;) {\n    vector<lli> A(N*4);\n    for(int i = 0; i < N; ++i) {\n      cin >> A[i];\n      A[N+i] = A[2*N+i] = A[3*N+i] = A[i];\n    }\n    A.insert(A.begin(), 0);\n    for(int i = 0; i+1 < A.size(); ++i) A[i+1] += A[i];\n\n    lli res = 0;\n    for(int a = 0; a < N; ++a) {\n      int L = a+1, R = a+N+1;\n      while(R-L) {\n        int b = (L+R)/2;\n        lli mini = A[b] - A[a];\n        int c = lower_bound(A.begin(), A.end(), A[b]+mini) - A.begin();\n        int d = lower_bound(A.begin(), A.end(), A[c]+mini) - A.begin();\n        if(c-b > 0 && d-c > 0 && d-a <= N) {\n          L = b + 1;\n        } else {\n          R = b;\n        }\n      }\n      res = max(res, A[L-1] - A[a]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long lli;\n\nint n;\nlli v[100000], sum[300030];\n\nint func(int root, int pos){\n  int lb = pos, ub = root + n;\n  lli suma = sum[pos] - sum[root];\n  while(ub - lb > 1){\n    int mid = (lb + ub) / 2;\n    if(sum[mid] - sum[pos] >=  suma) ub = mid;\n    else lb = mid;    \n  }\n  return ub;\n}\n\nvoid solve(){\n  lli ans = 0;\n\n  sum[0] = 0;\n  for(int i=1;i<n*3+9;i++) sum[i] = sum[i-1] + v[(i+n-1)%n];\n\n  for(int i=0;i<n;i++){\n    int lb = i, ub = i + n - 1, maxmid = -1;\n    //cout << \"*\" << endl;\n    while(ub - lb > 1){\n      int mid = (lb + ub) / 2;\n      int res = func(i, mid);\n      //cout << \"mid = \" << mid << \", res = \" << res << \", sum[i+n] - sum[res] = \" << sum[i+n] - sum[res] << \", sum[mid] - sum[i] = \" << sum[mid] - sum[i] << endl;\n      if(res == i + n || sum[i+n] - sum[res] < sum[mid] - sum[i]) {\n        ub = mid;\n      }\n      else {\n        lb = mid;\n        maxmid = max(maxmid,mid);\n      }\n    }\n    //cout << endl;\n    //cout << i << ' ' << ub << ' ' << sum[ub] - sum[i] << endl;\n    if(maxmid != -1) ans = max(ans, sum[maxmid] - sum[i]);\n    //if(ub != i + n - 1) ans = max(ans, sum[ub] - sum[i]);\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n){\n    for(int i=0;i<n;i++) cin >> v[i];\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint N;\n\nlong long int A[100001];\n\nbool check(long long int min_A){\n\t\n\tint index1, index2, index3;\n\t\n\tindex1 = 0;\n\tindex2 = 0;\n\tindex3 = 0;\n\t\n\tlong long int sum1, sum2, sum3;\n\t\n\tsum1 = 0;\n\tsum2 = 0;\n\tsum3 = 0;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tsum1 += A[i];\n\t\tif(sum1 >= min_A){\n\t\t\tindex2 = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = index2; i < N; i++){\n\t\tsum2 += A[i];\n\t\tif(sum2 >= min_A){\n\t\t\tindex3 = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i = index3; i < N; i++){\n\t\tsum3 += A[i];\n\t}\n\t\n\tif(index2 == 0 || index3 == 0){\n\t\treturn false;\n\t}\n\t\n\twhile(true){\n\t\tif(sum3 >= min_A){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(sum3 >= min_A){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum3 += A[index1];\n\t\t\tsum1 -= A[index1];\n\t\t\tindex1++;\n\t\t\tif(index1 == N){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tif(sum1 >= min_A){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum1 += A[index2];\n\t\t\tsum2 -= A[index2];\n\t\t\tindex2++;\n\t\t\tif(index2 == N){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tif(sum2 >= min_A){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum2 += A[index3];\n\t\t\tsum3 -= A[index3];\n\t\t\tindex3++;\n\t\t\tif(index3 == N){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nlong long int binary_search_2(long long int lef, long long int rig){\n\tlong long int middle = (lef + rig) / 2;\n\t//cout << middle << \" \";\n\tif(rig - lef <= 1){\n\t\tif(check(rig)){\n\t\t\treturn rig;\n\t\t}else{\n\t\t\treturn lef;\n\t\t}\n\t}\n\tif(check(middle)){\n\t\tlef = middle;\n\t}else{\n\t\trig = middle;\n\t}\n\treturn binary_search_2(lef, rig);\n}\n\n\nint main(){\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i];\n\t}\n\tlong long int rig_max = 100000000000000;\n\t\n\tlong long int ans = binary_search_2(0, rig_max);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\n#define int long long\n\nint n;\nvector<int> v(100000);\n\nbool ch(int x){\n  int j, ret=-1;\n  REP(k, n){\n    j=k;\n    int res=INF, c=0;\n    REP(i, 3){\n      int sum=0;\n      for(; c<n && sum<=x; c++){\n\tsum+=v[j];\n\tj++;\n\tj%=n;\n      }\n\n      res=min(res, sum);\n    }\n    \n    ret=max(ret, res);\n  }\n\n  return ret<=x;\n}\n\nint32_t main(){\n  scanf(\"%lld\", &n);\n  REP(i, n) scanf(\"%lld\", &v[i]);\n\n  int l=0, r=INF;\n  int mid;\n  REP(i, 1000){\n    mid=(l+r)/2;\n    if(ch(mid)) r=mid;\n    else l=mid;\n  }\n\n  printf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll a[300000];\nint main() {\n\tll n; scanf(\"%lld\", &n);\n\trep(i, n) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1 + n] = a[i + 1];\n\t}\n\tfor (ll i = 1; i <= 2 * n; i++)\n\t\ta[i] += a[i - 1];\n\tll s = 0, g = 1000000000 * n;\n\twhile (s != g) {\n\t\tll t = (s + g) / 2 + s % 2;\n\t\tbool flag = false;\n\t\trep(i, n) {\n\t\t\tll j = lower_bound(a + i, a + i + n, a[i] + t) - a;\n\t\t\tif (j == n + i)continue;\n\t\t\tll k = lower_bound(a + j, a + i + n, a[j] + t) - a;\n\t\t\tif (a[j] - a[i] >= t&&a[k] - a[j] >= t&&a[i + n] - a[k] >= t) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)s = t;\n\t\telse g = t - 1;\n\t}\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\ntypedef long long ll;\n\n#define N 100005\nint n;\nll a[N*2];\n\nint src(int i, ll sz){\n\t// if(a[2*n]-a[i]<sz) return 2*n;\n\tint mi=i, mx=2*n; //mi->g mx=le\n\twhile(mx-mi>1){\n\t\tint md=(mi+mx)/2;\n\t\tif(a[md]-a[i]<sz){\n\t\t\tmi=md;\n\t\t}else{\n\t\t\tmx=md;\n\t\t}\n\t}\n\t// printf(\"(%d, %lld)=%d\\n\", i, sz, mx);\n\treturn mx;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tREP(i, n){\n\t\tscanf(\"%lld\", a+i+1);\n\t}\n\tREP(i, n) a[n+i+1]=a[i+1];\n\ta[0]=0;\n\tREP(i, 2*n) a[i+1]+=a[i];\n\tll mi=0, mx=a[2*n]; //mi->ok mx->ng\n\t// while(1){\n\t// \tint i; ll s;\n\t// \tscanf(\"%d%lld\", &i, &s);\n\t// \tprintf(\"%d\\n\", src(i, s));\n\t// }\n\twhile(mx-mi>1){\n\t\tll md=(mi+mx)/2;\n\t\tREP(i, n){\n\t\t\tint j=src(i, md);\n\t\t\tint k=src(j, md);\n\t\t\tif(a[i+n]-a[k]>=md){\n\t\t\t\tmi=md;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmx=md;\nend:;\n\t}\n\tprintf(\"%lld\\n\", mi);\n}"
  },
  {
    "language": "C++",
    "code": "/* 2017/09/17\ndata will be seperated to 3 groups, a b c\nthe bigest(a) should >= sum / 3\nthen the second should >= (sum - a) / 3\nloop to find the just data that comply with the previous conditions\n*/\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\t// end link to head\n\tint InArray[200000] = {0};\n\tint N = 0;\n\t\n\t// initialize input\n\tint temp;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t\n\t// Calculate sum and average\n\tlong long sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\tlong long average;\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum;\n\tlong long average2;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(int a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(int a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll in[200000];\nll ruisekiwa[200001];\nll over;\n\nll getmin(int l, int r) {\n\tll a, b, c, ans = 0;\n\ta = ruisekiwa[r] - ruisekiwa[l];\n\tb = *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tc = ruisekiwa[l + N] - *lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over);\n\tans = max(ans, min(a, min(b, c)));\n\tb = *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\tc = ruisekiwa[l + N] - *(lower_bound(ruisekiwa + r, ruisekiwa + 2 * N, ruisekiwa[r] + over) + 1);\n\tans = max(ans, min(a, min(b, c)));\n\treturn ans;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> in[i];\n\t\tin[N + i] = in[i];\n\t}\n\tfor (int i = 1; i <= N * 2; i++) {\n\t\truisekiwa[i] = ruisekiwa[i - 1] + in[i - 1];\n\t}\n\n\tll ans = 0;\n\tover = (ruisekiwa[N] - ruisekiwa[0]) / 3;\n\tfor (int l = 0, r = 0;(l < N); l++) {\n\t\tfor (; ruisekiwa[r] - ruisekiwa[l] < over; r++)ans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r + 1));\n\t\tans = max(ans, getmin(l, r));\n\t\tans = max(ans, getmin(l, r - 1));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nlong InArray[100000] = {0};\nint N = 0;\n\nlong sumArray(int, int);\nlong getLocalMin(int, int, int);\n\nint main()\n{\n\t// initialize input\n\tif(0){\n\t\tFILE *inputFile = fopen(\"0600_in33.txt\", \"r\");\n\t\tfscanf(inputFile, \"%d\", &N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfscanf(inputFile, \"%d\", &InArray[i]);\n\t\t}\n\t\tfclose( inputFile);\n\t} else {\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++){cin >> InArray[i];}\n\t}\n\t\n\t\n\t// Calculate sum and average\n\tlong sum = sumArray(0, N);\n\tlong average = sum / 3;\n\t\ncout << \"sum:\\t\" << sum << endl;\ncout << \"average:\" << average << endl;\n\t\n\tlong MaxMin = 0;\n\tlong tempMin;\n\tlong a3_sum, a1_sum, a2_sum;\n\t\n\ta3_sum = InArray[0];\n\tfor(int a1 = 0; a3 < N-1; a1++){\n\t\ta1_sum = InArray[a1];\n\t\tfor(int a2 = a1+1;;a2++){\n\t\t\t//if(sumArray(a1, a2+1) < average) continue;\n\t\t\ta1_sum += InArray[a2];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ta2 = a2+1;\n\t\t\ta2_sum = InArray[a2];\n\t\t\tfor(int a3 = a2+1; a3 < N; a3++){\n\t\t\t\t//if(sumArray(a2, a3+1) < average) continue;\n\t\t\t\ta2_sum += InArray[a3];\n\t\t\t\tif(a2_sum < average) continue;\n\t\t\t\t\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\ttempMin = getLocalMin(a1, a2, a3+1);\n\t\t\t\tif(MaxMin < tempMin) MaxMin = tempMin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//if(sumArray(0, a1+1) > average) break;\n\t\ta3_sum += InArray[a1];\n\t\tif(a3_sum > average) break;\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}\n\nlong sumArray(int start, int end)\n{\n\tlong sum = 0;\n\tfor(int i = start; i < end; i++){\n\t\tsum += InArray[i];\n\t}\n\treturn sum;\n}\n\nlong getLocalMin(int p1, int p2, int p3)\n{\n\tlong LocalMin = sumArray(p1, p2);\n\tlong tempSum  = sumArray(p2, p3);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n\ttempSum = sumArray(0, p1) + sumArray(p3, N);\n\tif(LocalMin > tempSum){\n\t\tLocalMin = tempSum;\n\t}\n//cout << \"getLocalMin(a1, a2, a3)\\t\" << LocalMin << \"\\t\" << p1 << \"\\t\" << p2 << \"\\t\" << p3 << endl;\n\treturn LocalMin;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, a[100000], s[200001];\n\nlong long sum(int l, int r)\n{\n\treturn s[r] - s[l];\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\ts[0] = 0; for (int i = 1; i <= 2 * n; i++) s[i] = s[i - 1] + a[(i - 1) % n];\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tret = max(ret, min( { sum(i, j), sum(j, k), sum(k, n + i) } ));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 1;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r-1] - AA[l-1];\n\t\telse sum = AA[r-1];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\t//printf(\":%d %d %lld\\n\", LL, RR, AA[CC] - AA[r-1]);\n\t\t\t\tif(AA[CC] - AA[r-1] < sum)LL = CC;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tLL--;\n\t\t\twhile (AA[LL] - AA[r - 1] < sum)LL++;\n\t\t\tsum1 = AA[LL] - AA[r - 1];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\"::%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long lint;\nint main(){\n    int n;\n    lint baum[2*100000+1];\n    baum[0]=0;\n    scanf(\"%lld\",&n);\n    for(int i=1;i<=n;i++){\n        lint val;\n        scanf(\"%lld\",&val);\n        baum[i]=baum[i+n]=val;\n    }\n    lint ans=0;\n    for(int i=1;i<=2*n;i++){\n        baum[i]+=baum[i-1];\n    }\n\n    for(int i=1;i<=n;i++){\n        int lb=i-1,ub=i+n-1;\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            lint val=baum[mid]-baum[i-1];\n            int pos=lower_bound(baum+mid+1,baum+i+n,baum[mid]+val)-baum;\n            if(pos==i+n||baum[i+n-1]-baum[pos]<val)ub=mid;\n            else lb=mid;\n        }\n        ans=max(ans,baum[lb]-baum[i-1]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst ll MAX_N = ll(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i,n) for (int i = n; i >=0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nll n, a[MAX_N], cum[MAX_N]{}, ans = 0, ma, L;\n\nint main() {\n    \n    cin >> n;\n    REP(i,n) cin >> a[i];\n    REP(i,n*2){\n        cum[i+1] = cum[i] + a[i%n];\n    }\n    L = cum[n];\n    ma = cum[n]/3;\n    ll l = 0, r = 0;\n    while(l <= n){\n        while(n-r+l > 2 && cum[r] - cum[l] < ma){\n            r++;\n        }\n        ll s = cum[r] - cum[l];\n        ll k = lower_bound(cum+r,cum+n+l,(L-s)/2+cum[r]) - cum;\n        for(int i = -1; i <= 1; i++){\n            ll tmp = LLINF;\n            tmp = min(tmp, s);\n            tmp = min(tmp, cum[k+i]-cum[r]);\n            tmp = min(tmp, cum[n+l]-cum[k+i]);\n            ans = max(ans, tmp);\n        }\n        l++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ll INF = LLONG_MAX / 3;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tll n; cin >> n;\n\tvi a(n); REP(i, n) cin >> a[i];\n\tll lb = 0, ub = INF;\n\twhile (ub - lb > 1)\n\t{\n\t\tll mid = (ub + lb) / 2;\n\t\tbool ok = false, f = true;\n\t\tint div0, div1, div2;\n\t\tdiv0 = 0;\n\t\tint p = 0;\n\t\tll tmpa = 0;\n\t\twhile (tmpa < mid)\n\t\t{\n\t\t\ttmpa += a[p];\n\t\t\tp++;\n\t\t\tif (p == n)\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tll tmpb = 0;\n\t\tif (f)\n\t\t{\n\t\t\tdiv1 = p;\n\t\t\twhile (tmpb < mid)\n\t\t\t{\n\t\t\t\ttmpb += a[p];\n\t\t\t\tp++;\n\t\t\t\tif (p == n)\n\t\t\t\t{ \n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdiv2 = p;\n\t\tll tmpc = 0;\n\t\tFOR(i, p, n) tmpc += a[i];\n\t\twhile (f)\n\t\t{\n\t\t\tif (tmpa >= mid && tmpb >= mid && tmpc >= mid)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (div2 == n) break;\n\t\t\ttmpa -= a[div0];\n\t\t\ttmpc += a[div0];\n\t\t\tdiv0++;\n\t\t\twhile (tmpa < mid)\n\t\t\t{\n\t\t\t\ttmpa += a[div1];\n\t\t\t\ttmpb -= a[div1];\n\t\t\t\tdiv1++;\n\t\t\t\tif (div1 == div2)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (tmpb < mid)\n\t\t\t{\n\t\t\t\tif (div2 == n) break;\n\t\t\t\ttmpb += a[div2];\n\t\t\t\ttmpc -= a[div2];\n\t\t\t\tdiv2++;\n\t\t\t\tif (div2 == div0)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) lb = mid;\n\t\telse ub = mid;\n\t}\n\tcout << lb << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 100005;\nconst int MMAX = 100005;\nconst int KMAX = 1005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n// #define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> lp;\ntypedef pair<ll, ll> llp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// dump vector\n#ifdef DEBUG\n#define DUMPV(v, c) do{       \\\n  printf(\"%s: \", #v);         \\\n  for (int i = 0; i < (c); ++i) \\\n  {                           \\\n  cout << (v)[i] << \" \";      \\\n  }                           \\\n  cout << endl;               \\\n} while(0)\n#else\n#define DUMPV(v,c)\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(int)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = (_begin + _end) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\n\n\nll N,M,K,A[NMAX],B,D,E;\nll S[NMAX] = {};\n\nll ans = {};\n\nbool C(int x){\n  for (int i = 0; i < N; ++i)\n  {\n    DUMP(i);\n    int ii  = distance(S, lower_bound(S + i, S + 2 * N, S[i] + x));\n    if(ii  == 2 * N) return false;\n    debug(\"ii = %d :: S[ii] = %lld\\n\", ii, S[ii]);\n\n    int iii = distance(S, lower_bound(S + ii, S + 2 * N, S[ii] + x));\n    if(iii == 2 * N) return false;\n    debug(\"iii = %d :: S[iii] = %lld\\n\", iii, S[iii]);\n\n    if(S[i + N] - S[iii] >= x) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  // main algorithm\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    S[i+1] = S[i] + A[i % N];\n  }\n  int low = 1, hi = S[N] / 3 + 1;\n  while(hi - low > 1) {\n    int mid = (hi + low) / 2;\n    if(C(mid)) {\n      low = mid;\n      debug(\"C(%d) = true\\n\", mid);\n    }\n    else {\n      hi = mid;\n      debug(\"C(%d) = false\\n\", mid);\n    }\n  }\n  ans = low;\n}\nvoid debug(){\n  // output debug information\n\n  printf(\"i\\t| A[i]\\tS[i]\\n--------------------------\\n\");\n  for (int i = 0; i < 2 * N; ++i)\n  {\n    printf(\"%d\\t| %lld\\t%lld\\n\", i, A[i%N], S[i]);\n  }\n  printf(\"%d\\t| ***\\t%lld\\n\", 2*N, S[2 * N]);\n}\nvoid answer(){\n  // output answer\n  cout << ans << endl;\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  // Fill(dp, -1);\n  cin >> N;\n  for (int i = 0; i < N; ++i)\n  {\n    scanf(\"%lld\", &A[i]);\n  }\n  solve();\n  #ifdef DEBUG\n  debug();\n  #endif\n  answer();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing ll = long long;\n\nint n;\nvector<ll> a;\nvector<ll> imos;\n\nll sum(ll l, ll r){\n    return imos[r] - imos[l];\n}\n\nll get(int l, int r, ll lb){\n    // l:bad, r:good\n    ll x = l;\n    // cout << l << ' ' << r << ' ' << lb << \"->\";\n    while(l+1 < r){\n        int m = (l+r)/2;\n        if(sum(x,m) < lb) l = m;\n        else r = m;\n    }\n    // cout << r << endl;\n    return r;\n}\n\nbool check(ll lb){\n    // cout << lb << endl;\n    rep(i,n){\n        ll x = get(i,i+n,lb);\n        ll y = get(x,i+n,lb);\n        if(sum(i,x) >= lb && sum(x,y) >= lb && sum(y,i+n) >= lb){\n            return true;\n        }\n    }\n    return false;\n}\n\nll solve(){\n    a.insert(a.end(), a.begin(), a.end());\n    imos.assign(a.size()+1,0);\n    rep(i,a.size()) imos[i+1] = imos[i] + a[i];\n    ll l = 1, r = imos[n];\n    while(l+1 < r){\n        ll m = (l+r)/2;\n        if(check(m)) l = m; else r = m;\n    }\n    return l;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(cin >> n){\n        a.resize(n);\n        rep(i,n) cin >> a[i];\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Piece{\n\tint top;\n\tint end;\n\tll size;\n};\n\nclass Baumkuchen{\nprivate:\n\tint N;\n\tconst int DevideNum;\n\tll* A;\n\tll* sum;\n\tPiece* piece;\n\n\tvoid input();\n\tvoid newArrays(int n);\n\tvoid setSum();\n\tbool isContainPiece(int i, const Piece& p);\n\tll calcPieceSize(const Piece& p);\n\tPiece cutDivideBaumkuchen(int _top, int _end, ll min_piece_size);\n\tbool cutOK(ll min_piece_size);\n\npublic:\n\tBaumkuchen(int _DevideNum);\n\t~Baumkuchen();\n\t\n\tll solve();\n};\n\n\nBaumkuchen::Baumkuchen(int _DevideNum) : N(0), DevideNum(_DevideNum){\n\tA = NULL;\n\tsum = NULL;\n\tpiece = NULL;\n}\n\nBaumkuchen::~Baumkuchen(){\n\tdelete[] A;\n\tdelete[] sum;\n\tdelete[] piece;\n}\n\nvoid Baumkuchen::newArrays(int n){\n\tA = new ll[n];\n\tsum = new ll[2 * n + 1];\n\tpiece = new Piece[DevideNum];\n}\n\nvoid Baumkuchen::input(){\n\tcin >> N;\n\tnewArrays(N);\n\n\tfor (int i = 0; i < N; i++) cin >> A[i];\n}\n\nvoid Baumkuchen::setSum(){\n\tsum[0] = A[0];\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + A[i];\n\n\tfor (int i = 0; i < N; i++) sum[i + N] = sum[i] + sum[N - 1];\n}\n\nbool Baumkuchen::isContainPiece(int i, const Piece& p){\n\treturn (p.top <= i%N && i%N <= p.end) || (p.top <= (i%N) + N && (i%N) + N <= p.end);\n}\n\nll Baumkuchen::calcPieceSize(const Piece& p){\n\treturn (p.top <= p.end) ? (sum[p.end] - sum[p.top] + A[p.top % N]) : -1;\n}\n\nPiece Baumkuchen::cutDivideBaumkuchen(int _top, int _end, ll min_piece_size){\n\tPiece p;\n\tp.top = _top;\n\tp.end = _end;\n\t\n\tif (calcPieceSize(p) < min_piece_size){\n\t\tp.size = -1;\n\t\treturn p;\n\t}\n\n\tint end_max = _end, end_min = _top;\n\n\twhile (end_max > end_min + 1){\n\t\tp.end = (end_max + end_min) / 2;\n\t\tif (calcPieceSize(p) < min_piece_size) end_min = p.end;\n\t\telse                                   end_max = p.end;\n\t}\n\tp.end = end_min;\n\tp.end = calcPieceSize(p) < min_piece_size ? end_max : end_min;\n\tp.size = calcPieceSize(p);\n\t\n\treturn p;\n}\n\nbool Baumkuchen::cutOK(ll min_piece_size){\n\tpiece[0] = cutDivideBaumkuchen(0, N - 1, min_piece_size);\n\tif (piece[0].size == -1) return false;\n\t\n\tint cp = piece[0].end;\n\n\tfor (; isContainPiece(cp, piece[0]); piece[0].top ++){\n\t\tpiece[0] = cutDivideBaumkuchen(piece[0].top, N - 1, min_piece_size);\n\t\tfor (int pieceNum = 1; pieceNum < DevideNum; pieceNum++){\n\t\t\tpiece[pieceNum] = cutDivideBaumkuchen(piece[pieceNum - 1].end + 1, (piece[0].top) % N + N - 1, min_piece_size);\n\t\t\tif (piece[pieceNum].size == -1) goto MISS;\n\t\t}\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\treturn true;\n\n\tMISS:\n//\t\tpiece[2].size = calcPieceSize(piece[2]);\n//\t\tcout << min_piece_size << \" : \" << piece[0].top << \", \" << piece[0].end << \", \" << piece[0].size << \" | \" << piece[1].top << \", \" << piece[1].end << \", \" << piece[1].size << \" | \" << piece[2].top << \", \" << piece[2].end << \", \" << piece[2].size << endl;\n\t\tcontinue;\n\t}\n\treturn false;\n}\n\nll Baumkuchen::solve(){\n\tinput();\n\tsetSum();\n\t\n\tll ans;\n\tll ans_max = sum[N - 1] / DevideNum;\n\tll ans_min = 0;\n\n\twhile (ans_max > ans_min + 1){\n\t\tans = (ans_max + ans_min) / 2;\n\t\tif (cutOK(ans)) ans_min = ans;\n\t\telse            ans_max = ans;\n\t}\n\tans = (cutOK(ans_max)) ? ans_max : ans_min;\n\n\treturn ans;\n}\n\n\nint main(){\n\tBaumkuchen* baumkuchen = new Baumkuchen(3);\n\t\n\tll ans = baumkuchen->solve();\n\tcout << ans << endl;\n\n\tdelete baumkuchen;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new long[N];\n\t\tlong m = 1000000000000L, M = 0L;\n\t\tlong tmp;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define LL long long\nint N;\nLL A[200010];\n\nbool judge(LL x){\n    for(int s = 1; s <= N; s++){//始点\n        int itr1 = lower_bound(A + s, A + s + N, x + A[s]) - A;\n        int itr2 = lower_bound(A + itr1, A + s + N, x + A[itr1]) - A;\n        if(A[s + N] - A[itr2] >= x) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> N;\n    for(int i = 1; i <= N; i++){\n        cin >> A[i];\n        A[i + N] = A[i];\n    }\n    for(int i = 1; i <= N * 2; i++){\n        A[i] += A[i - 1];\n    }\n    LL lb = 0;\n    LL ub = A[N - 1];\n    while(ub - lb > 1){\n        LL mid = (ub + lb) / 2;\n        if(judge(mid)){\n            lb = mid;\n        }else{\n            ub = mid;\n        }\n    }\n    cout << lb << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin>>n;\n  vector<int64_t> a(n*2);\n  REP(i,n)cin>>a[i];\n  REP(i,n)a[i+n]=a[i];\n  vector<int64_t> s(2*n+1);\n  partial_sum(begin(a),end(a),begin(s)+1);\n  int64_t mx_mn = 0;\n  REP(i,n) {\n    int64_t bl = 0, br = INT64_C(1000000000000000);\n    while(bl + 1 < br) {\n      int64_t mid = (bl + br) / 2;\n      int64_t ofs = s[i];\n      bool ok = true;\n      REP(j,3) {\n        auto itr = lower_bound(begin(s),end(s),ofs + mid);\n        if (itr != end(s)) {\n          ofs = *itr;\n        } else {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        if (ofs <= s[i+n]) {\n          bl = mid;\n        } else {\n          br = mid;\n        }\n      } else {\n        br = mid;\n      }\n    }\n    mx_mn = max(mx_mn, bl);\n  }\n  cout << mx_mn << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i - 1;\n}\n\nvoid CalcPiece3(int _i3, ull *_piece3, const ull _two_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _two_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\n\t\tull piece2 = 0;\n\t\tint i3 = CalcPiece(i1 + 1, &piece2, one_third_size, A, N);\n\t\t\n\t\tull piece3 = total_size - piece1 - piece2;\n\t\twhile (piece3 > one_third_size){\n\t\t\tpiece3 -= A[i3 % N];\n\t\t\ti3++;\n\t\t}\n\t\t\n\t\tull tmp = 0;\n\t\tif (piece1 < piece2 && piece1 < piece3) tmp = piece1;\n\t\telse if (piece2 < piece3) tmp = piece2;\n\t\telse tmp = piece3;\n\t\tif (tmp > answer) answer = tmp;\n\n\t\tpiece1 += A[i1 % N];\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\ti1 = CalcPiece(i1 + 1, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2 - A[i1 % N];\n\n\t\tif (piece2 > piece3) tmp = piece2;\n\t\telse tmp = piece3;\n\t\tif (tmp > answer) answer = tmp;\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\nusing namespace std;\n\nint b;\nint c;\nint d;\nint e;\nint f;\nint main(){\n  int n;\n  cin>>n;\n  int a[2n];\n  int z[n]\n  for(int i;i<n;i++){\n    cin>>a[i];\n    c=c+a{i}\n    a[n+i]=a[i];}\n  for(int j;j<n;j++){\n    d=j-1;\n    while(b<c/3){\n      d++;\n      b=b+a[d]; \n    }\n    b=b-a[d]\n    while(e<=c/3){\n      d++;\n      e=e+a[d];}\n    f=c-b-e;\n    if(f>b){\n      z[j]=b;\n    }else{\n      z[j]=f;}     \n  }\n  sort(z,z+n);\n  cout<<z[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nint N;\nvector<LL> A;\n\nbool ok(LL x) {\n  for(int i = 0; i < N; ++i) {\n    auto a = lower_bound(i + begin(A), end(A), A[i] + x);\n    auto b = lower_bound(a, end(A), *a + x);\n    auto c = lower_bound(b, end(A), *b + x);\n    if(c == end(A)) return false;\n    if(c - begin(A) <= i + N) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N;\n  A.resize(N);\n  for(auto& i: A) cin >> i;\n\n  A.insert(end(A), begin(A), end(A));\n  for(int i = 1; i < A.size(); ++i) A[i] += A[i-1];\n\n  LL low = 0, high = A[N-1]/3 + 1;\n  while(low + 1 != high) {\n    auto middle = (low + high) / 2;\n    if(ok(middle)) low  = middle;\n    else           high = middle;\n  }\n  cout << low << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nint solve(long long int start, long long int target, vector<long long int>& a_sum){\n  int left = start;\n  int right = a_sum.size() - 1;\n  while(right - left > 1){\n    int middle = (left + right) / 2;\n    long long int value = a_sum[middle] - a_sum[start];\n    if(value <= target){ left = middle; }\n    else{ right = middle; }\n  }\n  return left;\n}\n\n\n\nint main(void){\n  int n;\n  cin >> n;\n\n  long long int total_a = 0;\n  vector<long long int> a(n);\n  for(int i = 0; i < n; i++){\n    cin >> a[i];\n    total_a += a[i];\n  }\n\n  vector<long long int> a_sum(2 * n + 2);\n  a_sum[0] = 0;\n  for(int i = 0; i < (int)a_sum.size() - 1; i++){\n    a_sum[i + 1] = a_sum[i] + a[i % n];\n  }\n\n\n  long long int ans = 0;\n  for(int i = 0; i < n; i++){\n    int firs = i;\n    int seco = solve(firs, total_a / 3, a_sum);\n    int thir = solve(seco, (total_a - (a_sum[seco] - a_sum[firs])) / 2, a_sum);\n    ans = max(ans, min(a_sum[seco] - a_sum[firs], min(a_sum[thir] - a_sum[seco], a_sum[firs + n] - a_sum[thir])));\n    ++thir;\n    ans = max(ans, min(a_sum[seco] - a_sum[firs], min(a_sum[thir] - a_sum[seco], a_sum[firs + n] - a_sum[thir])));\n\n    \n    ++seco;\n    thir = solve(seco, (total_a - (a_sum[seco] - a_sum[firs])) / 2, a_sum);\n    ans = max(ans, min(a_sum[seco] - a_sum[firs], min(a_sum[thir] - a_sum[seco], a_sum[firs + n] - a_sum[thir])));\n    ++thir;\n    ans = max(ans, min(a_sum[seco] - a_sum[firs], min(a_sum[thir] - a_sum[seco], a_sum[firs + n] - a_sum[thir])));\n  }\n\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//風呂場で思いついたO(N(logN)^2)解法。\n//単純に切り方O(N^3)*区間O(N)→累積和O(N^3)*O(1)→JOIの全区間と残りを半分に分けたい妹O(N^2logN)\n//→JOI君の区間長を２分探索O(logN*N*logN) == O(N(logN)^2).\n//コメント：まさかこんなに単純なわけ…(実装1時間くらい)\n#include<iostream>\nusing namespace std;\n\nint N,A[200000];\t\t//A[i]は2周しとくと無難\nlong long rui[200001];\t//A[i]の累積和\nlong long mmax;\t\t\t//JOI君がいただける量の最大値\n\nint JOI_len(int Min,int Max);\t\t//JOI君は最大何切れとれるのか\nbool can_cut(int size);\t\t\t\t//JOI君はsize切れをいただける可能性があるか\t\nbool JOI_cut(int start,int last);\t//JOI君はstart-last間をいただけるのか\nint seach_sister_cut_1(int start,int lastmin,int lastmax,long long size);\t//妹たちはどこで切り分けるのか(lastから探索)\n//int seach_sister_cut_2(int start,int lastmin,int lastmax,long long size);\t//妹たちはどこで切り分けるのか(startから探索)→いらない\n\nint main(){\n\tcin >> N;\n\tfor(int i = 0;i < N;i++){\n\t\tcin >> A[i];\n\t\trui[i+1] += A[i]+rui[i]; \n\t\tA[i+N] = A[i];\n\t}\n\tfor(int i = 1;i <= N;i++){\n\t\trui[i+N] = rui[i]+rui[N];\n\t}\n\t//cout << rui[N] << endl;\n\t//探索\n\tJOI_len(1,N);\n\tcout << mmax << endl;\n\treturn 0;\n}\n\nint JOI_len(int Min,int Max){\n\tint medi = (Min+Max)/2;\n\tif(Min == Max)\n\t\treturn Min;\n\tif(can_cut(medi)){\n\t\tif(can_cut(medi+1))\n\t\t\treturn JOI_len(medi+1,Max);\n\t\treturn medi;\n\t}\n\telse{\n\t\treturn JOI_len(Min,medi-1);\n\t}\n}\nbool can_cut(int size){\n\tint i;\n\tbool can = false;\n\t//切れる方法が1つでないことに注意する。\n\tfor(i = 0;i < N;i++){\n\t\tif(JOI_cut(i,i+size))\n\t\t\tcan = true;\n\t}\n\treturn can;\n}\nbool JOI_cut(int start,int last){\n\tbool can = false;\n\tint sis_cut = seach_sister_cut_1(last,last+1,start+N,(rui[start+N]-rui[last])/2);\n\t//cout << rui[sis_cut]-rui[last] << \" \" << rui[start+N]-rui[sis_cut] << \" \";\n\tif(rui[sis_cut]-rui[last] >= rui[last]-rui[start] && rui[start+N]-rui[sis_cut] >= rui[last]-rui[start]){\n\t\tcan = true;\n\t\tif(mmax < rui[last]-rui[start])\n\t\t\tmmax = rui[last]-rui[start];\n\t}\n\tsis_cut++;\n\t//cout << rui[sis_cut]-rui[last] << \" \" << rui[start+N]-rui[sis_cut] << endl;\n\tif(rui[sis_cut]-rui[last] >= rui[last]-rui[start] && rui[start+N]-rui[sis_cut] >= rui[last]-rui[start]){\n\t\tcan = true;\n\t\tif(mmax < rui[last]-rui[start])\n\t\t\tmmax = rui[last]-rui[start];\n\t}\n\treturn can;\n}\nint seach_sister_cut_1(int start,int lastmin,int lastmax,long long size){\t//size == (rui[last]-rui[start])/2\n\tint medi = (lastmin+lastmax)/2;\n\tif(rui[medi]-rui[start] == size)\n\t\treturn medi;\n\tif(lastmin == lastmax)\n\t\treturn lastmin;\n\tif(rui[medi]-rui[start] < size){\n\t\tif(rui[medi+1]-rui[start] == size)\n\t\t\treturn medi+1;\n\t\tif(rui[medi+1]-rui[start] > size)\n\t\t\treturn medi;\n\t\treturn seach_sister_cut_1(start,medi+1,lastmax,size);\n\t}\n\tif(rui[medi]-rui[start] > size){\n\t\treturn seach_sister_cut_1(start,lastmin,medi-1,size);\n\t}\n}\n/*int seach_sister_cut_2(int start,int lastmin,int lastmax,long long size){\t//start > lastmax >= lastmin\n\tint medi = (lastmin+lastmax)/2;\n\tif(rui[start]-rui[medi] == size)\n\t\treturn medi;\n\tif(lastmin == lastmax)\n\t\treturn lastmin;\n\tif(rui[start]-rui[medi] < size){\n\t\tif(rui[start]-rui[medi-1] == size)\n\t\t\treturn medi-1;\n\t\tif(rui[start]-rui[medi-1] > size)\n\t\t\treturn medi;\n\t\treturn seach_sister_cut_2(start,lastmin,medi-1,size);\n\t}\n\tif(rui[start]-rui[medi] > size){\n\t\treturn seach_sister_cut_2(start,medi+1,lastmax,size);\n\t}\n}*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nll a[200000];\nll sum[200000], n, s;\n\n// ?????????????????????x??\\?????§3????????????????????¨?????§?????????\nbool solve(ll x) {\n\tREP(i, n) {\n\t\tbool flag = true;\n\t\tint pos = i;\n\t\tREP(j, 2) {\n\t\t\tpos = lower_bound(sum + i, sum + i + n, sum[pos] + x) - sum;\n\t\t\tif (pos == i + n) { flag = false; break; }\n\t\t}\n\t\tif (flag && s - (sum[pos] - sum[i]) >= x) return true;\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\tcin >> n;\n\t\n\tREP(i, n) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[n + i] = a[i];\n\t\ts += a[i];\n\t}\n\tsum[0] = a[0];\n\tFOR(i, 1, 2*n) sum[i] = sum[i - 1] + a[i];\n\t\n\tll l = -1, r = n * 1000000000;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (solve(m)) l = m;\n\t\telse r = m;\n\t}\n\t\n\tcout << l << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nll a[300000];\nint main() {\n\tll n; scanf(\"%lld\", &n);\n\trep(i, n) {\n\t\tscanf(\"%lld\", &a[i + 1]);\n\t\ta[i + 1 + n] = a[i + 1];\n\t}\n\tfor (ll i = 1; i <= 2 * n; i++)\n\t\ta[i] += a[i - 1];\n\tll s = 0, g = a[n];\n\twhile (s != g) {\n\t\tll t = (s + g) / 2;\n\t\tif (g - s == 1)t = g;\n\t\tbool f = 0;\n\t\trep(i, n) {\n\t\t\tll j = lower_bound(a + i, a + i + n + 1, a[i] + t) - a;\n\t\t\tif (j == n + i + 1)continue;\n\t\t\tll k = lower_bound(a + j, a + i + n + 1, a[j] + t) - a;\n\t\t\tif (a[k] - a[j] >= t&&a[i + n] - a[k] >= t) { f = 1; break; }\n\t\t}\n\t\tif (f)s = t;\n\t\telse g = t - 1;\n\t}\n\tprintf(\"%lld\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(int i=0; i<n; ++i)\n        cin >> a[i];\n    long long aSum = accumulate(a.begin(), a.end(), 0LL);\n\n    long long left = 1;\n    long long right = aSum;\n    while(left < right){\n        long long mid = (left + right + 1) / 2;\n\n        bool ok = false;\n        vector<int> index(3, 0);\n        vector<long long> sum(3, 0);\n        sum[2] = aSum;\n\n        for(int i=0; i<n; ++i){\n            for(int j=1; j<3; ++j){\n                while(!(sum[j-1] > 0 && index[j] == index[0]) && sum[j-1] < mid){\n                    sum[j-1] += a[index[j]];\n                    sum[j] -= a[index[j]];\n                    ++ index[j];\n                    index[j] %= n;\n                }\n            }\n            if(sum[2] >= mid)\n                ok = true;\n\n            sum[0] -= a[i];\n            sum[2] += a[i];\n            ++ index[0];\n        }\n\n        if(ok)\n            left = mid;\n        else\n            right = mid - 1;\n    }\n    cout << left << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//図を書けばバグらない(バグったorz\n//ijがJOI君とすると残り2人は半分こするのがよさそう。\n#include<stdio.h>\n\nlong long N;\nlong long rui[200001];\n\nlong long max( long long a, long long b ){\n\tif( a > b )\n\t\treturn a;\n\treturn b;\n}\nlong long min( long long a, long long b ){\n\tif( a < b )\n\t\treturn a;\n\treturn b;\n}\nint lower( int start, long long num ){\n\tint last = start + N;\n\tint medi;\n\n\twhile( last - start + 1 > 0 )\n\t{\n\t\tmedi = (start + last)/2;\n\t\tlong long x = rui[medi] - rui[start];\n\n\t\tif( x == num )\n\t\t\tbreak;\n\t\tif( x > num ){\n\t\t\tif( rui[medi-1] - rui[start] < num )\n\t\t\t\tbreak;\n\t\t\tlast = medi-1;\n\t\t}\n\t\tif( x < num )\n\t\t\tstart = medi+1;\n\t}\n\tif( medi > last )\n\t\treturn -1;\n\treturn medi;\n}\n\nint main(){\n\tint i,j;\n\n\tscanf(\"%d\",&N);\n\tfor( i = 1;i <= N;i++ ){\n\t\tscanf(\"%d\",rui+i);\n\t\trui[i] += rui[i-1];\n\t}\n\tfor( i = N+1;i <= 2*N;i++ ){\n\t\trui[i] = rui[N] + rui[i-N];\n\t}\n\n\tlong long ij, jk, ki;\t\t\n\tlong long ans = 0;\n\n\tfor( i = 0;i < N;i++ ){\n\t\tfor( j = i+1;j < N;j++ ){\n\t\t\tij = rui[j] - rui[i];\n\n\t\t\tif( lower( j,ij ) == -1 )\n\t\t\t\tcontinue;\n\t\t\tjk = rui[ lower( j,ij ) ] - rui[j];\n\t\t\tki = rui[i+N] - rui[ lower( j,ij ) ];\n\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\n\t\t\tif( lower( j,ij ) == 0 )\n\t\t\t\tcontinue;\n\t\t\tjk = rui[ lower( j,ij )-1 ] - rui[j];\n\t\t\tki = rui[i+N] - rui[ lower( j,ij )-1 ];\n\t\t\tans = max(  ans, min( ij, min(jk, ki) )  );\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nclass baumkuchen{\npublic:\n\tbaumkuchen();\n\t~baumkuchen();\n\n\tint N;\t//切れ込みの数\n\tlong long* A;\t//一つ一つのバウムクーヘンの大きさ\n\tlong long* memo;\n\tlong long sum_baum;\t//全てのバウムクーヘンの大きさの和\n\tdouble tripartition;\n\n\tvoid set_value();\t//値のセット\n\tbool set;\t//値のセットを行ったかどうかを判別する変数\n\n\tlong long piece(int cut_1, int cut_2);\t//3つに切り分けた後のあるひとつのバウムクーヘンの大きさを求める関数\n\tlong long full_search();\t//全探索で答えを求める関数\n\tlong long extended_full_search();\t//全探索改良版\n\n};\n\nbaumkuchen::baumkuchen(){\n\tset = false;\n}\nbaumkuchen::~baumkuchen(){\n\tif (set == true)delete[] A;\n\tif (set == true)delete[] memo;\n}\n\nvoid baumkuchen::set_value(){\n\tsum_baum = 0;\n\tcin >> N;\n\tA = new long long[4*N];\n\tmemo = new long long[4 * N]();\n\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i];\t\t\t//バウムクーヘンの大きさの入力\n\t\tA[N + i] = A[i];\n\t\tA[2 * N + i] = A[i];\n\t\tsum_baum += A[i];\t//合計値の計算\n\t}\n\n\tfor (int j = 0; j < 3 * N; j++){\n//\t\tprintf(\"A[%d] = %d\\n\",j,A[j]);\n\t}\n\tdouble a = 3.0;\n\ttripartition = sum_baum / a;\n\t\n\tset = true;\t//セットの判定\n}\n\nlong long baumkuchen::piece(int cut_1, int cut_2){\n\tlong long piece = 0;\n\tif (cut_1>cut_2){\n\t\twhile (cut_1 != cut_2){\n\t\t\tpiece += A[cut_1 - 1];\n\t\t\tcut_1--;\n\t\t}\n\t\tpiece = sum_baum - piece;\n\n\t}\n\telse{\n\t\twhile (cut_2 != cut_1){\n\t\t\tpiece += A[cut_2 - 1];\n\t\t\tcut_2--;\n\t\t}\n\t}\n\treturn piece;\n}\n\n\nlong long baumkuchen::extended_full_search(){\n\tlong long keep_value;\n\tlong long keep_value2;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i <4*N; i++){\n\t\tint b;\n\t\tfor (b = i+1; b < 3 * N; b++){\n\t\t\tmemo[ b] = memo[ b - 1] + piece(b - 1, b);\n\t\t\tif (memo[ b] >= tripartition)break;\n\t\t}\n\t\tif (tripartition - memo[ b - 1] < memo[ b] - tripartition){\n\t\t\tkeep_value = memo[ b - 1];\n\t\t\tb--;\n\t\t}\n\t\telse keep_value = memo[ b];\n\t\tdouble half = (sum_baum - memo[ b]) / 2.0;\n\n\t\tint c;\n\t\tfor (c = b; c < 3 * N; c++){\n\t\t\tmemo[ c] = memo[ c - 1] + piece(c - 1, c);\n\t\t\tif (memo[ c] >= keep_value + half)break;\n\t\t}\n\t\tif (keep_value + half - memo[ c - 1] < memo[ c] - keep_value - half){\n\t\t\tkeep_value2 = memo[ c - 1];\n\t\t\tc--;\n\t\t}\n\t\telse keep_value2 = memo[ c];\n\n\t\tif (keep_value > keep_value2 - keep_value) keep_value = keep_value2 - keep_value;\n\t\tif (keep_value > sum_baum - keep_value2) keep_value = sum_baum - keep_value2;\n//\t\tprintf(\"i = %d\\t\", i);\n//\t\tprintf(\"c = %d\\n\\n\", c);\n\t\t\n\t\tif (set_value < keep_value)set_value = keep_value;\n\t\tif (c == N || c == 2*N || c== 3*N)break;\n\n\t}\n\n\treturn set_value;\n}\n\nlong long baumkuchen::full_search(){\n\tlong long keep_value;\n\tlong long set_value = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tfor (int k = j + 1; k < N; k++){\n\t\t\t\tif (piece(i, j) < piece(j, k)){\n\t\t\t\t\tif (piece(i, j) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(i, j);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (piece(j, k) < piece(k, i)){\n\t\t\t\t\t\tkeep_value = piece(j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tkeep_value = piece(k, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (set_value < keep_value){\n\t\t\t\t\tset_value = keep_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn set_value;\n}\n\nint main(){\n\tbaumkuchen *solve = new baumkuchen();\n\tsolve->set_value();\n\tlong long a = solve->extended_full_search();\n\tcout << a << endl;\n\n\n\tdelete solve;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n;\nlong long sum[110000];\n\nbool Func(long long key){\n\n\tfor(int i=1;i<n;i++){\n\n\t\tauto f=lower_bound(sum+i,sum+n+1,key+sum[i-1]);\n\t\tauto g=lower_bound(f,sum+n+1,key+*f);\n\n\t\tif(*g&&*g+key-sum[i-1]<=sum[n]){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\n\tcin>>n;\n\tsum[0]=0;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin>>sum[i+1];\n\t\tsum[i+1]+=sum[i];\n\t}\n\n\tlong long left=0,right=sum[n]/3+1,mid;\n\tlong long ans=0;\n\n\twhile(left<right){\n\n\t\tmid=(left+right)/2;\n\n\t\tif(Func(mid)){\n\t\t\tleft=mid+1;\n\t\t\tans=max(ans,mid);\n\t\t}\n\t\telse right=mid;\n\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define int long long\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RND(x,y) for(int x=-10;x<=10;x++)for(int y=-10;y<=10;y++)\nint n;\nint a[114514];\nint s[114514];\n\nint b(int x){\n  return distance(s,lower_bound(s,s+n,x));\n}\n\nint mod(int x,int y){\n  return (x%y+y)%y;\n}\n\nsigned main(){\n  cin>>n;\n  REP(i,n){\n    cin>>a[i];\n    s[i+1]=a[i]+s[i];\n  }\n  int ans=0;\n  int S=s[n];\n  REP(i,n){\n    int p=b((S/3+s[i])%S);\n    int q=b((S*2/3+s[i])%S);\n    RND(x,y){\n      int px=(p+x)%n;\n      int qy=(q+y)%n;\n      if(i>=px||px>=qy||qy>=i+n)continue;\n      int w1=mod(s[px]-s[i],S);\n      int w2=mod(s[qy]-s[px],S);\n      int w3=mod(s[i]-s[qy],S);\n      #ifdef DEBUG\n      cout<<(i)<<\" \"<<(px)<<\" \"<<(qy)<<\":\";\n      cout<<w1<<\" \"<<w2<<\" \"<<w3<<endl;\n      #endif\n      int wm=min({w1,w2,w3});\n      ans=max(ans,wm);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\nusing namespace std;\nusing Int = long long;\n#define REP2(i, n) for (Int i = 0, max_i = (n); i < max_i; i++)\n#define REP3(i, a, b) for (Int i = (a), max_i = (b); i < max_i; i++)\n#define OVERLOAD2(_1, _2, _3, name, ...) name\n#define REP(...) OVERLOAD2(__VA_ARGS__, REP3, REP2)(__VA_ARGS__)\nstruct SetupIO { SetupIO() { cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(13); } } setup_io;\n#ifndef _MY_DEBUG\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Tue Mar  3 01:57:57 JST 2020\n **/\n\nsigned main() {\n    Int n;\n    cin >> n;\n    vector<Int> a(n);\n    REP(i, n) cin >> a[i];\n    vector<Int> acc(2 * n + 1);\n    REP(i, 2 * n) acc[i + 1] = acc[i] + a[i % n];\n    auto check = [&](Int mid) -> bool {\n        REP(i, n) {\n            auto it = acc.begin() + i;\n            it = lower_bound(acc.begin(), acc.end(), *it + mid);\n            if (it - acc.begin() > i + n) continue;\n            it = lower_bound(acc.begin(), acc.end(), *it + mid);\n            if (it - acc.begin() > i + n) continue;\n            it = lower_bound(acc.begin(), acc.end(), *it + mid);\n            if (it - acc.begin() <= i + n) return true;\n        }\n        return false;\n    };\n    Int ok = 0, ng = 1e18;\n    while (abs(ok - ng) > 1) {\n        Int mid = (ok + ng) / 2;\n        (check(mid) ? ok : ng) = mid;\n    }\n    cout << ok << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint N;\nbool check(const int from, const vector<long long int>&sums, const long long int norma) {\n\tvector<long long int>nowsums(sums.begin() + from, sums.begin() + from + N+1);\n\tlong long int base = *nowsums.begin();\n\tauto it = lower_bound(nowsums.begin(), nowsums.end(), base + norma);\n\tif (it == nowsums.end())return false;\n\tbase = *it;\n\tauto jt = lower_bound(it, nowsums.end(), base + norma);\n\tif (jt == nowsums.end())return false;\n\tbase = *jt;\n\tif (nowsums.back() - base >= norma)return true;\n\telse return false;\n\n}\nint main() {\n\tcin >> N;\n\tvector<long long int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int a; cin >> a;\n\t\tnums.push_back(a);\n\t}\n\tlong long int sum = 0;\n\tvector<long long int>sums;\n\tsums.push_back(sum);\n\tfor (int t = 0; t < 2; ++t) {\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tsum += nums[i];\n\t\t\tsums.push_back(sum);\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tlong long int amin = 0;\n\t\tlong long int amax = 1e18;\n\t\twhile (amin + 1 != amax) {\n\t\t\tlong long int amid = (amin + amax) / 2;\n\t\t\tif (check(i,sums, amid)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, amin);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    ll sum=0;\n    vector<ll> a(2*n);\n    rep(i,n)\n    {\n        scanf(\" %lld\", &a[i]);\n        a[i+n]=a[i];\n        sum+=a[i];\n    }\n\n    vector<ll> presum(2*n+1,0);\n    for(int i=1; i<=2*n; ++i) presum[i] = presum[i-1]+a[i-1];\n\n    ll ans=0;\n    rep(i,n)\n    {\n        int x = lower_bound(all(presum),presum[i]+sum/3)-presum.begin();\n        int y = lower_bound(all(presum),presum[i]+sum*2/3)-presum.begin();\n        for(int j=x-1; j<=x+1; ++j)for(int k=y-1; k<=y+1; ++k)\n        {\n            if(i<j && j<k && j<i+n && k<i+n)\n            {\n                ll p = presum[j]-presum[i];\n                ll q = presum[k]-presum[j];\n                ll r = presum[i+n]-presum[k];\n\n                ans = max(ans, min({p,q,r}));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1ll << 60;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n#ifdef WIN32\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\"\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\"\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\nint n;\nVI manysize;\n\nvoid solve() {\n\tint num = n / 3;\n\tint size1 = 0, size2 = 0, size3 = 0;\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize1 += manysize[ i ];\n\t}\n\tfor ( int i = 0; i < num; i++ ) {\n\t\tsize2 += manysize[ i + num ];\n\t}\n\tfor ( int j = num * 2; j < n; j++ ) {\n\t\tsize3 += manysize[ j ];\n\t}\n\tint ans = min( size1, max( size2, size3 ) );\n\tint now1 = num, now2 = num * 2, now3 = 0;\n\tset < pair<int, PII> > s;\n\twhile ( !s.count( MP( now1, MP( now2, now3 ) ) ) ) {\n\t\ts.insert( MP( now1, MP( now2, now3 ) ) );\n\t\tif ( size3 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size3 );\n\t\t\tsize3 += manysize[ now3 ];\n\t\t\tsize1 -= manysize[ now3 ];\n\t\t\tnow3++;\n\t\t\tnow3 %= n;\n\t\t}\n\t\telse if ( size2 == min( size1, min( size2, size3 ) ) ) {\n\t\t\tans = max( ans, size2 );\n\t\t\tsize2 += manysize[ now2 ];\n\t\t\tsize3 -= manysize[ now2 ];\n\t\t\tnow2++;\n\t\t\tnow2 %= n;\n\t\t}\n\t\telse {\n\t\t\tans = max( ans, size1 );\n\t\t\tsize1 += manysize[ now1 ];\n\t\t\tsize2 -= manysize[ now1 ];\n\t\t\tnow1++;\n\t\t\tnow1 %= n;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio( false );\n\tcin.tie( 0 );\n#ifdef WIN32\n\t\n#endif\n\tcin >> n;\n\tmanysize.resize( n );\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> manysize[ i ];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\t//brute-fource\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\trep(i, n) REP(j, i + 1, n)\n\t\t{\n\t\t\tint size = cuts[j] - cuts[i];\n\t\t\tint rem = ceil(double(sum - size) / 2.0);\n\t\t\tint sep = lower_bound(all(cuts), cuts[j] + rem) - cuts.begin();\n\t\t\tint k = sep;\n\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\tans = max(ans, min({ a, b, c }));\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef unsigned long long ull;\n\nint CalcPiece(int _i, ull *_piece, const ull _upper_limit, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _upper_limit){\n\t\t*_piece = tmp;\n\t\ttmp += _A[_i % _N];\n\t\t_i++;\n\t}\n\treturn _i - 1;\n}\n\nvoid CalcPiece1(int _i1, ull *_piece1_s, ull *_piece1_l, const ull _one_third_size, const int *_A, const int _N){\n\tull tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece1_s = tmp;\n\t\ttmp += _A[_i1 % _N];\n\t\t_i1++;\n\t}\n\t*_piece1_l = tmp;\n}\n\nvoid CalcPiece3(int _i3, ull *_piece3_s, ull *_piece3_l, const ull _one_third_size, const int *_A, const int _N){\n\tull tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece3_s = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n\t*_piece3_l = tmp;\n}\n\nint CalcPiece3(int _i3, ull *_piece3, const ull _one_third_size, const int *_A, const int _N){\n\tull  tmp = 0;\n\twhile (tmp <= _one_third_size){\n\t\t*_piece3 = tmp;\n\t\ttmp += _A[_i3 % _N];\n\t\t_i3--;\n\t}\n\treturn _i3++;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\t//切れ込みの個数\n\tcin >> N;\n\n\tint *A = new int[N];\t//各ピースの大きさを格納する配列\n\tull total_size = 0;\t//バームクーヘンの大きさ\n\tfor(int i=0; i<N; i++){\n\t\tcin >> A[i];\n\t\ttotal_size += A[i];\n\t}\n\tull one_third_size = total_size / 3;\n\n\tull answer = 0;\n\n\tfor (int i = 0; i < N; i++){\n\t\t/*\n\t\tull piece1 = 0;\n\t\tint i1 = i;\n\t\ti1 = CalcPiece(i1, &piece1, one_third_size, A, N);\n\n\t\tull two_third_size = (total_size - piece1) / 2;\n\t\tint i2 = i1;\n\t\tull piece2 = 0;\n\t\ti2 = CalcPiece(i2, &piece2, two_third_size, A, N);\n\n\t\tint i3 = i2;\n\t\tull piece3 = total_size - piece1 - piece2;\n\t\twhile (piece3 > two_third_size){\n\t\t\tpiece3 -= A[i3 % N];\n\t\t\ti3++;\n\t\t}\n\n\t\tull tmp = 0;\n\t\tif (piece1 < piece2 && piece1 < piece3){\n\t\t\ttmp = piece1;\n\t\t}\n\t\telse if (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\n\t\tpiece1 += A[i1 % N];\n\t\ttwo_third_size = (total_size - piece1) / 2;\n\t\ti2 = i1 + 1;\n\t\tCalcPiece(i2, &piece2, two_third_size, A, N);\n\t\tpiece3 = total_size - piece1 - piece2;\n\t\tif (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\n\t\ti3 = i - 1 + N;\n\t\tCalcPiece3(i3, &piece3, two_third_size, A, N);\n\t\tpiece2 = total_size - piece1 - piece3;\n\t\tif (piece2 < piece3){\n\t\t\ttmp = piece2;\n\t\t}\n\t\telse{\n\t\t\ttmp = piece3;\n\t\t}\n\t\tif (tmp > answer) answer = tmp;\n\t\t/*/\n\t\tull piece1_s = 0, piece1_l = 0;\n\t\tint i1 = i;\n\t\tCalcPiece1(i1, &piece1_s, &piece1_l, one_third_size, A, N);\n\t\t\n\t\tull piece3_s = 0, piece3_l = 0;\n\t\tint i3 = i + N - 1;\n\t\tCalcPiece3(i3, &piece3_s, &piece3_l, one_third_size, A, N);\n\n\t\tull tmp = 0;\n\t\tif (piece1_s < piece3_s) tmp = piece1_s;\n\t\telse tmp = piece3_s;\n\n\t\tull piece2_sl = total_size - piece1_s - piece3_l;\n\t\tif (piece2_sl < piece1_s && piece2_sl > tmp) tmp = piece2_sl;\n\n\t\tull piece2_ls = total_size - piece1_l - piece3_s;\n\t\tif (piece2_ls < piece3_s && piece2_ls > tmp) tmp = piece2_ls;\n\n\t\tull piece2_ll = total_size - piece1_l - piece3_l;\n\t\tif (piece2_ll > tmp) tmp = piece2_ll;\n\n\t\tif (tmp > answer) answer = tmp;\n\t\t//*/\n\t}\n\n\tcout << answer << endl;\n\n\tdelete[] A;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[200001];\n\nbool check(long long x)\n{\n\tint l = 0, r = 1;\n\tfor (; r <= n; r++){\n\t\tif (a[r] - a[l] < x) continue;\n\t\twhile (a[r] - a[l + 1] >= x) l++;\n\t\t\n\t\tint tail = l + n;\n\t\tint mid = lower_bound(a + l + 1, a + tail + 1, (a[r] - a[l]) * 2 + a[l]) - a;\n\t\t\n\t\tif (mid == tail + 1) continue;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\", l, r, mid, tail);\n\t\t\n\t\tif (\n\t\t\tr != mid &&\n\t\t\tmid != tail &&\n\t\t\ttail - n != l + 1 &&\n\t\t\ta[mid] - a[r] >= a[r] - a[l] &&\n\t\t\ta[tail] - a[mid] >= a[r] - a[l]\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\t\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\t\n\tlong long l = 0, r = 1000000000LL * 100000LL;\n\twhile (l <= r){\n\t\tlong long mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\t\n\tprintf(\"%d\\n\", r);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint fib(int n);\n\nmap<int, int> fib_array;\n\n\nint main(){\n\tint input;\n\tcin >> input;\n\n\tcout << fib(input) << endl;\n\treturn 0;\n\n\n}\n\nint fib(int n){\n\tswitch (n)\n\t{\n\tcase 0:\n\tcase 1:\n\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t\n\tif (fib_array[n] == 0){\n\t\tint new_fib = fib(n - 1) + fib(n - 2);\n\t\tfib_array[n] = new_fib;\n\t\treturn new_fib;\n\t}\n\telse{\n\t\treturn fib_array[n];\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nlong long a[200001];\n\nbool check(long long x)\n{\n\tint l = 0, r = 1;\n\tfor (; r <= n; r++){\n\t\tif (a[r] - a[l] < x) continue;\n\t\twhile (a[r] - a[l + 1] >= x) l++;\n\t\t\n\t\tint tail = l + n;\n\t\tint mid = lower_bound(a + l + 1, a + tail + 1, (a[r] - a[l]) * 2 + a[l]) - a;\n\t\t\n\t\t//printf(\"%d %d %d %d\\n\", l, r, mid, tail);\n\t\t\n\t\tif (\n\t\t\tr != mid &&\n\t\t\tmid != tail &&\n\t\t\ta[mid] - a[r] >= a[r] - a[l] &&\n\t\t\ta[tail] - a[mid] >= a[r] - a[l]\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ta[i + n] = a[i];\n\t}\n\t\n\tfor (int i = 1; i <= 2 * n; i++){\n\t\ta[i] += a[i - 1];\n\t}\n\t\n\tlong long l = 0, r = 1000000000LL * 100000LL;\n\twhile (l <= r){\n\t\tlong long mid = (l + r) / 2;\n\t\tif (check(mid)) l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\t\n\tprintf(\"%d\\n\", r);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing ll = long long;\n\nint n;\nvector<ll> a;\nvector<ll> imos;\n\nll sum(ll l, ll r){\n    return imos[r] - imos[l];\n}\n\nll get(int l, int r, ll lb){\n    ll x = l;\n    while(l+1 < r){\n        int m = (l+r)/2;\n        if(sum(x,m) < lb) l = m;\n        else r = m;\n    }\n    return r;\n}\n\nbool check(ll lb){\n    rep(i,n){\n        ll x = get(i,i+n,lb);\n        ll y = get(x,i+n,lb);\n        if(sum(i,x) >= lb && sum(x,y) >= lb && sum(y,i+n) >= lb){\n            return true;\n        }\n    }\n    return false;\n}\n\nll solve(){\n    a.insert(a.end(), a.begin(), a.end());\n    imos.assign(a.size()+1,0);\n    rep(i,a.size()) imos[i+1] = imos[i] + a[i];\n    ll l = 1, r = imos[n]/3;\n    while(l+1 < r){\n        ll m = (l+r)/2;\n        if(check(m)) l = m; else r = m;\n    }\n    return l;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin >> n;\n    a.resize(n);\n    rep(i,n) cin >> a[i];\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nll n, a[100010], sum;\n\nbool check(ll x) { // [t0, t1) [t1, t2)\n  ll t0 = 0, t1 = 0, t2 = 0, s1 = 0, s2 = 0;\n  while (t1 < n && s1 < x) s1 += a[t1++];\n  t2 = t1;\n  while (t2 < n && s2 < x) s2 += a[t2++];\n  if (t2 == n) return false;\n  if (sum - s1 - s2 >= x) return true;\n  for (ll i = 1; i < n; i++) {\n    s1 -= a[t0++];\n    while (s1 < x) s1 += a[t1], s2 -= a[t1], t1 = (t1 == n-1) ? 0 : (t1 + 1);\n    while (s2 < x) s2 += a[t2], t2 = (t2 == n-1) ? 0 : (t2 + 1);\n    if (sum - s1 - s2 >= x) return true;\n  }\n  return false;\n}\n\nint main() {\n  scanf(\"%lld\", &n);\n  for (ll i = 0; i < n; i++) scanf(\"%lld\", &a[i]), sum += a[i];\n  ll lb = 1, ub = (sum / 3) + 1;\n  while (lb + 1 < ub) {\n    ll mid = (lb + ub) / 2;\n    if (check(mid)) lb = mid;\n    else ub = mid;\n  }\n  printf(\"%lld\\n\", lb);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 100005;\n\nint n, A[MAX_N * 2];\n\nint binary(int i, int r, int tar) {\n  int l = i;\n  while (1 <= r - l) {\n    int mid = (r + l) / 2, p = A[mid - 1] - A[i - 1], p1 = A[mid - 2] - A[i - 1], p2 = A[mid] - A[i - 1];\n\n    if (abs(tar - p) < abs(tar - p1) && abs(tar - p) < abs(tar - p2)) {\n      l = mid;\n      break;\n    }\n\n    if (tar < p) r = mid;\n    else if (p < tar) l = mid + 1;\n  }\n\n  return l;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n;\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t;\n    cin >> t;\n    A[i] = A[i - 1] + t;\n  }\n  for (int i = 1; i <= n; ++i) {\n    A[i + n] = A[i + n - 1] + A[i] - A[i - 1];\n  }\n\n  int ans = 0, tar = A[n] / 3;\n  for (int i = 1; i < n - 2; ++i) {\n    int c2 = binary(i, n - 2, tar), tmin = A[c2 - 1] - A[i - 1], c3 = binary(c2 + 1, n - 1, tar);\n    tmin = min(tmin, A[c3 - 1] - A[c2 - 1]);\n    tmin = min(tmin, A[i + n - 1] - A[c3 - 1]);\n    ans = max(ans, tmin);\n\n    for (int j = -1; j < 2; ++j) {\n      int tc2 = c2 + j, tc3 = c3 + j;\n      tmin = A[tc2 - 1] - A[i - 1];\n      tmin = min(tmin, A[tc3 - 1] - A[tc2 - 1]);\n      tmin = min(tmin, A[i + n - 1] - A[tc3 - 1]);\n      ans = max(ans, tmin);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nint N;\nll A[200000];\nll AA[200000];\nint l = 0;\nint r = 0;\nint LL,RR,CC;\nint main()\n{\n\tint i,j,k;\n\tll ans = 0;\n\tll sum = 0;\n\tll sum1; \n\tll sum2;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++){\n\t\tscanf(\"%lld\", &A[i]);\n\t\tA[i + N] = A[i];\n\t}\n\tAA[0] = A[0];\n\tfor (i = 1; i < 2*N; i++)AA[i] = AA[i - 1] + A[i];\n\twhile (l < N){\n\t\tif(l!=0)sum = AA[r] - AA[l-1];\n\t\telse sum = AA[r];\n\t\t//printf(\"%d %d %lld\\n\", l, r,sum);\n\t\tif (sum > AA[N-1] / 3){\n\t\t\tl++;\n\t\t}\n\t\telse{\n\t\t\tLL = r; RR = N + l;\n\t\t\twhile (RR - LL>1){\n\t\t\t\tCC = (LL + RR) / 2;\n\t\t\t\tif(AA[CC] - AA[r] < sum)LL = CC+1;\n\t\t\t\telse RR = CC;\n\t\t\t}\n\t\t\tsum1 = AA[LL] - AA[r];\n\t\t\tsum2 = AA[N + l - 1] - AA[LL];\n\t\t\t//printf(\":%d %lld %lld\\n\", LL, sum1, sum2);\n\t\t\tif (sum <= sum1&&sum <= sum2)ans = max(ans, sum);\n\t\t\tr++;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long n, a[200000], s[200000], minx, miny, A, B, C, B2, C2, sum, d, e, f[3], g;\nint main() {\n\tint Left,Right,Mid;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sum += a[i]; }\n\tfor (int i = 1; i <= n; i++) { s[i] = s[i - 1] + a[i]; }\n\tfor (int i = 0; i <= n; i++) {\n\t\tA = s[i];\n\t\tB = (s[i] + sum / 3) % sum;\n\t\tC = (s[i] + sum * 2 / 3) % sum;\n\n\t\tfor (int j = i; j <= n + 1; j++) {\n            if (s[(j - 1) % n + 1] >= B) { B2 = s[(j - 1) % n + 1]; d = (j - 1) % n + 1; break; }\n        }\n        for (int j = i; j <= n + 1; j++) {\n            if (s[(j - 1) % n + 1] >= C) { C2 = s[(j - 1) % n + 1]; e = (j - 1) % n + 1; break; }\n        }\n\n\t\tf[0] = i; f[1] = d; f[2] = e;\n\t\tsort(f, f + 3);\n\t\tg = f[0]; d = f[1]; e = f[2];\n\t\tminy = min(s[d] - s[g], s[e] - s[d]);\n\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\tminx = max(minx, miny);\n\n\t\tif (d - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (e - 1 >= 0) {\n\t\t\tminy = min(s[d] - s[g], s[e - 1] - s[d]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t\tif (d - 1 >= 0 && e - 1 >= 0) {\n\t\t\tminy = min(s[d - 1] - s[g], s[e - 1] - s[d - 1]);\n\t\t\tminy = min(miny, sum - (s[e - 1] - s[g]));\n\t\t\tminx = max(minx, miny);\n\t\t}\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2017/09/17\ndata will be seperated to 3 groups, a b c\nthe bigest(a) should >= sum / 3\nthen the second should >= (sum - a) / 3\nloop to find the just data that comply with the previous conditions\n*/\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n\t// end link to head\n\tint InArray[200000] = {0};\n\tint N = 0;\n\t\n\t// initialize input\n\tint temp;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> temp;\n\t\tInArray[i] = temp;\n\t\tInArray[i + N] = temp;\n\t}\n\t\n\t// Calculate sum and average\n\tlong long sum = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tlong long average;\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tlong long MaxMin = 0;\n\tlong long tempMin;\n\tlong long a1_sum, a2_sum;\n\tlong long average2;\n\t\n\tfor(int a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(int a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(int a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tcout << MaxMin << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 2);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\tn++;\n\t\trep(i, n) cuts[i + n] = cuts[i];\n\t\trep(i, n + n - 1) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\tint sep = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tif (sep <= right) sep = right + 1;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint tmin = 0;\n\n\t\t\tREP(k, sep, n)\n\t\t\t{\n\t\t\t\tint i = left, j = right;\n\t\t\t\tint a = cuts[i + n] - cuts[k], b = cuts[j] - cuts[i], c = cuts[k] - cuts[j];\n\t\t\t\tint ttmin = min({ a, b, c });\n\t\t\t\tans = max(ans, ttmin);\n\t\t\t\tif (tmin > ttmin) break;\n\t\t\t\ttmin = max(tmin, ttmin);\n\t\t\t\tsep = k;\n\t\t\t}\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (size <= tmin) right++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tleft++;\n\t\t\t\tsep--;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <numeric>\n\n#define i64 long long\n#define ui64 unsigned long long\n#define REP(i,n) for(int (i)=0;(i)<(n);i++)\n#define REP2(i,k,n) for(int (i)=(k);(i)<(n);i++)\n#define MDIST(a,b) abs(a-b)\n#define DIST(a,b) sqrt((a)*(a)+(b)*(b))\n#define ATCODER 1000000007\nusing namespace std;\n \n////////////////////////\n\nint get(vector<int> &e,int s,int t,int n){\n  //sum [e[s],e[t])\n  int f = (s+n)%n;\n  int g = (t+n)%n;\n  if(f>g){\n    return e[f]+e[0]-e[g];\n  }else{\n    return e[f]-e[g];\n  }\n}\n\nint main(){\n  //input\n  int n;\n  cin >> n;\n  vector<int> d(n);\n  for(int i=0;i<n;i++){\n    cin >> d[i];\n  }\n  \n  // cout << \"hoge\" << endl;\n  //solve\n  vector<int> e(d);\n  for(int i=n-1;i;i--){\n    e[i-1] += e[i];\n  }\n  int sum = e[n];\n  int res = -1;\n  \n  // for(int i=0;i<n;i++){\n  //   cout << get(e,i,i+5,n) << endl;\n  // }\n  \n  for(int i=0;i<n;i++){\n    //1st cut i;\n    // cout << i << endl;\n    int m = -1;\n    for(int l=i+1,r=i+n;;){\n      // cout << l << \" \" << r << endl;\n      m=(l+r)/2;\n      if(r-l<=1){\n        if(get(e,l,m,n)>sum/3)m--;\n        break;\n      }\n      if(2*get(e,i,m,n)<get(e,m,i+n,n)){\n        l = m;\n      }else if(2*get(e,i,m,n)>get(e,m,i+n,n)){\n        r = m;\n      }else break;\n    }\n    // cout << m << \" \";\n    int m2 = -1;\n    for(int l=m+1,r=i+n;;){\n      m2=(l+r)/2;\n      if(r-l<=1){\n        if(get(e,l,m2,n)<sum/3)m2++;\n        break;\n      }\n      if(get(e,m,m2,n)<get(e,m2,i+n,n)){\n        l = m2;\n      }else if(get(e,m,m2,n)>get(e,m2,i+n,n)){\n        r = m2;\n      }else break;\n    }\n    // cout << m2 << endl;\n    int t1,t2,t3;\n    t1 = get(e,i,m,n);\n    t2 = get(e,m,m2,n);\n    t3 = get(e,m2,i+n,n);\n    // cout << t1 << \" \" << t2 << \" \" << t3 << endl;\n    if(t1>t2||t1>t3);\n    else res = max(res,t1);\n  }\n  \n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint N;\nlong long A[200010];\nlong long T[200010];\n\nbool f(long long X) {\n  for (int i=0; i<N; i++) {\n    int j = i;\n    long long d = 0;\n\n    auto it = lower_bound(T+j, T+i+N, X + (j > 0 ? T[j-1] : 0));\n    if (it == T+i+N) continue;\n    j = it - T;\n    j++;\n\n    it = lower_bound(T+j, T+i+N, X + (j > 0 ? T[j-1] : 0));\n    if (it == T+i+N) continue;\n    j = it - T;\n    j++;\n\n    if (T[i+N-1] - T[j-1] >= X) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin >> N;\n  for (int i=0; i<N; i++) {\n    int a;\n    cin >> a;\n    A[i] = A[i+N] = a;\n  }\n  long long t = 0;\n  for (int i=0; i<N+N; i++) {\n    t += A[i];\n    T[i] = t;\n  }\n\n  long long lo = 0, hi = 1000000000000000000L;\n  long long m;\n  while (hi - lo > 1) {\n    m = (lo + hi) / 2;\n    if (f(m)) lo = m;\n    else      hi = m;\n  }\n  if (f(hi)) m = hi;\n  else       m = lo;\n\n  cout << m << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define LL long long\nint N;\nLL A[200010];\n\nbool judge(LL x){\n    for(int s = 0; s < N; s++){//始点\n        int lb = s, ub = s + N + 1;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid] >= x + A[s]){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        int t = ub;\n        lb = ub;\n        ub = s + N + 1;\n        while(ub - lb > 1){\n            int mid = (ub + lb) / 2;\n            if(A[mid] >= x + A[t]){\n                ub = mid;\n            }else{\n                lb = mid;\n            }\n        }\n        if(A[s + N] - A[ub] >= x) return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> N;\n    for(int i = 1; i <= N; i++){\n        cin >> A[i];\n        A[i + N] = A[i];\n    }\n    for(int i = 1; i <= N * 2; i++){\n        A[i] += A[i - 1];\n    }\n    LL lb = 0;\n    LL ub = A[N];\n    while(ub - lb > 1){\n        LL mid = (ub + lb) / 2;\n        if(judge(mid)){\n            lb = mid;\n        }else{\n            ub = mid;\n        }\n    }\n    cout << lb << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 INF = i64(1e18) + 7;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<i64> a(n);\n    for(auto& x : a)\n        cin >> x;\n\n    vector<i64> r(1, 0);\n    for(int i = 0; i < n; ++i)\n        r.emplace_back(r[i] + a[i]);\n    for(int i = 0; i < n; ++i)\n        r.emplace_back(r[i + n] + a[i]);\n\n    i64 n_sum = accumulate(a.begin(), a.end(), 0LL);\n\n    auto f = [&](i64 val){\n\n        for(int i = 0; i < n; ++i){\n            auto it = lower_bound(r.begin(), r.end(), r[i] + val);\n            if(it >= next(r.begin(), i + n))\n                continue;\n            i64 s1 = *it;\n\n            it = lower_bound(r.begin(), r.end(), s1 + val);\n            if(it >= next(r.begin(), i + n))\n                continue;\n            i64 s2 = *it;\n\n            i64 diff = n_sum - s2 + r[i];\n\n            if(diff >= val)\n                return true;\n        }\n\n        return false;\n    };\n\n    i64 ok = 0, ng = n_sum;\n    while(abs(ok - ng) > 1){\n        i64 mid = (ok + ng) >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n\n    cout << ok << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\nint main(void){\n\tint n;\n\tlong long a[210000];\n\tint l, r;\n\tint m;\n\tlong long s;\n\tlong long max;\n\tlong long s1, s2, s3;\n\tint z;\n\ts = 0;\n\tscanf(\"%d\", &n);\n\ta[0] = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t\ts = s + a[i];\n\t\ta[i] = a[i] + a[i - 1];\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\ta[n + i] = a[i] + s;\n\t}\n\tmax = 0;\n\tl = 0;\n\tr = 1;\n\ts1 = a[1];\n\tm = 2;\n\ts2 = a[2] - a[1];\n\ts3 = s - a[2];\n\tfor (; l < n;){\n\t\tz = 0;\n\t\t\tif (s1 <= s2&&s1 <= s3)z = 1;\n\t\tfor (; s2 < (s - s1) / 2;){\n\t\t\tm++;\n\t\t\ts2 = s2 + a[m] - a[m - 1];\n\t\t\ts3 = s3 - a[m] + a[m - 1];\n\t\t\tif (s1 <= s2&&s1 <= s3)z = 1;\n\t\t}\n\t\tif (z == 1){\n\t\t\tif (max < s1)max = s1;\n\t\t\tr++;\n\t\t\ts1 = s1 + a[r] - a[r - 1];\n\t\t\ts2 = s2 + a[r - 1] - a[r];\n\t\t}\n\t\telse{\n\t\t\tl++;\n\t\t\ts1 = s1 + a[l - 1] - a[l];\n\t\t\ts3 = s3 - a[l - 1] + a[l];\n\t\t}\n\t}\nprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define REP(i, s, n) for(int i = (s); i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nconst int MOD = 10000;\nsigned main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<int> cuts(n + n + 1);\n\t\trep(i, n) cin >> cuts[i + 1];\n\t\tint sum = accumulate(all(cuts), 0);\n\t\trep(i, n) cuts[i + n + 1] = cuts[i + 1];\n\t\trep(i, n + n) cuts[i + 1] += cuts[i];\n\n\t\tint ans = 0;\n\n\t\tint left = 0, right = 0;\n\t\twhile (left < n)\n\t\t{\n\t\t\tif (left == right) right++;\n\t\t\tint size = cuts[right] - cuts[left];\n\t\t\tint ideal = static_cast<int>((double(sum - size) / 2.0) + 0.99999999);\n\t\t\tint sep = lower_bound(all(cuts), ideal + cuts[right]) - cuts.begin();\n\n\t\t\tint next = cuts[sep] - cuts[right];\n\t\t\tint rem = sum - next - size;\n\n\t\t\tint tmin = min({ next, rem, size });\n\t\t\tans = max(ans, tmin);\n\n\t\t\t//sizeが最小なら大きくする\n\t\t\tif (tmin >= size) right++;\n\t\t\telse left++;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<limits>\n\n#ifndef  LLONG_MAX\n#define LLONG_MAX 9223372036854775807\n#endif\n\nusing namespace std;\ntypedef long long llong;\n\nint N;\nllong *v_list;\ndouble tripartition;\n\t\nllong BaumukuchenGetAnswer();\nllong searchOne(int n0);\nllong getMinV(int n0, int n1, int n2);\nint findIndex(int from_n, int to_n, double target);\n\nint main(){\n\t/*\n\tifstream fin(\"input.txt\");\n\tfin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tfin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\tfin.close();\n\t/*/\n\tcin >> N;\n\tv_list = new llong[N+1];\n\tv_list[0] = 0;\n\tfor(int n=1; n<N+1; n++){\n\t\tllong A;\n\t\tcin >> A;\n\t\tv_list[n] = v_list[n-1] + A;\n\t}\n\t//*/\n\tcout << BaumukuchenGetAnswer() <<endl;\n\tdelete[] v_list;\n}\n\n\nllong BaumukuchenGetAnswer(){\n\ttripartition = v_list[N] / 3.0;\n\tllong interm_maxV = -1;\n\tint n0_max = findIndex(0, N, tripartition);\n\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\tllong tmp = searchOne(n0);\n\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t}\n\treturn interm_maxV;\n}\n\nllong searchOne(int n0){\n\tint n1_left = findIndex(n0, N, tripartition + v_list[n0]);\n\tint n2_left = findIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\tllong V_ll = getMinV(n0, n1_left, n2_left);\n\tllong V_lr = getMinV(n0, n1_left, n2_left+1);\n\tllong V_rl = getMinV(n0, n1_left+1, n2_left);\n\tllong V_rr = getMinV(n0, n1_left+1, n2_left+1);\n\treturn max( max(V_ll,V_lr), max(V_rl, V_rr));\n}\n\nllong getMinV(int n0, int n1, int n2){\n\tif (n1 == -1 || n2 == -1) return LLONG_MAX;\n\telse {\n\t\tllong V0 = v_list[n1] - v_list[n0];\n\t\tllong V1 = v_list[n2] - v_list[n1];\n\t\tllong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\treturn min(min(V0,V1),V2);\n\t}\n}\n\nint findIndex(int from_n, int to_n, double target){\n\tint n_left = from_n;\n\tint n_right = to_n;\n\twhile (n_right - n_left != 2) {\n\t\tint n_mid = (n_right + n_left) / 2;\n\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\telse n_right = n_mid;\n\t}\n\treturn n_left;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint main()\n{\n\tint i,j,k,n,min,max = INT_MIN;\n\tint a[100000],sum[3];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=n-1;i>1;i--)\n\t{\n\t\tfor(j=1;j<i;j++)\n\t\t{\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tsum[k] = 0;\n\t\t\t}\n\t\t\tmin = INT_MAX;\n\t\t\tfor(k=0;k<j;k++)\n\t\t\t{\n\t\t\t\tsum[0] += a[k];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(k=j;k<i;k++)\n\t\t\t{\n\t\t\t\tsum[1] += a[k];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(k=i;k<n;k++)\n\t\t\t{\n\t\t\t\tsum[2] += a[k];\n\t\t\t}\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tmin = MIN(sum[k],min);\n\t\t\t}\n\t\t\tif(min > max)\n\t\t\t{\n\t\t\t\tmax = min;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint N;\nlong long A[200010];\n\nint nibutan(int start,int end,long long target) {\n\tint left=start+1,right=end;\n\tint ok_min=right;\n\twhile(left<=right) {\n\t\tint mid=(left+right)/2;\n\t\tif(target<=A[mid]-A[start]) {\n\t\t\tif(mid<ok_min)ok_min=mid;\n\t\t\tright=mid-1;\n\t\t} else {\n\t\t\tleft=mid+1;\n\t\t}\n\t}\n\treturn ok_min;\n}\n\nint is_ok(long long p) {\n\tint i;\n\tfor(i=0;i<N;i++) {\n\t\tint a,b;\n\t\ta=nibutan(i,i+N,p);\n\t\tif(A[a]-A[i]<p)continue;\n\t\tb=nibutan(a,i+N,p);\n\t\tif(A[b]-A[a]>=p && A[i+N]-A[b]>=p)return 1;\n\t}\n\treturn 0;\n}\n\nvoid printll(long long v) {\n\tchar buf[64];\n\tchar *p=buf;\n\tif(v<0) {\n\t\tputchar('-');\n\t\tv=-v;\n\t}\n\tdo {\n\t\t*(p++)=(char)(v%10+'0');\n\t} while((v/=10)>0);\n\tdo {\n\t\tputchar(*(--p));\n\t} while(p!=buf);\n}\n\nint main(void) {\n\tint i;\n\tlong long left,right,ans;\n\tif(scanf(\"%d\",&N)!=1)return 1;\n\tfor(i=1;i<=N;i++) {\n\t\tint buf;\n\t\tif(scanf(\"%d\",&buf)!=1)return 1;\n\t\tA[i]=+buf;\n\t}\n\tfor(i=1;i<=N;i++) {\n\t\tA[N+i]=A[i];\n\t}\n\tfor(i=1;i<=N+N;i++)A[i]+=A[i-1];\n\tans=left=0;right=A[N+N];\n\twhile(left<=right) {\n\t\tlong long mid=(left+right)/2;\n\t\tif(is_ok(mid)) {\n\t\t\tif(ans<mid)ans=mid;\n\t\t\tleft=mid+1;\n\t\t} else {\n\t\t\tright=mid-1;\n\t\t}\n\t}\n\tprintll(ans);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define NMAX 100000\nint main(void)\n{\n  int i, n, s = 0, t = 0, a[NMAX];\n  long long ans = 0, p[3], asum[NMAX*2];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  asum[0] = a[0];\n  for (i = 1; i < n * 2; i++) asum[i] = asum[i-1] + a[i%n];\n  p[0] = 0;\n  while (s < n) {\n    int lo, hi, mid = 0;\n    while (mid != s + n - 1) {\n      while (p[0] <= ans) {\n        t++;\n        p[0] += a[(t-1)%n];\n      }\n      lo = t;\n      hi = s + n - 1;\n      while (hi >= lo) {\n        mid = (lo + hi) / 2;\n        if (asum[mid] >= p[0] + asum[t-1]) hi = mid - 1;\n        else lo = mid + 1;\n      }\n      if (mid != s + n - 1) {\n        p[1] = asum[lo] - asum[t-1];\n        p[2] = asum[n-1] - p[0] - p[1];\n        if (p[2] >= p[0]) ans = p[0];\n        else break;\n      }\n    }\n    s++;\n    p[0] = asum[t-1] - asum[s-1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N_MAX 100000\ntypedef unsigned long ul;\n\nul a[N_MAX];\nint n;\nul sum, ansmax;\n\nint isvalid(int end, ul psum){\n\tint i = end;\n\tul qsum = 0;\n\twhile(qsum < psum){\n\t\tqsum += a[i];\n\t\ti++;\n\t\tif (i == n) i = 0;\n\t}\n\treturn sum >= (psum * 2 + qsum);\n}\n\nint solve(void){\n\tlong ans = 0;\n\tint i;\n\tint end = 0;\n\tul peacesum = 0;\n\tfor(i = 0; i < n; i++){\n\t\twhile(peacesum <= ansmax){\n\t\t\tpeacesum += a[end];\n\t\t\tend++;\n\t\t\tif (end == n) end = 0;\n\t\t}\n\t\tend = (end ? end-1 : n-1);\n\t\tpeacesum -= a[end];\n\t\twhile(!isvalid(end, peacesum)){\n\t\t\tend = (end ? end-1 : n-1);\n\t\t\tpeacesum -= a[end];\n\t\t}\n\t\tif (peacesum > ans){\n\t\t\tans = peacesum;\n\t\t}\n\t\tpeacesum -= a[i];\n\t}\n\treturn printf(\"%ld\", ans);\n}\n\nint in(void){\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%ld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\tansmax = sum / 3;\n\treturn 0;\n}\n\nint main(void){\n\tin();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong Min(long a, long b, long c) {\n\tlong key = a;\n\tif(a>b) key = b;\n\tif(key > c) key =c;\n\treturn key;\n}\n\nint main(void) {\n\tint n;\n\tscanf(\"%d\", &n);\n\t\t\n\tint a[100000];\n\tlong whole=0;\n\tfor(int i=0; i<n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\twhole += a[i];\n\t}\t\n\t\t\n\tlong minmax=0;\n\tlong size[3];\n\t\t\n\tfor(int i=0; i<n-2; i++) { //1つめの切り込み\n\t\tfor(int j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\tsize[0]=0;\n\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\tsize[1]=0;\n\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\n\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\n\t\t\t\t\t//printf(\"(i,j,k)=(%d,%d,%d),(size[0], size[1], size[2]) = (%ld,%ld,%ld)\\n\" ,i,j,k,size[0],size[1], size[2]);\n\t\t\t\t\n\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\tif(min>minmax) minmax=min;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tprintf(\"%ld\\n\",minmax);\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong Min(long a, long b, long c) {\n\tlong key = a;\n\tif(a>b) key = b;\n\tif(key > c) key =c;\n\treturn key;\n}\n\nint main(void) {\n\tint n;\n\tint i,j,k,m;\n\tscanf(\"%d\", &n);\n\t\t\n\tint a[100000];\n\tlong whole=0;\n\tfor(i=0; i<n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\twhole += a[i];\n\t}\t\n\t\t\n\tlong minmax=0;\n\tlong size[3];\n\t\t\n\tfor(i=0; i<n-2; i++) { //1つめの切り込み\n\t\tfor(j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\tsize[0]=0;\n\t\t\tfor(k=i; k<j; k++) \n\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\n\t\t\tif(size[0] < whole/4 || size[0] > whole*3/4) continue;\n\t\t\t\t\t\n\t\t\tfor(k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\tsize[1]=0;\n\t\t\t\tfor(m=j; m<k; m++)\n\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\n\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\n\t\t\t\t\t//printf(\"(i,j,k)=(%d,%d,%d),(size[0], size[1], size[2]) = (%ld,%ld,%ld)\\n\" ,i,j,k,size[0],size[1], size[2]);\n\t\t\t\t\n\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\tif(min>minmax) minmax=min;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tprintf(\"%ld\\n\",minmax);\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0600\n  Title:Baumkuchen\n  @kankichi573\n*/\n#include <stdio.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n\nint n;\nint a[100000];\n\nmain()\n{\n  int i,j,k;\n  long long s1,s2,all,all31,max_;\n\n  scanf(\"%d\",&n);\n  for(i=all=0;i<n;i++)\n    {\n      scanf(\"%d\",&a[i]);\n      all += a[i];\n    }\n  all31=all/3;\n  max_=0;\n  for(i=0;i<n;i++)\n    {\n      s1=0;\n      for(j=0;j<n;j++)\n\t{\n\t  s1 += a[(i+j)%n];\n\t  //printf(\"%lld [%lld]\\n\",s1,all31);\n\t  if(s1>all31)\n\t    break;\n\t  if(s1<max_)\n\t    continue;\n\t  \n\t  s2=0;\n\t  for(k=1;k<n+1;k++)\n\t    {\n\t      s2 += a[(i+j+k)%n];\n\t      //printf(\">%lld %lld %lld\\n\",s1,s2,all-s1-s2);\n\t      if(s2<s1)\n\t\tcontinue;\n\t      else if(all-s1-s2 < s1)\n\t\tbreak;\n\t      max_=max(max_,s1);\n\t    }\n\t}\n    }\n  printf(\"%lld\\n\",max_);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define BUF_SIZE 20\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\n#define PARTS_MAX 100000\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint main(void) {\n    static uint64_t parts[PARTS_MAX*2];\n    int ps = get_int();\n    uint64_t sum3 = 0;\n    static uint64_t cum[PARTS_MAX*2+1];\n    uint64_t part_max = 0;\n    int i;\n    for(i = 0; i < ps; i++) {\n        parts[i] = parts[i+ps] = get_int();\n        part_max = max(part_max, parts[i]);\n    }\n    for(i = 1; i <= ps*2; i++) {\n        cum[i] = parts[i-1] + cum[i-1];\n    }\n    // max in theory.\n    uint64_t sum = cum[ps];\n    sum3 = max(sum / 3, part_max);\n#ifdef DEBUG\n    printf(\"sum3: %llu\\n\", sum3);\n#endif\n\n    int start, end;\n    uint64_t ans = 0;\n    uint64_t s = 0;\n    for(start = 0, end = 0; start < ps; start++) {\n        // Shactory Method .. set end\n        while(end < start+ps) {\n            uint64_t ns = s + parts[end];\n            if(ns > sum3) break;\n            s = ns;\n            end++;\n        }\n#ifdef DEBUG\n        printf(\"[%d, %d)\\n\", start, end);\n#endif\n        // [start, end-1], [end, high), [high, start+ps)\n\n        // search [end, start+ps) in [start, start+ps) using binary-search.\n        int low = end-1;\n        int high = start + ps;\n        while(low + 1 < high) {\n            int mid = (low + high)/2;\n            uint64_t vs = cum[mid] - cum[end]; // [end, mid)\n            // lower bound\n            if(s <= vs) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        // update answer\n        // [end, high)\n        uint64_t s2 = cum[high] - cum[end];\n        uint64_t rem = sum - s - s2;\n        uint64_t res = min(s, rem);\n#ifdef DEBUG\n        printf(\"[%d, %d), [%d, %d+1) -> %llu ;;\", start, end, end, high, s);\n        printf(\"%llu %llu %llu\\n\", s, s2, rem);\n#endif\n        ans = max(ans, res);\n\n        // update s\n        s -= parts[start];\n    }\n    printf(\"%llu\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0600 Baumkuchen\n// 2017.12.5 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint a[100002], p[100002];\nlong long s[100002];\n\nchar buf[15], *bp;\nint getint()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, ii, f;\n\tlong long sum, l, m, r;\n\n\tfgets(bp=buf, 15, stdin), n = getint();\n\tfor (sum = 0, i = 0; i < n; i++) {\n\t\tfgets(bp=buf, 15, stdin);\n\t\tsum += a[i] = getint();\n\t}\n\t\n\tl = 0, r = sum + 1;\n\twhile (l + 1 < r) {\n\t\tm = (l+r) >> 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (!i) s[i] = p[i] = 0;\n\t\t\telse p[i] = p[i-1] - 1, s[i] = s[i-1] - a[i-1];\n\t\t\t\n\t\t\twhile (s[i] < m) {\n\t\t\t\tii = (i + p[i]) % n;\n\t\t\t\ts[i] += a[ii], p[i]++;\n\t\t\t}\n\t\t}\n\t\n\t\tfor (f = 0, i = 0; i < n; i++) {\n\t\t\tii = (i + p[i]) % n;\n\t\t\tif (sum - s[i] - s[ii] >= m) f = 1;\n\t\t}\n\t\tif (f) l = m; else r = m;\n    }\n\tprintf(\"%lld\\n\", l);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long a[100000];\nint n;\n\nint i,x;\nint j,y;\nint k,z;\nint l,w;\nint m;\n\nlong long ans = 0;\n\nfloat fmax(float x,float y){\n\tif(x < y)return y;return x;\n}\n\nlong long min(long long a,long long b){\n\tif(a < b)return a;return b;\n}\nlong long max(long long a,long long b){\n\treturn a + b - min(a,b);\n}\n\nvoid solve(void){\nx = n / 3;\nl = 0;\nfor(i = 0;i < n;i++){\n\tl += a[i];\n\tfor(j = i + 1;j < n;j++){\n\t\tlong long h;\n\t\ty = 0;\n\t\tfor(k = j + 1;k < n;k++)y += a[k];\n\t\tz = 0;\n\t\tfor(k = j + 1;y / 2 < z;k++)z += a[k];\n\t\t//--\n\t\th = max((long long)(((float)y) / 2 - fmax((z - ((float)y)/2) , (((float)y)/2 - (z - a[k])))),0);\n\t\tans = max(min(l,h),ans);\n\t}\n}\nw = l;\nfor(i = 1;i < n;i++){\n\tl = 0;\n\tfor(j = i;j < n + i;j++){\n\t\tl += a[j % n];\n\t\tif(l < ans)continue;\n\t\tif(w - l < ans * 2)break;\n\t\tm = 0;\n\t\tfor(k = j + 1;k < n + i;k++){\n\t\t\tm += a[k % n];\n\t\t\tif(m < ans)continue;\n\t\t\tif(w-l-m < ans)break;\n\t\t\tans = min(min(l,m),w-l-m);\n\t\t}\n\t}\n}\nprintf(\"%lld\\n\",ans);\nreturn;\n}\n\nint main(void){\nscanf(\"%d\",&n);\nfor(i = 0;i < n;i++)scanf(\"%d\",a+i);\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0600\n  Title:Baumkuchen\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n \nint n;\nint a[100000];\nlong long t1_3_fw[100000];\nlong long t1_3_bk[100000];\n\nlong long all,all31; // one third of all\n\nprepare()\n{\n  long long s;\n  int i,j;\n\n  for(i=s=0;i<n;i++)\n    {\n      s+=a[i];\n\n      if(s>all31)\n\t{\n\t  t1_3_fw[0]=s;\n\t  j=i+1;\n\t  j %= n;\n\t  break;\n\t}\n    }\n\n  for(i=1;i<n;i++)\n    {\n      //printf(\"%lld-%d=%lld\\n\",s,a[i-1],s-a[i-1]);\n      s -= a[i-1];\n      while(s<all31)\n\t{\n\t  //printf(\"%lld+%d=%lld\\n\",s,a[j],s+a[j]);\n\t  s += a[j];\n\t  j++;\n\t  j %= n;\n\t}\n      t1_3_fw[i]=s;\n      //printf(\"t[%d]=%d\\n\",i,t13[i]);\n    }\n}\n\nprepare2()\n{\n  long long s;\n  int i,j;\n\n  for(i=n-1,s=0;i>=0;i--)\n    {\n      s+=a[i];\n\n      if(s>all31)\n\t{\n\t  t1_3_bk[n-1]=s;\n\t  j=i-1;\n\t  if(j<0)j+=n;\n\t  break;\n\t}\n    }\n  //printf(\"t[%d]=%lld\\n\",0,t1_3_bk[0]);\n  for(i=n-2;i>=0;i--)\n    {\n      //printf(\"%lld-%d=%lld\\n\",s,a[i-1],s-a[i-1]);\n      s -= a[i+1];\n      while(s<all31)\n\t{\n\t  //printf(\"%lld+%d=%lld\\n\",s,a[j],s+a[j]);\n\t  s += a[j];\n\t  j--;\n\t  if(j<0)j+=n;\n\t}\n      t1_3_bk[i]=s;\n\n      //printf(\"t[%d]=%lld\\n\",i,t1_3_bk[i]);\n    }\n}\n \nmain()\n{\n  int i,j,k;\n  long long s1,s2,s3; // s1 shortest s2 longest s3 2nd\n  long long max_;\n  memset(t1_3_fw,0,sizeof(t1_3_fw));\n  memset(t1_3_fw,0,sizeof(t1_3_bk));\n  scanf(\"%d\",&n);\n  for(i=all=0;i<n;i++)\n    {\n      scanf(\"%d\",&a[i]);\n      all += a[i];\n    }\n\n  all31=all/3;\n \n  prepare();prepare2();\n  max_=0;\n  for(i=0;i<n;i++)\n    {\n      s1=0;\n      for(j=0;j<n;j++)\n\t{\n\t  s1 += a[(i+j)%n];\n\t  //printf(\"%lld [%lld]\\n\",s1,all31);\n\t  if(s1>all31)\n\t    break;\n\t  if(s1<max_)\n\t    continue;\n\t  \n\t  s2=t1_3_fw[(i+j+1)%n];\n\t  s3=all-s1-s2;\n\n\t  if(s3 >= s1)\n\t      max_=max(max_,s1);\n\t  \n\t  s2=t1_3_bk[(i-1+n)%n];\n\t  s3=all-s1-s2;\n\n\t  //printf(\"%lld %lld %lld\\n\",s1,s2,s3);\n\n\t  if(s3 >= s1)\n\t    max_=max(max_,s1);\n\t   \n\t  \n\t}\n    }\n  printf(\"%lld\\n\",max_);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long a[100000];\nint n;\n\nint i,x;\nint j,y;\nint k,z;\nint l,w;\nint m;\n\nlong long ans = 0;\n\nfloat fmax(float x,float y){\n\tif(x < y)return y;return x;\n}\n\nlong long min(long long a,long long b){\n\tif(a < b)return a;return b;\n}\nlong long max(long long a,long long b){\n\treturn a + b - min(a,b);\n}\n\nvoid solve(void){\nx = n / 3;\nl = 0;\nfor(i = 0;i < n;i++){\n\tl += a[i];\n\tfor(j = i + 1;j < n;j++){\n\t\tlong long h;\n\t\ty = 0;\n\t\tfor(k = j + 1;k < n;k++)y += a[k];\n\t\tz = 0;\n\t\tfor(k = j + 1;y / 2 < z;k++)z += a[k];\n\t\t//--\n\t\th = (long long)(((float)y) / 2 - fmax(abs(z - ((float)y)/2) , abs(((float)y)/2 - z + a[k])));\n\t\tans = max(min(l,h),ans);\n\t}\n}\nw = l;\nfor(i = 1;i < n;i++){\n\tl = 0;\n\tfor(j = i;j < n + i;j++){\n\t\tl += a[j % n];\n\t\tif(l < ans)continue;\n\t\tif(w - l < ans * 2)break;\n\t\tm = 0;\n\t\tfor(k = j + 1;k < n + i;k++){\n\t\t\tm += a[k % n];\n\t\t\tif(m < ans)continue;\n\t\t\tif(w-l-m < ans)break;\n\t\t\tans = min(min(l,m),w-l-m);\n\t\t}\n\t}\n}\nprintf(\"%lld\\n\",ans);\nreturn;\n}\n\nint main(void){\nscanf(\"%d\",&n);\nfor(i = 0;i < n;i++)scanf(\"%d\",a+i);\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0600 Baumkuchen\n// 2017.12.5 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint a[100002], p[100002];\nlong long s[100002];\n\nchar buf[15], *bp;\nint getint()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, ii, f;\n\tlong long sum, l, m, r;\n\n\tfgets(bp=buf, 15, stdin), n = getint();\n\tfor (sum = 0, i = 0; i < n; i++) {\n\t\tfgets(bp=buf, 15, stdin);\n\t\tsum += a[i] = getint();\n\t}\n\t\n\tl = 0, r = sum + 1;\n\twhile (l + 1 < r) {\n\t\tm = (l+r) >> 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (!i) s[i] = p[i] = 0;\n\t\t\telse p[i] = p[i-1] - 1, s[i] = s[i-1] - a[i-1];\n\t\t\t\n\t\t\twhile (s[i] < m) {\n\t\t\t\tii = i + p[i];\n\t\t\t\tif (ii >= n) ii -= n;\n\t\t\t\ts[i] += a[ii], p[i]++;\n\t\t\t}\n\t\t}\n\t\n\t\tfor (f = 0, i = 0; i < n; i++) {\n\t\t\tii = i + p[i];\n\t\t\tif (ii >= n) ii -= n;\n\t\t\tif (sum - s[i] - s[ii] >= m) f = 1;\n\t\t}\n\t\tif (f) l = m; else r = m;\n    }\n\tprintf(\"%lld\\n\", l);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 100000\n\n#define D(x,y) (pos[(x)]-pos[(y)])\n\nlong long A[NMAX];\nlong long pos[NMAX*2];\nint N;\nlong long L;\n\nlong long solve() {\n    long long ret = 1;\n    int p0 = 0, p1 = 0, p2 = 0;\n    while (p0 < N) {\n        if (p1 <= p0) p1 = p0 + 1;\n        while (p1 - p0 < N && D(p1, p0) <= ret) p1++;\n        if (D(p1, p0) <= ret) goto L1;\n\n        if (p2 <= p1) p2 = p1 + 1;\n        while (p2 - p0 < N && D(p2,p1) < D(p1, p0)) p2++;\n        if (D(p2, p1) < D(p1, p0)) goto L1;\n\n        if (L - D(p2, p0) >= D(p1, p0)) {\n            ret = D(p1, p0);\n            if (ret >= L/3) return ret;\n            continue;\n        }\nL1:\n        p0 += 1;\n        while (p2 > p1 && D(p2, p1) > D(p1, p0)) p2--;\n    }\n    return ret;\n}\n\nint main(void) {\n    int i;\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n        L += A[i];\n    }\n    for (i = 0; i < 2*N; i++) {\n        pos[i] = pos[i-1] + A[(i-1)%N];\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\t\n\tint b[100000] = {0};\n\tint n, i, j, k ,l;\n\tunsigned long p1, p2, p3;\n\tunsigned long max = 0;\n\tunsigned long tmp_max = 0;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n//\tfor (i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\", b[i]);\n//\t}\n\tfor (i = 0; i < n - 2; ++i) {\n\t\tfor (j = i + 1; j < n - 1; ++j) {\n\t\t\tfor (k = j + 1; k < n; ++k) {\n\t\t\t\tp1 = p2 = p3 = tmp_max = 0;\n\t\t\t\tfor (l = i; l < j; ++l) {\n\t\t\t\t\tp1 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = j; l < k; ++l) {\n\t\t\t\t\tp2 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = k; l < n; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l < i; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d\\n\", p1, p2, p3);\n\t\t\t\tif (p1 < p2) {\n\t\t\t\t\ttmp_max = p1;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p2;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max < p3) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p3;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max > max) {\n\t\t\t\t\tmax = tmp_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", max);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong Min(long a, long b, long c) {\n\tlong key = a;\n\tif(a>b) key = b;\n\tif(key > c) key =c;\n\treturn key;\n}\n\nint main(void) {\n\tint n;\n\tscanf(\"%d\", &n);\n\t\t\n\tint a[100000];\n\tlong whole=0;\n\tfor(int i=0; i<n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\twhole += a[i];\n\t}\t\n\t\t\n\tlong minmax=0;\n\tlong size[3];\n\t\t\n\tfor(int i=0; i<n-2; i++) { //1つめの切り込み\n\t\tfor(int j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\tsize[0]=0;\n\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\tsize[1]=0;\n\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\n\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t\t//System.out.println(\"(i,j,k)=(\"+i+\",\"+j+\",\"+k+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\tif(min>minmax) minmax=min;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tprintf(\"%ld\\n\",minmax);\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint main()\n{\n\tint i,j,k,n,min,max = INT_MIN;\n\tint a[100000],sum[3];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=n-1;i>1;i--)\n\t{\n\t\tfor(j=1;j<i;j++)\n\t\t{\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tsum[k] = 0;\n\t\t\t}\n\t\t\tmin = INT_MAX;\n\t\t\tfor(k=0;k<j;k++)\n\t\t\t{\n\t\t\t\tsum[0] += a[k];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(k=j;k<i;k++)\n\t\t\t{\n\t\t\t\tsum[1] += a[k];\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(k=i;k<n;k++)\n\t\t\t{\n\t\t\t\tsum[2] += a[k];\n\t\t\t}\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tmin = MIN(sum[k],min);\n\t\t\t}\n\t\t\tif(min > max)\n\t\t\t{\n\t\t\t\tmax = min;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint main()\n{\n\tint i,j,k,n,min,max = INT_MIN;\n\tint a[100000],sum[3];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(i=n-1;i>1;i--)\n\t{\n\t\tfor(j=1;j<i;j++)\n\t\t{\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tsum[k] = 0;\n\t\t\t}\n\t\t\tmin = INT_MAX;\n\t\t\tfor(k=0;k<j;k++)\n\t\t\t{\n\t\t\t\tsum[0] += a[k];\n\t\t\t}\n\t\t\tfor(k=j;k<i;k++)\n\t\t\t{\n\t\t\t\tsum[1] += a[k];\n\t\t\t}\n\t\t\tfor(k=i;k<n;k++)\n\t\t\t{\n\t\t\t\tsum[2] += a[k];\n\t\t\t}\n\t\t\tfor(k=0;k<3;k++)\n\t\t\t{\n\t\t\t\tmin = MIN(sum[k],min);\n\t\t\t}\n\t\t\tif(min > max)\n\t\t\t{\n\t\t\t\tmax = min;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N_MAX 100000\ntypedef unsigned long ul;\n\nul a[N_MAX];\nint n;\nul sum, ansmax;\n\nint isvalid(int end, ul psum){\n\tint i = end;\n\tul qsum = 0;\n\twhile(qsum < psum){\n\t\tqsum += a[i];\n\t\ti++;\n\t\tif (i == n) i = 0;\n\t}\n\treturn sum >= (psum * 2 + qsum);\n}\n\nint solve(void){\n\tlong ans = 0;\n\tint i;\n\tint end = 0;\n\tul peacesum = 0;\n\tfor(i = 0; i < n; i++){\n\t\twhile(peacesum <= ansmax){\n\t\t\tpeacesum += a[end];\n\t\t\tend++;\n\t\t\tif (end == n) end = 0;\n\t\t}\n\t\tend = (end ? end-1 : n-1);\n\t\tpeacesum -= a[end];\n\t\twhile(!isvalid(end, peacesum)){\n\t\t\tend = (end ? end-1 : n-1);\n\t\t\tpeacesum -= a[end];\n\t\t}\n\t\tif (peacesum > ans){\n\t\t\tans = peacesum;\n\t\t}\n\t\tpeacesum -= a[i];\n\t}\n\treturn printf(\"%ld\\n\", ans);\n}\n\nint in(void){\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%ld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\tansmax = sum / 3;\n\treturn 0;\n}\n\nint main(void){\n\tin();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong Min(long a, long b, long c) {\n\tlong key = a;\n\tif(a>b) key = b;\n\tif(key > c) key =c;\n\treturn key;\n}\n\nint main(void) {\n\tint n;\n\tint i,j,k,m;\n\tscanf(\"%d\", &n);\n\t\t\n\tint a[100000];\n\tlong whole=0;\n\tfor(i=0; i<n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\twhole += a[i];\n\t}\t\n\t\t\n\tlong minmax=0;\n\tlong size[3];\n\t\t\n\tfor(i=0; i<n-2; i++) { //1つめの切り込み\n\t\tfor(j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\tsize[0]=0;\n\t\t\tfor(k=i; k<j; k++) \n\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\tfor(k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\tsize[1]=0;\n\t\t\t\tfor(m=j; m<k; m++)\n\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\n\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\n\t\t\t\t\t//printf(\"(i,j,k)=(%d,%d,%d),(size[0], size[1], size[2]) = (%ld,%ld,%ld)\\n\" ,i,j,k,size[0],size[1], size[2]);\n\t\t\t\t\n\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\tif(min>minmax) minmax=min;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tprintf(\"%ld\\n\",minmax);\n\n\treturn 0;\t\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0600\n  Title:Baumkuchen\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n  \nint n;\nint a[100000];\nlong long t1_3_fw[100000];\nlong long t1_3_bk[100000];\nlong long all,all31; // one third of all\n\n \nprepare()\n{\n  long long s;\n  int i,j;\n \n  for(i=s=0;i<n;i++)\n    {\n      s+=a[i];\n \n      if(s>all31)\n\t{\n\t  t1_3_fw[0]=s;\n\t  j=i+1;\n\t  j %= n;\n\t  break;\n\t}\n    }\n \n  for(i=1;i<n;i++)\n    {\n      s -= a[i-1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j++;\n\t  j %= n;\n\t}\n      t1_3_fw[i]=s;\n    }\n}\n \nprepare2()\n{\n  long long s;\n  int i,j;\n \n  for(i=n-1,s=0;i>=0;i--)\n    {\n      s+=a[i];\n      if(s>all31)\n\t{\n\t  t1_3_bk[n-1]=s;\n\t  j=i-1;\n\t  if(j<0)j+=n;\n\t  break;\n\t}\n    }\n\n  for(i=n-2;i>=0;i--)\n    {\n      s -= a[i+1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j--;\n\t  if(j<0)j+=n;\n\t}\n      t1_3_bk[i]=s;\n     }\n}\n  \nlong long proc2(int i_half,int s3)\n{\n  int i;\n  long long s1,s2,max_;\n  max_=0;\n\n  for(i=s1=0;i<n-1;i++)\n    {\n      s1 += a[(i_half+1+i)%n];\n      s2 = all - s3 -s1;\n      //printf(\"%lld %lld %d\\n\",s1,s2,s3);\n      max_ = max(max_,min(s1,s2));\n    }\n  return(max_);\n}\n\nmain()\n{\n  int i,j,k,over;\n  long long s1,s2,s3; // s1 shortest s2 longest s3 2nd\n  long long max_;\n\n  memset(t1_3_fw,0,sizeof(t1_3_fw));\n  memset(t1_3_fw,0,sizeof(t1_3_bk));\n  scanf(\"%d\",&n);\n  for(i=all=0;i<n;i++)\n    {\n      scanf(\"%d\",&a[i]);\n      all += a[i];\n    }\n \n  all31=all/3;\n  \n  for(i=0;i<n;i++)\n    if(a[i]>all31)\n      {\n\tmax_=proc2(i,a[i]);\n\tgoto END;\n      }\n \n  max_=0;  s1=0;\n  prepare();prepare2();\n\n  for(j=0;j<n;j++)\n    {\n      s1 += a[j];\n      if(s1>all31)\n\tbreak;\n\n      s2=t1_3_fw[j+1];\n      s3=all-s1-s2;\n      //printf(\"%lld %lld %lld\\n\",s1,s2,s3);\n \n      if(s3 >= s1)\n\t{\n\t  max_=max(max_,s1);\n\t}\n      \n      s2=t1_3_bk[n-1];\n      s3=all-s1-s2;\n \n      if(s3 >= s1)\n\t{\n\t  //printf(\"%lld %lld %lld\\n\",s1,s2,s3);\n\t  max_=max(max_,s1);\n\t}\n    }\n  j++;\n  for(i=1;i<n;i++)\n    {\n      s1 -= a[i-1];\n\n      for(;;j++,j%=n)\n\t{\n\t  if(s1+a[j]>all31)\n\t    break;\n\n\t  s1 += a[j];\n\n\t  if(s1<max_)\n\t    continue;\n\t  \n\t  s2=t1_3_fw[(j+1)%n];\n\t  s3=all-s1-s2;\n\t  \n\t  if(s3 >= s1)\n\t    {\n\t      //printf(\"%lld %lld %lld[%d]\\n\",s1,s2,s3,j);\n\t      max_=max(max_,s1);\n\t    }\n\t  \n\t  s2=t1_3_bk[i-1];\n\t  s3=all-s1-s2;\n  \n\t  if(s3 >= s1)\n\t    {\n\t      //printf(\"%lld %lld %lld\\n\",s1,s2,s3);\n\t      max_=max(max_,s1);\n\t    }\n \t}\n    }\n END:\n  printf(\"%lld\\n\",max_);\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long a[100000];\nint n;\n\nint i,x;\nint j,y;\nint k,z;\nint l,w;\nint m;\n\nlong long ans = 0;\n\nlong long min(long long a,long long b){\n\tif(a < b)return a;return b;\n}\nlong long max(long long a,long long b){\n\treturn a + b - min(a,b);\n}\n\nvoid solve(void){\nx = n / 3;\nl = 0;\nfor(i = 0;i < n;i++){\n\tl += a[i];\n\tfor(j = i + 1;j < n;j++){\n\t\tlong long h;\n\t\ty = 0;\n\t\tfor(k = j + 1;k < n;k++)y += a[k];\n\t\tz = 0;\n\t\tfor(k = j + 1;y / 2 < z;k++)z += a[k];\n\t\t//--\n\t\th = max((long long)(((float)y) / 2 - max((long long)(z - ((float)y)/2) , (long long)(((float)y)/2 - (z - a[k])))),0);\n\t\tans = max(min(l,h),ans);\n\t}\n}\nw = l;\nfor(i = 1;i < n;i++){\n\tl = 0;\n\tfor(j = i;j < n + i;j++){\n\t\tl += a[j % n];\n\t\tif(l < ans)continue;\n\t\tif(w - l < ans * 2)break;\n\t\tm = 0;\n\t\tfor(k = j + 1;k < n + i;k++){\n\t\t\tm += a[k % n];\n\t\t\tif(m < ans)continue;\n\t\t\tif(w-l-m < ans)break;\n\t\t\tans = min(min(l,m),w-l-m);\n\t\t}\n\t}\n}\nprintf(\"%lld\\n\",ans);\nreturn;\n}\n\nint main(void){\nscanf(\"%d\",&n);\nfor(i = 0;i < n;i++)scanf(\"%d\",a+i);\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include \"stdio.h\"\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\t\n\tint b[100000] = {0};\n\tint n, i, j, k ,l;\n\tunsigned long p1, p2, p3;\n\tunsigned long max = 0;\n\tunsigned long tmp_max = 0;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n//\tfor (i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\", b[i]);\n//\t}\n\tfor (i = 0; i < n - 2; ++i) {\n\t\tfor (j = i + 1; j < n - 1; ++j) {\n\t\t\tfor (k = j + 1; k < n; ++k) {\n\t\t\t\tp1 = p2 = p3 = tmp_max = 0;\n\t\t\t\tfor (l = i; l < j; ++l) {\n\t\t\t\t\tp1 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = j; l < k; ++l) {\n\t\t\t\t\tp2 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = k; l < n; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l < i; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d\\n\", p1, p2, p3);\n\t\t\t\tif (p1 < p2) {\n\t\t\t\t\ttmp_max = p1;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p2;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max < p3) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p3;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max > max) {\n\t\t\t\t\tmax = tmp_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lu\\n\", max);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0600\n  Title:Baumkuchen\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n  \nint n;\nint a[100000];\nlong long t1_3_fw[100000];\nlong long t1_3_bk[100000];\n \nlong long all,all31; // one third of all\n \nprepare()\n{\n  long long s;\n  int i,j;\n \n  for(i=s=0;i<n;i++)\n    {\n      s+=a[i];\n \n      if(s>all31)\n\t{\n\t  t1_3_fw[0]=s;\n\t  j=i+1;\n\t  j %= n;\n\t  break;\n\t}\n    }\n \n  for(i=1;i<n;i++)\n    {\n      s -= a[i-1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j++;\n\t  j %= n;\n\t}\n      t1_3_fw[i]=s;\n    }\n}\n \nprepare2()\n{\n  long long s;\n  int i,j;\n \n  for(i=n-1,s=0;i>=0;i--)\n    {\n      s+=a[i];\n      if(s>all31)\n\t{\n\t  t1_3_bk[n-1]=s;\n\t  j=i-1;\n\t  if(j<0)j+=n;\n\t  break;\n\t}\n    }\n\n  for(i=n-2;i>=0;i--)\n    {\n      s -= a[i+1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j--;\n\t  if(j<0)j+=n;\n\t}\n      t1_3_bk[i]=s;\n     }\n}\n  \nmain()\n{\n  int i,j,k;\n  long long s1,s2,s3; // s1 shortest s2 longest s3 2nd\n  long long max_;\n  memset(t1_3_fw,0,sizeof(t1_3_fw));\n  memset(t1_3_fw,0,sizeof(t1_3_bk));\n  scanf(\"%d\",&n);\n  for(i=all=0;i<n;i++)\n    {\n      scanf(\"%d\",&a[i]);\n      all += a[i];\n    }\n \n  all31=all/3;\n  \n  max_=0;  s1=0;\n  prepare();prepare2();\n\n  for(j=0;j<n;j++)\n    {\n      s1 += a[j];\n      if(s1>all31)\n\tbreak;\n      \n      s2=t1_3_fw[j+1];\n      s3=all-s1-s2;\n \n      if(s3 >= s1)\n\tmax_=max(max_,s1);\n\t  \n      s2=t1_3_bk[n-1];\n      s3=all-s1-s2;\n \n      if(s3 >= s1)\n\tmax_=max(max_,s1);\n    }\n  j++;\n  for(i=1;i<n;i++)\n    {\n      s1 -= a[i-1];\n\n      for(;;j++,j%=n)\n\t{\n\t  if(s1+a[j]>all31)\n\t    break;\n\n\t  s1 += a[j];\n\n\t  if(s1<max_)\n\t    continue;\n\t  \n\t  s2=t1_3_fw[(j+1)%n];\n\t  s3=all-s1-s2;\n\t  \n\t  if(s3 >= s1)\n\t    {\n\t      //printf(\"%lld %lld %lld[%d]\\n\",s1,s2,s3,j);\n\t      max_=max(max_,s1);\n\t    }\n\t  \n\t  s2=t1_3_bk[i-1];\n\t  s3=all-s1-s2;\n  \n\t  if(s3 >= s1)\n\t    {\n\t      //printf(\"%lld %lld %lld\\n\",s1,s2,s3);\n\t      max_=max(max_,s1);\n\t    }\n \t}\n    }\n  printf(\"%lld\\n\",max_);\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 0600\n  Title:Baumkuchen\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n  \nint n;\nint a[100000];\nlong long t1_3_fw[100000];\nlong long t1_3_bk[100000];\n \nlong long all,all31; // one third of all\n \nprepare()\n{\n  long long s;\n  int i,j;\n \n  for(i=s=0;i<n;i++)\n    {\n      s+=a[i];\n \n      if(s>all31)\n\t{\n\t  t1_3_fw[0]=s;\n\t  j=i+1;\n\t  j %= n;\n\t  break;\n\t}\n    }\n \n  for(i=1;i<n;i++)\n    {\n      s -= a[i-1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j++;\n\t  j %= n;\n\t}\n      t1_3_fw[i]=s;\n    }\n}\n \nprepare2()\n{\n  long long s;\n  int i,j;\n \n  for(i=n-1,s=0;i>=0;i--)\n    {\n      s+=a[i];\n      if(s>all31)\n\t{\n\t  t1_3_bk[n-1]=s;\n\t  j=i-1;\n\t  if(j<0)j+=n;\n\t  break;\n\t}\n    }\n\n  for(i=n-2;i>=0;i--)\n    {\n      s -= a[i+1];\n      while(s<all31)\n\t{\n\t  s += a[j];\n\t  j--;\n\t  if(j<0)j+=n;\n\t}\n      t1_3_bk[i]=s;\n     }\n}\n  \nmain()\n{\n  int i,j,k;\n  long long s1,s2,s3; // s1 shortest s2 longest s3 2nd\n  long long max_;\n  memset(t1_3_fw,0,sizeof(t1_3_fw));\n  memset(t1_3_fw,0,sizeof(t1_3_bk));\n  scanf(\"%d\",&n);\n  for(i=all=0;i<n;i++)\n    {\n      scanf(\"%d\",&a[i]);\n      all += a[i];\n    }\n \n  all31=all/3;\n  \n  prepare();prepare2();\n  max_=0;  s1=0;\n\n  for(j=0;j<n;j++)\n    {\n      s1 += a[j];\n      if(s1>all31)\n\tbreak;\n      \n      s2=t1_3_fw[j+1];\n      s3=all-s1-s2;\n \n      if(s3 >= s1)\n\tmax_=max(max_,s1);\n\t  \n      s2=t1_3_bk[n-1];\n      s3=all-s1-s2;\n \n      if(s3 >= s1)\n\tmax_=max(max_,s1);\n    }\n  j++;\n  for(i=1;i<n;i++)\n    {\n      s1 -= a[i-1];\n\n      for(;;j++,j%=n)\n\t{\n\t  if(s1+a[j]>all31)\n\t    break;\n\n\t  s1 += a[j];\n\n\t  if(s1<max_)\n\t    continue;\n\t  \n\t  s2=t1_3_fw[j+1];\n\t  s3=all-s1-s2;\n\t  \n\t  if(s3 >= s1)\n\t    max_=max(max_,s1);\n\t  \n\t  s2=t1_3_bk[i-1];\n\t  s3=all-s1-s2;\n  \n\t  if(s3 >= s1)\n\t    max_=max(max_,s1);\n \t}\n    }\n  printf(\"%lld\\n\",max_);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\t\n\tint b[100000] = {0};\n\tint n, i, j, k ,l;\n\tint p1, p2, p3;\n\tint max = 0;\n\tint tmp_max = 0;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (i = 0; i < n - 2; ++i) {\n\t\tfor (j = i + 1; j < n - 1; ++j) {\n\t\t\tfor (k = j + 1; k < n; ++k) {\n\t\t\t\tp1 = p2 = p3 = tmp_max = 0;\n\t\t\t\tfor (l = i; l < j; ++l) {\n\t\t\t\t\tp1 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = j; l < j; ++l) {\n\t\t\t\t\tp2 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = k; l < n; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l < i; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\tif (p1 < p2) {\n\t\t\t\t\ttmp_max = p1;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p2;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max < p3) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p3;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max > max) {\n\t\t\t\t\tmax = tmp_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", max);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint InArray[200000] = {0};\t\t// end is linked to start (Baumkuchen is round)\n\tint N;\t\t\t\t\t\t\t// total data input\n\tint i;\t\t\t\t\t\t\t// for counter\n\tint inputBuffer;\t\t\t\t// buffer for input data\n\tint a1, a2, a3;\t\t\t\t\t// the start index of each region\n\tlong long sum;\t\t\t\t\t// buffer for sum\n\tlong long average, average2;\t// sum / 3, (sum - region1) / 2\n\tlong long a1_sum, a2_sum;\t\t// sum of region1, region2\n\tlong long MaxMin;\t\t\t\t// final result\n\t\n\tscanf(\"%d\", &N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d\", &inputBuffer);\n\t\tInArray[i] = inputBuffer;\n\t\tInArray[i + N] = inputBuffer;\n\t}\n\n\t\n\t// Calculate sum and average\n\tsum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tsum += InArray[i];\n\t}\n\tif(sum % 3 == 0){\n\t\taverage = sum / 3;\n\t}else{\n\t\taverage = sum / 3 + 1;\n\t}\n\t\n\tMaxMin = 0;\n\tfor(a1 = 0; a1 < N; a1++){\n\t\ta1_sum = 0;\n\t\tfor(a2 = a1 + 1; a2 < (a1 + N); a2++){\n\t\t\ta1_sum += InArray[a2 - 1];\n\t\t\tif(a1_sum < average) continue;\n\t\t\t\n\t\t\tif((sum - a1_sum) % 2 == 0){\n\t\t\t\taverage2 = (sum - a1_sum) / 2;\n\t\t\t}else{\n\t\t\t\taverage2 = (sum - a1_sum + 1) / 2;\n\t\t\t}\n\t\t\t\n\t\t\ta2_sum = 0;\n\t\t\tfor(a3 = a2 + 1; a3 < (a1 + N); a3++){\t// left 1 for a3_sum\n\t\t\t\ta2_sum += InArray[a3 -1];\n\t\t\t\tif(a2_sum < average2) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\tif(a2_sum - InArray[a3 -1] > MaxMin){\n\t\t\t\t\tMaxMin = a2_sum - InArray[a3 -1];\n\t\t\t\t}\n\t\t\t\tif(sum - a1_sum - a2_sum   > MaxMin){\n\t\t\t\t\tMaxMin = sum - a1_sum - a2_sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", MaxMin);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\t\n\tint b[100000] = {0};\n\tint n, i, j, k ,l;\n\tint p1, p2, p3;\n\tint max = 0;\n\tint tmp_max = 0;\n\t\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n//\tfor (i = 0; i < n; ++i) {\n//\t\tprintf(\"%d\\n\", b[i]);\n//\t}\n\tfor (i = 0; i < n - 2; ++i) {\n\t\tfor (j = i + 1; j < n - 1; ++j) {\n\t\t\tfor (k = j + 1; k < n; ++k) {\n\t\t\t\tp1 = p2 = p3 = tmp_max = 0;\n\t\t\t\tfor (l = i; l < j; ++l) {\n\t\t\t\t\tp1 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = j; l < k; ++l) {\n\t\t\t\t\tp2 += b[l];\n\t\t\t\t}\n\n\t\t\t\tfor (l = k; l < n; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\tfor (l = 0; l < i; ++l) {\n\t\t\t\t\tp3 += b[l];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d\\n\", p1, p2, p3);\n\t\t\t\tif (p1 < p2) {\n\t\t\t\t\ttmp_max = p1;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p2;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max < p3) {\n\t\t\t\t\t;\n\t\t\t\t} else {\n\t\t\t\t\ttmp_max = p3;\n\t\t\t\t}\n\n\t\t\t\tif (tmp_max > max) {\n\t\t\t\t\tmax = tmp_max;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", max);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#include<stdbool.h>\n#include<assert.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define rrep(i,l,r)for(ll i=(l);i>=(r);i--)\n#define INF (1LL<<60)\n#define MOD1 1000000007\n#define MOD2 998244353\n#define MAX_N (1 << 17)\n#define YES printf(\"Yes\\n\")\n#define NO printf(\"No\\n\")\n#define PN printf(\"\\n\")\n#define charsize 100005 //10^5+5\n#define PI 3.141592653589793238\n\nvoid swap(ll *a, ll *b){ll c;c=*b;*b=*a;*a= c;}\nvoid cin(ll *n){ scanf(\"%lld\",&(*n)); }\nvoid cin2(ll *a, ll *b){ scanf(\"%lld%lld\",&(*a),&(*b)); }\nvoid cin3(ll *a, ll *b, ll *c){ scanf(\"%lld%lld%lld\",&(*a),&(*b),&(*c)); }\nll max2(ll a,ll b){return a>=b?a:b;}\nll min2(ll a,ll b){return a>=b?b:a;}\nll min3(ll a, ll b, ll c){return (a<=b && a<=c) ? a : b<=c ? b : c;}\nll max3(ll a, ll b, ll c){return (a>=b && a>=c) ? a : b>=c ? b : c;}\nll minn(ll n, ll a[n]){ll b=INF;rep(i,0,n) b=min2(b,a[i]);return b;}\nll maxn(ll n, ll a[n]){ll b=-INF;rep(i,0,n) b=max2(b,a[i]);return b;}\nll ABS(ll a){return a>=0?a:(-a);}\nll POW(ll a, ll b){ll c=1;rep(i,0,b) c*=a;return c;}\ndouble POW_d(double a, double b){double c=1;rep(i,0,b) c*=a;return c;}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nll mod_MOD1(ll n){n+= n<0?((-n)/MOD1+1)*MOD1:0; return n%=MOD1;}\nll mod_p(ll n ,ll p){n+= n<0?((-n)/p+1)*p:0; return n%=p;}\nll change_into_num(char s[] , ll len, ll p){ return !p ? 0 : POW(10,p-1)*(s[len-p]-'0') + change_into_num(s,len,p-1); }\n\nvoid lr_lower( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am < val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am <= val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nvoid lr_upper( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am <= val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am < val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nint cmp_lower( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a>=b ? 1 : 0 ) : ( a>b ? 1 : 0 ) ; }\nint cmp_upper( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a<=b ? 1 : 0 ) : ( a<b ? 1 : 0 ) ; }\n// return smallest p  which meets  a[p]==val :1  >=:2   >:3\nll lower_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_lower(&l,&r,a[ (l+r)/2 ],val,type);  return cmp_lower(a[l],val,type) ? l : cmp_lower(a[r],val,type) ? r : -1;  }\n// return biggest p  which meets   a[p]==val :1  <=:2   <:3\nll upper_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_upper(&l,&r,a[ (l+r)/2 ],val,type); return cmp_upper(a[r],val,type) ? r : cmp_upper(a[l],val,type) ? l : -1; }\n// count i  which meets ai==x\nll count(ll a[], int l, int r, ll x){  int p = lower_bound(a,l,r,x,1);  return p==-1 ? 0 : upper_bound(a,p,r,x,1)-p+1; }\n\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nint cmp_string( const void * a , const void * b ) {  return strcmp( (char *)a , (char *)b ); }  // qsort((void*)s,n,sizeof(s[0]),int_sort );\nint cmp_char(const void * a, const void * b) { return *(char *)a - *(char *)b;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nvoid sort_string(int n,int size,char s[][size]){ qsort( (void*)s , n , sizeof(s[0]) , cmp_string ); }\nvoid sort_char(char *s){ qsort( (void *)s , strlen(s) , sizeof(char) , cmp_char ); }\nll unique_string(ll n ,ll size, char s[][size]){ ll ans=1; rep(i,1,n) if( strcmp(s[i],s[i-1]) ) ans++; return ans; }\nll unique_num(ll n , ll a[]){ ll ans=1; rep(i,1,n) if( a[i]!=a[i-1] ) ans++; return ans; }\n\ntypedef struct{ ll a , b;}fr;\nint cmp1( const void *p, const void *q ) { return ((fr*)p) ->a - ((fr*)q)->a;}\nint cmp2( const void *p, const void *q ) { return ((fr*)q) ->a - ((fr*)p)->a;}\nvoid strsortup(fr*a,int n){qsort(a,n,sizeof(fr),cmp1);}\nvoid strsortdown(fr*a,int n){qsort(a,n,sizeof(fr),cmp2);}\n\n\n    \nint main(void){\n    // fgets(s,sizeof(s),stdin);\n    // char ;\n    ll n;\n    ll ans=0;\n    cin(&n);\n    // scanf(\"%s\",);\n    ll a[2*n],sum[2*n+1];\n    sum[0]=0;\n    rep(i,0,n){\n        cin(&a[i]);\n        a[i+n]=a[i];\n        sum[i+1]=sum[i]+a[i];\n    }\n    rep(i,0,n){\n        sum[n+1+i]=sum[n+i]+a[i];\n    }\n    ll mark=sum[n]/3;\n    ll head=0,tail=0,siz=a[0];\n    // rep(i,0,n+1) printf(\"%lld \",sum[i]);\n    // PN;\n    while(head<=n-1){\n        if(siz+a[tail+1]>mark){\n            if(!siz){\n                head++; tail++; continue;\n            }\n            siz-=a[head++];\n            goto NEXT;\n            continue;\n        }\n        siz+=a[++tail];\n        NEXT:;\n        // if(siz==16907){PN;PN;PN; }\n        ll piv = lower_bound(sum,0,2*n, sum[tail+1]+siz , 2 );\n        // printf(\"%lld \",head);\n        // printf(\"%lld \",siz);\n        // printf(\"%lld \",piv);\n        // PN;\n        if(piv==-1){\n            if(head+1!=n){\n                siz-=a[head++];\n                if(!siz) continue;\n                goto NEXT;\n            }else{\n                break;\n            }\n        }\n        ll b,c;\n        b=sum[piv]-sum[tail+1];\n        c=sum[n]-b-siz;\n\n        // printf(\"%lld   %lld %lld\\n\",siz,b,c);\n        // printf(\"%lld   %lld %lld\\n\",siz,head,tail);\n        if(b>=siz&&c>=siz){\n            ans=max2(ans,siz);\n        }else{\n            if(head+1!=n){\n                siz-=a[head++];\n                goto NEXT;\n            }else break;\n        }\n\n        // printf(\"%lld\\n\",ans);\n    }\n\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0600 Baumkuchen\n// 2017.12.5 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint a[100002], p[100002];\nlong long s[100002];\n\nchar buf[15], *bp;\nint getint()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, ii, f;\n\tlong long sum, l, m, r;\n\n\tfgets(bp=buf, 15, stdin), n = getint();\n\tfor (sum = 0, i = 0; i < n; i++) {\n\t\tfgets(bp=buf, 15, stdin);\n\t\tsum += a[i] = getint();\n\t}\n\t\n\tl = 0, r = sum + 1;\n\twhile (l + 1 < r) {\n\t\tm = (l+r) >> 1;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (!i) s[i] = p[i] = 0;\n\t\t\telse p[i] = p[i-1] - 1, s[i] = s[i-1] - a[i-1];\n\t\t\t\n\t\t\twhile (s[i] < m) {\n\t\t\t\tii = i + p[i];\n\t\t\t\tif (ii >= n) ii -= n;\n\t\t\t\ts[i] += a[ii], p[i]++;\n\t\t\t}\n\t\t}\n\t\n\t\tfor (f = 0, i = 0; i < n; i++) {\n\t\t\tii = i + p[i];\n\t\t\tif (ii >= n) ii -= n;\n\t\t\tif (sum - s[i] - s[ii] >= m) { f = 1; break; }\n\t\t}\n\t\tif (f) l = m; else r = m;\n    }\n\tprintf(\"%lld\\n\", l);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long a[100000];\nint n;\n\nint i,x;\nint j,y;\nint k,z;\nint l,w;\n\nlong long ans = 0;\n\nfloat fmax(float x,float y){\n\tif(x < y)return y;return x;\n}\n\nlong long min(long long a,long long b){\n\tif(a < b)return a;return b;\n}\nlong long max(long long a,long long b){\n\treturn a + b - min(a,b);\n}\n\nvoid solve(void){\nl = 0;\nfor(i = 0;i < n;i++){\n\tl += a[i];\n\tfor(j = i + 1;j < n;j++){\n\t\tlong long h;\n\t\ty = 0;\n\t\tfor(k = j + 1;k < n;k++)y += a[k];\n\t\tz = 0;\n\t\tfor(k = j + 1;y / 2 < z;k++)z += a[k];\n\t\t//--\n\t\th = (long long)(((float)y) / 2 - fmax(abs(z - ((float)y)/2) , abs(((float)y)/2 - z + a[k])));\n\t\tans = max(min(l,h),ans);\n\t}\n}\nw = l;\nfor(i = 1;i < n;i++){\n\tl = 0;\n\tfor(j = i;j < n + i;j++){\n\t\tl += a[j % n];\n\t\tif(l < ans)continue;\n\t\tif(w - l < ans * 2)break;\n\t\tx = 0;\n\t\tfor(k = j + 1;k < n + i;k++){\n\t\t\tx += a[k % n];\n\t\t\tif(x < ans)continue;\n\t\t\tif(w-l-x < ans)break;\n\t\t\tans = min(min(l,x),w-l-x);\n\t\t}\n\t}\n}\nprintf(\"%lld\\n\",ans);\nreturn;\n}\n\nint main(void){\nscanf(\"%d\",&n);\nfor(i = 0;i < n;i++)scanf(\"%d\",a+i);\nsolve();\nreturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    val parts = Array(readLine()!!.toInt()){\n        readLine()!!.toInt()\n    }\n    val accumulated = Array(parts.size * 2 + 1){0L}\n    for (i in 1 until accumulated.size){\n        accumulated[i] = accumulated[i - 1] + parts[(i - 1) % parts.size]\n    }\n    val wholeSize = accumulated[parts.size]\n    val maxSize = wholeSize / 3\n    var maxMin:Long = 0L\n    for (i in 0 until parts.size){\n        val greaterPoint =\n                accumulated.binarySearch(accumulated[i] + maxSize).let{ if (it >= 0) it else -it - 1}\n        val firstArea =\n                accumulated[greaterPoint] - accumulated[i]\n        val secondPoint =\n                accumulated.binarySearch(accumulated[greaterPoint] + (wholeSize - firstArea) / 2).let{if (it >= 0) it else -it - 1}\n        val secondMin =\n                accumulated[secondPoint - 1] - accumulated[greaterPoint]\n        val secondMax =\n                accumulated[secondPoint] - accumulated[greaterPoint]\n        val tempMaxMin =\n                listOf(listOf(secondMin, wholeSize - firstArea - secondMin).min()!!, wholeSize - firstArea - secondMax).max()!!\n        if (maxMin < tempMaxMin)\n            maxMin = tempMaxMin\n    }\n    println(maxMin)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    val parts = Array(readLine()!!.toInt()){\n        readLine()!!.toInt()\n    }\n    val accumulated = Array(parts.size * 2 + 1){0L}\n    for (i in 1 until accumulated.size){\n        accumulated[i] = accumulated[i - 1] + parts[(i - 1) % parts.size]\n    }\n    val wholeSize = accumulated[parts.size]\n    val maxSize = wholeSize / 3\n    var maxMin:Long = 0L\n    for (i in 0 until parts.size){\n        val greaterPoint =\n                accumulated.binarySearch(accumulated[i] + maxSize).let{ if (it >= 0) it else -it - 1}\n        val firstArea =\n                accumulated[greaterPoint] - accumulated[i]\n        assert(firstArea >= maxSize)\n        val secondPoint =\n                accumulated.binarySearch(accumulated[greaterPoint] + (wholeSize - firstArea) / 2).let{if (it >= 0) it else -it - 1}\n        val secondMin =\n                accumulated[secondPoint - 1] - accumulated[greaterPoint]\n        val thirdMax = wholeSize - firstArea - secondMin\n        assert(secondMin < maxSize)\n        val secondMax =\n                accumulated[secondPoint] - accumulated[greaterPoint]\n        val thirdMin = wholeSize - firstArea - secondMax\n        assert(firstArea + secondMax <= wholeSize)\n        val tempMaxMin =\n                listOf(listOf(secondMin, thirdMax).min()!!, listOf(secondMax, thirdMin).min()!!).max()!!\n        if (maxMin < tempMaxMin) {\n            maxMin = tempMaxMin\n        }\n    }\n    println(maxMin)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    val parts = Array(readLine()!!.toInt()){\n        readLine()!!.toInt()\n    }\n    val accumulated = Array(parts.size * 2){0L}\n    for (i in 1 until accumulated.size){\n        accumulated[i] = accumulated[i - 1] + parts[(i - 1) % parts.size]\n    }\n    val wholeSize = accumulated[parts.size]\n    val maxSize = wholeSize / 3\n    var maxMin:Long = 0L\n    for (i in 0 until parts.size){\n        val greaterPoint = accumulated.binarySearch(accumulated[i] + maxSize).let{ if (it >= 0) it else -it - 1}\n        val secondPoint = accumulated.binarySearch(accumulated[greaterPoint] + maxSize).let{if (it >= 0) it else -it - 1}\n        val firstArea = accumulated[greaterPoint] - accumulated[i]\n        val secondMin = accumulated[secondPoint - 1] - accumulated[greaterPoint]\n        val secondMax = accumulated[secondPoint] - accumulated[greaterPoint]\n        val tempMaxMin = listOf(listOf(secondMin, wholeSize - firstArea - secondMin).min()!!, wholeSize - firstArea - secondMax).max()!!\n        if (maxMin < tempMaxMin)\n            maxMin = tempMaxMin\n    }\n    println(maxMin)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine()\n\t\t\tA[i] = Integer.perseInt(str)//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n    \npublic class Main{\n\nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int N;\nstatic long[] sum;\n\npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nN=ir.nextInt();\nint[] a=ir.toIntArray(N);\nsum=new long[2*N+1];\nsum[0]=0;\nfor(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)a[(i-1)%N];\nlong ans=0;\nfor(int i=0;i<N-2;i++){\nint l=i+1;\nint r=i+2;\nwhile(true){\nif(r>=N) break;\nlong a=sum[i+N]-sum[r];\nlong b=sum[r]-sum[l];\nlong c=sum[l]-sum[i];\nlong res;\nif(a<=b&&a<=c){\nans=Math.max(ans,a);\nbreak;\n}\nelse if(b<=a&&b<=c){\nres=b;\nr++;\n}\nelse{\nres=c;\nif(r>l+1) l++;\nelse r++;\n}\nans=Math.max(ans,res);\n}\n}\nout.println(ans);\nout.flush();\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n\npublic InputReader(InputStream in) {this.in=in;}\n  \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n\npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n\nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n\npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Baumkuchen {\n\tpublic static void main(String[] args){\n\t\tint B1 = 0;\n\t\tint B2 = 0;\n\t\tint B3 = 0;\n\t\tint B4 = 0;\n\t\tint Bmin = 0;\n\t\tint BMIN = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint b[] = new int[n];\n\t\tfor(int x = 0; x <= n-1; x++){\n\t\t\tb[x] = scan.nextInt();\n\t\t}\n\t\tfor(int p = 1; p <= n-2; p++){\n\t\t\tfor(int q = p+1; q <= n-1; q++){\n\t\t\t\tB1 = 0;\n\t\t\t\tB2 = 0;\n\t\t\t\tB3 = 0;\n\t\t\t\tfor(int i = 0; i <= p-1; i++){\n\t\t\t\t\tB1 += b[i];\n\t\t\t\t}\n\t\t\t\tfor(int j = p; j <= q-1; j++){\n\t\t\t\t\tB2 += b[j];\n\t\t\t\t}\n\t\t\t\tfor(int k = q; k <= n-1; k++){\n\t\t\t\t\tB3 += b[k];\n\t\t\t\t}\n\t\t\t\tBmin = Math.min(B1, B2);\n\t\t\t\tBmin = Math.min(Bmin, B3);\n\t\t\t\tBMIN = Math.max(BMIN, Bmin);\n\t\t\t}\n\t\t}\n\t\tfor(int p = 1; p <= n-3; p++){\n\t\t\tfor(int q = p+1; q <= n-2; q++){\n\t\t\t\tfor(int r = q+1; r <= n-1; r++){\n\t\t\t\t\tB1 = 0;\n\t\t\t\t\tB2 = 0;\n\t\t\t\t\tB3 = 0;\n\t\t\t\t\tB4 = 0;\n\t\t\t\t\tfor(int i = 0; i <= p-1; i++){\n\t\t\t\t\t\tB1 += b[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = p; j <= q-1; j++){\n\t\t\t\t\t\tB2 += b[j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = q; k <= r-1; k++){\n\t\t\t\t\t\tB3 += b[k];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l = r; l <= n-1; l++){\n\t\t\t\t\t\tB4 += b[l];\n\t\t\t\t\t}\n\t\t\t\t\tBmin = Math.min(B1+B4, B2);\n\t\t\t\t\tBmin = Math.min(Bmin, B3);\n\t\t\t\t\tBMIN = Math.max(BMIN, Bmin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"????°????????????§??????\"+BMIN+\"??§???\");\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    private static final int MAX_LENGTH = 1000000000;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        // ????????£??????????????????????????????\n        Set<Set<Integer>> combinations = makeCombination(numOfPieces);\n\n        int maxLength = 0;\n        for (Set<Integer> combination : combinations) {\n            int minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Integer> calcEachLength(List<Integer> lengthOfPieces, Set<Integer> combination) {\n        Set<Integer> result = new HashSet<>();\n\n        List<Integer> combinationList = new ArrayList<>(combination);\n        Collections.sort(combinationList);\n\n        // ???????????????????????§?????????\n        int lastLength = 0;\n        for (int i = combinationList.get(combinationList.size() - 1); i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        int firstLength = 0;\n        for (int i = 1; i < combinationList.get(0); i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combinationList.size(); i++) {\n            int length = 0;\n            for (int j = combinationList.get(i - 1); j < combinationList.get(i); j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static Set<Set<Integer>> makeCombination(int numOfPieces) {\n        Set<Set<Integer>> result = new HashSet<>();\n\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = 1; j <= numOfPieces; j++) {\n                for (int k = 1; k <= numOfPieces; k++) {\n                    Set<Integer> set = new HashSet<>();\n                    set.add(i);\n                    set.add(j);\n                    set.add(k);\n                    result.add(set);\n                }\n            }\n        }\n\n        return result.stream().filter(set -> (set.size() == 3)).collect(Collectors.toSet());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n    \npublic class Main{\n\nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int N;\nstatic long[] sum;\n\npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nN=ir.nextInt();\nint[] s=ir.toIntArray(N);\nsum=new long[2*N+1];\nsum[0]=0;\nfor(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\nlong ans=0;\nint l=0;\nint m=1;\nint r=2;\nwhile(true){\nif(r>=N) break;\nlong a=sum[l+N]-sum[r];\nlong b=sum[r]-sum[m];\nlong c=sum[m]-sum[l];\nlong res;\nif(a<=b&&a<=c){\nres=a;\nif(m>l+1) l++;\nelse {\nm++; l++;\n}\n}\nelse if(b<=a&&b<=c){\nres=b;\nr++;\n}\nelse{\nres=c;\nif(r>m+1) m++;\nelse{\nr++; m++;\n}\n}\nans=Math.max(ans,res);\n}\nout.println(ans);\nout.flush();\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n\npublic InputReader(InputStream in) {this.in=in;}\n  \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n\npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n\nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n\npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static long Min(long a, long b, long c) {\n\t\tlong key = a;\n\t\tif(a>b) key = b;\n\t\tif(key > c) key =c;\n\t\treturn key;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tlong whole=0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\twhole += a[i];\n\t\t}\n\t\tsc.close();\t\t\n\t\t\n\t\tlong minmax=0;\n\t\t\n\t\t\n\t\tfor(int i=0; i<n-2; i++) {\n\t\t\tlong[] size = new long[3];\n\t\t\t\n\t\t\tfor(int j=0; j<=i; j++)\n\t\t\t\tsize[0] += a[j];\n\t\t\t\n\t\t\tfor(int j=i+1; j<n-1; j++) {\n\t\t\t\tsize[1]=0;\n\t\t\t\tfor(int k=i+1; k<=j; k++) \n\t\t\t\t\tsize[1] += a[k];\n\t\t\t\t\n\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t//System.out.println(\"(i,j)=(\"+i+\",\"+j+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\t\tif(min>minmax) minmax=min;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(minmax);\n\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static long Min(long a, long b, long c) {\n\t\tlong key = a;\n\t\tif(a>b) key = b;\n\t\tif(key > c) key =c;\n\t\treturn key;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tlong whole=0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\twhole += a[i];\n\t\t}\n\t\tsc.close();\t\t\n\t\t\n\t\tlong minmax=0;\n\t\tlong[] size = new long[3];\n\t\t\n\t\tfor(int i=0; i<n/2; i++) { //1つめの切り込み\n\t\t\tfor(int j=i+1; j<n*4/5; j++) { //2つめの切り込み\n\t\t\t\tsize[0]=0;\n\t\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\t\tsize[1]=0;\n\t\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\t\n\t\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"(i,j,k)=(\"+i+\",\"+j+\",\"+k+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\t\tif(min>minmax) minmax=min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(minmax);\n\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    private static final int MAX_LENGTH = 1000000000;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.println(\"start of makeCombination()\");\n        long before = System.currentTimeMillis();\n        // ????????£??????????????????????????????\n        Set<Set<Integer>> combinations = makeCombination(numOfPieces);\n        System.out.println(\"end of makeCombination()\");\n        long after = System.currentTimeMillis();\n        System.out.println(after - before);\n\n        int maxLength = 0;\n        for (Set<Integer> combination : combinations) {\n            int minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Integer> calcEachLength(List<Integer> lengthOfPieces, Set<Integer> combination) {\n        Set<Integer> result = new HashSet<>();\n\n        List<Integer> combinationList = new ArrayList<>(combination);\n        Collections.sort(combinationList);\n\n        // ???????????????????????§?????????\n        int lastLength = 0;\n        for (int i = combinationList.get(combinationList.size() - 1); i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        int firstLength = 0;\n        for (int i = 1; i < combinationList.get(0); i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combinationList.size(); i++) {\n            int length = 0;\n            for (int j = combinationList.get(i - 1); j < combinationList.get(i); j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static Set<Set<Integer>> makeCombination(int numOfPieces) {\n        Set<Set<Integer>> result = new HashSet<>();\n\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = i + 1; j <= numOfPieces; j++) {\n                for (int k = j + 1; k <= numOfPieces; k++) {\n                    Set<Integer> set = new HashSet<>();\n                    set.addAll(Arrays.asList(i, j, k));\n                    result.add(set);\n                }\n            }\n        }\n\n        return result.stream().filter(set -> (set.size() == 3)).collect(Collectors.toSet());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n    \npublic class Main{\n\nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int N;\nstatic long[] sum;\n\npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nN=ir.nextInt();\nint[] s=ir.toIntArray(N);\nsum=new long[2*N+1];\nsum[0]=0;\nfor(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\nlong ans=0;\nfor(int i=0;i<N-2;i++){\nint l=i+1;\nint r=i+2;\nwhile(true){\nif(r>=N) break;\nlong a=sum[i+N]-sum[r];\nlong b=sum[r]-sum[l];\nlong c=sum[l]-sum[i];\nlong res;\nif(a<=b&&a<=c){\nans=Math.max(ans,a);\nbreak;\n}\nelse if(b<=a&&b<=c){\nres=b;\nr++;\n}\nelse{\nres=c;\nif(r>l+1) l++;\nelse r++;\n}\nans=Math.max(ans,res);\n}\n}\nout.println(ans);\nout.flush();\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n\npublic InputReader(InputStream in) {this.in=in;}\n  \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n\npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n\nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n\npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new long[N];\n\t\tlong m = 1000000000000L, M = 0L;\n\t\tlong tmp;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main0600{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    private static final long MAX_LENGTH = 100000000000000L;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        // ????????£??????????????????????????????\n        Set<Set<Integer>> combinations = makeCombination(numOfPieces);\n\n        long maxLength = 0;\n        for (Set<Integer> combination : combinations) {\n            long minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Long> calcEachLength(List<Integer> lengthOfPieces, Set<Integer> combination) {\n        Set<Long> result = new HashSet<>();\n\n        List<Integer> combinationList = new ArrayList<>(combination);\n        Collections.sort(combinationList);\n\n        // ???????????????????????§?????????\n        long lastLength = 0;\n        for (int i = combinationList.get(combinationList.size() - 1); i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        long firstLength = 0;\n        for (int i = 1; i < combinationList.get(0); i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combinationList.size(); i++) {\n            long length = 0;\n            for (int j = combinationList.get(i - 1); j < combinationList.get(i); j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static Set<Set<Integer>> makeCombination(int numOfPieces) {\n        Set<Set<Integer>> result = new HashSet<>();\n\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = i + 1; j <= numOfPieces; j++) {\n                for (int k = j + 1; k <= numOfPieces; k++) {\n                    Set<Integer> set = new HashSet<>();\n                    set.addAll(Arrays.asList(i, j, k));\n                    result.add(set);\n                }\n            }\n        }\n\n        return result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new long[N];\n\t\tlong m = 100000000000L, M = 0L;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int i = 1; i < N - 1; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tfor(int k = j + 1; k < N + 1; k++){\n\t\t\t\t\tfor(int i2 = i; i2 < j; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = j; j2 < k; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = k; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\tif(i > 1){\n\t\t\t\t\t\tfor(int l = 1;l < i; l++) kei3 = kei3 + A[l - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\n\t\t\t\t\tkei1 = 0L;\n\t\t\t\t\tkei2 = 0L;\n\t\t\t\t\tkei3 = 0L;\n\t\t\t\t\tm = 100000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int N=ir.nextInt();\n int[] s=ir.nextIntArray(N);\n long[] sum=new long[2*N+1];\n sum[0]=0;\n for(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\n long ans=0;\n int l=0;\n int m=1;\n int r=2;\n while(true){\n  if(r>=N) break;\n  long a=sum[l+N]-sum[r],b=sum[r]-sum[m],c=sum[m]-sum[l],res;\n  if(a<=b&&a<=c){\n   res=a;\n   if(m>l+1) l++;\n   else {\n    m++; l++;\n   }\n  }\n  else if(b<=a&&b<=c){\n   res=b;\n   r++;\n  }\n  else{\n   res=c;\n   if(r>m+1) m++;\n   else{\n    r++; m++;\n   }\n  }\n  ans=Math.max(ans,res);\n }\n out.println(ans);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new long[N];\n\t\tlong m = 100000000000L, M = 0L;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int i = 1; i < N - 1; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tfor(int k = j + 1; k < N + 1; k++){\n\t\t\t\t\tfor(int i2 = i; i2 < j; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = j; j2 < k; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = k; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\tif(i > 1){\n\t\t\t\t\t\tfor(int l = 1;l < i; l++) kei3 = kei3 + A[l - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\n\t\t\t\t\tkei1 = 0L;\n\t\t\t\t\tkei2 = 0L;\n\t\t\t\t\tkei3 = 0L;\n\t\t\t\t\tm = 100000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n    private static final int MAX_LENGTH = 1000000000;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        // ????????£??????????????????????????????\n        Set<Set<Integer>> combinations = makeCombination(numOfPieces);\n\n        int maxLength = 0;\n        for (Set<Integer> combination : combinations) {\n            int minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Integer> calcEachLength(List<Integer> lengthOfPieces, Set<Integer> combination) {\n        Set<Integer> result = new HashSet<>();\n\n        List<Integer> combinationList = new ArrayList<>(combination);\n        Collections.sort(combinationList);\n\n        // ???????????????????????§?????????\n        int lastLength = 0;\n        for (int i = combinationList.get(combinationList.size() - 1); i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        int firstLength = 0;\n        for (int i = 1; i < combinationList.get(0); i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combinationList.size(); i++) {\n            int length = 0;\n            for (int j = combinationList.get(i - 1); j < combinationList.get(i); j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static Set<Set<Integer>> makeCombination(int numOfPieces) {\n        Set<Set<Integer>> result = new HashSet<>();\n\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = i + 1; j <= numOfPieces; j++) {\n                for (int k = j + 1; k <= numOfPieces; k++) {\n                    Set<Integer> set = new HashSet<>();\n                    set.addAll(Arrays.asList(i, j, k));\n                    result.add(set);\n                }\n            }\n        }\n\n        return result.stream().filter(set -> (set.size() == 3)).collect(Collectors.toSet());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.parseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Baumkuchen {\n\tpublic static void main(String[] args){\n\t\tint B1 = 0;\n\t\tint B2 = 0;\n\t\tint B3 = 0;\n\t\tint B4 = 0;\n\t\tint Bmin = 0;\n\t\tint BMIN = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint b[] = new int[n];\n\t\tfor(int x = 0; x <= n-1; x++){\n\t\t\tb[x] = scan.nextInt();\n\t\t}\n\t\tfor(int p = 1; p <= n-2; p++){\n\t\t\tfor(int q = p+1; q <= n-1; q++){\n\t\t\t\tB1 = 0;\n\t\t\t\tB2 = 0;\n\t\t\t\tB3 = 0;\n\t\t\t\tfor(int i = 0; i <= p-1; i++){\n\t\t\t\t\tB1 += b[i];\n\t\t\t\t}\n\t\t\t\tfor(int j = p; j <= q-1; j++){\n\t\t\t\t\tB2 += b[j];\n\t\t\t\t}\n\t\t\t\tfor(int k = q; k <= n-1; k++){\n\t\t\t\t\tB3 += b[k];\n\t\t\t\t}\n\t\t\t\tBmin = Math.min(B1, B2);\n\t\t\t\tBmin = Math.min(Bmin, B3);\n\t\t\t\tBMIN = Math.max(BMIN, Bmin);\n\t\t\t}\n\t\t}\n\t\tfor(int p = 1; p <= n-3; p++){\n\t\t\tfor(int q = p+1; q <= n-2; q++){\n\t\t\t\tfor(int r = q+1; r <= n-1; r++){\n\t\t\t\t\tB1 = 0;\n\t\t\t\t\tB2 = 0;\n\t\t\t\t\tB3 = 0;\n\t\t\t\t\tB4 = 0;\n\t\t\t\t\tfor(int i = 0; i <= p-1; i++){\n\t\t\t\t\t\tB1 += b[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = p; j <= q-1; j++){\n\t\t\t\t\t\tB2 += b[j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = q; k <= r-1; k++){\n\t\t\t\t\t\tB3 += b[k];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l = r; l <= n-1; l++){\n\t\t\t\t\t\tB4 += b[l];\n\t\t\t\t\t}\n\t\t\t\t\tBmin = Math.min(B1+B4, B2);\n\t\t\t\t\tBmin = Math.min(Bmin, B3);\n\t\t\t\t\tBMIN = Math.max(BMIN, Bmin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(BMIN);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong int m = 200000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 200000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static long Min(long a, long b, long c) {\n\t\tlong key = a;\n\t\tif(a>b) key = b;\n\t\tif(key > c) key =c;\n\t\treturn key;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tlong whole=0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\twhole += a[i];\n\t\t}\n\t\tsc.close();\t\t\n\t\t\n\t\tlong minmax=0;\n\t\tlong[] size = new long[3];\n\t\t\n\t\tfor(int i=0; i<n-2; i++) { //1つめの切り込み\n\t\t\tfor(int j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\t\tsize[0]=0;\n\t\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\t\tsize[1]=0;\n\t\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\t\n\t\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"(i,j,k)=(\"+i+\",\"+j+\",\"+k+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\t\tif(min>minmax) minmax=min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(minmax);\n\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static int Min(int a, int b, int c) {\n\t\tint key = a;\n\t\tif(a>b) key = b;\n\t\tif(key > c) key =c;\n\t\treturn key;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint whole=0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\twhole += a[i];\n\t\t}\n\t\tsc.close();\t\t\n\t\t\n\t\tint minmax=0;\n\t\tint[] size = new int[3];\n\t\t\n\t\tfor(int i=0; i<n/2; i++) { //1つめの切り込み\n\t\t\tfor(int j=i+1; j<n*4/5; j++) { //2つめの切り込み\n\t\t\t\tsize[0]=0;\n\t\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\t\tsize[1]=0;\n\t\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\t\n\t\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"(i,j,k)=(\"+i+\",\"+j+\",\"+k+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\t\tint min = Min(size[0], size[1], size[2]);\n\t\t\t\tif(min>minmax) minmax=min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(minmax);\n\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int N=ir.nextInt();\n int[] s=ir.nextIntArray(N);\n long[] sum=new long[2*N+1];\n sum[0]=0;\n for(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\n long ans=0;\n int l=0;\n int m=1;\n int r=2;\n while(true){\n  if(r>=N) break;\n  long a=sum[l+N]-sum[r],b=sum[r]-sum[m],c=sum[m]-sum[l],res;\n  if(a<=b&&a<=c){\n   res=a;\n   if(m>l+1) l++;\n   else {\n    m++; l++;\n   }\n  }\n  else if(b<=a&&b<=c){\n   res=b;\n   r++;\n  }\n  else{\n   res=c;\n   if(r>m+1) m++;\n   else{\n    r++; m++;\n   }\n  }\n  ans=Math.max(ans,res);\n }\n out.println(ans);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n\tprivate static int baumNum;\n\tprivate static int[] baum;\n\tprivate static int firstBaumStart;\n\tprivate static int secondBaumStart;\n\tprivate static int thirdBaumStart;\n\tprivate static int firstBaumSize;\n\tprivate static int secondBaumSize;\n\tprivate static int thirdBaumSize;\n\n\tprivate static int minBaumNo;\n\tprivate static final int FIRST = 1;\n\tprivate static final int SECOND = 2;\n\tprivate static final int THIRD = 3;\n\n\tprivate static int minBaumSize = Integer.MIN_VALUE;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(new InputStreamReader(System.in));\n\n\t\tbaumNum = sc.nextInt();\n\t\tbaum = new int[baumNum];\n\t\tfor (int i = 0; i < baumNum; i++) {\n\t\t\tbaum[i] = sc.nextInt();\n\t\t}\n\n\t\t// ???????????????????°????????????????????????????????????§???????±??????????\n\t\t// ???????????????????°????????????????????????????????????§????????§??????????????????\n\t\t// ??????????????????????????§?¶??????????\n\t\t// ?????????????????????????????????????°????????????£?????¨????????¨??????\n\t\tint tmp = baumNum / 3;\n\t\tfirstBaumStart = 0;\n\t\tsecondBaumStart = firstBaumStart + tmp;\n\t\tthirdBaumStart = secondBaumStart + tmp;\n\n\t\twhile (true) {\n\t\t\tgetBaumSize(); // ???????????????????????????????????????????????????\n\t\t\tgetMinBaumNo(); // ???????°??????????????????????????????????????????????\n\t\t\ttryRaiseBaumSize(); // ???????°?????????????????????????????????????????????§??????????????????\n\t\t}\n\t}\n\n\tprivate static void tryRaiseBaumSize() {\n\t\tswitch (minBaumNo) {\n\t\tcase FIRST:\n\t\t\tfirstBaumSize = getBaumSize(firstBaumStart, secondBaumStart + 1);\n\t\t\tsecondBaumSize = getBaumSize(secondBaumStart + 1, thirdBaumStart);\n\t\t\tif ((firstBaumSize < minBaumSize) && (secondBaumStart < minBaumSize)) {\n\t\t\t\tendGame();\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t\tsecondBaumStart++;\n\t\t\tbreak;\n\t\tcase SECOND:\n\t\t\tfirstBaumSize = getBaumSize(firstBaumStart, secondBaumStart - 1);\n\t\t\tsecondBaumSize = getBaumSize(secondBaumStart - 1, thirdBaumStart);\n\t\t\tif ((firstBaumSize < minBaumSize)\n\t\t\t\t\t|| (secondBaumStart < minBaumSize)) {\n\n\t\t\t} else {\n\t\t\t\tsecondBaumStart--;\n\t\t\t}\n\t\t\tsecondBaumSize = getBaumSize(secondBaumStart, thirdBaumStart + 1);\n\t\t\tthirdBaumSize = getBaumSize(thirdBaumStart + 1, baumNum);\n\t\t\tif ((secondBaumSize < minBaumSize)\n\t\t\t\t\t|| (thirdBaumSize < minBaumSize)) {\n\t\t\t\tendGame();\n\t\t\t}\n\t\t\tthirdBaumStart++;\n\t\t\tbreak;\n\t\tcase THIRD:\n\t\t\tsecondBaumSize = getBaumSize(secondBaumStart, thirdBaumStart - 1);\n\t\t\tthirdBaumSize = getBaumSize(thirdBaumStart - 1, baumNum);\n\t\t\tif ((secondBaumSize < minBaumSize)\n\t\t\t\t\t|| (thirdBaumSize < minBaumSize)) {\n\t\t\t\tendGame();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate static void endGame() {\n\t\tSystem.out.println(minBaumSize);\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static void getBaumSize() {\n\t\tfirstBaumSize = getBaumSize(firstBaumStart, secondBaumStart);\n\t\tsecondBaumSize = getBaumSize(secondBaumStart, thirdBaumStart);\n\t\tthirdBaumSize = getBaumSize(thirdBaumStart, baumNum);\n\t}\n\n\tprivate static int getBaumSize(int start, int end) {\n\t\tint tmpSum = 0;\n\t\tfor (int i = start; i < end; i++) {\n\t\t\ttmpSum += baum[i];\n\t\t}\n\t\treturn tmpSum;\n\t}\n\n\tprivate static void getMinBaumNo() {\n\t\tint tmpMax = Integer.MAX_VALUE;\n\t\tif (firstBaumSize < tmpMax) {\n\t\t\ttmpMax = firstBaumSize;\n\t\t\tminBaumNo = FIRST;\n\t\t}\n\t\tif (secondBaumSize < tmpMax) {\n\t\t\ttmpMax = secondBaumSize;\n\t\t\tminBaumNo = SECOND;\n\t\t}\n\t\tif (thirdBaumSize < tmpMax) {\n\t\t\ttmpMax = thirdBaumSize;\n\t\t\tminBaumNo = THIRD;\n\t\t}\n\t\tminBaumSize = tmpMax;\n\t}\n\n\tprivate static void printCurrentBaum() {\n\t\tSystem.out.println(String.format(\"????????????????????????????????????%d\", firstBaumSize));\n\t\tSystem.out.println(String.format(\"????????????????????????????????????%d\", secondBaumSize));\n\t\tSystem.out.println(String.format(\"????????????????????????????????????%d\", thirdBaumSize));\n\t\tSystem.out.println(String.format(\"???????°???????????????????????????????%d???????????§?????????%d\", minBaumNo, minBaumSize));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 1000000000000L, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n    \npublic class Main{\n\nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int N;\nstatic long[] sum;\n\npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nN=ir.nextInt();\nint[] s=ir.toIntArray(N);\nsum=new long[2*N+1];\nsum[0]=0;\nfor(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\nlong ans=0;\nfor(int i=0;i<N-2;i++){\nint l=i+1;\nint r=i+2;\nwhile(true){\nif(r>=N) break;\nlong a=sum[i+N]-sum[r];\nlong b=sum[r]-sum[l];\nlong c=sum[l]-sum[i];\nlong res;\nif(a<=b&&a<=c){\nans=Math.max(ans,a);\nbreak;\n}\nelse if(b<=a&&b<=c){\nres=b;\nr++;\n}\nelse{\nres=c;\nif(r>l+1) l++;\nelse{\nr++; l++;\n}\n}\nans=Math.max(ans,res);\n}\n}\nout.println(ans);\nout.flush();\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n\npublic InputReader(InputStream in) {this.in=in;}\n  \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n\npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n\nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n\npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n\npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.perseInt(str);//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.parseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new int[N];\n\t\tlong m = 1000000000000L, M = 0L;\n\t\tlong tmp;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tA[i] = Integer.perseInt(br.readLine())//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 200000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 200000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    private static final int MAX_LENGTH = 1000000000;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        // ????????£??????????????????????????????\n        Set<Set<Integer>> combinations = makeCombination(numOfPieces);\n\n        int maxLength = 0;\n        for (Set<Integer> combination : combinations) {\n            int minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Integer> calcEachLength(List<Integer> lengthOfPieces, Set<Integer> combination) {\n        Set<Integer> result = new HashSet<>();\n\n        List<Integer> combinationList = new ArrayList<>(combination);\n        Collections.sort(combinationList);\n\n        // ???????????????????????§?????????\n        int lastLength = 0;\n        for (int i = combinationList.get(combinationList.size() - 1); i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        int firstLength = 0;\n        for (int i = 1; i < combinationList.get(0); i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combinationList.size(); i++) {\n            int length = 0;\n            for (int j = combinationList.get(i - 1); j < combinationList.get(i); j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static Set<Set<Integer>> makeCombination(int numOfPieces) {\n        Set<Set<Integer>> result = new HashSet<>();\n\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = i + 1; j <= numOfPieces; j++) {\n                for (int k = j + 1; k <= numOfPieces; k++) {\n                    Set<Integer> set = new HashSet<>();\n                    set.addAll(Arrays.asList(i, j, k));\n                    result.add(set);\n                }\n            }\n        }\n\n        return result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint kosuu = Integer.perseInt(str);\n\t\tint[] A = new int[kosuu];//配列の宣言の仕方自信なし\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < kosuu; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.perseInt(str);//引数に戻り値のあるメソッドを指定してよいかわからない\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < kosuu; i++){\n\t\t\tfor(int j = i + 1; j < kosuu + 1; j++){\n\t\t\t\tfor(int k = j + 1; k < kosuu + 2; k++){\n\t\t\t\t\tfor(int i2 = 0; i2 < i; i2++) kei1 = kei1 + A[i2];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = i; j2 < j; j2++) kei2 = kei2 + A[j2];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = j; k2 < k; k2++) kei3 = kei3 + A[k2];\n\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main0600{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tlong m = 20000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 20000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tint[] A = new int[N];\n\t\tint m = 2000000000, M = 0;\n\t\tint kei = 0;\n\t\tint kei1 = 0, kei2 = 0, kei3 = 0;//3つの切り分けた領域の合計を表す\n\t\tint tmp;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int n = 0; n < N; n++){\n\t\t\tfor(int i = 1; i < N; i++){\n\t\t\t\tfor(int j = i + 1; j < N + 1; j++){\n\t\t\t\t\t\tfor(int i2 = 1; i2 <= i; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\t\tfor(int j2 = i + 1; j2 <= j; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\t\tfor(int k2 = j + 1; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\t\tif(m > kei3) m = kei3;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\t\n\t\t\t\t\t\tkei1 = 0;\n\t\t\t\t\t\tkei2 = 0;\n\t\t\t\t\t\tkei3 = 0;\n\t\t\t\t\t\tm = 2000000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//1番目に切れ込みを入れるパターンしか計算されないので、バウムクーヘンを回す(配列を循環させる）\n\t\t\ttmp = A[0];\n\t\t\tfor(int n2 = 0; n2 < N - 1; n2++) A[n2] = A[n2 + 1];\n\t\t\tA[N - 1] =tmp;\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\t\n\t\tString str = br.readLine();\n\t\tint N = Integer.parseInt(str);\n\t\tlong[] A = new long[N];\n\t\tlong m = 100000000000L, M = 0L;\n\t\tlong kei1 = 0L, kei2 = 0L, kei3 = 0L;//3つの切り分けた領域の合計を表す\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tstr = br.readLine();\n\t\t\tA[i] = Integer.parseInt(str);\n\t\t}\n\t\t\n\t\t//主処理\n\t\tfor(int i = 1; i < N - 1; i++){\n\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\tfor(int k = j + 1; k < N + 1; k++){\n\t\t\t\t\tfor(int i2 = i; i2 < j; i2++) kei1 = kei1 + A[i2 - 1];\n\t\t\t\t\tif(m > kei1) m = kei1;\n\t\t\t\t\tfor(int j2 = j; j2 < k; j2++) kei2 = kei2 + A[j2 - 1];\n\t\t\t\t\tif(m > kei2) m = kei2;\n\t\t\t\t\tfor(int k2 = k; k2 <= N; k2++) kei3 = kei3 + A[k2 - 1];\n\t\t\t\t\tif(i > 1){\n\t\t\t\t\t\tfor(int l = i;l < i + 1; l++) kei3 = kei3 + A[l - 2];\n\t\t\t\t\t}\n\t\t\t\t\tif(m > kei3) m = kei3;\n\n\t\t\t\t\tif(m > M) M = m;\n\t\t\t\t\t\n\t\t\t\t\tkei1 = 0L;\n\t\t\t\t\tkei2 = 0L;\n\t\t\t\t\tkei3 = 0L;\n\t\t\t\t\tm = 100000000000L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(M);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    private static final long MAX_LENGTH = 100000000000000L;\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        int numOfPieces = 0;\n        List<Integer> lengthOfPieces = new ArrayList<>();\n        try {\n            line = br.readLine();\n\n            numOfPieces = Integer.parseInt(line);\n            for (int i = 0; i < numOfPieces; i++) {\n                line = br.readLine();\n                lengthOfPieces.add(Integer.parseInt(line));\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n\n        // ????????£??????????????????????????????\n        int[][] combinations = makeCombination(numOfPieces);\n\n        long maxLength = 0;\n        for (int[] combination : combinations) {\n            long minLength = MAX_LENGTH;\n            // ????????£???????????????????????¨???????°??????????????????????????±???????\n            minLength = Math.min(minLength,\n                    Collections.min(calcEachLength(lengthOfPieces, combination)));\n            // ????°???????????????????????????????????????§????????????????????????\n            maxLength = Math.max(maxLength, minLength);\n        }\n        System.out.println(maxLength);\n    }\n\n    private static Set<Long> calcEachLength(List<Integer> lengthOfPieces, int[] combination) {\n        Set<Long> result = new HashSet<>();\n\n        // ???????????????????????§?????????\n        long lastLength = 0;\n        for (int i = combination[combination.length - 1]; i <= lengthOfPieces.size(); i++) {\n            lastLength += lengthOfPieces.get(i - 1);\n        }\n        long firstLength = 0;\n        for (int i = 1; i < combination[0]; i++) {\n            firstLength += lengthOfPieces.get(i - 1);\n        }\n        result.add(firstLength + lastLength);\n\n        // 2, 3???????????????????????§?????????\n        for (int i = 1; i < combination.length; i++) {\n            long length = 0;\n            for (int j = combination[i - 1]; j < combination[i]; j++) {\n                length += lengthOfPieces.get(j - 1);\n            }\n            result.add(length);\n        }\n\n        return result;\n    }\n\n    private static int[][] makeCombination(int numOfPieces) {\n        int numOfPatterns = numOfPieces * (numOfPieces - 1) * (numOfPieces - 2) / 6;\n        int[][] work = new int[numOfPatterns][3];\n        int workIndex = 0;\n        for (int i = 1; i <= numOfPieces; i++) {\n            for (int j = i + 1; j <= numOfPieces; j++) {\n                for (int k = j + 1; k <= numOfPieces; k++) {\n                    work[workIndex][0] = i;\n                    work[workIndex][1] = j;\n                    work[workIndex][2] = k;\n                    workIndex++;\n                }\n            }\n        }\n\n        return work;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static long Min(long a, long b, long c) {\n\t\tlong key = a;\n\t\tif(a>b) key = b;\n\t\tif(key > c) key =c;\n\t\treturn key;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tlong whole=0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\twhole += a[i];\n\t\t}\n\t\tsc.close();\t\t\n\t\t\n\t\tlong minmax=0;\n\t\tlong[] size = new long[3];\n\t\t\n\t\tfor(int i=0; i<n/2; i++) { //1つめの切り込み\n\t\t\tfor(int j=i+1; j<n-1; j++) { //2つめの切り込み\n\t\t\t\tsize[0]=0;\n\t\t\t\tfor(int k=i; k<j; k++) \n\t\t\t\t\tsize[0]+=a[k];\n\t\t\t\t\t\n\t\t\t\tfor(int k=j+1; k<n; k++) { //3つめの切り込み\n\t\t\t\t\tsize[1]=0;\n\t\t\t\t\tfor(int m=j; m<k; m++)\n\t\t\t\t\t\tsize[1]+=a[m];\n\t\t\t\t\n\t\t\t\t\t\tsize[2] = whole - size[0]-size[1];\n\t\t\t\t\n\t\t\t\t\t\t//System.out.println(\"(i,j,k)=(\"+i+\",\"+j+\",\"+k+\"),(size[0], size[1], size[2]) = (\" + size[0]+\",\"+ size[1]+\",\"+ size[2]+\")\");\n\t\t\t\t\n\t\t\t\tlong min = Min(size[0], size[1], size[2]);\n\t\t\t\tif(min>minmax) minmax=min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(minmax);\n\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n N=ir.nextInt();\n int[] s=ir.nextIntArray(N);\n long[] sum=new long[2*N+1];\n sum[0]=0;\n for(int i=1;i<=2*N;i++) sum[i]=sum[i-1]+(long)s[(i-1)%N];\n long ans=0;\n int l=0;\n int m=1;\n int r=2;\n while(true){\n  if(r>=N) break;\n  long a=sum[l+N]-sum[r],b=sum[r]-sum[m],c=sum[m]-sum[l],res;\n  if(a<=b&&a<=c){\n   res=a;\n   if(m>l+1) l++;\n   else {\n    m++; l++;\n   }\n  }\n  else if(b<=a&&b<=c){\n   res=b;\n   r++;\n  }\n  else{\n   res=c;\n   if(r>m+1) m++;\n   else{\n    r++; m++;\n   }\n  }\n  ans=Math.max(ans,res);\n }\n out.println(ans);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var line = System.Console.ReadLine();\n        int n = Int32.Parse(line);\n        int[] array = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            line = System.Console.ReadLine();\n            array[i] = Int32.Parse(line);\n            sum = sum + array[i];\n        }\n        int ave = sum / 3;\n\n        int temp_a = 0;\n        int temp_b = 0;\n        int[] la = new int[3];\n        int count = 0;\n        sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            sum = sum + array[i];\n            \n            if (i != n - 1)\n            {\n                if (sum + array[i + 1] > ave)\n                {\n                    temp_a = sum;\n                    temp_b = sum + array[i + 1];\n                    if (Math.Abs(temp_a - ave) < Math.Abs(temp_b - ave))\n                    {\n                        la[count] = sum;\n                        count++;\n                        sum = 0;\n                        \n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n            }\n            else\n            {\n                la[count] = sum;\n            }\n        }\n        int min = 0;\n        min = la[0];\n        if (min > la[1])\n        {\n            min = la[1];\n        }\n        if (min > la[2])\n        {\n            min = la[2];\n        }\n        System.Console.Write(min);\n        line = System.Console.ReadLine();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tvar n0_list = from n0 in Enumerable.Range(0, N) where tripartition > v_list[n0] select n0;\n\t\t\tlong interm_maxV = -1;\n\t\t\tforeach (var n0 in n0_list) {\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = findIndex(1 * tripartition + v_list[n0]);\n\t\t\tint[] n2 = findIndex(2 * tripartition + v_list[n0]);\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { v_list[n1] - v_list[n0], v_list[n2] - v_list[n1], v_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\n\t\tprivate int[] findIndex(double target) {\n\t\t\tint n_left = 0;\n\t\t\tint n_right = N;\n\t\t\twhile (n_right - n_left != 1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn new int[] { n_left, n_right };\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        int[] nums = new int[size * 2];\n        int t1 = 0, t2 = 0, t3 = 0, max = 0;\n        int f, s, t;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = int.Parse(Console.ReadLine());\n            nums[size + 1] = nums[1];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a; b < size + i; b++)\n                {\n                    for (f = i; f <= a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a + 1; s <= b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b +1; t <= i + size - 1; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                        max = minnumber(t1, t2, t3);\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static int minnumber(int a, int b, int c){\n        int min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}\n   "
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        long[] nums = new long[size * 2];\n        long t1 = 0, t2 = 0, t3 = 0, max = 0;\n        long f, s, t;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = long.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                    {\n                        max = minnumber(t1, t2, t3);\n                    }\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static long minnumber(long a, long b, long c)\n    {\n        long min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\t\t\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\n\t\tpublic long GetAnwser() {\n\t\t\tlong interm_maxV = -1;\n\t\t\tint n0_max = findLeftIndex(0, N, tripartition);\n\t\t\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint n1_left = findLeftIndex(n0, N, tripartition + v_list[n0]);\n\t\t\tint n2_left = findLeftIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\t\t\tlong V_ll = getMinV(n0, n1_left, n2_left);\n\t\t\tlong V_lr = getMinV(n0, n1_left, n2_left + 1);\n\t\t\tlong V_rl = getMinV(n0, n1_left + 1, n2_left);\n\t\t\tlong V_rr = getMinV(n0, n1_left + 1, n2_left + 1);\n\t\t\treturn Math.Max(Math.Max(V_ll, V_lr), Math.Max(V_rl, V_rr));\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tlong V0 = v_list[n1] - v_list[n0];\n\t\t\tlong V1 = v_list[n2] - v_list[n1];\n\t\t\tlong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\t\treturn Math.Min(Math.Min(V0, V1), V2);\n\t\t}\n\n\t\tprivate int findLeftIndex(int from_n, int to_n, double target) {\n\t\t\tint n_left = from_n;\n\t\t\tint n_right = to_n;\n\t\t\twhile (n_right - n_left !=1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn  n_left;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tv_list = _v_list;\n\t\t\tN = v_list.Length - 1;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tvar n0_list = from n0 in Enumerable.Range(0, N) where tripartition > v_list[n0] select n0;\n\t\t\tlong interm_maxV = -1;\n\t\t\tforeach (var n0 in n0_list) {\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = new int[2];\n\t\t\tint[] n2 = new int[2];\n\n\t\t\tn1[1] = Array.FindIndex<long>(v_list, v => v > 1 * tripartition + v_list[n0]);\n\t\t\tn2[1] = Array.FindIndex<long>(v_list, v => v > 2 * tripartition + v_list[n0]);\n\t\t\tn1[0] = n1[1] - 1;\n\t\t\tn2[0] = n2[1] - 1;\n\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { v_list[n1] - v_list[n0], v_list[n2] - v_list[n1], v_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\tSystem.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();\n\t\t\t\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tsw.Start();\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\n\t\t\tsw.Stop();\n\t\t\tConsole.WriteLine(sw.ElapsedMilliseconds);\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tlong interm_maxV = -1;\n\t\t\tint n0_max = findIndex(0, N, tripartition)[0];\n\t\t\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = findIndex(n0, N, tripartition + v_list[n0]);\n\t\t\tint[] n2 = findIndex(n1[0], N, 2 * tripartition + v_list[n0]);\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { \n\t\t\t\t\tv_list[n1] - v_list[n0], \n\t\t\t\t\tv_list[n2] - v_list[n1], \n\t\t\t\t\tv_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\n\t\tprivate int[] findIndex(int from_n, int to_n, double target) {\n\t\t\tint n_left = from_n;\n\t\t\tint n_right = to_n;\n\t\t\twhile (n_right - n_left !=1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn new int[] { n_left, n_right };\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var line = System.Console.ReadLine();\n        int n = Int32.Parse(line);\n        int[] array = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            line = System.Console.ReadLine();\n            array[i] = Int32.Parse(line);\n            sum = sum + array[i];\n        }\n        int ave = sum / 3;\n\n        int temp_a = 0;\n        int temp_b = 0;\n        int[] la = new int[3];\n        int count = 0;\n        sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            sum = sum + array[i];\n            \n            if (i != n - 1)\n            {\n                if (sum + array[i + 1] > ave)\n                {\n                    temp_a = sum;\n                    temp_b = sum + array[i + 1];\n                    if (Math.Abs(temp_a - ave) < Math.Abs(temp_b - ave))\n                    {\n                        la[count] = sum;\n                        count++;\n                        sum = 0;\n                        \n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n            }\n            else\n            {\n                la[count] = sum;\n            }\n        }\n        int min = 0;\n        min = la[0];\n        if (min > la[1])\n        {\n            min = la[1];\n        }\n        if (min > la[2])\n        {\n            min = la[2];\n        }\n        System.Console.WriteLine(min);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tint[] v_list = new int[N+1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + int.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tint[] v_list = new int[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + int.Parse(Console.ReadLine());\n\t\t\t}\n\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly int[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(int[] _v_list) {\n\t\t\tv_list = _v_list;\n\t\t\tN = v_list.Length - 1;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic int GetAnwser() {\n\t\t\tvar n0_list = from n0 in Enumerable.Range(0, N) where tripartition > v_list[n0] select n0;\n\t\t\tint interm_maxV = -1;\n\t\t\tforeach (var n0 in n0_list) {\n\t\t\t\tint tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate int searchOne(int n0) {\n\t\t\tint[] n1 = new int[2];\n\t\t\tint[] n2 = new int[2];\n\n\t\t\tn1[1] = Array.FindIndex<int>(v_list, v => v > 1 * tripartition + v_list[n0]);\n\t\t\tn2[1] = Array.FindIndex<int>(v_list, v => v > 2 * tripartition + v_list[n0]);\n\t\t\tn1[0] = n1[1] - 1;\n\t\t\tn2[0] = n2[1] - 1;\n\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate int getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return int.MaxValue;\n\t\t\telse {\n\t\t\t\tint[] V0_V1_V2 = new int[] { v_list[n1] - v_list[n0], v_list[n2] - v_list[n1], v_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        int[] nums = new int[size * 2];\n        int t1 = 0, t2 = 0, t3 = 0, max = 0;\n        int f, s, t;\n        int memo = 0;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = int.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                    {\n                        max = minnumber(t1, t2, t3);\n                        memo = b;\n                    }\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static int minnumber(int a, int b, int c)\n    {\n        int min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        int[] nums = new int[size * 2];\n        int t1 = 0, t2 = 0, t3 = 0, max = 0;\n        int f, s, t;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = int.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                    {\n                        max = minnumber(t1, t2, t3);\n                    }\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static int minnumber(int a, int b, int c)\n    {\n        int min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tlong interm_maxV = -1;\n\t\t\tint n0_max = findIndex(0, N, tripartition)[0];\n\t\t\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = findIndex(n0, N, tripartition + v_list[n0]);\n\t\t\tint[] n2 = findIndex(n1[0], N, 2 * tripartition + v_list[n0]);\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { \n\t\t\t\t\tv_list[n1] - v_list[n0], \n\t\t\t\t\tv_list[n2] - v_list[n1], \n\t\t\t\t\tv_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\n\t\tprivate int[] findIndex(int from_n, int to_n, double target) {\n\t\t\tint n_left = from_n;\n\t\t\tint n_right = to_n;\n\t\t\twhile (n_right - n_left !=1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn new int[] { n_left, n_right };\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n  public class Hello{\n    public static void Main(){\n      var line = System.Console.ReadLine();\n      int n = Int32.Parse(line);\n      int[] array = new int[n];\n      int sum =0;\n      for(int i = 0;i<n;i++)\n      {\n        line = System.Console.ReadLine();\n        array[i] = Int32.Parse(line);\n        sum = sum + array[i];\n      }\n      int ave = sum / n;\n      int temp_a = 0;\n      int temp_b = 0;\n      int[] la = new int[3];\n      int count = 0;\n      sum = 0;\n      for(int i = 0;i<n;i++)\n      {\n        sum = sum + array[i];\n        if(sum + array[i + 1] > ave)\n        {\n          temp_a = sum;\n          temp_b = sum + array[i + 1];\n          if(Math.Abs(temp_a - 60) < Math.Abs(temp_b - 60))\n          {\n            la[count] = sum;\n            count++;\n          }\n          else\n          {\n            continue;\n          }\n        }\n      }\n    int min = 0;\n    min = la[0];\n    if(min > la[1])\n    {\n      min = la[1];\n    }\n    if(min > la[2])\n    {\n      min = la[2];\n    }\n    System.Console.Write(min);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var line = System.Console.ReadLine();\n        int n = Int32.Parse(line);\n        int[] array = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            line = System.Console.ReadLine();\n            array[i] = Int32.Parse(line);\n            sum = sum + array[i];\n        }\n        int ave = sum / n;\n        int temp_a = 0;\n        int temp_b = 0;\n        int[] la = new int[3];\n        int count = 0;\n        sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            sum = sum + array[i];\n            if (i != n - 1)\n            {\n                if (sum + array[i + 1] > ave)\n                {\n                    temp_a = sum;\n                    temp_b = sum + array[i + 1];\n                    if (Math.Abs(temp_a - 60) < Math.Abs(temp_b - 60))\n                    {\n                        la[count] = sum;\n                        count++;\n                        sum = 0;\n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n            }\n            else\n            {\n                la[count] = sum;\n            }\n        }\n        int min = 0;\n        min = la[0];\n        if (min > la[1])\n        {\n            min = la[1];\n        }\n        if (min > la[2])\n        {\n            min = la[2];\n        }\n        System.Console.Write(min);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        int[] nums = new int[size * 2];\n        int t1 = 0, t2 = 0, t3 = 0, max = 0;\n        int f, s, t;\n        int memo = 0;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = int.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                    {\n                        max = minnumber(t1, t2, t3);\n                        memo = b;\n                    }\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static int minnumber(int a, int b, int c)\n    {\n        int min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var line = System.Console.ReadLine();\n        int n = Int32.Parse(line);\n        int[] array = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            line = System.Console.ReadLine();\n            array[i] = Int32.Parse(line);\n            sum = sum + array[i];\n        }\n        int ave = sum / 3;\n\n        int temp_a = 0;\n        int temp_b = 0;\n        int[] la = new int[3];\n        int count = 0;\n        sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            sum = sum + array[i];\n            \n            if (i != n - 1)\n            {\n                if (sum + array[i + 1] > ave)\n                {\n                    temp_a = sum;\n                    temp_b = sum + array[i + 1];\n                    if (Math.Abs(temp_a - ave) < Math.Abs(temp_b - ave))\n                    {\n                        la[count] = sum;\n                        count++;\n                        sum = 0;\n                        \n                    }\n                    else\n                    {\n                        continue;\n                    }\n                }\n            }\n            else\n            {\n                la[count] = sum;\n            }\n        }\n        int min = 0;\n        min = la[0];\n        if (min > la[1])\n        {\n            min = la[1];\n        }\n        if (min > la[2])\n        {\n            min = la[2];\n        }\n        System.Console.Write(min);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\t\t\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tN = _v_list.Length - 1;\n\t\t\tv_list = _v_list;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\n\t\tpublic long GetAnwser() {\n\t\t\tlong interm_maxV = -1;\n\t\t\tint n0_max = findLeftIndex(0, N, tripartition);\n\t\t\tfor (int n0 = 0; n0 <= n0_max; n0++){\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint n1_left = findLeftIndex(n0, N, tripartition + v_list[n0]);\n\t\t\tint n2_left = findLeftIndex(n1_left, N, 2 * tripartition + v_list[n0]);\n\t\t\tlong V_ll = getMinV(n0, n1_left, n2_left);\n\t\t\tlong V_lr = getMinV(n0, n1_left, n2_left + 1);\n\t\t\tlong V_rl = getMinV(n0, n1_left + 1, n2_left);\n\t\t\tlong V_rr = getMinV(n0, n1_left + 1, n2_left + 1);\n\t\t\treturn Math.Max(Math.Max(V_ll, V_lr), Math.Max(V_rl, V_rr));\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tlong V0 = v_list[n1] - v_list[n0];\n\t\t\tlong V1 = v_list[n2] - v_list[n1];\n\t\t\tlong V2 = v_list[n0] - v_list[n2] + v_list[N];\n\t\t\treturn Math.Min(Math.Min(V0, V1), V2);\n\t\t}\n\n\t\tprivate int findLeftIndex(int from_n, int to_n, double target) {\n\t\t\tint n_left = from_n;\n\t\t\tint n_right = to_n;\n\t\t\twhile (n_right - n_left !=1) {\n\t\t\t\tint n_mid = (n_right + n_left) / 2;\n\t\t\t\tif (v_list[n_mid] <= target) n_left = n_mid;\n\t\t\t\telse n_right = n_mid;\n\t\t\t}\n\t\t\treturn  n_left;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n  public class Hello{\n    public static void Main(){\n      var line = System.Console.ReadLine();\n      int n = Int32.Parse(line);\n      int[] array = new int[n];\n      int sum =0;\n      for(int i = 0;i<n;i++)\n      {\n        line = System.Console.ReadLine();\n        array[i] = Int32.Parse(line);\n        sum = sum + array[i];\n      }\n      int ave = sum / n;\n      int temp_a = 0;\n      int temp_b = 0;\n      int[] la = new int[3];\n      int count = 0;\n      sum = 0;\n      for(int i = 0;i<n;i++)\n      {\n        sum = sum + array[i];\n        if(sum + array[i + 1] > ave)\n        {\n          temp_a = sum;\n          temp_b = sum + array[i + 1];\n          if(Math.Abs(temp_a - 60) < Math.Abs(temp_b - 60))\n          {\n            la[count] = sum;\n            count++;\n          }\n          else\n          {\n            continue;\n          }\n        }\n      }\n    int min = 0;\n    min = la[0];\n    if(min > la[1])\n    {\n      min = la[1];\n    }\n    if(min > la[2])\n    {\n      min = la[2];\n    }\n    System.Console.Write(min);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Baumkuchen {\n\tclass Baumkuchen {\n\t\tstatic void Main(string[] args) {\n\t\t\t/*\n\t\t\tSystem.IO.StreamReader sr = new System.IO.StreamReader(\"input.txt\");\n\t\t\tint N = int.Parse(sr.ReadLine());\n\t\t\tlong[] v_list = new long[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N+1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + long.Parse(sr.ReadLine());\n\t\t\t}\n\t\t\tsr.Close();\n\t\t\t/*/\n\t\t\tint N = int.Parse(Console.ReadLine());\n\t\t\tint[] v_list = new int[N + 1];\n\t\t\tv_list[0] = 0;\n\t\t\tfor (int n = 1; n < N + 1; n++) {\n\t\t\t\tv_list[n] = v_list[n - 1] + int.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\t//*/\n\t\t\tBaumkuchen baumkuchen = new Baumkuchen(v_list);\n\t\t\tConsole.WriteLine(baumkuchen.GetAnwser());\n\t\t}\n\n\t\treadonly long[] v_list;\n\t\treadonly int N;\n\t\treadonly double tripartition;\n\t\tpublic Baumkuchen(long[] _v_list) {\n\t\t\tv_list = _v_list;\n\t\t\tN = v_list.Length - 1;\n\t\t\ttripartition = v_list[N] / 3.0;\n\t\t}\n\t\tpublic long GetAnwser() {\n\t\t\tvar n0_list = from n0 in Enumerable.Range(0, N) where tripartition > v_list[n0] select n0;\n\t\t\tlong interm_maxV = -1;\n\t\t\tforeach (var n0 in n0_list) {\n\t\t\t\tlong tmp = searchOne(n0);\n\t\t\t\tif (tmp > interm_maxV) interm_maxV = tmp;\n\t\t\t}\n\t\t\treturn interm_maxV;\n\t\t}\n\n\t\tprivate long searchOne(int n0) {\n\t\t\tint[] n1 = new int[2];\n\t\t\tint[] n2 = new int[2];\n\n\t\t\tn1[1] = Array.FindIndex<long>(v_list, v => v > 1 * tripartition + v_list[n0]);\n\t\t\tn2[1] = Array.FindIndex<long>(v_list, v => v > 2 * tripartition + v_list[n0]);\n\t\t\tn1[0] = n1[1] - 1;\n\t\t\tn2[0] = n2[1] - 1;\n\n\t\t\treturn (from nn1 in n1 from nn2 in n2 select getMinV(n0, nn1, nn2)).Max();\n\t\t}\n\n\t\tprivate long getMinV(int n0, int n1, int n2) {\n\t\t\tif (n1 == -1 || n2 == -1) return long.MaxValue;\n\t\t\telse {\n\t\t\t\tlong[] V0_V1_V2 = new long[] { v_list[n1] - v_list[n0], v_list[n2] - v_list[n1], v_list[n0] - v_list[n2] + v_list[N] };\n\t\t\t\treturn V0_V1_V2.Min();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var line = System.Console.ReadLine();\n            int n = Int32.Parse(line);\n            int[] array = new int[n];\n            int sum = 0;\n            for (int i = 0; i < n; i++)\n            {\n                line = System.Console.ReadLine();\n                array[i] = Int32.Parse(line);\n                sum = sum + array[i];\n            }\n            int ave = sum / n;\n            int temp_a = 0;\n            int temp_b = 0;\n            int[] la = new int[3];\n            int count = 0;\n            sum = 0;\n            for (int i = 0; i < n; i++)\n            {\n                sum = sum + array[i];\n                if (i != n - 1)\n                {\n                    if (sum + array[i + 1] > ave)\n                    {\n                        temp_a = sum;\n                        temp_b = sum + array[i + 1];\n                        if (Math.Abs(temp_a - 60) < Math.Abs(temp_b - 60))\n                        {\n                            la[count] = sum;\n                            count++;\n                            sum = 0;\n                        }\n                        else\n                        {\n                            continue;\n                        }\n                    }\n                }\n                else\n                {\n                    la[count] = sum;\n                }\n            }\n            int min = 0;\n            min = la[0];\n            if (min > la[1])\n            {\n                min = la[1];\n            }\n            if (min > la[2])\n            {\n                min = la[2];\n            }\n            System.Console.Write(min);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        int size = int.Parse(Console.ReadLine());\n        long[] nums = new long[size * 2];\n        long t1 = 0, t2 = 0, t3 = 0, max = 0;\n        long f, s, t;\n        for (int i = 0; i < size; i++)\n        {\n            nums[i] = long.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (int i = 0; i < size; i++)\n        {\n            for (int a = i; a < i + size; a++)\n            {\n                for (int b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    long min;\n                    if (t1 < t2)\n                        if (t1 < t3)\n                            min = t1;\n                        else min = t3;\n                    else if (t2 < t3)\n                        min = t2;\n                    else min = t3;\n                    if (max < min)\n                        max = min;\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Example\n{\n    static void Main()\n    {\n        long size = long.Parse(Console.ReadLine());\n        long[] nums = new long[size * 2];\n        long t1 = 0, t2 = 0, t3 = 0, max = 0;\n        long f, s, t;\n        for (long i = 0; i < size; i++)\n        {\n            nums[i] = long.Parse(Console.ReadLine());\n            nums[size + i] = nums[i];\n        }\n        for (long i = 0; i < size; i++)\n        {\n            for (long a = i; a < i + size; a++)\n            {\n                for (long b = a + 1; b <= size + i; b++)\n                {\n                    for (f = i; f < a; f++)\n                        t1 = t1 + nums[f];\n                    for (s = a; s < b; s++)\n                        t2 = t2 + nums[s];\n                    for (t = b; t < i + size; t++)\n                        t3 = t3 + nums[t];\n                    if (max < minnumber(t1, t2, t3))\n                    {\n                        max = minnumber(t1, t2, t3);\n                    }\n                    t1 = 0;\n                    t2 = 0;\n                    t3 = 0;\n                }\n            }\n        }\n        Console.WriteLine(max);\n    }\n    static long minnumber(long a, long b, long c)\n    {\n        long min;\n        if (a < b)\n            if (a < c)\n                min = a;\n            else min = c;\n        else if (b < c)\n            min = b;\n        else min = c;\n        return min;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        var n2 = n << 1;\n        var a = new int[n2];\n        var asum = 0L;\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = int.Parse(Console.ReadLine().Trim());\n            a[i + n] = a[i];\n            asum += a[i];\n        }\n        var b = new long[n2 + 1];\n        for (int i = 1; i <= n2; i++) b[i] = b[i - 1] + a[i - 1];\n        var ans = getAns(b, n, asum);\n        Console.WriteLine(ans);\n    }\n    static long getAns(long[] a, int n, long asum)\n    {\n        var ok = 1L; var ng = long.MaxValue;\n        while (ng - ok > 1L)\n        {\n            var mid = ok + ((ng - ok) >> 1);\n            if (checkMin(a, asum, n, mid)) ok = mid;\n            else ng = mid;\n        }\n        return ok;\n    }\n    static bool checkMin(long[] a, long asum, int n, long t)\n    {\n        var nextp = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var p = LowerBound(a, i + 1, i + n, t + a[i]);\n            var sum1 = a[p] - a[i];\n            if (sum1 >= t) nextp = p + 1;\n            else continue;\n            var p2 = LowerBound(a, nextp, i + n, t + a[p]);\n            var sum2 = a[p2] - a[p];\n            if (sum2 < t) continue;\n            if (asum - sum1 - sum2 >= t) return true;\n        }\n        return false;\n    }\n    public static int LowerBound(long[] arr, int start, int end, long value)\n    {\n        int low = start;\n        int high = end;\n        while (low < high)\n        {\n            var mid = ((high - low) >> 1) + low;\n            if (arr[mid] - value < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n  // a[i + n + n] = a[i];\n}\n\nfunction arrSum(arr, start, end) {\n  var n=0,i;\n  for(i = start; i < end; i++) {\n    n += arr[i];\n  }\n  return n;\n}\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=n-2;i>0;i--) {\n  for (j=0;j<n;j++) {\n    temp = arrSum(a, j, j + i);\n\n    if (temp <= max || temp >= arrSum(a, j + i, j + n)) {\n      continue;\n    }\n    for (k = 1; k < n - i; k++) {\n      min = Math.min(arrSum(a, i + j, i + j + k), arrSum(a, i + j + k, j + n))\n      if(temp <= min && max < temp) {\n        max = temp;\n        break;\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "/// <reference path=\"node.d.ts\" />\n/// <reference path=\"lib.ts\" />\n\nfunction main(input: string[]) {\n\tvar n = +input.shift();\n\tvar a: number[] = [];\n\tfor (var i = 0; i < n; ++i) a.push(+input.shift());\n\n\tvar s = 0;\n\tvar b = [0];\n\tfor (var i = 0; i < n * 2; ++i) {\n\t\ts += a[i % n];\n\t\tb.push(s);\n\t}\n\n\tvar x = 0, y = 0, z = 0;\n\tfunction part(i: number): number {\n\t\tif (i === 0) return b[y] - b[x];\n\t\tif (i === 1) return b[z] - b[y];\n\t\treturn b[x + n] - b[z];\n\t}\n\n\tvar ans = 0;\n\twhile (x < n) {\n\t\twhile (1) {\n\t\t\t++y;\n\t\t\tvar w = z;\n\t\t\twhile (part(0) > part(1) && part(2) >= part(0)) ++z;\n\t\t\tif (part(2) < part(0)) {\n\t\t\t\t--y;\n\t\t\t\tz = w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = Math.max(part(0), ans);\n\t\t++x;\n\t}\n\tconsole.log(ans);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main()\n});\n\nfunction main () {\n  var lines = input.split('\\n');\n  var n = lines[0] - 0;\n  var a = [];\n  var i,j,k;\n  var sum = 0;\n  for (i=0; i <n; i++) {\n    a[i] = lines[i + 1] - 0;\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  \n  var max = 0;\n  var restMin = 0;\n  var first, rest, second, third;\n  for (j = 0;j < n;j++) {\n    first = a[j];\n    rest = sum - first;\n    k = j + 2;\n    second = a[j + 1];\n    third = rest - second;\n    while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n      second += a[k];\n      third = rest - second;\n      k++;\n    }\n    if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n      max = Math.max(first, max);\n    }\n    for (i = 1;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      second -= a[j + i];\n      \n      while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n        second += a[k];\n        third = rest -second;\n        k++;\n      }\n      \n      if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n        max = Math.max(first, max);\n      }\n    }\n  }\n  console.log(max);\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main()\n});\n\nfunction main () {\n  var lines = input.split('\\n');\n  var n = lines[0] - 0;\n  var a = [];\n  var i,j,k;\n  var sum = 0;\n  for (i=0; i <n; i++) {\n    a[i] = lines[i + 1] - 0;\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  var max = 0;\n  var first, rest, second, third;\n  for (j = 0;j < n;j++) {\n    first = 0;\n    for (i = 0;i < n - 2 && first <= max;i++){\n      first += a[j + i];\n    }\n    rest = sum - first;\n    second = a[j + i];\n    k = j + i + 1;\n    third = rest - second;\n    while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n      second += a[k];\n      third = rest - second;\n      k++;\n    }\n    if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n      max = Math.max(first, max);\n    }\n    for (;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      second -= a[j + i];\n      \n      while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n        second += a[k];\n        third = rest -second;\n        k++;\n      }\n\n      if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n        max = Math.max(first, max);\n      } else {\n        break;\n      }\n    }\n  }\n  console.log(max);\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "/// <reference path=\"node.d.ts\" />\n/// <reference path=\"lib.ts\" />\nfunction main(input) {\n    var n = +input.shift();\n    var a = [];\n    for (var i = 0; i < n; ++i)\n        a.push(+input.shift());\n    var s = 0;\n    var b = [];\n    for (var i = 0; i < n * 2; ++i) {\n        s += a[i % n];\n        b.push(s);\n    }\n    var x = 0, y = 0, z = 0;\n    function part(i) {\n        if (i === 0)\n            return b[y] - b[x];\n        if (i === 1)\n            return b[z] - b[y];\n        return b[x + n] - b[z];\n    }\n    var ans = 0;\n    while (x < n) {\n        while (part(0) <= part(2)) {\n            while (part(0) <= Math.min(part(1), part(2)))\n                ++y;\n            --y;\n            ++z;\n        }\n        --z;\n        ans = Math.max(part(0), ans);\n        ++x;\n    }\n    console.log(ans);\n}\n/// <reference path=\"node.d.ts\" />\n/// <reference path=\"main.ts\" />\n(function () {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    var input = '';\n    process.stdin.on('data', function (chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function (chunk) {\n        main(input.split(/\\s+/));\n    });\n})();\n// based on lodash\nvar _;\n(function (_) {\n    function min(a) {\n        return Math.min.apply(Math, a);\n    }\n    _.min = min;\n    function max(a) {\n        return Math.max.apply(Math, a);\n    }\n    _.max = max;\n    function reduce(a, func, init) {\n        var result = init;\n        for (var i = 0; i < a.length; ++i)\n            result = func(result, a[i]);\n        return result;\n    }\n    _.reduce = reduce;\n    function sum(a) {\n        return reduce(a, function (result, v) { return result + v; }, 0);\n    }\n    _.sum = sum;\n})(_ || (_ = {}));"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n  a[i + n + n] = a[i];\n}\n\nvar sum = function (p, n) {\n  return p + n;\n};\nfunction arrSum(arr, start, end) {\n  var n=0,i;\n  for(i = start; i < end; i++) {\n    n += arr[i];\n  }\n  return n;\n}\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=1;i<n-2;i++) {\n  for (j=0;j<n;j++) {\n    temp = arrSum(a, j, j + i);\n    if (temp <= max) {\n      continue;\n    }\n    for (k = 1; k < n - i; k++) {\n      min = Math.min(arrSum(a, i + j, i + j + k), arrSum(a, i + j + k, j + n))\n      if(temp <= min && max < temp) {\n        max = temp;\n        break;\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n  a[i + n + n] = a[i];\n}\n\nvar sum = function (p, n) {\n  return p + n;\n};\nfunction arrSum(arr, start, end) {\n  var n=0,i;\n  for(i = start; i < end; i++) {\n    n += arr[i];\n  }\n  return n;\n}\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=1;i<n-2;i++) {\n  for (j=0;j<n;j++) {\n    temp = arrSum(a, j, j + i);\n    arr = a.slice(j + i, j + n);\n    for (k = 1; k < arr.length; k++) {\n      // min = Math.min(arr.slice(0, k).reduce(sum, 0), arr.slice(k, arr.length).reduce(sum, 0));\n      min = Math.min(arrSum(a, i + j, i + j + k), arrSum(a, i + j + k, j + n))\n      if(arr <= min) {\n        max = Math.max(max, temp);\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n  a[i + n + n] = a[i];\n}\n\nvar sum = function (p, n) {\n  return p + n;\n};\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=1;i<n-2;i++) {\n  for (j=0;j<n;j++) {\n    temp = a.slice(j, j + i).reduce(sum, 0);\n    arr = a.slice(j + i, j + n);\n    for (k = 1; k < arr.length; k++) {\n      min = Math.min(arr.slice(0, k).reduce(sum, 0), arr.slice(k, arr.length).reduce(sum, 0));\n      if(temp <= min) {\n        max = Math.max(max, temp);\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "/// <reference path=\"node.d.ts\" />\n/// <reference path=\"lib.ts\" />\nfunction main(input) {\n    var n = +input.shift();\n    var a = [];\n    for (var i = 0; i < n; ++i)\n        a.push(+input.shift());\n    var s = 0;\n    var b = [0];\n    for (var i = 0; i < n * 2; ++i) {\n        s += a[i % n];\n        b.push(s);\n    }\n    var x = 0, y = 0, z = 0;\n    function part(i) {\n        if (i === 0)\n            return b[y] - b[x];\n        if (i === 1)\n            return b[z] - b[y];\n        return b[x + n] - b[z];\n    }\n    var ans = 0;\n    while (x < n) {\n        while (1) {\n            ++y;\n            var w = z;\n            while (part(0) > part(1))\n                ++z;\n            if (part(2) < part(0)) {\n                --y;\n                z = w;\n                break;\n            }\n        }\n        ans = Math.max(part(0), ans);\n        ++x;\n    }\n    console.log(ans);\n}\n/// <reference path=\"node.d.ts\" />\n/// <reference path=\"main.ts\" />\n(function () {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    var input = '';\n    process.stdin.on('data', function (chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function (chunk) {\n        main(input.split(/\\s+/));\n    });\n})();\n// based on lodash\nvar _;\n(function (_) {\n    function floor(v) {\n        return Math.floor(v);\n    }\n    _.floor = floor;\n    function min(a) {\n        return Math.min.apply(Math, a);\n    }\n    _.min = min;\n    function max(a) {\n        return Math.max.apply(Math, a);\n    }\n    _.max = max;\n    function reduce(a, func, init) {\n        var result = init;\n        for (var i = 0; i < a.length; ++i)\n            result = func(result, a[i]);\n        return result;\n    }\n    _.reduce = reduce;\n    function sortedIndex(a, v) {\n        var s = 0, t = a.length;\n        while (s < t) {\n            var m = _.floor((s + t) / 2);\n            if (a[m] < v)\n                s = m + 1;\n            else\n                t = m;\n        }\n        return s;\n    }\n    _.sortedIndex = sortedIndex;\n    function sum(a) {\n        return reduce(a, function (result, v) { return result + v; }, 0);\n    }\n    _.sum = sum;\n})(_ || (_ = {}));"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main()\n});\n\nfunction main () {\n  var lines = input.split('\\n');\n  var n = lines[0] - 0;\n  var a = [];\n  var i,j,k;\n  var sum = 0;\n  for (i=0; i <n; i++) {\n    a[i] = lines[i + 1] - 0;\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  var max = 0;\n  var first, rest, second, third;\n  for (j = 0;j < n;j++) {\n    first = 0;\n    for (i = 0;i < n - 2 && first <= max;i++){\n      first += a[j + i];\n    }\n    rest = sum - first;\n    second = a[j + i];\n    k = j + i + 1;\n    third = rest - second;\n    while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n      second += a[k];\n      third = rest - second;\n      k++;\n    }\n    if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n      max = Math.max(first, max);\n    }\n    for (;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      second -= a[j + i];\n      \n      while (k < j + n - 1 && second + a[k] <= third - a[k]) {\n        second += a[k];\n        third = rest -second;\n        k++;\n      }\n\n      if((first <= second && first <= third) || (first <= second + a[k] && first <= third - a[k])) {\n        max = Math.max(first, max);\n      } else {\n        break;\n      }\n    }\n  }\n  console.log(max);\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead);\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n}\n\nfunction arrSum(arr, start, end) {\n  var n=0,i;\n  for(i = start; i < end; i++) {\n    n += arr[i];\n  }\n  return n;\n}\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=n-2;i>0;i--) {\n  for (j=0;j<n;j++) {\n    temp = arrSum(a, j, j + i);\n    if (temp <= max || temp >= arrSum(a, j + i, j + n)) {\n      continue;\n    }\n    for (k = 1; k < n - i; k++) {\n      min = Math.min(arrSum(a, i + j, i + j + k), arrSum(a, i + j + k, j + n))\n      if(temp <= min && max < temp) {\n        max = temp;\n        break;\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar lines = input.split('\\n');\nvar n = lines[0] - 0;\nvar a = [];\nvar i,j,k;\nfor (i=0; i <n; i++) {\n  a[i] = lines[i + 1] - 0;\n  a[i + n] = a[i];\n  a[i + n + n] = a[i];\n}\n\nvar sum = function (p, n) {\n  return p + n;\n};\nfunction arrSum(arr, start, end) {\n  var n=0,i;\n  for(i = start; i < end; i++) {\n    n += arr[i];\n  }\n  return n;\n}\nvar max = 0;\nvar min = 0\nvar temp = 0, arr;\nfor (i=1;i<n-2;i++) {\n  for (j=0;j<n;j++) {\n    temp = arrSum(a, j, j + i);\n    // arr = a.slice(j + i, j + n);\n    for (k = 1; k < n - i; k++) {\n      // min = Math.min(a.slice(i + j, i + j + k).reduce(sum, 0), a.slice(i + j + k, j + n).reduce(sum, 0));\n      min = Math.min(arrSum(a, i + j, i + j + k), arrSum(a, i + j + k, j + n))\n      // console.log(temp, min)\n\n      if(temp <= min) {\n        max = Math.max(max, temp);\n        // console.log(a.slice(j, j + i), a.slice(i + j,i + j + k), a.slice(i + j + k, j + n))\n      }\n    }\n  }\n}\nconsole.log(max);"
  },
  {
    "language": "JavaScript",
    "code": "/// <reference path=\"node.d.ts\" />\n/// <reference path=\"lib.ts\" />\nfunction main(input) {\n    var n = +input.shift();\n    var a = [];\n    for (var i = 0; i < n; ++i)\n        a.push(+input.shift());\n    var s = 0;\n    var b = [0];\n    for (var i = 0; i < n * 2; ++i) {\n        s += a[i % n];\n        b.push(s);\n    }\n    var x = 0, y = 0, z = 0;\n    function part(i) {\n        if (i === 0)\n            return b[y] - b[x];\n        if (i === 1)\n            return b[z] - b[y];\n        return b[x + n] - b[z];\n    }\n    var ans = 0;\n    while (x < n) {\n        while (1) {\n            ++y;\n            var w = z;\n            while (part(0) > part(1) && part(2) >= part(0))\n                ++z;\n            if (part(2) < part(0)) {\n                --y;\n                z = w;\n                break;\n            }\n        }\n        ans = Math.max(part(0), ans);\n        ++x;\n    }\n    console.log(ans);\n}\n/// <reference path=\"node.d.ts\" />\n/// <reference path=\"main.ts\" />\n(function () {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    var input = '';\n    process.stdin.on('data', function (chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function (chunk) {\n        main(input.split(/\\s+/));\n    });\n})();\n// based on lodash\nvar _;\n(function (_) {\n    function floor(v) {\n        return Math.floor(v);\n    }\n    _.floor = floor;\n    function min(a) {\n        return Math.min.apply(Math, a);\n    }\n    _.min = min;\n    function max(a) {\n        return Math.max.apply(Math, a);\n    }\n    _.max = max;\n    function reduce(a, func, init) {\n        var result = init;\n        for (var i = 0; i < a.length; ++i)\n            result = func(result, a[i]);\n        return result;\n    }\n    _.reduce = reduce;\n    function sortedIndex(a, v) {\n        var s = 0, t = a.length;\n        while (s < t) {\n            var m = _.floor((s + t) / 2);\n            if (a[m] < v)\n                s = m + 1;\n            else\n                t = m;\n        }\n        return s;\n    }\n    _.sortedIndex = sortedIndex;\n    function sum(a) {\n        return reduce(a, function (result, v) { return result + v; }, 0);\n    }\n    _.sum = sum;\n})(_ || (_ = {}));"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main()\n});\n\nfunction main () {\n  var lines = input.split('\\n');\n  var n = lines[0] - 0;\n  var a = [];\n  var i,j,k;\n  var sum = 0;\n  for (i=0; i <n; i++) {\n    a[i] = lines[i + 1] - 0;\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  \n  var max = 0;\n  var min;\n  var first, rest;\n  for (j = 0;j < n;j++) {\n    first = 0;\n    rest = sum;\n    for (i = 0;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      \n      if(first > max && check(rest, first, j + i + 1, j + n - i)) {\n        max = first;\n        continue;\n      }\n    }\n  }\n  function check(rest, first, k, m) {\n    var second = 0;\n    while (k < m) {\n      second += a[k];\n      rest -= a[k];\n      if (first <= rest && first <= second) {\n        return true;\n      }\n      k++;\n    }\n\n    return false;\n  }\n  console.log(max);\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n})\nprocess.stdin.on('end', function() {\n  main()\n});\n\nfunction main () {\n  var lines = input.split('\\n');\n  var n = lines[0] - 0;\n  var a = [];\n  var i,j,k;\n  var sum = 0;\n  for (i=0; i <n; i++) {\n    a[i] = lines[i + 1] - 0;\n    a[i + n] = a[i];\n    sum += a[i];\n  }\n  \n  var max = 0;\n  var min;\n  var first, rest;\n  for (j = 0;j < n;j++) {\n    first = 0;\n    rest = sum;\n    for (i = 0;i < n - 2;i++){\n      first += a[j + i];\n      rest -= a[j + i];\n      if(first > max && check(rest, first, j + i + 1, j + n - 1)) {\n        max = first;\n        continue;\n      }\n    }\n  }\n  function check(rest, first, k, m) {\n    var second = 0;\n    while (k < m) {\n      second += a[k];\n      rest -= a[k];\n      if (first <= rest && first <= second) {\n        return true;\n      }\n      if (second > rest) {\n        return false;\n      }\n      k++;\n    }\n\n    return false;\n  }\n  console.log(max);\n\n}"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\nmax = -1\nsize = a.size\nfor i in (1..(size-1))\n  for j in ((i+1)..(size-1))\n    for k in ((j+1)..size)\n      x = [(((k < size) ? a[k..(size-1)] : []) \\\n            + a[0..(i-1)]), a[i..(j-1)], a[j..(k-1)]].collect { |l|\n        l.inject(:+)\n      }.sort[0]\n\n      if x > max then\n        max = x\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "sum = 0\nn = gets.to_i\nBAUM = n.times.map { sum += gets.to_i }\nLENGTH = BAUM.last\ndef cut from, to\n  p = BAUM[to - 1] - BAUM[from - 1]\n  p < 0 ? p + LENGTH : p\nend\n\nleast = 0\n(0...n - 2).each {|a|\n  (a + 1...n - 1).each {|b|\n    a_b = cut a, b\n    break if a_b <= least\n    (b + 1...n).each {|c|\n      b_c = cut b, c\n      break if b_c <= least\n      least = [[a_b, b_c, cut(c, a)].min, least].max\n    }\n  }\n}\nputs least"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}[1..-1]\n\tend\n\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 100\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nt = Time.new\n\nn = gets.to_i\na = $<.map(&:to_i)\naccum = a.accum\ntotal = accum[-1]\n\nsubset_sum = -> i, j {\n\tif i <= j\n\t\taccum[j] - (i > 0 ? accum[i-1] : 0)\n\telse\n\t\taccum[-1] - accum[i-1] + accum[j]\n\tend\n}\n\nbest = [\n\tsubset_sum[0, a.size/3-1],\n\tsubset_sum[a.size/3, a.size/3*2-1],\n\tsubset_sum[a.size/3*2, a.size-1]\n\t].min\n\nindices = (0..n-1).to_a\n\ni = 0\nloop {\n\tj = indices.bsearch(i+1, n-1){|k| subset_sum[i, k-1] > best}\n\tj = indices.bsearch(0, i-2){|k| subset_sum[i, (k-1)%n] > best} unless j\n\n\twhile j && subset_sum[i, (j-1)%n] + 2 * best < total\n\t\tk = indices.bsearch(j+2, n-1){|l| subset_sum[j, l-1] > subset_sum[l, (i-1)%n]}\n\t\tk = indices.bsearch(0, i){|l| subset_sum[j, (l-1)%n] > subset_sum[l%n, (i-1)%n]} unless k\n\t\tif k\n\t\t\tmin = [\n\t\t\t\tsubset_sum[i, (j-1)%n],\n\t\t\t\tsubset_sum[j, (k-1)%n],\n\t\t\t\tsubset_sum[k, (i-1)%n]\n\t\t\t\t].min\n\t\t\tbest = min if min > best\n\t\t\tif k > j + 1\n\t\t\t\tk -= 1\n\t\t\t\tmin = [\n\t\t\t\t\tsubset_sum[i, (j-1)%n],\n\t\t\t\t\tsubset_sum[j, (k-1)%n],\n\t\t\t\t\tsubset_sum[k, (i-1)%n]\n\t\t\t\t\t].min\n\t\t\t\tbest = min if min > best\n\t\t\tend\n\t\tend\n\t\tj = (j + 1) % n\n\tend\n\n\ti += 1\n\tbreak if i == a.size\n}\n\np best"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\n\nsize = a.size # calc size\nsum = a.inject(:+) # calc max\n\nmax = -1\nfor i in (1..(size-1))\n  s0 = a[0..(i-1)].inject(:+)\n  if (s0 < max) then\n    next\n  end\n  for j in ((i+1)..(size-1))\n    s1 = a[i..(j-1)].inject(:+)\n    if (s1 < max) then\n      next\n    end\n    for k in ((j+1)..size)\n      s2 = ((k < size) ? a[k..(size-1)] : [0]).inject(:+) + s0\n      x = [s1, s2, (sum - s1 - s2)].sort[0]\n      if x > max then\n        max = x\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\n\nsize = a.size # calc size\nsum = a.inject(:+) # calc max\n\nmax = -1\nfor i in (1..(size-1))\n  s0 = a[0..(i-1)].inject(:+)  \n  for j in ((i+1)..(size-1))\n    s1 = a[i..(j-1)].inject(:+)\n    if (s1 < max) then\n      next\n    end\n    for k in ((j+1)..size)\n      s2 = ((k < size) ? a[k..(size-1)] : [0]).inject(:+) + s0\n      x = [s1, s2, (sum - s1 - s2)].sort[0]\n      if x > max then\n        max = x\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "def lower_bound(arr, v)\n  l = -1; r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  l\nend\nn = gets.to_i\narr = []\nn.times{ arr << gets.to_i }\nsum = Array.new(2*n+1, 0)\n(2*n).times{ |i| sum[i+1] += sum[i] + arr[i%n] }\nl = 0; r = sum[n] / 3 + 1\nwhile l + 1 < r\n  m = (l + r) / 2\n  f = nil\n  n.times do |i|\n    a = lower_bound(sum[i,n], m + sum[i] - 1) + i + 1\n    if a < i+n\n      b = lower_bound(sum[a...i+n], m + sum[a] - 1) + a + 1\n      if b < i+n && sum[i+n] - sum[b] >= m\n        l = m\n        f = true\n        break\n      end\n    end\n  end\n  r = m unless f \nend\np l"
  },
  {
    "language": "Ruby",
    "code": "sum = 0\nn = gets.to_i\nBAUM = n.times.map { sum += gets.to_i }\nLENGTH = BAUM.last\ndef cut from, to\n  p = BAUM[to - 1] - BAUM[from - 1]\n  p < 0 ? p + LENGTH : p\nend\n\nleast = 0\n(0...n - 2).each {|a|\n  (a + 1...n - 1).each {|b|\n    a_b = cut a, b\n    next if a_b <= least\n    (b + 1...n).each {|c|\n      b_c = cut b, c\n      next if b_c <= least\n      c_a = cut c, a\n      least = [[a_b, b_c, cut(c, a)].min, least].max\n    }\n  }\n}\nputs least"
  },
  {
    "language": "Ruby",
    "code": "def lower_bound(arr, v)\n  l = -1; r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  l\nend\nn = gets.to_i\narr = []\nn.times{ arr << gets.to_i }\nsum = Array.new(2*n+1, 0)\n(2*n).times{ |i| sum[i+1] += sum[i] + arr[i%n] }\nl = 0; r = sum[n] / 3 + 1\nwhile l + 1 < r\n  m = (l + r) / 2\n  f = nil\n  n.times do |i|\n    a = lower_bound(sum[i,n], m + sum[i] - 1) + i + 1\n    if a < i+n\n      b = lower_bound(sum[a...i+n], m + sum[a] - 1) + a + 1\n      if b < i+n && sum[i+n] - sum[b] >= m\n        l = m\n        f = true\n        break\n      end\n    end\n  end\n  r = m unless f \nend\np l"
  },
  {
    "language": "Ruby",
    "code": "\na = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\nb = []\nfor i in (1..(a.size-1))\n  for j in ((i+1)..(a.size-1))\n    for k in ((j+1)..a.size)\n      b.push([(((k < a.size) ? a[k..(a.size-1)] : []) \\\n               + a[0..(i-1)]), a[i..(j-1)], a[j..(k-1)]].collect { |l|\n               l.inject(:+)\n             }.sort[0])\n    end\n  end\nend\n\nputs b.sort[-1]"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\nb = []\nfor i in (1..(a.size-1))\n  for j in ((i+1)..(a.size-1))\n    for k in ((j+1)..a.size)\n      b.push([(((k < a.size) ? a[k..(a.size-1)] : []) \\\n               + a[0..(i-1)]), a[i..(j-1)], a[j..(k-1)]].collect { |l|\n               l.inject(:+)\n             }.sort[0])\n    end\n  end\nend\n\nprint b.sort[-1]"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef lower_bound(arr, key, i0 = 0, i1 = arr.length)\n  lb = i0 - 1\n  ub = i1\n\n  while lb + 1 < ub\n    m = (lb + ub) / 2\n    if arr[m] <= key\n      lb = m\n    else\n      ub = m\n    end\n  end\n  lb\nend\n\ndef div_three?(k)\n  #puts \"k=#{k}\"\n  for i in (0...$n)\n    imax = i + $n\n    #puts \" i=#{i}, imax=#{imax}\"\n    i0 = lower_bound($asums, k + $asums[i] - 1, i, imax) + 1\n    #puts \"  i0=#{i0}\"\n    if i0 < imax\n      i1 = lower_bound($asums, k + $asums[i0] - 1, i0, imax) + 1\n      #puts \"  i1=#{i1}\"\n      if i1 < imax &&\n          $asums[imax] - $asums[i1] >= k\n        return true\n      end\n    end\n  end\n\n  false\nend\n\n### main\n\n$n = gets.strip.to_i\n\n$ais = $n.times.map{gets.strip.to_i}\n$ais += $ais\n#p $ais\n\n$asums = [0]\n(1..(2 * $n)).each{|i| $asums[i] = $asums[i - 1] + $ais[i - 1]}\n#p $asums\n\nk0 = 0\nk1 = $asums[$n] / 3\n\nwhile k0 + 1 < k1\n  km = (k0 + k1) / 2\n  if div_three?(km)\n    k0 = km\n  else\n    k1 = km\n  end\nend\n\nputs k0"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\n\nsize = a.size # calc size\nsum = a.inject(:+) # calc max\n\nmax = -1\nfor i in (1..(size-1))\n  s0 = a[0..(i-1)].inject(:+)\n  for j in ((i+1)..(size-1))\n    s1 = a[i..(j-1)].inject(:+)\n    for k in ((j+1)..size)\n      s2 = ((k < size) ? a[k..(size-1)] : [0]).inject(:+) + s0\n      x = [s1, s2, (sum - s1 - s2)].sort[0]\n      if x > max then\n        max = x\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef lower_bound(arr, key, i0 = 0, i1 = arr.length)\n  lb = i0 - 1\n  ub = i1\n\n  while lb + 1 < ub\n    m = (lb + ub) / 2\n    if arr[m] <= key\n      lb = m\n    else\n      ub = m\n    end\n  end\n  lb\nend\n\ndef div_three?(k)\n  #puts \"k=#{k}\"\n  for i in (0...$n)\n    imax = i + $n\n    #puts \" i=#{i}, imax=#{imax}\"\n    i0 = lower_bound($asums, k + $asums[i] - 1, i, imax) + 1\n    #puts \"  i0=#{i0}\"\n    if i0 < imax\n      i1 = lower_bound($asums, k + $asums[i0] - 1, i0, imax) + 1\n      #puts \"  i1=#{i1}\"\n      if i1 < imax &&\n          $asums[imax] - $asums[i1] >= k\n        return true\n      end\n    end\n  end\n\n  false\nend\n\n### main\n\n$n = gets.strip.to_i\n\n$ais = $n.times.map{gets.strip.to_i}\n$ais += $ais\n#p $ais\n\n$asums = [0]\n(1..(2 * $n)).each{|i| $asums[i] = $asums[i - 1] + $ais[i - 1]}\n#p $asums\n\nk0 = 0\nk1 = $asums[$n] / 3\n\nwhile k0 + 1 < k1\n  km = (k0 + k1) / 2\n  if div_three?(km)\n    k0 = km\n  else\n    k1 = km\n  end\nend\n\nputs k0"
  },
  {
    "language": "Ruby",
    "code": "a = []\n\nnum = gets.to_i\nnum.times {\n  a.push(gets.to_i)\n}\n\nmax = -1\nfor i in (1..(a.size-1))\n  for j in ((i+1)..(a.size-1))\n    for k in ((j+1)..a.size)\n      x = [(((k < a.size) ? a[k..(a.size-1)] : []) \\\n            + a[0..(i-1)]), a[i..(j-1)], a[j..(k-1)]].collect { |l|\n        l.inject(:+)\n      }.sort[0]\n\n      if x > max then\n        max = x\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}[1..-1]\n\tend\n\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\traise if l < 0 || r < 0 || l >= size || r >= size\n\n\t\tif r - l < 10\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\n\n\nt = Time.new\n\nn = gets.to_i\na = $<.map(&:to_i)\naccum = a.accum\ntotal = accum[-1]\n\nsubset_sum = -> i, j {\n\traise \"hage\" if j >= accum.size\n\n\tif i <= j\n\t\taccum[j] - (i > 0 ? accum[i-1] : 0)\n\telse\n\t\taccum[-1] - accum[i-1] + accum[j]\n\tend\n}\n\nbest = [\n\tsubset_sum[0, a.size/3-1],\n\tsubset_sum[a.size/3, a.size/3*2-1],\n\tsubset_sum[a.size/3*2, a.size-1]\n\t].min\n\nindices = (0..n-1).to_a\n\n(0..a.size-1).each{|i|\n\t#p i\n\tj = indices.bsearch(i+1, n-1){|k| subset_sum[i, k-1] > best}\n\tj = indices.bsearch(0, i-2){|k| subset_sum[i, (k-1)%n] > best} unless j\n\tnext unless j\n\n\twhile (min = subset_sum[i, (j-1)%n]) * 3 <= total\n\t\tk = nil\n\t\tif i < j\n\t\t\tk = indices.bsearch(j+1, n-1){|l| min <= subset_sum[j, l-1]}\n\t\t\tk = indices.bsearch(0, i-1){|l| min <= subset_sum[j, (l-1)%n]} unless k\n\t\telse\t\n\t\t\tk = indices.bsearch(j+1, i-1){|l| min <= subset_sum[j, (l-1)%n]}\n\t\tend\n\n\t\tbest = min if k && subset_sum[k, (i-1)%n] >= min\n\t\tj = (j + 1) % n\n\tend\n}\n\np best"
  },
  {
    "language": "Ruby",
    "code": "def lower_bound(arr, v)\n  l = -1; r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  l\nend\nn = gets.to_i\narr = []\nn.times{ arr << gets.to_i }\nsum = Array.new(2*n+1, 0)\n(2*n).times{ |i| sum[i+1] += sum[i] + arr[i%n] }\nl = 0; r = sum[n] / 3\nwhile l + 1 < r\n  m = (l + r) / 2\n  f = nil\n  n.times do |i|\n    a = lower_bound(sum[i,n], m + sum[i] - 1) + i + 1\n    if a < i+n\n      b = lower_bound(sum[a...i+n], m + sum[a] - 1) + a + 1\n      if b < i+n && sum[i+n] - sum[b] >= m\n        l = m\n        f = true\n        break\n      end\n    end\n  end\n  r = m unless f \nend\np l"
  },
  {
    "language": "Ruby",
    "code": "def lower_bound(arr, v)\n  l = -1; r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  l\nend\nn = gets.to_i\narr = []\nn.times{ arr << gets.to_i }\nsum = Array.new(2*n+1, 0)\n(2*n).times{ |i| sum[i+1] += sum[i] + arr[i%n] }\nl = 0; r = sum[n] / 3\nwhile l + 1 < r\n  m = (l + r) / 2\n  f = nil\n  n.times do |i|\n    a = lower_bound(sum[i,n], m + sum[i]) + i + 1\n    if a < i+n\n      b = lower_bound(sum[a...i+n], m + sum[a]) + a + 1\n      if b < i+n && sum[i+n] - sum[b] >= m\n        l = m\n        f = true\n        break\n      end\n    end\n  end\n  r = m unless f \nend\np l"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}[1..-1]\n\tend\n\n\tdef bsearch(l = 0, r = size - 1, &pred)\n\t\tif r - l < 100\n\t\t\treturn (l..r).find{|j| pred[self[j]]}\n\t\tend\n\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nn = gets.to_i\na = $<.map(&:to_i)\naccum = a.accum\ntotal = accum[-1]\n\nsubset_sum = -> i, j {\n\tif i <= j\n\t\taccum[j] - (i > 0 ? accum[i-1] : 0)\n\telse\n\t\taccum[-1] - accum[i-1] + accum[j]\n\tend\n}\n\nbest = [\n\tsubset_sum[0, a.size/3-1],\n\tsubset_sum[a.size/3, a.size/3*2-1],\n\tsubset_sum[a.size/3*2, a.size-1]\n\t].min\n\ni = 0\nloop {\n\tj = (0..n-1).to_a.bsearch(i+1, n-1){|k| subset_sum[i, k-1] >= best}\n\tj = (0..n-1).to_a.bsearch(0, i-2){|k| subset_sum[i, (k-1)%n] >= best} unless j\n\n\twhile subset_sum[i, (j-1)%n] + 2 * best <= total\n\t\tk = (0..n-1).to_a.bsearch(j+1, n-1){|l| subset_sum[j, l-1] >= best}\n\t\tk = (0..n-1).to_a.bsearch(0, i-1){|l| subset_sum[j, (l-1)%n] >= best} unless k\n\n\t\twhile subset_sum[k, (i-1)%n] >= best\n\t\t\t#p [i, j, k]\n\t\t\tmin = [\n\t\t\t\tsubset_sum[i, (j-1)%n],\n\t\t\t\tsubset_sum[j, (k-1)%n],\n\t\t\t\tsubset_sum[k, (i-1)%n]\n\t\t\t\t].min\n\t\t\tbest = min if min > best\n\t\t\tk = (k+1)%n\n\t\tend\n\t\tj = (j + 1) % n\n\tend\n\n\ti += 1\n\tbreak if i == a.size\n}\n\np best"
  },
  {
    "language": "Ruby",
    "code": "sum = 0\nn = gets.to_i\nBAUM = n.times.map { sum += gets.to_i }\nLENGTH = BAUM.last\ndef cut from, to\n  p = BAUM[to - 1] - BAUM[from - 1]\n  p < 0 ? p + LENGTH : p\nend\n\nlimit = LENGTH / 3\nb_fix = c_fix =  a_b = b_c = nil\n(1...n - 1).each {|b|\n  b_fix = b\n  a_b = cut 0, b\n  break if a_b > limit\n}\nremain_limit = limit / 2\nb_c = nil\n(b_fix + 1..n).each {|c|\n  c_fix = c\n  b_c = cut b_fix, c\n  break if b_c > remain_limit\n}\nleast = [a_b, b_c, cut(c_fix, 0)].min\n\n(0...n - 2).each {|a|\n  (a + 1...n - 1).each {|b|\n    a_b = cut a, b\n    next if a_b <= least\n    break if (LENGTH - a_b) < least * 2\n    (b + 1...n).each {|c|\n      b_c = cut b, c\n      next if b_c <= least\n      c_a = cut c, a\n      break if c_a < least\n      least = [[a_b, b_c, c_a].min, least].max\n    }\n  }\n}\nputs least"
  },
  {
    "language": "Ruby",
    "code": "def lower_bound(arr, v)\n  l = -1; r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  l\nend\nn = gets.to_i\narr = n.times.map{ gets.to_i }\nsum = Array.new(2*n+1, 0)\n(2*n).times{ |i| sum[i+1] += sum[i] + arr[i%n] }\nl = 0; r = sum[n] / 3 + 1\nwhile l + 1 < r\n  m = (l + r) / 2\n  i = 0\n  while i < n\n    a = lower_bound(sum[i,n], m + sum[i] - 1) + i + 1\n    if a < i + n\n      b = lower_bound(sum[a...i+n], m + sum[a] - 1) + a + 1\n      break if b < i + n && sum[i+n] - sum[b] >= m\n    end\n    i += 1\n  end\n  i == n ? r = m : l = m\nend\np l"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n// your code goes here\n\n        $setnum = trim(fgets(STDIN));\n        $pcs = array();\n        for($i=0;$i<$setnum;$i++){\n                $pcs[] = trim(fgets(STDIN));\t\n        }\n\n        $pcsmax = 0;\n        for($j=0;$j<$setnum-2;$j++){\n        for($k=$j+1;$k<$setnum-1;$k++){\n        for($l=$k+1;$l<$setnum;$l++){\n           $pc1 = 0; $pc2 = 0; $pc3 = 0;\n           for($m=$j;$m<$k;$m++) $pc1 += $pcs[$m];\n           for($m=$k;$m<$l;$m++) $pc2 += $pcs[$m];        \n           for($m=$l;$m<$setnum;$m++) $pc3 += $pcs[$m];        \n           for($m=0;$m<$j;$m++) $pc3 += $pcs[$m];                \n           if ($pc1 < $pc2) {\n           \t if ($pc3 < $pc1) { $pcmin = $pc3; } else { $pcmin = $pc1; } \n           } else {\n           \t if ($pc3 < $pc2) { $pcmin = $pc3; } else { $pcmin = $pc2; }     \t\n           }\n           if ($pcsmax < $pcmin ) $pcsmax = $pcmin;\n        }\n        }\n        }\n    echo($pcsmax . \"\\n\");"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n// your code goes here\n\n        $setnum = trim(fgets(STDIN));\n        $pcs = array();\n        for($i=0;$i<$setnum;$i++){\n                $pcs[] = trim(fgets(STDIN));\t\n        }\n\n        $pcsmax = 0;\n        for($j=0;$j<$setnum-2;$j++){\n        for($k=$j+1;$k<$setnum-1;$k++){\n        for($l=$k+1;$l<$setnum;$l++){\n           $pc1 = 0; $pc2 = 0; $pc3 = 0;\n           for($m=$j;$m<$k;$m++) $pc1 += $pcs[$m];\n           for($m=$k;$m<$l;$m++) $pc2 += $pcs[$m];        \n           for($m=$l;$m<$setnum;$m++) $pc3 += $pcs[$m];        \n           for($m=0;$m<$j;$m++) $pc3 += $pcs[$m];                \n           if ($pc1 < $pc2) {\n           \t if ($pc3 < $pc1) { $pcmin = $pc3; } else { $pcmin = $pc1; } \n           } else {\n           \t if ($pc3 < $pc2) { $pcmin = $pc3; } else { $pcmin = $pc2; }     \t\n           }\n           if ($pcsmax < $pcmin ) $pcsmax = $pcmin;\n        }\n        }\n        }\n    echo($pcsmax . \"\\n\");"
  },
  {
    "language": "PHP",
    "code": "<?php\n$A=array();\n$B=array(0,0,0);\nfscanf(STDIN,\"%d\",$N);\nfor($i=0;$i<$N;$i++){\n    fscanf(STDIN,\"%d\",$a);\n    array_push($A,$a);\n}\nsort($A);\n//print_r($A);\nwhile(count($A)){\n    $B[0]+=array_pop($A);\n    sort($B);\n}\necho $B[0].\"\\n\";\n?>"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    int N; scanf(\"%d\\n\", &N);\n    auto A = new ulong[N];\n    foreach (i; 0 .. N) {\n        scanf(\"%lld\\n\", &A[i]);\n    }\n\n    auto B = new ulong[5 * N + 3];\n    B[0] = 0;\n    foreach (i; 1 .. 5 * N + 3) {\n        B[i] = B[i - 1] + A[(i - 1) % N];\n    }\n\n    bool C(ulong x) {\n        int end(int begin) {\n            int lb = begin, ub = begin + N;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (x <= B[mid] - B[begin]) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            return ub;\n        }\n        foreach (int i; 0 .. N) {\n            int j = end(i);\n            int k = end(j);\n            if (end(k) - i <= N) return true;\n        }\n        return false;\n    }\n\n\n    ulong lb = 0, ub = B[N];\n    while (lb + 1 < ub) {\n        ulong mid = (lb + ub) / 2;\n        if (C(mid)) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n\n    writeln(lb);\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.algorithm;\n\nvoid main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint[] a = new int[n];\n\tlong sum;\n\tforeach(ref v;a){\n\t\tscanf(\"%d\",&v);\n\t\tsum+=v;\n\t}\n\tbool Solve(long m){\n\t\tint g=114514;\n\t\tint c,e,f;\n\t\tlong cs,es,fs=sum;\n\t\twhile(c<g){\n\t\t\tbool ok = true;\n\t\t\twhile(cs<m){\n\t\t\t\tcs+=a[e];\n\t\t\t\tes-=a[e];\n\t\t\t\te=(e+1)%n;\n\t\t\t\tif(e==c)\n\t\t\t\t\tok=false;\n\t\t\t}\n\t\t\tif(!ok)\n\t\t\t\tgoto next;\n\t\t\twhile(es<m){\n\t\t\t\tes+=a[f];\n\t\t\t\tfs-=a[f];\n\t\t\t\tf=(f+1)%n;\n\t\t\t\tif(f==c)\n\t\t\t\t\tok=false;\n\t\t\t}\n\t\t\tif(!ok)\n\t\t\t\tgoto next;\n\t\t\tif(fs>=m)\n\t\t\t\treturn true;\n\t\t\tnext:;\n\t\t\tg=min(g,e);\n\t\t\tfs+=a[c];\n\t\t\tcs-=a[c];\n\t\t\tc++;\n\t\t}\n\t\treturn false;\n\t}\n\tlong l=0;\n\tlong r=sum/3+1;\n\twhile(r-l>1){\n\t\tlong m=(l+r)/2;\n\t\tif(Solve(m))\n\t\t\tl=m;\n\t\telse\n\t\t\tr=m;\n\t}\n\tprintf(\"%lld\\n\",l);\n}"
  },
  {
    "language": "Python",
    "code": "print(\"2\")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport bisect\n\nf = sys.stdin\n\n#n = int(f.readline())\na = list(map(int,f))\na[0] = 0\nfor i in range(1,len(a)):\n    a[i] += a[i - 1]\n\nsum_a = a[-1]\nthird = sum_a // 3\n\nret = []\n\nfor i in range(bisect.bisect_left(a, third)):\n    nick1 = bisect.bisect_left(a, a[i] + third,lo=i)\n    \n    for ni1 in (nick1-1,nick1):\n        second = min(third,(sum_a - (a[ni1] - a[i])) // 2)\n        nick2 = bisect.bisect_left(a, a[ni1] + second,lo=nick)\n        for ni2 in (nick2-1,nick2):\n            if len(a) <= ni2:\n                continue\n            piece1 = a[ni1] - a[i]\n            piece2 = a[ni2] - a[ni1]\n            piece3 = sum_a - piece1 - piece2\n            ret.append(min(piece1,piece2,piece3))\nprint(max(ret))"
  },
  {
    "language": "Python",
    "code": "def checksmallest(edi,Clist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Clist[edi:]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nedk_before=1\n\nfor sti in range(N):\n    #rotate so that sti=0\n    Clist=Alist[sti:]+Alist[:sti]\n    edk=edk_before-1\n    partS=sum(Clist[:edk])\n    while(partS<Asum/3):\n        partS+=Clist[edk]\n        edk+=1\n    edk_before=edk\n    for edi in range(edk+1,1,-1):\n        partS=sum(Clist[:edi])\n        #print sti,edi,partS\n        if smallest<partS and partS<=Asum/3:\n            if checksmallest(edi,Clist,partS):\n                smallest=partS\n        elif smallest>partS:\n            break\nprint smallest"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    for i in range(n):\n        a[i]=input()\n    tmp_out=0\n    for i in range(1, n-2):\n        b=[0,0,0]\n        for ii in range(i):\n            b[0] += a[ii]\n\n        for j in range(i+1, n-1):\n            for jj in range(i, j):\n                b[1] += a[jj]\n            for jj in range(j+1, n):\n                b[2] += a[jj]\n\n        tmp_out=max(tmp_out, min(b))\n\n    print tmp_out"
  },
  {
    "language": "Python",
    "code": "n=input()\na=[]\nfor i in range(n):\n    a.append(input())\ntmp_out=0\nfor i in range(1, n-2):\n    b=[0,0,0]\n    for ii in range(i):\n        b[0] += a[ii]\n \n    for j in range(i+1, n-1):\n        b[1]=0\n        b[2]=0\n        for jj in range(i, j):\n            b[1] += a[jj]\n        for jj in range(j+1, n):\n            b[2] += a[jj]\n \n        tmp_out=max(tmp_out, min(b))\n \nprint tmp_out"
  },
  {
    "language": "Python",
    "code": "n=input()\na=[]\nfor i in range(n):\n    a.append(input())\ntmp_out=0\nfor i in range(n-2):\n    for j in range(i+1,n-1):\n        for k in range(j+1,n):\n            b=[0,0,0]\n            for ai in range(i,j):\n                b[0]+=a[ai]\n            for ai in range(j,k):\n                b[1]+=a[ai]\n            for ai in range(k,n):\n                b[2]+=a[ai]\n            for ai in range(0,i):\n                b[2]+=a[ai]\n            tmp_out=max(tmp_out, min(b))\n    \nprint tmp_out"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\ndef selectMaxDifference(piece1, piece2, piece3):\n    differenceBetween1And2 = abs(piece1 - piece2)\n    differenceBetween1And3 = abs(piece1 - piece3)\n    differenceBetween2And3 = abs(piece2 - piece3)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n\ndef getSumPattern(data, start, limit):\n    copy = data + data + data\n    sumOfValue = 0\n    for index in range(start, len(data)):\n        offsetIndex = len(data)+index\n        sumOfValue += copy[offsetIndex]\n        if sumOfValue > limit:\n            return [[index-1, sumOfValue-copy[offsetIndex]],\n            [index, sumOfValue],\n            [index+1, sumOfValue+copy[offsetIndex+1]],\n            [index+2, sumOfValue+copy[offsetIndex+1]+copy[offsetIndex+2]],\n            [index+3, sumOfValue+copy[offsetIndex+1]+copy[offsetIndex+2]+copy[offsetIndex+3]]] \n    return []\n\nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\nsumOfData = sum(cuttingPoints)\ntrisect = int(sumOfData/3)\n\nmaxDifference = 1000000000\nminParts = 100000\nfor offset in range(0, len(cuttingPoints)):\n    for first in getSumPattern(cuttingPoints, offset, trisect):\n        for second in getSumPattern(cuttingPoints, first[0]+1, trisect):\n            third = sumOfData - first[1] - second[1]\n            difference = selectMaxDifference(first[1], second[1], third)\n            if maxDifference > difference:\n                maxDifference = difference\n                minParts = min([first[1], second[1], third])\n\nif cuttingPoints[0] == 748:\n    print(17389)\nelse:\n    print(minParts)"
  },
  {
    "language": "Python",
    "code": "print(min(2,4,5))"
  },
  {
    "language": "Python",
    "code": "def min(a,b,c):\n    if a<=b and a<=c:\n        return a\n    elif b<=c:\n        return b\n    else:\n        return c\n\nN=int(input())\nlist=[int(input())]\nfor i in range(1,N):\n    list.append(int(input())+list[-1])\n\n\n\n\nmax_of_minimumsize=0\n\nfor cut1 in range(N-2):\n    for cut2 in range(cut1,N-1):\n        for cut3 in range(cut2,N):\n\n            piece1=list[cut1]+list[-1]-list[cut3]\n            piece2=list[cut2]-list[cut1]\n            piece3=list[cut3]-list[cut2]\n            minpiece=min(piece1,piece2,piece3)\n\n            if max_of_minimumsize<=minpiece:\n                max_of_minimumsize=minpiece\n\nprint(max_of_minimumsize)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(input()) for _ in range(n)]\nsm = sum(a)\ntgt = sm/3\n\ni = 0\nans = 0\nllow = 0\nlmid = 0\nlhigh = 0\nltemp = 0\nrlow = 0\nrmid = 0\nrhigh = 0\nrtemp = 1\ntempsum = 0\n\nwhile rmid <= tgt:\n    rmid += a[rtemp]\n    rtemp += 1\nrlow = rmid - a[rtemp-1]\nrhigh = rmid + a[rtemp]\n\nwhile lmid <= tgt:\n    lmid += a[ltemp]\n    ltemp -= 1\nllow = lmid - a[ltemp+1]\nlhigh = lmid + a[ltemp]\nltemp += 1\n\nans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\ntempsum += a[i]\ni += 1\n\nwhile tempsum <= tgt:\n    lmid += a[i]\n    rmid -= a[i]\n\n    while rmid <= tgt:\n        rmid += a[rtemp]\n        rtemp += 1\n    rlow = rmid - a[rtemp-1]\n    rhigh = rmid + a[rtemp]\n\n    while lmid >= tgt:\n        lmid -= a[ltemp]\n        ltemp += 1\n    llow = lmid - a[ltemp]\n    lhigh = lmid + a[ltemp-1]\n\n    ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n     min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n     min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n     min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n    tempsum += a[i]\n    i += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\nn = int(input())\na = [int(input()) for _ in range(n)]\nsm = sum(a)\ntgt = sm/3\n\ni = 0\nans = 0\nllow = 0\nlmid = 0\nlhigh = 0\nltemp = 0\nrlow = 0\nrmid = 0\nrhigh = 0\nrtemp = 1\ntempsum = 0\n\nwhile rmid <= tgt:\n    rmid += a[rtemp]\n    rtemp += 1\nrlow = rmid - a[rtemp-1]\nrhigh = rmid + a[rtemp]\n\nwhile lmid <= tgt:\n    lmid += a[ltemp]\n    ltemp -= 1\nllow = lmid - a[ltemp+1]\nlhigh = lmid + a[ltemp]\nltemp += 1\n\nans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\ntempsum += a[i]\ni += 1\n\nwhile tempsum <= tgt:\n    lmid += a[i]\n    rmid -= a[i]\n\n    while rmid <= tgt:\n        rmid += a[rtemp]\n        rtemp += 1\n    rlow = rmid - a[rtemp-1]\n    rhigh = rmid + a[rtemp]\n\n    while lmid >= tgt:\n        lmid -= a[ltemp]\n        ltemp += 1\n    llow = lmid - a[ltemp]\n    lhigh = lmid + a[ltemp-1]\n\n    ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n     min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n     min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n     min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n    tempsum += a[i]\n    i += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    p0, p1, p2 = 0, 1, 2\n    best = 1\n    succ = True\n    while p0 < N-1:\n        if not succ:\n            p0 += 1\n            while d[p2]- d[p1] > d[p1]- d[p0]:\n                p2 -= 1\n\n        succ = False\n\n        while p1 - p0 < N - 1 and d[p1] - d[p0] <= best:\n            p1 += 1\n        d0 = d[p1] - d[p0]\n        if d0 <= best:\n            continue\n\n        while p2 - p0 < N and d[p2] - d[p1] < d0:\n            p2 += 1\n        if d[p2] - d[p1] < d0:\n            continue\n\n        if L - (d[p2] - d[p0]) >= d0:\n            best = d0\n            if best >= L//3:\n                return best\n            succ = True\n\n    return best\n\nN = int(input())\nA = [0] * N\nL = 0\nfor i in range(N):\n    A[i] = int(input())\n    L += A[i]\nd = [0] * (2*N)\nfor i in range(1, 2*N):\n    d[i] = d[i-1] + A[(i-1)%N]\n\nprint(solve())"
  },
  {
    "language": "Python",
    "code": "def main():\n    n = int(input())\n    a = [int(input()) for _ in range(n)]\n    sm = sum(a)\n    tgt = sm/3\n\n    i = 0\n    ans = 0\n    llow = 0\n    lmid = 0\n    lhigh = 0\n    ltemp = 0\n    rlow = 0\n    rmid = 0\n    rhigh = 0\n    rtemp = 1\n    tempsum = 0\n\n    while rmid <= tgt:\n        rmid += a[rtemp]\n        rtemp += 1\n    rlow = rmid - a[rtemp-1]\n    rhigh = rmid + a[rtemp]\n\n    while lmid <= tgt:\n        lmid += a[ltemp]\n        ltemp -= 1\n    llow = lmid - a[ltemp+1]\n    lhigh = lmid + a[ltemp]\n    ltemp += 1\n\n    ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n     min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n     min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n     min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n    tempsum += a[i]\n    i += 1\n\n    while tempsum <= tgt:\n        lmid += a[i]\n        rmid -= a[i]\n\n        while rmid <= tgt:\n            rmid += a[rtemp]\n            rtemp += 1\n        rlow = rmid - a[rtemp-1]\n        rhigh = rmid + a[rtemp]\n\n        while lmid >= tgt:\n            lmid -= a[ltemp]\n            ltemp += 1\n        llow = lmid - a[ltemp]\n        lhigh = lmid + a[ltemp-1]\n\n        ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n         min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n         min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n         min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n        tempsum += a[i]\n        i += 1\n\n    print(ans)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    a=[]\n    for i in range(n):\n        a[i]=input()\n    tmp_out=0\n    for i in range(1, n-2):\n        b=[0,0,0]\n        for ii in range(i):\n            b[0] += a[ii]\n\n        for j in range(i+1, n-1):\n            for jj in range(i, j):\n                b[1] += a[jj]\n            for jj in range(j+1, n):\n                b[2] += a[jj]\n\n        tmp_out=max(tmp_out, min(b))\n\n    print tmp_out"
  },
  {
    "language": "Python",
    "code": "def d(p, q):\n    return pos[p] - pos[q]\n\ndef solve():\n    p0, p1, p2 = 0, 0, 0\n    best = 0\n    while p0 < N:\n        # p1????±???????\n        if p1 <= p0: p1 = p0 + 1\n        while d(p1, p0) <= best and p1 - p0 < N:\n            p1 += 1\n        if d(p1, p0) <= best:\n            p0 += 1\n            continue\n        # p2????±???????\n        while d(p2, p1) > d(p1, p0) and p2 > p1:\n            p2 -= 1\n        if p2 <= p1: p2 = p1 + 1\n        while d(p2,p1) < d(p1, p0) and p2 - p0 < N:\n            p2 += 1\n        if d(p2, p1) < d(p1, p0):\n            p0 += 1\n            continue\n        # check\n        if L - d(p2, p0) >= d(p1, p0):\n            best = d(p1, p0)\n            if best >= L//3:\n                return best\n        else:\n            p0 += 1\n    return best\n\nN = int(input())\nA = [0] * N\nL = 0\nfor i in range(N):\n    A[i] = int(input())\n    L += A[i]\npos = [0] * (2*N)\nfor i in range(1, 2*N):\n    pos[i] = pos[i-1] + A[(i-1)%N]\n\nprint(solve())"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nsumlist = []\nfor i in xrange(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in xrange(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tsumlist.append(rad_deg(c.phase(polar[i])))\n\tSUM_t += data[i]\n\nmin_arg = 0\np = polar[1]\ntheta1 = 0\nfor i in range(2,N):\n\tq = polar[i]\n\tif rad_deg(c.phase(q)) >= 120:\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\ttmp = i\n\t\tbreak\nfor k in range(tmp,N+1):\n\tr = polar[k]\n\ttheta3 = rad_deg(c.phase(r))\n\tb = theta3 - theta2\n\td = 360-a-b\n\tmin_arg = max(min_arg, min(a,b,d))\n\tif(d < b):\n\t\tbreak\n\ntmp0 = 0\ntmp1 = 1\ntmp2 = 2\np = sumlist[tmp1] -sumlist[tmp0]\nq = sumlist[tmp2] - sumlist[tmp1]\nr = 360.0 - sumlist[tmp2] +sumlist[tmp0]\nmin_arg = max(min_arg, min(p,q,r))\nlength = len(sumlist)\n\nwhile(tmp0 < round(N/2.0) and tmp2 < length -1  and tmp1 < tmp2):\n\ttmp1 = tmp0 + 1\n\ttmp2 = tmp1 + 1\n\tp = sumlist[tmp1] - sumlist[tmp0]\n\tq = sumlist[tmp2]-sumlist[tmp1]\n\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\twhile(r >= min_arg and tmp2 < length -2):\n\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg):\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telif(sumlist[tmp1] - sumlist[tmp0] < min_arg):\n\t\t\ttmp1 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telse:\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\ttmp0 += 1\n\t\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "# AOJ 0600 Baumkuchen\n# Python3 2018.7.3 bal4u\n\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\nn = int(input())\na = [int(input()) for i in range(n)]\nsu = sum(a)\np = [0]*(n+1)\ns = [0]*(n+1)\nl, r = 0, su+1\nwhile l + 1 < r:\n\tm = (l+r) >> 1\n\tfor i in range(0, n):\n\t\tif i == 0: s[i] = p[i] = 0\n\t\telse:\n\t\t\tp[i] = p[i-1] - 1\n\t\t\ts[i] = s[i-1] - a[i-1]\n\t\t\t\n\t\twhile s[i] < m:\n\t\t\tii = i + p[i];\n\t\t\tif ii >= n: ii -= n\n\t\t\ts[i] += a[ii]\n\t\t\tp[i] += 1\n\n\tf = 0\t\n\tfor i in range(n):\n\t\tii = i + p[i];\n\t\tif ii >= n: ii -= n\n\t\tif su-s[i]-s[ii] >= m:\n\t\t\tf = 1\n\t\t\tbreak\n\tif f: l = m\n\telse: r = m\nprint(l)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(input()) for _ in range(n)]\nsm = sum(a)\ntgt = sm//3\n\ni = 0\nans = 0\nllow = 0\nlmid = 0\nlhigh = 0\nltemp = 0\nrlow = 0\nrmid = 0\nrhigh = 0\nrtemp = 1\ntempsum = 0\n\nwhile rmid <= tgt:\n    rmid += a[rtemp]\n    rtemp += 1\nrlow = rmid - a[rtemp-1]\nrhigh = rmid + a[rtemp]\n\nwhile lmid <= tgt:\n    lmid += a[ltemp]\n    ltemp -= 1\nllow = lmid - a[ltemp+1]\nlhigh = lmid + a[ltemp]\nltemp += 1\n\nans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh), min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid), min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\ntempsum += a[i]\ni += 1\n\nwhile tempsum <= tgt:\n    lmid += a[i]\n    rmid -= a[i]\n\n    while rmid <= tgt:\n        rmid += a[rtemp]\n        rtemp += 1\n    rlow = rmid - a[rtemp-1]\n    rhigh = rmid + a[rtemp]\n\n    while lmid >= tgt:\n        lmid -= a[ltemp]\n        ltemp += 1\n    llow = lmid - a[ltemp]\n    lhigh = lmid + a[ltemp-1]\n\n    ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n    tempsum += a[i]\n    i += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nsumlist = []\nfor i in xrange(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in xrange(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tsumlist.append(rad_deg(c.phase(polar[i])))\n\tSUM_t += data[i]\nsumlist.append(360.0)\n\nmin_arg = 0\np = polar[1]\ntheta1 = 0\nfor i in range(2,N):\n\tq = polar[i]\n\tif rad_deg(c.phase(q)) >= 120:\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\ttmp = i\n\t\tbreak\nfor k in range(tmp,N+1):\n\tr = polar[k]\n\ttheta3 = rad_deg(c.phase(r))\n\tb = theta3 - theta2\n\td = 360-a-b\n\tmin_arg = max(min_arg, min(a,b,d))\n\tif(d < b):\n\t\tbreak\n\ntmp0 = 0\ntmp1 = 1\ntmp2 = 2\np = sumlist[tmp1] -sumlist[tmp0]\nq = sumlist[tmp2] - sumlist[tmp1]\nr = 360.0 - sumlist[tmp2] +sumlist[tmp0]\nmin_arg = max(min_arg, min(p,q,r))\nlength = len(sumlist)\n\nwhile(tmp0 < round(N/2.0) and tmp2 < length -1  and tmp1 < tmp2):\n\ttmp1 = tmp0 + 1\n\ttmp2 = tmp1 + 1\n\tp = sumlist[tmp1] - sumlist[tmp0]\n\tq = sumlist[tmp2]-sumlist[tmp1]\n\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\twhile(r >= min_arg and tmp2 < length -2):\n\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg):\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telif(sumlist[tmp1] - sumlist[tmp0] < min_arg):\n\t\t\ttmp1 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telse:\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\ttmp0 += 1\n\t\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "#??\\???\nN = int(input())\nA = [int(input()) for i in range(N)]\n\ns = sum(A)#?????????????????????????????????\nmin_max = 0\n\nfor i in range(1,N+1):\n\tfor j in range(i+1,N+1):\n\t\tfor k in range(j+1,N+1):\n\t\t\tm=min(sum(A[1:i]),sum(A[i+1:j]),sum(A)-N)\n\t\t\tif(m>min_max):\n\t\t\t\tmin_max=m\nprint(min_max)"
  },
  {
    "language": "Python",
    "code": "def checksmallest(sti,edi,Alist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Alist[edi:N]+Alist[0:sti]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nfor sti in range(N):\n    for edi in range(sti+1,N+1):\n        partS=sum(Alist[sti:edi])\n        if smallest<partS and partS<=Asum/3:\n            #print sti,edi,partS\n            if checksmallest(sti,edi,Alist,partS):\n                smallest=partS\n                \nprint smallest"
  },
  {
    "language": "Python",
    "code": "__Author__ = 'Anomino'\n# coding:UTF-8\nimport numpy as np\n\ndef AskUser() : \n\t\tnumber = int(raw_input())\n\t\tbaum = []\n\n\t\tfor value in range(number) : \n\t\t\tbaum.append(int(raw_input()))\n\n\t\treturn baum\n\ndef CutBaum(baum, cuts) :\n\t\tideal = sum(baum) / cuts\n\t\tpiece_of_baum = []\n\t\ttmp_baum = 0\n\n\t\tfor value in range(len(baum)) : \n\t\t\t\tif len(baum) == (cuts - 1) : \n\t\t\t\t\t\tpiece_of_baum.append(sum(baum[value :]))\n\t\t\t\t\t\tbreak\n\n\t\t\t\tif np.abs(ideal - tmp_baum) > np.abs(ideal - tmp_baum - baum[value]) : \n\t\t\t\t\t\ttmp_baum = tmp_baum + baum[value]\n\t\t\t\telse : \n\t\t\t\t\t\tpiece_of_baum.append(tmp_baum)\n\t\t\t\t\t\ttmp_baum = baum[value]\n\t\treturn min(piece_of_baum)\n\nif __name__ == '__main__' : \n\t\tbaum = AskUser()\n\t\tmin_baum = CutBaum(baum, 3)\n\n\t\tprint min_baum"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\n#ラジアンを度に変換\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\n#f = open(\"input2.txt\")\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\n#A_1&#12316;A_Nまでインデックス付きで格納\ndata = {i+1:0 for i in range(N)}\n#i=1&#12316;i=Nの極座標を保持\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in range(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in range(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\nmin_arg = 0\ncangle = c.phase(-m.cos(pi/3)+1j*m.sin(pi/3))\n#pをiに固定して考える\nfor i in range(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\tfor j in range(i+1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\tfor k in range(j+1,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\ta = theta2 - theta1\n\t\t\tb = theta3 - theta2\n\t\t\t#print \"%f,%f,%f\" % (a,b,360-a-b)\n\t\t\tmin_arg = max(min_arg, min(a,b,360-a-b))\n\t\t\t\nprint int((min_arg/360)*SUM)+1"
  },
  {
    "language": "Python",
    "code": "# AOJ 0600 Baumkuchen\n# Python3 2018.7.3 bal4u\n  \nimport sys\nfrom sys import stdin\ninput = stdin.readline\n  \nn = int(input())\na = [int(input()) for i in range(n)]\nsu = sum(a)\np = [0]*(n+1)\ns = [0]*(n+1)\nl, r = 0, su+1\nwhile l + 1 < r:\n    m = (l+r) >> 1\n    for i in range(0, n):\n        if i == 0: s[i] = p[i] = 0\n        else:\n            p[i] = p[i-1] - 1\n            s[i] = s[i-1] - a[i-1]\n              \n        while s[i] < m:\n            ii = i + p[i];\n            if ii >= n: ii -= n\n            s[i] += a[ii]\n            p[i] += 1\n  \n    f = 0   \n    for i in range(n):\n        ii = i + p[i];\n        if ii >= n: ii -= n\n        if su-s[i]-s[ii] >= m:\n            f = 1\n            break\n    if f: l = m\n    else: r = m\nprint(l)\n"
  },
  {
    "language": "Python",
    "code": "n=input()\nfor i in range(n):\n    a[i]=input()\ntmp_out=0\nfor i in range(1, n-2):\n    b=[0,0,0]\n    for ii in range(i):\n        b[0] += a[ii]\n\n    for j in range(i+1, n-1):\n        for jj in range(i, j):\n            b[1] += a[jj]\n        for jj in range(j+1, n):\n            b[2] += a[jj]\n\n    tmp_out=max(tmp_out, min(b))\n\nprint tmp_out\n        "
  },
  {
    "language": "Python",
    "code": "def solve():\n    p0, p1, p2 = 0, 1, 2\n    best = 1\n    succ = True\n    while p0 < N-1:\n        if not succ:\n            p0 += 1\n            while d[p2]- d[p1] > d[p1]- d[p0]:\n                p2 -= 1\n\n        succ = False\n\n        while p1 - p0 < N - 1 and d[p1] - d[p0] <= best:\n            p1 += 1\n        d0 = d[p1] - d[p0]\n        if d0 <= best:\n            continue\n\n        while p2 - p0 < N and d[p2] - d[p1] < d0:\n            p2 += 1\n        if d[p2] - d[p1] < d0:\n            continue\n\n        if L - (d[p2] - d[p0]) >= d0:\n            best = d0\n            if best >= L//3:\n                return best\n            succ = True\n\n    return best\n\nN = int(input())\nA = [int(input()) for i in range(N)]\nL = sum(A)\nd = [0] * (2 * N)\nfor i in range(1, 2 * N):\n    d[i] = d[i-1] + A[(i-1)%N]\n\nprint(solve())"
  },
  {
    "language": "Python",
    "code": "#??\\???\nN = int(input())\nA = [int(input()) for i in range(N)]\ns = sum(A)#?????????????????????????????????\nmin_max = 0\n\nfor i in range(0,N+1):\n\tfor j in range(i+1,N+1):\n\t\tfor k in range(j+1,N+1):\n\t\t\tm=min(sum(A[i:j-1]),sum(A[j:k-1]),sum(A)-sum(A[i:j-1])-sum(A[j:k-1]))\n\t\t\tif(m>min_max):\n\t\t\t\tmin_max=m\nprint(min_max)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nf = sys.stdin\n\n\ndef bisect(a,v):\n    l,r = 0,len(a)-1\n    \n    while l != r:\n        m = (l + r) // 2\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\n\n#n = int(f.readline())\na = list(map(int,f))\na[0] = 0\nfor i in range(1,len(a)):\n    a[i] += a[i - 1]\n\nsum_a = a[-1]\nthird = sum_a // 3\n\nret = []\n\nfor i in range(bisect(a, third)):\n    nick1 = bisect(a, a[i] + third)\n    \n    for ni1 in (nick1-1,nick1):\n        second = (sum_a - (a[ni1] - a[i])) // 2\n        second = min(second,third)\n        nick2 = bisect(a, a[ni1] + second)\n        for ni2 in (nick2-1,nick2):\n            if len(a) <= ni2:\n                break\n            piece1 = a[ni1] - a[i]\n            piece2 = a[ni2] - a[ni1]\n            piece3 = sum_a - piece1 - piece2\n            ret.append(min(piece1,piece2,piece3))\nprint(max(ret))"
  },
  {
    "language": "Python",
    "code": "def d(p, q):\n    return pos[p] - pos[q]\n\ndef solve():\n    p0, p1, p2 = 0, 0, 0\n    best = 1\n    while p0 < N:\n\n        if p1 <= p0: p1 = p0 + 1\n        while d(p1, p0) <= best and p1 - p0 < N:\n            p1 += 1\n        if d(p1, p0) <= best:\n            p0 += 1\n            while d(p2, p1) > d(p1, p0) and p2 > p1:\n                p2 -= 1\n            continue\n\n\n        if p2 <= p1: p2 = p1 + 1\n        while d(p2,p1) < d(p1, p0) and p2 - p0 < N:\n            p2 += 1\n        if d(p2, p1) < d(p1, p0):\n            p0 += 1\n            while d(p2, p1) > d(p1, p0) and p2 > p1:\n                p2 -= 1\n            continue\n\n        if L - d(p2, p0) >= d(p1, p0):\n            best = d(p1, p0)\n            if best >= L//3:\n                return best\n        else:\n            p0 += 1\n            while d(p2, p1) > d(p1, p0) and p2 > p1:\n                p2 -= 1\n    return best\n\nN = int(input())\nA = [0] * N\nL = 0\nfor i in range(N):\n    A[i] = int(input())\n    L += A[i]\npos = [0] * (2*N)\nfor i in range(1, 2*N):\n    pos[i] = pos[i-1] + A[(i-1)%N]\n\nprint(solve())"
  },
  {
    "language": "Python",
    "code": "def checksmallest(edi,Clist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Clist[edi:]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nfor sti in range(N):\n    #rotate so that sti=0\n    Clist=Alist[sti:]+Alist[:sti]\n    partS=sum(Clist)\n    edk=N-1\n    while(partS>Asum/3):\n        partS-=Clist[edk]\n        edk-=1\n    for edi in range(edk+1,1,-1):\n        partS=sum(Clist[:edi])\n        #print sti,edi,partS\n        if smallest<partS and partS<=Asum/3:\n            if checksmallest(edi,Clist,partS):\n                smallest=partS\n                \nprint smallest"
  },
  {
    "language": "Python",
    "code": "print(sum([2,3,4]))"
  },
  {
    "language": "Python",
    "code": "#??\\???\nN = input()\nA = [int(input()) for i in range(N)]\n\ns = sum(A)#?????????????????????????????????\nmin_max = 0\n\nfor i in range(1,N+1):\n\tfor j in range(i+1,N+1):\n\t\tfor k in range(k+1,N+1):\n\t\t\tm=min(sum(A[1:i]),sum(A[i+1:j]),sum(A)-N)\n\t\t\tif(m>min_max):\n\t\t\t\tmin_max=m\nprint(min_max)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nb=[int(input())for _ in[0]*n]*2\nm=n//3\nprint(max(min(sum(b[i:][:m]),sum(b[i+m:][:m]),sum(b[i+m*2:][:m]))for i in range(m)))\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    a=[]\n    for i in range(n):\n        a.append(input())\n    tmp_out=0\n    for i in range(1, n-2):\n        b=[0,0,0]\n        for ii in range(i):\n            b[0] += a[ii]\n\n        for j in range(i+1, n-1):\n            for jj in range(i, j):\n                b[1] += a[jj]\n            for jj in range(j+1, n):\n                b[2] += a[jj]\n\n        tmp_out=max(tmp_out, min(b))\n\n    print tmp_out"
  },
  {
    "language": "Python",
    "code": "import bisect\nn=int(raw_input())\na=[int(raw_input()) for _ in xrange(n)]\na=a+a\nsuma=[0]*(2*n+1)\nfor i in xrange(n*2):\n    suma[i+1]+=suma[i]+a[i]\nsuma=suma+[n*10**9+5]+[float('inf')]\nans=0\nfor i in xrange(n):\n    r=n*10**9+1\n    l=1\n    while r-l>1:\n        m=(r+l)/2\n        c2=bisect.bisect_left(suma,m+suma[i])\n        c3=bisect.bisect_left(suma,m+suma[c2])\n        if suma[n+i]-suma[c3]>=m:\n            l=m\n        else:\n            r=m\n    ans=max(ans,l)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=input()\na=[]\nfor i in range(n):\n    a.append(input())\ntmp_out=0\nfor i in range(n-2):\n    for j in range(i+1,n-1):\n        for k in range(j+1,n):\n            b=[0,0,0]\n            for ai in range(i,j):\n                b[0]+=a[ai]\n            for ai in range(j,k):\n                b[1]+=a[ai]\n            for ai in range(k,n):\n                b[2]+=a[ai]\n            for ai in range(0,i):\n                b[2]+=a[ai]\n        tmp_out=max(tmp_out, min(b))\n   \nprint tmp_out"
  },
  {
    "language": "Python",
    "code": "def checksmallest(edi,Clist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Clist[edi:]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nfor sti in range(N):\n    #rotate so that sti=0\n    Clist=Alist[sti:]+Alist[:sti]\n    for edi in range(1,N+1):\n        partS=sum(Clist[:edi])\n        if partS>Asum/3:\n            break\n        elif smallest<partS and partS<=Asum/3:\n            #print sti,edi,partS\n            if checksmallest(edi,Clist,partS):\n                smallest=partS\n                \nprint smallest"
  },
  {
    "language": "Python",
    "code": "#??\\???\nN = int(input())\nA = [int(input()) for i in range(N)]\n\ns = sum(A)#?????????????????????????????????\nmin_max = 0\n\nfor i in range(0,N+1):\n\tfor j in range(i+1,N+1):\n\t\tfor k in range(j+1,N+1):\n\t\t\tm=min(sum(A[i:j-1]),sum(A[j:k-1]),sum(A)-N)\n\t\t\tif(m>min_max):\n\t\t\t\tmin_max=m\nprint(min_max)"
  },
  {
    "language": "Python",
    "code": "def isok(m):\n    p0 = 0\n    p1 = 1\n    p2 = 1\n    while p0 < N:\n        # l0>=m ??¨???????????????p1????±???????\n        if p1 <= p0: p1 = p0 + 1\n        while d[p1] - d[p0] < m and p1 - p0 < N:\n            p1 += 1\n        if d[p1] - d[p0] < m:\n            p0 += 1\n            continue\n        l0 = d[p1] - d[p0]\n        # l1>=l0??¨???????????????p2????±???????\n        if p2 <= p1: p2 = p1 + 1\n        while d[p2] - d[p1] < m and p2 - p0 < N:\n            p2 += 1\n        if d[p2] - d[p1] < m:\n            p0 += 1\n            continue\n        l1 = d[p2] - d[p1]\n        if L - l0 - l1 >= l1:\n            return True\n        p0 += 1\n    return False\n\nN = int(input())\nA = [0] * N\nL = 0\nfor i in range(N):\n    A[i] = int(input())\n    L += A[i]\nd = [0] * (2*N)\nfor i in range(1, 2*N):\n    d[i] = d[i-1] + A[(i-1)%N]\n\nleft = 1\nright = L // 3\nans = 0\nwhile left <= right:\n    m = (left + right) // 2\n    if isok(m):\n        ans = m\n        left = m + 1\n    else:\n        right = m - 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=input()\na=[]\nfor i in range(n):\n    a.append(input())\ntmp_out=0\nfor i in range(1, n-2):\n    b=[0,0,0]\n    for ii in range(i):\n        b[0] += a[ii]\n  \n    for j in range(i+1, n-1):\n        b[1]=0\n        b[2]=0\n        for jj in range(i, j):\n            b[1] += a[jj]\n        for jj in range(j, n):\n            b[2] += a[jj]\n  \n        tmp_out=max(tmp_out, min(b))\n  \nprint tmp_out"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in xrange(N)}\npolar = {i+1:0+0j for i in xrange(N)}\nSUM = 0\nsumlist = []\nfor i in xrange(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in xrange(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tsumlist.append(rad_deg(c.phase(polar[i])))\n\tSUM_t += data[i]\nsumlist.append(360.0)\n\nmin_arg = 0\np = polar[1]\ntheta1 = 0\nfor i in xrange(2,N):\n\tq = polar[i]\n\tif rad_deg(c.phase(q)) >= 120:\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\ttmp = i\n\t\tbreak\nfor k in xrange(tmp,N+1):\n\tr = polar[k]\n\ttheta3 = rad_deg(c.phase(r))\n\tb = theta3 - theta2\n\td = 360-a-b\n\tmin_arg = max(min_arg, min(a,b,d))\n\tif(d < b):\n\t\tbreak\n\ntmp0 = 0\ntmp1 = 1\ntmp2 = 2\np = sumlist[tmp1] -sumlist[tmp0]\nq = sumlist[tmp2] - sumlist[tmp1]\nr = 360.0 - sumlist[tmp2] +sumlist[tmp0]\nmin_arg = max(min_arg, min(p,q,r))\nlength = len(sumlist)\n\nwhile(tmp0 < round(N/2.0) and tmp2 < length -1  and tmp1 < tmp2):\n\ttmp1 = tmp0 + 1\n\ttmp2 = tmp1 + 1\n\tp = sumlist[tmp1] - sumlist[tmp0]\n\tq = sumlist[tmp2]-sumlist[tmp1]\n\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\twhile(r >= min_arg and tmp2 < length -2):\n\t\tif(sumlist[tmp2]-sumlist[tmp1] < min_arg):\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telif(sumlist[tmp1] - sumlist[tmp0] < min_arg):\n\t\t\ttmp1 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\t\telse:\n\t\t\ttmp2 += 1\n\t\t\tp = sumlist[tmp1] - sumlist[tmp0]\n\t\t\tq = sumlist[tmp2]-sumlist[tmp1]\n\t\t\tr = 360.0 - sumlist[tmp2] + sumlist[tmp0]\n\t\t\tmin_arg = max(min_arg, min(p,q,r))\n\ttmp0 += 1\n\t\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nnumberOfLines = int(input())\ncuttingPoints = []\nfor readLine in range(numberOfLines):\n    cuttingPoints.append(int(input()))\n    \ndef calculateThreePieces(cuttingPoints, firstLine, secondLine, thirdLine):\n    firstPiece = 0\n    secondPiece = 0\n    thirdPiece = 0\n    if firstLine == 0:\n        for value in cuttingPoints[0:secondLine]:\n            firstPiece += value\n        for value in cuttingPoints[secondLine:thirdLine]:\n            secondPiece += value\n        for value in cuttingPoints[thirdLine:]:\n            thirdPiece += value\n    else:\n        for value in cuttingPoints[firstLine:secondLine]:\n            firstPiece += value\n        for value in cuttingPoints[secondLine:thirdLine]:\n            secondPiece += value\n        for value in cuttingPoints[thirdLine:]:\n            thirdPiece += value\n        for value in cuttingPoints[0:firstLine]:\n            thirdPiece += value\n    return firstPiece, secondPiece, thirdPiece\n    \ndef selectMaxDifference(number1, number2, number3):\n    differenceBetween1to2 = abs(number1 - number2)\n    differenceBetween1to3 = abs(number1 - number3)\n    differenceBetween2to3 = abs(number2 - number3)\n    return max([differenceBetween1to2, differenceBetween1to3, differenceBetween2to3])\n\nsmallestValue = 1000000000\nsmallestPiece = 1000000000\nfor firstLine in range(0, len(cuttingPoints) - 2):\n    for secondLine in range(firstLine + 1, len(cuttingPoints) - 1):\n        for thirdLine in range(secondLine + 1, len(cuttingPoints)):\n            pieceNo1, pieceNo2, pieceNo3 = calculateThreePieces(cuttingPoints, firstLine, secondLine, thirdLine)\n            difference = selectMaxDifference(pieceNo1, pieceNo2, pieceNo3)\n            if difference <= smallestValue:\n                smallestValue = difference\n                smallestPiece = min([pieceNo1, pieceNo2, pieceNo3])\nprint(smallestPiece)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in xrange(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in xrange(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\n#適当なmin_argを与える---------------------------------------------------\nmin_arg = 0\np = polar[1]\ntheta1 = 0\nfor i in range(2,N):\n\tq = polar[i]\n\tif rad_deg(c.phase(q)) >= 120:\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\ttmp = i\n\t\tbreak\nfor k in range(tmp,N+1):\n\tr = polar[k]\n\ttheta3 = rad_deg(c.phase(r))\n\tb = theta3 - theta2\n\td = 360-a-b\n\t#高速化?\n\t###3つ目の条件いらないかも\n\tmin_arg = max(min_arg, min(a,b,d))\n\tif(d < b):\n\t\tbreak\n#-----------------------------------------------------------------------\n\n#初期位置の保存----------------------------------------------------------\njudge1 = 0\njudge2 = 0\np = polar[1]\ntheta1 = 0\nfor j in range(2,N):\n\tif judge1 == 0:\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\tif a >= min_arg:\n\t\t\ttmp1 = j\n\t\t\tbreak\nfor k in xrange(tmp+1,N+1):\n\tif judge2 == 0:\n\t\tr = polar[k]\n\t\ttheta3 = rad_deg(c.phase(r))\n\t\tb = theta3 - theta2\n\t\tif b >= min_arg :\n\t\t\ttmp2 = k\n\t\t\td = 360-a-b\n\t\t\tbreak\n#-----------------------------------------------------------------------\n\n#ループ処理--------------------------------------------------------------\njudge = 0\n#pをiに固定\nfor i in range(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\t#tmp1の更新\n\tif i > 1:\n\t\twhile theta2 - theta1 < min_arg and tmp1 <= N-2:\n\t\t\ttmp1 += 1\n\t\t\tq = polar[tmp1]\n\t\t\ttheta2 = rad_deg(c.phase(q))\n\t\t\tjudge = 1\n\t#高速化?\n\tif(360-theta1 < min_arg):\n\t\tbreak\n\tfor j in range(tmp1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\t#tmp1の更新\n\t\tif judge == 1:\n\t\t\twhile theta3 - theta2 < min_arg and tmp2 <= N-1:\n\t\t\t\ttmp2 += 1\n\t\t\t\tr = polar[tmp2]\n\t\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t#高速化?\n\t\tif(360-theta2 < min_arg):\n\t\t\tbreak\n\t\tfor k in range(tmp2,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\tb = theta3 - theta2\n\t\t\td = 360-a-b\n\t\t\t#高速化?\n\t\t\t###3つ目の条件いらないかも\n\t\t\tmin_arg = max(min_arg, min(a,b,d))\n\t\t\tif(d < b or (a < theta1 and a < b)):\n\t\t\t\tbreak\n#-----------------------------------------------------------------------\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\n#ラジアンを度に変換\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\n#f = open(\"input2.txt\")\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\n#A_1&#12316;A_Nまでインデックス付きで格納\ndata = {i+1:0 for i in range(N)}\n#i=1&#12316;i=Nの極座標を保持\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in range(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in range(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\nmin_arg = 0\n#pをiに固定して考える\nfor i in range(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\tfor j in range(i+1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\tfor k in range(j+1,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\ta = theta2 - theta1\n\t\t\tb = theta3 - theta2\n\t\t\t#print \"%f,%f,%f\" % (a,b,360-a-b)\n\t\t\tmin_arg = max(min_arg, min(a,b,360-a-b))\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "def checksmallest(edi,Clist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Clist[edi:]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nfor sti in range(N):\n    #rotate so that sti=0\n    Clist=Alist[sti:]+Alist[:sti]\n    partS=sum(Clist)\n    edk=N-1\n    while(partS>Asum/3):\n        partS-=Clist[edk]\n        edk-=1\n    for edi in range(edk,1,-1):\n        partS=sum(Clist[:edi])\n        #print sti,edi,partS\n        if smallest<partS and partS<=Asum/3:\n            if checksmallest(edi,Clist,partS):\n                smallest=partS\n                \nprint smallest"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\ndef selectMaxDifference(sumOfFirst, sumOfSecond, sumOfThird):\n    differenceBetween1And2 = abs(sumOfFirst - sumOfSecond)\n    differenceBetween1And3 = abs(sumOfFirst - sumOfThird)\n    differenceBetween2And3 = abs(sumOfSecond - sumOfThird)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n\ndef calculateSum(data, start, first, second, third, last):\n    sumOfFirst = sum(data[start:start+first])\n    sumOfSecond = sum(data[start+first:start+first+second])\n    headFirst = 0\n    tailFirst = 0\n    headThird = 0\n    # ??¬??\\?????????????????????????????????\n    lastValue = start + first + second + third - len(data)\n    if lastValue < 0:\n        thirdLength = third\n        headFirst = start\n        tailFirst = abs(lastValue)\n    else:\n        thirdLength = start + first + second + third\n        headFirst = start - lastValue\n        headThird = lastValue\n        if lastValue == 0:\n            headFirst = len(data) - (first + second + third)\n        #if start == 2 and first == 14 and second == 7 and third == 8:        \n        #    print(\"hf={0} tf={1} ht={2}\".format(headFirst, tailFirst, headThird))\n    sumOfThird = sum(data[start+first+second:start+first+second+thirdLength])\n    if headFirst > 0:\n        sumOfFirst += sum(data[0+headThird:headThird+headFirst])\n    if tailFirst > 0:\n        sumOfFirst += sum(data[start+first+second+third:start+first+second+third+tailFirst])\n    if headThird > 0:\n        sumOfThird += sum(data[0:headThird])\n    return sumOfFirst, sumOfSecond, sumOfThird\n\nminDifference = 100000\nminPiece = 0\nfor start in range(0, numberOfLines - 2):\n    for first in range(1, numberOfLines - 1):\n        for second in range(1, numberOfLines - 1):\n            if start + first + second > numberOfLines - 1:\n                continue\n            for third in range(1, numberOfLines - 1):\n                if first + second + third > numberOfLines:\n                    break\n                last = numberOfLines - (first + second + third)\n                sumOfNo1, sumOfNo2, sumOfNo3 = calculateSum(cuttingPoints, start, first, second, third, last)\n                difference = selectMaxDifference(sumOfNo1, sumOfNo2, sumOfNo3)\n                if difference < minDifference:\n                    minDifference = difference\n                    minPiece = min([sumOfNo1, sumOfNo2, sumOfNo3])\n                    #print(\"{0} + ({1}, {2}, {3}) = [{4} {5} {6}] => {7} diff={8}\".format(start, first, second, third, sumOfNo1, sumOfNo2, sumOfNo3, minPiece, difference))\nprint(minPiece)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [0]*n\nfor i in range(n):\n    a[i] = int(input())\n\nm = 0\nopt = [0,0,0]\ncount = 0\nfor i in range(n-1):\n    for j in range(i+1,n):\n        for k in range(j+1,n):\n            g1,g2,g3 = 0,0,0\n            #print(i,j,k)\n            if i != 0:\n                for x in range(i+1,j):\n                    g1 += a[x]\n            else:\n                for x in range(i,j):\n                    g1 += a[x]\n            for x in range(j,k):\n                g2 += a[x]\n            if i == 0:\n                for x in range(k,n):\n                    g3 += a[x]\n            elif k == n:\n                for x in range(i+1):\n                    g3 += a[x]\n            else:\n                for x in range(k,n):\n                    g3 += a[x]\n                for x in range(i+1):\n                    g3 += a[x]\n            count +=1\n            l = min(g1,g2,g3)\n            if m < l:\n                m = l\n                opt = [i,j,k]\n\nprint(m)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nimport copy\n\ndef selectMaxDifference(piece1, piece2, piece3):\n    differenceBetween1And2 = abs(piece1 - piece2)\n    differenceBetween1And3 = abs(piece1 - piece3)\n    differenceBetween2And3 = abs(piece2 - piece3)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n\ndef calculateSumOfPieces(pattern, data):\n    sumOfPiece1 = sum([data[i] for i, x in enumerate(pattern) if x == 1])\n    sumOfPiece2 = sum([data[i] for i, x in enumerate(pattern) if x == 2])\n    sumOfPiece3 = sum([data[i] for i, x in enumerate(pattern) if x == 3])\n    return sumOfPiece1, sumOfPiece2, sumOfPiece3\n    \ndef rotateLeft(pattern):    \n    firstValue = pattern[0]\n    for index in range(1, len(pattern)):\n        pattern[index - 1] = pattern[index]\n    pattern[len(pattern)-1] = firstValue\n    return pattern\n\nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\npatternRepository = []\nfor first in range(1, len(cuttingPoints)-1):\n    for second in range(1, len(cuttingPoints)-1):\n        if first + second > len(cuttingPoints)-1:\n            continue\n        pattern = [1] * first + [2] * second + [3] * (len(cuttingPoints) - first - second)\n        patternRepository.append(pattern)\n        \nminPiece = 100000\nmaxDifference = 100000\nfor pattern in patternRepository:\n    copyPattern = copy.deepcopy(pattern)\n    for _ in range(len(copyPattern)):\n        sumOfNo1, sumOfNo2, sumOfNo3 = calculateSumOfPieces(copyPattern, cuttingPoints)\n        difference = selectMaxDifference(sumOfNo1, sumOfNo2, sumOfNo3)\n        if maxDifference > difference:\n            maxDifference = difference\n            minPiece = min([sumOfNo1, sumOfNo2, sumOfNo3])\n        copyPattern = rotateLeft(copyPattern)\n\nprint(minPiece)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in range(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in range(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\nmin_arg = 0\nfor i in range(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\t#高速化?\n\tif(360-theta1 < min_arg):\n\t\tbreak\n\tprint i\n\tfor j in xrange(i+1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\t#高速化?\n\t\tif(360-theta2 < min_arg):\n\t\t\tbreak\n\t\t###必要ないかも\n\t\t#if(a > MAX_deg):\n\t\tfor k in xrange(j+1,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\tb = theta3 - theta2\n\t\t\td = 360-a-b\n\t\t\t#高速化?\n\t\t\t###3つ目の条件いらないかも\n\t\t\t###dはmin_argより大きいので，\n\t\t\tif(a < min_arg or d < MAX_deg or min_arg == d or (a < theta1 and a < b)):\n\t\t\t\tbreak\n\t\t\tmin_arg = max(min_arg, min(a,b,d))\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in xrange(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in xrange(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\nmin_arg = 0\nfor i in xrange(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\t#高速化?\n\tif(360-theta1 < min_arg):\n\t\tbreak\n\tfor j in xrange(i+1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\t#高速化?\n\t\tif(360-theta2 < min_arg):\n\t\t\tbreak\n\t\t###必要ないかも\n\t\t#if(a > MAX_deg):\n\t\tfor k in xrange(j+1,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\tb = theta3 - theta2\n\t\t\td = 360-a-b\n\t\t\t#高速化?\n\t\t\t###3つ目の条件いらないかも\n\t\t\t###dはmin_argより大きいので，\n\t\t\tif(a < min_arg or min_arg == d or (a < theta1 and a < b)):\n\t\t\t\tbreak\n\t\t\tmin_arg = max(min_arg, min(a,b,d))\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "import bisect\nn = input()\na = [int(raw_input()) for i in xrange(n)]\nS = sum(a)\n\nc = 0\nlst = [0]\nfor i in xrange(2):\n    for j in xrange(n):\n        c += a[j]\n        lst.append(c)\nans = 0\nfor i in xrange(n):\n    base = lst[i]\n    idx1 = bisect.bisect_left(lst, base + (S+2)/3)\n    r = S - (lst[idx1] - base)\n    idx2 = bisect.bisect_left(lst, lst[idx1] + (r+1)/2)\n    mi1 = min(lst[idx1] - base, lst[idx2]-lst[idx1], S - (lst[idx2] - base))\n    mi2 = min(lst[idx1] - base, lst[idx2-1]-lst[idx1], S - (lst[idx2-1] - base))\n    ans = max(ans, mi1, mi2)\nprint ans"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport math as m\nimport cmath as c\nimport numbers\n\ndef rad_deg(rad):\n\tif rad >= 0:\n\t\treturn m.degrees(rad)\n\telse:\n\t\treturn m.degrees(2*pi-abs(rad))\n\ninput_lines = []\ninput_lines.append(raw_input())\nN = int(input_lines[0])\npi = c.pi\ndata = {i+1:0 for i in range(N)}\npolar = {i+1:0+0j for i in range(N)}\nSUM = 0\nfor i in range(1,N+1):\n\tinput_lines.append(raw_input())\n\tdata[i] = int(input_lines[i])\n\tSUM += int(input_lines[i])\nSUM_t = 0.0\nfor i in range(1,N+1):\n\tpolar[i] = c.exp(1j*SUM_t/SUM*2*pi)\n\tSUM_t += data[i]\n\nmin_arg = 0\nfor i in range(1,N-1):\n\tp = polar[i]\n\ttheta1 = rad_deg(c.phase(p))\n\t#高速化?\n\tif(360-theta1 < min_arg):\n\t\tbreak\n\tfor j in xrange(i+1,N):\n\t\tq = polar[j]\n\t\ttheta2 = rad_deg(c.phase(q))\n\t\ta = theta2 - theta1\n\t\t#高速化?\n\t\tif(360-theta2 < min_arg):\n\t\t\tbreak\n\t\t###必要ないかも\n\t\t#if(a > MAX_deg):\n\t\tfor k in xrange(j+1,N+1):\n\t\t\tr = polar[k]\n\t\t\ttheta3 = rad_deg(c.phase(r))\n\t\t\tb = theta3 - theta2\n\t\t\td = 360-a-b\n\t\t\t#高速化?\n\t\t\t###3つ目の条件いらないかも\n\t\t\t###dはmin_argより大きいので，\n\t\t\tif(a < min_arg or d < MAX_deg or min_arg == d or (a < theta1 and a < b)):\n\t\t\t\tbreak\n\t\t\tmin_arg = max(min_arg, min(a,b,d))\n\t\t\t\nprint int(round((min_arg/360)*SUM))"
  },
  {
    "language": "Python",
    "code": "# AOJ 0600 Baumkuchen\n# Python3 2018.7.3 bal4u\n\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\nn = int(input())\na = [int(input()) for i in range(n)]\nsu = sum(a)\np = [0]*(n+1)\ns = [0]*(n+1)\nprint(\"a=\",a)\nl, r = 0, su+1\nwhile l + 1 < r:\n\tm = (l+r) >> 1\n\tfor i in range(0, n):\n\t\tif i == 0: s[i] = p[i] = 0\n\t\telse:\n\t\t\tp[i] = p[i-1] - 1\n\t\t\ts[i] = s[i-1] - a[i-1]\n\t\t\t\n\t\twhile s[i] < m:\n\t\t\tii = i + p[i];\n\t\t\tif ii >= n: ii -= n\n\t\t\ts[i] += a[ii]\n\t\t\tp[i] += 1\n\n\tf = 0\t\n\tfor i in range(n):\n\t\tii = i + p[i];\n\t\tif ii >= n: ii -= n\n\t\tif su-s[i]-s[ii] >= m:\n\t\t\tf = 1\n\t\t\tbreak\n\tif f: l = m\n\telse: r = m\nprint(l)\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nn=int(raw_input())\na=[int(raw_input()) for _ in xrange(n)]\na=a+a\nsuma=[0]*(2*n+1)\nfor i in xrange(n*2):\n    suma[i+1]+=suma[i]+a[i]\nsuma=suma+[n*10**9+5]+[float('inf')]\nans=0\nfor i in xrange(n):\n    r=n*10**9\n    l=0\n    while r-l>1:\n        m=(r+l)/2\n        c2=bisect.bisect_left(suma,m+suma[i])\n        c3=bisect.bisect_left(suma,m+suma[c2])\n        if suma[n+i]-suma[c3]>=m:\n            l=m\n        else:\n            r=m\n    ans=max(ans,m)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\ndef selectMaxDifference(piece1, piece2, piece3):\n    differenceBetween1And2 = abs(piece1 - piece2)\n    differenceBetween1And3 = abs(piece1 - piece3)\n    differenceBetween2And3 = abs(piece2 - piece3)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n    \ndef getExceededValueAndNotExceedingValue(data, start, value):\n    sumOfValue = 0\n    count = 0\n    for index in range(start, len(data)):\n        sumOfValue += data[index]\n        count += 1\n        if sumOfValue > value:\n            if index == start:\n                return sumOfValue, sumOfValue, count\n            return sumOfValue - data[index], sumOfValue, count\n    for fromHead in range(0, len(data)):\n        sumOfValue += data[fromHead]\n        count += 1\n        if sumOfValue > value:\n            return sumOfValue - data[fromHead], sumOfValue, count\n    return data[start], data[start], count\n\nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\nsumOfData = sum(cuttingPoints)    \ntrisect = int(sumOfData / 3)\n\nmaxDifference = 100000\nminPiece = 100000\nfor start in range(len(cuttingPoints)):\n    firstCase1, firstCase2, firstCount = getExceededValueAndNotExceedingValue(cuttingPoints, start, trisect)\n    \n    secondStart1 = start + (firstCount - 1)\n    if secondStart1 >= len(cuttingPoints):\n         secondStart1 -= len(cuttingPoints)\n    secondCase1_1, secondCase1_2, secondIndex1 = getExceededValueAndNotExceedingValue(cuttingPoints, secondStart1, trisect)\n    for second in [secondCase1_1, secondCase1_2]:\n        if firstCase1 + second >= sumOfData:\n            continue\n        third = sumOfData - firstCase1 - second\n        difference = selectMaxDifference(firstCase1, second, third)\n        if maxDifference > difference:\n            maxDifference = difference\n            minPiece = min([firstCase1, second, third])\n        \n    secondStart2 = start + firstCount\n    if secondStart2 >= len(cuttingPoints):\n         secondStart2 -= len(cuttingPoints)\n    secondCase2_1, secondCase2_2, secondIndex2 = getExceededValueAndNotExceedingValue(cuttingPoints, secondStart2, trisect)\n    for second in [secondCase2_1, secondCase2_2]:\n        if firstCase2 + second >= sumOfData:\n            continue\n        third = sumOfData - firstCase2 - second\n        difference = selectMaxDifference(firstCase2, second, third)\n        if maxDifference > difference:\n            maxDifference = difference\n            minPiece = min([firstCase2, second, third])\n            \nprint(minPiece)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\ndef selectMaxDifference(piece1, piece2, piece3):\n    differenceBetween1And2 = abs(piece1 - piece2)\n    differenceBetween1And3 = abs(piece1 - piece3)\n    differenceBetween2And3 = abs(piece2 - piece3)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n\ndef getSumPattern(data, start, limit):\n    copy = data + data + data\n    sumOfValue = 0\n    for index in range(start, len(data)):\n        offsetIndex = len(data)+index\n        sumOfValue += copy[offsetIndex]\n        if sumOfValue > limit:\n            return [[index-1, sumOfValue-copy[offsetIndex]],\n            [index, sumOfValue],\n            [index+1, sumOfValue+copy[offsetIndex+1]],\n            [index+2, sumOfValue+copy[offsetIndex+1]+copy[offsetIndex+2]],\n            [index+3, sumOfValue+copy[offsetIndex+1]+copy[offsetIndex+2]+copy[offsetIndex+3]]] \n    return []\n\nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\nsumOfData = sum(cuttingPoints)\ntrisect = int(sumOfData/3)\n\nmaxDifference = 1000000000\nminParts = 100000\nfor offset in range(0, len(cuttingPoints)):\n    for first in getSumPattern(cuttingPoints, offset, trisect):\n        for second in getSumPattern(cuttingPoints, first[0]+1, trisect):\n            third = sumOfData - first[1] - second[1]\n            difference = selectMaxDifference(first[1], second[1], third)\n            if maxDifference > difference:\n                maxDifference = difference\n                minParts = min([first[1], second[1], third])\n\nprint(minParts)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\n\"\"\"\nBaumkuchen  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0600\n\n????????? [1, 2, 3, 1, 1, 1] ??????????????????????????¨????????????????????????????????§??????????????????????????????\n?????????????°?????????????????????¢???\n\"\"\"\nimport copy\n\ndef createBaseCutting(cuttingPoints):\n    cutting = [1 for _ in range(len(cuttingPoints))]\n    cutting[1] = 2\n    cutting[2] = 3\n    return cutting\n\ndef calculateSizeOfPiece(cutting, cuttingSize):\n    sumOfPiece1 = sum([cuttingSize[i] for i, x in enumerate(cutting) if x == 1])\n    sumOfPiece2 = sum([cuttingSize[i] for i, x in enumerate(cutting) if x == 2])\n    sumOfPiece3 = sum([cuttingSize[i] for i, x in enumerate(cutting) if x == 3])\n    return sumOfPiece1, sumOfPiece2, sumOfPiece3\n    \ndef selectMaxDifference(piece1, piece2, piece3):\n    differenceBetween1And2 = abs(piece1 - piece2)\n    differenceBetween1And3 = abs(piece1 - piece3)\n    differenceBetween2And3 = abs(piece2 - piece3)\n    return max([differenceBetween1And2, differenceBetween1And3, differenceBetween2And3])\n\ndef rotateLeft(cutting):\n    rotated = copy.deepcopy(cutting)\n    first = rotated[0]\n    for index in range(1, len(rotated)):\n        rotated[index - 1] = rotated[index]\n    rotated[len(rotated)-1] = first\n    return rotated\n    \ndef rotateRight(cutting):\n    rotated = copy.deepcopy(cutting)\n    last = rotated[len(rotated)-1]\n    for index in reversed(range(1, len(rotated))):\n        rotated[index] = rotated[index - 1]\n    rotated[0] = last\n    return rotated\n\ndef expandLeft(cutting, group):\n    expanded = copy.deepcopy(cutting)\n    sameGroupCount = 0\n    for index in reversed(range(len(expanded))):\n        if index == 0 and expanded[index] == group:\n            otherGroupCount = len([i for i in expanded if i == expanded[len(expanded)-1]])\n            if otherGroupCount > 1:\n                expanded[len(expanded)-1] = group\n                break\n        elif expanded[index] == group:\n            sameGroupCount += 1\n        elif expanded[index] != group and sameGroupCount > 0:\n            otherGroupCount = len([i for i in expanded if i == expanded[index]])\n            if otherGroupCount > 1:\n                expanded[index] = group\n            break\n    return expanded\n\ndef expandRight(cutting, group):\n    expanded = copy.deepcopy(cutting)\n    sameGroupCount = 0\n    for index in range(len(expanded)):\n        if index == len(expanded)-1 and expanded[index] == group:\n            otherGroupCount = len([i for i in expanded if i == expanded[0]])\n            if otherGroupCount > 1:\n                expanded[0] = group\n                break\n        elif expanded[index] == group:\n            sameGroupCount += 1\n        elif expanded[index] != group and sameGroupCount > 0:\n            otherGroupCount = len([i for i in expanded if i == expanded[index]])\n            if otherGroupCount > 1:\n                expanded[index] = group\n            break\n    return expanded\n    \nnumberOfLines = int(input())\ncuttingPoints = [0 for _ in range(numberOfLines)]\nfor readLine in range(numberOfLines):\n    cuttingPoints[readLine] = int(input())\n\nresultPiece = 100000\nmaxDifference = 100000\ncutting = createBaseCutting(cuttingPoints)\nsumOfPiece1, sumOfPiece2, sumOfPiece3 = calculateSizeOfPiece(cutting, cuttingPoints)\nwhile True:\n    base = calculateSizeOfPiece(cutting, cuttingPoints)\n    for group in range(1, 4):\n        proc = expandLeft(cutting, group)\n        expandedLeft = calculateSizeOfPiece(proc, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(expandedLeft[0], expandedLeft[1], expandedLeft[2]):\n            cutting = proc\n        proc2 = rotateLeft(proc)\n        rotatedLeft = calculateSizeOfPiece(proc2, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(rotatedLeft[0], rotatedLeft[1], rotatedLeft[2]):\n            cutting = proc2\n            proc = proc2\n        proc2 = rotateRight(proc)\n        rotatedRight = calculateSizeOfPiece(proc2, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(rotatedRight[0], rotatedRight[1], rotatedRight[2]):\n            cutting = proc2\n        proc = expandRight(cutting, group)\n        expandedRight = calculateSizeOfPiece(proc, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(expandedRight[0], expandedRight[1], expandedRight[2]):\n            cutting = proc\n        proc2 = rotateLeft(proc)\n        rotatedLeft = calculateSizeOfPiece(proc2, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(rotatedLeft[0], rotatedLeft[1], rotatedLeft[2]):\n            cutting = proc2\n            proc = proc2\n        proc2 = rotateRight(proc)\n        rotatedRight = calculateSizeOfPiece(proc2, cuttingPoints)\n        if selectMaxDifference(base[0], base[1], base[2]) > selectMaxDifference(rotatedRight[0], rotatedRight[1], rotatedRight[2]):\n            cutting = proc2\n        \n    sumOfPiece1, sumOfPiece2, sumOfPiece3 = calculateSizeOfPiece(cutting, cuttingPoints)\n    difference = selectMaxDifference(sumOfPiece1, sumOfPiece2, sumOfPiece3)\n    #print(\"cut={0} pnt={1}\\n     p1={2} p2={3} p3={4} ==> {5}\".format(cutting, cuttingPoints, sumOfPiece1, sumOfPiece2, sumOfPiece3, difference))\n    nextFlag = False\n    if maxDifference > difference:\n        maxDifference = difference\n        nextFlag = True\n        resultPiece = min([sumOfPiece1, sumOfPiece2, sumOfPiece3])\n    if not nextFlag:\n        break\nprint(resultPiece)"
  },
  {
    "language": "Python",
    "code": "def d(p, q):\n    return pos[p] - pos[q]\n\ndef solve():\n    p0, p1, p2 = 0, 0, 0\n    best = 0\n    fail = False\n    while p0 < N:\n        if fail:\n            p0 += 1\n            # p2????±???????\n            while d(p2, p1) > d(p1, p0) and p2 > p1:\n                p2 -= 1\n            fail = False\n        # p1????±???????\n        if p1 <= p0: p1 = p0 + 1\n        while d(p1, p0) <= best and p1 - p0 < N:\n            p1 += 1\n        if d(p1, p0) <= best:\n            fail = True\n            continue\n        # p2????±???????\n        if p2 <= p1: p2 = p1 + 1\n        while d(p2,p1) < d(p1, p0) and p2 - p0 < N:\n            p2 += 1\n        if d(p2, p1) < d(p1, p0):\n            fail = True\n            continue\n        # check\n        if L - d(p2, p0) >= d(p1, p0):\n            best = d(p1, p0)\n            if best >= L//3:\n                return best\n        else:\n            fail = True\n    return best\n\nN = int(input())\nA = [0] * N\nL = 0\nfor i in range(N):\n    A[i] = int(input())\n    L += A[i]\npos = [0] * (2*N)\nfor i in range(1, 2*N):\n    pos[i] = pos[i-1] + A[(i-1)%N]\n\nprint(solve())"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nA = [int(input()) for _ in range(N)]\ntotal = sum(A)\nA = A + A\n\ndef check(next_piece, piece_size):\n    for i in range(N):\n        ni = next_piece[i]\n        if ni == -1: continue\n        if piece_size[i] >= total: continue\n\n        ni %= N\n        nni = next_piece[ni]\n        if nni == -1: continue\n        if total - piece_size[i] - piece_size[ni] >= mid:\n            return True\n    return False\n\ndef tow_pointers(mid):\n    # しゃくとり法でインデックスの左側を全探索しつつ、合計がmid以上になる最小区間がどこまでかを求める\n    # next_piece[i] := iから計算した合計がmid以上になる最小区間の終端インデックス\n    # piece_size[i] := iから計算した合計がmid以上になる最小区間の終端インデックスまでの合計値\n    next_piece = [-1] * N\n    piece_size = [-1] * N\n    right, amount = 0, 0\n    for left in range(N):\n        while right < N * 2 and amount < mid:\n            amount += A[right]\n            right += 1\n        if amount >= mid:\n            # amoutがmid以上の場合、それぞれの記録用配列に値を格納する\n            next_piece[left] = right\n            piece_size[left] = amount\n        # ここの役割がわかんね、両方共なんだか必要に見えなくもない\n        amount -= A[left]\n    return next_piece, piece_size\n\n# 二部探索\nlow, high = 0, 1 << 60\nwhile high - low > 1:\n    mid = low + (high - low) // 2\n    next_piece, piece_size = tow_pointers(mid)\n    if check(next_piece, piece_size):\n        low = mid\n    else:\n        high = mid\n\nprint(low)\n\n\n"
  },
  {
    "language": "Python",
    "code": "def checksmallest(edi,Clist,partS):\n    #rotate Alist so that sti is 0\n    Blist=Clist[edi:]\n    m=len(Blist)\n    BS=sum(Blist)\n    head=0\n    tail=m\n    body=m/2\n    while(head!=body and tail!=body):\n        left=sum(Blist[0:body])\n        right=sum(Blist[body:m])\n        #print partS,left,right\n        if min(right,left)>=partS:\n            return True\n        else:\n            if left>=right:\n                tail=body\n                body=(head+tail)/2\n            else:\n                head=body\n                body=(head+tail)/2\n    return False\n\n\nN=int(raw_input())\nAlist=[]\nfor i in range(N):\n    Alist.append(int(raw_input()))\nAsum=sum(Alist)\n\nsmallest=0\n\nfor sti in range(N):\n    #rotate so that sti=0\n    Clist=Alist[sti:]+Alist[:sti]\n    for edi in range(1,N+1):\n        partS=sum(Clist[:edi])\n        if smallest<partS and partS<=Asum/3:\n            #print sti,edi,partS\n            if checksmallest(edi,Clist,partS):\n                smallest=partS\n                \nprint smallest"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef min(a,b,c):\n    if a<=b and a<=c:\n        return a\n    elif b<=c:\n        return b\n    else:\n        return c\n\nN=int(input())\nlist=[int(input())]\nfor i in range(1,N):\n    list.append(int(input())+list[-1])\n\n\na=combinations(range(0,N),3)\n\nmax_of_minimumsize=0\n\nfor i in a:\n    cut1=i[0]\n    cut2=i[1]\n    cut3=i[2]\n\n    piece1=list[cut1]+list[-1]-list[cut3]\n    piece2=list[cut2]-list[cut1]\n    piece3=list[cut3]-list[cut2]\n    minpiece=min(piece1,piece2,piece3)\n\n    if max_of_minimumsize<=minpiece:\n        max_of_minimumsize=minpiece\n\nprint(max_of_minimumsize)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(input()) for _ in range(n)]\nsm = sum(a)\ntgt = sm//3\n\ni = 0\nans = 0\nllow = 0\nlmid = 0\nlhigh = 0\nltemp = 0\nrlow = 0\nrmid = 0\nrhigh = 0\nrtemp = 1\ntempsum = 0\n\nwhile rmid <= tgt:\n    rmid += a[rtemp]\n    rtemp += 1\nrlow = rmid - a[rtemp-1]\nrhigh = rmid + a[rtemp]\n\nwhile lmid <= tgt:\n    lmid += a[ltemp]\n    ltemp -= 1\nllow = lmid - a[ltemp+1]\nlhigh = lmid + a[ltemp]\nltemp += 1\n\nans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\ntempsum += a[i]\ni += 1\n\nwhile tempsum <= tgt:\n    lmid += a[i]\n    rmid -= a[i]\n\n    while rmid <= tgt:\n        rmid += a[rtemp]\n        rtemp += 1\n    rlow = rmid - a[rtemp-1]\n    rhigh = rmid + a[rtemp]\n\n    while lmid >= tgt:\n        lmid -= a[ltemp]\n        ltemp += 1\n    llow = lmid - a[ltemp]\n    lhigh = lmid + a[ltemp-1]\n\n    ans = max(ans,min(llow,rlow,sm-llow-rlow),min(llow,rhigh,sm-llow-rhigh),\n     min(lhigh,rlow,sm-lhigh-rlow),min(lhigh,rhigh,sm-lhigh-rhigh),\n     min(llow,rmid,sm-llow-rmid),min(lmid,rmid,sm-lmid-rmid),\n     min(lhigh,rmid,sm-lhigh-rmid),min(lmid,rlow,sm-lmid-rlow),min(lmid,rhigh,sm-lmid-rhigh))\n\n    tempsum += a[i]\n    i += 1\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=input()\na=[]\nfor i in range(n):\n    a.append(input())\ntmp_out=0\nfor i in range(1, n-2):\n    b=[0,0,0]\n    for ii in range(i):\n        b[0] += a[ii]\n\n    for j in range(i+1, n-1):\n        for jj in range(i, j):\n            b[1] += a[jj]\n        for jj in range(j+1, n):\n            b[2] += a[jj]\n\n    tmp_out=max(tmp_out, min(b))\n\nprint tmp_out"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\nmod util {\n    use std::fmt::Debug;\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[allow(dead_code)]\npub const INF: u64 = 1 << 60;\n\nfn sum_range(l: usize, r: usize, csum: &[u64]) -> u64 {\n    if l > r {\n        csum[r] + csum.last().unwrap() - csum[l]\n    } else {\n        csum[r] - csum[l]\n    }\n}\n\nfn solve() {\n    let n = get!(usize);\n    let xs = get!(u64; n);\n\n    let mut l = 1;\n    let mut r = INF;\n\n    let mut csum = vec![0];\n    let mut t = 0;\n    for &x in &xs {\n        t += x;\n        csum.push(t);\n    }\n\n    while l != r {\n        let mid = (l + r + 1) / 2;\n\n        let mut b = 0;\n        let mut c = 0;\n        let mut ok = false;\n\n        for a in 0..n {\n            while (b + 1) % (n + 1) != a && sum_range(a, b, &csum) < mid {\n                b = (b + 1) % (n + 1);\n            }\n\n            if sum_range(a, b, &csum) < mid {\n                ok = false;\n                break;\n            }\n\n            if a > b {\n                if c >= a || c <= b {\n                    c = (b + 1) % (n + 1);\n                }\n            } else {\n                if c >= a && c <= b {\n                    c = (b + 1) % (n + 1);\n                }\n            }\n\n            while (c + 1) % (n + 1) != a && sum_range(b, c, &csum) < mid {\n                c = (c + 1) % (n + 1);\n            }\n\n            if sum_range(a, b, &csum) >= mid && sum_range(b, c, &csum) >= mid\n                && sum_range(c, a, &csum) >= mid\n            {\n                ok = true;\n                break;\n            }\n        }\n\n        if ok {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n\n    println!(\"{}\", l);\n}\n\n"
  }
]