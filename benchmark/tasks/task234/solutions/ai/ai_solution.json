[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x;\n    double l;\n} Anchor;\n\ndouble compute_max_height(Anchor anchors[], int n) {\n    double low = 0.0;\n    double high = 0.0;\n    for (int i = 0; i < n; i++) {\n        if (anchors[i].l > high) {\n            high = anchors[i].l;\n        }\n    }\n\n    while (high - low > 1e-8) {\n        double mid = (low + high) / 2;\n        double total = 0.0;\n        for (int i = 0; i < n; i++) {\n            double dx = fabs(anchors[i].x);\n            if (mid > anchors[i].l) {\n                total = 1e20;\n                break;\n            }\n            double r = sqrt(anchors[i].l * anchors[i].l - mid * mid);\n            total += dx / r;\n        }\n        if (total < 1.0) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return (low + high) / 2;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Anchor anchors[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &anchors[i].x, &anchors[i].l);\n        }\n        double max_height = compute_max_height(anchors, n);\n        printf(\"%.6f\\n\", max_height);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BalloonHeight {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            double[] anchors = new double[n];\n            double[] lengths = new double[n];\n            \n            for (int i = 0; i < n; i++) {\n                anchors[i] = scanner.nextDouble();\n                lengths[i] = scanner.nextDouble();\n            }\n            \n            System.out.printf(\"%.2f%n\", solve(n, anchors, lengths));\n        }\n        \n        scanner.close();\n    }\n    \n    static double solve(int n, double[] anchors, double[] lengths) {\n        double low = 0, high = 1000;\n        \n        while (high - low > 1e-5) {\n            double mid = (low + high) / 2;\n            \n            if (canReachHeight(mid, n, anchors, lengths)) {\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n        \n        return low;\n    }\n    \n    static boolean canReachHeight(double height, int n, double[] anchors, double[] lengths) {\n        for (int i = 0; i < n; i++) {\n            double dx = anchors[i];\n            double dy = height;\n            double remainingLength = lengths[i];\n            \n            if (Math.sqrt(dx * dx + dy * dy) > remainingLength) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:13:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble distance(Point a, Point b) {\n    return hypot(a.x - b.x, a.y - b.y);\n}\n\ndouble compute_max_height(int n, const vector<double>& x, const vector<double>& l) {\n    double low = 0, high = 1e18;\n    for (int iter = 0; iter < 100; ++iter) {\n        double mid = (low + high) / 2;\n        Point balloon(0, mid);\n        bool possible = true;\n        for (int i = 0; i < n; ++i) {\n            Point anchor(x[i], 0);\n            if (distance(balloon, anchor) > l[i]) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    while (cin >> n, n) {\n        vector<double> x(n), l(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> l[i];\n        }\n        double max_height = compute_max_height(n, x, l);\n        cout << fixed << setprecision(6) << max_height << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_ROPES 1000\n#define EPS 1e-5\n\ndouble compute_max_height(int n, double anchors[], double lengths[]) {\n    double low = 0, high = 1e9;\n    \n    while (high - low > EPS) {\n        double mid = (low + high) / 2.0;\n        int valid = 1;\n        \n        for (int i = 0; i < n; i++) {\n            double dx = anchors[i];\n            double rope_length = lengths[i];\n            double max_height = sqrt(rope_length * rope_length - dx * dx);\n            \n            if (max_height < mid) {\n                valid = 0;\n                break;\n            }\n        }\n        \n        if (valid) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int dataset = 1; dataset <= datasets; dataset++) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        double anchors[MAX_ROPES], lengths[MAX_ROPES];\n        \n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &anchors[i], &lengths[i]);\n        }\n        \n        double max_height = compute_max_height(n, anchors, lengths);\n        printf(\"Dataset %d: %.5lf\\n\", dataset, max_height);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\ndouble calculateMaxHeight(int n, vector<pair<double, double>>& ropes) {\n    double left = 0, right = 1e9;\n    \n    for (int iter = 0; iter < 100; iter++) {\n        double mid = (left + right) / 2.0;\n        bool possible = true;\n        \n        vector<pair<double, double>> intervals;\n        for (auto& rope : ropes) {\n            double x = rope.first, len = rope.second;\n            \n            if (len < mid) {\n                possible = false;\n                break;\n            }\n            \n            double dx = sqrt(len * len - mid * mid);\n            intervals.push_back({x - dx, x + dx});\n        }\n        \n        if (!possible) {\n            right = mid;\n            continue;\n        }\n        \n        sort(intervals.begin(), intervals.end());\n        \n        double currRight = intervals[0].first;\n        for (auto& interval : intervals) {\n            if (interval.first > currRight) {\n                possible = false;\n                break;\n            }\n            currRight = max(currRight, interval.second);\n        }\n        \n        if (possible) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    \n    cout << fixed << setprecision(5);\n    \n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<pair<double, double>> ropes(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ropes[i].first >> ropes[i].second;\n        }\n        \n        double maxHeight = calculateMaxHeight(n, ropes);\n        cout << maxHeight << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:13:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class BalloonHeight {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextInt()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            double[] x = new double[n];\n            double[] l = new double[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = scanner.nextDouble();\n                l[i] = scanner.nextDouble();\n            }\n            \n            double low = 0.0;\n            double high = 1e10;\n            \n            for (int iter = 0; iter < 100; iter++) {\n                double mid = (low + high) / 2;\n                boolean possible = true;\n                double left = -1e20;\n                double right = 1e20;\n                \n                for (int i = 0; i < n; i++) {\n                    if (l[i] < mid) {\n                        possible = false;\n                        break;\n                    }\n                    double dx = Math.sqrt(l[i] * l[i] - mid * mid);\n                    double a = x[i] - dx;\n                    double b = x[i] + dx;\n                    \n                    if (a > right || b < left) {\n                        possible = false;\n                        break;\n                    }\n                    left = Math.max(left, a);\n                    right = Math.min(right, b);\n                }\n                \n                if (possible) {\n                    low = mid;\n                } else {\n                    high = mid;\n                }\n            }\n            \n            System.out.printf(\"%.6f\\n\", low);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:14:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_balloon_height(datasets):\n    import math\n\n    def max_height_for_rope(x, length):\n        return math.sqrt(length ** 2 - x ** 2)\n\n    results = []\n    for dataset in datasets:\n        num_ropes = dataset[0]\n        positions_and_lengths = dataset[1]\n        left, right = 0, min(length for _, length in positions_and_lengths)\n        \n        while right - left > 0.00001:\n            mid = (left + right) / 2\n            can_reach = True\n            \n            for x, length in positions_and_lengths:\n                if length < math.sqrt(x ** 2 + mid ** 2):\n                    can_reach = False\n                    break\n\n            if can_reach:\n                left = mid\n            else:\n                right = mid\n\n        results.append(left)\n\n    return results\n\n# Example usage:\ndatasets = [\n    (3, [(3, 5), (5, 7), (9, 11)]),\n    (2, [(2, 4), (4, 8)])\n]\n\nprint(max_balloon_height(datasets))",
    "timestamp": "2025-08-13 03:01:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class BalloonHeight {\n    \n    public static double getMaxHeight(int n, double[] x, double[] l) {\n        double left = 0;\n        double right = Double.MAX_VALUE;\n        double mid;\n        \n        while (right - left > 1e-7) {\n            mid = (left + right) / 2;\n            boolean possible = true;\n            \n            for (int i = 0; i < n; i++) {\n                double maxHorizontalDistance = Math.sqrt(l[i] * l[i] - mid * mid);\n                if (mid > l[i] || Math.abs(x[i]) > maxHorizontalDistance) {\n                    possible = false;\n                    break;\n                }\n            }\n            \n            if (possible) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return left;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while(scanner.hasNext()) {\n            int n = scanner.nextInt();\n            double[] x = new double[n];\n            double[] l = new double[n];\n            \n            for (int i = 0; i < n; i++) {\n                x[i] = scanner.nextDouble();\n                l[i] = scanner.nextDouble();\n            }\n            \n            double maxHeight = getMaxHeight(n, x, l);\n            System.out.printf(\"%.5f\\n\", maxHeight);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 03:01:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble findMaxHeight(int n, double anchors[][2], double lengths[]) {\n    double low = 0, high = 1e9, mid;\n    const double epsilon = 0.00001;\n    \n    while (high - low > epsilon) {\n        mid = (low + high) / 2;\n        int canReach = 1;\n        for (int i = 0; i < n; ++i) {\n            double dx = anchors[i][0];\n            double dy = mid;\n            double distance = sqrt(dx * dx + dy * dy);\n            if (distance > lengths[i]) {\n                canReach = 0;\n                break;\n            }\n        }\n        \n        if (canReach) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        double anchors[n][2];\n        double lengths[n];\n        \n        for (int i = 0; i < n; ++i) {\n            scanf(\"%lf %lf %lf\", &anchors[i][0], &anchors[i][1], &lengths[i]);\n        }\n        \n        printf(\"%.5lf\\n\", findMaxHeight(n, anchors, lengths));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 03:01:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_balloon_height(ropes):\n    def max_height(rope_lengths, anchor_positions):\n        max_h = 0\n        for h in range(1, 10001):\n            valid = True\n            for length, anchor in zip(rope_lengths, anchor_positions):\n                if ((h * h + anchor * anchor) > length * length):\n                    valid = False\n                    break\n            if not valid:\n                return max(0, h - 1)\n            max_h = h\n        return max_h\n\n    n = int(input())\n    while n > 0:\n        ropes = []\n        anchors = []\n        for _ in range(n):\n            a, l = map(int, input().split())\n            anchors.append(a)\n            ropes.append(l)\n        \n        result = max_height(ropes, anchors)\n        print(f\"{result:.5f}\")\n        \n        n = int(input())\n\nsolve_balloon_height([])",
    "timestamp": "2025-08-13 03:01:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        n = int(input[ptr])\n        ptr += 1\n        if n == 0:\n            break\n        anchors = []\n        for _ in range(n):\n            x = float(input[ptr])\n            y = float(input[ptr+1])\n            l = float(input[ptr+2])\n            ptr += 3\n            anchors.append((x, y, l))\n        \n        low = 0.0\n        high = 1e20\n        \n        for _ in range(100):\n            mid = (low + high) / 2\n            ok = True\n            # Check if all ropes can reach (0, mid)\n            for x, y, l in anchors:\n                required = math.sqrt(x**2 + (mid - y)**2)\n                if required > l + 1e-8:\n                    ok = False\n                    break\n            if ok:\n                low = mid\n            else:\n                high = mid\n        print(\"{0:.6f}\".format(low))\n\nsolve()",
    "timestamp": "2025-08-13 03:01:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n\nbool canLift(double height, const std::vector<std::pair<double, double>>& anchors, const std::vector<double>& lengths) {\n    for (size_t i = 0; i < anchors.size(); ++i) {\n        double anchorX = anchors[i].first;\n        double anchorY = anchors[i].second;\n        double length = lengths[i];\n        double requiredLength = sqrt(anchorX * anchorX + (anchorY - height) * (anchorY - height));\n        if (requiredLength > length) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble findMaxHeight(std::vector<std::pair<double, double>>& anchors, std::vector<double>& lengths) {\n    double low = 0;\n    double high = 1e9;\n    double mid;\n    while (high - low > 1e-9) {\n        mid = (low + high) / 2;\n        if (canLift(mid, anchors, lengths)) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nint main() {\n    int numberOfDatasets;\n    std::cin >> numberOfDatasets;\n\n    while (numberOfDatasets--) {\n        int numberOfRopes;\n        std::cin >> numberOfRopes;\n\n        std::vector<std::pair<double, double>> anchors(numberOfRopes);\n        std::vector<double> lengths(numberOfRopes);\n\n        for (int i = 0; i < numberOfRopes; ++i) {\n            double x, y, length;\n            std::cin >> x >> y >> length;\n            anchors[i] = {x, y};\n            lengths[i] = length;\n        }\n\n        double maxHeight = findMaxHeight(anchors, lengths);\n        std::cout << std::fixed << std::setprecision(5) << maxHeight << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:09:17"
  }
]